<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="59f5f5ff16e9a38088c4dc6203d56f4f8fc6a9aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-rtsopts&lt;/code&gt; has no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意，当与&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;一起使用时， &lt;code&gt;-rtsopts&lt;/code&gt; 无效；有关详细信息，请参见&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce579c6f316db1c83cacd820fffea2c995a62db3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-with-rtsopts&lt;/code&gt; has no effect when used with &lt;code&gt;-no-hs-main&lt;/code&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意 &lt;code&gt;-with-rtsopts&lt;/code&gt; 与 &lt;code&gt;-no-hs-main&lt;/code&gt; 一起使用时无效；有关详细信息，请参见&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3251b2749b31476313c89aa83d9865be6457e1bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; has no concept of fairness, and there is no guarantee that threads blocked in &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; will be unblocked in the same order; in fact they will all be unblocked at the same time and will fight over the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;. Hence &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is not suitable if you expect there to be a high number of threads contending for the resource. However, like other STM abstractions, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is composable.</source>
          <target state="translated">注意， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 没有公平性的概念，不能保证在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; 中阻塞的线程将以相同的顺序解除阻塞。实际上，它们都将同时 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 并会为TSem争战。因此，如果您期望有大量线程争用资源，则 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 不适合。但是，与其他STM抽象一样， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 是可组合的。</target>
        </trans-unit>
        <trans-unit id="23d023ee2a96a8f414c4d59de19543cf5936dac9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and friends &lt;em&gt;do not&lt;/em&gt; have a similar default, because there is no exception handler in this case. Don't use &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; for recovering from an asynchronous exception.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 和friends &lt;em&gt;没有&lt;/em&gt;类似的默认值，因为在这种情况下没有异常处理程序。不要使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从异步异常中恢复。</target>
        </trans-unit>
        <trans-unit id="2718dae009fe5e3d1238b1c135ae52c90ac37837" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are a bit verbose, but quite versatile. Here is an example of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for combined HTML escaping and UTF-8 encoding. It exploits that the escaped character with the maximal Unicode codepoint is '&amp;gt;'.</source>
          <target state="translated">注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 有点冗长，但是用途广泛。这是一个结合HTML转义和UTF-8编码的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 示例。它利用最大Unicode代码点的转义字符为'&amp;gt;'。</target>
        </trans-unit>
        <trans-unit id="cde3b09d583614c69aacef3bde117f6bdd3d0e24" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="2ee6deeaabf24f4412e1e49868879a0b5b1aa1c9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Complex Float&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt; 的实例继承了type参数的不足之处。例如， &lt;code&gt;Complex Float&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="3e1f90e9e322b989e73d82fdede82115af771f84" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dced2e98ed0e357e8b533e5a5a89a9d764b8df7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dedd1659c7efcc5ad810d0e5c4b39237ba9eb03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60f7565d417c50efc94986aa99cb5f4a947f5ff6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 的实例从type参数的实例继承缺陷。例如， &lt;code&gt;Ratio Natural&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="7cefd424b19607d5edc1403e68699fc8f6d2f620" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (in the guise of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;) can still occur in a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; representation, namely when the datatype has a field that does not mention the parameter.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; （以 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 为幌子）仍可以以 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 表示形式出现，即，当数据类型的字段中未提及参数时。</target>
        </trans-unit>
        <trans-unit id="281ca52e047c00d45cb2f86224fe53a9a4fae794" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a858cff92b21869646f30a2b371df6ee5495052" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="fc2f4f0bfb855f7375943aa12d1fb8ac219a3580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="6dbd9a25c551eff23fa22c53698220086818ffcf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd1e7ed5d4e140984d3791f7195f3b569e53a3a5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3220254f0cec09ffeb96b93db4b6d62483e447b2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e52e647e2604f5fb2a960fb656ed98c28cb82a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; does not suffice for this purpose due to &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac #5041&lt;/a&gt;.</source>
          <target state="translated">请注意，由于&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac＃5041&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; 不足以满足此目的。</target>
        </trans-unit>
        <trans-unit id="08f4018cb49ca32078d9a1bef08f427eb4907a21" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 的实例从type参数的实例继承缺陷。例如， &lt;code&gt;Ratio Natural&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="e88d411cc968059e325ae13439252f0afd371b01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="1e81757f506803c58656ee3360e5e3fcdb790671" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="692875f553a19ed51b447480be26cc2da0a377bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 将文字字符串写入文件。要像 &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样写入任何可打印类型的值，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 函数首先将值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="82ee7c2d72b3eb91473ef9443731d0f34073a559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 将文字字符串写入文件。要像 &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样写入任何可打印类型的值，请使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 函数首先将值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="b7939772f8f7e35e3f9e1df2549a55f3569ee2cb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;F0&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F2&lt;/code&gt;, &lt;code&gt;FD1&lt;/code&gt;, and &lt;code&gt;FD2&lt;/code&gt; all have identical standalone kind signatures. The arity is inferred from the type family header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5d841ba3035a60d47bde6683188e551f1ba64a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt; or &lt;code&gt;std_out&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">请注意，通过CreateProcess记录为 &lt;code&gt;std_in&lt;/code&gt; 或 &lt;code&gt;std_out&lt;/code&gt; 提供的 &lt;code&gt;Handle&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="146678c0e776f2ff851c7e2c8dcebc022186f041" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;Handle&lt;/code&gt; s提供了 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 通过 &lt;code&gt;UseHandle&lt;/code&gt; 构造函数将调用此函数关闭。这并不总是所需的行为。如果您希望在生成子进程之后使 &lt;code&gt;Handle&lt;/code&gt; 保持打开状态，请改用 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 。所有创建的 &lt;code&gt;Handle&lt;/code&gt; 最初都处于文本模式；如果需要它们处于二进制模式，则使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0bc50405f92753187a855ca32c150ffebfb1ca1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">请注意，通过CreateProcess记录为 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 提供的 &lt;code&gt;Handle&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="fb75a50ee8a25d92207e02df9efd12ab2bbd9b08" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\case&lt;/code&gt; starts a layout, so you can write</source>
          <target state="translated">请注意 &lt;code&gt;\case&lt;/code&gt; 开始布局，因此您可以编写</target>
        </trans-unit>
        <trans-unit id="ef8c98fb1e9ccb919f4d179a7222663f9bc06990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; is not overloaded; the &lt;code&gt;Eq&lt;/code&gt; constraint arising from the use of &lt;code&gt;==&lt;/code&gt; is discharged by the pattern match on &lt;code&gt;T1&lt;/code&gt; and similarly the &lt;code&gt;Show&lt;/code&gt; constraint arising from the use of &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;f&lt;/code&gt; 没有过载。使用 &lt;code&gt;==&lt;/code&gt; 引起的 &lt;code&gt;Eq&lt;/code&gt; 约束由 &lt;code&gt;T1&lt;/code&gt; 上的模式匹配释放，并且类似地，由于使用 &lt;code&gt;show&lt;/code&gt; 产生 &lt;code&gt;Show&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="01a09441c6e85b11dd8ac3855c0f8d219030d13a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d5971cd304a24fd7e0c3cb761f12d88c0c5300" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ghc -M&lt;/code&gt; 需要在依赖关系图中为每个模块找到一个&lt;em&gt;源文件&lt;/em&gt;，以便它可以解析导入声明并遵循依赖关系。因此，任何没有源文件的预编译模块都必须属于包&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9ad10b105a7bebae4f8165fa8685e319e4cd138" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;hTestEquality&lt;/code&gt; takes two arguments where the type variable &lt;code&gt;t&lt;/code&gt; is applied to types of different kinds. That type variable must then be polykinded. Accordingly, the kind of &lt;code&gt;HTestEquality&lt;/code&gt; (the class) is &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt;, a higher-rank kind.</source>
          <target state="translated">请注意， &lt;code&gt;hTestEquality&lt;/code&gt; 带有两个参数，其中类型变量 &lt;code&gt;t&lt;/code&gt; 适用于不同类型的类型。然后必须对该类型变量进行多类化。因此， &lt;code&gt;HTestEquality&lt;/code&gt; 的类型（该类）是 &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt; k。k- &amp;gt; Type）-&amp;gt; Constraint，一种较高等级的类型。</target>
        </trans-unit>
        <trans-unit id="d49f48cab2336da3b33335456da6ac1c62fd042c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; tests whether all the keys in &lt;code&gt;m1&lt;/code&gt; are also keys in &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; 测试 &lt;code&gt;m1&lt;/code&gt; 中的所有键是否也是 &lt;code&gt;m2&lt;/code&gt; 中的键。</target>
        </trans-unit>
        <trans-unit id="8d87919fed4910f020e65cc52017097a20305800" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;it&lt;/code&gt; is shadowed by the new value each time you evaluate a new expression, and the old value of &lt;code&gt;it&lt;/code&gt; is lost.</source>
          <target state="translated">请注意， &lt;code&gt;it&lt;/code&gt; 是由新的值每次评估新的表达时间的阴影，和旧的价值 &lt;code&gt;it&lt;/code&gt; 将丢失。</target>
        </trans-unit>
        <trans-unit id="8965b5ad7e3a3d0f07f953f01997900513413179" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;k2&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;, and that &lt;code&gt;k&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;. Also, note that &lt;code&gt;k2&lt;/code&gt; is written here in braces. As explained with &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called &lt;em&gt;inferred&lt;/em&gt; variables.) Such variables are written in braces with &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">请注意， &lt;code&gt;k2&lt;/code&gt; 放在 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;，而 &lt;code&gt;k&lt;/code&gt; 放在 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。另外，请注意， &lt;code&gt;k2&lt;/code&gt; 用大括号写在这里。如有关&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; 的&lt;/a&gt;说明（&lt;a href=&quot;#inferred-vs-specified&quot;&gt;推断的vs.指定的类型变量&lt;/a&gt;）所述，GHC泛化但未写在原始程序中的类型和种类变量不适用于可见类型应用程序。（这些称为&lt;em&gt;推断&lt;/em&gt;变量。）在启用&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; 的情况下,将&lt;/a&gt;这些变量写在括号中。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a55de5915599f1590abb3356c8fe6ece583ed02" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings do not automatically print the value bound, unlike monadic bindings.</source>
          <target state="translated">请注意，与单键绑定不同， &lt;code&gt;let&lt;/code&gt; 绑定不会自动打印值绑定。</target>
        </trans-unit>
        <trans-unit id="5f999ecaeb1e7a69b4163c053a67ca1cf1c9ff63" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mkName&lt;/code&gt; may be used with qualified names:</source>
          <target state="translated">请注意， &lt;code&gt;mkName&lt;/code&gt; 可以与限定名称一起使用：</target>
        </trans-unit>
        <trans-unit id="01c07aa245695205a32a04f4daab1815beac9b5c" translate="yes" xml:space="preserve">
          <source>Note that GHC can only follow dependencies if it has the source file available, so if your program includes a module for which there is no source file, even if you have an object and an interface file for the module, then GHC will complain. The exception to this rule is for package modules, which may or may not have source files.</source>
          <target state="translated">需要注意的是,GHC只有在有源文件的情况下才能跟踪依赖关系,所以如果你的程序包含了一个没有源文件的模块,即使你有该模块的对象和接口文件,GHC也会抱怨。这个规则的例外是包模块,它可能有也可能没有源文件。</target>
        </trans-unit>
        <trans-unit id="628959edf33f1bf4af75378e5117a34fc0ac8086" translate="yes" xml:space="preserve">
          <source>Note that a &quot;minute&quot; of &lt;code&gt;DiffTime&lt;/code&gt; is simply 60 SI seconds, rather than a minute of civil time. Use &lt;code&gt;NominalDiffTime&lt;/code&gt; to work with civil time, ignoring any leap seconds.</source>
          <target state="translated">请注意， &lt;code&gt;DiffTime&lt;/code&gt; 的&amp;ldquo;分钟&amp;rdquo; 仅为60 SI秒，而不是一分钟的民用时间。使用 &lt;code&gt;NominalDiffTime&lt;/code&gt; 来处理民用时间，而忽略任何seconds秒。</target>
        </trans-unit>
        <trans-unit id="db63214ed45116be549d0295c81ce0bf585bc000" translate="yes" xml:space="preserve">
          <source>Note that a given &lt;code&gt;mdo&lt;/code&gt; expression can cause the creation of multiple &lt;code&gt;rec&lt;/code&gt; blocks. If there are no recursive dependencies, &lt;code&gt;mdo&lt;/code&gt; will introduce no &lt;code&gt;rec&lt;/code&gt; blocks. In this latter case an &lt;code&gt;mdo&lt;/code&gt; expression is precisely the same as a &lt;code&gt;do&lt;/code&gt; expression, as one would expect.</source>
          <target state="translated">请注意，给定的 &lt;code&gt;mdo&lt;/code&gt; 表达式可以导致创建多个 &lt;code&gt;rec&lt;/code&gt; 块。如果没有递归依赖性，则 &lt;code&gt;mdo&lt;/code&gt; 将不引入 &lt;code&gt;rec&lt;/code&gt; 块。在后一种情况下， &lt;code&gt;mdo&lt;/code&gt; 表达式与 &lt;code&gt;do&lt;/code&gt; 表达式完全相同，正如人们所期望的那样。</target>
        </trans-unit>
        <trans-unit id="edb8824abf3adc676b8fc9d4d2a15be4648aabba" translate="yes" xml:space="preserve">
          <source>Note that after splitting the string at newline characters, the last part of the string is considered a line even if it doesn't end with a newline. For example,</source>
          <target state="translated">请注意,在换行符处拆分字符串后,即使字符串的最后部分没有以换行符结束,也会被视为一行。例如</target>
        </trans-unit>
        <trans-unit id="e48d232edc1ec00a99a6fd6c27346f29f36049ef" translate="yes" xml:space="preserve">
          <source>Note that after the closing brace, GHCi knows that the current statement is finished, so no empty line is required.</source>
          <target state="translated">需要注意的是,在结束括号之后,GHCi知道当前语句已经结束,所以不需要空行。</target>
        </trans-unit>
        <trans-unit id="629c79c2f8b660ab85b6013a5e3159a0a225a4a6" translate="yes" xml:space="preserve">
          <source>Note that although the above translation suggests that &lt;code&gt;let&lt;/code&gt;-bound variables like &lt;code&gt;z&lt;/code&gt; must be monomorphic, the actual translation produces Core, so polymorphic variables are allowed.</source>
          <target state="translated">请注意，尽管以上翻译建议 &lt;code&gt;let&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 这样的让绑定变量必须是单态的，但实际的翻译会生成Core，因此允许使用多态变量。</target>
        </trans-unit>
        <trans-unit id="629818198328cd462665ec73736ee33ba93fceb4" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; is often absolutely essential. Consider the rose-tree example</source>
          <target state="translated">请注意，明确的 &lt;code&gt;forall&lt;/code&gt; 通常是绝对必要的。考虑玫瑰树的例子</target>
        </trans-unit>
        <trans-unit id="92e28e232c8219184dccc4e81df68cd45a16bf4c" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; must appear at the front of the type signature and is not permitted to appear nested within the type, as in the following (erroneous) examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fedd4b9525d691022adec17bbc58c0482f1424f" translate="yes" xml:space="preserve">
          <source>Note that any multi-parameter constraints &lt;code&gt;(D a b)&lt;/code&gt; or &lt;code&gt;(D [a] Int)&lt;/code&gt; do not participate in the process (either to help or to hinder); but they must of course be soluble once the defaulting process is complete.</source>
          <target state="translated">请注意，任何多参数约束 &lt;code&gt;(D a b)&lt;/code&gt; 或 &lt;code&gt;(D [a] Int)&lt;/code&gt; 都不参与该过程（帮助或阻碍）；但是，一旦默认设置完成，它们当然必须是可溶解的。</target>
        </trans-unit>
        <trans-unit id="c67cc7b453618af847cc15ad44d064d4550a5b4a" translate="yes" xml:space="preserve">
          <source>Note that any non-flag arguments are never passed to GHC. An unused non-flag argument will be considered as the name of the program to run. If a GHC flag takes an argument use &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass the argument to GHC. For example, if you want to pass &lt;code&gt;-package foo&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">请注意，任何非标志参数都不会传递给GHC。未使用的非标志参数将被视为要运行的程序的名称。如果GHC标志采用参数，请使用 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 将参数传递给GHC。例如，如果您要将 &lt;code&gt;-package foo&lt;/code&gt; 传递给GHC，请使用以下任一方法：</target>
        </trans-unit>
        <trans-unit id="1d2d4c489f4d5c10bf98bfdb6c95992494ea1737" translate="yes" xml:space="preserve">
          <source>Note that because constraints are just handled as types of a particular kind, this extension allows type constraint synonyms:</source>
          <target state="translated">请注意,由于约束只是作为特定种类的类型来处理,所以这个扩展允许类型约束同义词。</target>
        </trans-unit>
        <trans-unit id="1e70909e8298e18a428bd14a078ccbac8a33b1c3" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is only safe to use, therefore, if the immutable array is never referenced again in this thread, and there is no possibility that it can be also referenced in another thread. If you use an unsafeThaw&lt;em&gt;write&lt;/em&gt;unsafeFreeze sequence in a multi-threaded setting, then you must ensure that this sequence is atomic with respect to other threads, or a garbage collector crash may result (because the write may be writing to a frozen array).</source>
          <target state="translated">请注意，由于可能未复制数组，因此对数组的可变版本进行的任何后续修改都可以与不可变版本共享。因此，如果不可变数组在该线程中不再被引用，并且只有在另一个线程中也可以被引用时，才可以安全使用。如果在多线程设置中使用unsafeThaw &lt;em&gt;写入&lt;/em&gt; unsafeFreeze序列，则必须确保该序列相对于其他线程是原子的，否则可能导致垃圾收集器崩溃（因为该写入可能正在写入冻结的数组）。</target>
        </trans-unit>
        <trans-unit id="312ce308d507158c0dbd1448754583dfb49275af" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is safe to use, therefore, if the mutable version is never modified after the freeze operation.</source>
          <target state="translated">请注意,由于数组可能不会被复制,因此对数组的可变版本的任何后续修改都可能与不可变版本共享。因此,如果在冻结操作后从未修改过可变版本,那么使用该方法是安全的。</target>
        </trans-unit>
        <trans-unit id="cf2145147a60ace311fa33d22d382ca44077b49d" translate="yes" xml:space="preserve">
          <source>Note that calling `breakSubstring x` does some preprocessing work, so you should avoid unnecessarily duplicating breakSubstring calls with the same pattern.</source>
          <target state="translated">请注意,调用 &quot;breakSubstring x &quot;会做一些预处理工作,所以应该避免不必要地重复调用相同模式的breakSubstring。</target>
        </trans-unit>
        <trans-unit id="fc9763765bf9b4fd333d384e2c7f6d48a5f90bb7" translate="yes" xml:space="preserve">
          <source>Note that class instances are always for particular &lt;em&gt;instances&lt;/em&gt; of a data family and never for an entire family as a whole. This is for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of &lt;em&gt;different&lt;/em&gt; instances of a single type family. It would require a form of extensible case construct.</source>
          <target state="translated">请注意，类实例始终用于数据族的特定&lt;em&gt;实例&lt;/em&gt;，而不是整个族的整体。出于本质上相同的原因，我们无法定义一个顶级函数来对单个类型族的&lt;em&gt;不同&lt;/em&gt;实例的数据构造函数执行模式匹配。这将需要一种可扩展的案例构造形式。</target>
        </trans-unit>
        <trans-unit id="3fd26db2c5a937cd006a71ef434cb9a6ac571280" translate="yes" xml:space="preserve">
          <source>Note that command-line options are &lt;em&gt;order-dependent&lt;/em&gt;, with arguments being evaluated from left-to-right. This can have seemingly strange effects in the presence of flag implication. For instance, consider &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fno-specialise&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt;&lt;code&gt;-O1&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fspecialise&lt;/code&gt;&lt;/a&gt;). These two command lines mean very different things:</source>
          <target state="translated">请注意，命令行选项是&lt;em&gt;顺序相关的&lt;/em&gt;，参数是从左到右评估的。在存在标志含义的情况下，这可能会产生看似奇怪的效果。例如，考虑&lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fno-specialise&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt; &lt;code&gt;-O1&lt;/code&gt; &lt;/a&gt;（这意味着&lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fspecialise&lt;/code&gt; &lt;/a&gt;）。这两个命令行的含义非常不同：</target>
        </trans-unit>
        <trans-unit id="76091aaf5e35a41319f5ec500de56fcd89951658" translate="yes" xml:space="preserve">
          <source>Note that deriving &lt;code&gt;Eq&lt;/code&gt; is necessary for the pattern matching to work since it gets translated into an equality comparison.</source>
          <target state="translated">请注意，派生 &lt;code&gt;Eq&lt;/code&gt; 对于模式匹配起作用是必需的，因为它将转换为相等比较。</target>
        </trans-unit>
        <trans-unit id="5e66a3c265c4c5b432263a07a725a136b6324e29" translate="yes" xml:space="preserve">
          <source>Note that due to Haskell's unspecified evaluation order, an expression may throw one of several possible exceptions: consider the expression &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt;. Does the expression throw &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt;, or &lt;code&gt;DivideByZero&lt;/code&gt;?</source>
          <target state="translated">请注意，由于Haskell的评估顺序未指定，表达式可能会引发以下几种可能的异常之一：考虑表达式 &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt; 。表达式是否抛出 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 或 &lt;code&gt;DivideByZero&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a38e6766cff20e461dc54ded66126b634b012173" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="0ef6487a6a1f23d9e6d0eab035203c36999e612c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="718b6ec1eedc7b0e6b0505f3537b21d4d5090824" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="b2e8c03bc2025303c4c75357649bb45ee1572579" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="8bb133570167aeb8235fd7aa64e771323ce317b8" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="b8c80f9a804d45f8387d652852d3f1b319e89bab" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="abaa8283c8c82c454b3f39dc4e8b3b95dea832bf" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="efa258be8dec869f272beb6b3b0719e9c9136d95" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="cc8602ae6c9f5374c5b3e2f4892e8ddead96cf59" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="434b11a6a2c5a23f490c3dca6b67c53a554a0d1b" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="6077357d3de95b1c68b9540f7bddf5fc70a526b4" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="2043553ccd4d376d49787321f94def08da904851" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="194e7c783a359ef09d66938c7b166d817c622581" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="9890f34bd7580f2b47b85fe9349066eb034aa874" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="9dcbc1e84d812484382f7054b4ea09eece714d9c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="20c322bafd53e5e4ac584f0f4c7683ecf396fc66" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="e775258fb33a9c99aae311b322919c0b7003500f" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="1f89c3ca9731aeeb8476c132b53e6e61c23b4594" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="24ad6371739df6cce2c9d49e41a79e67a4549c98" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="59b02bd4bf7fdf2cce1cbde77a7195b31de26236" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="5b8a7de16c8d613620813c9851308e5845856e62" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="c868d72c8e906befa9b0e16299d79ca57971708c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="da59b4a14361d344a87c211c8c8c17fcca4de300" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="96f2507b88b419212359ae0a529d1957a3da8fe1" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="6105c208b7c6f44c6b239700c54851ff6acd9f7c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="9187cd519377bc44a76fe47963badb1dfb10c1de" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="0dc5c80ae44926709a883abad455c22674f3d607" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="7935bc741f62235ae7bf01a48ecac728f0a179e3" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="646e8b4539cacf2e9e9d3ae0b8e3c032a0312c22" translate="yes" xml:space="preserve">
          <source>Note that even with &lt;code&gt;--install-signal-handlers=no&lt;/code&gt;, the RTS interval timer signal is still enabled. The timer signal is either SIGVTALRM or SIGALRM, depending on the RTS configuration and OS capabilities. To disable the timer signal, use the &lt;code&gt;-V0&lt;/code&gt; RTS option (see &lt;code&gt;-V ⟨secs⟩&lt;/code&gt;).</source>
          <target state="translated">请注意，即使使用 &lt;code&gt;--install-signal-handlers=no&lt;/code&gt; ，RTS间隔计时器信号仍然启用。计时器信号可以是SIGVTALRM或SIGALRM，具体取决于RTS配置和OS功能。要禁用计时器信号，请使用 &lt;code&gt;-V0&lt;/code&gt; RTS选项（请参见 &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4432323376182dfbdca3fdc7130f34b9170ab0c0" translate="yes" xml:space="preserve">
          <source>Note that exceptions which are thrown to the current thread are thrown in turn to the thread that is executing the given computation. This ensures there's always a way of killing the forked thread.</source>
          <target state="translated">请注意,向当前线程抛出的异常会反过来抛给正在执行给定计算的线程。这确保了总有办法杀死分叉的线程。</target>
        </trans-unit>
        <trans-unit id="4e7cb7371c58bd222ab2560f3a7d99af3af20d16" translate="yes" xml:space="preserve">
          <source>Note that fixed primitives can be considered as a special case of bounded primitives, and we can lift from fixed to bounded.</source>
          <target state="translated">请注意,固定基元可以看作是有界基元的特例,我们可以从固定提升到有界。</target>
        </trans-unit>
        <trans-unit id="56b0f705789ec7ac7e04637b1063cafb79dc672b" translate="yes" xml:space="preserve">
          <source>Note that for consistency &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Word64&lt;/code&gt;, and &lt;code&gt;Int64&lt;/code&gt; constructor fields are unpacked on 32-bit platforms, even though they are technically larger than a pointer on those platforms.</source>
          <target state="translated">请注意，为了保持一致性， &lt;code&gt;Double&lt;/code&gt; ， &lt;code&gt;Word64&lt;/code&gt; 和 &lt;code&gt;Int64&lt;/code&gt; 构造函数字段在32位平台上解压缩，即使它们在技术上比那些平台上的指针大。</target>
        </trans-unit>
        <trans-unit id="6128c2afaa4b4099fa2f7f80159c3c3eb7d037da" translate="yes" xml:space="preserve">
          <source>Note that for non-C languages (for example C++) &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; directives must be used to get symbols that we can access from Haskell.</source>
          <target state="translated">请注意，对于非C语言（例如C ++），必须使用 &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 指令来获取可从Haskell访问的符号。</target>
        </trans-unit>
        <trans-unit id="250d6d584d95f50004937c03dc209e45f1572a99" translate="yes" xml:space="preserve">
          <source>Note that for scripts and interactive sessions, this is the path to the interpreter (e.g. ghci.)</source>
          <target state="translated">请注意,对于脚本和交互式会话,这是通往解释器的路径(如ghci.)。</target>
        </trans-unit>
        <trans-unit id="2a64a1dfeaac3f04e05a2dfa765d6f00da1d204a" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;package-db&lt;/code&gt; directive, if a relative path is given it must be relative to the location of the package environment file.</source>
          <target state="translated">请注意，对于 &lt;code&gt;package-db&lt;/code&gt; 指令，如果给出了相对路径，则它必须相对于软件包环境文件的位置。</target>
        </trans-unit>
        <trans-unit id="96e9f8d44f9309d061a4735a30dbfcf393329303" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.</source>
          <target state="translated">请注意,为了在子弹(4)和(5)中进行注入性检查,GHC使用了一种特殊的统一算法变体,将类型族应用视为可能与任何东西统一。</target>
        </trans-unit>
        <trans-unit id="ffa639807aa32c333508357828c548fb4190cf20" translate="yes" xml:space="preserve">
          <source>Note that foreign calls made by different Haskell threads may execute in &lt;em&gt;parallel&lt;/em&gt;, even when the &lt;code&gt;+RTS -N&lt;/code&gt; flag is not being used (&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;). The &lt;code&gt;-N ⟨x⟩&lt;/code&gt; flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the &lt;code&gt;+RTS -N&lt;/code&gt; value.</source>
          <target state="translated">请注意，即使未使用 &lt;code&gt;+RTS -N&lt;/code&gt; 标志（&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;SMP并行性的RTS选项&lt;/a&gt;），由不同的Haskell线程进行的外部调用也可能&lt;em&gt;并行&lt;/em&gt;执行。在 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 标志控制的Haskell线程并行执行，但也有可能在任一个时刻在进展中外来呼叫的任意数量，而不管的 &lt;code&gt;+RTS -N&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="e12827f70b05908494f598eac9c4f60068827e87" translate="yes" xml:space="preserve">
          <source>Note that functions marked with &quot;&lt;em&gt;Heavy inlining.&lt;/em&gt;&quot; are forced to be inlined because they must be specialized for concrete encodings, but are rather heavy in terms of code size. We recommend to define a top-level function for every concrete instantiation of such a function in order to share its code. A typical example is the function &lt;code&gt;byteStringHex&lt;/code&gt; from &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;, which is implemented as follows.</source>
          <target state="translated">请注意，标记为&amp;ldquo; &lt;em&gt;Heavy inlining。&lt;/em&gt; &amp;rdquo;的函数被强制内联，因为它们必须专门用于具体编码，但是在代码大小方面相当繁琐。我们建议为该函数的每个具体实例定义一个顶层函数，以共享其代码。一个典型的例子是功能 &lt;code&gt;byteStringHex&lt;/code&gt; 从&lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;，这是如下实现的。</target>
        </trans-unit>
        <trans-unit id="2216bc2850d8b97233a3efc13f854171f19bee87" translate="yes" xml:space="preserve">
          <source>Note that higher optimisation levels cause more cross-module optimisation to be performed, which can have an impact on how much of your program needs to be recompiled when you change something. This is one reason to stick to no-optimisation when developing code.</source>
          <target state="translated">请注意,更高的优化级别会导致更多的跨模块优化,这可能会影响到当你改变一些东西时,你的程序需要重新编译的程度。这也是开发代码时坚持不优化的一个原因。</target>
        </trans-unit>
        <trans-unit id="c4c0dcced941ac54917c55caf21e22d4636d250c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="11abb5f8d9b5fba3f33fa0b7e155694cf82d23ad" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="55ba0c9a076ac9b515d71482f78bc92a96d264e8" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="53bdddcd649e7c0b18af6cbb0a2342c2614754df" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="0cd84aceb1741c1097100af32525f39087b79c2c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;C&lt;/code&gt; does not contain any class methods, the instance context is wholly unnecessary, and as such GHC will instead generate:</source>
          <target state="translated">请注意，如果 &lt;code&gt;C&lt;/code&gt; 不包含任何类方法，则实例上下文是完全不必要的，因此GHC会生成：</target>
        </trans-unit>
        <trans-unit id="28c37978b95dd575e513b0b23b8deb28631dd7fb" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="288715920cc43c37cbcf03237a6afbc9e9f1ca44" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23075918281a3d4a9a4393210ab00757f30add13" translate="yes" xml:space="preserve">
          <source>Note that if Haskeline is built against a version of the &lt;code&gt;Win32&lt;/code&gt; library earlier than 2.5, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; will incorrectly echo back input on MinTTY consoles (such as Cygwin or MSYS).</source>
          <target state="translated">请注意，如果Haskeline是针对 &lt;code&gt;Win32&lt;/code&gt; 库的2.5 版之前的版本构建的，则 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; 将错误地回显MinTTY控制台（例如Cygwin或MSYS）上的输入。</target>
        </trans-unit>
        <trans-unit id="748b314274792a265ed7c2434a739a0777fcbd47" translate="yes" xml:space="preserve">
          <source>Note that if the expression can&amp;rsquo;t be translated into uses of &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; only, then it will incur a &lt;code&gt;Monad&lt;/code&gt; constraint as usual. This happens when there is a dependency on a value produced by an earlier statement in the &lt;code&gt;do&lt;/code&gt;-block:</source>
          <target state="translated">请注意，如果表达式不能仅转换为 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 的使用，则它将照常受到 &lt;code&gt;Monad&lt;/code&gt; 约束。当对 &lt;code&gt;do&lt;/code&gt; -block中的较早语句产生的值有依赖性时，就会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="3cbb7152b808b31e2c0cac825f8fb2dae7c7b28d" translate="yes" xml:space="preserve">
          <source>Note that if you do need to interpret file paths or environment strings as text, then some Unicode encoding or decoding should be applied first.</source>
          <target state="translated">请注意,如果你确实需要将文件路径或环境字符串解释为文本,那么应该先应用一些Unicode编码或解码。</target>
        </trans-unit>
        <trans-unit id="727e91ac7cf7235ceb01512e066f5fa194d7f879" translate="yes" xml:space="preserve">
          <source>Note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;. The reason is that the latter does not force the &quot;inner&quot; results, resulting in a thunk chain which then must be evaluated from the outside-in.</source>
          <target state="translated">请注意，如果您想要有效的左折，则可能要使用 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 。原因是后者不会强制执行&amp;ldquo;内部&amp;rdquo;结果，从而导致必须从外到内评估链状链。</target>
        </trans-unit>
        <trans-unit id="3f920b899f0a93de7b234be63afb284d817b0204" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;S2&lt;/code&gt; and &lt;code&gt;S3&lt;/code&gt;, the kind of the right-hand side is rather apparent, but it is still not considered to have a complete signature &amp;ndash; no inference can be done before detecting the signature.</source>
          <target state="translated">请注意，在 &lt;code&gt;S2&lt;/code&gt; 和 &lt;code&gt;S3&lt;/code&gt; 中，右侧的种类非常明显，但仍不认为它具有完整的签名-在检测到签名之前无法进行推断。</target>
        </trans-unit>
        <trans-unit id="1ed65ace60cec8fe502a481f05e3dda7d603ff35" translate="yes" xml:space="preserve">
          <source>Note that in GHCi, and &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode, the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for &lt;em&gt;source&lt;/em&gt; files, whereas in standard batch-compilation mode the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for interface files, see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;.</source>
          <target state="translated">请注意，在GHCI和&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式下，&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项来指定搜索路径&lt;em&gt;源&lt;/em&gt;文件，而在标准批处理编译模式的&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项来指定接口文件的搜索路径，看到&lt;a href=&quot;separate_compilation#search-path&quot;&gt;的搜索路径&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f74e9b413c970241bf9e71c360a313d3c98064d3" translate="yes" xml:space="preserve">
          <source>Note that in the last example, it&amp;rsquo;s impossible to learn that &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;k&lt;/code&gt; in the body of the &lt;code&gt;forall&lt;/code&gt; (that is, the &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt;). And so GHC rejects the program.</source>
          <target state="translated">请注意，在最后一个例子，这是不可能得知 &lt;code&gt;a&lt;/code&gt; 依赖于 &lt;code&gt;k&lt;/code&gt; 在体内 &lt;code&gt;forall&lt;/code&gt; （也就是 &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt; ）。因此，GHC拒绝了该计划。</target>
        </trans-unit>
        <trans-unit id="3c3f39847ba19e77a6a582f15278eee9d18590bf" translate="yes" xml:space="preserve">
          <source>Note that invariant checking (namely the &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;alwaysSucceeds&lt;/code&gt; functions) has been removed. See ticket &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;#14324&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;removal proposal&lt;/a&gt;. Existing users are encouraged to encapsulate their STM operations in safe abstractions which can perform the invariant checking without help from the runtime system.</source>
          <target state="translated">请注意，不变检查（即 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;alwaysSucceeds&lt;/code&gt; 函数）已被删除。请参阅票证&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;＃14324&lt;/a&gt;和&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;拆除建议&lt;/a&gt;。鼓励现有用户将其STM操作封装为安全的抽象，这些抽象可以执行不变性检查而无需运行时系统的帮助。</target>
        </trans-unit>
        <trans-unit id="bfd5ca80319611f2ad6a6d58665d93fcbb3c156f" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;希望 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 的类型实例实现一个字段。但是， &lt;code&gt;base&lt;/code&gt; 中的所有实例都可以。</target>
        </trans-unit>
        <trans-unit id="525bc9621da46140b66110bf09981d8c0a2b7083" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;希望 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 的类型实例实现一个字段。但是， &lt;code&gt;base&lt;/code&gt; 中的所有实例都可以。</target>
        </trans-unit>
        <trans-unit id="ccaf9ee57d711da801bed84dfadd525a75d70df7" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;期望 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的类型实例都实现有序环。事实上，在 &lt;code&gt;base&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 做的。</target>
        </trans-unit>
        <trans-unit id="0b0ebefaf6a8fd7841a426ebbf90075219fca0d8" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;期望 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的类型实例都实现有序环。事实上，在 &lt;code&gt;base&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 做的。</target>
        </trans-unit>
        <trans-unit id="b265c3aed4a0fae4215ed6797047f0fad0de3ff1" translate="yes" xml:space="preserve">
          <source>Note that it doesn&amp;rsquo;t fully negate the effects of &lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; - the warning will still be enabled.</source>
          <target state="translated">请注意，它并未完全消除 &lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; 的影响 -该警告仍将启用。</target>
        </trans-unit>
        <trans-unit id="7005610565a4c7898f3b659dd8d96fce7be60db0" translate="yes" xml:space="preserve">
          <source>Note that line numbers start counting at one, but column numbers start at zero. This choice was made to follow existing convention (i.e. this is how Emacs does it).</source>
          <target state="translated">请注意,行号从1开始计数,但列号从0开始。这种选择是为了遵循现有的惯例(即Emacs是这样做的)。</target>
        </trans-unit>
        <trans-unit id="b58c5082533c6ce920a238e2630b3a0a649c4aa4" translate="yes" xml:space="preserve">
          <source>Note that memory allocation is unrelated to &lt;em&gt;live memory&lt;/em&gt;, also known as &lt;em&gt;heap residency&lt;/em&gt;. A thread can allocate a large amount of memory and retain anything between none and all of it. It is better to think of the allocation limit as a limit on &lt;em&gt;CPU time&lt;/em&gt;, rather than a limit on memory.</source>
          <target state="translated">请注意，内存分配与&lt;em&gt;活动内存&lt;/em&gt;无关，也称为&lt;em&gt;堆驻留时间&lt;/em&gt;。线程可以分配大量内存，并在所有内存之间保留任何内容。最好将分配限制视为对&lt;em&gt;CPU时间&lt;/em&gt;的限制，而不是对内存的限制。</target>
        </trans-unit>
        <trans-unit id="273d41914c5c6dac58d5704a8903f640ae883fcf" translate="yes" xml:space="preserve">
          <source>Note that module &lt;code&gt;D&lt;/code&gt; was compiled, but in this instance because its source hadn&amp;rsquo;t really changed, its interface remained the same, and the recompilation checker determined that &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; didn&amp;rsquo;t need to be recompiled.</source>
          <target state="translated">请注意，模块 &lt;code&gt;D&lt;/code&gt; 已编译，但是在这种情况下，由于其源代码并没有真正更改，因此其接口保持不变，并且重新编译检查器确定不需要重新编译 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa9b10733e365e8f6145122de16aa95fd734e161" translate="yes" xml:space="preserve">
          <source>Note that no assumptions may be made about the values representing stable pointers. In fact, they need not even be valid memory addresses. The only guarantee provided is that if they are passed back to Haskell land, the function &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; will be able to reconstruct the Haskell value referred to by the stable pointer.</source>
          <target state="translated">注意，不能对表示稳定指针的值做任何假设。实际上，它们甚至不必是有效的内存地址。唯一提供的保证是，如果将它们传递回Haskell领域，则函数 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 将能够重建稳定指针引用的Haskell值。</target>
        </trans-unit>
        <trans-unit id="cc4fefad8cc30b2189f543b2c01f22060d9ca1a7" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">请注意，即使&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt;会更改其是否引用Prelude，也不会对隐式引用Prelude的语法给出警告。例如，当 &lt;code&gt;368&lt;/code&gt; 表示 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; （其中 &lt;code&gt;Prelude&lt;/code&gt; 指代实际的Prelude模块，而不考虑正在编译的模块的导入），则不会给出警告。</target>
        </trans-unit>
        <trans-unit id="49a7cd2da732a498264fe69cdc55ccc2e5f59d22" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3961e6b1d44470d139a066bd7e5e99b36cc380d" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，此函数可解析ASCII范围之外的数字（例如&amp;ldquo; ٤&amp;rdquo;或 &lt;code&gt;U+0664&lt;/code&gt; 0664之类的阿拉伯文数字）以及不是数字的数字字符，但不会解析 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ed51f37ef06c30fed9104ea5ecb01d29f66f7e" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，此函数可解析ASCII范围之外的数字（例如&amp;ldquo; ٤&amp;rdquo;或 &lt;code&gt;U+0664&lt;/code&gt; 0664之类的阿拉伯文数字）以及不是数字的数字字符，但不会解析 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aca93abfde5ec064588876b85a983dba2e1d897" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">请注意，使用此功能而不是 &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 可以选择ASCII范围之外的数字以及不是数字的数字字符。这样的字符可能是标识符的一部分，但打印机和阅读器不使用它来表示数字。</target>
        </trans-unit>
        <trans-unit id="f6ca479e6c19d19f7cbdf53fa1975eb3bf201fe0" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">请注意，使用此功能而不是 &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 可以选择ASCII范围之外的数字以及不是数字的数字字符。这样的字符可能是标识符的一部分，但打印机和阅读器不使用它来表示数字。</target>
        </trans-unit>
        <trans-unit id="00198523cbc0082fb3428e68e1d61ecf58a45ae8" translate="yes" xml:space="preserve">
          <source>Note that on Windows parent directories &lt;code&gt;..&lt;/code&gt; are always fully expanded before the symbolic links, as consistent with the rest of the Windows API (such as &lt;code&gt;GetFullPathName&lt;/code&gt;). In contrast, on POSIX systems parent directories &lt;code&gt;..&lt;/code&gt; are expanded alongside symbolic links from left to right. To put this more concretely: if &lt;code&gt;L&lt;/code&gt; is a symbolic link for &lt;code&gt;R/P&lt;/code&gt;, then on Windows &lt;code&gt;L\..&lt;/code&gt; refers to &lt;code&gt;.&lt;/code&gt;, whereas on other operating systems &lt;code&gt;L/..&lt;/code&gt; refers to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">请注意，在Windows上，父目录 &lt;code&gt;..&lt;/code&gt; 始终在符号链接之前完全展开，这与Windows API的其余部分（例如 &lt;code&gt;GetFullPathName&lt;/code&gt; ）一致。相反，在POSIX系统上，父目录 &lt;code&gt;..&lt;/code&gt; 与符号链接一起从左到右扩展。更具体地说：如果 &lt;code&gt;L&lt;/code&gt; 是 &lt;code&gt;R/P&lt;/code&gt; 的符号链接，则在Windows上 &lt;code&gt;L\..&lt;/code&gt; 是指 &lt;code&gt;.&lt;/code&gt; 的，而在其他操作系统上 &lt;code&gt;L/..&lt;/code&gt; 是指 &lt;code&gt;R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce57e0602bd626d4114bc65f1120819b7a872c0" translate="yes" xml:space="preserve">
          <source>Note that packages only contain compiled code, so debugging a package requires finding its source and loading that directly.</source>
          <target state="translated">需要注意的是,包只包含编译后的代码,所以调试包需要找到它的源码并直接加载。</target>
        </trans-unit>
        <trans-unit id="92c2203dfd5a194d5612dfeec8df42a4f09f5338" translate="yes" xml:space="preserve">
          <source>Note that primitives are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意，原语是 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="b038144c16c5927ecb1a6490213329a05b30c08f" translate="yes" xml:space="preserve">
          <source>Note that processes which use the POSIX &lt;code&gt;exec&lt;/code&gt; system call (e.g. &lt;code&gt;gcc&lt;/code&gt;) require special care on Windows. Specifically, the &lt;code&gt;msvcrt&lt;/code&gt; C runtime used frequently on Windows emulates &lt;code&gt;exec&lt;/code&gt; in a non-POSIX compliant manner, where the caller will be terminated (with exit code 0) and execution will continue in a new process. As a result, on Windows it will appear as though a child process which has called &lt;code&gt;exec&lt;/code&gt; has terminated despite the fact that the process would still be running on a POSIX-compliant platform.</source>
          <target state="translated">请注意，在Windows上，使用POSIX &lt;code&gt;exec&lt;/code&gt; 系统调用的进程（例如 &lt;code&gt;gcc&lt;/code&gt; ）需要特别注意。具体来说，Windows上经常使用的 &lt;code&gt;msvcrt&lt;/code&gt; C运行时以不符合POSIX的方式模拟 &lt;code&gt;exec&lt;/code&gt; ，在此方式下，调用方将被终止（退出代码为0），并且执行将在新进程中继续。结果，在Windows上，尽管该进程仍将在符合POSIX的平台上运行，但似乎已终止了名为 &lt;code&gt;exec&lt;/code&gt; 的子进程。</target>
        </trans-unit>
        <trans-unit id="5e2096ed561c2bf3900c21383006ef3f61805855" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">注意，来自终结器的引用不一定会阻止另一个对象被终结。如果A的终结器引用B（也许使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; ，则唯一的保证是B的终结器将永远不会在A之前启动。如果A和B都无法访问，则这两个终结器将一起启动。有关终结器排序的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e90d7572d19320cf7344ae3b1d0ce896d5029a" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">注意，来自终结器的引用不一定会阻止另一个对象被终结。如果A的终结器引用B（也许使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; ，则唯一的保证是B的终结器将永远不会在A之前启动。如果A和B都无法访问，则这两个终结器将一起启动。有关终结器排序的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc356b8793bb083a67ad53425e549e6eaf817f79" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is ignored. For example,</source>
          <target state="translated">注意 &lt;code&gt;:^:&lt;/code&gt; 右关联性被忽略。例如，</target>
        </trans-unit>
        <trans-unit id="ea16129864c9bc69b1267cd317e60b8e1cd54033" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is unused.</source>
          <target state="translated">请注意， &lt;code&gt;:^:&lt;/code&gt; 的右相关性未使用。</target>
        </trans-unit>
        <trans-unit id="cb25fb232eaa8d92d1074e6f26210af239a4d814" translate="yes" xml:space="preserve">
          <source>Note that sequences are typically &lt;em&gt;slower&lt;/em&gt; than lists when using only operations for which they have the same big-(O) complexity: sequences make rather mediocre stacks!</source>
          <target state="translated">请注意，当仅使用序列具有相同的大（O）复杂度的操作时，序列通常比列表&lt;em&gt;慢&lt;/em&gt;：序列构成相当平庸的堆栈！</target>
        </trans-unit>
        <trans-unit id="c723aeed4af9dd83a9b82069c07b9c3ccbc5da99" translate="yes" xml:space="preserve">
          <source>Note that signature matching does check if &lt;em&gt;fixity&lt;/em&gt; matches, so be sure specify fixity of ordinary identifiers if you intend to use them with backticks.</source>
          <target state="translated">请注意，签名匹配会检查&lt;em&gt;固定性是否&lt;/em&gt;匹配，因此，如果要与反引号一起使用，请确保指定普通标识符的固定性。</target>
        </trans-unit>
        <trans-unit id="f095c03ad06a310fd52b2a6d717b98f26776e7da" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;integer-gmp&lt;/code&gt; does not depend on &lt;code&gt;base&lt;/code&gt;, error reporting via exceptions, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; is not available. Instead, the low-level functions will crash the runtime if called with invalid arguments.</source>
          <target state="translated">请注意，由于 &lt;code&gt;integer-gmp&lt;/code&gt; 不依赖于 &lt;code&gt;base&lt;/code&gt; ，因此无法通过异常， &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 进行错误报告。相反，如果使用无效参数调用，则低级函数将使运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="9b83514c0ce414a47b834dc48f510e88bcd807c9" translate="yes" xml:space="preserve">
          <source>Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group</source>
          <target state="translated">需要注意的是,由于表达式拼接无法引用同一声明组中的声明,我们可以引入一个顶层(空)拼接来分解声明组</target>
        </trans-unit>
        <trans-unit id="a74f896437a88c7d014238b3770a7c1c62b51099" translate="yes" xml:space="preserve">
          <source>Note that the 32-bit x86 native code generator only supports excess-precision mode, so neither &lt;code&gt;-fexcess-precision&lt;/code&gt; nor &lt;code&gt;-fno-excess-precision&lt;/code&gt; has any effect. This is a known bug, see &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;.</source>
          <target state="translated">请注意，32位x86本机代码生成器仅支持超精度模式，因此 &lt;code&gt;-fexcess-precision&lt;/code&gt; 和 &lt;code&gt;-fno-excess-precision&lt;/code&gt; 均无效。这是一个已知的错误，请参阅&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC中的错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="330613fe18f73ee23466f7511d7b202676e5cd38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-odir&lt;/code&gt; option does &lt;em&gt;not&lt;/em&gt; affect where the interface files are put; use the &lt;code&gt;-hidir&lt;/code&gt; option for that. In the above example, they would still be put in &lt;code&gt;parse/Foo.hi&lt;/code&gt;, &lt;code&gt;parse/Bar.hi&lt;/code&gt;, and &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;-odir&lt;/code&gt; 选项并&lt;em&gt;不会&lt;/em&gt;影响在接口文件放在; &lt;code&gt;-hidir&lt;/code&gt; 使用-hidir选项。在上面的示例中，它们仍将放在 &lt;code&gt;parse/Foo.hi&lt;/code&gt; ， &lt;code&gt;parse/Bar.hi&lt;/code&gt; 和 &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="309a5bb3e84ee602253ec738970608aecfccc201" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 并不是特别懒惰。要产生任何结果，将需要与各个结果序列的对数之和成正比的时间。</target>
        </trans-unit>
        <trans-unit id="ecf7bfd1b411f608d1147e0ef0a9518d1e3597b7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532a96aa546fe516b65f4c317f8d98964d1adb0b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致将额外的字节顺序标记写入文件。</target>
        </trans-unit>
        <trans-unit id="2204063e4c34f1c3a4a4b15d40a00171735eecd7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致将额外的字节顺序标记写入文件。</target>
        </trans-unit>
        <trans-unit id="2b693c1b448bc94cf66607a78730b10d509a368a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Lift&lt;/code&gt; typeclass takes advantage of &lt;a href=&quot;#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt; in order to support instances involving unboxed types. This means &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; also works for these types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1e65aa301e4b1be82f664f9499398a1e7e1f92" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Prelude&lt;/code&gt; import is marked as implicit. It can be overridden with an explicit &lt;code&gt;Prelude&lt;/code&gt; import, just like in a Haskell module.</source>
          <target state="translated">请注意， &lt;code&gt;Prelude&lt;/code&gt; 导入被标记为隐式。可以使用显式的 &lt;code&gt;Prelude&lt;/code&gt; 导入来覆盖它，就像在Haskell模块中一样。</target>
        </trans-unit>
        <trans-unit id="502132d21d5978b3a8ec6cd6de231a4d98125ce2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;nominal&lt;/code&gt; type arguments are equal, the &lt;code&gt;representational&lt;/code&gt; type arguments can differ, but need to have a &lt;code&gt;Coercible&lt;/code&gt; instance themself, and the &lt;code&gt;phantom&lt;/code&gt; type arguments can be changed arbitrarily.</source>
          <target state="translated">请注意， &lt;code&gt;nominal&lt;/code&gt; 类型参数是相等的， &lt;code&gt;representational&lt;/code&gt; 类型参数可以不同，但​​是 &lt;code&gt;Coercible&lt;/code&gt; 自己需要具有Coercible实例，并且 &lt;code&gt;phantom&lt;/code&gt; 类型参数可以任意更改。</target>
        </trans-unit>
        <trans-unit id="e840ae12e6ff09c359b921347e60a8e6a051ed31" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87a7979be5edffeddb07b20613db6dbe774e135f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454010dcf1120ceeb3132c227f791c724eec83d9" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="170a4ee31f2d0f202d220168ec1fdc8ad29400b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60d714ad07dfbcb448ae9178edf63b83c268312" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;via&lt;/code&gt; type does not have to be a &lt;code&gt;newtype&lt;/code&gt;. The only restriction is that it is coercible with the original data type. This means there can be arbitrary nesting of newtypes, as in the following example:</source>
          <target state="translated">注意，过 &lt;code&gt;via&lt;/code&gt; 类型不必是 &lt;code&gt;newtype&lt;/code&gt; 。唯一的限制是它可以与原始数据类型一起使用。这意味着新类型可以有任意嵌套，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="49a9ad3bbf35b1a32c2be7eda4a33ddd430bcebb" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">请注意，ASCII编码是UTF-8编码的子集，这就是为什么我们可以使用优化的函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 将具有UTF-8编码数字的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字的原因。使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 比 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 更有效。显示，因为它避免构造中间 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。避免使用这种中间数据结构会显着提高性能，因为编码 &lt;code&gt;Cell&lt;/code&gt; 是渲染CSV表的核心操作。有关如何提高 &lt;code&gt;renderString&lt;/code&gt; 性能的更多信息，请参见&lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0dbdccc6b0227bdbf0bac2e7e966328224fe997" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f06bfc55bfbd403475823742e13e429c0ca2e0" translate="yes" xml:space="preserve">
          <source>Note that the RTS will not set CPU affinity for bound threads and threads entering Haskell from C/C++, so if your program uses bound threads you should ensure that each bound thread calls the RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; from C/C++ before calling into Haskell. Otherwise there could be a mismatch between the CPU that the thread is running on and the memory it is using while running Haskell code, which will negate any benefits of &lt;code&gt;--numa&lt;/code&gt;.</source>
          <target state="translated">请注意，RTS不会为绑定线程和从C / C ++进入Haskell的线程设置CPU关联性，因此，如果您的程序使用绑定线程，则应确保每个绑定线程在从C / C ++ 调用RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; 之前召集到Haskell。否则，在运行Haskell代码时线程正在运行的CPU与它正在使用的内存之间可能会出现不匹配，这将抵消 &lt;code&gt;--numa&lt;/code&gt; 的任何好处。</target>
        </trans-unit>
        <trans-unit id="58d5dd0ddd0336b419dba13d539e292846c264a2" translate="yes" xml:space="preserve">
          <source>Note that the application of &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; is not an action in the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context, as &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; type. While the fresh bindings in the following example will force the &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; expressions to be reduced every time the &lt;code&gt;do&lt;/code&gt;-block is executed, &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; would only be reduced once, and the message would only be printed once. If your monad is in &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; may be a better option.</source>
          <target state="translated">需要注意的是应用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 不在动作 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 背景下，作为 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 类型。尽管以下示例中的新绑定将强制每次执行 &lt;code&gt;do&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 时都减少traceM表达式，但 &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; 将仅减少一次，并且消息仅打印一次。如果您的monad在 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 中，请使用 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;可能是一个更好的选择。</target>
        </trans-unit>
        <trans-unit id="84f82e7fb65a174913c30b1e72c6c8b2742829f2" translate="yes" xml:space="preserve">
          <source>Note that the bang has no effect at all in this case</source>
          <target state="translated">请注意,在这种情况下,爆炸根本没有任何影响</target>
        </trans-unit>
        <trans-unit id="b4b32cd6cbf824718f0bdfb9b704b062cdf90b8a" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回三个以上的子图,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="68d7fa1f654e15d8602e5a0f9e4ae840941c5c24" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three subsets, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回三个以上的子集,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="adfda92db68ba407dc5fdfba24f554547fcbb251" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回两个以上的子图,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="a8b5ab808606c44886a770fd7971f5bf90a9f368" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two subsets, but you should not depend on this behaviour because it can change in the future without notice. Also, the current version does not continue splitting all the way to individual singleton sets -- it stops at some point.</source>
          <target state="translated">请注意,当前的实现不会返回两个以上的子集,但你不应该依赖这种行为,因为它可能会在未来不经意间改变。另外,当前的版本并不会一直拆分到单个单子集--它会在某个点上停止。</target>
        </trans-unit>
        <trans-unit id="086a1162aacfb2236087d8ed35712ce6942f14ad" translate="yes" xml:space="preserve">
          <source>Note that the datatype &lt;code&gt;G&lt;/code&gt; is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion. It is thus only possible to use this feature if you have provided a complete user-supplied kind signature for the datatype (&lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">请注意，数据类型 &lt;code&gt;G&lt;/code&gt; 在其主体中使用了不同的种类，因此种类索引的GADT使用一种多态递归形式。因此，只有在为数据类型提供了完整的用户提供的种类签名（&lt;a href=&quot;#complete-kind-signatures&quot;&gt;完整的用户提供的种类签名和多态递归&lt;/a&gt;）后，才能使用此功能。</target>
        </trans-unit>
        <trans-unit id="442f6f35f8b2e112d5cfdda0a46fff2deeaa6cc5" translate="yes" xml:space="preserve">
          <source>Note that the following operator interactions are expected to hold:</source>
          <target state="translated">请注意,以下运算符的交互作用预计会成立。</target>
        </trans-unit>
        <trans-unit id="c120d45347ef3551abdd412d6c3c744d162a17b6" translate="yes" xml:space="preserve">
          <source>Note that the foreign function &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;ccall&lt;/code&gt; calling convention.</source>
          <target state="translated">请注意，外部函数&lt;em&gt;必须&lt;/em&gt;使用 &lt;code&gt;ccall&lt;/code&gt; 调用约定。</target>
        </trans-unit>
        <trans-unit id="2b614124ab834b2d7b11895f2dcc340c5cee01ee" translate="yes" xml:space="preserve">
          <source>Note that the formatting for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; types is currently a bit different from that of C &lt;code&gt;printf(3)&lt;/code&gt;, conforming instead to &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; (and their alternate versions &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt;). This is hard to fix: the fixed versions would format in a backward-incompatible way. In any case the Haskell behavior is generally more sensible than the C behavior. A brief summary of some key differences:</source>
          <target state="translated">请注意，当前 &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 类型的格式与C &lt;code&gt;printf(3)&lt;/code&gt; 的格式略有不同，取而代之的是 &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; （以及它们的替代版本 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt; ）。这很难解决：固定版本将以向后不兼容的方式格式化。在任何情况下，Haskell行为通常比C行为更明智。一些主要区别的简要摘要：</target>
        </trans-unit>
        <trans-unit id="6333d0cd3c8a1c9277e720de89a814eceeaca59c" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; （在下面使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 编写）足以为所有非递归代数数据类型构造 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="e5834f94034f4c9c7099a4fe839728a49c4d2727" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; （在下面使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 编写）足以为所有非递归代数数据类型构造 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="8f8de4b46e9fc5311e12637212df5e73b817991a" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;#8657&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45346d36f74c21a2830e97a59a45b659f59ada4b" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue #8657&lt;/a&gt;.</source>
          <target state="translated">请注意，图形着色分配器只是一个实验，可能在遇到具有较高寄存器压力的代码&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue＃8657&lt;/a&gt;时失败。</target>
        </trans-unit>
        <trans-unit id="96e6fa4ccd6707887b270260302a346013c42cc4" translate="yes" xml:space="preserve">
          <source>Note that the implementation is &lt;em&gt;left-biased&lt;/em&gt; -- the elements of a first argument are always preferred to the second, for example in &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，实现是&lt;em&gt;偏左的&lt;/em&gt; -第一个参数的元素始终优先于第二个参数，例如，在 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="26e0c734ac95701d148351fdd4b47d9138fb0c9b" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="259d0e9c405d160a835af61c7ce39b23637e93f5" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="70bb8bafe9d5794e15a6e0a9bc59a3fd519eaaca" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="f2ac01eed48e680198fa41a99d8fed147ac41510" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="38d11ff08ef387c96608bffa08a777dba57a2a33" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="cb352c04cf593932ccc7109649ee4df971ea1e0e" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two sets as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the entries in the first argument to those in the second. Of course, this bias can only be observed when equality is an equivalence relation instead of structural equality.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个集合作为参数并将它们组合在一起的函数（例如 &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的条目而不是第二个参数中的条目。当然，只有当平等是等价关系而不是结构平等时，才能观察到这种偏见。</target>
        </trans-unit>
        <trans-unit id="42a24a4ea20d65f2df9e64aaf0077349c30737f9" translate="yes" xml:space="preserve">
          <source>Note that the kind of &lt;code&gt;a&lt;/code&gt; is specified in the kind of &lt;code&gt;C&lt;/code&gt; but inferred in the kind of &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b863c9095848a793815119dcb80b73aa065664bb" translate="yes" xml:space="preserve">
          <source>Note that the line information in this section is not nearly as rich as the information provided in &lt;code&gt;.debug_info&lt;/code&gt;. Whereas &lt;code&gt;.debug_line&lt;/code&gt; requires that each instruction is assigned exactly one source location, the DIEs in &lt;code&gt;.debug_info&lt;/code&gt; can be used to identify all relevant sources locations.</source>
          <target state="translated">请注意，本节中的行信息并不比 &lt;code&gt;.debug_info&lt;/code&gt; 中提供的信息丰富。而 &lt;code&gt;.debug_line&lt;/code&gt; 要求每个指令被分配一个源位置，在模具 &lt;code&gt;.debug_info&lt;/code&gt; 可用于识别所有有关来源的位置。</target>
        </trans-unit>
        <trans-unit id="cf810684fcb41725f6886705bdc64d801b1f9b52" translate="yes" xml:space="preserve">
          <source>Note that the local variables at each step in the history have been preserved, and can be examined as usual. Also note that the prompt has changed to indicate that we&amp;rsquo;re currently examining the first step in the history: &lt;code&gt;-1&lt;/code&gt;. The command &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt; can be used to traverse forward in the history.</source>
          <target state="translated">请注意，历史记录中每个步骤的局部变量均已保留，可以照常检查。另请注意，提示已更改，以指示我们当前正在检查历史记录的第一步： &lt;code&gt;-1&lt;/code&gt; 。&lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt;命令可用于在历史记录中向前移动。</target>
        </trans-unit>
        <trans-unit id="34cdea8f3371da06ac1a345345c3c5002304f5fa" translate="yes" xml:space="preserve">
          <source>Note that the package might still end up being linked into the final program, if it is a dependency (direct or indirect) of another exposed package.</source>
          <target state="translated">请注意,如果这个包是另一个暴露的包的依赖(直接或间接),那么它可能最终还是会被链接到最终程序中。</target>
        </trans-unit>
        <trans-unit id="654350bad2f19f9da14ea79da18d4e92d82c3375" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">请注意，窥视和戳功能可能需要正确对齐的地址才能正常运行。这取决于体系结构；因此，可移植代码应确保在偷看或戳取某些类型 &lt;code&gt;a&lt;/code&gt; 的值时，满足由函数 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 给出的 &lt;code&gt;a&lt;/code&gt; 的对齐约束。</target>
        </trans-unit>
        <trans-unit id="3e394d38fdeaac337578117a43906351c1d79b5f" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">请注意，窥视和戳功能可能需要正确对齐的地址才能正常运行。这取决于体系结构；因此，可移植代码应确保在偷看或戳取某些类型 &lt;code&gt;a&lt;/code&gt; 的值时，满足由函数 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 给出的 &lt;code&gt;a&lt;/code&gt; 的对齐约束。</target>
        </trans-unit>
        <trans-unit id="e73723a6b46c23d5ed4a216d4c7a2b7c6b5806fa" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d82712c12c8cee5b77f4ba6fbc419e98e702525b" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22e279d3458c2e34319e6e20c6829368879e2a50" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1166a95e8823cf3e0d0bc99a95c0278ded704bed" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8de5a86d574b2ca399eee3e30f64be312fc9bc" translate="yes" xml:space="preserve">
          <source>Note that the rather verbose syntax for composition stems from the requirement to be able to compute the size / size bound at compile time.</source>
          <target state="translated">请注意,组成的相当啰嗦的语法源于在编译时能够计算大小/尺寸约束的要求。</target>
        </trans-unit>
        <trans-unit id="54b1d4f1be10b0845077542d67e90448dc344e0a" translate="yes" xml:space="preserve">
          <source>Note that the second example has a &lt;code&gt;forall&lt;/code&gt; that binds both a kind &lt;code&gt;k&lt;/code&gt; and a type variable &lt;code&gt;a&lt;/code&gt; of kind &lt;code&gt;k&lt;/code&gt;. In general, there is no limit to how deeply nested this sort of dependency can work. However, the dependency must be well-scoped: &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; is an error.</source>
          <target state="translated">注意，第二实施例具有 &lt;code&gt;forall&lt;/code&gt; 结合两者一种 &lt;code&gt;k&lt;/code&gt; 和类型可变 &lt;code&gt;a&lt;/code&gt; 种 &lt;code&gt;k&lt;/code&gt; 。通常，对此类依赖项可以嵌套到多深没有限制。但是，依赖项必须具有良好的范围： &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; 是一个错误。</target>
        </trans-unit>
        <trans-unit id="1b1310d229e7aede634064e0ec7e66e799d19c89" translate="yes" xml:space="preserve">
          <source>Note that the second item only at the &lt;em&gt;head&lt;/em&gt; of the quantified constraint, not its context. Reason: the head is the new goal that has to be solved if we use the instance declaration.</source>
          <target state="translated">请注意，第二项仅位于量化约束的&lt;em&gt;开头&lt;/em&gt;，而不是其上下文。原因：如果我们使用实例声明，那么head是必须解决的新目标。</target>
        </trans-unit>
        <trans-unit id="3c8c63d3b44c41dfd3ecc9855ec677afa1387569" translate="yes" xml:space="preserve">
          <source>Note that the strictness of &lt;code&gt;f&lt;/code&gt; differs from that of &lt;code&gt;g&lt;/code&gt; defined below:</source>
          <target state="translated">请注意， &lt;code&gt;f&lt;/code&gt; 的严格性与以下定义的 &lt;code&gt;g&lt;/code&gt; 的严格性不同：</target>
        </trans-unit>
        <trans-unit id="b0d67f48c00a6048890cd9462dc5217e24546eeb" translate="yes" xml:space="preserve">
          <source>Note that the suffix rules are all repeated twice, once for normal Haskell source files, and once for &lt;code&gt;hs-boot&lt;/code&gt; files (see &lt;a href=&quot;#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;).</source>
          <target state="translated">请注意，所有后缀规则均重复两次，一次用于普通的Haskell源文件，一次用于 &lt;code&gt;hs-boot&lt;/code&gt; 文件（请参阅&lt;a href=&quot;#mutual-recursion&quot;&gt;如何编译相互递归的模块&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ca6ebf983fc1a2fd926f4a83f66b04b8d23d1437" translate="yes" xml:space="preserve">
          <source>Note that the unmask function passed to the child thread should only be used in that thread; the behaviour is undefined if it is invoked in a different thread.</source>
          <target state="translated">需要注意的是,传递给子线程的解除掩码函数只能在该线程中使用,如果在不同的线程中调用该函数,则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="c1c671757e9a3af40d5bdde86bfebfd0651c0310" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; in this module conflicts with an operator with the same name that is being exported by &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;. However, this package re-exports (most of) the contents of Data.Monoid, so to use semigroups and monoids in the same package just</source>
          <target state="translated">请注意，在此模块中使用 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 与&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;导出的同名运算符冲突。但是，此程序包会重新导出（大部分）Data.Monoid的内容，因此仅在同一程序包中使用半组和monoid</target>
        </trans-unit>
        <trans-unit id="da3869327f08d21fab9f4a7548818e33dbc49531" translate="yes" xml:space="preserve">
          <source>Note that there is an orphan &lt;code&gt;Binary&lt;/code&gt; instance for this type supplied by the &lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt; module provided by &lt;code&gt;ghc-boot&lt;/code&gt;. We can't provide here as this would require adding transitive dependencies to the &lt;code&gt;template-haskell&lt;/code&gt; package, which must have a minimal dependency set.</source>
          <target state="translated">请注意， &lt;code&gt;ghc-boot&lt;/code&gt; 提供的&lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt;模块提供了此类型的孤立 &lt;code&gt;Binary&lt;/code&gt; 实例。我们此处无法提供，因为这将需要向 &lt;code&gt;template-haskell&lt;/code&gt; 包中添加传递性依赖，该包必须具有最小的依赖集。</target>
        </trans-unit>
        <trans-unit id="25f165099a7186900fe29f29d734746be66f7ff0" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">请注意,不支持使用大写字符。如果您的应用程序不能在没有使用大写字符的十六进制编码的情况下工作,请联系维护者。</target>
        </trans-unit>
        <trans-unit id="42fd927f1ef5d9b3a3e3d4ec201b36298d76dcdc" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer, if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">请注意,不支持使用大写字符。如果您的应用程序不能在没有使用大写字符的十六进制编码的情况下工作,请联系维护者。</target>
        </trans-unit>
        <trans-unit id="815e86136be57ff7983e8867a1653ca3748062a4" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 7 release series.</source>
          <target state="translated">需要注意的是,这个GHC版本期待7版本系列的LLVM版本。</target>
        </trans-unit>
        <trans-unit id="054fc5bfe46fd252b25912f49de7b42d063bf60e" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 9 release series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140a5a874045474c447887a9c7534e65797715b8" translate="yes" xml:space="preserve">
          <source>Note that this change relies on an existing meta-rule to resolve ambiguities:</source>
          <target state="translated">请注意,这一变化依靠现有的元规则来解决含糊不清的问题。</target>
        </trans-unit>
        <trans-unit id="6daa68880e86cbbf8117c1ecf2aaa1d59b601a6d" translate="yes" xml:space="preserve">
          <source>Note that this compatibility condition is independent of whether the type family is associated or not, and it is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">请注意,这个兼容性条件与类型族是否关联无关,它不仅是一个一致性的问题,也是一个类型安全的问题。</target>
        </trans-unit>
        <trans-unit id="6a49b31c7b3933e096f19de10387ce395bfc388b" translate="yes" xml:space="preserve">
          <source>Note that this feature is intended for debugging, and should not be relied on for the correct operation of your program. There is no guarantee that the garbage collector will be accurate enough to detect your deadlock, and no guarantee that the garbage collector will run in a timely enough manner. Basically, the same caveats as for finalizers apply to deadlock detection.</source>
          <target state="translated">请注意,这个功能是用来调试的,不应该依靠这个功能来保证你的程序的正确运行。不能保证垃圾回收器能足够准确地检测到你的死锁,也不能保证垃圾回收器能足够及时地运行。基本上,与终结器相同的注意事项也适用于死锁检测。</target>
        </trans-unit>
        <trans-unit id="f93e105b95e71dad1e256717f21218ff603f0e60" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">请注意，此功能在操作上非常&lt;em&gt;严格&lt;/em&gt;。也就是说， &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt; 。有关详细信息，请参见。</target>
        </trans-unit>
        <trans-unit id="4a3f1beae872eb8d0767738fe954a7102092701f" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchException undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">请注意，此功能在操作上非常&lt;em&gt;严格&lt;/em&gt;。也就是说， &lt;code&gt;catchException undefined b == _|_&lt;/code&gt; 。有关详细信息，请参见。</target>
        </trans-unit>
        <trans-unit id="be14bcfbfa87beefee836b26fb76d5e01c5bceae" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="4677b22a99bb8480062aaee7c99a3069c99501b0" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="204ab198814021ed6627310d82463388c4393515" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="6e3ecf4648736200d9ff929266ddf8cefc397759" translate="yes" xml:space="preserve">
          <source>Note that this is a &quot;shallow&quot; test; the declarations returned merely have instance heads which unify with &lt;code&gt;nm tys&lt;/code&gt;, they need not actually be satisfiable.</source>
          <target state="translated">注意，这是一个&amp;ldquo;浅&amp;rdquo;测试；返回的声明仅具有与 &lt;code&gt;nm tys&lt;/code&gt; 统一的实例头，它们实际上不一定是可满足的。</target>
        </trans-unit>
        <trans-unit id="439905505d9474fed9ffc65381b6ac6111a52311" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="a0ff55b445dc3b8027838fa247f8b759ea676ef6" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="159781685c28a0f652ef7a2657affedee9b597c8" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="ade4eadc51bb90be35da5528bf329479e583e59a" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="191887df22eeccf7c1081143dfdd938d7b2699e9" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="b569264b0537b82b52a587dd6185d1e70e6667fe" translate="yes" xml:space="preserve">
          <source>Note that this is an &lt;em&gt;expensive&lt;/em&gt; operation that forces the whole lazy ByteString into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</source>
          <target state="translated">请注意，这是一个&lt;em&gt;昂贵的&lt;/em&gt;操作，它将整个惰性ByteString强制放入内存，然后复制所有数据。如果可能，请尝试避免在严格字节字符串和惰性字节字符串之间来回转换。</target>
        </trans-unit>
        <trans-unit id="b6aebbc89aa137801ec2b9b8db93a16d46e98c00" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as a grapheme (e.g. a composition of code points that form one visual symbol). For instance, consider the grapheme &quot;&amp;auml;&quot;. This symbol has two Unicode representations: a single code-point representation &lt;code&gt;U+00E4&lt;/code&gt; (the &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; code point), and a two code point representation &lt;code&gt;U+0061&lt;/code&gt; (the &quot;&lt;code&gt;A&lt;/code&gt;&quot; code point) and &lt;code&gt;U+0308&lt;/code&gt; (the &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; code point).</source>
          <target state="translated">请注意，这与字素不一样（例如，组成一个视觉符号的代码点的组合）。例如，考虑字素&amp;ldquo;&amp;auml;&amp;rdquo;。此符号具有两种Unicode表示形式：一个代码点表示形式 &lt;code&gt;U+00E4&lt;/code&gt; （ &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; 代码点的拉丁文小写字母A）和两个代码点表示形式 &lt;code&gt;U+0061&lt;/code&gt; （&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;代码点）和 &lt;code&gt;U+0308&lt;/code&gt; （所述 &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; 代码点）。</target>
        </trans-unit>
        <trans-unit id="f1fb7a0e32b7e5f879759dbeacfe592b9604fb63" translate="yes" xml:space="preserve">
          <source>Note that this is only a specification, not necessarily the concrete implementation of the function.</source>
          <target state="translated">注意,这只是一个规范,不一定是函数的具体实现。</target>
        </trans-unit>
        <trans-unit id="669d9533b1634ff933892e992fae9bef3085f70e" translate="yes" xml:space="preserve">
          <source>Note that this is unsafe as it allows you to construct ill-kinded types.</source>
          <target state="translated">请注意,这是不安全的,因为它允许你构建恶意的类型。</target>
        </trans-unit>
        <trans-unit id="d02571c77536bd22aa42f3d92c1dd568dc209d06" translate="yes" xml:space="preserve">
          <source>Note that this kind of backtracking parser is very inefficient; reading a large structure may be quite slow (cf &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请注意，这种回溯解析器效率很低。读取大型结构可能会非常慢（请 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="436febebad9716edb3813b0bdb233588fd016eb7" translate="yes" xml:space="preserve">
          <source>Note that this option also has an effect on code generation (see above).</source>
          <target state="translated">请注意,这个选项对代码生成也有影响(见上文)。</target>
        </trans-unit>
        <trans-unit id="a6b15405a93ed10e85a7b3a620cdf673c82ced0d" translate="yes" xml:space="preserve">
          <source>Note that this policy has changed slightly in GHC 7.4.1 relative to earlier versions, and may yet change further, feedback is welcome.</source>
          <target state="translated">需要注意的是,这个政策在GHC 7.4.1中相对于之前的版本有了细微的变化,还可能会有进一步的变化,欢迎反馈。</target>
        </trans-unit>
        <trans-unit id="b69c87ebe8336d7ccf7274b115a1b224456d8a37" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，如果与&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; 一起&lt;/a&gt;使用，此警告将不会引发错误。</target>
        </trans-unit>
        <trans-unit id="371339dae687a1a51a3fb07f036275ab96d4f0aa" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690fcd2d09231ef4b1eb51f1d47ac594a9ff2305" translate="yes" xml:space="preserve">
          <source>Note that this will also match a function type,</source>
          <target state="translated">请注意,这也将匹配一个函数类型。</target>
        </trans-unit>
        <trans-unit id="38577a39855d6c49037bc139ad505bfea55af18e" translate="yes" xml:space="preserve">
          <source>Note that to avoid wasting space, this value should typically be less than 10% of the size of a stack chunk (&lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-kc ⟨size⟩&lt;/code&gt;&lt;/a&gt;), because in a chain of stack chunks, each chunk will have a gap of unused space of this size.</source>
          <target state="translated">请注意，为避免浪费空间，该值通常应小于堆栈块大小（&lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-kc ⟨size⟩&lt;/code&gt; &lt;/a&gt;）的10％，因为在堆栈块链中，每个块都将有一个未使用空间尺寸。</target>
        </trans-unit>
        <trans-unit id="50c38f07d65fbe728d13e67127cf7478adb9040c" translate="yes" xml:space="preserve">
          <source>Note that to change some, but not all permissions, a construct on the following lines must be used.</source>
          <target state="translated">需要注意的是,如果要改变部分而非全部的权限,必须使用下面一行结构。</target>
        </trans-unit>
        <trans-unit id="948767acfa623815c2e53deacab04e0b2b72ef49" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要生成运算符的最外层应用程序，必须遍历整个输入列表。这意味着如果给出无限的列表， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 将会发散。</target>
        </trans-unit>
        <trans-unit id="1c06bd2a9205927068bd825ef9aa825d38908e90" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要生成运算符的最外层应用程序，必须遍历整个输入列表。这意味着如果给出无限的列表， &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 将会发散。</target>
        </trans-unit>
        <trans-unit id="639bcb4a8a84771a9594ddef615c26a4482fa193" translate="yes" xml:space="preserve">
          <source>Note that using this option when linking causes GHC to link against shared libraries.</source>
          <target state="translated">请注意,在链接时使用这个选项会导致GHC与共享库链接。</target>
        </trans-unit>
        <trans-unit id="15c08fdbeb90f2cad5ab816623c21e3981596c4c" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">请注意，将投射出合成后期未使用的变量。使用&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义的重写规则（请参见&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;）进行简化后，这可以简化为</target>
        </trans-unit>
        <trans-unit id="d081dca768500d8bfebb68333b03740fb45995ab" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5449f9493cc87f80694124b3b78a072657bfaa5" translate="yes" xml:space="preserve">
          <source>Note that we do promote existential data constructors that are otherwise suitable. For example, consider the following:</source>
          <target state="translated">需要注意的是,我们确实提倡存在性数据构造器,否则就会被认为是合适的。例如,考虑以下内容。</target>
        </trans-unit>
        <trans-unit id="314ff3aa2a3753338a78c5d3b1a3ae5cc49a2871" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">请注意，我们必须给 &lt;code&gt;e&lt;/code&gt; 提供类型签名，否则程序将不会进行类型检查，因为类型不明确。虽然可以捕获任何类型的异常，但是请参见&amp;ldquo;捕获所有异常&amp;rdquo;一节（在&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception中&lt;/a&gt;）以获取有关这样做的问题的说明。</target>
        </trans-unit>
        <trans-unit id="7e4fcbcc185ba6453250d12b73264bd5a24e8c57" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6902ece8b4b4299511f807fb9055377eab6a78df" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">请注意，我们必须给 &lt;code&gt;e&lt;/code&gt; 提供类型签名，否则程序将不会进行类型检查，因为类型不明确。虽然可以捕获任何类型的异常，但是请参见&amp;ldquo;捕获所有异常&amp;rdquo;一节（在&lt;a href=&quot;control-exception&quot;&gt;Control.Exception中&lt;/a&gt;）以获取有关这样做的问题的说明。</target>
        </trans-unit>
        <trans-unit id="76ca0561afaae4f1d2c8c729d8d1d3d8826d06c9" translate="yes" xml:space="preserve">
          <source>Note that we have used the &lt;code&gt;the&lt;/code&gt; function to change the type of x from a list to its original numeric type. The variable y, in contrast, is left unchanged from the list form introduced by the grouping.</source>
          <target state="translated">请注意，我们使用 &lt;code&gt;the&lt;/code&gt; 函数从列表中更改x的类型到原来的数值类型。相反，变量y在分组引入的列表形式中保持不变。</target>
        </trans-unit>
        <trans-unit id="09f377418ad5f99dc0f5a64da80f0713a40b3490" translate="yes" xml:space="preserve">
          <source>Note that we only look at the &lt;em&gt;outermost&lt;/em&gt; kind signature to decide which variables to quantify implicitly. As a counter-example, consider &lt;code&gt;M1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd74d100bc4c918985dc8c45e18282ca70173e38" translate="yes" xml:space="preserve">
          <source>Note that we use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkFinally&quot;&gt;forkFinally&lt;/a&gt;&lt;/code&gt; to make sure that the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is written to even if the thread dies or is killed for some reason.</source>
          <target state="translated">请注意，即使线程由于某种原因死掉或被杀死，我们也使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkFinally&quot;&gt;forkFinally&lt;/a&gt;&lt;/code&gt; 确保写入了 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="195b4f7b39fa15cf5686437b038f8e2c25374532" translate="yes" xml:space="preserve">
          <source>Note that we use &lt;code&gt;pseq&lt;/code&gt; rather than &lt;code&gt;seq&lt;/code&gt;. The two are almost equivalent, but differ in their runtime behaviour in a subtle way: &lt;code&gt;seq&lt;/code&gt; can evaluate its arguments in either order, but &lt;code&gt;pseq&lt;/code&gt; is required to evaluate its first argument before its second, which makes it more suitable for controlling the evaluation order in conjunction with &lt;code&gt;par&lt;/code&gt;.</source>
          <target state="translated">请注意，我们使用 &lt;code&gt;pseq&lt;/code&gt; 而不是 &lt;code&gt;seq&lt;/code&gt; 。两者几乎相等，但是它们的运行时行为以微妙的方式有所不同： &lt;code&gt;seq&lt;/code&gt; 可以按任意顺序评估其参数，但要求 &lt;code&gt;pseq&lt;/code&gt; 在其第二个参数之前评估其第一个参数，这使其更适合于控制seq中的评估顺序。与 &lt;code&gt;par&lt;/code&gt; 结合。</target>
        </trans-unit>
        <trans-unit id="a24e29de02329dd8b134e0305ad760b6bb59db9d" translate="yes" xml:space="preserve">
          <source>Note that when unboxed tuples are enabled, &lt;code&gt;(#&lt;/code&gt; is a single lexeme, so for example when using operators like &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;#-&lt;/code&gt; you need to write &lt;code&gt;( # )&lt;/code&gt; and &lt;code&gt;( #- )&lt;/code&gt; rather than &lt;code&gt;(#)&lt;/code&gt; and &lt;code&gt;(#-)&lt;/code&gt;.</source>
          <target state="translated">请注意，启用未装箱的元组时， &lt;code&gt;(#&lt;/code&gt; 是单个词素，因此例如在使用像 &lt;code&gt;#&lt;/code&gt; 和 &lt;code&gt;#-&lt;/code&gt; 这样的运算符时，您需要编写 &lt;code&gt;( # )&lt;/code&gt; 和 &lt;code&gt;( #- )&lt;/code&gt; 而不是 &lt;code&gt;(#)&lt;/code&gt; 和 &lt;code&gt;(#-)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96155a3a07c05ad3d25b4166aba72ebd8c6ede42" translate="yes" xml:space="preserve">
          <source>Note that when using GHC's SMP runtime, it is possible (but rare) to get duplicate events emitted if two CPUs simultaneously evaluate the same thunk that uses &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在使用GHC的SMP运行 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; ，如果两个CPU同时评估使用traceEvent的同一个重击，则有可能（但很少）得到发出的重复事件。</target>
        </trans-unit>
        <trans-unit id="97cde920f55fa2c8be2a7fd409625538b54c2e49" translate="yes" xml:space="preserve">
          <source>Note that when using GHC's SMP runtime, it is possible (but rare) to get duplicate events emitted if two CPUs simultaneously evaluate the same thunk that uses &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在使用GHC的SMP运行 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; ，如果两个CPU同时评估使用traceMarker的同一个重击，则有可能（但很少）获得发出重复事件的信息。</target>
        </trans-unit>
        <trans-unit id="975f537ecdcf165602ed63ca3707c22b645f30bf" translate="yes" xml:space="preserve">
          <source>Note that you can also use these functions for the ISO/IEC 8859-1 and UTF-8 encodings, as the ASCII encoding is equivalent on the codepoints 0-127.</source>
          <target state="translated">请注意,您也可以将这些函数用于ISO/IEC 8859-1和UTF-8编码,因为ASCII编码在0-127码点上是等价的。</target>
        </trans-unit>
        <trans-unit id="988a10d31fdf9259d05bf72a071142f1a3add4ac" translate="yes" xml:space="preserve">
          <source>Note that you do &lt;em&gt;not&lt;/em&gt; need &lt;code&gt;-threaded&lt;/code&gt; in order to use concurrency; the single-threaded runtime supports concurrency between Haskell threads just fine.</source>
          <target state="translated">请注意，你&lt;em&gt;不会&lt;/em&gt;需要 &lt;code&gt;-threaded&lt;/code&gt; 为了使用并发; 单线程运行时恰好支持Haskell线程之间的并发。</target>
        </trans-unit>
        <trans-unit id="e343daabdfa1eb15ae112b3e958a780cd1f3cc0a" translate="yes" xml:space="preserve">
          <source>Note that your command shell does not get to the source file options, they are just included literally in the array of command-line arguments the compiler maintains internally, so you&amp;rsquo;ll be desperately disappointed if you try to glob etc. inside &lt;code&gt;OPTIONS_GHC&lt;/code&gt;.</source>
          <target state="translated">请注意，您的命令外壳程序并没有进入源文件选项，它们只是按字面意义包含在编译器内部维护的命令行参数数组中，因此，如果您尝试在 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 内进行glob等操作，您将非常失望。</target>
        </trans-unit>
        <trans-unit id="95fcdb5b17d3eb800495015f3365bb861935deea" translate="yes" xml:space="preserve">
          <source>Note that, since the head of the resulting expression is produced by an application of the operator to the first element of the list, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an infinite list.</source>
          <target state="translated">请注意，由于结果表达式的开头是通过将运算符应用于列表的第一个元素而生成的，因此 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无限列表中生成终止表达式。</target>
        </trans-unit>
        <trans-unit id="e5d3c4a356999277e59f3b00c955748086b00edd" translate="yes" xml:space="preserve">
          <source>Note that, since the head of the resulting expression is produced by an application of the operator to the first element of the list, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an infinite list.</source>
          <target state="translated">请注意，由于结果表达式的开头是通过将运算符应用于列表的第一个元素而生成的，因此 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无限列表中生成终止表达式。</target>
        </trans-unit>
        <trans-unit id="5f4a6ca2c168bc2286ac44e91edbb190b8b9b499" translate="yes" xml:space="preserve">
          <source>Note that, since the head of the resulting expression is produced by an application of the operator to the first element of the list, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an infinite list.</source>
          <target state="translated">请注意，由于结果表达式的开头是通过将运算符应用于列表的第一个元素而生成的，因此 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无限列表中生成终止表达式。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">请注意:</target>
        </trans-unit>
        <trans-unit id="62ef7150065e1034031843436cbbc944bc66ec36" translate="yes" xml:space="preserve">
          <source>Note that: &lt;code&gt;bitDefault i = 1 &lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt; i&lt;/code&gt;</source>
          <target state="translated">注意： &lt;code&gt;bitDefault i = 1 &lt;a href=&quot;data-bits#v:shiftL&quot;&gt;shiftL&lt;/a&gt; i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="714e1b5dc8ebf117db4aacd3e2ff65c6f7e92a87" translate="yes" xml:space="preserve">
          <source>Note that: &lt;code&gt;testBitDefault x i = (x .&amp;amp;. bit i) /= 0&lt;/code&gt;</source>
          <target state="translated">注意： &lt;code&gt;testBitDefault x i = (x .&amp;amp;. bit i) /= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b868e5fb2332b1924118dd162a57200ec6c0d6b" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag to GHC: GHCi uses dynamically-linked object code (if you are on a platform that supports it), and so in order to use compiled code with GHCi it must be compiled for dynamic linking.</source>
          <target state="translated">请注意GHC 的&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志：GHCi使用动态链接的目标代码（如果您在支持该代码的平台上），因此为了在GHCi中使用已编译的代码，必须对其进行编译以进行动态链接。</target>
        </trans-unit>
        <trans-unit id="6c97a0dc4b9e5fe99b99872bdf8a5aa064c5f01f" translate="yes" xml:space="preserve">
          <source>Note the cheesy &lt;code&gt;.o.hi&lt;/code&gt; rule: It records the dependency of the interface (&lt;code&gt;.hi&lt;/code&gt;) file on the source. The rule says a &lt;code&gt;.hi&lt;/code&gt; file can be made from a &lt;code&gt;.o&lt;/code&gt; file by doing&amp;hellip;nothing. Which is true.</source>
          <target state="translated">请注意俗气的 &lt;code&gt;.o.hi&lt;/code&gt; 规则：它记录了源文件中接口（ &lt;code&gt;.hi&lt;/code&gt; ）文件的依赖性。规则说， &lt;code&gt;.hi&lt;/code&gt; 文件可以由 &lt;code&gt;.o&lt;/code&gt; 文件制成，什么都不做。没错</target>
        </trans-unit>
        <trans-unit id="9f4b885566e702dc04158890b1f14eb9a9f8dc99" translate="yes" xml:space="preserve">
          <source>Note the following details</source>
          <target state="translated">注意以下细节</target>
        </trans-unit>
        <trans-unit id="d60984d1f4be6b4151fa96c42997242fb5bf515f" translate="yes" xml:space="preserve">
          <source>Note the following points:</source>
          <target state="translated">注意以下几点:</target>
        </trans-unit>
        <trans-unit id="579e1fdfe10d47e8222286724942854a900c815f" translate="yes" xml:space="preserve">
          <source>Note the implicit &lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt;&lt;code&gt;-hide-all-packages&lt;/code&gt;&lt;/a&gt; and the fact that it is &lt;a href=&quot;#ghc-flag--package-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;. This is because the environment specifies precisely which packages should be visible.</source>
          <target state="translated">注意隐式的&lt;a href=&quot;#ghc-flag--hide-all-packages&quot;&gt; &lt;code&gt;-hide-all-packages&lt;/code&gt; &lt;/a&gt;，它是&lt;a href=&quot;#ghc-flag--package-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt;，而不是&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;。这是因为环境精确指定了哪些软件包应该可见。</target>
        </trans-unit>
        <trans-unit id="7e9d0f9e3600e2466d48b494d5298e939e029788" translate="yes" xml:space="preserve">
          <source>Note the lower-case &lt;code&gt;proxy&lt;/code&gt; in the definition. This allows any type constructor with just one argument to be passed to the function, for example we could also write</source>
          <target state="translated">请注意定义中的小写 &lt;code&gt;proxy&lt;/code&gt; 。这允许将仅有一个参数的任何类型构造函数传递给函数，例如，我们也可以编写</target>
        </trans-unit>
        <trans-unit id="aaf1c1fd4ff534ae111ecae892bf2bcd7993217c" translate="yes" xml:space="preserve">
          <source>Note the overlapping parsers &lt;code&gt;anyChar&lt;/code&gt; and &lt;code&gt;string &quot;--&amp;gt;&quot;&lt;/code&gt;, and therefore the use of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; combinator.</source>
          <target state="translated">注意重叠的解析器 &lt;code&gt;anyChar&lt;/code&gt; 和 &lt;code&gt;string &quot;--&amp;gt;&quot;&lt;/code&gt; ，因此使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 组合器。</target>
        </trans-unit>
        <trans-unit id="441c0cba9bf13da30347945fe457f85eb0f55a4b" translate="yes" xml:space="preserve">
          <source>Note this also won't work if your &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; has embedded &lt;code&gt;'\0'&lt;/code&gt; characters in the string, as &lt;code&gt;strlen&lt;/code&gt; will return too short a length.</source>
          <target state="translated">请注意，如果您的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 在字符串中嵌入了 &lt;code&gt;'\0'&lt;/code&gt; 字符，这也将不起作用，因为 &lt;code&gt;strlen&lt;/code&gt; 返回的长度太短。</target>
        </trans-unit>
        <trans-unit id="2cc1aaf9aea823467359b53973ba731a918d34af" translate="yes" xml:space="preserve">
          <source>Note this also won't work if your &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; has embedded &lt;code&gt;'\0'&lt;/code&gt; characters in the string, as &lt;code&gt;strlen&lt;/code&gt; will return too short a length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="331df034b2e5e385eb588956cf1683ff013c17c6" translate="yes" xml:space="preserve">
          <source>Note two changes: we included &lt;code&gt;Rts.h&lt;/code&gt;, which defines the GHC-specific external RTS interface, and we called &lt;code&gt;hs_init_ghc()&lt;/code&gt; instead of &lt;code&gt;hs_init()&lt;/code&gt;, passing an argument of type &lt;code&gt;RtsConfig&lt;/code&gt;. &lt;code&gt;RtsConfig&lt;/code&gt; is a struct with various fields that affect the behaviour of the runtime system. Its definition is:</source>
          <target state="translated">请注意两个更改：我们包含了 &lt;code&gt;Rts.h&lt;/code&gt; ，它定义了GHC特定的外部RTS接口，并且我们调用了 &lt;code&gt;hs_init_ghc()&lt;/code&gt; 而不是 &lt;code&gt;hs_init()&lt;/code&gt; ，并传递了 &lt;code&gt;RtsConfig&lt;/code&gt; 类型的参数。 &lt;code&gt;RtsConfig&lt;/code&gt; 是具有各种字段的结构，这些字段会影响运行时系统的行为。其定义是：</target>
        </trans-unit>
        <trans-unit id="dbd0d840fffa0b06839b501dbe88b8d7f54d53d9" translate="yes" xml:space="preserve">
          <source>Note, all arrays are zero-indexed (we assume this when serializing/deserializing)</source>
          <target state="translated">注意,所有的数组都是零索引的(当序列化/反序列化时,我们假定这一点)。</target>
        </trans-unit>
        <trans-unit id="730b394c0c10758545e9a2ade5e0de83b2629e8b" translate="yes" xml:space="preserve">
          <source>Note, however, that, because of platform limitations, the exit code returned by &lt;code&gt;waitForProcess&lt;/code&gt; and &lt;code&gt;getProcessExitCode&lt;/code&gt; cannot not be relied upon when the child uses &lt;code&gt;exec&lt;/code&gt;, even when &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; is used. Specifically, these functions will return the exit code of the *original child* (which always exits with code 0, since it called &lt;code&gt;exec&lt;/code&gt;), not the exit code of the process which carried on with execution after &lt;code&gt;exec&lt;/code&gt;. This is different from the behavior prescribed by POSIX but is the best approximation that can be realised under the restrictions of the Windows process model.</source>
          <target state="translated">但是请注意，由于平台的限制，即使子级使用 &lt;code&gt;exec&lt;/code&gt; ，即使使用 &lt;code&gt;&lt;a href=&quot;system-process#v:use_process_jobs&quot;&gt;use_process_jobs&lt;/a&gt;&lt;/code&gt; ，也不能依赖 &lt;code&gt;waitForProcess&lt;/code&gt; 和 &lt;code&gt;getProcessExitCode&lt;/code&gt; 返回的退出代码。具体来说，这些函数将返回&amp;ldquo;原始子项&amp;rdquo;的退出代码（由于调用 &lt;code&gt;exec&lt;/code&gt; ，它总是以代码0退出），而不是在 &lt;code&gt;exec&lt;/code&gt; 之后执行的进程的退出代码。这与POSIX规定的行为不同，但是是在Windows进程模型的限制下可以实现的最佳近似。</target>
        </trans-unit>
        <trans-unit id="d0a01347d8f201b4f6b2c57fd3b7e47719124dc8" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">注意，第二定律遵循类型为 &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的自由定理和第一定律，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="2830183e18899d4e372b719af094ff5e6b7a9c72" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">注意，第二定律遵循类型为 &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的自由定理和第一定律，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="f0748b6f628eb029f122017d46cd14b10952446d" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">注意，第二定律遵循类型为 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的自由定理和第一定律，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="52fc4b01facd5a339b73681c8694af51bc082a62" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">注意，第二定律遵循类型为 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的自由定理和第一定律，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="96706d72d094cc01d3673e8248f1d0035eb63985" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">注意，第二定律遵循类型为 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的自由定理和第一定律，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="ce105fc66c680b733cba29b7608ec8bace0b2002" translate="yes" xml:space="preserve">
          <source>Note, that the second law follows from the free theorem of the type of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; and the first law, so you need only check that the former condition holds.</source>
          <target state="translated">请注意，第二定律是根据对 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 类型的自由定理和第一定律来进行的，因此您只需要检查前一个条件成立即可。</target>
        </trans-unit>
        <trans-unit id="ef5e0408b764fbf7ba59484a3e0107c8420f818d" translate="yes" xml:space="preserve">
          <source>Note, that we do encode the endianness, however there is no support for mixed endianness setups. This is primarily to ensure that ghc and iserv share the same endianness.</source>
          <target state="translated">请注意,我们确实对endianness进行了编码,但是不支持混合endianness设置。这主要是为了确保ghc和iserv共享相同的endianness。</target>
        </trans-unit>
        <trans-unit id="06b6e80f1bb81b50259a4ccf958ae5b7adb76332" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; can be auto-derived starting with GHC 7.4</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 可以从GHC 7.4开始自动派生</target>
        </trans-unit>
        <trans-unit id="77d1c837a68cd0e75c8157f56af3d19189468e1c" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; can be auto-derived starting with GHC 7.4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b6adb414c47fdecbbaaba70b7564a885e8ef88" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; is the same as &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="cbd96635b83b79b85b8f4e1016e5730892c3d233" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; is a flipped version of the &lt;code&gt;at&lt;/code&gt; combinator from &lt;code&gt;Control.Lens.At&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Control.Lens.At&lt;/code&gt; 中 &lt;code&gt;at&lt;/code&gt; 组合器的翻转版本。</target>
        </trans-unit>
        <trans-unit id="81c735af3f404441fa9d816ccdae0f40e4b55edc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; is a flipped version of the &lt;code&gt;at&lt;/code&gt; combinator from &lt;code&gt;Control.Lens.At&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Control.Lens.At&lt;/code&gt; 中 &lt;code&gt;at&lt;/code&gt; 组合器的翻转版本。</target>
        </trans-unit>
        <trans-unit id="a687870c3a920d75af69fd721da0de7905df07fc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; is a flipped version of the &lt;code&gt;at&lt;/code&gt; combinator from &lt;code&gt;Control.Lens.At&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Control.Lens.At&lt;/code&gt; 中 &lt;code&gt;at&lt;/code&gt; 组合器的翻转版本。</target>
        </trans-unit>
        <trans-unit id="2964ec6af20f2b601e448fae11c342d7b0eed6a4" translate="yes" xml:space="preserve">
          <source>Note: Internally uses &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; for base 2</source>
          <target state="translated">注意：内部使用 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 作为基数2</target>
        </trans-unit>
        <trans-unit id="80e57873e1dc630e8dde69cfc4bc558e5a2fe2bb" translate="yes" xml:space="preserve">
          <source>Note: On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; usually map to the same directory.</source>
          <target state="translated">注意：在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; 通常映射到同一目录。</target>
        </trans-unit>
        <trans-unit id="bbcae614a4a4c25c65679edf7ec5e7b1565fefc7" translate="yes" xml:space="preserve">
          <source>Note: On Windows, &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; usually yield the same result.</source>
          <target state="translated">注意：在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; 通常产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="0333eb6df18590b545c284ef499ea274c56d9557" translate="yes" xml:space="preserve">
          <source>Note: On Windows, &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; usually map to the same directory.</source>
          <target state="translated">注意：在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgData&quot;&gt;XdgData&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgConfig&quot;&gt;XdgConfig&lt;/a&gt;&lt;/code&gt; 通常映射到同一目录。</target>
        </trans-unit>
        <trans-unit id="319f1c37ffa7be2cb2ae10b3aadb89c55a7e270e" translate="yes" xml:space="preserve">
          <source>Note: On Windows, &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; usually yield the same result.</source>
          <target state="translated">注意：在Windows上， &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgDataDirs&quot;&gt;XdgDataDirs&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory-internal#v:XdgConfigDirs&quot;&gt;XdgConfigDirs&lt;/a&gt;&lt;/code&gt; 通常产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="2d06096a22bf57ecce3b66e194accc6d77193dc1" translate="yes" xml:space="preserve">
          <source>Note: Result of div/0 undefined</source>
          <target state="translated">注:div/0的结果未定义</target>
        </trans-unit>
        <trans-unit id="cbd627c4c16ef632d3fa099449c00647abd8ea5f" translate="yes" xml:space="preserve">
          <source>Note: Since for signed fixed-width integer types, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt; &amp;lt; 0&lt;/code&gt;, the result may be negative if one of the arguments is &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; (and necessarily is if the other is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt;) for such types.</source>
          <target state="translated">注意：由于对于带符号的固定宽度整数类型， &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt; &amp;lt; 0&lt;/code&gt; ，对于此类类型，如果其中一个参数为 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; （并且必须为另一个为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; ），则结果可能为负。</target>
        </trans-unit>
        <trans-unit id="674e78f56244223095d66376333e081f352405fa" translate="yes" xml:space="preserve">
          <source>Note: The default implementation for this method is intentionally naive. However, the instances provided for the primitive integral types are implemented using CPU specific machine instructions.</source>
          <target state="translated">注:该方法的默认实现是故意幼稚的。但是,为基元积分类型提供的实例是使用CPU特定的机器指令来实现的。</target>
        </trans-unit>
        <trans-unit id="7818d870c76cf216b00e434a150dca33f7df98b2" translate="yes" xml:space="preserve">
          <source>Note: The directory may not actually exist, in which case you would need to create it with file mode &lt;code&gt;700&lt;/code&gt; (i.e. only accessible by the owner).</source>
          <target state="translated">注意：该目录可能实际上不存在，在这种情况下，您需要使用文件模式 &lt;code&gt;700&lt;/code&gt; 创建目录（即只能由所有者访问）。</target>
        </trans-unit>
        <trans-unit id="0cd8a114aa9321f1d0d10c53fc749989dbf8e3df" translate="yes" xml:space="preserve">
          <source>Note: The instances for &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; violate reflexivity for &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的实例违反了 &lt;code&gt;NaN&lt;/code&gt; 的反射性。</target>
        </trans-unit>
        <trans-unit id="02742f900a83eee688841797767d74d57b9a3632" translate="yes" xml:space="preserve">
          <source>Note: The out-list may contain keys that don't correspond to nodes of the graph; they are ignored.</source>
          <target state="translated">注意:out-list可能包含与图的节点不对应的键,它们被忽略。</target>
        </trans-unit>
        <trans-unit id="e38f2e80b32086e27bef2b0266717c504d1d9973" translate="yes" xml:space="preserve">
          <source>Note: This function will overflow the Int for large integers.</source>
          <target state="translated">注意:对于大的整数,这个函数会溢出Int。</target>
        </trans-unit>
        <trans-unit id="9c37eef5d6056fc160330417f3bea3c9d7af78c9" translate="yes" xml:space="preserve">
          <source>Note: You should worry about UAC (User Account Control) when use this module's function in your application:</source>
          <target state="translated">注意:在您的应用程序中使用该模块的功能时,您应该担心UAC(用户帐户控制)。</target>
        </trans-unit>
        <trans-unit id="ac778c93d19c8f9b9b2156b24f137765a286116d" translate="yes" xml:space="preserve">
          <source>Note: You should worry about file system type when use this module's function in your application:</source>
          <target state="translated">注意:在您的应用程序中使用该模块的功能时,您需要注意文件系统类型。</target>
        </trans-unit>
        <trans-unit id="a935c141a1282c40c4d13949ec0910ffa24a0fce" translate="yes" xml:space="preserve">
          <source>Note: adding a finalizer to a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:addFinalizer&quot;&gt;addFinalizer&lt;/a&gt;&lt;/code&gt; won't work; use the specialised version &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; instead. For discussion see the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; type. .</source>
          <target state="translated">注：添加一个终结的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:addFinalizer&quot;&gt;addFinalizer&lt;/a&gt;&lt;/code&gt; 将无法正常工作; 请改用专用版本 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 。有关讨论，请参见 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 类型。。</target>
        </trans-unit>
        <trans-unit id="2097d2502bf72066e6338b00241515b264646719" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;access&lt;/code&gt;.</source>
          <target state="translated">注意：通话 &lt;code&gt;access&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47a5ce04e50da050a609249923f505414a2b6c3a" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;chmod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4d725c5c43aa8cc0a4915dd3466f0457eca94a8" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;chown&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;chown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81ad88f149f3063c197001795818b6823154dc14" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;fchmod&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;fchmod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6030cb951c6f266563f54a519db1f69cbabc10d8" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;fchown&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;fchown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dd9f0dc0d1c8559fbb770086e670ffe8174b556" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;fpathconf&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;fpathconf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c784018b1764520d2f3f72bfaf80d9f4a298c67" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;fstat&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;fstat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b3f3b1b22a3530df7e0c4f2e3bac4484512a52f" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;ftruncate&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;ftruncate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eebdf5750908ee142920fee74c1caeed35366551" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;futimens&lt;/code&gt; or &lt;code&gt;futimes&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;futimens&lt;/code&gt; 或 &lt;code&gt;futimes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90f9647756a74661a9bdc0a9c20d4908f0e7a503" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;futimes&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;futimes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23c23e7db83b3608ec2d06f627e484942cc29d18" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;lchown&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;lchown&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c155b2e5620e073cb17c1c7c209997815551141a" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">注意：通话 &lt;code&gt;link&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd88efd3faf02cea25b3fced565fc1318e09889c" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;lstat&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;lstat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c4b9527d6aeade9b87f9ffcf35e25c0e1d6597e" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;lutimes&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;lutimes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="641e26b8beeb20f2884975f28668f2c405e6b0b0" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;mkfifo&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;mkfifo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37c59507b9516717f0afe20d3d052ddf9908362d" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;mknod&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;mknod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81ed673abd5a82dc7e99410acf38ec2277555bfb" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;pathconf&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;pathconf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="039d8fa52ca80812eb645d692ce3ef11b0cb3ca7" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;readlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1366a63986732619d6beabc26255cf1b662685a6" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;rename&lt;/code&gt;.</source>
          <target state="translated">注意：通话 &lt;code&gt;rename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5782d43e3522ff7210266c96575bbd5b68e34826" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;stat&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;stat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65ff4e6ead5e4f29f97706aaac05101e76a8ac86" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;symlink&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c207e69e9ae7e528e940038ec03e5d5bc0aa3f34" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;truncate&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;truncate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e464692da7e94ff8a1d77187f87ac0f6f3b8682" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;umask&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;umask&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c12b05171f72e9faf61a3e799d01d78f9ed72bd7" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;unlink&lt;/code&gt;.</source>
          <target state="translated">注意：通话 &lt;code&gt;unlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcb5b167f7c968ad10d575603b69054a4b118017" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;utime&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;utime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dffccc96b86fbac0369ca9ed5019ac9f7f5061d" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;utimensat&lt;/code&gt; or &lt;code&gt;lutimes&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;utimensat&lt;/code&gt; 或 &lt;code&gt;lutimes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3369755b47d8acc74ee74f75c779638972380854" translate="yes" xml:space="preserve">
          <source>Note: calls &lt;code&gt;utimensat&lt;/code&gt; or &lt;code&gt;utimes&lt;/code&gt;.</source>
          <target state="translated">注意：调用 &lt;code&gt;utimensat&lt;/code&gt; 或 &lt;code&gt;utimes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22fedcf56957f2b61dfd1fe752153d0eddeba4cd" translate="yes" xml:space="preserve">
          <source>Note: changing directories causes all currently loaded modules to be unloaded. This is because the search path is usually expressed using relative directories, and changing the search path in the middle of a session is not supported.</source>
          <target state="translated">注意:改变目录会导致所有当前加载的模块被卸载。这是因为搜索路径通常使用相对目录来表示,不支持在会话中间改变搜索路径。</target>
        </trans-unit>
        <trans-unit id="0baa49f63d6662a3ea39a54e91e2f9bf0dd4e3c3" translate="yes" xml:space="preserve">
          <source>Note: consider using the more general &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：考虑使用更通用的 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;system-process#v:runProcess&quot;&gt;runProcess&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c493553c9e68ae21e1845f6961a2d86f0cd1b1a7" translate="yes" xml:space="preserve">
          <source>Note: for various murky reasons, stdout and stderr handles are not necessarily flushed when the compiler finishes running, so you should flush them yourself.</source>
          <target state="translated">注意:由于各种模糊的原因,stdout和stderr句柄在编译器完成运行时不一定会被刷新,所以你应该自己刷新它们。</target>
        </trans-unit>
        <trans-unit id="b613c731654056bb4ffa8acaf76928a12a8fe432" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;p&lt;/code&gt; is not actually antitone, then &lt;code&gt;spanAntitone&lt;/code&gt; will split the map at some &lt;em&gt;unspecified&lt;/em&gt; point where the predicate switches from holding to not holding (where the predicate is seen to hold before the first key and to fail after the last key).</source>
          <target state="translated">注意：如果 &lt;code&gt;p&lt;/code&gt; 实际上不是反调，则 &lt;code&gt;spanAntitone&lt;/code&gt; 会在&lt;em&gt;未指定的&lt;/em&gt;点上拆分映射，在该点上谓词从保持切换为不保持（该谓词在第一个键之前保持，而在最后一个键之后失败）。</target>
        </trans-unit>
        <trans-unit id="ae4388084290b5d7a3bdeb27693194ba96d9e296" translate="yes" xml:space="preserve">
          <source>Note: if &lt;code&gt;p&lt;/code&gt; is not actually antitone, then &lt;code&gt;spanAntitone&lt;/code&gt; will split the set at some &lt;em&gt;unspecified&lt;/em&gt; point where the predicate switches from holding to not holding (where the predicate is seen to hold before the first element and to fail after the last element).</source>
          <target state="translated">注意：如果 &lt;code&gt;p&lt;/code&gt; 实际上不是反调，则 &lt;code&gt;spanAntitone&lt;/code&gt; 会在&lt;em&gt;未指定的&lt;/em&gt;点上将集合拆分，在该点上谓词从保持切换为不保持（该谓词在第一个元素之前保持，而在最后一个元素之后失败）。</target>
        </trans-unit>
        <trans-unit id="ee69151d314995840dfa893a521205cf26ed2e2f" translate="yes" xml:space="preserve">
          <source>Note: if you will be working with files containing binary data, you'll want to be using &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：如果要使用包含二进制数据的文件，则需要使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea2673c5a22c74869057def36152984def9b63f0" translate="yes" xml:space="preserve">
          <source>Note: if you will be working with files containing binary data, you'll want to be using &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：如果要使用包含二进制数据的文件，则需要使用 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a07912622d0b837b6fccc970a6e823a1ae01ea0" translate="yes" xml:space="preserve">
          <source>Note: in GHC, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; should be called from the main program thread in order to exit the process. When called from another thread, &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; will throw an &lt;code&gt;ExitException&lt;/code&gt; as normal, but the exception will not cause the process itself to exit.</source>
          <target state="translated">注意：在GHC中， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 主程序线程中调用exitWith，以退出该进程。当从另一个线程调用时， &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 会照常抛出 &lt;code&gt;ExitException&lt;/code&gt; ，但是该异常不会导致进程本身退出。</target>
        </trans-unit>
        <trans-unit id="bb017a16224e898b6ffb988ed0bbe310767a5f54" translate="yes" xml:space="preserve">
          <source>Note: no other base module should import this module.</source>
          <target state="translated">注:其他基础模块不得导入此模块。</target>
        </trans-unit>
        <trans-unit id="d0e9855cc09c89d974c2cb2617285413cf098e03" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="2c3066659d43a1497598449b3caf33fb26732423" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="470bf041c378cc926d1b7954cf1cf709d99bc3b9" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="45c32ee5b6384c005264d7901f76bb36e623444b" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="aa7fe119dd59f69aad0b1fc189959fe661bfb05d" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="efb202994ee3d3218df857fdac6cb270273fad26" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="e8574c06639a12a57d5964a738e28ef433d4381c" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b6afd996aff4ed599e852d040ffe628aecd7c3f1" translate="yes" xml:space="preserve">
          <source>Note: on Windows and with Haskell implementation other than GHC, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上以及使用GHC以外的Haskell实现时，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hPut&quot;&gt;hPut&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c084ddabd74d6b6909e8ec15589cb5a744e9692b" translate="yes" xml:space="preserve">
          <source>Note: on Windows, if the process was a shell command created by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt;, or created by &lt;code&gt;&lt;a href=&quot;system-process#v:runCommand&quot;&gt;runCommand&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-process#v:runInteractiveCommand&quot;&gt;runInteractiveCommand&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; will only terminate the shell, not the command itself. On Unix systems, both processes are in a process group and will be terminated together.</source>
          <target state="translated">注意：在Windows上，如果进程是由 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 创建的shell命令，或者是由 &lt;code&gt;&lt;a href=&quot;system-process#v:runCommand&quot;&gt;runCommand&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-process#v:runInteractiveCommand&quot;&gt;runInteractiveCommand&lt;/a&gt;&lt;/code&gt; 创建的shell命令，则 &lt;code&gt;&lt;a href=&quot;system-process#v:terminateProcess&quot;&gt;terminateProcess&lt;/a&gt;&lt;/code&gt; 将仅终止该shell，而不终止该命令本身。在Unix系统上，两个进程都在一个进程组中，并且将一起终止。</target>
        </trans-unit>
        <trans-unit id="2f6dbfc9a1fde96f341be1c1077f8b56e055e450" translate="yes" xml:space="preserve">
          <source>Note: on Windows, if the result is an executable file, the extension &amp;ldquo;&lt;code&gt;.exe&lt;/code&gt;&amp;rdquo; is added if the specified filename does not already have an extension. Thus</source>
          <target state="translated">注意：在Windows上，如果结果是可执行文件，则在指定的文件名尚没有扩展名的情况下，将添加扩展名&amp;ldquo; &lt;code&gt;.exe&lt;/code&gt; &amp;rdquo;。从而</target>
        </trans-unit>
        <trans-unit id="f64cdc1c8388b25ba0abb5fc5d63de4643c82376" translate="yes" xml:space="preserve">
          <source>Note: see &lt;code&gt;chmod&lt;/code&gt;.</source>
          <target state="translated">注意：请参阅 &lt;code&gt;chmod&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be040b0811689aa8aa9d5c45cb215e66188077b4" translate="yes" xml:space="preserve">
          <source>Note: size parameter (times &lt;code&gt;sizeof(GmpLimb)&lt;/code&gt;) must be less or equal to its &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#v:sizeofByteArray-35-&quot;&gt;sizeofByteArray#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：size参数（times &lt;code&gt;sizeof(GmpLimb)&lt;/code&gt; ）必须小于或等于其 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#v:sizeofByteArray-35-&quot;&gt;sizeofByteArray#&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab465ac8e9035afbcd775312d9253baee0527e0" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; should be placed in binary mode with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; to work correctly.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 应使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 置于二进制模式，以使 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 正常工作。</target>
        </trans-unit>
        <trans-unit id="e744fc2c55c810e55221c484fe135e425eeecdb6" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; should be placed in binary mode with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; to work correctly.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 应使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 置于二进制模式，以使 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; 正常工作。</target>
        </trans-unit>
        <trans-unit id="d9b30040f4397b2f911a65307971bd5711cb73a0" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; should be placed in binary mode with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b7e1e2845c3bc077710b5f8ff529e652a30481" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; should be placed in binary mode with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; to work correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd72112ea2f921d76ec2535fa06bb9c0d5ee66a" translate="yes" xml:space="preserve">
          <source>Note: the directory may not actually exist, in which case you would need to create it. It is expected that the parent directory exists and is writable.</source>
          <target state="translated">注意:该目录可能并不存在,在这种情况下,你需要创建它。预计父目录是存在的,并且是可写的。</target>
        </trans-unit>
        <trans-unit id="905ee1ed0e8a9a4a64475bdb86e9e45b5fa215dd" translate="yes" xml:space="preserve">
          <source>Note: the final statement must match one of these patterns exactly:</source>
          <target state="translated">注意:最后的语句必须与这些模式之一完全匹配。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="82ff0a7b103c8f1f65e9521f63650d629b1a809b" translate="yes" xml:space="preserve">
          <source>Notes about &lt;code&gt;exec&lt;/code&gt; on Windows</source>
          <target state="translated">关于Windows上的 &lt;code&gt;exec&lt;/code&gt; 的注意事项</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="964b5c5b84d75722d090e7870f65fb2d7ea468f5" translate="yes" xml:space="preserve">
          <source>Nothing happened! Here&amp;rsquo;s another lesson: newly compiled modules aren&amp;rsquo;t picked up by &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, only &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">什么都没有发生！这里的另一个教训：新编译的模块没有被拾起&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;，只&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="53e0c13486116b5f437ae0c07f239ea24aca4e1a" translate="yes" xml:space="preserve">
          <source>Notice also that the &lt;em&gt;order&lt;/em&gt; of class parameters becomes important, since we can only derive instances for the last one. If the &lt;code&gt;StateMonad&lt;/code&gt; class above were instead defined as</source>
          <target state="translated">还要注意，类参数的&lt;em&gt;顺序&lt;/em&gt;很重要，因为我们只能派生最后一个实例。如果将上面的 &lt;code&gt;StateMonad&lt;/code&gt; 类定义为</target>
        </trans-unit>
        <trans-unit id="00c9b29a34f5499d2e9bea194ad83800538a2e0c" translate="yes" xml:space="preserve">
          <source>Notice here that the &lt;code&gt;Maybe&lt;/code&gt; type is parameterised by the &lt;em&gt;polymorphic&lt;/em&gt; type &lt;code&gt;(forall a. [a] -&amp;gt; [a])&lt;/code&gt;. However &lt;em&gt;the extension should be considered highly experimental, and certainly un-supported&lt;/em&gt;. You are welcome to try it, but please don&amp;rsquo;t rely on it working consistently, or working the same in subsequent releases. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ImpredicativePolymorphism&quot;&gt;this wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">注意这里 &lt;code&gt;Maybe&lt;/code&gt; 类型是由&lt;em&gt;多态&lt;/em&gt;类型 &lt;code&gt;(forall a. [a] -&amp;gt; [a])&lt;/code&gt; 。但是，&lt;em&gt;该扩展应该被认为是高度实验性的，并且肯定不受支持&lt;/em&gt;。欢迎您尝试使用它，但是请不要依赖它始终如一地工作，也不要依赖于以后的发行版中的相同工作。有关更多详细信息，请参&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ImpredicativePolymorphism&quot;&gt;见此Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc6a18bab0d3bb67ccb79f1e6008765fc4f48e2b" translate="yes" xml:space="preserve">
          <source>Notice here that the &lt;code&gt;Maybe&lt;/code&gt; type is parameterised by the &lt;em&gt;polymorphic&lt;/em&gt; type &lt;code&gt;(forall a. [a] -&amp;gt; [a])&lt;/code&gt;. However &lt;em&gt;the extension should be considered highly experimental, and certainly un-supported&lt;/em&gt;. You are welcome to try it, but please don&amp;rsquo;t rely on it working consistently, or working the same in subsequent releases. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/impredicative-polymorphism&quot;&gt;this wiki page&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5de621f10f81f3f42fbb7d8765349ac0e858fc" translate="yes" xml:space="preserve">
          <source>Notice how every constructor of &lt;code&gt;E&lt;/code&gt; utilizes some sort of existential quantification, but only the argument of &lt;code&gt;E1&lt;/code&gt; is actually &amp;ldquo;folded over&amp;rdquo;. This is because we make a deliberate choice to only fold over universally polymorphic types that are syntactically equivalent to the last type parameter. In particular:</source>
          <target state="translated">请注意， &lt;code&gt;E&lt;/code&gt; 的每个构造函数如何利用某种形式的存在性量化，但实际上只有 &lt;code&gt;E1&lt;/code&gt; 的参数被&amp;ldquo;覆盖&amp;rdquo;了。这是因为我们故意选择仅折叠在语法上等同于last类型参数的通用多态类型。特别是：</target>
        </trans-unit>
        <trans-unit id="6f333808bd82420a615128b3e13ffe515c8a7857" translate="yes" xml:space="preserve">
          <source>Notice that</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="93b754f4099d6d9a61c017edf4751f109c263ebd" translate="yes" xml:space="preserve">
          <source>Notice that C didn&amp;rsquo;t need to trust package Wuggle; the machine checking is enough. C only needs to trust packages that contain &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">注意，C不需要信任Wuggle包；机器检查就足够了。C只需要信任包含&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;模块的软件包。</target>
        </trans-unit>
        <trans-unit id="bff9e3af9d3e69ccca8ea13acc452ca2fd25796c" translate="yes" xml:space="preserve">
          <source>Notice that GADT-style syntax generalises existential types (&lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;). For example, these two declarations are equivalent:</source>
          <target state="translated">请注意，GADT样式的语法概括了存在类型（&lt;a href=&quot;#existential-quantification&quot;&gt;存在量化的数据构造函数&lt;/a&gt;）。例如，这两个声明是等效的：</target>
        </trans-unit>
        <trans-unit id="553b556eabe0c77570a3bf578e47d4e277ab246a" translate="yes" xml:space="preserve">
          <source>Notice that GHC always adds implicit quantifiers &lt;em&gt;at the outermost level&lt;/em&gt; of a user-written type; it does &lt;em&gt;not&lt;/em&gt; find the inner-most possible quantification point. For example:</source>
          <target state="translated">请注意，GHC始终&lt;em&gt;在&lt;/em&gt;用户编写的类型&lt;em&gt;的最外层&lt;/em&gt;添加隐式量词。它并&lt;em&gt;没有&lt;/em&gt;找到内最有可能的量化点。例如：</target>
        </trans-unit>
        <trans-unit id="6c6aa2291aadd5f99fafa11b2ff64b43b4b4001b" translate="yes" xml:space="preserve">
          <source>Notice that a top-level binding that is affected by the monomorphism restriction is not closed, and hence may in turn prevent generalisation of bindings that mention it.</source>
          <target state="translated">注意,受单形限制影响的顶层绑定不是封闭的,因此可能反过来阻止提到它的绑定的泛化。</target>
        </trans-unit>
        <trans-unit id="106f2542b9ad1a1791ff62a736a20934f1332297" translate="yes" xml:space="preserve">
          <source>Notice that since &lt;code&gt;myLength1&lt;/code&gt; was defined with an explicit type signature, &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; reports that all of its type variables are available for type application. On the other hand, &lt;code&gt;myLength2&lt;/code&gt; was not given a type signature. As a result, all of its type variables are surrounded with braces, and trying to use visible type application with &lt;code&gt;myLength2&lt;/code&gt; fails.</source>
          <target state="translated">注意，由于 &lt;code&gt;myLength1&lt;/code&gt; 是用显式类型签名定义的，所以&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;报告其所有类型变量都可用于类型应用程序。另一方面，未给 &lt;code&gt;myLength2&lt;/code&gt; 提供类型签名。结果，其所有类型变量都用花括号括起来，并且尝试对 &lt;code&gt;myLength2&lt;/code&gt; 使用可见类型应用程序失败。</target>
        </trans-unit>
        <trans-unit id="3afaa45a394da4b41eb772316597dd6a43b099f4" translate="yes" xml:space="preserve">
          <source>Notice that since the command-line passed to the linker is rather involved, you probably want to use &lt;code&gt;ghc&lt;/code&gt; to do the final link of your `mixed-language&amp;rsquo; application. This is not a requirement though, just try linking once with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; on to see what options the driver passes through to the linker.</source>
          <target state="translated">注意，由于传递给链接器的命令行相当复杂，因此您可能希望使用 &lt;code&gt;ghc&lt;/code&gt; 来完成&amp;ldquo; mixed-language&amp;rdquo;应用程序的最终链接。不过，这不是必需的，只需尝试将&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;链接一次即可查看驱动程序传递给链接器的选项。</target>
        </trans-unit>
        <trans-unit id="0cdaf211f37e5b03ee9118a3708a26c5977a2cbc" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;seq&lt;/code&gt; is added only in the translation to Core If we did it in Haskell source, thus</source>
          <target state="translated">注意，如果我们在Haskell源代码中将 &lt;code&gt;seq&lt;/code&gt; 添加到Core中，则仅在翻译中添加了seq</target>
        </trans-unit>
        <trans-unit id="ad31586b6779a56318944b9ce1f29dd7560ef27a" translate="yes" xml:space="preserve">
          <source>Notice that the boolean value returned is just a snapshot of the state of the MVar. By the time you get to react on its result, the MVar may have been filled (or emptied) - so be extremely careful when using this operation. Use &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; instead if possible.</source>
          <target state="translated">请注意，返回的布尔值只是MVar状态的快照。在您对结果产生反应之前，MVar可能已装满（或倒空）-因此在使用此操作时要格外小心。如果可能，请改用 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e1ecc3fd950dbbe0cc120eb2c026af385ef2b1" translate="yes" xml:space="preserve">
          <source>Notice that the boolean value returned is just a snapshot of the state of the MVar. By the time you get to react on its result, the MVar may have been filled (or emptied) - so be extremely careful when using this operation. Use &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; instead if possible.</source>
          <target state="translated">请注意，返回的布尔值只是MVar状态的快照。在您对结果产生反应之前，MVar可能已装满（或倒空）-因此在使用此操作时要格外小心。如果可能，请改用 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a38f193ac7cf511a7d9b66a274ed6b21ec714e3f" translate="yes" xml:space="preserve">
          <source>Notice that the extension does not affect equality constraints in an instance context; they are permitted by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">注意，扩展不会影响实例上下文中的相等约束；它们被&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;允许。</target>
        </trans-unit>
        <trans-unit id="68d3d7ffa432ffbf89c1390ad1ba459abda3d14c" translate="yes" xml:space="preserve">
          <source>Notice that the return type of the constructors is not always &lt;code&gt;Term a&lt;/code&gt;, as is the case with ordinary data types. This generality allows us to write a well-typed &lt;code&gt;eval&lt;/code&gt; function for these &lt;code&gt;Terms&lt;/code&gt;:</source>
          <target state="translated">请注意，构造函数的返回类型并不总是 &lt;code&gt;Term a&lt;/code&gt; ，与普通数据类型一样。这种普遍性使我们可以为这些 &lt;code&gt;Terms&lt;/code&gt; 编写类型明确的 &lt;code&gt;eval&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="54ceac8f09d6cd564081b0cfb5c886543152f775" translate="yes" xml:space="preserve">
          <source>Notice that the type for &lt;code&gt;f&lt;/code&gt; allows the two parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to be assigned different types, even though it attempts to insert each of the two values, one after the other, into the same collection. If we&amp;rsquo;re trying to model collections that contain only one type of value, then this is clearly an inaccurate type. Worse still, the definition for g is accepted, without causing a type error. As a result, the error in this code will not be flagged at the point where it appears. Instead, it will show up only when we try to use &lt;code&gt;g&lt;/code&gt;, which might even be in a different module.</source>
          <target state="translated">请注意， &lt;code&gt;f&lt;/code&gt; 的类型允许为两个参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 分配不同的类型，即使它试图将两个值中的每个值依次插入同一个集合中。如果我们试图对仅包含一种类型的值的集合进行建模，那么这显然是不准确的类型。更糟糕的是，g的定义被接受，而不会引起类型错误。结果，该代码中的错误将不会在出现的位置进行标记。相反，它仅在我们尝试使用 &lt;code&gt;g&lt;/code&gt; 时才会显示，g甚至可能在其他模块中。</target>
        </trans-unit>
        <trans-unit id="5f1d96bc469648f83d30d647d11b32d3f6914897" translate="yes" xml:space="preserve">
          <source>Notice that the type variable &lt;code&gt;a&lt;/code&gt; in the type of &lt;code&gt;MkFoo&lt;/code&gt; does not appear in the data type itself, which is plain &lt;code&gt;Foo&lt;/code&gt;. For example, the following expression is fine:</source>
          <target state="translated">请注意， &lt;code&gt;MkFoo&lt;/code&gt; 类型的类型变量 &lt;code&gt;a&lt;/code&gt; 不会出现在数据类型本身中，即普通 &lt;code&gt;Foo&lt;/code&gt; 。例如，以下表达式很好：</target>
        </trans-unit>
        <trans-unit id="c2cacddb0032e02b56801b19bb25767c6b4b2aa5" translate="yes" xml:space="preserve">
          <source>Notice that these rules are not influenced by flag settings in the client module, where the instances are &lt;em&gt;used&lt;/em&gt;. These rules make it possible for a library author to design a library that relies on overlapping instances without the client having to know.</source>
          <target state="translated">请注意，这些规则不受&lt;em&gt;使用&lt;/em&gt;实例的客户端模块中标志设置的影响。这些规则使图书馆作者可以设计一个依赖重叠实例的图书馆，而客户不必知道。</target>
        </trans-unit>
        <trans-unit id="f517de781679d2f59e7171cbc1b0d4c1a9102403" translate="yes" xml:space="preserve">
          <source>Notice that this is a tiny bit more restrictive than the expression &lt;code&gt;MkT 42 x&lt;/code&gt; which would not require &lt;code&gt;(Eq a)&lt;/code&gt;.</source>
          <target state="translated">请注意，这比不需要的表达式 &lt;code&gt;MkT 42 x&lt;/code&gt; &lt;code&gt;(Eq a)&lt;/code&gt; 更具限制性。</target>
        </trans-unit>
        <trans-unit id="003f05d1557b084246e0ee7d6debdcbfd568cdc0" translate="yes" xml:space="preserve">
          <source>Notice that we do &lt;em&gt;not&lt;/em&gt; put bangs on nested patterns. For example</source>
          <target state="translated">注意，我们&lt;em&gt;不会&lt;/em&gt;在嵌套模式上使用刘海。例如</target>
        </trans-unit>
        <trans-unit id="9bdcc186dbf6e6f1c8fa171c8965b88ff5dc5e8b" translate="yes" xml:space="preserve">
          <source>Notice that we gave a type signature to &lt;code&gt;f&lt;/code&gt;, so GHC had to &lt;em&gt;check&lt;/em&gt; that &lt;code&gt;f&lt;/code&gt; has the specified type. Suppose instead we do not give a type signature, asking GHC to &lt;em&gt;infer&lt;/em&gt; it instead. In this case, GHC will refrain from simplifying the constraint &lt;code&gt;C Int [b]&lt;/code&gt; (for the same reason as before) but, rather than rejecting the program, it will infer the type</source>
          <target state="translated">请注意，我们给了一个类型签名 &lt;code&gt;f&lt;/code&gt; ，所以GHC不得不&lt;em&gt;检查&lt;/em&gt;该 &lt;code&gt;f&lt;/code&gt; 具有指定的类型。假设我们没有给出类型签名，而是要求GHC进行&lt;em&gt;推断&lt;/em&gt;。在这种情况下，GHC将避免简化约束 &lt;code&gt;C Int [b]&lt;/code&gt; （由于与以前相同的原因），但它会拒绝类型，而不是拒绝程序。</target>
        </trans-unit>
        <trans-unit id="15c7b54b4dfbcc9256d5d4ff6fc20f5ba1def337" translate="yes" xml:space="preserve">
          <source>Notice that we named the command &lt;code&gt;:.&lt;/code&gt;, by analogy with the &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; Unix shell command that does the same thing.</source>
          <target state="translated">注意，我们将命令命名为 &lt;code&gt;:.&lt;/code&gt; 类似于&amp;ldquo; &lt;code&gt;.&lt;/code&gt; 做同样事情的Unix shell命令。</target>
        </trans-unit>
        <trans-unit id="f58c38490fd1aa839924248ed27f036d2894c6f4" translate="yes" xml:space="preserve">
          <source>Notice that, since &lt;code&gt;Monad&lt;/code&gt; is a constructor class, the instance is a &lt;em&gt;partial application&lt;/em&gt; of the newtype, not the entire left hand side. We can imagine that the type declaration is &amp;ldquo;eta-converted&amp;rdquo; to generate the context of the instance declaration.</source>
          <target state="translated">请注意，由于 &lt;code&gt;Monad&lt;/code&gt; 是构造函数类，因此该实例是newtype 的&lt;em&gt;部分应用程序&lt;/em&gt;，而不是整个左侧。我们可以想象类型声明被&amp;ldquo; eta转换&amp;rdquo;以生成实例声明的上下文。</target>
        </trans-unit>
        <trans-unit id="5a032b6c9e39feada9a5daefc6215d234b296f13" translate="yes" xml:space="preserve">
          <source>Notice that, unlike the situation when declaring an existential, there is no &lt;code&gt;forall&lt;/code&gt;, because the &lt;code&gt;Num&lt;/code&gt; constrains the data type&amp;rsquo;s universally quantified type variable &lt;code&gt;a&lt;/code&gt;. A constructor may have both universal and existential type variables: for example, the following two declarations are equivalent:</source>
          <target state="translated">请注意，与声明一个存在物的情况不同，它不会 &lt;code&gt;forall&lt;/code&gt; 存在，因为 &lt;code&gt;Num&lt;/code&gt; 限制了数据类型的通用量化类型变量 &lt;code&gt;a&lt;/code&gt; 。构造函数可以同时具有通用和存在类型变量：例如，以下两个声明是等效的：</target>
        </trans-unit>
        <trans-unit id="5a05411fd54d44b0e8b85296aa89e70109d6f8ae" translate="yes" xml:space="preserve">
          <source>Notice the &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt;! That prevents &lt;code&gt;(:)&lt;/code&gt; from being inlined when compiling &lt;code&gt;PrelBase&lt;/code&gt;, so that an importing module will &amp;ldquo;see&amp;rdquo; the &lt;code&gt;(:)&lt;/code&gt;, and can match it on the LHS of a rule. &lt;code&gt;INLINE&lt;/code&gt; prevents any inlining happening in the RHS of the &lt;code&gt;INLINE&lt;/code&gt; thing. I regret the delicacy of this.</source>
          <target state="translated">注意&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;！这样可以防止在编译 &lt;code&gt;PrelBase&lt;/code&gt; 时内联 &lt;code&gt;(:)&lt;/code&gt; ，以便导入模块将&amp;ldquo;看到&amp;rdquo; &lt;code&gt;(:)&lt;/code&gt; ，并可以在规则的LHS上进行匹配。 &lt;code&gt;INLINE&lt;/code&gt; 防止 &lt;code&gt;INLINE&lt;/code&gt; 事物的RHS中发生任何内联。我对此感到遗憾。</target>
        </trans-unit>
        <trans-unit id="dfc12e02833bfccc09f794f1f49ea08204cd679e" translate="yes" xml:space="preserve">
          <source>Notice the two different types reported for the two different occurrences of &lt;code&gt;_x&lt;/code&gt;.</source>
          <target state="translated">请注意，针对 &lt;code&gt;_x&lt;/code&gt; 的两次不同出现报告了两种不同的类型。</target>
        </trans-unit>
        <trans-unit id="6604e09c0f282b92ddefa954435f8ea32da60f44" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;g&lt;/code&gt; is inlined into &lt;code&gt;h&lt;/code&gt;, but &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s &lt;code&gt;RULE&lt;/code&gt; has no chance to fire. If instead GHC had first inlined &lt;code&gt;g&lt;/code&gt; into &lt;code&gt;h&lt;/code&gt; then there would have been a better chance that &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s &lt;code&gt;RULE&lt;/code&gt; might fire.</source>
          <target state="translated">现在 &lt;code&gt;g&lt;/code&gt; 内联到 &lt;code&gt;h&lt;/code&gt; ，但是 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;RULE&lt;/code&gt; 没有机会触发。相反，如果GHC首先将 &lt;code&gt;g&lt;/code&gt; 内联到 &lt;code&gt;h&lt;/code&gt; 中,则 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;RULE&lt;/code&gt; 可能会触发。</target>
        </trans-unit>
        <trans-unit id="c1fc5a6daa0c6ffe63bac8e9b2d756cf37c94575" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;g&lt;/code&gt; is inlined into &lt;code&gt;h&lt;/code&gt;, but &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RULE has no chance to fire. If instead GHC had first inlined &lt;code&gt;g&lt;/code&gt; into &lt;code&gt;h&lt;/code&gt; then there would have been a better chance that &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; might fire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78c84c1ba9965d82f3eb5258f04e3357ef661af" translate="yes" xml:space="preserve">
          <source>Now a constraint &lt;code&gt;(C (F Bool))&lt;/code&gt; would match both instances. The situation is especially bad because the type instance for &lt;code&gt;F Bool&lt;/code&gt; might be in another module, or even in a module that is not yet written.</source>
          <target state="translated">现在约束 &lt;code&gt;(C (F Bool))&lt;/code&gt; 将匹配两个实例。这种情况特别糟糕，因为 &lt;code&gt;F Bool&lt;/code&gt; 的类型实例可能在另一个模块中，或者甚至在尚未编写的模块中。</target>
        </trans-unit>
        <trans-unit id="bc776dd529df85cf6ec0f1c7cad2c546f9d262d6" translate="yes" xml:space="preserve">
          <source>Now although we had two calls to &lt;code&gt;fib&lt;/code&gt; in the program, it is immediately clear that it was the call from &lt;code&gt;f&lt;/code&gt; which took all the time. The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; which are defined in the &lt;code&gt;where&lt;/code&gt; clause in &lt;code&gt;main&lt;/code&gt; are given their own cost centres, &lt;code&gt;main.f&lt;/code&gt; and &lt;code&gt;main.g&lt;/code&gt; respectively.</source>
          <target state="translated">现在，尽管我们在程序中有两次对 &lt;code&gt;fib&lt;/code&gt; 的调用，但很明显，这一直是 &lt;code&gt;f&lt;/code&gt; 的调用。功能 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 它们中定义的 &lt;code&gt;where&lt;/code&gt; 在第 &lt;code&gt;main&lt;/code&gt; 给出了自己的成本中心， &lt;code&gt;main.f&lt;/code&gt; 和 &lt;code&gt;main.g&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="2dc613132cc81aeb40d770a7a8834847fb2f6b7d" translate="yes" xml:space="preserve">
          <source>Now consider a splice using &lt;code&gt;add1&lt;/code&gt; in a separate module:</source>
          <target state="translated">现在考虑在单独的模块中使用 &lt;code&gt;add1&lt;/code&gt; 进行拼接：</target>
        </trans-unit>
        <trans-unit id="89991c287b92501854086e6fe84a0eb23ce3a9d6" translate="yes" xml:space="preserve">
          <source>Now find all instances, or in-scope given constraints, that &lt;em&gt;unify&lt;/em&gt; with the target constraint, but do not &lt;em&gt;match&lt;/em&gt; it. Such non-candidate instances might match when the target constraint is further instantiated. If all of them are incoherent top-level instances, the search succeeds, returning the prime candidate. Otherwise the search fails.</source>
          <target state="translated">现在，找到与目标约束&lt;em&gt;统一&lt;/em&gt;但不&lt;em&gt;匹配的&lt;/em&gt;所有实例或作用域内给定的约束。当进一步约束目标约束时，此类非候选实例可能会匹配。如果它们都是不连贯的顶级实例，则搜索成功，并返回主要的候选对象。否则，搜索将失败。</target>
        </trans-unit>
        <trans-unit id="ffef5ee2ac0281452ebd5c434b1c32bedfee55fe" translate="yes" xml:space="preserve">
          <source>Now let us explain the additional tags being used in the complete representation:</source>
          <target state="translated">现在让我们解释一下在完整的表示中使用的附加标签。</target>
        </trans-unit>
        <trans-unit id="7c396d7bbb8219cdfd5349a4df1d272a2d0f39e0" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s have a look at the flow of control. For this we can just start our program under &lt;code&gt;gdb&lt;/code&gt; (or an equivalent debugger) as we would any other native executable,</source>
          <target state="translated">现在让我们看一下控制流程。为此，我们可以像使用其他任何本机可执行文件一样，在 &lt;code&gt;gdb&lt;/code&gt; （或等效的调试器）下启动程序，</target>
        </trans-unit>
        <trans-unit id="680befe83eacad29ed4ff9bcb2bacba7e8ba5512" translate="yes" xml:space="preserve">
          <source>Now run the compiler,</source>
          <target state="translated">现在运行编译器。</target>
        </trans-unit>
        <trans-unit id="625396a0dc9892499ed6a922372b939b5ec972d5" translate="yes" xml:space="preserve">
          <source>Now run the compiler:</source>
          <target state="translated">现在运行编译器。</target>
        </trans-unit>
        <trans-unit id="b4b47a22e45bcc87c6e8f7f606395485b312ab48" translate="yes" xml:space="preserve">
          <source>Now suppose that the type inference engine needs to solve the constraint &lt;code&gt;C Int [Int]&lt;/code&gt;. This constraint matches instances (A), (C) and (D), but the last is more specific, and hence is chosen.</source>
          <target state="translated">现在假设类型推断引擎需要解决约束 &lt;code&gt;C Int [Int]&lt;/code&gt; 。此约束与实例（A），（C）和（D）匹配，但是最后一个更为具体，因此选择了该约束。</target>
        </trans-unit>
        <trans-unit id="b25ed4e4bb0e4d9e8025db5ceef110bd5f3b12df" translate="yes" xml:space="preserve">
          <source>Now suppose that we receive this encoded string as 3 packets that are split up on untidy boundaries: &lt;code&gt;[&quot;hi \xe2&quot;, &quot;\x98&quot;,
 &quot;\x83&quot;]&lt;/code&gt;. We cannot decode the entire Unicode string until we have received all three packets, but we would like to make progress as we receive each one.</source>
          <target state="translated">现在假设我们以3个数据包的形式接收此编码字符串，这些数据包在 &lt;code&gt;[&quot;hi \xe2&quot;, &quot;\x98&quot;, &quot;\x83&quot;]&lt;/code&gt; 边界上分开：[&amp;ldquo; hi \ xe2&amp;rdquo;，&amp;ldquo; \ x98&amp;rdquo;，&amp;ldquo; \ x83&amp;rdquo;]。在我们收到所有三个数据包之前，我们无法解码整个Unicode字符串，但是我们希望在收到每个数据包时取得进展。</target>
        </trans-unit>
        <trans-unit id="2861b41b3f54722c42e97b0121b6f6de624fa90c" translate="yes" xml:space="preserve">
          <source>Now suppose that, in some client module, we are searching for an instance of the &lt;em&gt;target constraint&lt;/em&gt;&lt;code&gt;(C ty1 .. tyn)&lt;/code&gt;. The search works like this:</source>
          <target state="translated">现在假设，在某些客户端模块中，我们正在搜索&lt;em&gt;目标约束&lt;/em&gt; &lt;code&gt;(C ty1 .. tyn)&lt;/code&gt; 的实例。搜索是这样的：</target>
        </trans-unit>
        <trans-unit id="438cc1997bb44ad791fefe6807da64e3c6115b37" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;lexp&lt;/code&gt; nonterminal is redundant and can be dropped from the grammar.</source>
          <target state="translated">现在， &lt;code&gt;lexp&lt;/code&gt; 非终结符是多余的，可以从语法中删除。</target>
        </trans-unit>
        <trans-unit id="f816c3eab864d3f8e7a4de157e0cfdc0f3fc8b6c" translate="yes" xml:space="preserve">
          <source>Now the file &lt;code&gt;Adder.dll&lt;/code&gt; can be used from other programming languages. Before calling any functions in Adder it is necessary to call &lt;code&gt;HsStart&lt;/code&gt;, and at the very end call &lt;code&gt;HsEnd&lt;/code&gt;.</source>
          <target state="translated">现在，可以从其他编程语言中使用文件 &lt;code&gt;Adder.dll&lt;/code&gt; 。在Adder中调用任何函数之前，必须先调用 &lt;code&gt;HsStart&lt;/code&gt; ，并在最后调用 &lt;code&gt;HsEnd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a42eb01f5e40d8a6ba95b33cb3730256cdc03814" translate="yes" xml:space="preserve">
          <source>Now the inlining of &lt;code&gt;op&lt;/code&gt; is delayed until the rule has a chance to fire. The down-side is that instance declarations must define &lt;code&gt;op_c&lt;/code&gt;, but all other uses should go via &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">现在， &lt;code&gt;op&lt;/code&gt; 的内联会延迟到规则有机会触发之前。 &lt;code&gt;op_c&lt;/code&gt; 的一面是实例声明必须定义op_c，但所有其他用途都应通过 &lt;code&gt;op&lt;/code&gt; 进行。</target>
        </trans-unit>
        <trans-unit id="0e94329f358c7c7c6ea83c351b1bf77d44f13a9b" translate="yes" xml:space="preserve">
          <source>Now we can define counters with different underlying implementations:</source>
          <target state="translated">现在我们可以定义不同底层实现的计数器。</target>
        </trans-unit>
        <trans-unit id="13f588bad21ffa379b7da21f8421e46de69a5837" translate="yes" xml:space="preserve">
          <source>Now we must infer a type for &lt;code&gt;z&lt;/code&gt;. To do so without generalising over kind variables, we must default the kind variables of &lt;code&gt;'MkCompose&lt;/code&gt;. We can easily default &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;Type&lt;/code&gt;, but &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; would be ill-kinded if defaulted. The definition for &lt;code&gt;z&lt;/code&gt; is thus an error.</source>
          <target state="translated">现在我们必须推断 &lt;code&gt;z&lt;/code&gt; 的类型。要做到这一点而不泛化种类变量，我们必须默认 &lt;code&gt;'MkCompose&lt;/code&gt; 的种类变量。我们可以轻松地将 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 默认设置为 &lt;code&gt;Type&lt;/code&gt; ，但是如果默认将 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 设置为不正确。因此， &lt;code&gt;z&lt;/code&gt; 的定义是一个错误。</target>
        </trans-unit>
        <trans-unit id="c0f6faa70067f8acaf63ef4e77013da4181317f2" translate="yes" xml:space="preserve">
          <source>Now we would like to be able to use the operations associated with each of those monad transformers on &lt;code&gt;InterpM&lt;/code&gt; actions. Since the uppermost monad transformer of &lt;code&gt;InterpM&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;, it already has the state operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">现在，我们希望能够对 &lt;code&gt;InterpM&lt;/code&gt; 动作使用与每个monad转换器相关的操作。由于 &lt;code&gt;InterpM&lt;/code&gt; 的最高Monad转换器是 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; ，因此它已经具有状态操作 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6583d556a077c92ce007ce319f478a614b82c53" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;re stuck, since we have no way to refer to &lt;code&gt;a&lt;/code&gt; on the right-hand side of the &lt;code&gt;B&lt;/code&gt; family instance, so this instance doesn&amp;rsquo;t really make sense in a &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; setting.</source>
          <target state="translated">现在我们被困住了，因为我们无法在 &lt;code&gt;B&lt;/code&gt; 系列实例的右侧引用 &lt;code&gt;a&lt;/code&gt; ，因此在&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;设置中，该实例实际上没有任何意义。</target>
        </trans-unit>
        <trans-unit id="2a56b6491f7450e6b6cbf461a479f7b983410abe" translate="yes" xml:space="preserve">
          <source>Now you are thinking: 'Wow, what a great monad! I wish I could use Reader functionality in MyFavoriteComplexMonad!'. Don't worry. This can be easily done with the &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; monad transformer. This example shows how to combine &lt;code&gt;ReaderT&lt;/code&gt; with the IO monad.</source>
          <target state="translated">现在您在想：'哇，多么伟大的单子！我希望我可以在MyFavoriteComplexMonad中使用阅读器功能！不用担心 使用 &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; monad转换器可以轻松完成此操作。本示例说明如何将 &lt;code&gt;ReaderT&lt;/code&gt; 与IO monad 结合使用。</target>
        </trans-unit>
        <trans-unit id="c30331621c70c268fbe2b12a4ae43098403e94bc" translate="yes" xml:space="preserve">
          <source>Now, before you start compiling, and any time you change the &lt;code&gt;imports&lt;/code&gt; in your program, do &lt;code&gt;make depend&lt;/code&gt; before you do &lt;code&gt;make cool_pgm&lt;/code&gt;. The command &lt;code&gt;ghc -M&lt;/code&gt; will append the needed dependencies to your &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">现在，在开始编译之前，以及任何时候在程序中更改 &lt;code&gt;imports&lt;/code&gt; 在 &lt;code&gt;make cool_pgm&lt;/code&gt; 之前都要先 &lt;code&gt;make depend&lt;/code&gt; 。 &lt;code&gt;ghc -M&lt;/code&gt; 命令将所需的依赖项附加到 &lt;code&gt;Makefile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="bd187ce0a311638f4b81ef33c620a2408b095c6a" translate="yes" xml:space="preserve">
          <source>Now, for each remaining group G, try each type &lt;code&gt;ty&lt;/code&gt; from the default-type list in turn; if setting &lt;code&gt;a = ty&lt;/code&gt; would allow the constraints in G to be completely solved. If so, default &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">现在，对于剩余的每个组G，依次尝试使用默认类型列表中的每个类型 &lt;code&gt;ty&lt;/code&gt; ；如果设置 &lt;code&gt;a = ty&lt;/code&gt; 将完全解决G中的约束。如果是这样， &lt;code&gt;ty&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 缺省设置为ty。</target>
        </trans-unit>
        <trans-unit id="b7ce07c7b8c1ce96092cb2c45e25b07d0cb48d20" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s set a breakpoint on the right-hand-side of the second equation of qsort:</source>
          <target state="translated">现在，让我们在qsort的第二个方程式的右侧设置一个断点：</target>
        </trans-unit>
        <trans-unit id="0e3828de0ce28186da70eb335d21ada4d2bedf92" translate="yes" xml:space="preserve">
          <source>Now, let's have a look at a decoder for this format.</source>
          <target state="translated">现在,我们来看看这种格式的解码器。</target>
        </trans-unit>
        <trans-unit id="370b8fafd1f82580290fa5780a4f150c9bfec2a3" translate="yes" xml:space="preserve">
          <source>Now, since &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; has inspected the runtime value of &lt;code&gt;left&lt;/code&gt;, it has reconstructed its type. We can see the results of this type reconstruction:</source>
          <target state="translated">现在，由于&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;检查了 &lt;code&gt;left&lt;/code&gt; 的运行时值，因此它重构了其类型。我们可以看到这种类型重构的结果：</target>
        </trans-unit>
        <trans-unit id="088c477373df4be46b91600c2f869d8a58285c64" translate="yes" xml:space="preserve">
          <source>Now, the definition for &lt;code&gt;f&lt;/code&gt; is typechecked, with this type for &lt;code&gt;g&lt;/code&gt; in the type environment.</source>
          <target state="translated">现在，对类型 &lt;code&gt;f&lt;/code&gt; 的定义进行类型检查，在类型环境中类型为 &lt;code&gt;g&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccd704ba50674817b795271869557981d0858cb5" translate="yes" xml:space="preserve">
          <source>Now, we run the program:</source>
          <target state="translated">现在,我们运行这个程序。</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="d3a26805a2b067d93448f180e6e182bcbb75712c" translate="yes" xml:space="preserve">
          <source>Nullary (no parameter) type classes are enabled with &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;; historically, they were enabled with the (now deprecated) &lt;a href=&quot;#extension-NullaryTypeClasses&quot;&gt;&lt;code&gt;NullaryTypeClasses&lt;/code&gt;&lt;/a&gt;. Since there are no available parameters, there can be at most one instance of a nullary class. A nullary type class might be used to document some assumption in a type signature (such as reliance on the Riemann hypothesis) or add some globally configurable settings in a program. For example,</source>
          <target state="translated">Nullary（无参数）类型类通过&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;启用；从历史上看，它们已使用（现在不推荐使用）&lt;a href=&quot;#extension-NullaryTypeClasses&quot;&gt; &lt;code&gt;NullaryTypeClasses&lt;/code&gt; 启用&lt;/a&gt;。由于没有可用的参数，因此最多可以有一个空类的实例。无效类型类可用于记录类型签名中的某些假设（例如，对Riemann假设的依赖）或在程序中添加一些全局可配置的设置。例如，</target>
        </trans-unit>
        <trans-unit id="133e3871ba59491ac637914e2f6d552d2543837b" translate="yes" xml:space="preserve">
          <source>NullaryTypeClasses</source>
          <target state="translated">NullaryTypeClasses</target>
        </trans-unit>
        <trans-unit id="8a24e40402207b8b70cc14eba1867548ac1b09e9" translate="yes" xml:space="preserve">
          <source>Num</source>
          <target state="translated">Num</target>
        </trans-unit>
        <trans-unit id="7207a8516803af416f88657a270437f29009c516" translate="yes" xml:space="preserve">
          <source>NumDecimals</source>
          <target state="translated">NumDecimals</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="6078e33a463c3fc4bf018c6d4892757dd06fd1c8" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s to read</source>
          <target state="translated">读取的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数</target>
        </trans-unit>
        <trans-unit id="8d2ec22cff354083eb5de7939c8c294986b55f23" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s to write</source>
          <target state="translated">要写入的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数</target>
        </trans-unit>
        <trans-unit id="556c2737e8c3dcbc1fd0849ca5c6a723df3e391e" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s to read</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2587022bb40a8ae81a89efee9f69c81acb8ba8" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s to write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e7b8e10141a983d3dd9d9f8df7f5e50f8a877" translate="yes" xml:space="preserve">
          <source>Number of bytes allocated in the heap while in this cost-centre; again, this is the raw number from which we get the &lt;code&gt;%alloc&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">在此成本中心内在堆中分配的字节数；再次，这是原始数字，从中可以得到上面提到的 &lt;code&gt;%alloc&lt;/code&gt; 数字。</target>
        </trans-unit>
        <trans-unit id="b7c1e6aab2f730e67e60e3f3630fd512b37f7fd9" translate="yes" xml:space="preserve">
          <source>Number of bytes allocated since the previous GC</source>
          <target state="translated">自上次GC后分配的字节数</target>
        </trans-unit>
        <trans-unit id="226ebfaaed57810b266577456986b00eeea443ef" translate="yes" xml:space="preserve">
          <source>Number of bytes read (zero for EOF)</source>
          <target state="translated">读取的字节数(EOF为零)</target>
        </trans-unit>
        <trans-unit id="a5ef9af163a69873ba44e8fbcba5f8084ad42ee2" translate="yes" xml:space="preserve">
          <source>Number of bytes written</source>
          <target state="translated">写入的字节数</target>
        </trans-unit>
        <trans-unit id="37d9add7b22f84b749fc0bb781a0c319aa35911b" translate="yes" xml:space="preserve">
          <source>Number of decimal places to render.</source>
          <target state="translated">渲染的小数位数。</target>
        </trans-unit>
        <trans-unit id="2d0276fde8b8bccf3967e13465adad04dcd3fb55" translate="yes" xml:space="preserve">
          <source>Number of elements in &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 列表中的元素数。</target>
        </trans-unit>
        <trans-unit id="bfae1057272c15097d6afebcd7248cb367ca7b45" translate="yes" xml:space="preserve">
          <source>Number of hard links to this file.</source>
          <target state="translated">该文件的硬链接数量。</target>
        </trans-unit>
        <trans-unit id="219521647d9d3d4445e681b40b5e2a5607f91d09" translate="yes" xml:space="preserve">
          <source>Number of threads used in this GC</source>
          <target state="translated">该GC中使用的螺纹数量</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="48663ea04658b1300d2330bd05e7f63994e32176" translate="yes" xml:space="preserve">
          <source>Numeric ID for this user (pw_uid)</source>
          <target state="translated">该用户的数字ID (pw_uid)</target>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">数字功能</target>
        </trans-unit>
        <trans-unit id="f0f578ffa8300a7d47627f52c99db9d0bc7e728b" translate="yes" xml:space="preserve">
          <source>Numeric representations</source>
          <target state="translated">数字表示法</target>
        </trans-unit>
        <trans-unit id="7e059a90d732985fd4e5da7181d4f1a4f4554ef6" translate="yes" xml:space="preserve">
          <source>Numeric type classes</source>
          <target state="translated">数值型类</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">数字类型</target>
        </trans-unit>
        <trans-unit id="50c7d8c8437705640951d4fdbcb3597372fedc84" translate="yes" xml:space="preserve">
          <source>Numeric.Natural</source>
          <target state="translated">Numeric.Natural</target>
        </trans-unit>
        <trans-unit id="adb496574c9de2fe1e7a86803e148d10ff98d0cb" translate="yes" xml:space="preserve">
          <source>NumericUnderscores</source>
          <target state="translated">NumericUnderscores</target>
        </trans-unit>
        <trans-unit id="4f59093c4c5b281154dbfc53d826d3b6bf440eb2" translate="yes" xml:space="preserve">
          <source>O(1) A variant of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is non-empty.</source>
          <target state="translated">O（1）非空 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; 的变体。 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 省略了对是否为空的检查，因此程序员有义务提供证明 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 为非空的证明。</target>
        </trans-unit>
        <trans-unit id="63618ec7a7277a575e924f0d0594778e294019a2" translate="yes" xml:space="preserve">
          <source>O(1) A variant of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is non-empty.</source>
          <target state="translated">O（1）用于非空 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; 的变体。 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 省略了对是否为空的检查，因此程序员有义务提供证明 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 为非空的证明。</target>
        </trans-unit>
        <trans-unit id="a80a8b2cc5a997d9f243eb68838aa2dff6075584" translate="yes" xml:space="preserve">
          <source>O(1) Adds a character to the front of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（1）在 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的前面添加一个字符。受到融合。</target>
        </trans-unit>
        <trans-unit id="4205ee874ea222c9bfd093dacb8a59f0c949bce2" translate="yes" xml:space="preserve">
          <source>O(1) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. This value will have &lt;em&gt;no&lt;/em&gt; finalizer associated with it, and will not be garbage collected by Haskell. This operation has O(1) complexity as we already know the final size, so no &lt;em&gt;strlen(3)&lt;/em&gt; is required.</source>
          <target state="translated">O（1）从 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 构建一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。此值将&lt;em&gt;没有&lt;/em&gt;与其关联的终结器，并且Haskell不会对其进行垃圾回收。我们已经知道最终大小，因此该操作的复杂度为O（1），因此不需要&lt;em&gt;strlen（3）&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c6e5c48dee8cd2bc0ceaff2d8837913ec349a43" translate="yes" xml:space="preserve">
          <source>O(1) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. This value will have &lt;em&gt;no&lt;/em&gt; finalizer associated with it, and will not be garbage collected by Haskell. This operation has O(1) complexity as we already know the final size, so no &lt;em&gt;strlen(3)&lt;/em&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2852686ecf17dc62ec862c9ea8960726fe4924" translate="yes" xml:space="preserve">
          <source>O(1) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a malloced &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. This value will have a &lt;code&gt;free(3)&lt;/code&gt; finalizer associated to it.</source>
          <target state="translated">O（1）从分配的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 构建一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。该值将具有一个与之关联的 &lt;code&gt;free(3)&lt;/code&gt; 终结器。</target>
        </trans-unit>
        <trans-unit id="e683e781924b9b59e4e489f06a7297c19c5a65de" translate="yes" xml:space="preserve">
          <source>O(1) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a malloced &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. This value will have a &lt;code&gt;free(3)&lt;/code&gt; finalizer associated to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ab1c87418f21e22791b9f74f9f938ded3ec112" translate="yes" xml:space="preserve">
          <source>O(1) Build a ByteString from a ForeignPtr.</source>
          <target state="translated">O(1)从一个ForeignPtr构建一个ByteString。</target>
        </trans-unit>
        <trans-unit id="54a20a665c28555de9ad492062514aa96fa4ad77" translate="yes" xml:space="preserve">
          <source>O(1) Construct a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; given a Ptr Word8 to a buffer, a length, and an IO action representing a finalizer. This function is not available on Hugs.</source>
          <target state="translated">O（1）构造一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，将Ptr Word8赋予缓冲区，长度和代表终结器的IO操作。此功能不适用于拥抱。</target>
        </trans-unit>
        <trans-unit id="de476cec8ba99d6fd4661fdd8846b9d97390fcc2" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70b2781938bd0493d75c600f419b4c9160251630" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48defe8058b03923064d67548a2b775944ea08a9" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1135130e054d969e933893cb0c9b0a905884452e" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcf4ae8a1fb788d406f9d60d282bee6bda3de541" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef7bf63c625a651be5fd187d2bb2df7563ff2a6" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a56dcd06fedebb15f1d4c7aafead11af2e67b8" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0e1171a57671034ff3e2e1e31b9e1dd33fcd53" translate="yes" xml:space="preserve">
          <source>O(1) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca86ad277b497891880219a763e14c2e60e44f86" translate="yes" xml:space="preserve">
          <source>O(1) Convert a character into a Text. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O(1)将一个字符转换为一个文本。受制于融合。对无效的标量值进行替换。</target>
        </trans-unit>
        <trans-unit id="2d2c9063126a95a29a04dd0bcdd2c4149b975983" translate="yes" xml:space="preserve">
          <source>O(1) Convert a strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）将严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2784eb6b77a9790550f7d3343addfb99e8ffb8f2" translate="yes" xml:space="preserve">
          <source>O(1) Convert a strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）将严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c54de2b2bb93392704d2290b65ff8789bf48fadf" translate="yes" xml:space="preserve">
          <source>O(1) Deconstruct a ForeignPtr from a ByteString</source>
          <target state="translated">O(1)从ByteString解构一个ForeignPtr。</target>
        </trans-unit>
        <trans-unit id="e4c550276392b862d05e2ec6841167619ba5e98b" translate="yes" xml:space="preserve">
          <source>O(1) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O（1）提取ByteString 的 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，如果为空则返回Nothing。</target>
        </trans-unit>
        <trans-unit id="f218019d72ba8f90ea322b3f2b6e1aba698a3e17" translate="yes" xml:space="preserve">
          <source>O(1) Extract the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O（1）提取ByteString 的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ，如果为空则返回Nothing。</target>
        </trans-unit>
        <trans-unit id="21fbbb3d55222802fa13dd27566010dcacacbb85" translate="yes" xml:space="preserve">
          <source>O(1) Extract the elements after the head of a ByteString, which must be non-empty.</source>
          <target state="translated">O(1)提取ByteString头部后的元素,该元素必须是非空的。</target>
        </trans-unit>
        <trans-unit id="5378fc0faa39743c85aac4b42ce79db1e5ef3957" translate="yes" xml:space="preserve">
          <source>O(1) Extract the elements after the head of a ByteString, which must be non-empty. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O(1)提取ByteString头部后的元素,该元素必须是非空的。如果是一个空的ByteString,将会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="f7bb822a81bb37fffbf9ab64b08353c32fd00381" translate="yes" xml:space="preserve">
          <source>O(1) Extract the first element of a ByteString, which must be non-empty.</source>
          <target state="translated">O(1)提取ByteString的第一个元素,它必须是非空的。</target>
        </trans-unit>
        <trans-unit id="91fefa55c7e6570a93d3b82592f091c9c1da1c43" translate="yes" xml:space="preserve">
          <source>O(1) Extract the first element of a ByteString, which must be non-empty. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O(1)提取ByteString的第一个元素,该元素必须是非空的。如果是一个空的ByteString,将会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="48adec6ba5891d93d8739199d579814f571004f9" translate="yes" xml:space="preserve">
          <source>O(1) Extract the head and tail of a ByteString, returning Nothing if it is empty.</source>
          <target state="translated">O(1)提取一个 ByteString 的头和尾,如果是空的,返回 Nothing。</target>
        </trans-unit>
        <trans-unit id="2a9b4b8518197ecf8a0a278a8275e54c235ada18" translate="yes" xml:space="preserve">
          <source>O(1) Extract the last element of a ByteString, which must be finite and non-empty. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O(1)提取一个 ByteString 的最后一个元素,该元素必须是有限的且非空的。如果是一个空的ByteString,将会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="cd893e262e0101eff2ce68ac9e7922d9a1211337" translate="yes" xml:space="preserve">
          <source>O(1) Extract the last element of a packed string, which must be non-empty.</source>
          <target state="translated">O(1)提取一个打包字符串的最后一个元素,该元素必须是非空的。</target>
        </trans-unit>
        <trans-unit id="dc52c26904640a5efaa0703c692f739516d37935" translate="yes" xml:space="preserve">
          <source>O(1) Iterate (unsafely) one step forwards through a UTF-16 array, returning the current character and the delta to add to give the next offset to iterate at.</source>
          <target state="translated">O(1)在 UTF-16 数组中向前迭代(不安全地)一步,返回当前字符和要添加的 delta,以给出下一个要迭代的偏移量。</target>
        </trans-unit>
        <trans-unit id="0dbb0d476e90cf0bcc5354f708c5afd3b311d028" translate="yes" xml:space="preserve">
          <source>O(1) Iterate one step backwards through a UTF-16 array, returning the current character and the delta to add (i.e. a negative number) to give the next offset to iterate at.</source>
          <target state="translated">O(1)在 UTF-16 数组中向后迭代一步,返回当前字符和要添加的 delta (即负数),以给出下一个要迭代的偏移量。</target>
        </trans-unit>
        <trans-unit id="59362dccb79763a625b4941a41931672d368a885" translate="yes" xml:space="preserve">
          <source>O(1) Iterate one step backwards through a UTF-16 array, returning the delta to add (i.e. a negative number) to give the next offset to iterate at.</source>
          <target state="translated">O(1)在 UTF-16 数组中向后迭代一步,返回要加的 delta (即负数),以给出下一个要迭代的偏移量。</target>
        </trans-unit>
        <trans-unit id="8fac424387f182f658cffd67afe9158309c43db4" translate="yes" xml:space="preserve">
          <source>O(1) Iterate one step through a UTF-16 array, returning the delta to add to give the next offset to iterate at.</source>
          <target state="translated">O(1)在 UTF-16 数组中迭代一步,返回加到下一个偏移量的 delta。</target>
        </trans-unit>
        <trans-unit id="65a9d66f3e8e0dfb5e1e8438073c9c97711420a0" translate="yes" xml:space="preserve">
          <source>O(1) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有元素，最后一个除外。空ByteString的情况下将引发异常。</target>
        </trans-unit>
        <trans-unit id="5d0d1f833e469cba787b59254669273bd03367fb" translate="yes" xml:space="preserve">
          <source>O(1) Return all the elements of a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; except the last one. An exception will be thrown in the case of an empty ByteString.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有元素，最后一个除外。空ByteString的情况下将引发异常。</target>
        </trans-unit>
        <trans-unit id="e25e541eee9e6dc19f8f7877304db9fdc8b56771" translate="yes" xml:space="preserve">
          <source>O(1) Return the length of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; in units of &lt;code&gt;Word16&lt;/code&gt;. This is useful for sizing a target array appropriately before using &lt;code&gt;unsafeCopyToPtr&lt;/code&gt;.</source>
          <target state="translated">O（1）以 &lt;code&gt;Word16&lt;/code&gt; 为单位返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的长度。这对于在使用 &lt;code&gt;unsafeCopyToPtr&lt;/code&gt; 之前适当调整目标数组的大小很有用。</target>
        </trans-unit>
        <trans-unit id="198814e3d54d147837c8bc788d2df5104fc80457" translate="yes" xml:space="preserve">
          <source>O(1) Return the prefix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; units in length.</source>
          <target state="translated">O（1）返回长度为 &lt;code&gt;n&lt;/code&gt; 个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 单位的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的前缀。</target>
        </trans-unit>
        <trans-unit id="ed973df02b8dc1d8689230668a7fcb34cbaa2b14" translate="yes" xml:space="preserve">
          <source>O(1) Return the suffix of the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, with &lt;code&gt;n&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; units dropped from its beginning.</source>
          <target state="translated">O（1）返回的后缀 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，与 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 单位从它开始下降。</target>
        </trans-unit>
        <trans-unit id="ee12bce996f9dd611dc521eecfba44efbf2bf08d" translate="yes" xml:space="preserve">
          <source>O(1) Returns all but the last character and the last character of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty.</source>
          <target state="translated">O（1）返回所有，但最后一个字符和最后一个字符 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。</target>
        </trans-unit>
        <trans-unit id="30c5ea714b31776c0c939e953673ed65c738da77" translate="yes" xml:space="preserve">
          <source>O(1) Returns all but the last character of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的最后一个字符，但不能为空。受到融合。</target>
        </trans-unit>
        <trans-unit id="ffc9094d4df7eb7305b9b46fcb8befe4e1d077b5" translate="yes" xml:space="preserve">
          <source>O(1) Returns all but the last character of a Stream Char, which must be non-empty.</source>
          <target state="translated">O(1)返回一个Stream Char的所有字符,但最后一个字符必须是非空的。</target>
        </trans-unit>
        <trans-unit id="d733a5834ddb55e9edc61780b9b4253209d0011f" translate="yes" xml:space="preserve">
          <source>O(1) Returns all characters after the head of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 开头之后的所有字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="c390386103a1f898875da0a1381da3b4f899972c" translate="yes" xml:space="preserve">
          <source>O(1) Returns all characters after the head of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 开头之后的所有字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="f824be4a587faf7b9a075e83a7d8449d662355c4" translate="yes" xml:space="preserve">
          <source>O(1) Returns all characters after the head of a Stream Char, which must be non-empty.</source>
          <target state="translated">O(1)返回Stream Char头部后的所有字符,该字符必须是非空的。</target>
        </trans-unit>
        <trans-unit id="5f47a226cede2eb3313a8e93512ec2f3ea9253f9" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character and remainder of a 'Stream Char', or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty. Subject to array fusion.</source>
          <target state="translated">O（1）返回&amp;ldquo;流字符&amp;rdquo;的第一个字符和其余字符；如果为空，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。接受数组融合。</target>
        </trans-unit>
        <trans-unit id="fb95a8c303e35a104867be5f73d3a2e519e841d9" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character and rest of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty. Subject to fusion.</source>
          <target state="translated">O（1）返回的第一个字符和其他 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。受到融合。</target>
        </trans-unit>
        <trans-unit id="c3de350e1a1bf61a7c0c878585e608e897b9465a" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character and rest of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if empty. Subject to fusion.</source>
          <target state="translated">O（1）返回的第一个字符和其他 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果是空的。受到融合。</target>
        </trans-unit>
        <trans-unit id="abd745bbc1f2d744bc4216344ce23057b41261ea" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的第一个字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="0df8ce1324f5fac4bc8e5c75e37600890d277cf3" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的第一个字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="e7dcd793666506b8a22379fc7f221c60e6a42e20" translate="yes" xml:space="preserve">
          <source>O(1) Returns the first character of a Text, which must be non-empty. Subject to array fusion.</source>
          <target state="translated">O(1)返回 Text 的第一个字符,必须是非空的。受数组融合影响。</target>
        </trans-unit>
        <trans-unit id="2f58d3fa40d2d24aa915ae0115e301a8e95734bc" translate="yes" xml:space="preserve">
          <source>O(1) Returns the last character of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, which must be non-empty. Subject to fusion.</source>
          <target state="translated">O（1）返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的最后一个字符，该字符必须为非空。受到融合。</target>
        </trans-unit>
        <trans-unit id="6524f7d79973c429a0db52bab5bb86132b85dc05" translate="yes" xml:space="preserve">
          <source>O(1) Test whether a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; is empty.</source>
          <target state="translated">O（1）测试 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 是否为空。</target>
        </trans-unit>
        <trans-unit id="7697b61777e432d35abde8141f9ed33264f561d7" translate="yes" xml:space="preserve">
          <source>O(1) Test whether a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; is empty.</source>
          <target state="translated">O（1）测试 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 是否为空。</target>
        </trans-unit>
        <trans-unit id="c79a107bde05d928aa937a571e1d002de46c859b" translate="yes" xml:space="preserve">
          <source>O(1) Test whether a ByteString is empty.</source>
          <target state="translated">O(1)测试一个ByteString是否为空。</target>
        </trans-unit>
        <trans-unit id="8d9f0edce381f99c9f7942893218a73d880843b7" translate="yes" xml:space="preserve">
          <source>O(1) Tests whether a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is empty or not. Subject to fusion.</source>
          <target state="translated">O（1）测试 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 是否为空。受到融合。</target>
        </trans-unit>
        <trans-unit id="c5acba2c60ed95b9b64c17300fc1b52ac0ebb02f" translate="yes" xml:space="preserve">
          <source>O(1) Tests whether a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is empty or not. Subject to fusion.</source>
          <target state="translated">O（1）测试 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 是否为空。受到融合。</target>
        </trans-unit>
        <trans-unit id="53b6f63204a6bc565ef947657aecf518015139e0" translate="yes" xml:space="preserve">
          <source>O(1) Tests whether a Stream Char is empty or not.</source>
          <target state="translated">O(1)测试一个Stream Char是否为空。</target>
        </trans-unit>
        <trans-unit id="4d91225346f00dbbf19a6af59479e1a0a2cb483b" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a9d1350802d1b65b3e735520268cfa9d6988d30" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1faf35ade730014da64f04df752187b12fb2d9a" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c47e1f1ac4b7d54ed000c7f35d97cb1376363515" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22716aa315ed9621c399cfdccf30a747e639f849" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fa46a3722601b21767162610c552d11526774af" translate="yes" xml:space="preserve">
          <source>O(1) The empty &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）空的 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54c2c7f30c834f781e980d0899ac5fb1417351de" translate="yes" xml:space="preserve">
          <source>O(1) The length of a &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="eba9e6f5ca714056e0093cd12bc2aa2b10b4357b" translate="yes" xml:space="preserve">
          <source>O(1) The length of a &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="08bc6b2be18b6d8f73561c3c144fb9857d11bb8f" translate="yes" xml:space="preserve">
          <source>O(1) Unchecked drop of &lt;code&gt;k&lt;/code&gt;&lt;code&gt;Word16&lt;/code&gt;s from the front of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）从 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的前面未经检查地丢弃 &lt;code&gt;k&lt;/code&gt; 个 &lt;code&gt;Word16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2a475db7c49f1740baff7d13c09a38d90b4368c" translate="yes" xml:space="preserve">
          <source>O(1) Unchecked take of &lt;code&gt;k&lt;/code&gt;&lt;code&gt;Word16&lt;/code&gt;s from the front of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）从 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的前面未经检查地获取 &lt;code&gt;k&lt;/code&gt; 个 &lt;code&gt;Word16&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ad3b6a808c1165f1cfa2f2b7075eabe2e5fba3b" translate="yes" xml:space="preserve">
          <source>O(1) Unlike &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons-39-&quot;&gt;cons'&lt;/a&gt;&lt;/code&gt; is strict in the ByteString that we are consing onto. More precisely, it forces the head and the first chunk. It does this because, for space efficiency, it may coalesce the new byte onto the first 'chunk' rather than starting a new 'chunk'.</source>
          <target state="translated">O（1）与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons-39-&quot;&gt;cons'&lt;/a&gt;&lt;/code&gt; 在我们要使用的ByteString中严格。更确切地说，它迫使头部和第一个块。这样做是因为，为了提高空间效率，它可以将新字节合并到第一个&amp;ldquo;块&amp;rdquo;上，而不是开始一个新的&amp;ldquo;块&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="01126982fe868007a0fc66a14b7386a86df6ae65" translate="yes" xml:space="preserve">
          <source>O(1) Unlike &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons-39-&quot;&gt;cons'&lt;/a&gt;&lt;/code&gt; is strict in the ByteString that we are consing onto. More precisely, it forces the head and the first chunk. It does this because, for space efficiency, it may coalesce the new byte onto the first 'chunk' rather than starting a new 'chunk'.</source>
          <target state="translated">O（1）与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons-39-&quot;&gt;cons'&lt;/a&gt;&lt;/code&gt; 在我们要使用的ByteString中严格。更确切地说，它迫使头部和第一个块。这样做是因为，为了提高空间效率，它可以将新字节合并到第一个&amp;ldquo;块&amp;rdquo;上，而不是开始一个新的&amp;ldquo;块&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8342f5c1dd2f444af3ebb6236b7a8c8f2bf0d312" translate="yes" xml:space="preserve">
          <source>O(1) construction Use a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with a function requiring a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）构造将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 与需要 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 的函数一起使用。</target>
        </trans-unit>
        <trans-unit id="e4838c340b4983dfa1e7c3816b7f90e67b9654b3" translate="yes" xml:space="preserve">
          <source>O(1) construction Use a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with a function requiring a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）构造将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 与需要 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 的函数一起使用。</target>
        </trans-unit>
        <trans-unit id="37270b96253d8fa8318e6f70f0c87998dddcbcf0" translate="yes" xml:space="preserve">
          <source>O(1) construction Use a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with a function requiring a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe1e53d0405b41a76d441caeef68d8a2d36f9d7" translate="yes" xml:space="preserve">
          <source>O(1) construction Use a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with a function requiring a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70abeb09e0439b25147d1a32ea87000cb8df126" translate="yes" xml:space="preserve">
          <source>O(1). A &lt;code&gt;Builder&lt;/code&gt; taking a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。一个 &lt;code&gt;Builder&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，满意</target>
        </trans-unit>
        <trans-unit id="efc4c4f8c38e1bbb82d36caba0cebf4f4ae6de30" translate="yes" xml:space="preserve">
          <source>O(1). A &lt;code&gt;Builder&lt;/code&gt; taking a lazy &lt;code&gt;Text&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。一个 &lt;code&gt;Builder&lt;/code&gt; 以一个懒惰 &lt;code&gt;Text&lt;/code&gt; ，满足</target>
        </trans-unit>
        <trans-unit id="a71659c80a2aef85809ebd1b024235a1c0c8f814" translate="yes" xml:space="preserve">
          <source>O(1). A &lt;code&gt;Builder&lt;/code&gt; taking a single character, satisfying</source>
          <target state="translated">O（1）。一个拥有单个角色的 &lt;code&gt;Builder&lt;/code&gt; ，令人满意</target>
        </trans-unit>
        <trans-unit id="c8aac3a51370414a6d1d529198ef3822c42b8755" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。一个使用 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的构建器，满足</target>
        </trans-unit>
        <trans-unit id="a78b2c60e3d71431683d0a38d58908db6b3e5436" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a &lt;code&gt;String&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。一个建筑工人拿一个 &lt;code&gt;String&lt;/code&gt; ，满意</target>
        </trans-unit>
        <trans-unit id="258f07c76f01be46264e4d02c8cd9928b57a6564" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。一个采用惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的构建器，满足</target>
        </trans-unit>
        <trans-unit id="70b3cc0d5f228216be66eec65f6b57e3d525c69e" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a single byte, satisfying</source>
          <target state="translated">O(1).一个生成器取一个单字节,满足于</target>
        </trans-unit>
        <trans-unit id="4a8e367a67805a009ff18cfa3ad1ac144bcf2b63" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a single native machine word. The word is written in host order, host endian form, for the machine you're on. On a 64 bit machine the Int is an 8 byte value, on a 32 bit machine, 4 bytes. Values written this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">O(1).一个生成器取一个单一的本机字。这个字是按照你所在的机器的主机顺序写的,主机endian形式。在64位机器上,Int是一个8字节的值,在32位机器上,是4个字节。这样写的值在没有转换的情况下,不能移植到不同恩迪安或字大小的机器上。</target>
        </trans-unit>
        <trans-unit id="f047d2d9931d48fdb616d3df74b9eaff92d21452" translate="yes" xml:space="preserve">
          <source>O(1). A Builder taking a single native machine word. The word is written in host order, host endian form, for the machine you're on. On a 64 bit machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes. Values written this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">O(1).一个生成器取一个单一的本机字。这个字是按主机顺序写的,主机恩迪亚形式,为你所在的机器。在64位机器上,字是一个8字节的值,在32位机器上,是4个字节。这样写的值在没有转换的情况下,不能移植到不同恩迪安或字大小的机器上。</target>
        </trans-unit>
        <trans-unit id="2bdbae62296f9dc8c3ecfc46770a3acc9d5025a9" translate="yes" xml:space="preserve">
          <source>O(1). A map of one element.</source>
          <target state="translated">O(1).一个元素的映射。</target>
        </trans-unit>
        <trans-unit id="6209b5f8471f6cbf7bb350bbdb3f8d270167bd41" translate="yes" xml:space="preserve">
          <source>O(1). A map with a single element.</source>
          <target state="translated">O(1).一个单一元素的地图。</target>
        </trans-unit>
        <trans-unit id="9232d201c5916a3136d98f2d2cc954b7d3457758" translate="yes" xml:space="preserve">
          <source>O(1). A set of one element.</source>
          <target state="translated">O(1).一个元素的集合。</target>
        </trans-unit>
        <trans-unit id="dace43eb5a7b150d785e0956aa9b9e6ce114b151" translate="yes" xml:space="preserve">
          <source>O(1). Create a singleton set.</source>
          <target state="translated">O(1).建立一个单子集。</target>
        </trans-unit>
        <trans-unit id="cedf37f6d0fba366d4f35d73bd4f7c4e3810f0e6" translate="yes" xml:space="preserve">
          <source>O(1). Decompose a list into its head and tail. If the list is empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. If the list is non-empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the head of the list and &lt;code&gt;xs&lt;/code&gt; its tail.</source>
          <target state="translated">O（1）。将列表分解成其头部和尾部。如果列表为空，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。如果列表是非空的，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是列表的头部， &lt;code&gt;xs&lt;/code&gt; 是列表的尾部。</target>
        </trans-unit>
        <trans-unit id="acd62fb62d85ccbd3e873eb07f9bf62980e87634" translate="yes" xml:space="preserve">
          <source>O(1). Decompose a map into pieces based on the structure of the underlying tree. This function is useful for consuming a map in parallel.</source>
          <target state="translated">O(1).根据底层树的结构将一个地图分解成若干块。这个函数对于并行消耗一个地图很有用。</target>
        </trans-unit>
        <trans-unit id="aaaef29c2922406e0eb9d12c5cb013161ee19ec8" translate="yes" xml:space="preserve">
          <source>O(1). Decompose a set into pieces based on the structure of the underlying tree. This function is useful for consuming a set in parallel.</source>
          <target state="translated">O(1).根据底层树的结构将一个集合分解成若干个片段。这个函数对于并行消耗一个集合很有用。</target>
        </trans-unit>
        <trans-unit id="f86a0da08a5d4c84252d7184c00eb64c6f9cb7e3" translate="yes" xml:space="preserve">
          <source>O(1). Extract the elements after the head of a list, which must be non-empty.</source>
          <target state="translated">O(1).提取列表头部后的元素,这些元素必须是非空的。</target>
        </trans-unit>
        <trans-unit id="4632274a52ddc7483885829fac2748ba06921f35" translate="yes" xml:space="preserve">
          <source>O(1). Extract the first element of a list, which must be non-empty.</source>
          <target state="translated">O(1).提取列表的第一个元素,该元素必须是非空的。</target>
        </trans-unit>
        <trans-unit id="9f9451fc8b110267f6c8b81ec942700c786fa2d5" translate="yes" xml:space="preserve">
          <source>O(1). Is the map empty?</source>
          <target state="translated">O(1).地图是空的吗?</target>
        </trans-unit>
        <trans-unit id="ee63439003724255f7dba160c74924c248455c3f" translate="yes" xml:space="preserve">
          <source>O(1). Is the set empty?</source>
          <target state="translated">O(1).集合是空的吗?</target>
        </trans-unit>
        <trans-unit id="28bf79774ccbece345be850fd9860024b7d4638d" translate="yes" xml:space="preserve">
          <source>O(1). Is this the empty set?</source>
          <target state="translated">O(1).这是空集吗?</target>
        </trans-unit>
        <trans-unit id="2c5e8173ef50b843bba5a876065a0360b1842abd" translate="yes" xml:space="preserve">
          <source>O(1). Pop the strict &lt;code&gt;Text&lt;/code&gt; we have constructed so far, if any, yielding a new chunk in the result lazy &lt;code&gt;Text&lt;/code&gt;.</source>
          <target state="translated">O（1）。弹出到目前为止我们已经构造的严格 &lt;code&gt;Text&lt;/code&gt; （如果有），在结果lazy &lt;code&gt;Text&lt;/code&gt; 中产生一个新的块。</target>
        </trans-unit>
        <trans-unit id="982337e8280c6ac9255cf5a12cb1f3c67eab903a" translate="yes" xml:space="preserve">
          <source>O(1). Read a 2 byte Int16 in native host order and host endianness.</source>
          <target state="translated">O(1).按主机顺序和主机字节数读取一个2字节的Int16。</target>
        </trans-unit>
        <trans-unit id="349fd90c038d1d072ecb6fcbb4b74516b5c2e647" translate="yes" xml:space="preserve">
          <source>O(1). Read a 2 byte Word16 in native host order and host endianness.</source>
          <target state="translated">O(1).以本机主机顺序和主机字节数读取一个2字节的Word16。</target>
        </trans-unit>
        <trans-unit id="ecdc1757de2dba66b8360f8bde4c845b1aa02fdd" translate="yes" xml:space="preserve">
          <source>O(1). Read a Word32 in native host order and host endianness.</source>
          <target state="translated">O(1).按本机主机顺序和主机字节数读取一个Word32。</target>
        </trans-unit>
        <trans-unit id="3e1ef563725a39ca83cb55ef4e772382c9d1bec2" translate="yes" xml:space="preserve">
          <source>O(1). Read a Word64 in native host order and host endianess.</source>
          <target state="translated">O(1).按原生宿主顺序和宿主endianess读取一个Word64。</target>
        </trans-unit>
        <trans-unit id="1875c222b5c00ce430aed929213073e836f0d3cd" translate="yes" xml:space="preserve">
          <source>O(1). Read a single native machine word in native host order. It works in the same way as &lt;code&gt;&lt;a href=&quot;data-binary-get#v:getWordhost&quot;&gt;getWordhost&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）。按本地主机顺序读取单个本地机器字。它的工作方式与 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:getWordhost&quot;&gt;getWordhost&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d1f3e0a204289e7b7025cf4aabe934218e5f2842" translate="yes" xml:space="preserve">
          <source>O(1). Read a single native machine word. The word is read in host order, host endian form, for the machine you're on. On a 64 bit machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes.</source>
          <target state="translated">O(1).读取单个本机字。这个字是按照你所在机器的主机顺序,主机恩迪亚形式读取的。在64位机器上,字是一个8字节的值,在32位机器上,是4个字节。</target>
        </trans-unit>
        <trans-unit id="92857427e318885ee7caede05c631d6ae3b25b9e" translate="yes" xml:space="preserve">
          <source>O(1). Read an Int32 in native host order and host endianness.</source>
          <target state="translated">O(1).按主机顺序和主机字节数读取Int32。</target>
        </trans-unit>
        <trans-unit id="a0cddbff751d108cb0cfd4b75e17a5b12bd1f579" translate="yes" xml:space="preserve">
          <source>O(1). Read an Int64 in native host order and host endianess.</source>
          <target state="translated">O(1).按主机的顺序和主机的endianess读取Int64。</target>
        </trans-unit>
        <trans-unit id="aac1672ab4255d16440eeecf74a29e257eaa22b2" translate="yes" xml:space="preserve">
          <source>O(1). Test whether a list is empty.</source>
          <target state="translated">O(1).测试一个列表是否为空。</target>
        </trans-unit>
        <trans-unit id="e7cb47e9f9b73b3679b0c1295f9026c8631d0fe3" translate="yes" xml:space="preserve">
          <source>O(1). The concatenation of two Builders, an associative operation with identity &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, satisfying</source>
          <target state="translated">O（1）。两个Builder的串联，一个标识为 &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 的关联操作，满足</target>
        </trans-unit>
        <trans-unit id="28ec62e6018014118ef7768573b333a75dfa498f" translate="yes" xml:space="preserve">
          <source>O(1). The empty &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）。空的 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae24273afe362c721440f979994739048f543806" translate="yes" xml:space="preserve">
          <source>O(1). The empty &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1）。空的 &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f5c72989966a0e1b490a1c6397635d9efd1c730" translate="yes" xml:space="preserve">
          <source>O(1). The empty Builder, satisfying</source>
          <target state="translated">O(1).空的生成器,满足</target>
        </trans-unit>
        <trans-unit id="7be26a840457d7a9cb16b70698725b4acf3c37ca" translate="yes" xml:space="preserve">
          <source>O(1). The empty map.</source>
          <target state="translated">O(1).空图。</target>
        </trans-unit>
        <trans-unit id="bad934cde2e4a22144be650ff0165b94ae35b737" translate="yes" xml:space="preserve">
          <source>O(1). The empty set.</source>
          <target state="translated">O(1).空集。</target>
        </trans-unit>
        <trans-unit id="2ba61cc4f7911b923b0328ff3dc657e0cf1a0c42" translate="yes" xml:space="preserve">
          <source>O(1). The number of elements in the map.</source>
          <target state="translated">O(1).地图中元素的数量。</target>
        </trans-unit>
        <trans-unit id="8130a572981e2a1ede611a465660141584ffe399" translate="yes" xml:space="preserve">
          <source>O(1). The number of elements in the set.</source>
          <target state="translated">O(1).集合中元素的数量。</target>
        </trans-unit>
        <trans-unit id="08e64bd0db1d1fbedd0a299664b7a171dfd128cd" translate="yes" xml:space="preserve">
          <source>O(1). Write a Word16 in native host order and host endianness. For portability issues see &lt;code&gt;putWordhost&lt;/code&gt;.</source>
          <target state="translated">O（1）。按照本地主机顺序和主机字节顺序编写Word16。有关可移植性问题，请参见 &lt;code&gt;putWordhost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fa15d05114ccf3a54a292d7dab956acfddbd619" translate="yes" xml:space="preserve">
          <source>O(1). Write a Word32 in native host order and host endianness. For portability issues see &lt;code&gt;putWordhost&lt;/code&gt;.</source>
          <target state="translated">O（1）。按照本机主机顺序和主机字节顺序编写Word32。有关可移植性问题，请参见 &lt;code&gt;putWordhost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a11e780f1a61bda1ac70d54f20308bc95083c79" translate="yes" xml:space="preserve">
          <source>O(1). Write a Word64 in native host order On a 32 bit machine we write two host order Word32s, in big endian form. For portability issues see &lt;code&gt;putWordhost&lt;/code&gt;.</source>
          <target state="translated">O（1）。以本机主机顺序编写Word64在32位计算机上，我们以大字节序形式编写两个主机顺序Word32。有关可移植性问题，请参见 &lt;code&gt;putWordhost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4105c31526c1b2c23cfef226019e9d121a5f0732" translate="yes" xml:space="preserve">
          <source>O(1). Write a single native machine word. The word is written in host order, host endian form, for the machine you're on. On a 64 bit machine the Int is an 8 byte value, on a 32 bit machine, 4 bytes. Values written this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">O(1).写一个单一的本机字。这个字是按照你所在的机器的主机顺序,主机endian形式写的。在 64 位机器上,Int 是一个 8 字节的值,在 32 位机器上,是 4 字节。这样写的值在没有转换的情况下,不能移植到不同恩迪安或字大小的机器上。</target>
        </trans-unit>
        <trans-unit id="4fd565c6502d3274c18a3dffa4a1de1d9f4986b2" translate="yes" xml:space="preserve">
          <source>O(1). Write a single native machine word. The word is written in host order, host endian form, for the machine you're on. On a 64 bit machine the Word is an 8 byte value, on a 32 bit machine, 4 bytes. Values written this way are not portable to different endian or word sized machines, without conversion.</source>
          <target state="translated">O(1).写一个单一的本机字。这个字是按照你所在的机器的主机顺序,主机恩迪亚形式写的。在 64 位机器上,字是一个 8 字节的值,在 32 位机器上,是 4 字节。这样写的值在没有转换的情况下,不能移植到不同恩迪安或字大小的机器上。</target>
        </trans-unit>
        <trans-unit id="0a1211440c41b008025fd5d08a5a02efbd05afc8" translate="yes" xml:space="preserve">
          <source>O(1). Write an Int16 in native host order and host endianness. For portability issues see &lt;code&gt;putInthost&lt;/code&gt;.</source>
          <target state="translated">O（1）。按照本地主机顺序和主机字节顺序编写一个Int16。有关可移植性问题，请参见 &lt;code&gt;putInthost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64b8185d430f3135e2d45e7e611125c2fa41da62" translate="yes" xml:space="preserve">
          <source>O(1). Write an Int32 in native host order and host endianness. For portability issues see &lt;code&gt;putInthost&lt;/code&gt;.</source>
          <target state="translated">O（1）。按照本机主机顺序和主机字节顺序编写一个Int32。有关可移植性问题，请参见 &lt;code&gt;putInthost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd67d17a24224cf4fad81638e61d3e67d8db6e92" translate="yes" xml:space="preserve">
          <source>O(1). Write an Int64 in native host order On a 32 bit machine we write two host order Int32s, in big endian form. For portability issues see &lt;code&gt;putInthost&lt;/code&gt;.</source>
          <target state="translated">O（1）。以本机主机顺序编写一个Int64在32位计算机上，我们以大字节序形式编写两个主机顺序Int32。有关可移植性问题，请参见 &lt;code&gt;putInthost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48f2771d14d48dfa60c630493ad0c9b1f384a240" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="f76df71a59358c7dbc7d2bd6d49d6a20235b9cce" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 返回前 &lt;code&gt;n&lt;/code&gt; 个元素后的 &lt;code&gt;xs&lt;/code&gt; 后缀，如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt; xs则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af17f515239bcc935e4702a4f4a6700695d9f19b" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="332762aa91c7e13ad717bba9c0d52c92bfe7c53a" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127e23acd8e00b0d3fe958d794982720f2a93de5" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 相当于 &lt;code&gt;(&lt;a href=&quot;data-bytestring#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9953abbf9da9e931feebd7c70d539cdc8573c547" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个字节串 &lt;code&gt;xs&lt;/code&gt; ，返回的前缀 &lt;code&gt;xs&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;xs&lt;/code&gt; 本身如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b0e2e932afd954ae8b599c8cf08e02d933eac29" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="fe33cf04f77021fe94136a83192b2df80c5138a0" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; returns the suffix of &lt;code&gt;xs&lt;/code&gt; after the first &lt;code&gt;n&lt;/code&gt; elements, or &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 返回前 &lt;code&gt;n&lt;/code&gt; 个元素后的 &lt;code&gt;xs&lt;/code&gt; 后缀，如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; &lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt; xs则返回 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="316b5b4107a2056569fa09330995dcd5f6f5d78b" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 返回ByteString的长度作为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4a2a2bb077964af0c5ef645da1fc6b1425469da" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a ByteString as an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e715ab4e039d06e20c1f848353be761d880a66" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n xs&lt;/code&gt; is equivalent to &lt;code&gt;(&lt;a href=&quot;data-bytestring-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n xs&lt;/code&gt; 相当于 &lt;code&gt;(&lt;a href=&quot;data-bytestring-char8#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-bytestring-char8#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b790901cebc08771fb98982b9a797ae8635a79a1" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;, applied to a ByteString &lt;code&gt;xs&lt;/code&gt;, returns the prefix of &lt;code&gt;xs&lt;/code&gt; of length &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;xs&lt;/code&gt; itself if &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; ，施加到一个字节串 &lt;code&gt;xs&lt;/code&gt; ，返回的前缀 &lt;code&gt;xs&lt;/code&gt; 长度的 &lt;code&gt;n&lt;/code&gt; ，或 &lt;code&gt;xs&lt;/code&gt; 本身如果 &lt;code&gt;n &amp;gt; &lt;a href=&quot;data-bytestring-char8#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81d348ec756eac2297ebce38909b39338ac8932" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to &lt;code&gt;(:)&lt;/code&gt; for lists.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 类似于列表的 &lt;code&gt;(:)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84d8aa5fa7be5792634aebd1239ff67f5cc75e21" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="25d79b07a376fbd4bc45a3e9d670716e9e970bd5" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; is analogous to &lt;code&gt;(:)&lt;/code&gt; for lists.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 类似于列表的 &lt;code&gt;(:)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="513661b77f911e3e7139b1e52439a40483f3ae90" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="48db5a2c7e16edc1ca261414beb9f506892b1c7a" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-short-internal#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="359d8d0b775e683b308dab26731b241bdb0ed693" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddressLen&quot;&gt;unsafePackAddressLen&lt;/a&gt;&lt;/code&gt; provides constant-time construction of &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s, which is ideal for string literals. It packs a sequence of bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, given a raw &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; to the string, and the length of the string.</source>
          <target state="translated">O（1） &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddressLen&quot;&gt;unsafePackAddressLen&lt;/a&gt;&lt;/code&gt; 提供 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的恒定时间构造，这对于字符串文字是理想的。它将一个字节序列打包到 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，给该字符串一个原始的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; ，并给出字符串的长度。</target>
        </trans-unit>
        <trans-unit id="1514afafdfb2e6e09462412156913addf713e722" translate="yes" xml:space="preserve">
          <source>O(1)&lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddressLen&quot;&gt;unsafePackAddressLen&lt;/a&gt;&lt;/code&gt; provides constant-time construction of &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s, which is ideal for string literals. It packs a sequence of bytes into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, given a raw &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; to the string, and the length of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1be145ed2001005bb14d35b20d891eec17a0139" translate="yes" xml:space="preserve">
          <source>O(c) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a list of strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（c）将惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为严格 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表</target>
        </trans-unit>
        <trans-unit id="74667d75b2ec51e29669918eee72fba3ebeae738" translate="yes" xml:space="preserve">
          <source>O(c) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a list of strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（c）将惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为严格 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表</target>
        </trans-unit>
        <trans-unit id="5f2389ba75fd26ec5193923e1d0a09f25f526004" translate="yes" xml:space="preserve">
          <source>O(c) Convert a list of strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（c）将严格 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表转换为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a497c3b62834a5a6f2ae83148c3f48809bcca685" translate="yes" xml:space="preserve">
          <source>O(c) Convert a list of strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（c）将严格 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的列表转换为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d264b3988854013da762b4869f81230d3399ded" translate="yes" xml:space="preserve">
          <source>O(c) Convert a list of strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s into a lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（c）将严格 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的列表转换为惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e5e8f5471ea69b112c21a6ca2b82ec4773d339" translate="yes" xml:space="preserve">
          <source>O(c) Convert a strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（c）将严格 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05205d2840348358328515bb5d059d0c2e7d3a07" translate="yes" xml:space="preserve">
          <source>O(c)&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0.</source>
          <target state="translated">O（c） &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始。</target>
        </trans-unit>
        <trans-unit id="af6e3a7c23911f9a6fa7f50fa70acaf74e0cece1" translate="yes" xml:space="preserve">
          <source>O(log n). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned.</source>
          <target state="translated">O(log n)。在特定的键处调整一个值。当该键不是地图的成员时,将返回原地图。</target>
        </trans-unit>
        <trans-unit id="5c32e846e083d90915ccaf6ac3869ade0caab613" translate="yes" xml:space="preserve">
          <source>O(log n). Combines insert operation with old value retrieval. The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt;) is a pair where the first element is equal to (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;) and the second element equal to (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt;).</source>
          <target state="translated">O（log n）。将插入操作与旧值检索结合在一起。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）是一对，其中第一个元素等于（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; ），第二个元素等于（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0b2f3822bf7c1ae26bd35d1e0b67be3f7c37d01" translate="yes" xml:space="preserve">
          <source>O(log n). Combines insert operation with old value retrieval. The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt;) is a pair where the first element is equal to (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;) and the second element equal to (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt;).</source>
          <target state="translated">O（log n）。将插入操作与旧值检索结合在一起。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）是一对，其中第一个元素等于（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; ），第二个元素等于（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="073aefa25116659d43e9fd0e2e991227f7e80c9d" translate="yes" xml:space="preserve">
          <source>O(log n). Delete a key and its value from the map. When the key is not a member of the map, the original map is returned.</source>
          <target state="translated">O(log n)。从地图中删除一个键和它的值。当键不是地图的成员时,返回原地图。</target>
        </trans-unit>
        <trans-unit id="32a88437841d168a4b03991ed8d0d03dfe51f05b" translate="yes" xml:space="preserve">
          <source>O(log n). Delete an element from a set.</source>
          <target state="translated">O(log n)。从一个集合中删除一个元素。</target>
        </trans-unit>
        <trans-unit id="98588a699ab0e3cc2a4f0d4bbcd31fb1d80ddf49" translate="yes" xml:space="preserve">
          <source>O(log n). Delete and find the maximal element.</source>
          <target state="translated">O(log n)。删去并找到最大的元素。</target>
        </trans-unit>
        <trans-unit id="eac58fe63b635fd9efb58cab5645157886d37625" translate="yes" xml:space="preserve">
          <source>O(log n). Delete and find the minimal element.</source>
          <target state="translated">O(log n)。删除并找到最小元素。</target>
        </trans-unit>
        <trans-unit id="ad05ba71f70f9da853eda0a89025664664c4b775" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。删除&lt;em&gt;index&lt;/em&gt;处的元素，即按键排序序列中的从零开始的索引。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于地图的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f7fed812ef039db05e196ba266ae87718acd16" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccf48cd92d13cac8e374bba9a57309c8e08857e" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。删除&lt;em&gt;index&lt;/em&gt;处的元素，即按键排序序列中的从零开始的索引。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于地图的 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00d853000d2e6488565da714b0b5292fda5a441b" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a138b763f5bcf0b11954e6535ff11ce808241082" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sorted sequence of elements. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。删除&lt;em&gt;index&lt;/em&gt;处的元素，即按排序后的元素序列中从零开始的索引。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于集合的 &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f9a841e263ec111559da27eabf9406d1a540729" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sorted sequence of elements. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181c5af60bcb54ac4f811d680b11d508307933a1" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the maximal element. Returns an empty set if the set is empty.</source>
          <target state="translated">O(log n)。删除最大元素。如果集合为空,则返回一个空集合。</target>
        </trans-unit>
        <trans-unit id="6790550db3234f37cf6493f7b1535c713a09ba76" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the maximal key. Returns an empty map if the map is empty.</source>
          <target state="translated">O(log n)。删除最大的键。如果地图为空,返回一个空地图。</target>
        </trans-unit>
        <trans-unit id="fbc32aa53e2a4a6369d4d9562f6deeabf28ae8e7" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the minimal element. Returns an empty set if the set is empty.</source>
          <target state="translated">O(log n)。删除最小元素。如果集合为空,则返回一个空集合。</target>
        </trans-unit>
        <trans-unit id="7cf4d523f99138c238ea157a7e88da884c96423d" translate="yes" xml:space="preserve">
          <source>O(log n). Delete the minimal key. Returns an empty map if the map is empty.</source>
          <target state="translated">O(log n)。删除最小键。如果地图为空,返回一个空地图。</target>
        </trans-unit>
        <trans-unit id="94dc59b450b55ade9833343f711d54182224fe30" translate="yes" xml:space="preserve">
          <source>O(log n). Divide a map at the point where a predicate on the keys stops holding. The user is responsible for ensuring that for all keys &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the map, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;.</source>
          <target state="translated">O（log n）。在键上的谓词停止保持的位置划分地图。用户负责确保映射中的所有键 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19c7a4f5123369243555c207001e5355651809c6" translate="yes" xml:space="preserve">
          <source>O(log n). Divide a set at the point where a predicate on the elements stops holding. The user is responsible for ensuring that for all elements &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the set, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;.</source>
          <target state="translated">O（log n）。在元素的谓词停止保持的点上划分集合。用户是负责确保所有元素 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 在该组， &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbbe96dbb3f910804916b2bf6b9f9c4a00de96df" translate="yes" xml:space="preserve">
          <source>O(log n). Drop while a predicate on the elements holds. The user is responsible for ensuring that for all elements &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the set, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-set#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。在元素的谓词成立时放下。用户是负责确保所有元素 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 在该组， &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-set#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="6bd8dcfa2cd7fed4471d0799d179b6297b9a6ff9" translate="yes" xml:space="preserve">
          <source>O(log n). Drop while a predicate on the keys holds. The user is responsible for ensuring that for all keys &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the map, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。按住键上的谓词时放下。用户负责确保映射中的所有键 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="4d73a626bb138826eaf0b30feaf1a52a50743ef7" translate="yes" xml:space="preserve">
          <source>O(log n). Drop while a predicate on the keys holds. The user is responsible for ensuring that for all keys &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the map, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-map-strict#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。按住键上的谓词时放下。用户负责确保映射中的所有键 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="c054a90bcde9445ceb0ad65d2d81dbd0a79070e9" translate="yes" xml:space="preserve">
          <source>O(log n). Find largest element smaller or equal to the given one.</source>
          <target state="translated">O(log n)。找出小于或等于给定元素的最大元素。</target>
        </trans-unit>
        <trans-unit id="22f8c5d39b35a0c1903faaf4fd9bdc6b957bdd68" translate="yes" xml:space="preserve">
          <source>O(log n). Find largest element smaller than the given one.</source>
          <target state="translated">O(log n)。找出比给定元素小的最大元素。</target>
        </trans-unit>
        <trans-unit id="c54f0ae11eb14d8371f7752243637479199282c4" translate="yes" xml:space="preserve">
          <source>O(log n). Find largest key smaller or equal to the given one and return the corresponding (key, value) pair.</source>
          <target state="translated">O(log n)。找出小于或等于给定的最大键,并返回相应的(键,值)对。</target>
        </trans-unit>
        <trans-unit id="0cbd5435f7e27980c116ae0cbf1bec62916dab0d" translate="yes" xml:space="preserve">
          <source>O(log n). Find largest key smaller than the given one and return the corresponding (key, value) pair.</source>
          <target state="translated">O(log n)。找出比给定键小的最大键,并返回相应的(键,值)对。</target>
        </trans-unit>
        <trans-unit id="c166cc88a9061a0faff568068500fac730cd1814" translate="yes" xml:space="preserve">
          <source>O(log n). Find smallest element greater or equal to the given one.</source>
          <target state="translated">O(log n)。找出大于或等于给定元素的最小元素。</target>
        </trans-unit>
        <trans-unit id="bcbb0a2e40a67b635be36d431f43d2ffa11e95eb" translate="yes" xml:space="preserve">
          <source>O(log n). Find smallest element greater than the given one.</source>
          <target state="translated">O(log n)。找出比给定元素大的最小元素。</target>
        </trans-unit>
        <trans-unit id="386ffcb6cfe6b3ab23a2c54a241fdf164b8c87d1" translate="yes" xml:space="preserve">
          <source>O(log n). Find smallest key greater or equal to the given one and return the corresponding (key, value) pair.</source>
          <target state="translated">O(log n)。找出大于或等于给定的最小键,并返回相应的(键,值)对。</target>
        </trans-unit>
        <trans-unit id="03c25e8e40b24a17f03f0806610d599831aae84f" translate="yes" xml:space="preserve">
          <source>O(log n). Find smallest key greater than the given one and return the corresponding (key, value) pair.</source>
          <target state="translated">O(log n)。找出比给定键大的最小键,并返回相应的(键,值)对。</target>
        </trans-unit>
        <trans-unit id="e819bde42f73b70f2dee6f1c39d4f04065803ccc" translate="yes" xml:space="preserve">
          <source>O(log n). Find the value at a key. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="translated">O（log n）。在键上找到值。当找不到元素时调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a29ed5f140634a473e81aab082456f838115e19" translate="yes" xml:space="preserve">
          <source>O(log n). Find the value at a key. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ab75822ed89103eda7f1e92a96f10c32286f07" translate="yes" xml:space="preserve">
          <source>O(log n). Find the value at a key. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="translated">O（log n）。在键上找到值。当找不到元素时，返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6542c4c5766a217c317b3b982892f57870e29732" translate="yes" xml:space="preserve">
          <source>O(log n). Find the value at a key. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019ca7975312c117efa851704f554fc877e21e48" translate="yes" xml:space="preserve">
          <source>O(log n). Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。在地图中插入新的键和值。如果键已存在于映射中，则将关联的值替换为提供的值。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="890e69b546d584fa2e7719c610c759ce20bf11db" translate="yes" xml:space="preserve">
          <source>O(log n). Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93122902b3ce42539585f883cb3a58a5a2492dd" translate="yes" xml:space="preserve">
          <source>O(log n). Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。在地图中插入新的键和值。如果键已存在于映射中，则将关联的值替换为提供的值。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e45ca3a86dc47e0a048198626bad89f3a07c1167" translate="yes" xml:space="preserve">
          <source>O(log n). Insert a new key and value in the map. If the key is already present in the map, the associated value is replaced with the supplied value. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aa915e14eda50a9fe587ae53fcea61f10b9eff" translate="yes" xml:space="preserve">
          <source>O(log n). Insert an element in a set. If the set already contains an element equal to the given value, it is replaced with the new value.</source>
          <target state="translated">O(log n)。在一个集合中插入一个元素。如果集合中已经包含一个等于给定值的元素,则用新的值替换。</target>
        </trans-unit>
        <trans-unit id="ab30bbb0e160d85a91fb53cc20d393b681529f2c" translate="yes" xml:space="preserve">
          <source>O(log n). Insert with a function, combining key, new value and old value. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert the pair &lt;code&gt;(key,f key new_value old_value)&lt;/code&gt;. Note that the key passed to f is the same key passed to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。插入功能，结合键，新值和旧值。如果映射中不存在key，则 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; 会将对（键，值）插入 &lt;code&gt;mp&lt;/code&gt; 中。如果键确实存在，该函数将插入对 &lt;code&gt;(key,f key new_value old_value)&lt;/code&gt; 。请注意，传递给f的键与传递给 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 的键相同。</target>
        </trans-unit>
        <trans-unit id="d3eb71411ee6d48888bcea43d4a1ea6a30107c13" translate="yes" xml:space="preserve">
          <source>O(log n). Insert with a function, combining key, new value and old value. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert the pair &lt;code&gt;(key,f key new_value old_value)&lt;/code&gt;. Note that the key passed to f is the same key passed to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。插入功能，结合键，新值和旧值。如果映射中不存在key，则 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; 会将对（键，值）插入 &lt;code&gt;mp&lt;/code&gt; 中。如果键确实存在，该函数将插入对 &lt;code&gt;(key,f key new_value old_value)&lt;/code&gt; 。请注意，传递给f的键与传递给 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 的键相同。</target>
        </trans-unit>
        <trans-unit id="c303e9e33583ca10d0311eaa78b1ec3836d2ba66" translate="yes" xml:space="preserve">
          <source>O(log n). Insert with a function, combining new value and old value. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert the pair &lt;code&gt;(key, f new_value old_value)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。插入一个函数，将新值和旧值组合在一起。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; &lt;code&gt;mp&lt;/code&gt; 如果映射中不存在key，则将对（键，值）插入mp。如果键确实存在，则该函数将插入对 &lt;code&gt;(key, f new_value old_value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab99c304a7c1bc44b47fcc76ff24ddeaf74a156a" translate="yes" xml:space="preserve">
          <source>O(log n). Insert with a function, combining new value and old value. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert the pair &lt;code&gt;(key, f new_value old_value)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。插入一个函数，将新值和旧值组合在一起。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; &lt;code&gt;mp&lt;/code&gt; 如果映射中不存在key，则将对（键，值）插入mp。如果键确实存在，则该函数将插入对 &lt;code&gt;(key, f new_value old_value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7909b1a215db48e576d94f06d2ca092625d11dc3" translate="yes" xml:space="preserve">
          <source>O(log n). Is the element in the set?</source>
          <target state="translated">O(log n)。元素是否在集合中?</target>
        </trans-unit>
        <trans-unit id="1d6a5e97e24e7c1a5f6a2e7f2bf174b2b039a516" translate="yes" xml:space="preserve">
          <source>O(log n). Is the element not in the set?</source>
          <target state="translated">O(log n)。该元素不在集合中吗?</target>
        </trans-unit>
        <trans-unit id="93420e251bb522f3edff5b61e4bb4755f20fb04a" translate="yes" xml:space="preserve">
          <source>O(log n). Is the key a member of the map? See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:notMember&quot;&gt;notMember&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。钥匙是地图的成员吗？另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:notMember&quot;&gt;notMember&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d02b6dd90232b232e1c2539a783ea56f43e6f101" translate="yes" xml:space="preserve">
          <source>O(log n). Is the key a member of the map? See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:notMember&quot;&gt;notMember&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。钥匙是地图的成员吗？另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:notMember&quot;&gt;notMember&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1fe4f566babb2256607c6aaa79cb42b8b841988" translate="yes" xml:space="preserve">
          <source>O(log n). Is the key not a member of the map? See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。钥匙不是地图的成员吗？另请参阅 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c288a50f28e510d77952c813c670527c9a0633c" translate="yes" xml:space="preserve">
          <source>O(log n). Is the key not a member of the map? See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。钥匙不是地图的成员吗？另请参阅 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d7390e74de7c336333d4a8a806077372bb35a3" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup and update. See also &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt;&lt;/code&gt;. The function returns changed value, if it is updated. Returns the original key value if the map entry is deleted.</source>
          <target state="translated">O（log n）。查找和更新。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt;&lt;/code&gt; 。如果更新，该函数将返回更改后的值。如果删除了地图项，则返回原始键值。</target>
        </trans-unit>
        <trans-unit id="f481f2fd72b729ff1ff3b6f8cc827e854467c4de" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup and update. See also &lt;code&gt;&lt;a href=&quot;data-map-strict#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt;&lt;/code&gt;. The function returns changed value, if it is updated. Returns the original key value if the map entry is deleted.</source>
          <target state="translated">O（log n）。查找和更新。另请参见 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt;&lt;/code&gt; 。如果更新，该函数将返回更改后的值。如果删除了地图项，则返回原始键值。</target>
        </trans-unit>
        <trans-unit id="baf2102b1f382e0a669f93c4b9db2a7e8dd36c72" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="translated">O（log n）。查找键的&lt;em&gt;索引&lt;/em&gt;，它是按键排序的序列中从零开始的索引。索引是一个从&lt;em&gt;0&lt;/em&gt;到但不包括地图 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。</target>
        </trans-unit>
        <trans-unit id="56d8a61798fd9cbe0182cb2ae5cc0279469f8c7a" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="translated">O（log n）。查找键的&lt;em&gt;索引&lt;/em&gt;，它是按键排序的序列中从零开始的索引。索引是一个从&lt;em&gt;0&lt;/em&gt;到但不包括地图 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。</target>
        </trans-unit>
        <trans-unit id="17038d38b7c384c30f26ac44610a872b0c457a98" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup the &lt;em&gt;index&lt;/em&gt; of an element, which is its zero-based index in the sorted sequence of elements. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set.</source>
          <target state="translated">O（log n）。查找元素的&lt;em&gt;索引&lt;/em&gt;，这是元素的排序序列中从零开始的索引。索引是从&lt;em&gt;0&lt;/em&gt;到但不包括集合 &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。</target>
        </trans-unit>
        <trans-unit id="3c0961dee65d18050a044e97e8e4b95713c11b54" translate="yes" xml:space="preserve">
          <source>O(log n). Lookup the value at a key in the map.</source>
          <target state="translated">O(log n)。在地图中的某个键处查找值。</target>
        </trans-unit>
        <trans-unit id="ca99e4520ea2482791017e12374e93c86c40626a" translate="yes" xml:space="preserve">
          <source>O(log n). Performs a &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot element was found in the original set.</source>
          <target state="translated">O（log n）。执行 &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始集中找到了枢轴元素。</target>
        </trans-unit>
        <trans-unit id="5ca1b7273b4b039c8f02f3f6db3eb71e4cee1c3a" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。通过其&lt;em&gt;索引&lt;/em&gt;（即，按键排序的序列中从零开始的索引）检索元素。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于地图的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fbd20ba1e097e2fe919cb7c9f861d0705b5de7f" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a573df304c5cfe9d3a5e45be45f263e5d31a5416" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。通过其&lt;em&gt;索引&lt;/em&gt;（即，按键排序的序列中从零开始的索引）检索元素。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于地图的 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12be2fbeafb6f21b6f94c4c759c42ed698616a74" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ad71696e650ca1a2af78787af00f58520298a1" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sorted sequence of elements. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。通过元素的&lt;em&gt;索引&lt;/em&gt;（即元素的排序序列中从零开始的索引）检索元素。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于集合的 &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2326a117339c8a4092a536379277568c82b40712" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieve an element by its &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sorted sequence of elements. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf816a91eeb2d4bf3180cd5d89ea5959395f954" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（log n）。检索映射的最大（键，值）对，以及从该元素中剥离的映射，如果传递了空映射，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab20c62c5301461314db45506023711d692e2d4f" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670b9cb16dc7d6ba3c68eeb4f865f7ae1622fdcd" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the maximal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="translated">O（log n）。检索集合的最大键，并删除该元素的集合，如果传递了空集合，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f37f6d3f8c5075a1b60cbd4fe664882f1dce38ca" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the maximal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39248bbdd1d8d5f568b1794c433b4789cd821c3e" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（log n）。检索地图的最小（键，值）对，并去除该元素的地图；如果传递了空地图，则获取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57d0e25053022ca6496d2fa589490a3a7ac91a1b" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b373e366a112bdfa3ea3363432c0b6a7d59aa" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the minimal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="translated">O（log n）。检索集合的最小键，并删除该集合的元素，如果传递空集合，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28f5487cd0685f69f928d45b77785d8acc263078" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the minimal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c8e44c2a29468317d9b7515cd93dda87f9a202" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the value associated with maximal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（log n）。检索与地图的最大键相关联的值，并从该地图上剥离该元素；如果传递空地图，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc498300eb0b48ca6979b9e323f3aa4cb8b6f5f7" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the value associated with maximal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a615b27bb68ae386cdb67bea660c6e66528c017" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the value associated with minimal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（log n）。检索与地图的最小键关联的值，以及从该地图去除了该元素的地图；如果传递了空地图，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d402f22b4b910b51607d0d0074bc0b6165af9e7" translate="yes" xml:space="preserve">
          <source>O(log n). Retrieves the value associated with minimal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c514295f87d1ca84ba6db8541425c2d9831917c" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the key is not a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="translated">O（log n）。返回键的&lt;em&gt;索引&lt;/em&gt;，它是按键排序的序列中从零开始的索引。索引是从&lt;em&gt;0&lt;/em&gt;到但不包括地图 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。当键不是地图的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; 时，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b84f7949c8550e7f1f977ad54b660c3cf511a5" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the key is not a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c21566259dfcedc27a229f682291b87f887697" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the key is not a &lt;code&gt;&lt;a href=&quot;data-map-strict#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="translated">O（log n）。返回键的&lt;em&gt;索引&lt;/em&gt;，它是按键排序的序列中从零开始的索引。索引是从&lt;em&gt;0&lt;/em&gt;到但不包括地图 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。当键不是地图的 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; 时，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="920b06814f65fd62b5599b99138b38ad4ba8276d" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of a key, which is its zero-based index in the sequence sorted by keys. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-map-strict#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the key is not a &lt;code&gt;&lt;a href=&quot;data-map-strict#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6392e60e3cd19809cd08495d76c065cada91cb" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of an element, which is its zero-based index in the sorted sequence of elements. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element is not a &lt;code&gt;&lt;a href=&quot;data-set#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the set.</source>
          <target state="translated">O（log n）。返回元素的&lt;em&gt;索引&lt;/em&gt;，这是元素排序后的元素从零开始的索引。索引是从&lt;em&gt;0&lt;/em&gt;到但不包括集合 &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; 的数字。当元素不是集合的 &lt;code&gt;&lt;a href=&quot;data-set#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; 时，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f20a6a2ebe4c1bc4356e24d4cac02373a2eab16" translate="yes" xml:space="preserve">
          <source>O(log n). Return the &lt;em&gt;index&lt;/em&gt; of an element, which is its zero-based index in the sorted sequence of elements. The index is a number from &lt;em&gt;0&lt;/em&gt; up to, but not including, the &lt;code&gt;&lt;a href=&quot;data-set#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the set. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element is not a &lt;code&gt;&lt;a href=&quot;data-set#v:member&quot;&gt;member&lt;/a&gt;&lt;/code&gt; of the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b39c10f5395aedc4a9107b96f66a5d8b36b5ebd" translate="yes" xml:space="preserve">
          <source>O(log n). Split a map at a particular index.</source>
          <target state="translated">O(log n)。在某一特定索引处拆分一个地图。</target>
        </trans-unit>
        <trans-unit id="8ef9aa443e04929c386c965b34861c97ae9e8c21" translate="yes" xml:space="preserve">
          <source>O(log n). Split a set at a particular index.</source>
          <target state="translated">O(log n)。在某一特定索引处拆分一个集合。</target>
        </trans-unit>
        <trans-unit id="4b9666d6af9c50f9ae999346b3dff678398e7d40" translate="yes" xml:space="preserve">
          <source>O(log n). Take while a predicate on the elements holds. The user is responsible for ensuring that for all elements &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the set, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-set#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。假设元素上的谓词成立。用户是负责确保所有元素 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 在该组， &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-set#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="021166fabe5a2434a8793e0abec1bfd86c66be03" translate="yes" xml:space="preserve">
          <source>O(log n). Take while a predicate on the keys holds. The user is responsible for ensuring that for all keys &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the map, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。按住键上的谓词。用户负责确保映射中的所有键 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="66a508937864d4ec6df07112c22f6f25123880b3" translate="yes" xml:space="preserve">
          <source>O(log n). Take while a predicate on the keys holds. The user is responsible for ensuring that for all keys &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; in the map, &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt;. See note at &lt;code&gt;&lt;a href=&quot;data-map-strict#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（log n）。按住键上的谓词。用户负责确保映射中的所有键 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; &lt;code&gt;j &amp;lt; k ==&amp;gt; p j &amp;gt;= p k&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:spanAntitone&quot;&gt;spanAntitone&lt;/a&gt;&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="07985d8bb10f9ea56955aad534ec1fb0ee1ecde0" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; can be used to inspect, insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f
 (&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 可用于检查，插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbdb624ad922439626975a2694af40dd74323694" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; can be used to inspect, insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f
 (&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 可用于检查，插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80800c88ab3ea5c7eeb370232e0fce4820989aaf" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; can be used to inspect, insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f
 (&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 可用于检查，插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k &lt;a href=&quot;%24&quot;&gt;$&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b17c31779999be462616440caced04e05ce795d0" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; can be used to insert, delete, or update a value in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 可用于插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16a84137ad6b83c400797fa72447394c88dbd79f" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; can be used to inspect, insert, delete, or update a value in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. In short: &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k &amp;lt;$&amp;gt; &lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f
 (&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 可用于检查，插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k &amp;lt;$&amp;gt; &lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="846cee8bfff2febb81f9991ef0df69c4e96a54dd" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt;) is a pair &lt;code&gt;(map1,map2)&lt;/code&gt; where the keys in &lt;code&gt;map1&lt;/code&gt; are smaller than &lt;code&gt;k&lt;/code&gt; and the keys in &lt;code&gt;map2&lt;/code&gt; larger than &lt;code&gt;k&lt;/code&gt;. Any key equal to &lt;code&gt;k&lt;/code&gt; is found in neither &lt;code&gt;map1&lt;/code&gt; nor &lt;code&gt;map2&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt; ）是一对 &lt;code&gt;(map1,map2)&lt;/code&gt; ，其中 &lt;code&gt;map1&lt;/code&gt; 中的键小于 &lt;code&gt;k&lt;/code&gt; ，而 &lt;code&gt;map2&lt;/code&gt; 中的键大于 &lt;code&gt;k&lt;/code&gt; 。在 &lt;code&gt;map1&lt;/code&gt; 和 &lt;code&gt;map2&lt;/code&gt; 中都找不到等于 &lt;code&gt;k&lt;/code&gt; 的任何键。</target>
        </trans-unit>
        <trans-unit id="4cf60d3defa4a074751ebaa4b78e7d45e27cd485" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:splitLookup&quot;&gt;splitLookup&lt;/a&gt; k map&lt;/code&gt;) splits a map just like &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:splitLookup&quot;&gt;splitLookup&lt;/a&gt; k map&lt;/code&gt; ）像 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 一样拆分地图，而且还返回 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77dc05af812457fc6d20ad1d8d76485e45c9e5c9" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e071fcb00978659fb7e585f91e7fe4d40c01e8b7" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5bcaeee0bb1b7163dcc0a43971989cf3a9392c" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt; ）将 &lt;code&gt;k&lt;/code&gt; 处的值 &lt;code&gt;x&lt;/code&gt; 更新（如果它在映射中）。如果（ &lt;code&gt;f k x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; y），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bfe4775eb26ffd0f1c6afadf6bad0f091fa542f" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420200fe54e3b7064bf01736dbaed8c7fc822039" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; can be used to insert, delete, or update a value in a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 可用于插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-map-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38d6b1873475d1bbf53194fdef1c62c16a8fa59f" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; can be used to inspect, insert, delete, or update a value in a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. In short: &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k &amp;lt;$&amp;gt; &lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 可用于检查，插入，删除或更新 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 中的值。简而言之： &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k &amp;lt;$&amp;gt; &lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt; f k m = f (&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8844772ffce9d1bdf37c3fbbe1c5d36447bbca81" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt;) is a pair &lt;code&gt;(map1,map2)&lt;/code&gt; where the keys in &lt;code&gt;map1&lt;/code&gt; are smaller than &lt;code&gt;k&lt;/code&gt; and the keys in &lt;code&gt;map2&lt;/code&gt; larger than &lt;code&gt;k&lt;/code&gt;. Any key equal to &lt;code&gt;k&lt;/code&gt; is found in neither &lt;code&gt;map1&lt;/code&gt; nor &lt;code&gt;map2&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt; ）是一对 &lt;code&gt;(map1,map2)&lt;/code&gt; ，其中 &lt;code&gt;map1&lt;/code&gt; 中的键小于 &lt;code&gt;k&lt;/code&gt; ，而 &lt;code&gt;map2&lt;/code&gt; 中的键大于 &lt;code&gt;k&lt;/code&gt; 。在 &lt;code&gt;map1&lt;/code&gt; 和 &lt;code&gt;map2&lt;/code&gt; 中都找不到等于 &lt;code&gt;k&lt;/code&gt; 的任何键。</target>
        </trans-unit>
        <trans-unit id="4bce83bccf119db7643fd19957e649f5abd26420" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:splitLookup&quot;&gt;splitLookup&lt;/a&gt; k map&lt;/code&gt;) splits a map just like &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:splitLookup&quot;&gt;splitLookup&lt;/a&gt; k map&lt;/code&gt; ）像 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 一样拆分地图，而且还返回 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="141cb5e7031d13ae3e5d38b593828d3e953ace06" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2692f0fd9895bf6c576908bd72eefd3cd73bfa6" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942fcde6574fd0bf1dadaa061f06747e7027860b" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt; ）将 &lt;code&gt;k&lt;/code&gt; 处的值 &lt;code&gt;x&lt;/code&gt; 更新（如果它在映射中）。如果（ &lt;code&gt;f k x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; y），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d439c820104fa4df32198f00d041eb334f2ee252" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:updateWithKey&quot;&gt;updateWithKey&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0083ce39eafea25bc1eb434d4710802b4b9b9434" translate="yes" xml:space="preserve">
          <source>O(log n). The expression (&lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt;) is a pair &lt;code&gt;(set1,set2)&lt;/code&gt; where &lt;code&gt;set1&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; less than &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">O（log n）。表达式（ &lt;code&gt;&lt;a href=&quot;data-set#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt; ）是一个对 &lt;code&gt;(set1,set2)&lt;/code&gt; ，其中 &lt;code&gt;set1&lt;/code&gt; 包含小于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素，而 &lt;code&gt;set2&lt;/code&gt; 包含大于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="f59e471908c0cb769e323ded7451edf88824d17a" translate="yes" xml:space="preserve">
          <source>O(log n). The expression &lt;code&gt;(&lt;a href=&quot;data-map-lazy#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; returns the value at key &lt;code&gt;k&lt;/code&gt; or returns default value &lt;code&gt;def&lt;/code&gt; when the key is not in the map.</source>
          <target state="translated">O（log n）。表达式 &lt;code&gt;(&lt;a href=&quot;data-map-lazy#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; 返回键 &lt;code&gt;k&lt;/code&gt; 的值，或者当键不在映射中时返回默认值 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b8eabb149549a5a4f5aa89de7316f9295fe5642" translate="yes" xml:space="preserve">
          <source>O(log n). The expression &lt;code&gt;(&lt;a href=&quot;data-map-strict#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; returns the value at key &lt;code&gt;k&lt;/code&gt; or returns default value &lt;code&gt;def&lt;/code&gt; when the key is not in the map.</source>
          <target state="translated">O（log n）。表达式 &lt;code&gt;(&lt;a href=&quot;data-map-strict#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; 返回键 &lt;code&gt;k&lt;/code&gt; 的值，或者当键不在映射中时返回默认值 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b7902cec921dd561cb2e74c422b1f566ccb6fc1" translate="yes" xml:space="preserve">
          <source>O(log n). The maximal element of a set.</source>
          <target state="translated">O(log n)。一个集合的最大元素。</target>
        </trans-unit>
        <trans-unit id="d0dba945940bf77a9f8546f5e8d6bc56c10244fa" translate="yes" xml:space="preserve">
          <source>O(log n). The maximal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="translated">O（log n）。地图的最大键。如果映射为空，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17a9cd4dbc2d223856f51279a9d165a4d08158e6" translate="yes" xml:space="preserve">
          <source>O(log n). The maximal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e29493e9815e34f81908db72301e0f9af6f2e1" translate="yes" xml:space="preserve">
          <source>O(log n). The minimal element of a set.</source>
          <target state="translated">O(log n)。一个集合的最小元素。</target>
        </trans-unit>
        <trans-unit id="75bf53779ddd197f25d637059702a3c3edcf89b6" translate="yes" xml:space="preserve">
          <source>O(log n). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="translated">O（log n）。地图的最小键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5defe887cab709582327a38a9ed266771fcad21c" translate="yes" xml:space="preserve">
          <source>O(log n). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc504508d7c033dfb2ffc72482be53a17cccd4ab" translate="yes" xml:space="preserve">
          <source>O(log n). The minimal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="translated">O（log n）。地图的最小键。如果映射为空，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ffc6991b17f97549dbf273ef190d2cc99c6b07f" translate="yes" xml:space="preserve">
          <source>O(log n). The minimal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6297181a94307d00070168de4a757799d8df5e" translate="yes" xml:space="preserve">
          <source>O(log n). Update a value at a specific key with the result of the provided function. When the key is not a member of the map, the original map is returned.</source>
          <target state="translated">O(log n)。用提供的函数的结果更新特定键的值。当键不是地图的成员时,返回原始地图。</target>
        </trans-unit>
        <trans-unit id="f79b5a6aa413d4037719e05758f32c5f8ba90d30" translate="yes" xml:space="preserve">
          <source>O(log n). Update the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">O（log n）。更新&lt;em&gt;index&lt;/em&gt;处的元素，即按键排序序列中的从零开始的索引。如果&lt;em&gt;索引&lt;/em&gt;超出范围（小于零，大于或等于地图的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ），则会调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6930702e5d5905392f0652368b1a623f5461ec98" translate="yes" xml:space="preserve">
          <source>O(log n). Update the element at &lt;em&gt;index&lt;/em&gt;, i.e. by its zero-based index in the sequence sorted by keys. If the &lt;em&gt;index&lt;/em&gt; is out of range (less than zero, greater or equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; of the map), &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a883eed1f0e84ad0d1adac39532f5c417c5952fd" translate="yes" xml:space="preserve">
          <source>O(log n). Update the element at &lt;em&gt;index&lt;/em&gt;. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when an invalid index is used.</source>
          <target state="translated">O（log n）。更新&lt;em&gt;index&lt;/em&gt;处的元素。使用无效索引时调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a64596e117217d108f251b2bf2ee525eed4f77d5" translate="yes" xml:space="preserve">
          <source>O(log n). Update the element at &lt;em&gt;index&lt;/em&gt;. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when an invalid index is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86e8b51009be278f98c522ea044dc7efe4b0b2c" translate="yes" xml:space="preserve">
          <source>O(log n). Update the value at the maximal key.</source>
          <target state="translated">O(log n)。在最大键处更新值。</target>
        </trans-unit>
        <trans-unit id="925dd16a87a450286fe6e3a226b6245309317e84" translate="yes" xml:space="preserve">
          <source>O(log n). Update the value at the minimal key.</source>
          <target state="translated">O(log n)。更新最小键的值。</target>
        </trans-unit>
        <trans-unit id="200baab44017e862c998bed9f5a88ffe409337e0" translate="yes" xml:space="preserve">
          <source>O(log&lt;em&gt; k)&lt;/em&gt;. &lt;code&gt;&lt;a href=&quot;data-sequence#v:cycleTaking&quot;&gt;cycleTaking&lt;/a&gt; k xs&lt;/code&gt; forms a sequence of length &lt;code&gt;k&lt;/code&gt; by repeatedly concatenating &lt;code&gt;xs&lt;/code&gt; with itself. &lt;code&gt;xs&lt;/code&gt; may only be empty if &lt;code&gt;k&lt;/code&gt; is 0.</source>
          <target state="translated">为O（log &lt;em&gt;K） &lt;/em&gt;。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:cycleTaking&quot;&gt;cycleTaking&lt;/a&gt; k xs&lt;/code&gt; 通过将 &lt;code&gt;xs&lt;/code&gt; 与自身重复连接而形成长度为 &lt;code&gt;k&lt;/code&gt; 的序列。如果 &lt;code&gt;k&lt;/code&gt; 为0，则 &lt;code&gt;xs&lt;/code&gt; 只能为空。</target>
        </trans-unit>
        <trans-unit id="ea599e3b9adb4a817ef3358c0e6ce26510f610c8" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. &lt;code&gt;(s1 `isProperSubsetOf` s2)&lt;/code&gt; indicates whether &lt;code&gt;s1&lt;/code&gt; is a proper subset of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。 &lt;code&gt;(s1 `isProperSubsetOf` s2)&lt;/code&gt; 指示 &lt;code&gt;s1&lt;/code&gt; 是否是 &lt;code&gt;s2&lt;/code&gt; 的适当子集。</target>
        </trans-unit>
        <trans-unit id="7f120dfe430dcf91f1806848ae0ebb84996478fd" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; indicates whether &lt;code&gt;s1&lt;/code&gt; is a subset of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。 &lt;code&gt;(s1 `isSubsetOf` s2)&lt;/code&gt; 指示 &lt;code&gt;s1&lt;/code&gt; 是否为 &lt;code&gt;s2&lt;/code&gt; 的子集。</target>
        </trans-unit>
        <trans-unit id="890536917eae87ea2ce9b9265523e515197ccc98" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Check whether the key sets of two maps are disjoint (i.e., their &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。检查两个地图的键集是否不相交（即，它们的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="56887fb99e2fa5f7d002374b35d1d1c4a254b87f" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Check whether the key sets of two maps are disjoint (i.e., their &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; is empty).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。检查两个地图的键集是否不相交（即，它们的 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 为空）。</target>
        </trans-unit>
        <trans-unit id="efe7a894c2259a7792dd8fe72ad96807fe0b3199" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Check whether two sets are disjoint (i.e., their intersection is empty).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。检查两个集合是否不相交（即它们的交集为空）。</target>
        </trans-unit>
        <trans-unit id="d3ff11ef4eb80e41910d6fa66aca5cc33fdc13df" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Difference of two maps. Return elements of the first map not existing in the second map.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两张地图的区别。返回第二张地图中不存在的第一张地图的元素。</target>
        </trans-unit>
        <trans-unit id="53a7b84438e4db5ebbeef4186b723c70f40bd6d9" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Difference of two sets.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两组差异。</target>
        </trans-unit>
        <trans-unit id="cbd2c49887d009a2c47e8b2ebb341bd0fcee38b7" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Intersection of two maps. Return data in the first map for the keys existing in both maps. (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两张地图的交点。在第一个地图中返回两个地图中现有键的数据。（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="056d15b52d2db14790454c78624da8a5f3dbef97" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Intersection of two maps. Return data in the first map for the keys existing in both maps. (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24384862da1da4772be95c928fa0e56cd1c26bcc" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Intersection of two maps. Return data in the first map for the keys existing in both maps. (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两张地图的交点。在第一个地图中返回两个地图中现有键的数据。（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f4a4d5aa0fe07824e62be14dc8acc96ac0551b0d" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Intersection of two maps. Return data in the first map for the keys existing in both maps. (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt; m1 m2 == &lt;a href=&quot;data-map-lazy#v:intersectionWith&quot;&gt;intersectionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; m1 m2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ea8f6c03512981409f12bafc0cdf1ce0bce15d" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Intersection with a combining function.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。具有组合功能的交叉路口。</target>
        </trans-unit>
        <trans-unit id="69726103bf86bbabc6383796a766f72732440e39" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。这是合适的子图吗？（即子图，但不相等）。定义为（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="36000bd072b354123c4db326516ad04c95634c92" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). Defined as (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。这是合适的子图吗？（即子图，但不相等）。定义为（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:isProperSubmapOf&quot;&gt;isProperSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b8a0eb51eb1b43177a7fea9d0b7ee3d98e21e1dc" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。这是合适的子图吗？（即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2597fe5698598ff44f24dc80ca926ad32a1e8e8" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ff11d8c423e267647b0c62c479fbb61548c9cc" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。这是合适的子图吗？（即子图，但不相等）。当 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 不相等， &lt;code&gt;m1&lt;/code&gt; 中的所有键都在 &lt;code&gt;m2&lt;/code&gt; 中时，表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，表达式f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="79472f9f58c1bfab8565789aab21ccfeff8a246a" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Is this a proper submap? (ie. a submap but not equal). The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isProperSubmapOfBy&quot;&gt;isProperSubmapOfBy&lt;/a&gt; f m1 m2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are not equal, all keys in &lt;code&gt;m1&lt;/code&gt; are in &lt;code&gt;m2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9f9f93684e40fedff7b8f3d7b1d43b17fcf50e" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Remove all keys in a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。从 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 删除 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 中的所有键。</target>
        </trans-unit>
        <trans-unit id="25d1829822c2cb6940b138a4881a5d2cbd233395" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Remove all keys in a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。从 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 删除 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 中的所有键。</target>
        </trans-unit>
        <trans-unit id="fd19834586d78b2279282ad35c5312f23907cbb4" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Restrict a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; to only those keys found in a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。将 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 限制为仅在 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 中找到的那些键。</target>
        </trans-unit>
        <trans-unit id="e256a2e1874ee4e88bea6e8b5d2c1038be1580bc" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Restrict a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; to only those keys found in a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。将 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 限制为仅在 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 中找到的那些键。</target>
        </trans-unit>
        <trans-unit id="fc9a76b1e849784b891ff401f283438e0197cff8" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;t1&lt;/code&gt; are in tree &lt;code&gt;t2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。如果 &lt;code&gt;t1&lt;/code&gt; 中的所有键都在树 &lt;code&gt;t2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e73af8eb26516ab7a5c74efe69cd1f0d71b0b970" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;t1&lt;/code&gt; are in tree &lt;code&gt;t2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534ba675f9e7515b5c796d43157c0f4311986cd2" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt;) takes the left-biased union of &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;. It prefers &lt;code&gt;t1&lt;/code&gt; when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt; ）采用 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; 的左偏联合。当遇到重复的键时，它更喜欢 &lt;code&gt;t1&lt;/code&gt; ，即（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2d934294b9dc63b5f98cc35e1da76aadd0c40908" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt;) takes the left-biased union of &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;. It prefers &lt;code&gt;t1&lt;/code&gt; when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9aac91c9f6df7e573a4f748866dd23ad70f5a7" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;t1&lt;/code&gt; are in tree &lt;code&gt;t2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。如果 &lt;code&gt;t1&lt;/code&gt; 中的所有键都在树 &lt;code&gt;t2&lt;/code&gt; 中，则表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt; ）返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，并且当 &lt;code&gt;f&lt;/code&gt; 应用于它们各自的值时，f返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。例如，以下表达式均为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="00043fa789f8c62e139acd917dd73e0ff7dc7003" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; f t1 t2&lt;/code&gt;) returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all keys in &lt;code&gt;t1&lt;/code&gt; are in tree &lt;code&gt;t2&lt;/code&gt;, and when &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to their respective values. For example, the following expressions are all &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bcae9aca1a5a3440740117a7c6753d5a42ac70d" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt;) takes the left-biased union of &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;. It prefers &lt;code&gt;t1&lt;/code&gt; when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。表达式（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt; ）采用 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; 的左偏联合。当遇到重复的键时，它更喜欢 &lt;code&gt;t1&lt;/code&gt; ，即（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59f960cbf55a76ade215c01edf87bb35054130b8" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The expression (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; t1 t2&lt;/code&gt;) takes the left-biased union of &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;. It prefers &lt;code&gt;t1&lt;/code&gt; when duplicate keys are encountered, i.e. (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; == &lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77655267f45ca20d832ae7b9f3321daa25ed3037" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The intersection of two sets. Elements of the result come from the first set, so for example</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两组的交集。结果的元素来自第一组，例如</target>
        </trans-unit>
        <trans-unit id="08a00bb42c6c90c9e5c8843a1c2aa2a175bffbab" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. The union of two sets, preferring the first set when equal elements are encountered.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。两个集合的并集，当遇到相等的元素时优先选择第一个集合。</target>
        </trans-unit>
        <trans-unit id="7da82b28e4d04a495f59c2a184b60b979330488d" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. This function is defined as (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。此函数定义为（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-lazy#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b9c96074d5cb3551e1982c63637fc9bbce69706e" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. This function is defined as (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt;).</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。此函数定义为（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:isSubmapOf&quot;&gt;isSubmapOf&lt;/a&gt; = &lt;a href=&quot;data-map-strict#v:isSubmapOfBy&quot;&gt;isSubmapOfBy&lt;/a&gt; (==)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bfe7aa725ee4ccc91810462d954d586b33b9cc38" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m + 1)), m &amp;lt;= n. Union with a combining function.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。具有合并功能的联合。</target>
        </trans-unit>
        <trans-unit id="6020fd5e8839684e25f87786a802a9f30819132d" translate="yes" xml:space="preserve">
          <source>O(m*log(n/m+1)), m &amp;lt;= n. See &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（m * log（n / m + 1）），m &amp;lt;= n。看 &lt;code&gt;&lt;a href=&quot;data-set#v:difference&quot;&gt;difference&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a2e164692b82247370b4e8a0e931f51aa45499a" translate="yes" xml:space="preserve">
          <source>O(m*n) (conjectured). Calculate the Cartesian product of two sets.</source>
          <target state="translated">O(m*n)(猜想)。计算两个集合的笛卡尔积。</target>
        </trans-unit>
        <trans-unit id="8b99572d32d0eb232cb14bbbcad9b5a63c3e5980" translate="yes" xml:space="preserve">
          <source>O(m+n) Break a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into pieces separated by the first &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument (which cannot be empty), consuming the delimiter. An empty delimiter is invalid, and will cause an error to be raised.</source>
          <target state="translated">O（m + n）使用第一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 参数（不能为空）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 拆分为多个段，从而消耗定界符。空的定界符无效，并且将引发错误。</target>
        </trans-unit>
        <trans-unit id="80d9b0977be1a47fea5a2986013868ce85329037" translate="yes" xml:space="preserve">
          <source>O(m+n) Break a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into pieces separated by the first &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; argument (which cannot be an empty string), consuming the delimiter. An empty delimiter is invalid, and will cause an error to be raised.</source>
          <target state="translated">O（M + N）的断裂 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 到由第一分隔件 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 参数（它不能是空字符串），消耗的分隔符。空的定界符无效，并且将引发错误。</target>
        </trans-unit>
        <trans-unit id="03a6457cc617cf6a7d267b06d802753713b204fc" translate="yes" xml:space="preserve">
          <source>O(m+n) Replace every non-overlapping occurrence of &lt;code&gt;needle&lt;/code&gt; in &lt;code&gt;haystack&lt;/code&gt; with &lt;code&gt;replacement&lt;/code&gt;.</source>
          <target state="translated">O（M + N）替换的每个非重叠发生 &lt;code&gt;needle&lt;/code&gt; 在 &lt;code&gt;haystack&lt;/code&gt; 与 &lt;code&gt;replacement&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96f5b347406354d571a5843dc30d08e1ec76b516" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回相应对的列表。</target>
        </trans-unit>
        <trans-unit id="9d3db3829ae8efa9d0433ebed5096bd49cc702e0" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="e3438cb73e516de5bbac10931d621d0aaa3e994e" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回相应对的列表。</target>
        </trans-unit>
        <trans-unit id="0089ac18b528ae9ead16dab3a8c9c8897d4bc1f1" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="362f8271e448b6fa92211162ea396be5b6ff39e1" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回相应对的列表。</target>
        </trans-unit>
        <trans-unit id="f37d8b34926fecd6ab8e6a71b5f4b380e2224a03" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="43ae27edf2a6e23ff118106deced552e62ba40c5" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回相应对的列表。</target>
        </trans-unit>
        <trans-unit id="4cae374e2b3b4bf55945376b3e8485eb1f689914" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">O（最小（m，n））。 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="d03ac74df2775f3de40840cff9df60d987e779e3" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). The &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">O（最小（m，n））。该 &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的前缀。</target>
        </trans-unit>
        <trans-unit id="ea1699f32df51d2cef7cf951b9788434480a66a8" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). The &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">O（最小（m，n））。该 &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 功能减退从列表中给定的前缀。如果列表不是以给定的前缀开头，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ;否则，返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 是前缀之后的列表。</target>
        </trans-unit>
        <trans-unit id="62b551a049fc5746c922a24ff35bb2d54771567b" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">O（最小（m，n））。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的前缀。</target>
        </trans-unit>
        <trans-unit id="8e1c861f0aeba2955d4abdb1e20c87c002cdf147" translate="yes" xml:space="preserve">
          <source>O(min(m,n)). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">O（最小（m，n））。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 功能减退从列表中给定的前缀。如果列表不是以给定的前缀开头，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ;否则，返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 是前缀之后的列表。</target>
        </trans-unit>
        <trans-unit id="666947615a3fb4b01fe9cb9f28098ce35062dbc9" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Add a value to the set. There is no left- or right bias for IntSets.</source>
          <target state="translated">O(min(n,W))。向集合中添加一个值。IntSets没有左偏或右偏。</target>
        </trans-unit>
        <trans-unit id="117ec9887d00deff34b39434bdeddb8572b9481a" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned.</source>
          <target state="translated">O(min(n,W))。在特定的键处调整一个值。当该键不是地图的成员时,将返回原始地图。</target>
        </trans-unit>
        <trans-unit id="bb2412bbf0388d193b7f8f6e942d3baf2b765891" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete a key and its value from the map. When the key is not a member of the map, the original map is returned.</source>
          <target state="translated">O(min(n,W))。从地图中删除一个键和它的值。当键不是地图的成员时,返回原地图。</target>
        </trans-unit>
        <trans-unit id="80f021247c32dfb7532faab79b48c35031598555" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete a value in the set. Returns the original set when the value was not present.</source>
          <target state="translated">O(min(n,W))。删除集合中的一个值。当该值不存在时,返回原集合。</target>
        </trans-unit>
        <trans-unit id="27b7e40e3d5ee1a884d9658bdfcee9370d509cbe" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the maximal element.</source>
          <target state="translated">O(min(n,W))。删除并找到最大的元素。</target>
        </trans-unit>
        <trans-unit id="39eabda31f3ee71f3a877ec6e419027b3ef0e507" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the maximal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最大元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f6aaac349145ba247ec568fd2d572699f900442" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the maximal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最大元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05a005cae0707be25fec92a305a7a5b879d7c3f0" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the maximal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最大元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65bad5b61cfb5b1331f071640501863a2dc86dca" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the minimal element.</source>
          <target state="translated">O(min(n,W))。删除并找到最小元素。</target>
        </trans-unit>
        <trans-unit id="9c6bdd35d5e7b928fe7d9b107ba0097360b938d5" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the minimal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最小元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530db2d22f095c6099c8462f012679802de1f9fa" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the minimal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最小元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d0cd90b03d528ba8f41c55613d00a43a816a7d7" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete and find the minimal element. This function throws an error if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。删除并找到最小元素。如果映射为空，则此函数将引发错误。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e92ba6c80512f36cce9b2d45b1d94d08736c542" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete the maximal element. Returns an empty set if the set is empty.</source>
          <target state="translated">O(min(n,W))。删除最大的元素。如果集合为空,则返回一个空集合。</target>
        </trans-unit>
        <trans-unit id="1b5aacaba0d8c73c6b4d63b77d8edcda3a3de286" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete the maximal key. Returns an empty map if the map is empty.</source>
          <target state="translated">O(min(n,W))。删除最大的键。如果地图为空,返回一个空地图。</target>
        </trans-unit>
        <trans-unit id="5cadf90838fff0ddfad92bb47122bfdb3f728f17" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete the minimal element. Returns an empty set if the set is empty.</source>
          <target state="translated">O(min(n,W))。删除最小元素。如果集合为空,则返回一个空集合。</target>
        </trans-unit>
        <trans-unit id="88b0c4955f2491752a07506a0a100406b872172e" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Delete the minimal key. Returns an empty map if the map is empty.</source>
          <target state="translated">O(min(n,W))。删除最小键。如果地图为空,返回一个空地图。</target>
        </trans-unit>
        <trans-unit id="f5433c3ea2cdf692917f1d0f6238f285722c77c8" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Find the value at a key. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="translated">O（最小（n，W））。在键上找到值。当找不到元素时调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd8ee0ddd834d74f0fb9d691ce331218a75be3ac" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Find the value at a key. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f62720517526f8b1a7e7846e6261e5f54ce3de" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Find the value at a key. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="translated">O（最小（n，W））。在键上找到值。当找不到元素时，返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8e7da55955612b916a0d5343c2c2af09fe44537" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Find the value at a key. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; when the element can not be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0899918feebf227c8d98ea614d6cac7629a2c11d" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。在地图中插入新的键/值对。如果键已经存在于映射中，则将关联的值替换为提供的值，即 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d4fadab1c5f17136f5d4b96404d594f422641eb" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720601ecfaca71ed23a517497429611a9cb1a0bc" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。在地图中插入新的键/值对。如果键已经存在于映射中，则将关联的值替换为提供的值，即 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fed807e9594bff342fecde57ec9bf6885e66376" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08c56f00090dcb9ead9336de097f9ef76e6d394" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。在地图中插入新的键/值对。如果键已经存在于映射中，则将关联的值替换为提供的值，即 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7c77b28b3bb473b83b9ebf21927cf02291df13e" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWith&quot;&gt;insertWith&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87dcde6ee0d5ba450e086f4b322e1e67e6edf99d" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; &lt;code&gt;mp&lt;/code&gt; 如果映射中不存在key，则将对（键，值）插入mp。如果键确实存在，该函数将插入 &lt;code&gt;f new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a7291711423ea42b73075f6c11339e3a1678ab6" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f key new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。如果映射中不存在键，则 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; 会将对（键，值）插入 &lt;code&gt;mp&lt;/code&gt; 中。如果键确实存在，则函数将插入 &lt;code&gt;f key new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef3efc58cbe3c17bf8df120c987be760469d0ae0" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; &lt;code&gt;mp&lt;/code&gt; 如果映射中不存在key，则将对（键，值）插入mp。如果键确实存在，该函数将插入 &lt;code&gt;f new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4ee4153cb0857eb89b62d8c874cdfebe773c1d2" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f key new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。如果映射中不存在键，则 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; 会将对（键，值）插入 &lt;code&gt;mp&lt;/code&gt; 中。如果键确实存在，则函数将插入 &lt;code&gt;f key new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3881f3a2cdeb918b5d976bc3db4b60549e3e8761" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWith&quot;&gt;insertWith&lt;/a&gt; f key value mp&lt;/code&gt; &lt;code&gt;mp&lt;/code&gt; 如果映射中不存在key，则将对（键，值）插入mp。如果键确实存在，该函数将插入 &lt;code&gt;f new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="387b72c28953b965af535519012b754270894d15" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Insert with a combining function. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; will insert the pair (key, value) into &lt;code&gt;mp&lt;/code&gt; if key does not exist in the map. If the key does exist, the function will insert &lt;code&gt;f key new_value old_value&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。用组合功能插入。如果映射中不存在键，则 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f key value mp&lt;/code&gt; 会将对（键，值）插入 &lt;code&gt;mp&lt;/code&gt; 中。如果键确实存在，则函数将插入 &lt;code&gt;f key new_value old_value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="299f2cdf7547accd0fda27e3387efdc180bf37b8" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Is the element not in the set?</source>
          <target state="translated">O(min(n,W))。该元素是否不在集合中?</target>
        </trans-unit>
        <trans-unit id="f3b38da89b30bce3c0b997495994179d33e981c2" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Is the key a member of the map?</source>
          <target state="translated">O(min(n,W))。钥匙是地图的成员吗?</target>
        </trans-unit>
        <trans-unit id="ebc38617c47ab2f2b3089d3243f1a9edf77335f8" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Is the key not a member of the map?</source>
          <target state="translated">O(min(n,W))。钥匙不是地图的成员吗?</target>
        </trans-unit>
        <trans-unit id="f07ca4edd352a879234ba71a939671a44d043d25" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Is the value a member of the set?</source>
          <target state="translated">O(min(n,W))。该值是否为集合的成员?</target>
        </trans-unit>
        <trans-unit id="cda441da7f048a8899e36335b8ca68a0957fc6d1" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Lookup and update. The function returns original value, if it is updated. This is different behavior than &lt;code&gt;&lt;a href=&quot;data-map#v:updateLookupWithKey&quot;&gt;updateLookupWithKey&lt;/a&gt;&lt;/code&gt;. Returns the original key value if the map entry is deleted.</source>
          <target state="translated">O（最小（n，W））。查找和更新。该函数将返回原始值（如果已更新）。这与 &lt;code&gt;&lt;a href=&quot;data-map#v:updateLookupWithKey&quot;&gt;updateLookupWithKey&lt;/a&gt;&lt;/code&gt; 不同。如果删除了地图项，则返回原始键值。</target>
        </trans-unit>
        <trans-unit id="4fe409c1e12e147087ee2fdd3aa5983d150901be" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Lookup the value at a key in the map. See also &lt;code&gt;&lt;a href=&quot;data-map#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。在地图中的某个键处查找值。另请参阅 &lt;code&gt;&lt;a href=&quot;data-map#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45efca9f41b3ec01cab49331d88177d669d0ee3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Performs a &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot key was found in the original map.</source>
          <target state="translated">O（最小（n，W））。执行 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始地图中找到了枢轴键。</target>
        </trans-unit>
        <trans-unit id="a04040ca0480cf03f44cf16069113b525c61a1d3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Performs a &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot key was found in the original map.</source>
          <target state="translated">O（最小（n，W））。执行 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始地图中找到了枢轴键。</target>
        </trans-unit>
        <trans-unit id="eb3e2c52a8ec234bbb7bd538392652ab524f8ba9" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Performs a &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot key was found in the original map.</source>
          <target state="translated">O（最小（n，W））。执行 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始地图中找到了枢轴键。</target>
        </trans-unit>
        <trans-unit id="269c98bb57576420c9ab4705c6cef436e62de4c3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Performs a &lt;code&gt;&lt;a href=&quot;data-intset#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot element was found in the original set.</source>
          <target state="translated">O（最小（n，W））。执行 &lt;code&gt;&lt;a href=&quot;data-intset#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始集中找到了枢轴元素。</target>
        </trans-unit>
        <trans-unit id="202753d27cef04c7739f8d43679bd99d77ef596f" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Performs a &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; but also returns whether the pivot element was found in the original set.</source>
          <target state="translated">O（最小（n，W））。执行 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 但还返回是否在原始集中找到了枢轴元素。</target>
        </trans-unit>
        <trans-unit id="03a47e9146b6302cdbcad78b738525e9b6adc91e" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（最小（n，W））。检索映射的最大（键，值）对，以及从该元素中剥离的映射，如果传递了空映射，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eef8c8b028bc4bd66b08966b1da124258cd1e329" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3ba19cf295058368407b8c79daa93462ac9396" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（最小（n，W））。检索地图的最大键，并删除该元素的地图，如果传递了空地图，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa61e4709382597b18923c1316bc05d291539267" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce36e576ddae0bdd376d60f5d02b8ec754afca81" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="translated">O（最小（n，W））。检索集合的最大键，并删除该元素的集合，如果传递了空集合，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19855047e6595e8f6b94a853c82d2d83fc8a9830" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the maximal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c82a2d927b0073446296f901ba4d2a7658a41e2" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（最小（n，W））。检索地图的最小（键，值）对，并去除该元素的地图；如果传递了空地图，则获取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="994fd0c4b500030512e95a5eed56a661413a725a" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal (key,value) pair of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be892bb62cbd2be0aa55e43cd28f42c3c3c71d2" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="translated">O（最小（n，W））。检索地图的最小键，并删除该元素的地图，如果传递了空地图，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373683a1e952881322a8e343c14f9871479dd30c" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal key of the map, and the map stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469b6c23a404d85496accba6c549a66d730a5b0d" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="translated">O（最小（n，W））。检索集合的最小键，并删除该集合的元素，如果传递空集合，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98d9736c39d0e69f1a3b05e41eca0f02dbf67239" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Retrieves the minimal key of the set, and the set stripped of that element, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if passed an empty set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd27e90b1ea01227ea96de2471d31567a1e9fede" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; can be used to insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 可用于在 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中插入，删除或更新值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-lazy#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fd4e867156139312dde0368d0f9f11065e8b6a3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt;) is a pair where the first element is equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;) and the second element equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt;).</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）是一对，其中第一个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; ），第二个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="266b0390d6b00f983edeef60f0f3a0e707cdf1c6" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt;) is a pair &lt;code&gt;(map1,map2)&lt;/code&gt; where all keys in &lt;code&gt;map1&lt;/code&gt; are lower than &lt;code&gt;k&lt;/code&gt; and all keys in &lt;code&gt;map2&lt;/code&gt; larger than &lt;code&gt;k&lt;/code&gt;. Any key equal to &lt;code&gt;k&lt;/code&gt; is found in neither &lt;code&gt;map1&lt;/code&gt; nor &lt;code&gt;map2&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt; ）是一对 &lt;code&gt;(map1,map2)&lt;/code&gt; 其中所有的键 &lt;code&gt;map1&lt;/code&gt; 是低于 &lt;code&gt;k&lt;/code&gt; 和在所有的键 &lt;code&gt;map2&lt;/code&gt; 大于 &lt;code&gt;k&lt;/code&gt; 。在 &lt;code&gt;map1&lt;/code&gt; 和 &lt;code&gt;map2&lt;/code&gt; 中都找不到等于 &lt;code&gt;k&lt;/code&gt; 的任何键。</target>
        </trans-unit>
        <trans-unit id="ed6e8a591b89dda08ed7403a5dbad83f845252b0" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f k x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e06930505b370a059079f65cfe2edeed6b2c9b1b" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fce4f2bef6107331beaee085c5f5d86169d4d3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="190bf4d7c5fbcec8353f776ef9a1b5a6c6061c3b" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cad83c9728da4882ca8ec78fbe92e10e97fe9e" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; can be used to insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 可用于在 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中插入，删除或更新值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-strict#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0652f4655256bab91040a230460e82cf5f363675" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt;) is a pair where the first element is equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;) and the second element equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt;).</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）是一对，其中第一个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; ），第二个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3f646c831ba90d65ef185c306ad9dea4a6e73920" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt;) is a pair &lt;code&gt;(map1,map2)&lt;/code&gt; where all keys in &lt;code&gt;map1&lt;/code&gt; are lower than &lt;code&gt;k&lt;/code&gt; and all keys in &lt;code&gt;map2&lt;/code&gt; larger than &lt;code&gt;k&lt;/code&gt;. Any key equal to &lt;code&gt;k&lt;/code&gt; is found in neither &lt;code&gt;map1&lt;/code&gt; nor &lt;code&gt;map2&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt; ）是一对 &lt;code&gt;(map1,map2)&lt;/code&gt; 其中所有的键 &lt;code&gt;map1&lt;/code&gt; 是低于 &lt;code&gt;k&lt;/code&gt; 和在所有的键 &lt;code&gt;map2&lt;/code&gt; 大于 &lt;code&gt;k&lt;/code&gt; 。在 &lt;code&gt;map1&lt;/code&gt; 和 &lt;code&gt;map2&lt;/code&gt; 中都找不到等于 &lt;code&gt;k&lt;/code&gt; 的任何键。</target>
        </trans-unit>
        <trans-unit id="a51d89473766e051358bac859785370dd5b5c713" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f k x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a7a68b549d492f88bf91b659438a37a3cec7759" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01cae26910e95c1a23515f1272d5399633f88cd" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5f4134065090b867f03f07b95400b700c125576" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d12519aee971d473191d3870175501fa5a2e33" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt;) alters the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt;, or absence thereof. &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; can be used to insert, delete, or update a value in an &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. In short : &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt; f k map&lt;/code&gt; ）改变值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; ，或不存在它们。 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 可用于在 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中插入，删除或更新值。简而言之： &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k (&lt;a href=&quot;data-intmap-strict-internal#v:alter&quot;&gt;alter&lt;/a&gt; f k m) = f (&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k m)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9575c87c5d3abe67695c17223a036913a00176b3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt;) is a pair where the first element is equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt;) and the second element equal to (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt;).</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）是一对，其中第一个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:lookup&quot;&gt;lookup&lt;/a&gt; k map&lt;/code&gt; ），第二个元素等于（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt; f k x map&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dbdb163a374f9647fb79abaff3f3fc565835835c" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt;) is a pair &lt;code&gt;(map1,map2)&lt;/code&gt; where all keys in &lt;code&gt;map1&lt;/code&gt; are lower than &lt;code&gt;k&lt;/code&gt; and all keys in &lt;code&gt;map2&lt;/code&gt; larger than &lt;code&gt;k&lt;/code&gt;. Any key equal to &lt;code&gt;k&lt;/code&gt; is found in neither &lt;code&gt;map1&lt;/code&gt; nor &lt;code&gt;map2&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:split&quot;&gt;split&lt;/a&gt; k map&lt;/code&gt; ）是一对 &lt;code&gt;(map1,map2)&lt;/code&gt; 其中所有的键 &lt;code&gt;map1&lt;/code&gt; 是低于 &lt;code&gt;k&lt;/code&gt; 和在所有的键 &lt;code&gt;map2&lt;/code&gt; 大于 &lt;code&gt;k&lt;/code&gt; 。在 &lt;code&gt;map1&lt;/code&gt; 和 &lt;code&gt;map2&lt;/code&gt; 中都找不到等于 &lt;code&gt;k&lt;/code&gt; 的任何键。</target>
        </trans-unit>
        <trans-unit id="236490cb13c15424f56d1fb207431191cf8c51cd" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f k x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a50b6cc5e04376dd1894ceae33eb37696d0cd49b" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f k x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3f0692e3303c59a1fb1333530540edfd33a8e4" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt; ）更新该值 &lt;code&gt;x&lt;/code&gt; 在 &lt;code&gt;k&lt;/code&gt; （如果它是在地图）。如果（ &lt;code&gt;f x&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则删除该元素。如果它是（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt; ），则密钥 &lt;code&gt;k&lt;/code&gt; 绑定到新值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b4a3486e754983c68e04d197a841e993873f991" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:update&quot;&gt;update&lt;/a&gt; f k map&lt;/code&gt;) updates the value &lt;code&gt;x&lt;/code&gt; at &lt;code&gt;k&lt;/code&gt; (if it is in the map). If (&lt;code&gt;f x&lt;/code&gt;) is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the element is deleted. If it is (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; y&lt;/code&gt;), the key &lt;code&gt;k&lt;/code&gt; is bound to the new value &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a99f7249f68857509851cc7453a1aeb180e694f" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intset#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt;) is a pair &lt;code&gt;(set1,set2)&lt;/code&gt; where &lt;code&gt;set1&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; less than &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt; ）是一个对 &lt;code&gt;(set1,set2)&lt;/code&gt; ，其中 &lt;code&gt;set1&lt;/code&gt; 包含小于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素，而 &lt;code&gt;set2&lt;/code&gt; 包含大于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="7e1b97b65f6d08668e9082cd73b6206c29041153" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression (&lt;code&gt;&lt;a href=&quot;data-intset-internal#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt;) is a pair &lt;code&gt;(set1,set2)&lt;/code&gt; where &lt;code&gt;set1&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; less than &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; comprises the elements of &lt;code&gt;set&lt;/code&gt; greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">O（最小（n，W））。表达式（ &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:split&quot;&gt;split&lt;/a&gt; x set&lt;/code&gt; ）是一个对 &lt;code&gt;(set1,set2)&lt;/code&gt; ，其中 &lt;code&gt;set1&lt;/code&gt; 包含小于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素，而 &lt;code&gt;set2&lt;/code&gt; 包含大于 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="99d7a107634b57c1fd8a22f088cbcca75cf1269a" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression &lt;code&gt;(&lt;a href=&quot;data-intmap-lazy#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; returns the value at key &lt;code&gt;k&lt;/code&gt; or returns &lt;code&gt;def&lt;/code&gt; when the key is not an element of the map.</source>
          <target state="translated">O（最小（n，W））。表达式 &lt;code&gt;(&lt;a href=&quot;data-intmap-lazy#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; 返回键 &lt;code&gt;k&lt;/code&gt; 的值，或者当键不是映射的元素时返回 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95a141af56f4ed1671f18c9eafee704e53edbe14" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression &lt;code&gt;(&lt;a href=&quot;data-intmap-strict#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; returns the value at key &lt;code&gt;k&lt;/code&gt; or returns &lt;code&gt;def&lt;/code&gt; when the key is not an element of the map.</source>
          <target state="translated">O（最小（n，W））。表达式 &lt;code&gt;(&lt;a href=&quot;data-intmap-strict#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; 返回键 &lt;code&gt;k&lt;/code&gt; 的值，或者当键不是映射的元素时返回 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1e01d67b84403261eb50f2450959f4e5fe235c" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The expression &lt;code&gt;(&lt;a href=&quot;data-intmap-strict-internal#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; returns the value at key &lt;code&gt;k&lt;/code&gt; or returns &lt;code&gt;def&lt;/code&gt; when the key is not an element of the map.</source>
          <target state="translated">O（最小（n，W））。表达式 &lt;code&gt;(&lt;a href=&quot;data-intmap-strict-internal#v:findWithDefault&quot;&gt;findWithDefault&lt;/a&gt; def k map)&lt;/code&gt; 返回键 &lt;code&gt;k&lt;/code&gt; 的值，或者当键不是映射的元素时返回 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6dc5fc3cdf1b4d125926300ee26c65bed49f551" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal element of a set.</source>
          <target state="translated">O(min(n,W))。一个集合的最大元素。</target>
        </trans-unit>
        <trans-unit id="d2462cacf54cf720366db6deb2c7efbf159d474f" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最大键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57f11967cfd21e6f14248db000b5cc1d3388caee" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最大键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b268c696265ac398cffef739604d9c4512fbfa9" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最大键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="970f0b32d5c1a9ff03f6b35fc7dff2e2006f4723" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a39d43587a76550904d81dca41aad887315aa04" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b05b5a4ea1f820bf1b225ab155a270619c581b" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:maxViewWithKey&quot;&gt;maxViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d62a30eab747bbb6f31327bf0078374495d1b3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="translated">O（最小（n，W））。地图的最大键。如果映射为空，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd67bf6c006e4618d487ea59ecfdf470bfd21e5f" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The maximal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3666b7eb2b8c6f957e79ee0dec5b883ddd516d" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal element of the set.</source>
          <target state="translated">O(min(n,W))。集的最小元素。</target>
        </trans-unit>
        <trans-unit id="ff6fbb91e22a64aed6579b3e2cbfa4ccefbf8ab1" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最小键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fe4b833f1d465cd1359db33e5075e57beb5249e" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最小键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98b675d209fae92bedecdf6c9acf093358e627b5" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="translated">O（最小（n，W））。地图的最小键。如果地图为空，则调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。如果地图可能为空，请使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81cd051910d850c6553db9d34e0a76d126fc33c7" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ded224ee0ecbc9d49904472f28e00d5cab6993" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe79aa1b2e7a9d8f671e53117f8bf76e5833bb7" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the map is empty. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:minViewWithKey&quot;&gt;minViewWithKey&lt;/a&gt;&lt;/code&gt; if the map may be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3fc2f09c1fb6396ee7140ecf01f62a8158f9f3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="translated">O（最小（n，W））。地图的最小键。如果映射为空，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c646bf841c9a523f6cae3ce8de4ee8935ebb6d3" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). The minimal key of the map. Returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the map is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ddef42511439715463c262dd647510bb923a656" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Update the value at the maximal key.</source>
          <target state="translated">O(min(n,W))。更新最大键处的值。</target>
        </trans-unit>
        <trans-unit id="6a7e4dac78f253520454d472d33abf2be556456f" translate="yes" xml:space="preserve">
          <source>O(min(n,W)). Update the value at the minimal key.</source>
          <target state="translated">O(min(n,W))。更新最小键处的值。</target>
        </trans-unit>
        <trans-unit id="82fc215a1cbeb6b03841f93c9302c2b33f044a65" translate="yes" xml:space="preserve">
          <source>O(n) A strict version of &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。受到融合。</target>
        </trans-unit>
        <trans-unit id="faa70c807d4994d4edd6ea19beb2384f76844519" translate="yes" xml:space="preserve">
          <source>O(n) A strict version of &lt;code&gt;&lt;a href=&quot;data-text#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 的严格版本。受到融合。</target>
        </trans-unit>
        <trans-unit id="abfea64affcfadaef83556d96991e9cf807016a7" translate="yes" xml:space="preserve">
          <source>O(n) A strict version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。受到融合。</target>
        </trans-unit>
        <trans-unit id="1b139d0ad5fe2dfa9969c322ee47ab070db09bf5" translate="yes" xml:space="preserve">
          <source>O(n) A strict version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 的严格版本。受到融合。</target>
        </trans-unit>
        <trans-unit id="524fe3dde7e60946b25f62bff134b68dafeba1ae" translate="yes" xml:space="preserve">
          <source>O(n) A variant of &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no starting value argument, and thus must be applied to a non-empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的变体，没有起始值参数，因此必须应用于非空 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="cd976344c35646f098392678c122c8afc64e3a43" translate="yes" xml:space="preserve">
          <source>O(n) A variant of &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no starting value argument, and thus must be applied to a non-empty &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的一个变体，没有起始值参数，因此必须应用于非空 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="362fc313f1d880386c5f926648e11505bacedb6a" translate="yes" xml:space="preserve">
          <source>O(n) A variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no starting value argument, and thus must be applied to a non-empty &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的变体，没有起始值参数，因此必须应用于非空 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="1851bd3ccc2e835bed20d566d13198f16fade08b" translate="yes" xml:space="preserve">
          <source>O(n) A variant of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no starting value argument, and thus must be applied to a non-empty &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n） &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 的一个变体，没有起始值参数，因此必须应用于非空 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="079000bf2caf640ad5e9a1b67f64227aac23660f" translate="yes" xml:space="preserve">
          <source>O(n) Adds a character to the end of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This copies the entire array in the process, unless fused. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）在 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的末尾添加一个字符。除非已融合，否则此过程将复制整个阵列。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="73370e89c2c667aac93c384c108b533da8d0ebf7" translate="yes" xml:space="preserve">
          <source>O(n) Adds a character to the end of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This copies the entire array in the process, unless fused. Subject to fusion.</source>
          <target state="translated">O（n）在 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的末尾添加一个字符。除非已融合，否则此过程将复制整个阵列。受到融合。</target>
        </trans-unit>
        <trans-unit id="f84771c07cad0b5e330926bd0561fbd5c887a399" translate="yes" xml:space="preserve">
          <source>O(n) Adds a character to the end of a stream.</source>
          <target state="translated">O(n)在流的末端添加一个字符。</target>
        </trans-unit>
        <trans-unit id="c30e95f79a433eca7f5ab822328bc6b7e8a0e603" translate="yes" xml:space="preserve">
          <source>O(n) Adds a character to the front of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function is more costly than its &lt;code&gt;List&lt;/code&gt; counterpart because it requires copying a new array. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）在 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的前面添加一个字符。此功能比其 &lt;code&gt;List&lt;/code&gt; 的代价更高，因为它需要复制一个新数组。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="faca040d960572f5511cea0f149a1cacd567a6db" translate="yes" xml:space="preserve">
          <source>O(n) Adds a character to the front of a Stream Char.</source>
          <target state="translated">O(n)在Stream Char的前面添加一个字符。</target>
        </trans-unit>
        <trans-unit id="69363fe4aa486bf436e18ae61b03abbb4db1c0b4" translate="yes" xml:space="preserve">
          <source>O(n) Append a Char to the end of a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Similar to &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, this function performs a memcpy.</source>
          <target state="translated">O（n）将Char附加到 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的末尾。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 类似，此函数执行memcpy。</target>
        </trans-unit>
        <trans-unit id="932ddd222e0ed6d57b6b5dd205731dc20fa49790" translate="yes" xml:space="preserve">
          <source>O(n) Append a Char to the end of a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Similar to &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, this function performs a memcpy.</source>
          <target state="translated">O（n）将Char附加到 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的末尾。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 类似，此函数执行memcpy。</target>
        </trans-unit>
        <trans-unit id="c57a700fb53855035acd0b43838b114c29ab6f43" translate="yes" xml:space="preserve">
          <source>O(n) Append a byte to the end of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n）将一个字节附加到 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的末尾</target>
        </trans-unit>
        <trans-unit id="899661b7fba388bc64e709a2595e5aa51ef43958" translate="yes" xml:space="preserve">
          <source>O(n) Append two ByteStrings</source>
          <target state="translated">O(n)添加两个ByteStrings。</target>
        </trans-unit>
        <trans-unit id="752cdc56ee778965bdf8a8092ebd0df6e9ab1930" translate="yes" xml:space="preserve">
          <source>O(n) Appends one &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to the other by copying both of them into a new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n）将一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 附加到另一个文本，方法是将两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 都复制到新文本中。受到融合。</target>
        </trans-unit>
        <trans-unit id="2708519f65d9965908b0d2084035e19aaf57ac32" translate="yes" xml:space="preserve">
          <source>O(n) Appends one Stream to the other.</source>
          <target state="translated">O(n)将一个流添加到另一个流中。</target>
        </trans-unit>
        <trans-unit id="0544a0b38abcf9046607e640f3f6b1fd91e2749e" translate="yes" xml:space="preserve">
          <source>O(n) Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">为O（n）施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="e566db6cd81a019f5bcfe3af8a71033a9e7c618e" translate="yes" xml:space="preserve">
          <source>O(n) Applied to a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; determines if all elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfy the predicate.</source>
          <target state="translated">为O（n）施加到谓词和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:all&quot;&gt;all&lt;/a&gt;&lt;/code&gt; 确定是否所有要素 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="11c91b6ace2ab454f8b01b12b57b91b5303310dc" translate="yes" xml:space="preserve">
          <source>O(n) Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">为O（n）施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="94377428d645ea1f0c763816d8c0d2b8b5b1a96c" translate="yes" xml:space="preserve">
          <source>O(n) Applied to a predicate and a ByteString, &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; determines if any element of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; satisfies the predicate.</source>
          <target state="translated">为O（n）施加到谓词和字节字符串， &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:any&quot;&gt;any&lt;/a&gt;&lt;/code&gt; 确定是否任何元件 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 满足谓词。</target>
        </trans-unit>
        <trans-unit id="3792e943133d3c512cc9ee5cf4f8dee11ff59329" translate="yes" xml:space="preserve">
          <source>O(n) Break a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into pieces separated by the byte argument, consuming the delimiter. I.e.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 拆分为多个字节，并用byte参数将其分隔开，从而消耗了定界符。即</target>
        </trans-unit>
        <trans-unit id="4f50034edd7931475872001a2a7a0aaa0bc4003e" translate="yes" xml:space="preserve">
          <source>O(n) Break a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into pieces separated by the byte argument, consuming the delimiter. I.e.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 拆分为多个字节，并用byte参数将其分隔开，从而消耗了定界符。即</target>
        </trans-unit>
        <trans-unit id="1ee13f2afb1dd48c8d79c4c72f120a0554cd381a" translate="yes" xml:space="preserve">
          <source>O(n) Break a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into pieces separated by the byte argument, consuming the delimiter. I.e.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 拆分为多个字节，并用byte参数将其分隔开，从而消耗了定界符。即</target>
        </trans-unit>
        <trans-unit id="6dacd07271c66cc97e87ca0fdd8ffba8c1f57615" translate="yes" xml:space="preserve">
          <source>O(n) Break a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into pieces separated by the byte argument, consuming the delimiter. I.e.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 拆分为多个字节，并用byte参数将其分隔开，从而消耗了定界符。即</target>
        </trans-unit>
        <trans-unit id="8c80e25631c76e9bb2980147330a7b1fa3de97a2" translate="yes" xml:space="preserve">
          <source>O(n) Breaks a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; up into a list of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s at newline &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s. The resulting strings do not contain newlines.</source>
          <target state="translated">O（n）在换行符 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 处将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 分解为 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 列表。结果字符串不包含换行符。</target>
        </trans-unit>
        <trans-unit id="d2b44bdda63fc16d17e62b097fc8149c1274fa2d" translate="yes" xml:space="preserve">
          <source>O(n) Breaks a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; up into a list of words, delimited by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s representing white space.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 分解为单词列表，由表示空白的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="bd353119138214d627302c0ab83407022b4f2c58" translate="yes" xml:space="preserve">
          <source>O(n) Breaks a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; up into a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s at newline &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s. The resulting strings do not contain newlines.</source>
          <target state="translated">O（n）在换行符 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 处将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 分解为 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 列表。结果字符串不包含换行符。</target>
        </trans-unit>
        <trans-unit id="f6add654aa21fa7ad7f2f38568d2d469a1f4770b" translate="yes" xml:space="preserve">
          <source>O(n) Breaks a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; up into a list of words, delimited by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s representing white space.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 分解为单词列表，由表示空白的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 分隔。</target>
        </trans-unit>
        <trans-unit id="4e44d46feb39d03346b6a529a323e54a603aa364" translate="yes" xml:space="preserve">
          <source>O(n) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. This value will have &lt;em&gt;no&lt;/em&gt; finalizer associated to it, and will not be garbage collected by Haskell. The ByteString length is calculated using &lt;em&gt;strlen(3)&lt;/em&gt;, and thus the complexity is a O(n).</source>
          <target state="translated">O（n）从 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 构造一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。该值将&lt;em&gt;没有&lt;/em&gt;关联的终结器，Haskell不会将其垃圾收集。使用&lt;em&gt;strlen（3）&lt;/em&gt;计算ByteString的长度，因此复杂度为O（n）。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff3a1e124ddbcd30fbd068dbffe2dec033297c98" translate="yes" xml:space="preserve">
          <source>O(n) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. This value will have &lt;em&gt;no&lt;/em&gt; finalizer associated to it, and will not be garbage collected by Haskell. The ByteString length is calculated using &lt;em&gt;strlen(3)&lt;/em&gt;, and thus the complexity is a O(n).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f038e72056f4d455a440a2f6060588238f050d1" translate="yes" xml:space="preserve">
          <source>O(n) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a malloced &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. This value will have a &lt;code&gt;free(3)&lt;/code&gt; finalizer associated to it.</source>
          <target state="translated">O（n）从分配的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 构造一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。该值将具有一个与之关联的 &lt;code&gt;free(3)&lt;/code&gt; 终结器。</target>
        </trans-unit>
        <trans-unit id="5a80c8b2a7ee0c60bf3b65958a61659d5c5f1e87" translate="yes" xml:space="preserve">
          <source>O(n) Build a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; from a malloced &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. This value will have a &lt;code&gt;free(3)&lt;/code&gt; finalizer associated to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588b9b5fa7d5118bce671aafc5ddaf9be0603587" translate="yes" xml:space="preserve">
          <source>O(n) Center a string to the given length, using the specified fill character on either side. Performs replacement on invalid scalar values.</source>
          <target state="translated">O(n)使用指定的填充字符将字符串居中到指定长度。对无效的标量值进行替换。</target>
        </trans-unit>
        <trans-unit id="df9f7ff3b55e350682e221ae634b0d48d6e2d749" translate="yes" xml:space="preserve">
          <source>O(n) Compare the count of characters in a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to a number. Subject to fusion.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的字符数与数字进行比较。受到融合。</target>
        </trans-unit>
        <trans-unit id="3cda0f6932b592593deafffcda940e7a9d7a1b50" translate="yes" xml:space="preserve">
          <source>O(n) Compare the count of characters in a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to a number. Subject to fusion.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的字符数与数字进行比较。受到融合。</target>
        </trans-unit>
        <trans-unit id="8e77c4b48250a0c64a9b2ca7b4d17d4922317e57" translate="yes" xml:space="preserve">
          <source>O(n) Compares the count of characters in a string to a number. Subject to fusion.</source>
          <target state="translated">O(n)将一个字符串中的字符数与一个数字进行比较。受融合的影响。</target>
        </trans-unit>
        <trans-unit id="b51b7baba688293ce16eda93568bffa96030a1d1" translate="yes" xml:space="preserve">
          <source>O(n) Concatenate a list of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">O（n）连接 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="d865fabf07004c8189e963123ea699f725640e18" translate="yes" xml:space="preserve">
          <source>O(n) Concatenate a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">O（n）连接 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="d8fea86b4a8a78b9c5f18f7ac7b440e68cabfc2c" translate="yes" xml:space="preserve">
          <source>O(n) Concatenate a list of ByteStrings.</source>
          <target state="translated">O(n)连接一个ByteStrings列表。</target>
        </trans-unit>
        <trans-unit id="41361e1c1af932fdb367f52ef9e402238fb34753" translate="yes" xml:space="preserve">
          <source>O(n) Concatenate a list of streams. Subject to array fusion.</source>
          <target state="translated">O(n)串联一个流的列表。受数组融合的影响。</target>
        </trans-unit>
        <trans-unit id="4d10beba949c3d1fcf75628a1fe52eb8361f6b4f" translate="yes" xml:space="preserve">
          <source>O(n) Convert a 'Stream Char' into a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将&amp;ldquo;流字符&amp;rdquo;转换为 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dddea4515b35cd72a32688d338f11f92f5a27e96" translate="yes" xml:space="preserve">
          <source>O(n) Convert a 'Stream Char' into a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:defaultChunkSize&quot;&gt;defaultChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）使用 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:defaultChunkSize&quot;&gt;defaultChunkSize&lt;/a&gt;&lt;/code&gt; 将&amp;ldquo;流字符&amp;rdquo;转换为 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c4feffce695da7ecb4270820fe9fa4a8ddf4219" translate="yes" xml:space="preserve">
          <source>O(n) Convert a 'Stream Char' into a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, using the given chunk size.</source>
          <target state="translated">O（n）使用给定的块大小将&amp;ldquo;流字符&amp;rdquo;转换为 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3f861cd302cfe47883a8a36c5d7a4f17f239300" translate="yes" xml:space="preserve">
          <source>O(n) Convert a '[Word8]' into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将'[Word8]'转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28ec6bfbea3bf96bb4e05de94f9bfce7e6a57967" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1250ebc782478987fbbb63eab4f85fb17a384acb" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78b503284ec951b09bde8eb8e96b65afc4718d1b" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="6a4329f0180993e73313d695786d19741fe653a8" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa4630618998933ec58505b2f53f280d1bb4905" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0695d1673788e36156e4806e5b4f20a1aa7791" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50a42b1db807b31c89dc47ff255446a98f39244" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using UTF-8 encoding.</source>
          <target state="translated">O（n）使用UTF-8编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9c994148dd5a812cff0396e8d838246731f48ffc" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using big endian UTF-16 encoding.</source>
          <target state="translated">O（n）使用大端UTF-16编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="18b85dc67d7ebe26705964dbc6de39d8405010b7" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using big endian UTF-32 encoding.</source>
          <target state="translated">O（n）使用大端UTF-32编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ecffef13fd9148e59c459f851a79e87ad1209114" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using little endian UTF-16 encoding.</source>
          <target state="translated">O（n）使用小尾数UTF-16编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5e760e8fab287ba8946fcca233427a22640edc3a" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using little endian UTF-32 encoding.</source>
          <target state="translated">O（n）使用小端UTF-32编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e6044fbf74251cc2c457a52a84e1bd03efb7be35" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using big endian UTF-16 encoding.</source>
          <target state="translated">O（n）使用大端UTF-16编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9f4c23d2fe8ef4b6f0aca653c4ab7639543571db" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using big endian UTF-32 encoding.</source>
          <target state="translated">O（n）使用大端UTF-32编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9cbacf603b5e5d2fdcce3a634ef93ce274f8d8d2" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using little endian UTF-16 encoding.</source>
          <target state="translated">O（n）使用小尾数UTF-16编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="29a62b4ccf40bd24ed896366c36d7361e16022ae" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using little endian UTF-32 encoding.</source>
          <target state="translated">O（n）使用小端UTF-32编码将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; Stream Char&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b2f16f8299ef06dabb82519f282ce1372289de8a" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', but iterate backwards.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo;流字符&amp;rdquo;，但向后迭代。</target>
        </trans-unit>
        <trans-unit id="b143d3cf3d816d8c8c93db4f5bf7ea41ef14055b" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a 'Stream Char'.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo;流字符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7aca44283867709f9018dbe9610e0e7fd999f85e" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="0c29be0ed43ad939fb3e296a47f49c43cedb73b1" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cf8793d960b9253dabd7a8b22897bd670c76761" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 转换为惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d657f82e9c6f26ef041158915524963e725aedb3" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a 'Stream Char'.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo;流字符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="53b065bc2d242042f99532fc70338d9e6882bfe8" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。受到融合。</target>
        </trans-unit>
        <trans-unit id="021a5aecc0c509332493c72852e697f40ca40561" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;[&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;[&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1df3c0652b153dfe4a5195f2ccc3b2af3c7a4976" translate="yes" xml:space="preserve">
          <source>O(n) Convert a &lt;code&gt;[&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8d55951dccb9a5743259ddce4e236662cc0630" translate="yes" xml:space="preserve">
          <source>O(n) Convert a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a 'Stream Char', using UTF-8 encoding.</source>
          <target state="translated">O（n）使用UTF-8编码将惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo;流字符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e5f147634e8b77f90355ee835978a5b3bb8dbef" translate="yes" xml:space="preserve">
          <source>O(n) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7073f0f6df8ee44f0d469193aace6f72e11b317b" translate="yes" xml:space="preserve">
          <source>O(n) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; into a strict &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64531d7ba209ea0098fac9a375397be2984683d1" translate="yes" xml:space="preserve">
          <source>O(n) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a list of strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">O（n）将惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为严格 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 列表。</target>
        </trans-unit>
        <trans-unit id="116244e0bc6158ce564e16f533da50e98d0a7f44" translate="yes" xml:space="preserve">
          <source>O(n) Convert a lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 转换为严格 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bbbc4147ca838c00032188a6ccf06e57207b41a" translate="yes" xml:space="preserve">
          <source>O(n) Convert a literal string into a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将文字字符串转换为 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ccbaa11b341fb852679dff2ce88252754ea5f59" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to folded case. Subject to fusion.</source>
          <target state="translated">O(n)将字符串转换为折案。受融合。</target>
        </trans-unit>
        <trans-unit id="b772991b7c4e6cfb13ff25128958c479ac74e993" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to folded case. This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">O(n)将一个字符串转换为折叠大小写。这个函数主要用于执行无大小写(或对大小写不敏感)的字符串比较。</target>
        </trans-unit>
        <trans-unit id="46312e84de82a4f156ac3c44ef66dad6a4f1427f" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to lower case, using simple case conversion. Subject to fusion.</source>
          <target state="translated">O(n)使用简单的大小写转换,将一个字符串转换为小写。受融合。</target>
        </trans-unit>
        <trans-unit id="7c3a348ec061135b0691aa691587c6d2b1821b7f" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to lower case, using simple case conversion. The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">O(n)使用简单的大小写转换,将一个字符串转换为小写。结果字符串可能比输入字符串长。例如,拉丁文大写字母I与上面的点(U+0130)映射到序列拉丁文小写字母i(U+0069),然后再加上上面的组合点(U+0307)。</target>
        </trans-unit>
        <trans-unit id="f81cbf482def73ca1f69ddb22bc272d835e0e613" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to title case, using simple case conversion.</source>
          <target state="translated">O(n)将字符串转换为标题大小写,使用简单的大小写转换。</target>
        </trans-unit>
        <trans-unit id="9af6e9c5a7a15004f91b18ab51c4077bca67d27a" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to title case, using simple case conversion. Subject to fusion.</source>
          <target state="translated">O(n)将一个字符串转换为标题大小写,使用简单的大小写转换。受融合。</target>
        </trans-unit>
        <trans-unit id="3c56a2d831d67cefbee96be022aa22612eccf23b" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to upper case, using simple case conversion. Subject to fusion.</source>
          <target state="translated">O(n)将一个字符串转换为大写,使用简单的大小写转换。受融合。</target>
        </trans-unit>
        <trans-unit id="4320b35e8740ca1413709e97064c6248875b1172" translate="yes" xml:space="preserve">
          <source>O(n) Convert a string to upper case, using simple case conversion. The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">O(n)使用简单的大小写转换,将一个字符串转换为大写。结果字符串可能比输入的字符串长。例如,德语eszett (U+00DF)映射到两个字母序列SS。</target>
        </trans-unit>
        <trans-unit id="4d4f75e9a8520767bf6d31a84eb12816ed4ed2df" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;[&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;[&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98c02abbc8f1614b56f307ed77817fd0c73f0818" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;[&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1852a6d8a9b7eb6d3e890a797734bc8e20d37a8" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50c6fc2c1f1e789aa7922017a54197d55537f07f" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9229cdb5f2ab8990edbd8242d5eadf8a9fefe864" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a '[Word8]'.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为&amp;ldquo; [Word8]&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="73a0722955ce6234fe6238bca6bb72526ed940c3" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb3db6b98a358363668c759fcc16d0a5dd4f17a3" translate="yes" xml:space="preserve">
          <source>O(n) Converts a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4431645dd65ad362332ead4fd078850964fee1" translate="yes" xml:space="preserve">
          <source>O(n) Copy a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to an array. The array is assumed to be big enough to hold the contents of the entire &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 复制到数组。假定数组足够大，可以容纳整个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="49c08abd35188cd479552e06274ab3b606783a11" translate="yes" xml:space="preserve">
          <source>O(n) Create a new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; by copying the contents of the array.</source>
          <target state="translated">O（n）通过复制数组的内容从 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 创建一个新 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c217afeaf00ee9c60d285e731e3da02867342ba2" translate="yes" xml:space="preserve">
          <source>O(n) Decode a C string with explicit length, which is assumed to have been encoded as UTF-8. If decoding fails, a &lt;code&gt;UnicodeException&lt;/code&gt; is thrown.</source>
          <target state="translated">O（n）解码具有明确长度的C字符串，假定该字符串已被编码为UTF-8。如果解码失败，则抛出 &lt;code&gt;UnicodeException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e3328697b5ee0f14c1d440014223940704b364" translate="yes" xml:space="preserve">
          <source>O(n) Find the longest non-empty common prefix of two strings and return it, along with the suffixes of each string at which they no longer match.</source>
          <target state="translated">O(n)找到两个字符串中最长的非空公共前缀,并返回它,同时返回它们不再匹配的每个字符串的后缀。</target>
        </trans-unit>
        <trans-unit id="a659add40cbc2036f206e93f510451803009f875" translate="yes" xml:space="preserve">
          <source>O(n) Group characters in a string according to a predicate.</source>
          <target state="translated">O(n)根据前提条件对字符串中的字符进行分组。</target>
        </trans-unit>
        <trans-unit id="2c3a4c26ce02dc31929573a63ee80cbf9fdf8d6d" translate="yes" xml:space="preserve">
          <source>O(n) Group characters in a string by equality.</source>
          <target state="translated">O(n)将字符串中的字符按等价分组。</target>
        </trans-unit>
        <trans-unit id="a35e2d04eaba5d2c39f00dca373142e68d8e4937" translate="yes" xml:space="preserve">
          <source>O(n) Indicate whether a string contains exactly one element.</source>
          <target state="translated">O(n)表示一个字符串是否只包含一个元素。</target>
        </trans-unit>
        <trans-unit id="e69779d685dab6931eb0355e3d89b3eaab286a99" translate="yes" xml:space="preserve">
          <source>O(n) Joins lines, after appending a terminating newline to each.</source>
          <target state="translated">O(n)在每行上添加一个终止的新行后,将其连接起来。</target>
        </trans-unit>
        <trans-unit id="e44b825be255274a45eb30360f32f9695b729290" translate="yes" xml:space="preserve">
          <source>O(n) Joins words using single space characters.</source>
          <target state="translated">O(n)使用单个空格字符连接单词。</target>
        </trans-unit>
        <trans-unit id="4caa0ddd9c2ce974aebf5f413d5bbcbbb2c46a20" translate="yes" xml:space="preserve">
          <source>O(n) Left-justify a string to the given length, using the specified fill character on the right. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O(n)向左调整字符串的长度,在右边使用指定的填充字符。受制于融合。对无效的标量值进行替换。</target>
        </trans-unit>
        <trans-unit id="002b8ca37853b9d5f45b87e48a5f4148e3852209" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. However, the length of the result is limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; when the maximum length of the result is known.</source>
          <target state="translated">O（n）像 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建一个ByteString。但是，结果的长度受 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的最大长度已知时，此功能比 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 器更有效。</target>
        </trans-unit>
        <trans-unit id="30faaaf56a0ae79ae9892bda7fec05bf8d8792fa" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a ByteString from a seed value. However, the length of the result is limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; when the maximum length of the result is known.</source>
          <target state="translated">O（n）像 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建一个ByteString。但是，结果的长度受 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的最大长度已知时，此功能比 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 器更有效。</target>
        </trans-unit>
        <trans-unit id="23d3bf4235940f470f4847d4c8acf9dd2db958f8" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. However, the length of the result should be limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; when the maximum length of the result is known and correct, otherwise its performance is similar to &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）像 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。但是，结果的长度应受 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的最大长度已知且正确时，此功能比 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 器更有效，否则其性能类似于展开 &lt;code&gt;&lt;a href=&quot;data-text#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="707cceb1604a4178ddd41cfe2b4ef536a770043b" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldrNI&quot;&gt;unfoldrNI&lt;/a&gt;&lt;/code&gt; builds a stream from a seed value. However, the length of the result is limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldrNI&quot;&gt;unfoldrNI&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; when the length of the result is known.</source>
          <target state="translated">O（n）类似于 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldrNI&quot;&gt;unfoldrNI&lt;/a&gt;&lt;/code&gt; 从种子值构建流。但是，结果的长度受 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldrNI&quot;&gt;unfoldrNI&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的长度已知时，此功能比 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 器更有效。</target>
        </trans-unit>
        <trans-unit id="a9d0c0d5f88448bad03631296676996f087a10bd" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from a seed value. However, the length of the result should be limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; when the maximum length of the result is known and correct, otherwise its performance is similar to &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;. Subject to fusion. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）像 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。但是，结果的长度应受 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的最大长度已知且正确时，此功能比 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 器更有效，否则其性能类似于展开 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 。受到融合。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="9f37f4c96c452341a250f5601186d1637dd0883f" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;unfoldr&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a stream from a seed value. However, the length of the result is limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;unfoldr&lt;/code&gt; when the length of the result is known.</source>
          <target state="translated">O（n）像 &lt;code&gt;unfoldr&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建一个流。但是，结果的长度受 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的长度已知时，此功能比 &lt;code&gt;unfoldr&lt;/code&gt; 器更有效。</target>
        </trans-unit>
        <trans-unit id="b396cc0699fd0b96323d0ef46d3f497892fbd600" translate="yes" xml:space="preserve">
          <source>O(n) Like &lt;code&gt;unfoldr&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; builds a stream from a seed value. However, the length of the result is limited by the first argument to &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt;. This function is more efficient than &lt;code&gt;unfoldr&lt;/code&gt; when the length of the result is known.</source>
          <target state="translated">O（n）像 &lt;code&gt;unfoldr&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 从种子值构建一个流。但是，结果的长度受 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy-fusion#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 的第一个参数限制。当结果的长度已知时，此功能比 &lt;code&gt;unfoldr&lt;/code&gt; 器更有效。</target>
        </trans-unit>
        <trans-unit id="fd69d474274557b0d6669c6da4cb8762e9af27fd" translate="yes" xml:space="preserve">
          <source>O(n) Like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt;. Applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from left to right, and returns a final &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）就像 &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 的组合。将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从左到右传递一个累加参数，并返回最终的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="71c1e6eceb02e9ab65c18fbc166cfd1f8aa5a8a1" translate="yes" xml:space="preserve">
          <source>O(n) Like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt;. Applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from left to right, and returns a final &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">O（n）就像 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 的组合。将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从左到右传递一个累加参数，并返回最终的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="0e5eae43715f0958b594d36ece6c395a5f524ef7" translate="yes" xml:space="preserve">
          <source>O(n) Like a combination of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;foldl'&lt;/code&gt;. Applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from left to right, and returns a final &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）就像 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;foldl'&lt;/code&gt; 的组合。将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从左到右传递一个累加参数，并返回最终的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd385cf8434587510e850712a26f3c9cf6ba8434" translate="yes" xml:space="preserve">
          <source>O(n) Make a copy of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with its own storage. This is mainly useful to allow the rest of the data pointed to by the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</source>
          <target state="translated">O（n）使用自己的存储空间复制 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。这主要用于允许对 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 指向的其余数据进行垃圾回收，例如，如果已读取大字符串，而在程序的其余部分中只需要一小部分。</target>
        </trans-unit>
        <trans-unit id="d12e2721f328b4d06ddae962d2ce45fb2c052956" translate="yes" xml:space="preserve">
          <source>O(n) Make a copy of the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with its own storage. This is mainly useful to allow the rest of the data pointed to by the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</source>
          <target state="translated">O（n）使用自己的存储空间复制 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。这主要用于允许对 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 指向的其余数据进行垃圾回收，例如，如果已读取大字符串，而在程序的其余部分中只需要一小部分。</target>
        </trans-unit>
        <trans-unit id="8b30b22f5754643370d85fce8b530d6fa583b842" translate="yes" xml:space="preserve">
          <source>O(n) Make a copy of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with its own storage. This is mainly useful to allow the rest of the data pointed to by the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</source>
          <target state="translated">O（n）使用自己的存储空间复制 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。这主要用于允许对 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 指向的其余数据进行垃圾回收，例如，如果已读取大字符串，而在程序的其余部分中只需要一小部分。</target>
        </trans-unit>
        <trans-unit id="a35b65a085a476052cf10f8c2994c502445fa2d3" translate="yes" xml:space="preserve">
          <source>O(n) Make a copy of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; with its own storage. This is mainly useful to allow the rest of the data pointed to by the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to be garbage collected, for example if a large string has been read in, and only a small part of it is needed in the rest of the program.</source>
          <target state="translated">O（n）使用自己的存储空间复制 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。这主要用于允许对 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 指向的其余数据进行垃圾回收，例如，如果已读取大字符串，而在程序的其余部分中只需要一小部分。</target>
        </trans-unit>
        <trans-unit id="36d157ae699f73d51c7635484fa80b09e436d0de" translate="yes" xml:space="preserve">
          <source>O(n) Make a distinct copy of the given string, sharing no storage with the original string.</source>
          <target state="translated">O(n)为给定的字符串制作一个独立的副本,不与原始字符串共享存储空间。</target>
        </trans-unit>
        <trans-unit id="7b962b34d0705417935a21646daa08ad0bd91512" translate="yes" xml:space="preserve">
          <source>O(n) Make a mutable copy of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">O（n）制作 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的可变副本。</target>
        </trans-unit>
        <trans-unit id="5fd8a16c06dc7fe70e5658dcca9f741b51f4cfb0" translate="yes" xml:space="preserve">
          <source>O(n) Map a function over a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that results in a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and concatenate the results.</source>
          <target state="translated">在O（n）的地图功能 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的结果的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并且将结果连接。</target>
        </trans-unit>
        <trans-unit id="db885632c7e5503f149667ebae46860b1840604d" translate="yes" xml:space="preserve">
          <source>O(n) Map a function over a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that results in a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, and concatenate the results.</source>
          <target state="translated">在O（n）的地图功能 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的结果的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并且将结果连接。</target>
        </trans-unit>
        <trans-unit id="0bbd083a8a22901ff533a63a5373f1541604a5fc" translate="yes" xml:space="preserve">
          <source>O(n) Pack a null-terminated sequence of bytes, pointed to by an Addr# (an arbitrary machine address assumed to point outside the garbage-collected heap) into a &lt;code&gt;ByteString&lt;/code&gt;. A much faster way to create an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; is with an unboxed string literal, than to pack a boxed string. A unboxed string literal is compiled to a static &lt;code&gt;char
 []&lt;/code&gt; by GHC. Establishing the length of the string requires a call to &lt;code&gt;strlen(3)&lt;/code&gt;, so the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; must point to a null-terminated buffer (as is the case with &lt;code&gt;&quot;string&quot;#&lt;/code&gt; literals in GHC). Use &lt;code&gt;unsafePackAddressLen&lt;/code&gt; if you know the length of the string statically.</source>
          <target state="translated">O（n）将以Addr＃（假定为指向垃圾收集堆之外的任意计算机地址）指向的空终止字节序列包装到 &lt;code&gt;ByteString&lt;/code&gt; 中。创建 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 的更快方法是使用未装箱的字符串文字，而不是打包装箱的字符串。GHC 将未装箱的字符串文字编译为静态 &lt;code&gt;char []&lt;/code&gt; 。确定字符串的长度需要调用 &lt;code&gt;strlen(3)&lt;/code&gt; ，因此 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 必须指向以空值结尾的缓冲区（GHC中 &lt;code&gt;&quot;string&quot;#&lt;/code&gt; 文字就是这种情况）。如果您静态知道字符串的长度，请使用 &lt;code&gt;unsafePackAddressLen&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c7141221e6d916fda83d734899a25ffabe1f8cd" translate="yes" xml:space="preserve">
          <source>O(n) Pack a null-terminated sequence of bytes, pointed to by an Addr# (an arbitrary machine address assumed to point outside the garbage-collected heap) into a &lt;code&gt;ByteString&lt;/code&gt;. A much faster way to create an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; is with an unboxed string literal, than to pack a boxed string. A unboxed string literal is compiled to a static &lt;code&gt;char
 []&lt;/code&gt; by GHC. Establishing the length of the string requires a call to &lt;code&gt;strlen(3)&lt;/code&gt;, so the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; must point to a null-terminated buffer (as is the case with &lt;code&gt;&quot;string&quot;#&lt;/code&gt; literals in GHC). Use &lt;code&gt;unsafePackAddressLen&lt;/code&gt; if you know the length of the string statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa2dc9c124826e722b7302103c6162bfec0a518" translate="yes" xml:space="preserve">
          <source>O(n) Perform an action on a temporary, mutable copy of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. The copy is freed as soon as the action returns.</source>
          <target state="translated">O（n）对 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的临时可变副本执行操作。操作返回后，副本将被释放。</target>
        </trans-unit>
        <trans-unit id="5a3520a1f3466d62ccf2e02b909da8fbb502a47e" translate="yes" xml:space="preserve">
          <source>O(n) Perform the equivalent of &lt;code&gt;scanr&lt;/code&gt; over a list, only with the input and result reversed.</source>
          <target state="translated">O（n）仅对输入和结果取反，对列表执行等效的 &lt;code&gt;scanr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4408f818c20c6217b9247c13b45f97f3e4c7c59b" translate="yes" xml:space="preserve">
          <source>O(n) Remove leading and trailing white space from a string. Equivalent to:</source>
          <target state="translated">O(n)删除字符串中的前导空格和尾部空格。相当于</target>
        </trans-unit>
        <trans-unit id="2dfa53b91b5ae5d3dc0a8459960a0235033e611a" translate="yes" xml:space="preserve">
          <source>O(n) Remove leading white space from a string. Equivalent to:</source>
          <target state="translated">O(n)删除字符串中的前导空格。相当于</target>
        </trans-unit>
        <trans-unit id="91993e1f8f45e9899425bf17157340b8550c3f01" translate="yes" xml:space="preserve">
          <source>O(n) Remove trailing white space from a string. Equivalent to:</source>
          <target state="translated">O(n)删除字符串中的尾部空白。相当于</target>
        </trans-unit>
        <trans-unit id="d1b460d5465e414388d690a52f8b275a28b8962e" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有最后段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="0cd8e99b593914a928a8994486df357064e0aa7e" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有最后段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="0447eab4b1342c8def4f1a6d3d62851c5aa4e9a7" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有最后段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="1b47513634de64ed48d49dec6cd06ce2a62a70ba" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有最后段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="0918a76c9101f9ca3e08437edfcfe1ec3db95836" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的所有最后一段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="8512f24bd27c38103de615185f10ac9cab56d0dc" translate="yes" xml:space="preserve">
          <source>O(n) Return all final segments of the given &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, longest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的所有最后一段，最长的一个。</target>
        </trans-unit>
        <trans-unit id="86ce9dd7ee5a050d58f437b270db688fdc14627c" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="827aa4ed2bfda02704f45f7ee63f65cce844ee2b" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="7245de3299eb44868a28ac4c4866342b6ebfba00" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="1b6f1115f89118bdf3d91f6fe488e6b82de8f516" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="01a401462425ebfdfa08580f8adc498a7c81cbd4" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="6493d7f08bee7ce31df304f4187491ac5b073d36" translate="yes" xml:space="preserve">
          <source>O(n) Return all initial segments of the given &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, shortest first.</source>
          <target state="translated">O（n）返回给定 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的所有初始段，最短的开始。</target>
        </trans-unit>
        <trans-unit id="e7559e1e46588798ae20bee6f98692079368f689" translate="yes" xml:space="preserve">
          <source>O(n) Return the prefix of the second string if its suffix matches the entire first string.</source>
          <target state="translated">O(n)如果第二个字符串的后缀与第一个字符串完全匹配,则返回第二个字符串的前缀。</target>
        </trans-unit>
        <trans-unit id="d9484a9c84958f4b1c549035d04de982894d0855" translate="yes" xml:space="preserve">
          <source>O(n) Return the suffix of the second string if its prefix matches the entire first string.</source>
          <target state="translated">O(n)如果第二个字符串的前缀与第一个字符串完全匹配,则返回第二个字符串的后缀。</target>
        </trans-unit>
        <trans-unit id="74822af1f80936cd2b8ea0230424c8c5098730fa" translate="yes" xml:space="preserve">
          <source>O(n) Returns the last character of a 'Stream Char', which must be non-empty.</source>
          <target state="translated">O(n)返回 &quot;Stream Char &quot;的最后一个字符,该字符必须是非空的。</target>
        </trans-unit>
        <trans-unit id="4de1693f32328b8dad075caaa510fd78ef2522ce" translate="yes" xml:space="preserve">
          <source>O(n) Returns the number of characters in a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n）返回 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中的字符数。受到融合。</target>
        </trans-unit>
        <trans-unit id="8c9725c0fd61149f636713101d2cf2ca76ec6a55" translate="yes" xml:space="preserve">
          <source>O(n) Returns the number of characters in a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Subject to fusion.</source>
          <target state="translated">O（n）返回 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中的字符数。受到融合。</target>
        </trans-unit>
        <trans-unit id="65968c83b715cc5cf01fe6e4b6c6001e10b5e3fc" translate="yes" xml:space="preserve">
          <source>O(n) Returns the number of characters in a string.</source>
          <target state="translated">O(n)返回字符串中的字符数。</target>
        </trans-unit>
        <trans-unit id="8ad690f6a723316d96ed98d5e549a0244804f6b5" translate="yes" xml:space="preserve">
          <source>O(n) Returns the number of characters in a text.</source>
          <target state="translated">O(n)返回文本中的字符数。</target>
        </trans-unit>
        <trans-unit id="9c2cec9aaac41f861e71c244bdd00b0c68afb3e3" translate="yes" xml:space="preserve">
          <source>O(n) Reverse the characters of a string.</source>
          <target state="translated">O(n)反转一个字符串的字符。</target>
        </trans-unit>
        <trans-unit id="695207b9ba76a7a265006a065899106dbc0649bc" translate="yes" xml:space="preserve">
          <source>O(n) Right-justify a string to the given length, using the specified fill character on the left. Performs replacement on invalid scalar values.</source>
          <target state="translated">O(n)使用左侧指定的填充字符,将字符串右对齐到指定长度。对无效的标量值进行替换。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
