<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="b77b2a992aaa4c5d69ac5d9df4c739fffdace5ec" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadP</source>
          <target state="translated">Text.ParserCombinators.ReadP</target>
        </trans-unit>
        <trans-unit id="bd62cb34823dd96a921d926b9390b7652930d50d" translate="yes" xml:space="preserve">
          <source>Text.ParserCombinators.ReadPrec</source>
          <target state="translated">Text.ParserCombinators.ReadPrec</target>
        </trans-unit>
        <trans-unit id="841f953fb25d967de66bdc2bfa7b808a4902b9cc" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated</source>
          <target state="translated">Text.PrettyPrint.Annotated</target>
        </trans-unit>
        <trans-unit id="933dae42a8460538e7deec160889c28236a5659e" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJ</target>
        </trans-unit>
        <trans-unit id="6ba7533c729a21d883c35ea710a41810576fe3f9" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.Annotated.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.Annotated.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="75d296916408b85ed138aacae307021f81e9b105" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJ</source>
          <target state="translated">Text.PrettyPrint.HughesPJ</target>
        </trans-unit>
        <trans-unit id="070a1b0e3666fba02bf11cf21864f94454e18fee" translate="yes" xml:space="preserve">
          <source>Text.PrettyPrint.HughesPJClass</source>
          <target state="translated">Text.PrettyPrint.HughesPJClass</target>
        </trans-unit>
        <trans-unit id="852f9faf333892c8bfed010752077687bc710eb3" translate="yes" xml:space="preserve">
          <source>Text.Printf</source>
          <target state="translated">Text.Printf</target>
        </trans-unit>
        <trans-unit id="3e467eeda741670cee0544e799baf3bc68f8f6af" translate="yes" xml:space="preserve">
          <source>Text.Read</source>
          <target state="translated">Text.Read</target>
        </trans-unit>
        <trans-unit id="e7d2b433e6b1a5bfaf0e500258b53ab2699f6b40" translate="yes" xml:space="preserve">
          <source>Text.Read.Lex</source>
          <target state="translated">Text.Read.Lex</target>
        </trans-unit>
        <trans-unit id="82d6f31f8994e83ef79b1676df6acd06d40c0952" translate="yes" xml:space="preserve">
          <source>Text.Show</source>
          <target state="translated">Text.Show</target>
        </trans-unit>
        <trans-unit id="a8c2710c3553b8ef538c168f7f038d784360e352" translate="yes" xml:space="preserve">
          <source>Text.XHtml</source>
          <target state="translated">Text.XHtml</target>
        </trans-unit>
        <trans-unit id="1c794c577eeed3e827f3f4434b0b677541efc237" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Frameset</source>
          <target state="translated">Text.XHtml.Frameset</target>
        </trans-unit>
        <trans-unit id="4e310429294785c3e4ed13f69b32d21e7e3c6e8a" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Strict</source>
          <target state="translated">Text.XHtml.Strict</target>
        </trans-unit>
        <trans-unit id="eaaae80f3e09d76e5b52e5458697c3fd39663493" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Table</source>
          <target state="translated">Text.XHtml.Table</target>
        </trans-unit>
        <trans-unit id="b60bd5c761b5c1a8480926f234df22b56fc27ec9" translate="yes" xml:space="preserve">
          <source>Text.XHtml.Transitional</source>
          <target state="translated">Text.XHtml.Transitional</target>
        </trans-unit>
        <trans-unit id="840c7e38544dbd613fa0b1f9a59f6f627ea3dd88" translate="yes" xml:space="preserve">
          <source>TextDecoder</source>
          <target state="translated">TextDecoder</target>
        </trans-unit>
        <trans-unit id="b1ec439dd8ac6da12ff0821c5bfa7393b4881faa" translate="yes" xml:space="preserve">
          <source>TextEncoder</source>
          <target state="translated">TextEncoder</target>
        </trans-unit>
        <trans-unit id="9195c9a1d76bd3421ac42c82a5d2ce786ab09b23" translate="yes" xml:space="preserve">
          <source>TextEncoding</source>
          <target state="translated">TextEncoding</target>
        </trans-unit>
        <trans-unit id="ef309892f2826f378147927737ca881b40420a37" translate="yes" xml:space="preserve">
          <source>Textual name of this user (pw_name)</source>
          <target state="translated">该用户的文字名称(pw_name)</target>
        </trans-unit>
        <trans-unit id="45b3ae04eef9762e57f97f506e36c837398301fc" translate="yes" xml:space="preserve">
          <source>Textual source positions.</source>
          <target state="translated">文字来源位置。</target>
        </trans-unit>
        <trans-unit id="6a2ec719ddee27b8ee0018e15dcb0d3552659a4c" translate="yes" xml:space="preserve">
          <source>Th32SnapFlags</source>
          <target state="translated">Th32SnapFlags</target>
        </trans-unit>
        <trans-unit id="f1c71aeaa559503cb5c111582956f3709a70b40b" translate="yes" xml:space="preserve">
          <source>Th32SnapHandle</source>
          <target state="translated">Th32SnapHandle</target>
        </trans-unit>
        <trans-unit id="78e1c498231e4965c95cd3fcf27fb9a7f46b40a8" translate="yes" xml:space="preserve">
          <source>That being said, with the appropriate use of wrapper datatypes, the above limitations induce no loss of generality:</source>
          <target state="translated">也就是说,只要适当地使用封装数据类型,上述限制不会引起通用性的损失。</target>
        </trans-unit>
        <trans-unit id="58dcecccbdfb19a6c28d4e72b8694cf3a95079aa" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;lsquo;s fundep!</source>
          <target state="translated">这就产生了 &lt;code&gt;(X [Bool] beta)&lt;/code&gt; 约束，并且使用实例意味着我们需要 &lt;code&gt;(D Bool beta)&lt;/code&gt; ,并通过 &lt;code&gt;D&lt;/code&gt; 的fundep 修复了 &lt;code&gt;beta&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="6a7f123da8ed9434c97040e703694b356a4d2399" translate="yes" xml:space="preserve">
          <source>That gives rise to a &lt;code&gt;(X [Bool] beta)&lt;/code&gt; constraint, and using the instance means we need &lt;code&gt;(D Bool beta)&lt;/code&gt; and that fixes &lt;code&gt;beta&lt;/code&gt; via &lt;code&gt;D&lt;/code&gt;&amp;rsquo;s fundep!</source>
          <target state="translated">这就产生了 &lt;code&gt;(X [Bool] beta)&lt;/code&gt; 约束，使用实例意味着我们需要 &lt;code&gt;(D Bool beta)&lt;/code&gt; ,并通过 &lt;code&gt;D&lt;/code&gt; 的Fundep修复了 &lt;code&gt;beta&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="f2a29bc8dbb5ee0c4a1930b318abbbb60994a117" translate="yes" xml:space="preserve">
          <source>That is because we require an &lt;code&gt;Eq (Option a)&lt;/code&gt; instance from the default type signature for &lt;code&gt;(==#)&lt;/code&gt;, which in turn requires an &lt;code&gt;Eq a&lt;/code&gt; instance, which we don&amp;rsquo;t have in scope. But if you tweak the definition of &lt;code&gt;HigherEq&lt;/code&gt; slightly:</source>
          <target state="translated">这是因为我们需要从 &lt;code&gt;(==#)&lt;/code&gt; 的默认类型签名中获得一个 &lt;code&gt;Eq (Option a)&lt;/code&gt; 实例，而这又需要一个 &lt;code&gt;Eq a&lt;/code&gt; 实例，而我们在范围内没有此实例。但是，如果您稍微调整 &lt;code&gt;HigherEq&lt;/code&gt; 的定义：</target>
        </trans-unit>
        <trans-unit id="462366d2ca673f43337d58fb2f79b52eb40d828a" translate="yes" xml:space="preserve">
          <source>That is the same as the dynamic linking on other platforms, and it is described in &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt;.</source>
          <target state="translated">这与其他平台上的动态链接相同，并且在&lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;使用共享库中&lt;/a&gt;对此进行了描述。</target>
        </trans-unit>
        <trans-unit id="5adb8f6d680643cb988e19cd9ebd95685b0e9084" translate="yes" xml:space="preserve">
          <source>That is, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; pattern-matches its way into tuples and maps over each type that constitutes the tuple. The generated code is reminiscent of what would be generated from &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt;, except with extra machinery to handle the tuple.</source>
          <target state="translated">也就是说，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;将其模式匹配到元组中，并映射到构成该元组的每种类型。生成的代码让人想起将从 &lt;code&gt;data Triple a = Triple a Int [a]&lt;/code&gt; 生成的代码，除非使用额外的机制来处理元组。</target>
        </trans-unit>
        <trans-unit id="4a82aebf2ff4e63f82086bf2da9eae4d7a61ab25" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 生成的字符串，并提供以 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 开头的值。</target>
        </trans-unit>
        <trans-unit id="9e481507876f41c367fe06e578b12b78a4e7b1ac" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 生成的字符串，并提供以 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 开头的值。</target>
        </trans-unit>
        <trans-unit id="49ebb42c3d6e117d12265da60c750a18218cde33" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 生成的字符串，并提供以 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 开头的值。</target>
        </trans-unit>
        <trans-unit id="924d09ba70f052db4b220a5f8dac59b3109fa413" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 生成的字符串，并提供以 &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 开头的值。</target>
        </trans-unit>
        <trans-unit id="5981428896475a8992aaf356fb600c2886c3b975" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; parses the string produced by &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, and delivers the value that &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; started with.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 生成的字符串，并提供以 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 开头的值。</target>
        </trans-unit>
        <trans-unit id="a0d56a2fcb64d6ff47305c969e3cc186106c4d12" translate="yes" xml:space="preserve">
          <source>That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.</source>
          <target state="translated">也就是说,quoter是一个由四个解析器组成的元组,每一个解析器代表一个准引号可能出现的上下文。</target>
        </trans-unit>
        <trans-unit id="1ac21267c135501bf8d1d0d91f2b069a3782591d" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="translated">也就是说，将使用所有方法的空实现创建一个 &lt;code&gt;SPretty Foo&lt;/code&gt; 实例。由于在此示例中使用的是&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;，因此会自动填充 &lt;code&gt;sPpr&lt;/code&gt; 的默认实现。</target>
        </trans-unit>
        <trans-unit id="663aa2118010ecc8a1e027d6bf82ba72221ad60a" translate="yes" xml:space="preserve">
          <source>That is, an &lt;code&gt;SPretty Foo&lt;/code&gt; instance will be created with empty implementations for all methods. Since we are using &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt; in this example, a default implementation of &lt;code&gt;sPpr&lt;/code&gt; is filled in automatically.</source>
          <target state="translated">也就是说，将使用所有方法的空实现创建一个 &lt;code&gt;SPretty Foo&lt;/code&gt; 实例。由于在此示例中使用的是&lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;，因此会自动填充 &lt;code&gt;sPpr&lt;/code&gt; 的默认实现。</target>
        </trans-unit>
        <trans-unit id="8b860dffaafb771638ee538e2b0ac1693cebe622" translate="yes" xml:space="preserve">
          <source>That is, since the type variable &lt;code&gt;a&lt;/code&gt; isn&amp;rsquo;t in scope, it&amp;rsquo;s implicitly universally quantified.</source>
          <target state="translated">也就是说，由于类型变量 &lt;code&gt;a&lt;/code&gt; 不在范围内，因此它被隐式地普遍量化。</target>
        </trans-unit>
        <trans-unit id="d7a4e9e2c0f64dd1b628ca2224d1a3e388241d4f" translate="yes" xml:space="preserve">
          <source>That is, the &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; methods should be the inverse of each other. A range of instances are provided for basic Haskell types.</source>
          <target state="translated">也就是说， &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 方法应该彼此相反。为基本的Haskell类型提供了一系列实例。</target>
        </trans-unit>
        <trans-unit id="2de858dbd3f42f7a78dc46a1d661e4c45116e634" translate="yes" xml:space="preserve">
          <source>That is, the operator must be a function of two arguments. GHC allows it to take only one argument, and that in turn allows you to write the function postfix.</source>
          <target state="translated">也就是说,运算符必须是两个参数的函数。GHC允许它只接受一个参数,这反过来又允许你写函数postfix。</target>
        </trans-unit>
        <trans-unit id="de2666094f8dd3b89fcecfae7a344b137b1c390e" translate="yes" xml:space="preserve">
          <source>That is, the scoping is the same as it would be if the curried arguments were collected into a tuple.</source>
          <target state="translated">也就是说,范围化与将策动机参数收集到一个元组中是一样的。</target>
        </trans-unit>
        <trans-unit id="a08280c0c335de4d817b47c060a3f4af660b030a" translate="yes" xml:space="preserve">
          <source>That is, to match a variable ⟨v⟩ against a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt;, evaluate &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ ⟨v⟩ &lt;code&gt;)&lt;/code&gt; and match the result against ⟨pat⟩.</source>
          <target state="translated">也就是说，要使变量⟨v⟩与模式 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 相匹配，求值 &lt;code&gt;(&lt;/code&gt; ⟨exp⟩⟨v⟩ &lt;code&gt;)&lt;/code&gt; 并将结果与​​⟨pat⟩相匹配。</target>
        </trans-unit>
        <trans-unit id="f81ae30760fa45f0027ed10944dbae9bf4a7947d" translate="yes" xml:space="preserve">
          <source>That is, we add a new form of pattern, written ⟨expression⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pattern⟩ that means &amp;ldquo;apply the expression to whatever we&amp;rsquo;re trying to match against, and then match the result of that application against the pattern&amp;rdquo;. The expression can be any Haskell expression of function type, and view patterns can be used wherever patterns are used.</source>
          <target state="translated">也就是说，我们添加了一种新的模式形式，写为⟨expression⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pattern⟩，这意味着&amp;ldquo;将表达式应用于我们要匹配的对象，然后将该应用程序的结果与该模式匹配&amp;rdquo;。该表达式可以是函数类型的任何Haskell表达式，并且无论使用哪种模式，都可以使用视图模式。</target>
        </trans-unit>
        <trans-unit id="e4472bb74389d304d179494e5f818bbd3e2091fe" translate="yes" xml:space="preserve">
          <source>That is, we represent every functional dependency (FD) &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; by an FD type family &lt;code&gt;F a1 .. an&lt;/code&gt; and a superclass context equality &lt;code&gt;F a1 .. an ~ b&lt;/code&gt;, essentially giving a name to the functional dependency. In class instances, we define the type instances of FD families in accordance with the class head. Method signatures are not affected by that process.</source>
          <target state="translated">也就是说，我们用FD类型族 &lt;code&gt;F a1 .. an&lt;/code&gt; 和超类上下文相等 &lt;code&gt;F a1 .. an ~ b&lt;/code&gt; an〜b 表示每个功能依赖项（FD） &lt;code&gt;a1 .. an -&amp;gt; b&lt;/code&gt; b，本质上为功能依赖项命名。在类实例中，我们根据类头定义FD系列的类型实例。方法签名不受该过程的影响。</target>
        </trans-unit>
        <trans-unit id="087a1186066043015d53285a25aa834f074c4bb9" translate="yes" xml:space="preserve">
          <source>That last one deserves a special mention, however, since &lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; is a straightforward instantiation of &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. You can still write such a default type signature, but you now must use type equalities to do so:</source>
          <target state="translated">然而，最后一个值得特别提及，因为 &lt;code&gt;a -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; 是 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 的直接实例化。a-&amp;gt; b-&amp;gt; b。您仍然可以编写这样的默认类型签名，但是现在必须使用类型相等性来这样做：</target>
        </trans-unit>
        <trans-unit id="7aa747ff9513051d2f3e0f63c5ab4677db5c86d5" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="translated">剩下的让表达式，在Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;3.12节中&lt;/a&gt;给出了翻译。用以下内容替换&amp;ldquo;翻译&amp;rdquo;。 &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt; 给出let {bind1 ... bindn}：</target>
        </trans-unit>
        <trans-unit id="cd50fc2b9c34278d98468c36da785c66b0803c5a" translate="yes" xml:space="preserve">
          <source>That leaves let expressions, whose translation is given in &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;Section 3.12&lt;/a&gt; of the Haskell Report. Replace the &amp;ldquo;Translation&amp;rdquo; there with the following one. Given &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt;:</source>
          <target state="translated">这样就剩下让表达式了，其翻译在《 Haskell报告》的&lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.12&quot;&gt;第3.12节中&lt;/a&gt;给出。用以下内容替换&amp;ldquo;翻译&amp;rdquo;。 &lt;code&gt;let { bind1 ... bindn } in body&lt;/code&gt; 给出let {bind1 ... bindn}：</target>
        </trans-unit>
        <trans-unit id="9239200a2fcf1e520b700775bc66f764a197c669" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">这其中放缓实例的问题挑来调用网站 &lt;code&gt;f&lt;/code&gt; 到那时更多人知道的类型 &lt;code&gt;b&lt;/code&gt; 。如果使用&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展，则可以自己编写此类型签名。</target>
        </trans-unit>
        <trans-unit id="d389a135a3109bdad0320beb8a57c6c2152f2179" translate="yes" xml:space="preserve">
          <source>That postpones the question of which instance to pick to the call site for &lt;code&gt;f&lt;/code&gt; by which time more is known about the type &lt;code&gt;b&lt;/code&gt;. You can write this type signature yourself if you use the &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">这其中放缓实例的问题挑来调用网站 &lt;code&gt;f&lt;/code&gt; 到那时更多人知道的类型 &lt;code&gt;b&lt;/code&gt; 。如果使用&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展，则可以自己编写此类型签名。</target>
        </trans-unit>
        <trans-unit id="0af663474763fbec92b5233bfe0db021c376fce2" translate="yes" xml:space="preserve">
          <source>That would make no sense if the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; involves the bound variable &lt;code&gt;x&lt;/code&gt;. More generally, the expression to the left of &lt;code&gt;-&amp;lt;&lt;/code&gt; may not involve any local variable, i.e. a variable bound in the current arrow abstraction. For such a situation there is a variant &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt;, as in</source>
          <target state="translated">如果 &lt;code&gt;-&amp;lt;&lt;/code&gt; 左侧的表达式包含绑定变量 &lt;code&gt;x&lt;/code&gt; ,那将毫无意义。更一般而言， &lt;code&gt;-&amp;lt;&lt;/code&gt; 左侧的表达式可能不涉及任何局部变量，即当前箭头抽象中绑定的变量。对于这种情况，有一个变体 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; ，如</target>
        </trans-unit>
        <trans-unit id="8395997f12760883e7bd00deba567522fa0be628" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all a little confusing, so here&amp;rsquo;s a few examples. To start with, here&amp;rsquo;s a new GHCi command which doesn&amp;rsquo;t take any arguments or produce any results, it just outputs the current date and time:</source>
          <target state="translated">这有点令人困惑，所以这里有一些例子。首先，这是一个新的GHCi命令，该命令不带任何参数也不产生任何结果，它仅输出当前日期和时间：</target>
        </trans-unit>
        <trans-unit id="3a5d327acf1cda84e99ba8c8418f8a6e3f1a6041" translate="yes" xml:space="preserve">
          <source>The &quot;%v&quot; specifier is provided for all built-in types, and should be provided for user-defined type formatters as well. It picks a &quot;best&quot; representation for the given type. For the built-in types the &quot;%v&quot; specifier is converted as follows:</source>
          <target state="translated">%v &quot;指定符是为所有内置类型提供的,也应该为用户定义的类型格式化提供。它为给定的类型选择了一个 &quot;最佳 &quot;表示。对于内置类型,&quot;%v &quot;指定符的转换如下。</target>
        </trans-unit>
        <trans-unit id="307d8dbf7393ba19bad8b70f752ec95aa046ce44" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;By&lt;/code&gt;&quot; operations</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;By&lt;/code&gt; &amp;rdquo;操作</target>
        </trans-unit>
        <trans-unit id="599928469bbf0c1871f851f1ade723c44533fb25" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;generic&lt;/code&gt;&quot; operations</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;generic&lt;/code&gt; &amp;rdquo;操作</target>
        </trans-unit>
        <trans-unit id="d6bed068edef8687960252343aec2dce4a6f9960" translate="yes" xml:space="preserve">
          <source>The &quot;alternate form&quot; for unsigned radix conversions is as in C &lt;code&gt;printf(3)&lt;/code&gt;:</source>
          <target state="translated">无符号基数转换的&amp;ldquo;替代形式&amp;rdquo;与C &lt;code&gt;printf(3)&lt;/code&gt; 相同：</target>
        </trans-unit>
        <trans-unit id="594cda52526f7a4ced49e3f563eb6b3d2f24eeb4" translate="yes" xml:space="preserve">
          <source>The &quot;format parser&quot; walks over argument-type-specific modifier characters to find the primary format character. This is the type of its result.</source>
          <target state="translated">格式解析器 &quot;走过特定于参数类型的修饰字符,找到主要的格式字符。这就是其结果的类型。</target>
        </trans-unit>
        <trans-unit id="7723ee8b77a369d6247096077763bfcd23d475ce" translate="yes" xml:space="preserve">
          <source>The &quot;live&quot; elements of the buffer are those between the &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; offsets. In an empty buffer, &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt;, but they might not be zero: for example, the buffer might correspond to a memory-mapped file and in which case &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; will point to the next location to be written, which is not necessarily the beginning of the file.</source>
          <target state="translated">缓冲区的&amp;ldquo;活动&amp;rdquo;元素是 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; 偏移量之间的元素。在空缓冲区中， &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufR&quot;&gt;bufR&lt;/a&gt;&lt;/code&gt; ，但它们可能不为零：例如，缓冲区可能对应于一个内存映射文件，在这种情况下， &lt;code&gt;&lt;a href=&quot;ghc-io-buffer#v:bufL&quot;&gt;bufL&lt;/a&gt;&lt;/code&gt; 将指向下一个要写入的位置，这不一定文件的开头。</target>
        </trans-unit>
        <trans-unit id="2a8382d16990b13cd15a39a55ae784945d07894a" translate="yes" xml:space="preserve">
          <source>The &quot;normal&quot; (Level 0) of detail.</source>
          <target state="translated">细节的 &quot;正常&quot;(0级)。</target>
        </trans-unit>
        <trans-unit id="f72b6aeac8d85eeec70693b005224f9243157a76" translate="yes" xml:space="preserve">
          <source>The &quot;reflection trick&quot;, which takes advantanage of the fact that in &lt;code&gt;class C a where { op :: ty }&lt;/code&gt;, we can safely coerce between &lt;code&gt;C a&lt;/code&gt; and &lt;code&gt;ty&lt;/code&gt; (which have different kinds!) because it's really just a newtype. Note: there is &lt;em&gt;no guarantee, at all&lt;/em&gt; that this behavior will be supported into perpetuity.</source>
          <target state="translated">&amp;ldquo;反射技巧&amp;rdquo;的优点是，在 &lt;code&gt;class C a where { op :: ty }&lt;/code&gt; ，我们可以安全地在 &lt;code&gt;C a&lt;/code&gt; 和 &lt;code&gt;ty&lt;/code&gt; （具有不同种类！）之间进行强制转换，因为它实际上只是一个新类型。注意：&lt;em&gt;不能完全保证&lt;/em&gt;将永久支持这种行为。</target>
        </trans-unit>
        <trans-unit id="c953365586bc5a5e627fb11bde8ec6bbd7800149" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; exposed via the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; etc. instances.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 等实例公开的&amp;ldquo;值&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="667c18fb4c63293a30cf0ae6252784353ac2d4c3" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;&lt;code&gt;forall a&lt;/code&gt;&amp;rdquo; brings &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; into scope in the definition of &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;forall a&lt;/code&gt; &amp;rdquo;将&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;带入&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo; 定义的范围内。</target>
        </trans-unit>
        <trans-unit id="c6c6c6b0c9636ffbfcb145dd52b6cf329767257a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes allocated in the heap&amp;rdquo; is the total bytes allocated by the program over the whole run.</source>
          <target state="translated">&amp;ldquo;堆中分配的字节&amp;rdquo;是程序在整个运行过程中分配的总字节。</target>
        </trans-unit>
        <trans-unit id="584d620fa2734b6b5eaa0370f4dc4f644b3e240e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bytes maximum slop&amp;rdquo; tells you the most space that is ever wasted due to the way GHC allocates memory in blocks. Slop is memory at the end of a block that was wasted. There&amp;rsquo;s no way to control this; we just like to see how much memory is being lost this way.</source>
          <target state="translated">&amp;ldquo;最大字节数&amp;rdquo;告诉您由于GHC在块中分配内存的方式而浪费的最多空间。Slop是浪费的块末的内存。没有办法控制它。我们只是想看看这种方式丢失了多少内存。</target>
        </trans-unit>
        <trans-unit id="45090aca257e8cf2e737992e0dab8be6af802dda" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;general principle&amp;rdquo; described here is meant to make all this more predictable for users. It would not be hard to extend GHC to relax this principle. If you should want a change here, consider writing a &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;proposal&lt;/a&gt; to do so.</source>
          <target state="translated">此处描述的&amp;ldquo;一般原则&amp;rdquo;旨在使用户更容易预测所有这些。扩大GHC以放松这一原则并不困难。如果您想在此处进行更改，请考虑编写&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/&quot;&gt;建议&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fef8e475f005ce6d6f926436263775847cc3803" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;i&amp;rdquo; stands for &amp;ldquo;Interactive&amp;rdquo;</source>
          <target state="translated">&amp;ldquo; i&amp;rdquo;代表&amp;ldquo;互动&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fc84efa3e37fb0d48e7458b75c4700965bef870a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;total memory in use&amp;rdquo; tells you the peak memory the RTS has allocated from the OS.</source>
          <target state="translated">&amp;ldquo;正在使用的总内存&amp;rdquo;告诉您RTS已从OS分配的峰值内存。</target>
        </trans-unit>
        <trans-unit id="c4ca1b8698b4c3c42a66add6d5685bab0dd89277" translate="yes" xml:space="preserve">
          <source>The (binary) &lt;code&gt;Tree&lt;/code&gt; instance example makes use of both, after defining the &lt;code&gt;Empty&lt;/code&gt; base case and the singleton &lt;code&gt;Leaf&lt;/code&gt; node case, non-empty internal nodes introduce both a prepended child node on the left and an appended child node on the right:</source>
          <target state="translated">（二进制） &lt;code&gt;Tree&lt;/code&gt; 实例示例在定义了 &lt;code&gt;Empty&lt;/code&gt; 基本案例和Singleton &lt;code&gt;Leaf&lt;/code&gt; 节点案例后都使用了这两个实例，非空内部节点在左侧引入了一个前置子节点，在右侧引入了一个附加子节点：</target>
        </trans-unit>
        <trans-unit id="eb3433e82abbee6557ae4932640c2d8da6b781db" translate="yes" xml:space="preserve">
          <source>The (mono)type: &lt;code&gt;tau&lt;/code&gt;</source>
          <target state="translated">（单声道）类型： &lt;code&gt;tau&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60b26e67d917cc3a857c71a7f8b8990a2841e52f" translate="yes" xml:space="preserve">
          <source>The 0 pointer. Used to indicate the empty Bytestring.</source>
          <target state="translated">0指针。用于表示空的Bytestring。</target>
        </trans-unit>
        <trans-unit id="b0f2110e66ee660be4c8c2f43b8e22fc7b2ac364" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension allows these constructs to be directly used as a function argument. For example:</source>
          <target state="translated">所述&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; &lt;/a&gt;扩展允许这些构建体直接使用作为函数参数。例如：</target>
        </trans-unit>
        <trans-unit id="64bdb3d073f079d531b8a96572945cc8af7548ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;</source>
          <target state="translated">该&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; &lt;/a&gt;扩展移动下这些生产规则 &lt;code&gt;aexp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c6312d568cf2735ca75edec69b8ff484ecdbef9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-BlockArguments&quot;&gt;&lt;code&gt;BlockArguments&lt;/code&gt;&lt;/a&gt; extension moves these production rules under &lt;code&gt;aexp&lt;/code&gt;:</source>
          <target state="translated">该&lt;a href=&quot;#extension-BlockArguments&quot;&gt; &lt;code&gt;BlockArguments&lt;/code&gt; &lt;/a&gt;扩展下运行这些生产规则 &lt;code&gt;aexp&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c11e29052e1ea592c72c0d937dab2a12cd84eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;exts/pragmas#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="translated">该&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt;语言扩展，也可以使用启用&lt;a href=&quot;exts/pragmas#language-pragma&quot;&gt;语言&lt;/a&gt;编译; 例如：</target>
        </trans-unit>
        <trans-unit id="35c65f0dc74f4931d91c01fa9c6d3700981ddac7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension can also be enabled using the &lt;a href=&quot;glasgow_exts#language-pragma&quot;&gt;LANGUAGE&lt;/a&gt; pragma; For example:</source>
          <target state="translated">该&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt;语言扩展，也可以使用启用&lt;a href=&quot;glasgow_exts#language-pragma&quot;&gt;语言&lt;/a&gt;编译; 例如：</target>
        </trans-unit>
        <trans-unit id="cb9ce911311ab5062d718c76033a5381bcc759c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-CPP&quot;&gt;&lt;code&gt;CPP&lt;/code&gt;&lt;/a&gt; language extension enables the C pre-processor. This can be turned into a command-line flag by prefixing it with &lt;code&gt;-X&lt;/code&gt;; For example:</source>
          <target state="translated">该&lt;a href=&quot;#extension-CPP&quot;&gt; &lt;code&gt;CPP&lt;/code&gt; &lt;/a&gt;语言扩展使下预处理器。通过在其前面加上 &lt;code&gt;-X&lt;/code&gt; 可以将其转换为命令行标志。例如：</target>
        </trans-unit>
        <trans-unit id="ae4cf567699873d6594767b8148b3283fe3e91e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt; extension enables case expressions, or lambda-case expressions, that have no alternatives, thus:</source>
          <target state="translated">该&lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; &lt;/a&gt;扩展允许的情况下表达，或&amp;lambda;-case语句，有没有替代品，这样的：</target>
        </trans-unit>
        <trans-unit id="abbd0ecca5ae43844dd2d11341709a7cbf2688b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="translated">所述&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt;标志仅需要使这四个&amp;ldquo;标准&amp;rdquo;型（其在Haskell的报告提及）类导出。 &lt;code&gt;deriving&lt;/code&gt; 机制的其他扩展（将在下面更详细地说明）不需要将&lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt; &lt;code&gt;EmptyDataDeriving&lt;/code&gt; &lt;/a&gt;与空数据类型结合使用。这些包括：</target>
        </trans-unit>
        <trans-unit id="012817880879ac3870d5610c6cda1f372d2afa1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; extension allows you to prefix the name of a type constructor in an import or export list with &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to disambiguate this case, thus:</source>
          <target state="translated">该&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;扩展允许前缀导入或导出列表与&amp;ldquo;一类的构造函数的名称 &lt;code&gt;type&lt;/code&gt; &amp;rdquo;的歧义这种情况下，这样的：</target>
        </trans-unit>
        <trans-unit id="5ba167f467ba97a573f10efce8b6b966cd314396" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 &amp;hellip; typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">所述&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展抬起的Haskell 98限制，在一个类型的签名的类型级约束必须具有形式&lt;em&gt;（类型变量）&lt;/em&gt;或&lt;em&gt;（类（类型变量TYPE1类型2 ...力typen）） &lt;/em&gt;。使用&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; ,&lt;/a&gt;这些类型签名完全可以</target>
        </trans-unit>
        <trans-unit id="1e42ac5c594dfd901f58792044e9a9041c4003be" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">所述&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展抬起的Haskell 98限制，在一个类型的签名的类型级约束必须具有形式&lt;em&gt;（类型变量）&lt;/em&gt;或&lt;em&gt;（类（类型变量TYPE1类型2 ...力typen）） &lt;/em&gt;。使用&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; ,&lt;/a&gt;这些类型签名完全可以</target>
        </trans-unit>
        <trans-unit id="7a3b07e5c3b3f792ae9a2205da0ebe6f644dadb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="translated">所述&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展放松这一规则，以及放宽类型签名对应的规则（见&lt;a href=&quot;#flexible-contexts&quot;&gt;类型签名的上下文&lt;/a&gt;）。具体来说，&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;允许在实例声明的上下文中（良好）类形式为 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 类约束。</target>
        </trans-unit>
        <trans-unit id="0562613b8f75a0cd91d39da3210ac809ea1b3a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension allows the head of the instance declaration to mention arbitrary nested types. For example, this becomes a legal instance declaration</source>
          <target state="translated">该&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt;扩展允许的实例声明的头提任意嵌套类型。例如，这成为一个法律实例声明</target>
        </trans-unit>
        <trans-unit id="661ec8113ef99ccdd08a9cd1e3cdeaf21af63fa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt; extension implies &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt;扩展意味着&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdcc91b25b9ed4cc5c0260c1f012c1a5f82d2927" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-LambdaCase&quot;&gt;&lt;code&gt;LambdaCase&lt;/code&gt;&lt;/a&gt; extension enables expressions of the form</source>
          <target state="translated">所述&lt;a href=&quot;#extension-LambdaCase&quot;&gt; &lt;code&gt;LambdaCase&lt;/code&gt; &lt;/a&gt;扩展使形式的表达式</target>
        </trans-unit>
        <trans-unit id="ae186343574b4460d96f7f83aeb4d511026cbbfd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="translated">该&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;也使文本（见的一些新形式的&lt;a href=&quot;#glasgow-unboxed&quot;&gt;无盒装类型&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="e3929c268c7ca8099bc7fccc912027c58685a7e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; also enables some new forms of literals (see &lt;a href=&quot;primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt;):</source>
          <target state="translated">该&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;也使文本（见的一些新形式的&lt;a href=&quot;primitives#glasgow-unboxed&quot;&gt;无盒装类型&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="f156d0b8de4e1a07b993f716b37564cac76a1370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-PostfixOperators&quot;&gt;&lt;code&gt;PostfixOperators&lt;/code&gt;&lt;/a&gt; extension enables a small extension to the syntax of left operator sections, which allows you to define postfix operators. The extension is this: the left section</source>
          <target state="translated">该&lt;a href=&quot;#extension-PostfixOperators&quot;&gt; &lt;code&gt;PostfixOperators&lt;/code&gt; &lt;/a&gt;扩展使一个小扩展到左操作部分的语法，它允许你定义后缀运算符。扩展名是这样的：左侧部分</target>
        </trans-unit>
        <trans-unit id="a89c98a9a3a672e6e0625684027419f38aef7f06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; option is also required for any type with a &lt;code&gt;forall&lt;/code&gt; or context to the right of an arrow (e.g. &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt;, or &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt;). Such types are technically rank 1, but are clearly not Haskell-98, and an extra extension did not seem worth the bother.</source>
          <target state="translated">所述&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;也需要任何类型的与选项 &lt;code&gt;forall&lt;/code&gt; 或上下文中的箭头的右侧（例如 &lt;code&gt;f :: Int -&amp;gt; forall a. a-&amp;gt;a&lt;/code&gt; ，或 &lt;code&gt;g :: Int -&amp;gt; Ord a =&amp;gt; a -&amp;gt; a&lt;/code&gt; ）。从技术上讲，此类类型为1级，但显然不是Haskell-98，并且额外的扩展似乎也不值得打扰。</target>
        </trans-unit>
        <trans-unit id="35fe223925e3329d9b396b0289c0f1edb80c5f64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TupleSections&quot;&gt;&lt;code&gt;TupleSections&lt;/code&gt;&lt;/a&gt; extension enables partially applied tuple constructors. For example, the following program</source>
          <target state="translated">所述&lt;a href=&quot;#extension-TupleSections&quot;&gt; &lt;code&gt;TupleSections&lt;/code&gt; &lt;/a&gt;扩展使部分地施加元组构造。例如下面的程序</target>
        </trans-unit>
        <trans-unit id="b17d31417452ac7082cc9ac3c80a11f860e37344" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;lsquo;s type.</source>
          <target state="translated">该&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;扩展允许您使用&lt;em&gt;可视类型的应用程序&lt;/em&gt;中的表达式。这是一个示例： &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt; 。该 &lt;code&gt;@Int&lt;/code&gt; 是可见类型的应用程序; 它以 &lt;code&gt;read&lt;/code&gt; 的类型指定type变量的值。</target>
        </trans-unit>
        <trans-unit id="815a49f2870c920071d25b5de51faa8078cb6a12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; extension allows you to use &lt;em&gt;visible type application&lt;/em&gt; in expressions. Here is an example: &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt;. The &lt;code&gt;@Int&lt;/code&gt; is the visible type application; it specifies the value of the type variable in &lt;code&gt;read&lt;/code&gt;&amp;rsquo;s type.</source>
          <target state="translated">该&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;扩展允许您使用&lt;em&gt;可视类型的应用程序&lt;/em&gt;中的表达式。这是一个示例： &lt;code&gt;show (read @Int &quot;5&quot;)&lt;/code&gt; 。该 &lt;code&gt;@Int&lt;/code&gt; 是可见类型的应用程序; 它以 &lt;code&gt;read&lt;/code&gt; 的类型指定type变量的值。</target>
        </trans-unit>
        <trans-unit id="2ebe94937368bfa68f3a743d993e9e33b0ab16eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;扩展名也被解除了一些强加于型家庭情况的限制。请参见&lt;a href=&quot;#type-family-decidability&quot;&gt;类型同义词实例的可判定性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f4536f5d8a26219603d39e37690a74527cca915" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; extension is also used to lift some of the restrictions imposed on type family instances. See &lt;a href=&quot;type_families#type-family-decidability&quot;&gt;Decidability of type synonym instances&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;扩展名也被解除了一些强加于型家庭情况的限制。请参见&lt;a href=&quot;type_families#type-family-decidability&quot;&gt;类型同义词实例的可判定性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a40f430193c52ab9a3cf3f22af8fbf5bb4348a51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt;&lt;code&gt;-Wmissing-export-lists&lt;/code&gt;&lt;/a&gt; flag will warn that &lt;code&gt;M&lt;/code&gt; does not declare an export list. Declaring an explicit export list for &lt;code&gt;M&lt;/code&gt; enables GHC dead code analysis, prevents accidental export of names and can ease optimizations like inlining.</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--Wmissing-export-lists&quot;&gt; &lt;code&gt;-Wmissing-export-lists&lt;/code&gt; &lt;/a&gt;标志将警告说， &lt;code&gt;M&lt;/code&gt; 不声明导出列表。声明 &lt;code&gt;M&lt;/code&gt; 的显式导出列表可启用GHC死代码分析，防止名称的意外导出，并可简化诸如内联的优化。</target>
        </trans-unit>
        <trans-unit id="2a474ac6ba444d90bd68f49cf89271d299c2d550" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;lsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt; &lt;code&gt;-Wmissing-import-lists&lt;/code&gt; &lt;/a&gt;标志警告的进口 &lt;code&gt;Y&lt;/code&gt; 但不是 &lt;code&gt;X&lt;/code&gt; 如果模块 &lt;code&gt;Y&lt;/code&gt; 被后来改为出口（说） &lt;code&gt;f&lt;/code&gt; ，则参考 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 会变得模糊。 &lt;code&gt;Z&lt;/code&gt; 的进口没有发出警告，因为扩大 &lt;code&gt;Z&lt;/code&gt; 的出口不太可能在 &lt;code&gt;M&lt;/code&gt; 中产生歧义。</target>
        </trans-unit>
        <trans-unit id="0e9463d37bc7356ac89d64ece95dfb6664646492" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt;&lt;code&gt;-Wmissing-import-lists&lt;/code&gt;&lt;/a&gt; flag will warn about the import of &lt;code&gt;Y&lt;/code&gt; but not &lt;code&gt;X&lt;/code&gt; If module &lt;code&gt;Y&lt;/code&gt; is later changed to export (say) &lt;code&gt;f&lt;/code&gt;, then the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; will become ambiguous. No warning is produced for the import of &lt;code&gt;Z&lt;/code&gt; because extending &lt;code&gt;Z&lt;/code&gt;&amp;rsquo;s exports would be unlikely to produce ambiguity in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--Wmissing-import-lists&quot;&gt; &lt;code&gt;-Wmissing-import-lists&lt;/code&gt; &lt;/a&gt;标志警告的进口 &lt;code&gt;Y&lt;/code&gt; 但不是 &lt;code&gt;X&lt;/code&gt; 如果模块 &lt;code&gt;Y&lt;/code&gt; 被后来改为出口（说） &lt;code&gt;f&lt;/code&gt; ，则参考 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 会变得模糊。 &lt;code&gt;Z&lt;/code&gt; 的进口没有发出警告，因为扩大 &lt;code&gt;Z&lt;/code&gt; 的出口不太可能在 &lt;code&gt;M&lt;/code&gt; 中产生歧义。</target>
        </trans-unit>
        <trans-unit id="e36bf4d5a27eab719495aba2d65180ff3cb627fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; flag is only required to enable deriving of these four &amp;ldquo;standard&amp;rdquo; type classes (which are mentioned in the Haskell Report). Other extensions to the &lt;code&gt;deriving&lt;/code&gt; mechanism, which are explained below in greater detail, do not require &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; to be used in conjunction with empty data types. These include:</source>
          <target state="translated">所述&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt;标志仅需要使这四个&amp;ldquo;标准&amp;rdquo;型（其在Haskell的报告提及）类导出。 &lt;code&gt;deriving&lt;/code&gt; 机制的其他扩展（将在下面更详细地说明）不要求将&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt;与空数据类型结合使用。这些包括：</target>
        </trans-unit>
        <trans-unit id="db722c4293a180623ff6c051b1d85ff7e25c05ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt;标志允许指定类型的任何功能 &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt; ，对于一些约束 &lt;code&gt;C&lt;/code&gt; ，作为函数用于打印计算的表达式。该函数可以驻留在任何已加载的模块或任何已注册的程序包中，但是只有当它驻留在已注册的程序包中时，它才能在&lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 中&lt;/a&gt;生存。</target>
        </trans-unit>
        <trans-unit id="630c44ffedd4dd17a812ef0191fcfe9f164168e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8expr%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨expr⟩&lt;/code&gt; &lt;/a&gt;在运行时GHC的标志也可以用 &lt;code&gt;-e mode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="78f35da957d4cd52b15e9fdc17483788082f1d5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag allows to specify any function of type &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt;, for some constraint &lt;code&gt;C&lt;/code&gt;, as the function for printing evaluated expressions. The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; or, &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt; &lt;/a&gt;标志允许指定类型的任何功能 &lt;code&gt;C a =&amp;gt; a -&amp;gt; IO ()&lt;/code&gt; ，对于一些约束 &lt;code&gt;C&lt;/code&gt; ，作为函数用于打印计算的表达式。该函数可以驻留在任何已加载的模块或任何已注册的程序包中，但是只有当它驻留在已注册的程序包中时，它才能在&lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 中&lt;/a&gt;生存。</target>
        </trans-unit>
        <trans-unit id="21b2b57c36c8c1575a9d46ca71c9857aa94c645d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt;&lt;/a&gt; flag can also be used when running GHC in &lt;code&gt;-e mode&lt;/code&gt;:</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--interactive-print%20%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-interactive-print ⟨name⟩&lt;/code&gt; &lt;/a&gt;在运行时GHC的标志也可以用 &lt;code&gt;-e mode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a9ee5aa0e4404a66caea5cfa0e31661321a8a071" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; option makes GHC &lt;em&gt;verbose&lt;/em&gt;: it reports its version number and shows (on stderr) exactly how it invokes each phase of the compilation system. Moreover, it passes the &lt;code&gt;-v&lt;/code&gt; flag to most phases; each reports its version number (and possibly some other information).</source>
          <target state="translated">该&lt;a href=&quot;#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;选项使得GHC &lt;em&gt;详细&lt;/em&gt;：报告其版本号表示了（在stderr）究竟如何调用编译系统的各个阶段。而且，它将 &lt;code&gt;-v&lt;/code&gt; 标志传递到大多数阶段。每个报告其版本号（可能还报告其他信息）。</target>
        </trans-unit>
        <trans-unit id="f2aaf666449f19ca504a747ac617450334ac0091" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command is particularly useful when single-stepping, to see where you currently are:</source>
          <target state="translated">在&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt;时，单步，看到您当前所在的命令特别有用：</target>
        </trans-unit>
        <trans-unit id="c742c2c7dca48891181fe9d4cdbd89257e05f404" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command lists the source code around the current breakpoint. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt;命令列出围绕当前断点的源代码。如果您的输出设备支持它，则GHCi将以粗体突出显示活动的子表达式。</target>
        </trans-unit>
        <trans-unit id="207cb516d01051ef8920382f50ac703484da325f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#ghci-load-scope&quot;&gt;The effect of :load on what is in scope&lt;/a&gt;).</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;命令（&lt;a href=&quot;#ghci-load-scope&quot;&gt;的效果：负载上什么是在范围&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8573f5c2fc7b5e00d88d28e04c98a9bc731777f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; commands (&lt;a href=&quot;#loading-source-files&quot;&gt;Loading source files&lt;/a&gt; and &lt;a href=&quot;#ghci-compiled&quot;&gt;Loading compiled code&lt;/a&gt;) affect the top-level scope. Let&amp;rsquo;s start with the simple cases; when you start GHCi the prompt looks like this:</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;命令（&lt;a href=&quot;#loading-source-files&quot;&gt;加载源文件&lt;/a&gt;和&lt;a href=&quot;#ghci-compiled&quot;&gt;加载编译的代码&lt;/a&gt;）影响顶层作用域。让我们从简单的案例开始；当您启动GHCi时，提示如下：</target>
        </trans-unit>
        <trans-unit id="37bb2b0da32b33f4372a12f64ecdf95d300dbf99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command (&lt;a href=&quot;#ghci-module-cmd&quot;&gt;Controlling what is in scope with the :module command&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令（用：module命令&lt;a href=&quot;#ghci-module-cmd&quot;&gt;控制范围&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f54887dc2345c58aa577bced9bca30f40c4398ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; command provides a way to do two things that cannot be done with ordinary &lt;code&gt;import&lt;/code&gt; declarations:</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令提供了一种方法做两件事情，不能用普通来完成 &lt;code&gt;import&lt;/code&gt; 报关：</target>
        </trans-unit>
        <trans-unit id="18bed73a85898df39bbfb21bec72caa1d380f65e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command modifies both, but there is also a &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; command (for &amp;ldquo;set interactive&amp;rdquo;) that affects only the interactive options set.</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;指令修改两者，但也有一个&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;命令（&amp;ldquo;集互动&amp;rdquo;）的影响仅设置了互动选择。</target>
        </trans-unit>
        <trans-unit id="93a4b5fbe24659bd6501066dacfcac63a656645a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;ldquo;.</source>
          <target state="translated">所述&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;命令组的两个类型的选项：选项GHCI，这与&amp;ldquo;开头 &lt;code&gt;+&lt;/code&gt; &amp;rdquo;和&amp;ldquo;命令行&amp;rdquo;选项，其中与开始&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;ldquo;。</target>
        </trans-unit>
        <trans-unit id="09a5d114307bab84d24ded440bb5e92a7d6743f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; command sets two types of options: GHCi options, which begin with &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;command-line&amp;rdquo; options, which begin with &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">所述&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;命令组的两个类型的选项：选项GHCI，这与&amp;ldquo;开头 &lt;code&gt;+&lt;/code&gt; &amp;rdquo;和&amp;ldquo;命令行&amp;rdquo;选项，其中与开始&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="994ae649374ddd00dcbdb0398a07b789d70d3ee6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command can be used with or without an expression. When used without an expression, tracing begins from the current breakpoint, just like &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;命令可以使用或不表达来使用。当不带表达式使用时，跟踪从当前断点开始，就像&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; 一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d895b0d326a117dc38216e64627bcf0b504cc040" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt;命令要求&lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt;被设置。</target>
        </trans-unit>
        <trans-unit id="199a238337750e7292c80d8483aa164b1180ba95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ghci-cmd-:uses&quot;&gt;&lt;code&gt;:uses&lt;/code&gt;&lt;/a&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">的&lt;a href=&quot;#ghci-cmd-:uses&quot;&gt; &lt;code&gt;:uses&lt;/code&gt; &lt;/a&gt;命令要求&lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt;被设置。</target>
        </trans-unit>
        <trans-unit id="aa13aae9cfabe1538d35b3d45ac31cfcc6173609" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma has the additional effect of making the function body look small, so that when inlining is allowed it is very likely to happen.</source>
          <target state="translated">该&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;编译具有使函数体看起来很小的附加效果，所以当内联允许就很有可能发生。</target>
        </trans-unit>
        <trans-unit id="3f27181af99e9c0027aecbaabc8044d1c05e8049" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma does exactly what you&amp;rsquo;d expect: it stops the named function from being inlined by the compiler. You shouldn&amp;rsquo;t ever need to do this, unless you&amp;rsquo;re very cautious about code size.</source>
          <target state="translated">该&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译不正是你所期望的：它停止从编译器被内联命名的功能。除非您对代码大小非常谨慎，否则您永远不需要这样做。</target>
        </trans-unit>
        <trans-unit id="c1a5fffbed9c12afd5da25081d7fe2ae31e2b1e9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;编译允许您指定重写规则。在&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则中进行了&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="bf0632a671131031d8937312a06897d2e45574c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt; setting will be automatically reduced by the garbage collector when the maximum heap size (the &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt; setting) is approaching.</source>
          <target state="translated">当&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;最大堆大小（&lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt;设置）时，垃圾收集器会自动减少-F⟨factor⟩设置。</target>
        </trans-unit>
        <trans-unit id="e8b0c5124d5ea3dd22ec93a4e1efaee8762c585c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; option produces a more detailed report containing the actual time and allocation data as well. (Not used much.)</source>
          <target state="translated">所述&lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt;选项产生包含实际时间和分配数据，以及更详细的报告。（使用不多。）</target>
        </trans-unit>
        <trans-unit id="1bd683aedc043a933d9975ed15640d3bb66f7a3a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; option produces a standard &lt;em&gt;time profile&lt;/em&gt; report. It is written into the file &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt;; the stem is taken to be the program name by default, but can be overridden by the &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po
⟨stem⟩&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">该&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt;选项生成一个标准的&lt;em&gt;时间分布&lt;/em&gt;报告。它被写入文件 &lt;code&gt;&amp;lt;stem&amp;gt;.prof&lt;/code&gt; 中；默认情况下，词干为程序名称，但可以用&lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt;标志覆盖。</target>
        </trans-unit>
        <trans-unit id="6f811997f5e52254e16a04cd53e244ebe3b6c6f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pa&quot;&gt;&lt;code&gt;-pa&lt;/code&gt;&lt;/a&gt; option produces the most detailed report containing all cost centres in addition to the actual time and allocation data.</source>
          <target state="translated">该&lt;a href=&quot;#rts-flag--pa&quot;&gt; &lt;code&gt;-pa&lt;/code&gt; &lt;/a&gt;选项生成一个包含所有成本中心除了实际时间和分配数据的最详细的报告。</target>
        </trans-unit>
        <trans-unit id="7a84a3b7430c33f4f0db03022262f484fb7742f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; option produces a time/allocation profile report in JSON format written into the file &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt;选项产生JSON格式写入到该文件的时间/分配概况报告 &lt;code&gt;&amp;lt;program&amp;gt;.prof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e571794c298f99f38543a85d7967e52fd97375" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt;&lt;code&gt;-po ⟨stem⟩&lt;/code&gt;&lt;/a&gt; option overrides the stem used to form the output file paths for the cost-centre profiler (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flags above) and heap profiler (see &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">所述&lt;a href=&quot;#rts-flag--po%20%E2%9F%A8stem%E2%9F%A9&quot;&gt; &lt;code&gt;-po ⟨stem⟩&lt;/code&gt; &lt;/a&gt;选项覆盖用于形成成本中心分析器输出文件路径（见茎&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt;标志以上）和堆分析器（见&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b5635087d38bc262bde4371eac4de7d97f976c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt;输入功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9765ad4ea03f4950380592b31970ad8c5c5f3ec8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base-4.13.0.0/system-io&quot;&gt;System.IO&lt;/a&gt;输出功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Windows上多字节字符串，所以提供了这个功能，使从给定的代码页中的Unicode字符串转换为一个适当的多字节字符串。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ce9122f50ea53be58cbd2cf028ecc8f4c1bc2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt;输入功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcced739f4877615ca0b1d338f8fe3c56b49eea5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base-4.14.1.0/system-io&quot;&gt;System.IO&lt;/a&gt;输出功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Windows上多字节字符串，所以提供了这个功能，使从给定的代码页中的Unicode字符串转换为一个适当的多字节字符串。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7715095f5c8ef807cdbc23a84037a885e460b586" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt;输入功能（如 &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd8e728d7d3436bf9c9bfd3d9742877fbe0b85c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt; output functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;) don't automatically convert to multibyte string on Windows, so this function is provided to make the conversion from a Unicode string in the given code page to a proper multibyte string. To get the code page for the console, use &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../base/system-io&quot;&gt;System.IO&lt;/a&gt;输出功能（如 &lt;code&gt;&lt;a href=&quot;../base/system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Windows上多字节字符串，所以提供了这个功能，使从给定的代码页中的Unicode字符串转换为一个适当的多字节字符串。要获取控制台的代码页，请使用 &lt;code&gt;&lt;a href=&quot;system-win32-encoding#v:getCurrentCodePage&quot;&gt;getCurrentCodePage&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b352da45baeb9202cb7df82ff50b474eca2ca6d4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt; can sometimes do a far better job at producing fast code than the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;. This is not universal and depends on the code. Numeric heavy code seems to show the best improvement when compiled via LLVM. You can also experiment with passing specific flags to LLVM with the &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; and &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; flags. Be careful though as setting these flags stops GHC from setting its usual flags for the LLVM optimiser and compiler.</source>
          <target state="translated">该&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM代码生成器&lt;/a&gt;有时在比生产快的代码做一个更好的工作&lt;a href=&quot;codegens#native-code-gen&quot;&gt;的本地代码生成器&lt;/a&gt;。这不是通用的，取决于代码。通过LLVM进行编译时，数字沉重的代码似乎显示出最佳的改进。您还可以尝试通过 &lt;code&gt;-optlo ⟨option⟩&lt;/code&gt; 和 &lt;code&gt;-optlc ⟨option⟩&lt;/code&gt; 将特定标志传递给LLVM 。请注意，尽管设置这些标志会阻止GHC为LLVM优化器和编译器设置其常规标志。</target>
        </trans-unit>
        <trans-unit id="23545e3e460bae073f6181734f7192afe90ccb39" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exts/template_haskell#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="translated">该&lt;a href=&quot;exts/template_haskell#th-usage&quot;&gt;模板哈斯克尔分级限制&lt;/a&gt;适用于被注释与表达，因此，例如，你不能运行从模块的功能被编译。</target>
        </trans-unit>
        <trans-unit id="441b96de5f40c0b544a2b13e929cf0a32ab969bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension lifts the Haskell 98 restriction that the type-class constraints in a type signature must have the form &lt;em&gt;(class type-variable)&lt;/em&gt; or &lt;em&gt;(class (type-variable type1 type2 ... typen))&lt;/em&gt;. With &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; these type signatures are perfectly okay</source>
          <target state="translated">所述&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展抬起的Haskell 98限制，在一个类型的签名的类型级约束必须具有形式&lt;em&gt;（类型变量）&lt;/em&gt;或&lt;em&gt;（类（类型变量TYPE1类型2 ...力typen）） &lt;/em&gt;。使用&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; ,&lt;/a&gt;这些类型签名完全可以</target>
        </trans-unit>
        <trans-unit id="4a4611a6bd66536dd5d384f455f6f4187e13b84f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; extension relaxes this rule, as well as relaxing the corresponding rule for type signatures (see &lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;). Specifically, &lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt;, allows (well-kinded) class constraints of form &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context of an instance declaration.</source>
          <target state="translated">所述&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;扩展放松这一规则，以及放宽类型签名对应的规则（见&lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;类型签名的上下文&lt;/a&gt;）。具体来说，&lt;a href=&quot;flexible_contexts#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;允许在实例声明的上下文中（良好）类形式为 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; 类约束。</target>
        </trans-unit>
        <trans-unit id="25f2f2f377d7a4d9d4c30076fac395670f976ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ghc-err&quot;&gt;GHC.Err&lt;/a&gt; module defines the code for the wired-in error functions, which have a special type in the compiler (with &quot;open tyvars&quot;).</source>
          <target state="translated">所述&lt;a href=&quot;ghc-err&quot;&gt;GHC.Err&lt;/a&gt;模块定义了该代码的有线中的误差函数，其中有一个特殊类型的编译器（用&amp;ldquo;开放tyvars&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="be2bac9dc3e1c4a106dab0bef04844b8cf103571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;Template Haskell staging restrictions&lt;/a&gt; apply to the expression being annotated with, so for example you cannot run a function from the module being compiled.</source>
          <target state="translated">该&lt;a href=&quot;glasgow_exts#th-usage&quot;&gt;模板哈斯克尔分级限制&lt;/a&gt;适用于被注释与表达，因此，例如，你不能运行从模块的功能被编译。</target>
        </trans-unit>
        <trans-unit id="7bcd2aebd16cff6eded9cdf9d7624bc94b45657f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &amp;lt;Language.Haskell.TH.&amp;gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="translated">该&lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;模板哈斯克尔&lt;/a&gt;在GHC的维基页面有大量的信息。您也可以查阅Haddock参考文档&amp;lt;Language.Haskell.TH。&amp;gt;。&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;在模板Haskell版本2的注释&lt;/a&gt;中描述了对原始设计的许多更改。但是，并非所有这些变化都在GHC中。</target>
        </trans-unit>
        <trans-unit id="813ef8b7c698943925b858288d022656cbf4c0e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">该&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt;模块提供了一种方法，使垃圾收集长期数据结构更加高效。压缩数据结构会将对象收集在内存中，在内存中，垃圾回收器将它们视为单个对象，而不是单独遍历。</target>
        </trans-unit>
        <trans-unit id="b007f5500c0bf2359ef4d7c48a45339585e270b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">该&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt;模块提供了一种方法，使垃圾收集长期数据结构更加高效。压缩数据结构会将这些对象收集在内存中，在内存中，垃圾回收器将它们视为单个对象，而不是单独遍历。</target>
        </trans-unit>
        <trans-unit id="846fd4cdbb42806031c1db4eb657c7e293898b2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt; module provides a way to make garbage collection more efficient for long-lived data structures. Compacting a data structure collects the objects together in memory, where they are treated as a single object by the garbage collector and not traversed individually.</source>
          <target state="translated">该&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html&quot;&gt;GHC.Compact&lt;/a&gt;模块提供了一种方法，使垃圾收集长期数据结构更加高效。压缩数据结构会将对象收集在内存中，在内存中，垃圾回收器将它们视为单个对象，而不是单独遍历。</target>
        </trans-unit>
        <trans-unit id="7f5f20ac4d1c46620e544e0b73094893e035e0db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/fmlist&quot;&gt;&lt;code&gt;fmlist&lt;/code&gt;&lt;/a&gt; package takes this approach, by representing a list via its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">该&lt;a href=&quot;https://hackage.haskell.org/package/fmlist&quot;&gt; &lt;code&gt;fmlist&lt;/code&gt; &lt;/a&gt;包采用这种方法，由代表通过其列表 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 行动。</target>
        </trans-unit>
        <trans-unit id="419b4e0aea1efdbf0b01d8b1d21faeb75cc776ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hackage.haskell.org/package/foldl&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; package implements a robust general framework for dealing with this situation. If you choose to to do it yourself, with a bit of care, the simplest cases are not difficult to handle directly. You just need to accumulate the individual aggregates as &lt;strong&gt;strict&lt;/strong&gt; components of a single data type, and then apply a final transformation to it to extract the composite result. For example, computing an average requires computing both the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; of a (non-empty) structure and dividing the sum by the length:</source>
          <target state="translated">在&lt;a href=&quot;https://hackage.haskell.org/package/foldl&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt;包实现了处理这种情况一个强大的总体框架。如果您选择自己动手做，但要格外小心，最简单的情况并不难直接处理。您只需要将单个聚合累积为单个数据类型的&lt;strong&gt;严格&lt;/strong&gt;组成部分，然后对其进行最终转换以提取复合结果。例如，计算平均值需要计算（非空）结构的 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ，然后将总和除以长度：</target>
        </trans-unit>
        <trans-unit id="b627e268f4e5e65bb4d343165c72971cc53747cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;Template Haskell&lt;/a&gt; page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th&quot;&gt;Language.Haskell.TH&lt;/a&gt;. Many changes to the original design are described in &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;Notes on Template Haskell version 2&lt;/a&gt;. Not all of these changes are in GHC, however.</source>
          <target state="translated">该&lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;模板哈斯克尔&lt;/a&gt;在GHC的维基页面有大量的信息。您也可以查阅Haddock参考文档&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th&quot;&gt;Language.Haskell.TH&lt;/a&gt;。&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/th2.ps&quot;&gt;在模板Haskell版本2的注释&lt;/a&gt;中描述了对原始设计的许多更改。但是，并非所有这些变化都在GHC中。</target>
        </trans-unit>
        <trans-unit id="070dd57b8d8cd78717786ee303fe48951109a4cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; flag is required for all code that will end up in a shared library. The &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flag specifies to make a shared library rather than a program. To make this clearer we can break this down into separate compilation and link steps:</source>
          <target state="translated">所述&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;标志是必需的所有的代码，将在一个共享库中结束。该&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;标志指定作共享库，而不是一个项目。为了使这一点更清楚，我们可以将其分解为单独的编译和链接步骤：</target>
        </trans-unit>
        <trans-unit id="92ecf85c887a15b246620bb154b24adf3249c4f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma lets you specify rewrite rules. It is described in &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;编译允许您指定重写规则。在&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;重写规则中进行了&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="096f364a4638bd5a30481fff7cf63dd60a75f2bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library manages multiplexing in its own way. On Windows systems it uses &lt;code&gt;safe&lt;/code&gt; foreign calls to ensure that threads doing I/O operations don't block the whole runtime, whereas on Unix systems all the currently blocked I/O requests are managed by a single thread (the &lt;em&gt;IO manager thread&lt;/em&gt;) using a mechanism such as &lt;code&gt;epoll&lt;/code&gt; or &lt;code&gt;kqueue&lt;/code&gt;, depending on what is provided by the host operating system.</source>
          <target state="translated">该&lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt;图书馆负责复用自己的方式。在Windows系统上，它使用 &lt;code&gt;safe&lt;/code&gt; 外部调用来确保执行I / O操作的线程不会阻塞整个运行时，而在Unix系统上，所有当前阻塞的I / O请求都由单个线程（&lt;em&gt;IO管理器线程&lt;/em&gt;）使用一种机制，例如 &lt;code&gt;epoll&lt;/code&gt; 或 &lt;code&gt;kqueue&lt;/code&gt; ，取决于主机操作系统提供的内容。</target>
        </trans-unit>
        <trans-unit id="ad73609e01e96153a93cfebddc86a915d6769a77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;text-read&quot;&gt;Text.Read&lt;/a&gt; library is the canonical library to import for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;-class facilities. For GHC only, it offers an extended and much improved &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class, which constitutes a proposed alternative to the Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;. In particular, writing parsers is easier, and the parsers are much more efficient.</source>
          <target state="translated">该&lt;a href=&quot;text-read&quot;&gt;Text.Read&lt;/a&gt;库是规范的库导入用于 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; -class设施。仅针对GHC，它提供了扩展的且经过改进的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类，它构成了Haskell 2010 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 的建议替代方案。特别是，编写解析器更加容易，而解析器则更加高效。</target>
        </trans-unit>
        <trans-unit id="6049bb328d08178d103c9076445b562b087834cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;state hack&lt;/code&gt;&lt;/a&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;#7411&lt;/a&gt;). For instance,</source>
          <target state="translated">该&lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;state hack&lt;/code&gt; &lt;/a&gt;优化可以导致评价排序不明显的变化，这可能隐藏例外，甚至&lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt;（见，例如，&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;＃7411&lt;/a&gt;）。例如，</target>
        </trans-unit>
        <trans-unit id="f6bc8b6c64115e4a7c4698a00f5d0d1bc2ad89f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; operator adds the bound function into the continuation chain.</source>
          <target state="translated">所述 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 操作者增加了结合的功能到延续链。</target>
        </trans-unit>
        <trans-unit id="5c388ccd0a655842d446db681e2ea71ce5783acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'MetaSel&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt;, which can be used to obtain information about the field at the value level.</source>
          <target state="translated">该 &lt;code&gt;'MetaSel&lt;/code&gt; 类型也是类型类的实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Selector&quot;&gt;Selector&lt;/a&gt;&lt;/code&gt; ，它可以用于获得关于在值级别的字段信息。</target>
        </trans-unit>
        <trans-unit id="d0fc85998eb7929a8a09016834cb15b185c38b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(!)&lt;/code&gt; operator, when written in prefix form (preceded by whitespace and not followed by whitespace, as in &lt;code&gt;f !x = ...&lt;/code&gt;), is interpreted as a bang pattern, contrary to the Haskell Report, which prescribes to treat &lt;code&gt;!&lt;/code&gt; as an operator regardless of surrounding whitespace. Note that this does not imply that GHC always enables &lt;a href=&quot;exts/strict#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt;. Without the extension, GHC will issue a parse error on &lt;code&gt;f !x&lt;/code&gt;, asking to enable the extension.</source>
          <target state="translated">的 &lt;code&gt;(!)&lt;/code&gt; 操作符，写成前缀形式时（由空格前面和后面没有空格，如 &lt;code&gt;f !x = ...&lt;/code&gt; ），被解释为爆炸模式，违背了Haskell的报告，其中规定了对待 &lt;code&gt;!&lt;/code&gt; 作为运算符，而不考虑周围的空白。请注意，这并不意味着GHC始终启用&lt;a href=&quot;exts/strict#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; &lt;/a&gt;。如果没有扩展名，GHC将在 &lt;code&gt;f !x&lt;/code&gt; 上发出解析错误，要求启用扩展名。</target>
        </trans-unit>
        <trans-unit id="866373df1d7e4a2d96c88db426b8a4e214a580f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(C t1..tj)&lt;/code&gt; is a partial applications of the class &lt;code&gt;C&lt;/code&gt;, where the arity of &lt;code&gt;C&lt;/code&gt; is exactly &lt;code&gt;j+1&lt;/code&gt;. That is, &lt;code&gt;C&lt;/code&gt; lacks exactly one type argument.</source>
          <target state="translated">的 &lt;code&gt;(C t1..tj)&lt;/code&gt; 是类的局部应用 &lt;code&gt;C&lt;/code&gt; ，其中的元数 &lt;code&gt;C&lt;/code&gt; 正是 &lt;code&gt;j+1&lt;/code&gt; 。也就是说， &lt;code&gt;C&lt;/code&gt; 恰好缺少一种类型参数。</target>
        </trans-unit>
        <trans-unit id="0e53d457109427ef5ddcdce2f9d16292b3ffd5e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt;-form is only available for modules which are interpreted; for compiled modules (including modules from packages) only the non-&lt;code&gt;*&lt;/code&gt; form of &lt;a href=&quot;#ghci-cmd-:browse&quot;&gt;&lt;code&gt;:browse&lt;/code&gt;&lt;/a&gt; is available.</source>
          <target state="translated">的 &lt;code&gt;*&lt;/code&gt; -型仅适用于被解释模块; 对于已编译的模块（包括软件包中的模块），仅非 &lt;code&gt;*&lt;/code&gt; 形式的&lt;a href=&quot;#ghci-cmd-:browse&quot;&gt; &lt;code&gt;:browse&lt;/code&gt; &lt;/a&gt;可用。</target>
        </trans-unit>
        <trans-unit id="b53e971ecc81a3e0c6bf1b64d28ddf52cdda1a1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-#include&lt;/code&gt; option is now deprecated, and the &lt;code&gt;include-files&lt;/code&gt; field in a Cabal package specification is ignored.</source>
          <target state="translated">本 &lt;code&gt;-#include&lt;/code&gt; 选项现在已经过时，并且 &lt;code&gt;include-files&lt;/code&gt; 在惊天动地包规范场被忽略。</target>
        </trans-unit>
        <trans-unit id="ab34545a3d0cf93b61e2311037778df3c80a23fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; flag is typically beneficial when a program is using all cores of a large multi-core NUMA system, with a large allocation area (&lt;code&gt;-A&lt;/code&gt;). All memory accesses to the allocation area will go to local memory, which can save a significant amount of remote memory access. A runtime speedup on the order of 10% is typical, but can vary a lot depending on the hardware and the memory behaviour of the program.</source>
          <target state="translated">当程序使用具有较大分配区域（ &lt;code&gt;-A&lt;/code&gt; ）的大型多核NUMA系统的所有核时，-- &lt;code&gt;--numa&lt;/code&gt; 标志通常非常有用。对分配区域的所有内存访问都将进入本地内存，这可以节省大量的远程内存访问。通常，运行时加速会达到10％左右，但取决于硬件和程序的内存行为，其运行速度可能会有很大差异。</target>
        </trans-unit>
        <trans-unit id="561f71da812b2bddee25afb3e6e2e25bcb2e2f87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numa&lt;/code&gt; option tells the RTS to tune its memory usage to maximize local memory accesses. In particular, the RTS will:</source>
          <target state="translated">该 &lt;code&gt;--numa&lt;/code&gt; 选项告诉RTS调整其内存使用量，最大限度的本地存储器访问。特别是，RTS将：</target>
        </trans-unit>
        <trans-unit id="82790760e32203fbe3b3708f08a40fb1f26d4abb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-O*&lt;/code&gt; options specify convenient &amp;ldquo;packages&amp;rdquo; of optimisation flags; the &lt;code&gt;-f*&lt;/code&gt; options described later on specify &lt;em&gt;individual&lt;/em&gt; optimisations to be turned on/off; the &lt;code&gt;-m*&lt;/code&gt; options specify &lt;em&gt;machine-specific&lt;/em&gt; optimisations to be turned on/off.</source>
          <target state="translated">该 &lt;code&gt;-O*&lt;/code&gt; 选项指定方便优化标志的&amp;ldquo;套餐&amp;rdquo;; 稍后描述的 &lt;code&gt;-f*&lt;/code&gt; 选项指定要打开/关闭的&lt;em&gt;各个&lt;/em&gt;优化；该 &lt;code&gt;-m*&lt;/code&gt; 选项指定&lt;em&gt;计算机特定&lt;/em&gt;的优化，以开启/关闭。</target>
        </trans-unit>
        <trans-unit id="00acee18a5b40f8ae0cd328101fb51b5648ea410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-S&lt;/code&gt; flag, as well as giving the same output as the &lt;code&gt;-s&lt;/code&gt; flag, prints information about each GC as it happens:</source>
          <target state="translated">该 &lt;code&gt;-S&lt;/code&gt; 标志，以及给输出一样 &lt;code&gt;-s&lt;/code&gt; 标志，打印有关每个GC的信息，因为它发生：</target>
        </trans-unit>
        <trans-unit id="5abe89944b59b5975a75aacf7b4842e37070b39c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; extension switches the desugaring of &lt;code&gt;do&lt;/code&gt;-blocks to use &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of &lt;code&gt;Monad.fail&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-XMonadFailDesugaring&lt;/code&gt; 扩展名将 &lt;code&gt;do&lt;/code&gt; - block 的减重切换为使用 &lt;code&gt;MonadFail.fail&lt;/code&gt; 而不是 &lt;code&gt;Monad.fail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97d0f469a862a380331313f906971c001e89be36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-fno-gen-manifest&lt;/code&gt; disables generation of the manifest file. One reason to do this would be if you had a manifest file of your own, for example.</source>
          <target state="translated">该 &lt;code&gt;-fno-gen-manifest&lt;/code&gt; 不能产生清单文件。这样做的原因之一是，例如，如果您拥有自己的清单文件。</target>
        </trans-unit>
        <trans-unit id="f09316b31fc22fa8a933567bd8337abedb8c8a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hie&lt;/code&gt; file suffix for extended interface files to whatever you specify.</source>
          <target state="translated">该 &lt;code&gt;-hiesuf&lt;/code&gt; ⟨suffix⟩将改变 &lt;code&gt;.hie&lt;/code&gt; 的扩展接口文件后缀的文件到你指定的任何。</target>
        </trans-unit>
        <trans-unit id="181c112c9b1448494d00b3a0eb2345692c427713" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-hisuf&lt;/code&gt;/&lt;code&gt;-osuf&lt;/code&gt; game is particularly useful if you want to compile a program both with and without profiling, in the same directory. You can say:</source>
          <target state="translated">该 &lt;code&gt;-hisuf&lt;/code&gt; / &lt;code&gt;-osuf&lt;/code&gt; 如果你想编译程序既没有分析，在同一目录下比赛是非常有用的。你可以说：</target>
        </trans-unit>
        <trans-unit id="9cfd0028b8c4e48cc0b0a43a4c0d4e8fc3d08a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-no-hs-main&lt;/code&gt; flag can also be used to persuade the compiler to do the link step in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode when there is no Haskell &lt;code&gt;Main&lt;/code&gt; module present (normally the compiler will not attempt linking when there is no &lt;code&gt;Main&lt;/code&gt;).</source>
          <target state="translated">当没有Haskell &lt;code&gt;Main&lt;/code&gt; 模块存在时， &lt;code&gt;-no-hs-main&lt;/code&gt; 标志还可以用于说服编译器以&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式执行链接步骤（通常，当没有 &lt;code&gt;Main&lt;/code&gt; 时，编译器将不尝试链接）。</target>
        </trans-unit>
        <trans-unit id="cfb7b69d0673862e9ddfa0a4b5f54819de95e5d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.o&lt;/code&gt; file suffix for object files to whatever you specify. We use this when compiling libraries, so that objects for the profiling versions of the libraries don&amp;rsquo;t clobber the normal ones.</source>
          <target state="translated">该 &lt;code&gt;-osuf&lt;/code&gt; ⟨suffix⟩将改变 &lt;code&gt;.o&lt;/code&gt; 为任何你指定目标文件后缀的文件。我们在编译库时使用它，以使库的分析版本的对象不会破坏正常对象。</target>
        </trans-unit>
        <trans-unit id="cf7cc663be7922fef0739796260273d9b72b496e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hiedir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hiedir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;-outputdir&lt;/code&gt; 选项是组合速记&lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--hiedir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hiedir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58fc191cffb134d6d4bcb21e65f27ae26e638ff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-outputdir&lt;/code&gt; option is shorthand for the combination of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-stubdir
⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;-outputdir&lt;/code&gt; 选项是组合速记&lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--stubdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-stubdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--dumpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-dumpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ae93959276ca239dd5463c43ee8f6f822a7abcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option also causes package ⟨pkg⟩ to be linked into the resulting executable or shared object. Whether a packages&amp;rsquo; library is linked statically or dynamically is controlled by the flag pair &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/ &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">所述 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 选项也导致包⟨pkg⟩被链接到生成的可执行文件或共享对象。软件包库是静态链接还是动态链接由标志对&lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 进行控制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="712c183f0262639bdefc67f670ef5786d9f9839d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qn&lt;/code&gt; flag may be useful when running with a large &lt;code&gt;-A&lt;/code&gt; value (so that GC is infrequent), and a large &lt;code&gt;-N&lt;/code&gt; value (so as to make use of hyperthreaded cores, for example). For example, on a 24-core machine with 2 hyperthreads per core, we might use &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; to specify that the mutator should use hyperthreads but the GC should only use real cores. Note that this configuration would use 6GB for the allocation area.</source>
          <target state="translated">所述 &lt;code&gt;-qn&lt;/code&gt; 具有大运行时，标志可以是有用的 &lt;code&gt;-A&lt;/code&gt; 值（使得GC是不频繁），和一个大 &lt;code&gt;-N&lt;/code&gt; 值（以便使用超线程核的，例如）。例如，在每个内核有2个超线程的24内核计算机上，我们可以使用 &lt;code&gt;-N48 -qn24 -A128m&lt;/code&gt; 来指定mutator应该使用超线程，而GC应该仅使用真实内核。请注意，此配置将使用6GB作为分配区域。</target>
        </trans-unit>
        <trans-unit id="b8f8cb8014da701a79e6b46cb3e225b86d226612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. Note that the &lt;code&gt;where&lt;/code&gt; clause is still necessary to distinguish closed families from open ones. If you give any equations of a closed family, you must give all of them, in the same order as they appear in the accompanying Haskell file.</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 字面上的意思-你应该在你的文件中写入两个点。请注意，仍然需要 &lt;code&gt;where&lt;/code&gt; 子句来区分封闭家庭和开放家庭。如果给出封闭族的任何方程式，则必须按照在随附的Haskell文件中出现的顺序给出所有方程式。</target>
        </trans-unit>
        <trans-unit id="83164f5917a7372adba9f0624f17681c738f05e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; is meant literally &amp;ndash; you should write two dots in your file. The &lt;code&gt;where&lt;/code&gt; clause distinguishes closed families from open ones.</source>
          <target state="translated">该 &lt;code&gt;..&lt;/code&gt; 字面上的意思-你应该在你的文件中写入两个点。在 &lt;code&gt;where&lt;/code&gt; 子句区分开那些关闭的家庭。</target>
        </trans-unit>
        <trans-unit id="dcb0143d4440c731a3c677d373f63d932883b86d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hp&lt;/code&gt; file is generated incrementally as your program runs. In principle, running &lt;strong&gt;hp2ps&lt;/strong&gt; on the incomplete file should produce a snapshot of your program&amp;rsquo;s heap usage. However, the last sample in the file may be incomplete, causing &lt;strong&gt;hp2ps&lt;/strong&gt; to fail. If you are using a machine with UNIX utilities installed, it&amp;rsquo;s not too hard to work around this problem (though the resulting command line looks rather Byzantine):</source>
          <target state="translated">该 &lt;code&gt;.hp&lt;/code&gt; 文件逐步产生的程序运行。原则上，在不完整的文件上运行&lt;strong&gt;hp2ps&lt;/strong&gt;应该会生成程序堆使用情况的快照。但是，文件中的最后一个样本可能不完整，从而导致&lt;strong&gt;hp2ps&lt;/strong&gt;失败。如果您使用的计算机上安装了UNIX实用程序，则解决此问题并不是很困难（尽管生成的命令行看起来像是拜占庭式的）：</target>
        </trans-unit>
        <trans-unit id="cc7ae67c0b8544a12cdcfe050a8d2d65b4d2d666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:loc-at&lt;/code&gt; command requires &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; to be set.</source>
          <target state="translated">的 &lt;code&gt;:loc-at&lt;/code&gt; 命令要求&lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt;被设置。</target>
        </trans-unit>
        <trans-unit id="868acbe7a67a816021798517632096beabaa53fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="245cbed390fbb3e5caa7e31d436f7995b13c904c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="642ea10a7ef999e759dd2a8003076f1bb542bca1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="a07f81de1f86161a74a26e3f56178d074bbb9cb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="2d902fab64461e51ee2d74548c6c487fbabdaebf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="3c17f4dbd13e6f82990bc913e1553422faf7c0d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数忽略了环境，同时 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 通过继承的环境都subcomputations。</target>
        </trans-unit>
        <trans-unit id="51a96013d171e823610e883b0dcca6ee8756149e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 功能叶的状态不变，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 使用第一个计算作为第二初始状态的最终状态。</target>
        </trans-unit>
        <trans-unit id="d443b950974bb112ab951f3d2eeff5624ca7c870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5978bf75b4f58ddc37c3dcfcb955a35e4410f24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eefac33165054643d0f820e7473410a1e3ca417e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参见 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="197b7d8676ceb906c4004a1522862a02b89f5e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参见 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e2a2bef52e7aaec2926a366a49ef4ff7f5dc015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生该值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，如果任一计算不退出。</target>
        </trans-unit>
        <trans-unit id="a772099ec423a1c20cd2f57c2352719bbfc68ad0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生给定的值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations中，离开第一个例外。</target>
        </trans-unit>
        <trans-unit id="0c02e3b1c74fff6be8fd138b7b81638f5520f137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生一个成功的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，失败的第一个错误。</target>
        </trans-unit>
        <trans-unit id="591c2084b78ba16832d7264b63d440c1c164a1fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; ，随着 &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fd5d1becb199aae7fcf8f5cddb1b46323f94938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="b9caf64cdefb09c64255eb7f22c88a16a5fc1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="d633291de962b83e64a4f5366d8780f130fabd29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将在第13位或第14位小数位丢失精度。</target>
        </trans-unit>
        <trans-unit id="d703712be7881bd93cfd2bc01dfee32118d427e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将在第13位或第14位小数位丢失精度。</target>
        </trans-unit>
        <trans-unit id="f8c0ff807ccff9eb26062cb229ca77b0ed057850" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="9c784a6d7ab10d7763556a008a4766e1b2eda4a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="8d81a3f4c85b4191151075e8c67e5bf6b30eb413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="886078b2aaab08d590ba45d81857ef8f5563600b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="519517bb832149c99d7d65f9e38c30f74e55d8c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 参数名的可执行文件，并根据用于搜索可执行文件平台的标准政策解释。特别：</target>
        </trans-unit>
        <trans-unit id="9c0ad1ae490321b15fc5c17f80550d3243babef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dece6bc59608b974325c5124d02a6f75ef4c62d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="f7a9c0b4e24f513886a0fe3de6f9f53dadcdf0d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="1bc09e39326ac463b521633cc81f1ec225a8a20d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="68eed02a9714eb35cf81751d72df7caa308a61f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="7f2da1b81116404bb6e8b43cb3a0637a688bb46e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数忽略了环境，同时 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 通过继承的环境都subcomputations。</target>
        </trans-unit>
        <trans-unit id="260fcde2dc8277fbba23a670e261449948424309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 功能叶的状态不变，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 使用第一个计算作为第二初始状态的最终状态。</target>
        </trans-unit>
        <trans-unit id="dc6d56b3f6d2c5e6f40ede452ae79b597fe5912c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c0f713409cb9cf5a1a1a5c72fd485b5db43eb31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7de8acf7cc9bc186692daa7881912af0fc23a852" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参阅 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1706a86dea612dae3883f17c7ddf1ff83583e970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参阅 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56aecaa933008307756b2efe20503802422650bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生该值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，如果任一计算不退出。</target>
        </trans-unit>
        <trans-unit id="1cc201c4c6a6bfd3a1b5af7fbb6792cb6cd39609" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生给定的值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations中，离开第一个例外。</target>
        </trans-unit>
        <trans-unit id="d623297a7b53d6225cb0faf61fb94fa727435ae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生一个成功的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，失败的第一个错误。</target>
        </trans-unit>
        <trans-unit id="55ee7b9be2c0feeeaeb3c31adf4da82d6f854ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; ，随着 &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11e1aa3150c01618910f02e8bbc7bf355bd69cbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是必要的处理元组的部分。</target>
        </trans-unit>
        <trans-unit id="11b5bc40c86fffa7a6076174b1bffbac140f29df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="f95780e47c020eeeda31a8c201eb535a8974578f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="8a75b664a9646e6aa02764c34d0fe587f5a1dfbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将失去第13位或第14位小数的精度。</target>
        </trans-unit>
        <trans-unit id="1201c6da12de4aba1276a3d6388e0825a36aceda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将失去第13位或第14位小数的精度。</target>
        </trans-unit>
        <trans-unit id="2acb16e4a1657fdc3b4413dfd0838f6380ef5ab8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="a9de1cc1416c3082400d8b6dfbf1289ad2cbe6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="d955c1b4b45545a54049a0a44af93865745803be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1e8a62dc2c0577ea2e4fa388d91268432827035" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6e7c89abb8ca4cf07ac674bde1a74e6e1be7e25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 参数名的可执行文件，并根据用于搜索可执行文件平台的标准政策解释。具体来说：</target>
        </trans-unit>
        <trans-unit id="f78ea894305fa2f92651eb848a796e984b4e4110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d405feb3a6b9895afaa0f318b7f28398f4bd6aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="86f1266aae7ad8bdc0dba42358ae53d2bcc3771f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="458e0e129dcbdfa5cce87aefa9e19048a965d645" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="fc0c4cd9b9fd204bedd14ea51fb195630c8139d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactics are included because they are valid. However, they are inefficient in many cases and should usually be avoided. The instances for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactics should not pose any major efficiency problems.</source>
          <target state="translated">包含 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; 策略的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-category#v:Category&quot;&gt;Category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例，因为它们是有效的。但是，它们在许多情况下效率低下，通常应避免使用。 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略的实例不应造成任何重大的效率问题。</target>
        </trans-unit>
        <trans-unit id="d72da00b002507603215122aff2a0c788a0b577d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function ignores the environment, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; passes the inherited environment to both subcomputations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数忽略了环境，同时 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 通过继承的环境都subcomputations。</target>
        </trans-unit>
        <trans-unit id="975265378d608c7754aeb46eef5e343d004094c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function leaves the state unchanged, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; uses the final state of the first computation as the initial state of the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 功能叶的状态不变，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 使用第一个计算作为第二初始状态的最终状态。</target>
        </trans-unit>
        <trans-unit id="046b9ec685e02d0b7255d415f7a53e51ece44c02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce59aa9aa7770be720fe2f9ab4b78c390dafeca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function produces the output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; combines the outputs of the subcomputations using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生输出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ，而 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 结合使用subcomputations的输出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab2094e6381df03e75161328d5b93c89ad3d9048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参阅 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc17f1fd4fad20e7ff547a572bbb918d61a43edc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function returns a normal value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; exits on the first exception. For a variant that continues after an error and collects all the errors, see &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数返回一个正常值，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 第一异常退出。有关在发生错误后仍继续并收集所有错误的变体，请参阅 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Errors&quot;&gt;Errors&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a9fbc9218ae7816a7764ba8f4b7ea997abf1ec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces that value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting if either computation does.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生该值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，如果任一计算不退出。</target>
        </trans-unit>
        <trans-unit id="dbde8b545bd4180a31e36b9eaf901736baf44dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a computation that produces the given value, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, exiting on the first exception.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生，其产生给定的值的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations中，离开第一个例外。</target>
        </trans-unit>
        <trans-unit id="70d2fe74f9a13fe2abf46ab4a20202c52ca11c4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; function yields a successful computation, while &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; sequences two subcomputations, failing on the first error.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 函数产生一个成功的计算，而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 序列的两个subcomputations，失败的第一个错误。</target>
        </trans-unit>
        <trans-unit id="0392dbac15f5a29ace95ddc3854629ee10a2c673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; methods &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;, along with &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; ，随着 &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a49a233b3aaeb66c434e12308ae79ebd04f8c90b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is necessary for handling tuple sections.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是必要的处理元组的部分。</target>
        </trans-unit>
        <trans-unit id="4a31b665a96aa687aea00989af736838ac7b1ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="ba0b18140a235048175aac50f5fcbba208d418d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used for the same purposes as the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于相同目的的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="97ca3a40e1687acc199ba4ae4156a478a2153d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将失去第13位或第14位小数的精度。</target>
        </trans-unit>
        <trans-unit id="28366f4f1cc4165989efbd16469d4c39f286fe41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; type supports about 16 decimal places of accuracy. For 94.2% of numbers, this function and &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; give identical results, but for the remaining 5.8%, this function loses precision around the 15th decimal place. For 0.001% of numbers, this function will lose precision at the 13th or 14th decimal place.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 类型支持有关精度的16位小数。对于94.2％的数字，此函数和 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 给出相同的结果，但对于其余的5.8％，此函数的精度在小数点后15位左右丢失。对于0.001％的数字，此功能将失去第13位或第14位小数的精度。</target>
        </trans-unit>
        <trans-unit id="54880289dd15dc1c7fcd477651a6537f2d2ab48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="dc53a4659b8ab96fd92904a1a6f76268c60e672b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; is used to append the result of several parsers, for example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 例如 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt;&lt;/code&gt; 用于追加几个解析器，用于示例的结果：</target>
        </trans-unit>
        <trans-unit id="89cddb92704acf6ee37cc5e18ac776492c7fd174" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ece285de7b69fb6ebec656427cb5d85fead59f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; operation for &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;, which prefers values from the left operand. If &lt;code&gt;m1&lt;/code&gt; maps a key &lt;code&gt;k&lt;/code&gt; to a value &lt;code&gt;a1&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; maps the same key to a different value &lt;code&gt;a2&lt;/code&gt;, then their union &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; maps &lt;code&gt;k&lt;/code&gt; to &lt;code&gt;a1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 操作是 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; ，它更喜欢左侧操作数中的值。如果 &lt;code&gt;m1&lt;/code&gt; 将键 &lt;code&gt;k&lt;/code&gt; 映射到值 &lt;code&gt;a1&lt;/code&gt; ，而 &lt;code&gt;m2&lt;/code&gt; 将相同键映射到不同值 &lt;code&gt;a2&lt;/code&gt; ，则它们的并集 &lt;code&gt;m1 &amp;lt;&amp;gt; m2&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 映射到 &lt;code&gt;a1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="161eb66f14a2659bb4450195c7fef766d0c5fa15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; argument names the executable, and is interpreted according to the platform's standard policy for searching for executables. Specifically:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 参数名的可执行文件，并根据用于搜索可执行文件平台的标准政策解释。具体来说：</target>
        </trans-unit>
        <trans-unit id="b8ec1a27d9645ead49a8fac70722d498afadafab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 仿函数。</target>
        </trans-unit>
        <trans-unit id="404d7369c3ed5cd7574fad867737a14afb444a12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; class is equivalent to &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;: any monad gives rise to a &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; arrow, and any instance of &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; defines a monad.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 类相当于 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; ：任何单子产生了 &lt;code&gt;&lt;a href=&quot;control-arrow#t:Kleisli&quot;&gt;Kleisli&lt;/a&gt;&lt;/code&gt; 箭头，的任何实例 &lt;code&gt;&lt;a href=&quot;control-arrow#t:ArrowApply&quot;&gt;ArrowApply&lt;/a&gt;&lt;/code&gt; 限定单子。</target>
        </trans-unit>
        <trans-unit id="712abe7e2f78e39742519eb3d9a6b4a2f4ce365d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; operator expresses computations in which an output value is fed back as input, although the computation occurs only once. It underlies the &lt;code&gt;rec&lt;/code&gt; value recursion construct in arrow notation. &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; should satisfy the following laws:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 操作者表示，其中的输出值被反馈作为输入计算，虽然计算仅发生一次。它是箭头表示法的 &lt;code&gt;rec&lt;/code&gt; 值递归构造的基础。 &lt;code&gt;&lt;a href=&quot;control-arrow#v:loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; 应满足以下法律：</target>
        </trans-unit>
        <trans-unit id="4d5ea08c77b20ca5949edb787e87c9bfc18d424c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 操作允许（力，在一个合作多任务执行）一个上下文切换到任何其它目前可运行的线程（如果有的话），并实施并发抽象时是偶尔是有用的。</target>
        </trans-unit>
        <trans-unit id="2aecf2fbfb3505dad21f83e912f2781f57633420" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; classes, with some useful operations on monads.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类，对单子一些有用的操作。</target>
        </trans-unit>
        <trans-unit id="e42cbe3850d6befefe426ee80a44a4c35d7e57b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="4fc32a4cddc34ade233961b4012b777dbb17097e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例使我们可以将可能失败的多个动作链接在一起，如果任何单个步骤失败，则整体失败。首先，我们将编写一个可以从 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 解析 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 或失败的函数。</target>
        </trans-unit>
        <trans-unit id="841e7fb83df459d53e389056b37c0fc15cd60e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are not strict in the state. For example,</source>
          <target state="translated">状态中的 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 操作不严格。例如，</target>
        </trans-unit>
        <trans-unit id="8492deac48ede758cea8f52bc65fb3e2f9ba2826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; operations are strict in the state (though not in values stored in the state). For example,</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 操作在状态严格（虽然不是在存储在状态值）。例如，</target>
        </trans-unit>
        <trans-unit id="27d5a6c8ea1acb5010f2c9679c264fd5c989ebdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, except that its result is encapsulated in a monad. Note that &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; works from left-to-right over the list arguments. This could be an issue where &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; and the `folded function' are not commutative.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 函数类似于 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ，不同之处在于它的结果被封装在单子。请注意， &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 在列表参数上从左到右起作用。这可能是 &lt;code&gt;(&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 和&amp;ldquo;折叠函数&amp;rdquo;不可交换的问题。</target>
        </trans-unit>
        <trans-unit id="9ee235b387a6a14db33bdf2a6b2158fa66bc38c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的功能是传统的单子连接操作。它用于删除单子结构的一个级别，将其绑定参数投射到外部级别。</target>
        </trans-unit>
        <trans-unit id="b7e9731c305b0f549055c674d9ac68832bd130e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state monad.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapAndUnzipM&quot;&gt;mapAndUnzipM&lt;/a&gt;&lt;/code&gt; 函数的第一个参数映射了一个列表，返回结果为一对列表。此功能主要用于复杂的数据结构或状态monad。</target>
        </trans-unit>
        <trans-unit id="adfaa2036ac4e96d2cf9b7c53ce9041b46c41b72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; to arbitrary applicative functors.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad#v:zipWithM&quot;&gt;zipWithM&lt;/a&gt;&lt;/code&gt; 功能概括 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 任意应用性函子。</target>
        </trans-unit>
        <trans-unit id="9e4c77f8896de4159de2b19d91214d29c830fc9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="680d557813d267dc8f3ee06e2da84590ab3ebc77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; 单子（也称为环境单子）。表示一种计算，该计算可以从共享环境中读取值，在函数之间传递值，以及在修改后的环境中执行子计算。与使用 &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad 相比，使用 &lt;code&gt;&lt;a href=&quot;control-monad-reader#t:Reader&quot;&gt;Reader&lt;/a&gt;&lt;/code&gt; monad进行这样的计算通常更容易。</target>
        </trans-unit>
        <trans-unit id="81283641c0b20f0b2748a09d602fde66cbffe272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; operation has a more complex type, so we need to use the special-purpose lifting function &lt;code&gt;liftCatch&lt;/code&gt; provided by most monad transformers. Here we use the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; version followed by the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; version:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:catchE&quot;&gt;catchE&lt;/a&gt;&lt;/code&gt; 操作具有更复杂的类型，所以我们需要使用专用的升降功能 &lt;code&gt;liftCatch&lt;/code&gt; 大多数单子变压器提供。在这里，我们使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 版本，然后使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 版本：</target>
        </trans-unit>
        <trans-unit id="545d7b475a316b28ef1da840a21adda70380c2c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; monad transformer extends a monad with the ability to exit the computation without returning a value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; 单子转换扩展与退出的计算不返回值的能力的单子。</target>
        </trans-unit>
        <trans-unit id="a2118806ea587f5911ee90a60aa429d89bdcab96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-array#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; 与使用在所述关联列表中重复指数函数优惠&lt;em&gt;累积功能&lt;/em&gt;相结合的关联的值具有相同的索引。</target>
        </trans-unit>
        <trans-unit id="0179248504c3fa08ab2a958c9b5147b68d6c33e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifind&quot;&gt;bifind&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和结构，并返回该结构的最左边的元素相匹配的谓词，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="87802a775d4245309a8eade317e7d18abe967e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biproduct&quot;&gt;biproduct&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="e6a2674d1a15617e9adc9ceb2614394b34abbb43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisum&quot;&gt;bisum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="dc2ecd95ed8a8f0c6f2cf1d560aaa6d8aea4ed41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类提供 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; ，方法进行编码和解码Haskell的价值懒惰 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它镜像了 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类，以用于Haskell类型的文本表示，并且适用于通过网络将Haskell值序列化到磁盘上。</target>
        </trans-unit>
        <trans-unit id="ef67bb75d4cd691a3105fe1fbf4dfcaa9ea238dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类提供 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; ，方法进行编码和解码Haskell的价值懒惰 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它镜像了 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类，以用于Haskell类型的文本表示，并且适用于通过网络将Haskell值序列化到磁盘上。</target>
        </trans-unit>
        <trans-unit id="359a7c862ec288bde5c781831027b2789d88d4e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class provides &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt;, methods to encode and decode a Haskell value to a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It mirrors the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; classes for textual representation of Haskell types, and is suitable for serialising Haskell values to disk, over the network.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类提供 &lt;code&gt;&lt;a href=&quot;data-binary#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; ，方法进行编码和解码Haskell的价值懒惰 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它镜像了 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类，以用于Haskell类型的文本表示，并且适用于通过网络将Haskell值序列化到磁盘上。</target>
        </trans-unit>
        <trans-unit id="fc3c4e321db0da5c60f5e57209330b5697cd8103" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad. A monad for efficiently building structures from encoded lazy ByteStrings.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 单子。用于从编码的惰性ByteString有效地构建结构的monad。</target>
        </trans-unit>
        <trans-unit id="4d3613093bfbb78cd7a2a16f8922cee7681b2bed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from left to right, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumL&quot;&gt;bimapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 的和 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; 它遍历从左至右，穿线型的状态的结构 &lt;code&gt;a&lt;/code&gt; 并使用给定的操作来计算结构的新元素。</target>
        </trans-unit>
        <trans-unit id="9a87ec27622ff13e398e24344f3a64ac0e1395d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 的和 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; ; 它从右到左遍历一个结构，对类型 &lt;code&gt;a&lt;/code&gt; 的状态进行线程化，并使用给定的动作为该结构计算新元素。</target>
        </trans-unit>
        <trans-unit id="8fde160a7fc5705892a4e1ea87c284f4780166ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;; it traverses a structure from right to left, threading a state of type &lt;code&gt;a&lt;/code&gt; and using the given actions to compute new elements for the structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapAccumR&quot;&gt;bimapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 的和 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; ; 它横穿结构从右到左，穿线型的状态 &lt;code&gt;a&lt;/code&gt; 并使用给定的操作来计算结构的新元素。</target>
        </trans-unit>
        <trans-unit id="48db54c46d3aa624ae5d297b1ebeb1fa3977d71b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; class defines bitwise operations over integral types.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 类定义按位在整数类型的操作。</target>
        </trans-unit>
        <trans-unit id="0ad9b411edb3c5e8c1b9471ab75ecc126a6721eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; class denotes types with a finite, fixed number of bits.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bits#t:FiniteBits&quot;&gt;FiniteBits&lt;/a&gt;&lt;/code&gt; 类表示具有有限的，固定数量的比特的类型。</target>
        </trans-unit>
        <trans-unit id="20817eeecc682279fcdb27f8168c9dc5e0bd900f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; type and related functions.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 类型和相关功能。</target>
        </trans-unit>
        <trans-unit id="0ac698df5fa5f3ca66ad118ffad20bf3b266295d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，并返回第一个元素的索引中满足谓词的字节串。</target>
        </trans-unit>
        <trans-unit id="a88a45076c0dfb13c7596a49a77c0da26a873595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="d89ae35b30db39f44c3fe60d6b3d04049f068a4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个字节串，并返回字节串的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="4ee4acaf8e9d95a9f5ef4c31e80b5ce11a67d031" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e617691064b9b4b87d847163f54ff7d363170a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将一个函数应用于ByteString的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="2ea34718a3c5162fce3eb666e6adf60a8a7d062c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于ByteString的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="fd51442d30fe2b55d7fe46723f9d58913d2aa41f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换它的行和列 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="c1aa92f924157b1d391e0c5573f2c097c3b5ec16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; itself is an IO action: you supply it with a buffer (as a pointer and length) and it will write data into the buffer. It returns a number indicating how many bytes were actually written (which can be &lt;code&gt;0&lt;/code&gt;). It also returns a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; which describes what comes next.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 本身是一个IO动作：你用缓冲液提供它（作为一个指针和长度）和将数据写入到缓冲器中。它返回一个数字，指示实际写入了多少个字节（可以为 &lt;code&gt;0&lt;/code&gt; ）。它还返回一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; ，描述下一步。</target>
        </trans-unit>
        <trans-unit id="ea2d270840cc8c9daa194a459da571d928cff274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 表示的字节的零长度序列。仅导出此功能以用于重写规则。否则使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77e9d20b09fe3cb5d3e34c82f2d34d8c4d1fbd52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 表示的字节的零长度序列。仅导出此功能以用于重写规则。否则使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dd19fcd92601ecabd679db17cd19a75a81c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; denoting a zero-length sequence of bytes. This function is only exported for use in rewriting rules. Use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 表示的字节的零长度序列。仅导出此功能以用于重写规则。否则使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02c6b6ed74cc07d8a8ef6b6a51e39f07fbdde207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">始终导致长度为零的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="386c97767c9a0e690099a424827f366fbf618180" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">始终导致零长度序列的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4a29465a0ac4c8f6fffb025991665c12b63f1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; pairing and mapping operators can be used with &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;(&amp;gt;*&amp;lt;)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;(&amp;gt;$&amp;lt;)&lt;/a&gt;&lt;/code&gt; 配对和映射运算符可以与用于 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdd16a4104dcd27da4c5d7c015155569458cf5d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">始终导致长度为零的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ca076d9cd96bbcd373168527623c2c7280cd67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; that always results in the zero-length sequence.</source>
          <target state="translated">始终导致零长度序列的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34fcdbaf6996fe7f65d389f0c0fdfc1f2f89c754" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，并返回第一个元素的索引中满足谓词的字节串。</target>
        </trans-unit>
        <trans-unit id="2808d77c990696b44b127af7d539f85921526158" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="3b2f3c13460a923ec70902424b286392ebcf4ee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个字节串，并返回字节串的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="011ecd68a05489bd1b20ac9d77a9cea0655b8352" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72cc5f08d56e30d247f072343ee4d0e1aa87e68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将一个函数应用于ByteString的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="c9e160c9ad7473babd1af40af00cbf0162bdef7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于ByteString的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="83f55a6f846dc49344b68895528bedee225f9b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换它的行和列 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="cfef4b206c70c32eec3092e778efb683d81d66b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; 功能是类似于 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; 功能，上字。</target>
        </trans-unit>
        <trans-unit id="1d758a0f563300419f025322f07bdf29baaf99ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，并返回第一个元素的索引中满足谓词的字节串。</target>
        </trans-unit>
        <trans-unit id="014ce90607c5489f1d18b6f1c446b9bba5ae0212" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndexEnd&quot;&gt;findIndexEnd&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the last element in the ByteString satisfying the predicate.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndexEnd&quot;&gt;findIndexEnd&lt;/a&gt;&lt;/code&gt; 功能需要一个谓语和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，返回的最后一个元素的索引中满足谓词的字节串。</target>
        </trans-unit>
        <trans-unit id="bc3fedbb007a3889a87db49cdfcce211f6dec12f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="11978bfbf1d81f38393dc6440b94501585d47dc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个字节串，并返回字节串的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="063223aebad86f89a99e6e89e5807a67aa057281" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de39eec2cad2fac68f9d8a352ebb2380e3936c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 和`点缀的的元件之间的该字节 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它类似于列表上的散布函数。</target>
        </trans-unit>
        <trans-unit id="6625add11fa1e445312d92a0c6788839896adacf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 和`点缀的的元件之间的该字节 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它类似于Lists上的散布函数。</target>
        </trans-unit>
        <trans-unit id="ca33e217cddf98a06cc4dd73bac5dae5740289e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and `intersperses' that byte between the elements of the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It is analogous to the intersperse function on Lists.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 和`点缀的的元件之间的该字节 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它类似于Lists上的散布函数。</target>
        </trans-unit>
        <trans-unit id="8b89a766d13b74128a8333abb002900f94b6b437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将一个函数应用于ByteString的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="c773ca1b34d782e061cf0d6996806a66376f97f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于ByteString的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="612dd81abb27b510de3a02ab1ed120cd76a9a6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换它的行和列 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="b02cc89d4861343dc4906429c0519e1e575b9b01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and returns the index of the first element in the ByteString satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，并返回第一个元素的索引中满足谓词的字节串。</target>
        </trans-unit>
        <trans-unit id="89e6612f1c49c256bb1909e6d5ea7235d2f56477" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="0683ca6fb89db86c531b2e317168c1b2a68d2259" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a ByteString and returns a list of ByteStrings such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个字节串，并返回字节串的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="7f63028123ecc27ee69e82bdcdeb63da564a6078" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9318a5a01ea45d555a0875fa484d9ff476c3e0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将一个函数应用于ByteString的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="e142671c8576be4ab4d32dbd1993a19bfee360ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a ByteString, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new ByteString.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于ByteString的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的ByteString。</target>
        </trans-unit>
        <trans-unit id="21e9a6162eb970619d9172486dd0b5106006c4bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换它的行和列 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="981ef85d841145750af6b8e72525229c75f0ae12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; function is analogous to the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; function, on words.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unwords&quot;&gt;unwords&lt;/a&gt;&lt;/code&gt; 功能是类似于 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:unlines&quot;&gt;unlines&lt;/a&gt;&lt;/code&gt; 功能，上字。</target>
        </trans-unit>
        <trans-unit id="70b1e8ad66966b19620f6916e96d89ef82853d69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class comprehends a fundamental primitive &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; for folding over constructor applications, say terms. This primitive can be instantiated in several ways to map over the immediate subterms of a term; see the &lt;code&gt;gmap&lt;/code&gt; combinators later in this class. Indeed, a generic programmer does not necessarily need to use the ingenious gfoldl primitive but rather the intuitive &lt;code&gt;gmap&lt;/code&gt; combinators. The &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; primitive is completed by means to query top-level constructors, to turn constructor representations into proper terms, and to list all possible datatype constructors. This completion allows us to serve generic programming scenarios like read, show, equality, term generation.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 类领悟一种基本的原始 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的折叠构造应用程序，说条款。可以通过几种方式实例化该原语，以映射术语的直接子项。请参阅本课程后面的 &lt;code&gt;gmap&lt;/code&gt; 组合器。实际上，通用程序员不一定需要使用巧妙的gfoldl原语，而需要使用直观的 &lt;code&gt;gmap&lt;/code&gt; 组合器。该 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 原语的手段查询顶级构造完成后，把构造表示分为适当的条款，并列出所有可能的数据类型构造。这样的完成使我们能够为通用编程方案提供服务，例如阅读，展示，相等性，术语生成。</target>
        </trans-unit>
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型有时被用来表示一个值，其是正确或错误; 按照惯例， &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数用于保存错误值，而 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数用于保存正确的值（助记符：&amp;ldquo; right&amp;rdquo;也表示&amp;ldquo; correct&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型表示的值与两种可能性：type的值 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 或者是 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类定义平等（ &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）和不等式（ &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ）。&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出的所有基本数据类型都是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例，并且 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 可以针对其组成也是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例的任何数据类型派生。</target>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 的情况下，首先遍历实部。</target>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和结构，并返回该结构的最左边的元素相匹配的谓词，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="1b7c06198a94e0e0bdce1efceb1fa1157608eeea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` method is a special case of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, in which the initial accumulator is &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; and the operator is &lt;code&gt;mappend . f&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; maps each input element into the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in question. Therefore, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is an appropriate choice under essentially the same conditions as &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;`, and its implementation for a given &lt;code&gt;Foldable&lt;/code&gt; structure should also be a strict left-associative reduction.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `方法是一个特殊情形 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; `，其中初始累积器是 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 并且操作者是 &lt;code&gt;mappend . f&lt;/code&gt; ，其中 &lt;code&gt;f&lt;/code&gt; 将每个输入元素映射到相关的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 中。因此，在与 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 基本上相同的条件下， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `是一个合适的选择，并且对于给定的 &lt;code&gt;Foldable&lt;/code&gt; 结构，它的实现也应严格地与左相关联。</target>
        </trans-unit>
        <trans-unit id="40cadb370f92894eea0177fbad74525b49368dd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; form works verbatim if the type of &lt;strong&gt;&lt;code&gt;mvalue&lt;/code&gt;&lt;/strong&gt; is later refactored from &lt;strong&gt;&lt;code&gt;Maybe a&lt;/code&gt;&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; (assuming it remains OK to silently do nothing in the error case).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 形式的作品，如果逐字的类型&lt;strong&gt; &lt;code&gt;mvalue&lt;/code&gt; &lt;/strong&gt;以后从重构&lt;strong&gt; &lt;code&gt;Maybe a&lt;/code&gt; &lt;/strong&gt;到&lt;strong&gt; &lt;code&gt;Either e a&lt;/code&gt; &lt;/strong&gt;（假设它仍然是OK默默做什么错误的情况下）。</target>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="4e16e1b415ac8aa1d79a0e8941de4b3fd089e939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; base class means that the container cannot impose any constraints on the element type, so containers that require elements to be comparable, or hashable, etc., cannot be instances of the &lt;code&gt;Traversable&lt;/code&gt; class.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 基类意味着容器不能强加在元件类型的任何限制，从而使需要的元件的容器是相当的，或可哈希等，不能作为实例 &lt;code&gt;Traversable&lt;/code&gt; 的类。</target>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">来自 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 将忽略 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值，但会将提供的函数应用于 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 中包含的值：</target>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 功能也可作为管道符 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 仿函数。</target>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; 类型是有限的邻接表表示，向图型的顶点 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 类型表示&lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;强连接分量&lt;/a&gt;的曲线图的。</target>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-strict&quot;&gt;mapMissing，&lt;/a&gt;则将在插入结果之前强制结果。如果您在此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则不会。</target>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您从此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则将在插入结果之前强制执行结果。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-lazy&quot;&gt;mapMissing，&lt;/a&gt;则不会。</target>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;Functor&lt;/code&gt; ， &lt;code&gt;Traversable&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="5d01cac285dd99db980e4e71910e5f17ef1269f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;Functor&lt;/code&gt; ， &lt;code&gt;Traversable&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="de110598e79367090ddf9a9502e16c3db920c1a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;Functor&lt;/code&gt; ， &lt;code&gt;Traversable&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="352aafc40cb132717ac79f053c1b34a159a6c7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="4df8970586f0c961dd4f430a41d51d650439ca67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在一个类型到整数映射值的连续子区间。它主要用于数组索引（请参阅数组包）。</target>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在类型值的连续的子范围映射到整数。它主要用于数组索引（请参阅数组包）。 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 使用行优先顺序。</target>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 功能列表差异（非关联）。根据 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; 的结果，依次将 &lt;code&gt;ys&lt;/code&gt; 的每个元素的第一次出现（如果有的话）从 &lt;code&gt;xs&lt;/code&gt; 中删除。从而</target>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和两个列表并移除所述第二列表中的每个元素的第一次出现返回第一个列表。</target>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 机能下降，其中给定的断言为所有元素的列表中最大的后缀。例如：</target>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回在给定列表的第一个元素的索引，其等于（由 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）到查询元件，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 功能延伸 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; ，通过返回所有元素的索引等于查询元件，按升序排列。</target>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 功能只 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 专门到列表单子：</target>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和结构，并返回该结构的最左边的元素相匹配的谓词，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和列表，并返回第一个元素的索引列表中的满足谓词，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为要素下降的数量。</target>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 功能的重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 数值作为索引。</target>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为重复数作出。</target>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 函数是的重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为在该分割的位置。</target>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为元素采取的数量。</target>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数接受一个列表，并返回列表的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有的初始段，第一最短。例如，</target>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 函数有两个列表清单交集。例如，</target>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一个名单载，完全和完整，第二个内的任何地方。</target>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果所有发生的第一个list的元素，为了在第二。元素不必连续出现。</target>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的后缀。第二个列表必须是有限的。</target>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将函数应用于结构的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="8dd53e15a4486e163e923e5edcb16e98edcfede4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将一个函数应用于结构的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于结构的每个元素，从右向左传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="58255312061a37b729a440f59df1d47f433cf4a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似; 它将一个函数应用于结构的每个元素，从右向左传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词的列表，并返回一对和不满足谓词，分别元素列表的; 即</target>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有排列的列表。</target>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 函数实现稳定的排序算法。这是 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 功能的非重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有子序列的列表。</target>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换其参数的行和列。例如，</target>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数是双重`&amp;rdquo;至 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：而 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似减小了列表的摘要值， &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 构建从种子值的列表。该函数接受元素，如果完成生成列表，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，或者返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是列表的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。例如，</target>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 函数返回两个列表名单工会。例如，</target>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 功能是非重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 功能需要四倍和回报四个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 函数采用的五元组，并返回五个列表，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 函数采用六元组，并返回6个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 函数采用的七元组，并返回7个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 函数有四个名单，并返回四倍的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 功能需要五个名单和返回的五元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 功能需要六个月名单和返回的六元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 功能需要七名名单和返回的七元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="808a6c884122f71311b11b7294556f8f16861f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 函数采用由三个元件，以及三个列表并返回施加到对应的元件，类似于功能的列表的功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它具有列表融合功能，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 函数采用结合了四个元件，以及四个列表并返回其逐点组合的列表，类似于一个函数 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 功能需要，结合五行，以及五个列表，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 功能需要，结合六大要素，以及6名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 功能需要它结合了七个要素，以及七名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; 功能相当于 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个流，并返回这样的流的列表的是平坦化结果列表是等于参数。此外，结果列表中的每个流仅包含相等的元素。例如，在列表符号中：</target>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数接受一个流 &lt;code&gt;xs&lt;/code&gt; 并返回所有的有限前缀 &lt;code&gt;xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果第一个参数是第二的前缀。</target>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的不平等测试。</target>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词 &lt;code&gt;p&lt;/code&gt; 和流 &lt;code&gt;xs&lt;/code&gt; ，并返回一个对列表。第一个列表对应于 &lt;code&gt;xs&lt;/code&gt; 的元素，其中 &lt;code&gt;p&lt;/code&gt; 成立；第二个对应于 &lt;code&gt;xs&lt;/code&gt; 的元素，其中 &lt;code&gt;p&lt;/code&gt; 不成立。</target>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数接受一个流 &lt;code&gt;xs&lt;/code&gt; 并返回所有的后缀 &lt;code&gt;xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数类似于&lt;a href=&quot;data-list&quot;&gt;Data.List模块&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 功能是逆 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 函数有两个流，并返回对应的对流。</target>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 功能概括 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。而不是组合元素，而是使用作为第一个参数传递的函数来组合元素。</target>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;k&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 是在其键严格的，但在它的值懒惰。</target>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-strict&quot;&gt;mapMissing，&lt;/a&gt;则将在插入结果之前强制结果。如果您在此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则不会。</target>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您从此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则将在插入结果之前强制执行结果。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-lazy&quot;&gt;mapMissing，&lt;/a&gt;则不会。</target>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;k&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 种类的懒惰和严格的模块之间共享，这意味着相同的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="80a0485ade9c643df5c2ea0bf0c47d55fb54166e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 种类的懒惰和严格的模块之间共享，这意味着相同的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="ff715be94759f4fe46e742d1184a2a615aa793fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 种类的懒惰和严格的模块之间共享，这意味着相同的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; 函数提取的元素出来的 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; ，如果它的参数是抛出一个错误 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e0e0ae5827a91039e8b0c00412d73abae7c014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值和一个 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值，并 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当它的参数是形式 &lt;code&gt;Just _&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果参数为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 空列表或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ，其中 &lt;code&gt;a&lt;/code&gt; 是列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 功能是一个版本 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ，可以扔出去的元素。特别是，函数参数返回类型 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt; 东西。如果为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则不会将任何元素添加到结果列表。如果它是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt; ，则 &lt;code&gt;b&lt;/code&gt; 包含在结果列表中。</target>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 的功能需要一个默认值，函数，和 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该函数返回默认值。否则，它将函数应用于 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 内的值并返回结果。</target>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数返回一个空列表，而给出 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，则返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; 半群由数值加法运算符和定义`0`为中性元素：</target>
        </trans-unit>
        <trans-unit id="7f108b74d9d0f499180865c6097577550b780ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。如果 &lt;code&gt;a&lt;/code&gt; 具有与之关联的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例，则比较由此包装的两个值将得到与它们正常排序顺序相反的结果。在按广义列表 &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 排序时，这特别有用，例如：then down by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类用于全序数据类型。</target>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例定义为始终选择较小的数字：&amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</target>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; 类型表示类型的值的有限序列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;e&lt;/code&gt; 。大多数操作都要求 &lt;code&gt;e&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类的实例。一 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 是在其元素严格。</target>
        </trans-unit>
        <trans-unit id="1038dcfb90af9b5c0cfcdb7ab1311da4e5ed3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;e&lt;/code&gt; 。大多数操作都要求 &lt;code&gt;e&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类的实例。一 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 是在其元素严格。</target>
        </trans-unit>
        <trans-unit id="c9efbd927cc3f3d70bf87d84d4a730da30c040e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;e&lt;/code&gt; 。大多数操作都要求 &lt;code&gt;e&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类的实例。一 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 是在其元素严格。</target>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型是使用不能保证在Haskell的堆的固定地址阵列实现。因此，所有与本机代码的通信都必须通过来回复制数据来进行。</target>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型的内部表现为UTF-16，使用平台的本机字节序。这使复制的数据适合与使用类似表示形式的本机库一起使用，例如ICU。要与使用不同内部表示形式的本机库（例如UTF-8或UTF-32）进行互操作，请考虑使用&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; 模块中的函数。</target>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和一个严格 &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 由于构造暴露 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 因为构造暴露 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 函数接受一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示一个可能不完整输入（例如，从网络流分组），其可以不是UTF-8边界结束。</target>
        </trans-unit>
        <trans-unit id="651e438c6d91bc7b186512f8dad01a122ee5eab0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 函数接受一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示一个可能不完整输入（例如，从网络流分组），其可以不是UTF-8边界结束。</target>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和流并返回第一个元素的索引满足谓词的信息流中。</target>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和流并返回第一个元素的索引满足谓词的信息流中。</target>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 码点。</target>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="translated">给定代码点的 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 功能需要类型的函数 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 作为其参数。来自标准输入设备的全部输入作为其参数传递给此函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。与 &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，严格读取整个文件。</target>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回的列表 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; S，从而使结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和一个严格 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 功能需要类型的函数 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入（作为参数）（延迟地）传递给此函数，结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将函数应用于结构的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于结构的每个元素，从右向左传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="37d7ebaf143b71c90e000c5e485da2fe61a5ea4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; methods are useful when what you have is a container of applicative or, respectively, monadic actions, and you want to evaluate them left-to-right to obtain a container of the computed values.</source>
          <target state="translated">当您拥有的是应用动作或单子动作的容器，并且您想要从左到右评估它们以获得计算值的容器时， &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 方法很有用。</target>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; 类型代表的森林 &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 类型代表一个懒惰的，可能是无限的，多路树（也被称为&lt;em&gt;玫瑰树&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 类按类型交涉类型相关联的类型具体化在一定程度上。可以对这些类型表示进行比较，然后可以依次定义一种类型安全的强制转换操作。为此，通过类型（表示）等效性测试来保护不安全的转换。&lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt;模块将Typeable用于动态实现。&lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt;模块使用Typeable和类型安全的强制转换（但不使用动态转换）来支持通用编程的&amp;ldquo;废话&amp;rdquo;样式。</target>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 函数输出给定的作为第一个参数，返回第二自变量作为其结果之前跟踪消息。</target>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 功能应&lt;em&gt;仅&lt;/em&gt;用于调试，或用于监测执行。该函数不是参照透明的：其类型表明它是纯函数，但具有输出跟踪消息的副作用。</target>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 功能消息输出到输出流。它们用于&amp;ldquo; printf调试&amp;rdquo;，即：跟踪执行流并打印有趣的值。</target>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 与该消息被发射到事件日志，事件日志，如果分析是可用的，并在运行时启用的差别。</target>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 分析可用并在运行时启用，则traceEventIO函数会向事件日志发出消息。</target>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 函数输出来自IO单子跟踪消息。这将根据其他IO动作对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; 功能发出一个标记，事件日志，事件日志，如果分析是可用的，并在运行时启用。该 &lt;code&gt;String&lt;/code&gt; 是标记的名称。该名称仅在分析工具中使用，以帮助您弄清楚哪个标记是哪个标记。</target>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 分析可用并在运行时启用，则traceMarkerIO函数将向事件日志发出标记。</target>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。该模块是外部功能接口（FFI）的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;外部&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。该模块是外部功能接口（FFI）的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;外部&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 功能投射的指针从一种类型到另一个。</target>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在一个类型到整数映射值的连续子区间。它主要用于数组索引（请参阅数组包）。</target>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; 与使用在所述关联列表中重复指数函数优惠&lt;em&gt;累积功能&lt;/em&gt;相结合的关联的值具有相同的索引。</target>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的功能是传统的单子连接操作。它用于删除单子结构的一个级别，将其绑定参数投射到外部级别。</target>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 操作允许（力，在一个合作多任务执行）一个上下文切换到任何其它目前可运行的线程（如果有的话），并实施并发抽象时是偶尔是有用的。</target>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 操作允许（力，在一个合作多任务执行）一个上下文切换到任何其它目前可运行的线程（如果有的话），并实施并发抽象时是偶尔是有用的。</target>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类用于命名的类型的上限和下限。 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 的超类，因为未完全排序的类型也可能具有上限和下限。</target>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类可衍生自任何枚举类型; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;data&lt;/code&gt; 声明中列出的第一个构造函数，而 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 是最后一个。 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 也可以导出单构造的数据类型，其构成类型在 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="5927fd518988da69d26cdf922ae3e2a15412bf75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。如果 &lt;code&gt;a&lt;/code&gt; 具有与之关联的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例，则比较由此包装的两个值将得到与它们正常排序顺序相反的结果。在按广义列表 &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 排序时，这特别有用，例如：then down by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; 类及其方法意在与OverloadedLists扩展一起使用。</target>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; 类型函数返回结构 &lt;code&gt;l&lt;/code&gt; 的项目类型。</target>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 函数构造结构 &lt;code&gt;l&lt;/code&gt; 从给定的清单 &lt;code&gt;Item l&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39677f8a87165f5afc7795359f53bb6627c8c811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length and potentially uses it to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given number does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 函数接受输入列表的长度和可能使用它来构造结构 &lt;code&gt;l&lt;/code&gt; 更有效地相比 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 。如果给定数字不等于输入列表的长度，则不指定 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 函数获取输入列表长度作为提示。它的行为应等效于 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 。与 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 相比，该提示可用于更有效地构造结构 &lt;code&gt;l&lt;/code&gt; 。如果给定的提示不等于输入列表的长度，则不指定 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; 函数使用用户提供的功能，其上这些预计元件由平等突出的元件每列表元素的以第一排序输入列表，然后以形成基团</target>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 功能性约束的严格分析一点点。调用 &lt;code&gt;lazy e&lt;/code&gt; 的含义与 &lt;code&gt;e&lt;/code&gt; 相同，但是就严格性分析而言， &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 具有神奇的性质：即使其语义严格，它的第一个参数也是惰性的。运行严格性分析后，内联到 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 的调用将成为身份功能。</target>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; 的功能可以被用来给出提示给编译器，它的参数将至多一次被调用，其可以（或可以不）使某些优化。以连续传递方式提高代码性能可能很有用。</target>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; 函数对使用用户提供的函数，项目东西元素的列表每个元素的</target>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数提取列表 &lt;code&gt;Item l&lt;/code&gt; 从结构 &lt;code&gt;l&lt;/code&gt; 。它应该满足fromList。toList = ID。</target>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; 调用指示该封闭部分是数据类型的第一和第二构造的表示 &lt;code&gt;Tree&lt;/code&gt; ，分别。在这里，有关构造函数名称，固定性以及是否具有命名字段的元信息在类型级别进行编码。该 &lt;code&gt;'MetaCons&lt;/code&gt; 类型也是类型的类的实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt; 。此类型类可用于在值级别获取有关构造函数的信息。</target>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; 标签指示包围的部分是数据类型的表示 &lt;code&gt;Tree&lt;/code&gt; 。同样，元信息是在类型级别上编码的。所述 &lt;code&gt;'MetaData&lt;/code&gt; 类型是类的实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt; ，这可以被用来获得一个数据类型的名字，它在被限定的模块，它位于下包，以及它是否已使用被定义 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 在价值水平。</target>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 类可以推广到范围在类型种 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; ，对于任何一种 &lt;code&gt;k&lt;/code&gt; 。为此，派生启用 &lt;code&gt;PolyKinds&lt;/code&gt; 扩展的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 实例。例如，声明</target>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)&lt;/code&gt; 标签指示几件事情。在 &lt;code&gt;'Nothing&lt;/code&gt; 表明存在与构造的这个领域相关的任何记录字段选择器（如果有的话，它会被标记为 &lt;code&gt;'Just &quot;recordName&quot;&lt;/code&gt; 代替）。其他类型包含有关字段严格性的元信息：</target>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; 用于构建 &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; S，并且指定他们如何处理非法的序列。</target>
        </trans-unit>
        <trans-unit id="71ec4fbd1cac8b401802c535c7f65214143acd87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 动作恢复它作为一个之前读取给定的手柄上的所有输入 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 和关闭句柄。</target>
        </trans-unit>
        <trans-unit id="787de66be7bec193d5479d5569e0c178f340123a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 动作恢复它作为一个之前读取给定的手柄上的所有输入 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 和关闭句柄。</target>
        </trans-unit>
        <trans-unit id="755de46cccecfaefa5e6388cdeaf72d6ecd06136" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在一个类型到整数映射值的连续子区间。它主要用于数组索引（请参阅数组包）。</target>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限清单的产品。</target>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限列表的总和。</target>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5514609ab8e7a4d1ade5d1bc201f6e65aae2801a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 函数采用由三个元件，以及三个列表并返回施加到对应的元件，类似于功能的列表的功能 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它具有列表融合功能，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 功能列表差异（非关联）。根据 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; 的结果，依次将 &lt;code&gt;ys&lt;/code&gt; 的每个元素的第一次出现（如果有的话）从 &lt;code&gt;xs&lt;/code&gt; 中删除。从而</target>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和两个列表并移除所述第二列表中的每个元素的第一次出现返回第一个列表。</target>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 机能下降，其中给定的断言为所有元素的列表中最大的后缀。例如：</target>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回在给定列表的第一个元素的索引，其等于（由 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）到查询元件，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 功能延伸 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; ，通过返回所有元素的索引等于查询元件，按升序排列。</target>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 功能需要一个谓语和一个列表，返回列表中的第一个元素相匹配的谓语，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果没有这样的元素。</target>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和列表，并返回第一个元素的索引列表中的满足谓词，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为要素下降的数量。</target>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 功能的重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 数值作为索引。</target>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为重复数作出。</target>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 函数是的重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为在该分割的位置。</target>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为元素采取的数量。</target>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数接受一个列表，并返回列表的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有的初始段，第一最短。例如，</target>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 函数有两个列表清单交集。例如，</target>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一个名单载，完全和完整，第二个内的任何地方。</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的后缀。第二个列表必须是有限的。</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它对列表的每个元素应用一个函数，从左到右传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将函数应用于列表的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; 功能需要一个比较函数和一个列表，并通过比较函数返回列表中的最大元素。该列表必须是有限且非空的。</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; 函数采用一个比较功能和列表，并通过比较函数返回列表的最小元素。该列表必须是有限且非空的。</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词的列表，并返回一对和不满足谓词，分别元素列表的; 即</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有排列的列表。</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限清单的产品。</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 函数实现稳定的排序算法。这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 功能的非重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有子序列的列表。</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限列表的总和。</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换其参数的行和列。例如，</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数是双重`&amp;rdquo;至 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：而 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似减小了列表的摘要值， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 构建从种子值的列表。该函数接受元素，如果完成生成列表，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，或者返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是列表的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。例如，</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 函数返回两个列表名单工会。例如，</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 功能是非重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 功能需要四倍和回报四个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 函数采用的五元组，并返回五个列表，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 函数采用六元组，并返回6个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 函数采用的七元组，并返回7个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 函数有四个名单，并返回四倍的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 功能需要五个名单和返回的五元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 功能需要六个月名单和返回的六元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 功能需要七名名单和返回的七元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="ebe2dcade01df40ba8567bc29c6d76d5179227b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 函数采用由三个元件，以及三个列表并返回施加到对应的元件，类似于功能的列表的功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它具有列表融合功能，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 函数采用结合了四个元件，以及四个列表并返回其逐点组合的列表，类似于一个函数 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 功能需要，结合五行，以及五个列表，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 功能需要，结合六大要素，以及6名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 功能需要它结合了七个要素，以及七名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 功能投射的指针从一种类型到另一个。</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">基本数据类型的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类和实例。</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类，以及相关业务。</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; 可用于查找指定 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7476e9e0f102360787454857433b298127a63a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; 类实现了最小的接口，该接口是必要的脱糖报价。</target>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 功能让你运行一个I / O运算在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。请注意：可以确保在单个 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 计算中对 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 的调用顺序，但不能保证运行拼接的顺序。</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 类型，值 &lt;code&gt;q&lt;/code&gt; 这种类型的可以在语法中使用 &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; 。实际上，为方便起见， &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 实际上定义了多个拟引用符，这些拟引用符可用于不同的剪接上下文中。如果你只在定义用于表达式quasiquoter兴趣的话，你会定义一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; ，并留下错误灭掉其他领域。</target>
        </trans-unit>
        <trans-unit id="312071dde460138e1108547da6f4f1b6fb25ee33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; class implements the minimal interface which is necessary for desugaring quotations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Quote&quot;&gt;Quote&lt;/a&gt;&lt;/code&gt; 类实现了最小的接口，该接口是必要的脱糖报价。</target>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 功能让你运行一个I / O运算在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。请注意：可以确保在单个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 计算中对 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 的调用顺序，但不能保证运行拼接的顺序。</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类用于命名的类型的上限和下限。 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 的超类，因为未完全排序的类型也可能具有上限和下限。</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类可衍生自任何枚举类型; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;data&lt;/code&gt; 声明中列出的第一个构造函数，而 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 是最后一个。 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 也可以导出单构造的数据类型，其构成类型在 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型有时被用来表示一个值，其是正确或错误; 按照惯例， &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数用于保存错误值，而 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数用于保存正确的值（助记符：&amp;ldquo; right&amp;rdquo;也表示&amp;ldquo; correct&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型表示的值与两种可能性：type的值 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 或者是 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类定义平等（ &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）和不等式（ &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ）。&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出的所有基本数据类型都是 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例，并且 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 可以针对其组成也是 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例的任何数据类型派生。</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取诸如 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例使我们可以将可能失败的多个动作链接在一起，如果任何单个步骤失败，则整体失败。首先，我们将编写一个可以从 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 解析 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 或失败的函数。</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类用于全序数据类型。</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">来自 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 将忽略 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值，但会将提供的函数应用于 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 中包含的值：</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 方法限制到类型 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入一个字符串，其被懒惰地读取，因为它需要（同 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="15b8f72cef1878abf7fe3c9117a25867af1d77b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入一个字符串，其被懒惰地读取，因为它需要（同 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 函数采用类型的函数 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入作为其参数传递给该函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 的功能需要一个默认值，函数，和 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值为 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该函数返回默认值。否则，它将函数应用于 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 内的值并返回结果。</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能输出任何可打印类型到标准输出设备的值。可打印类型是属于 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类的实例的那些类型； &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作将值转换为字符串以输出，并添加换行符。</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 功能从一个字符串，它必须由输入处理被完全消耗读取输入。如果解析不成功，则 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 失败并显示 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ，因此不建议在实际应用程序中使用它。使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 作为安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。像 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，按需延迟读取文件。</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 功能类似于 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 不同之处在于它用信号解析失败的 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子终止程序，而不是。</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 函数组合 &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 方法限制到类型 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="164c0899882615aec29723262627c2283ba64928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 函数采用由三个元件，以及三个列表并返回施加到对应的元件，类似于功能的列表的功能 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它具有列表融合功能，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 输入功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;getConsoleCP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d9c12dfa8f43bbbd8a126756fa99035e9751842" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 输入功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;getConsoleCP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4e61834da932da0adacdc02d3dfdbd2e02c1903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 输入功能（如 &lt;code&gt;&lt;a href=&quot;../base/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;getConsoleCP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; 单子变压器提供给用户的在线历史记录状态直接，低级别的访问。</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; 方法使我们能够&amp;ldquo;升降机&amp;rdquo;管理IO操作（如函数 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ）到一个函数，它包裹任意的一元操作。</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 独异抽象了所有填充和控制序列输出。不幸的是，该数据类型很难集成到现有的基于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的API（例如pretty-printer）中。因此，作为一种解决方法， &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 还允许我们以 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的形式访问控制序列。一个警告是，它不允许您将填充的控制序列作为字符串访问。例如：</target>
        </trans-unit>
        <trans-unit id="aa804a6c1292fd02b3dfa80191cff02ea40114ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 独异抽象了所有填充和控制序列输出。不幸的是，该数据类型很难集成到现有的基于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的API（例如pretty-printer）中。因此，作为一种解决方法， &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 还允许我们以 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的形式访问控制序列。一个警告是，它将不允许您以字符串形式访问带填充的控制序列。例如：</target>
        </trans-unit>
        <trans-unit id="9841931aa367ad9ec0fec011cdda76359ac86c24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 独异抽象了所有填充和控制序列输出。不幸的是，该数据类型很难集成到现有的基于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的API（例如pretty-printer）中。因此，作为一种解决方法， &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 还允许我们以 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的形式访问控制序列。一个警告是，它将不允许您以字符串形式访问带填充的控制序列。例如：</target>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; 常数是在CPU时间最小可测量的差异是，实现可以记录，并给出皮秒的整数倍。</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 类型是用来记录某些操作是否在一个文件/目录允许的。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 分别获取和设置这些权限。权限适用于文件和目录。对于目录，可执行字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，对于文件，可搜索字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。请注意，如果已允许使用目录作为路径的一部分，但不检查目录内容，则可以搜索目录而不可读。</target>
        </trans-unit>
        <trans-unit id="4d69896f050cda9242fbd0b11650fb1d4798c283" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 类型是用来记录某些操作是否在一个文件/目录允许的。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 分别获取和设置这些权限。权限适用于文件和目录。对于目录，可执行字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，对于文件，可搜索字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。请注意，如果已允许将目录用作路径的一部分，但不检查目录内容，则可以在不可读的情况下搜索目录。</target>
        </trans-unit>
        <trans-unit id="81b34c5c4fafcde21f795d5b394e5bb5a6d86701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 类型是用来记录某些操作是否在一个文件/目录允许的。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 分别获取和设置这些权限。权限适用于文件和目录。对于目录，可执行字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，对于文件，可搜索字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。请注意，如果已允许将目录用作路径的一部分，但不检查目录内容，则可以在不可读的情况下搜索目录。</target>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="6c024b37fca52e47d642918b547e5abf37fb3fa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="7508fdaba8c4fef16bb54aaa518032f06b07a40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 功能建立接收任何处理 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中所保护的作用提出 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 是由的异常处理功能，建立了一个最新的处理程序捕获。这些处理程序不是选择性的：捕获了所有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。必须通过重新引发任何不需要的异常，在处理程序中显式提供异常传播。例如，在</target>
        </trans-unit>
        <trans-unit id="6f3b229367a29bd9496f06fab85e58716c437cd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default value; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值和一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值，并 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="9769cc1036b71fdb3662c8da0daae0ce7bf97a68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值，并 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数返回一个空列表，而给出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，则返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="0fbaf05deefa3d41622751d07a352a608fb45d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数将返回一个空列表，而当给出 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，该函数将返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="98dbef89b986d97360e7b13124294962d761670e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数将返回一个空列表，而当给出 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，该函数将返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入一个字符串，其被懒惰地读取，因为它需要（同 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9903da760704cfbe9ebaf26276c9f6d1fe29b948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is fully read before being returned (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入作为一个单一的字符串，它被返回之前完全读（同 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e1624a7bf77b1533080ced7e88bbdc61480bcdf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; operation reads all input on the given handle before returning it as a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and closing the handle.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents-39-&quot;&gt;hGetContents'&lt;/a&gt;&lt;/code&gt; 动作恢复它作为一个之前读取给定的手柄上的所有输入 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 和关闭句柄。</target>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 函数采用类型的函数 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入作为其参数传递给该函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能输出任何可打印类型到标准输出设备的值。可打印类型是属于 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类的实例的那些类型； &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作将值转换为字符串以输出，并添加换行符。</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。像 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，按需延迟读取文件。</target>
        </trans-unit>
        <trans-unit id="a31c1b6bd7ac14eeefe46c3d60ed2cc1bc11f6d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile-39-&quot;&gt;readFile'&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is fully read before being returned, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readFile-39-&quot;&gt;readFile'&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。与 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents-39-&quot;&gt;getContents'&lt;/a&gt;&lt;/code&gt; 一样，文件在返回之前已被完全读取。</target>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 功能类似于 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 不同之处在于它用信号解析失败的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子终止程序，而不是。</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 函数组合 &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 功能建立接收任何处理 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中所保护的作用提出 &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 是由的异常处理功能，建立了一个最新的处理程序捕获。这些处理程序不是选择性的：捕获了所有 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。必须通过重新引发任何不需要的异常，在处理程序中显式提供异常传播。例如，在</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; 功能清除所有名称-值对的环境。</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 功能插入或重置当前环境列表中的环境变量名称。如果列表中不存在变量 &lt;code&gt;name&lt;/code&gt; ，则会使用给定值将其插入。如果变量确实存在，则测试参数 &lt;code&gt;overwrite&lt;/code&gt; ；否则，将测试参数覆盖。如果 &lt;code&gt;overwrite&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则不重置变量，否则将其重置为给定值。</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 函数删除从环境变量名的所有实例。</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 功能插入或重置当前环境列表中的环境变量名称。如果列表中不存在变量 &lt;code&gt;name&lt;/code&gt; ，则会使用给定值将其插入。如果变量确实存在，则测试参数 &lt;code&gt;overwrite&lt;/code&gt; ；否则，将测试参数覆盖。如果 &lt;code&gt;overwrite&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则不重置变量，否则将其重置为给定值。</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 函数删除从环境变量名的所有实例。</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 函数创建一对连接的文件描述符。第一个组件是要读取的fd，第二个组件是写端。尽管管道可能是双向的，但这种行为不是可移植的，为此，程序员应使用两个单独的管道。如果这是一个无效的描述符，可能会引发异常。</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 函数创建一对连接的文件描述符。第一个组件是要读取的fd，第二个组件是写端。尽管管道可能是双向的，但这种行为不是可移植的，为此，程序员应使用两个单独的管道。如果这是一个无效的描述符，可能会引发异常。</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; 类为可变参数魔法 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 。从模块中看不到它的实现。</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 类为可变参数神奇 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 。从模块中看不到它的实现。如果您尝试将不是此类的实例的类型的参数传递给 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; ，则编译器会将其报告为缺少的 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 功能从一个字符串，它必须由输入处理被完全消耗读取输入。如果解析不成功，则 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 失败并显示 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ，因此不建议在实际应用程序中使用它。使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 作为安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">第 &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; 个参数控制执行多少轮测试以确定&lt;em&gt;可能的素数&lt;/em&gt;。有关更多详细信息，请参见&lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;`mpz_probab_prime_p（）`的GMP文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;BigNat&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">该 &lt;code&gt;Bits&lt;/code&gt; 类没有一个 &lt;code&gt;Num&lt;/code&gt; 超。因此，对于 &lt;code&gt;bit&lt;/code&gt; ， &lt;code&gt;testBit&lt;/code&gt; 和 &lt;code&gt;popCount&lt;/code&gt; 方法，它没有默认方法。</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ByteString&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">的 &lt;code&gt;ByteString&lt;/code&gt; 类型和表示</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">该 &lt;code&gt;CApiFFI&lt;/code&gt; 扩展允许的调用约定 &lt;code&gt;capi&lt;/code&gt; 在国外报关使用，例如</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">的 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示被用来通知模式匹配检查了某种特定的图案是完全的，而且，其上的所有指定的模式匹配的任何功能是总。</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">例如， &lt;code&gt;CallStack&lt;/code&gt; 只能扩展到类型允许的范围内</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">在 &lt;code&gt;Chan&lt;/code&gt; 式</target>
        </trans-unit>
        <trans-unit id="d49e2d29e0d016b816ecb90ca81622c4424ea99a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Coercible&lt;/code&gt; machinery works with unlifted newtypes just like it does with lifted types. In either of the equivalent formulations of &lt;code&gt;A&lt;/code&gt; given above, users would additionally have access to a coercion between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Coercible&lt;/code&gt; 机械工程与未提升newtypes就像它与解除类型一样。在上述给定的 &lt;code&gt;A&lt;/code&gt; 的等效公式中，用户还可以访问 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;Int#&lt;/code&gt; 之间的强制。</target>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">XHTML 1.0严格的 &lt;code&gt;DOCTYPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Dynamic&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">该 &lt;code&gt;ErrorT&lt;/code&gt; 单子结构参数超过两件事情：</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">当您要求程序 &lt;code&gt;FOO&lt;/code&gt; 的堆概要文件时生成的 &lt;code&gt;FOO.hp&lt;/code&gt; 文件是具有特别简单结构的文本文件。这是一个有代表性的示例，其中省略了许多实际数据：</target>
        </trans-unit>
        <trans-unit id="141ca8f382c40e251a5df604ac774ed0428d094e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FieldName&lt;/code&gt; is open-ended, but typically it should contain the producing package name, along with the actual field name. Then, the version number can either be attached to the serialised data for that field, or in cases where multiple versions of a field could exist in the same interface file, included in the field name.</source>
          <target state="translated">该 &lt;code&gt;FieldName&lt;/code&gt; 是开放式的，但通常它应该包含生成包名，实际现场姓名。然后，可以将版本号附加到该字段的序列化数据上，或者在字段名称中包含的同一接口文件中可能存在一个字段的多个版本的情况下。</target>
        </trans-unit>
        <trans-unit id="04db3a4ce85cd545b2791b532c1d65a006beea18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; class makes it possible to use idioms familiar from the List type with container structures that are better suited to the task at hand. This allows a user to substitute more appropriate &lt;code&gt;Foldable&lt;/code&gt; data types for Lists without requiring new idioms (see &lt;a href=&quot;#uselistsnot&quot;&gt;[1]&lt;/a&gt; for when not to use lists).</source>
          <target state="translated">该 &lt;code&gt;Foldable&lt;/code&gt; 类可让您使用从容器结构的表型是在手更适合的任务熟悉的成语。这使用户可以使用更合适的 &lt;code&gt;Foldable&lt;/code&gt; 数据类型替换列表，而无需新的习惯用法（有关何时不使用列表的信息，请参见&lt;a href=&quot;#uselistsnot&quot;&gt;[1]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="46bbc9453d0aa157f0a481b32f1e12742cfde543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; instance should be defined in a manner that avoids construction of an unnecesary copy of the container.</source>
          <target state="translated">所述 &lt;code&gt;Foldable&lt;/code&gt; 实例应该以避免的容器的unnecesary复制结构的方式来定义。</target>
        </trans-unit>
        <trans-unit id="d3310324645be48c511e536603b07bcff55b712f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foldable&lt;/code&gt; method &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; and its flipped version &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; can be used to sequence IO actions over all the elements of a &lt;code&gt;Traversable&lt;/code&gt; container (just for their side-effects, ignoring any results) . One special case is a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; container that optionally holds a value. Given:</source>
          <target state="translated">该 &lt;code&gt;Foldable&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 及其翻转形式 &lt;code&gt;&lt;a href=&quot;data-foldable#v:forM_&quot;&gt;forM_&lt;/a&gt;&lt;/code&gt; 可用于在所有元素序列IO动作 &lt;code&gt;Traversable&lt;/code&gt; 的容器（只是它们的副作用，忽略任何结果）。一种特殊情况是 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 容器，该容器可选地包含一个值。鉴于：</target>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">所述 &lt;code&gt;Foo @k a = a&lt;/code&gt; 等式可表示为如下：</target>
        </trans-unit>
        <trans-unit id="4c4c7a176e62f2d3f87095896756c7aad5096548" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;../separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;Foo_stub.h&lt;/code&gt; 文件，可以使用重定向 &lt;code&gt;-stubdir&lt;/code&gt; 选项; 请参阅&lt;a href=&quot;../separate_compilation#options-output&quot;&gt;重定向编译输出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;Foo_stub.h&lt;/code&gt; 文件，可以使用重定向 &lt;code&gt;-stubdir&lt;/code&gt; 选项; 请参阅&lt;a href=&quot;separate_compilation#options-output&quot;&gt;重定向编译输出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">所述 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 环境变量可以被设置为一个 &lt;code&gt;:&lt;/code&gt; -分隔（ &lt;code&gt;;&lt;/code&gt; -分隔视窗上）包含数据库文件的列表。由GHC和ghc-pkg使用的软件包数据库列表从上到下指定了软件包数据库的堆栈。选择此顺序以匹配 &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 环境变量的行为，其中PATH中较早的条目会覆盖后面的条目。有关如何使用软件包数据库堆栈的详细信息，请参见&lt;a href=&quot;#package-databases&quot;&gt;软件包数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">该 &lt;code&gt;GenLanguageDef&lt;/code&gt; 类型是包含所有参数化特征的记录&lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;模块。模块&lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt;包含一些默认定义。</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;Generic1&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">的 &lt;code&gt;Generic&lt;/code&gt; 和 &lt;code&gt;Generic1&lt;/code&gt; 类用户定义的数据类型和它们的内部表示作为求和的产品之间进行调解：</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">该 &lt;code&gt;HSfoo.o&lt;/code&gt; 文件由卡瓦尔自动构建; 使用 &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; 将其禁用。要手动构建一个，可以使用以下GNU &lt;code&gt;ld&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">当使用FFI并通过C进行编译时， &lt;code&gt;INCLUDE&lt;/code&gt; 曾经是指定要包含的头文件所必需的。GHC不再需要INCLUDE，但是为了与其他编译器兼容，它被接受（并被忽略）。</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;INLINABLE&lt;/code&gt; 编译还与 &lt;code&gt;SPECIALISE&lt;/code&gt; ：如果您标记功能 &lt;code&gt;f&lt;/code&gt; 作为 &lt;code&gt;INLINABLE&lt;/code&gt; ，那么你就可以随后 &lt;code&gt;SPECIALISE&lt;/code&gt; 在另一模块（见&lt;a href=&quot;#specialize-pragma&quot;&gt;专门编译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b36c40931e360e8d5c5cef07a830cd7b25a1fd89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ImportQualifiedPost&lt;/code&gt; extension allows &lt;code&gt;qualified&lt;/code&gt; to appear in postpositive position : &lt;code&gt;import M qualified&lt;/code&gt;. With this extension enabled, one can write:</source>
          <target state="translated">该 &lt;code&gt;ImportQualifiedPost&lt;/code&gt; 扩展允许 &lt;code&gt;qualified&lt;/code&gt; 出现在后置位置： &lt;code&gt;import M qualified&lt;/code&gt; 。启用此扩展程序后，您可以编写：</target>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">该 &lt;code&gt;Int&lt;/code&gt; 可能修复 &lt;code&gt;b&lt;/code&gt; 在调用点，让签名应该不会被拒绝。此外，依赖项可能被隐藏。考虑</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Integer&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">的 &lt;code&gt;IsList&lt;/code&gt; 类及其方法意在与所述结合使用 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展。</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">在 &lt;code&gt;Ix&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">在 &lt;code&gt;Ix&lt;/code&gt; 类和操作</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">在 &lt;code&gt;Just Refl&lt;/code&gt; 情况下， &lt;code&gt;step2&lt;/code&gt; 是无法访问的，因为为了 &lt;code&gt;checkTEQ&lt;/code&gt; 能够产生 &lt;code&gt;Just&lt;/code&gt; ， &lt;code&gt;t ~ u&lt;/code&gt; 必须坚持，但因为我们传递 &lt;code&gt;Foo1&lt;/code&gt; 和 &lt;code&gt;Foo2&lt;/code&gt; 在这里，它遵循 &lt;code&gt;t ~ Char&lt;/code&gt; ，并且 &lt;code&gt;u ~ Int&lt;/code&gt; ，因此 &lt;code&gt;t ~ u&lt;/code&gt; 无法容纳。</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">该 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译允许语言扩展到一个可移植的方式来实现。意图是所有Haskell编译器都以相同的语法支持 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译指示，尽管当然并非所有编译器都支持所有扩展。该 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译应该用来代替 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; ，如果可能的话。</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">所述 &lt;code&gt;MArray&lt;/code&gt; 类在两个参数化 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; （使得专用于某些元件类型的实例可以被定义，以同样的方式作为用于 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; ），并且还通过单子的类型， &lt;code&gt;m&lt;/code&gt; ，其中，所述可变的阵列将是被操纵。</target>
        </trans-unit>
        <trans-unit id="c2c38f8bb84f00cd772ad558cf0397e189ff32c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;exts/pragmas#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示可用于该方法的组合将需要特定的类的实例的变化。参见&amp;ldquo;&lt;a href=&quot;exts/pragmas#minimal-pragma&quot;&gt;最小用法&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示可用于该方法的组合将需要特定的类的实例的变化。参见&lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;最小用法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">该 &lt;code&gt;MINIMAL&lt;/code&gt; 编译用于指定一个类的最小的完整定义，即指定哪些方法必须由所有实例来实现。如果实例不满足最小完整定义，则会生成警告。当类具有循环默认值的方法时，这将很有用。例如</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">该 &lt;code&gt;Maybe Dec&lt;/code&gt; 字段包含 &lt;code&gt;Just&lt;/code&gt; 其定义的变量的声明-包括声明的RHS -要不然 &lt;code&gt;Nothing&lt;/code&gt; ，在RHS不可用编译器的情况下。目前，此值&lt;em&gt;始终&lt;/em&gt; &lt;code&gt;Nothing&lt;/code&gt; ：由于缺乏兴趣，尚未执行返回RHS的操作。</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">该 &lt;code&gt;Maybe String&lt;/code&gt; 参数允许提供一个可选的时间规范。例如：</target>
        </trans-unit>
        <trans-unit id="1242be218ada359701dd67c2a646eb32b9e883ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MkG&lt;/code&gt; GADT constructor has two records, &lt;code&gt;unG1&lt;/code&gt; and &lt;code&gt;unG2&lt;/code&gt;. However, only &lt;code&gt;unG1&lt;/code&gt; can be used as a top-level field selector. &lt;code&gt;unG2&lt;/code&gt; cannot because it is a &amp;ldquo;hidden&amp;rdquo; selector (see &lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;); its type mentions a free variable &lt;code&gt;n&lt;/code&gt; that does not appear in the result type &lt;code&gt;G a (Maybe x)&lt;/code&gt;. On the other hand, the only free type variables in the type of &lt;code&gt;unG1&lt;/code&gt; are &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, so &lt;code&gt;unG1&lt;/code&gt; is fine to use as a top-level function.</source>
          <target state="translated">该 &lt;code&gt;MkG&lt;/code&gt; GADT构造函数有两个记录， &lt;code&gt;unG1&lt;/code&gt; 和 &lt;code&gt;unG2&lt;/code&gt; 。但是，只有 &lt;code&gt;unG1&lt;/code&gt; 可以用作顶级字段选择器。 &lt;code&gt;unG2&lt;/code&gt; 不能，因为它是一个&amp;ldquo;隐藏&amp;rdquo;的选择器（请参见&lt;a href=&quot;existential_quantification#existential-records&quot;&gt;Record Constructors&lt;/a&gt;）；它的类型提到一个自由变量 &lt;code&gt;n&lt;/code&gt; ，该变量没有出现在结果类型 &lt;code&gt;G a (Maybe x)&lt;/code&gt; 。另一方面， &lt;code&gt;unG1&lt;/code&gt; 类型中唯一的自由类型变量是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; ，因此可以将 &lt;code&gt;unG1&lt;/code&gt; 用作顶级函数。</target>
        </trans-unit>
        <trans-unit id="7cc66baaebfeab0512a0b98ea32973ef95be01d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModIface&lt;/code&gt; datatype also contains facilities for extending it with extra data, stored in a &lt;code&gt;Map&lt;/code&gt; of serialised fields, indexed by field names and using GHC&amp;rsquo;s internal &lt;code&gt;Binary&lt;/code&gt; class. The interface to work with these fields is:</source>
          <target state="translated">该 &lt;code&gt;ModIface&lt;/code&gt; 数据类型还包含额外的数据，存储在扩展它的设施 &lt;code&gt;Map&lt;/code&gt; 序列字段，通过字段名索引，使用GHC的内部 &lt;code&gt;Binary&lt;/code&gt; 类。使用这些字段的界面是：</target>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">该 &lt;code&gt;ModSummary&lt;/code&gt; 包含有关编译的模块有用的元信息。该 &lt;code&gt;HsParsedModule&lt;/code&gt; 包含了我们之前提到的词汇和句法信息。您返回的结果将更改解析的结果。如果您不想更改结果，只需返回作为参数接收的 &lt;code&gt;HsParsedModule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e5172db92414aea034dae74f377abfc598950a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad m&lt;/code&gt; superclass is needed to stitch together the different AST fragments.</source>
          <target state="translated">该 &lt;code&gt;Monad m&lt;/code&gt; 需要超缝合的不同AST片段连接在一起。</target>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Monad&lt;/code&gt; 类有一个 &lt;code&gt;Applicative&lt;/code&gt; 超。您不能编写适用于GHC的 &lt;code&gt;Monad&lt;/code&gt; 实例，也不能编写未定义 &lt;code&gt;Applicative&lt;/code&gt; 的Haskell 2010实现的实例。</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">该 &lt;code&gt;NOCLDSTOP&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">该 &lt;code&gt;NOINLINE&lt;/code&gt; 编译告诉GHC不在线 &lt;code&gt;foo&lt;/code&gt; ，直到0期; 并且此属性由专门化规则继承，因此将仅在阶段0触发。</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">该 &lt;code&gt;NOUNPACK&lt;/code&gt; 编译指示编译器，它不应该解压构造字段的内容。例：</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">在 &lt;code&gt;Natural&lt;/code&gt; 数类型</target>
        </trans-unit>
        <trans-unit id="8cad6ad0a7f69274a3358108b76be507fd692fa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; case is a right fold of the left subtree whose initial value is a right fold of the rest of the tree.</source>
          <target state="translated">该 &lt;code&gt;Node&lt;/code&gt; 的情况下是一个正确的折叠左子树，其初始值是右折树的其余部分的。</target>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">在 &lt;code&gt;Num&lt;/code&gt; 类没有 &lt;code&gt;Show&lt;/code&gt; 或 &lt;code&gt;Eq&lt;/code&gt; 超。</target>
        </trans-unit>
        <trans-unit id="47f8c2780da53550af283e3c4d79cd73d8a4eb47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;../using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">该 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译用来指定编译这个源文件时给出编译器的附加选项。有关详细信息，请参见&lt;a href=&quot;../using#source-file-options&quot;&gt;源文件中的命令行选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">该 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译用来指定编译这个源文件时给出编译器的附加选项。有关详细信息，请参见&lt;a href=&quot;using#source-file-options&quot;&gt;源文件中的命令行选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">该 &lt;code&gt;Plugin&lt;/code&gt; 类型具有一个场 &lt;code&gt;tcPlugin&lt;/code&gt; 类型的 &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; ，其中 &lt;code&gt;TcPlugin&lt;/code&gt; 类型这样定义：</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">所述 &lt;code&gt;PluginRecompile&lt;/code&gt; 数据类型是枚举确定所述插件应该如何影响重新编译。</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">该 &lt;code&gt;Pointer&lt;/code&gt; ，当标签说，这是不使用领域 &lt;code&gt;Nothing&lt;/code&gt; 。否则 &lt;code&gt;Pointer&lt;/code&gt; 指向 &lt;code&gt;Just&lt;/code&gt; 中的值。如上所述，这种类型在其提升领域是懒惰的。因此，类型</target>
        </trans-unit>
        <trans-unit id="6e89ab13d6b3312a22f1cb7af0a4c7b83065d7ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Q&lt;/code&gt; monad is a monad defined in &lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; which supports several useful operations during code generation such as reporting errors or looking up identifiers in the environment.</source>
          <target state="translated">该 &lt;code&gt;Q&lt;/code&gt; 单子是定义一个单子&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt;支持如报告错误，或者在环境中查找标识代码生成过程中的几个有用的操作。</target>
        </trans-unit>
        <trans-unit id="06c6b11868285014da3646f38b0333396538986f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Quote&lt;/code&gt; type class (&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax#t:Quote&quot;&gt;Language.Haskell.TH.Syntax.Quote&lt;/a&gt;) is the minimal interface necessary to implement the desugaring of quotations. The &lt;code&gt;Q&lt;/code&gt; monad is an instance of &lt;code&gt;Quote&lt;/code&gt; but contains many more operations which are not needed for defining quotations.</source>
          <target state="translated">所述 &lt;code&gt;Quote&lt;/code&gt; 类型的类（&lt;a href=&quot;../../libraries/template-haskell-2.17.0.0/language-haskell-th-syntax#t:Quote&quot;&gt;Language.Haskell.TH.Syntax.Quote&lt;/a&gt;）是实施报价的脱糖所必需的最少的接口。该 &lt;code&gt;Q&lt;/code&gt; 单子是一个实例 &lt;code&gt;Quote&lt;/code&gt; ，但包含了很多的一些并不需要定义报价更多的操作。</target>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="e93842ca545a852f968c15b8fc8e56550de74c3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;exts/rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类有两个额外的方法， &lt;code&gt;readPrec&lt;/code&gt; 和 &lt;code&gt;readListPrec&lt;/code&gt; ，未在Haskell的2010中，因为它们依赖于 &lt;code&gt;ReadPrec&lt;/code&gt; 数据类型，这就需要&lt;a href=&quot;exts/rank_polymorphism#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;扩展。 GHC也派生 &lt;code&gt;Read&lt;/code&gt; 通过实施实例 &lt;code&gt;readPrec&lt;/code&gt; 代替 &lt;code&gt;readsPrec&lt;/code&gt; ，并依靠的默认实现 &lt;code&gt;readsPrec&lt;/code&gt; 是在来定义 &lt;code&gt;readPrec&lt;/code&gt; 。 GHC添加了这两个额外的方法，仅仅是因为 &lt;code&gt;ReadPrec&lt;/code&gt; 比 &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; 所基于的类型）更有效。</target>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类有两个额外的方法， &lt;code&gt;readPrec&lt;/code&gt; 和 &lt;code&gt;readListPrec&lt;/code&gt; ，未在Haskell的2010中，因为它们依赖于 &lt;code&gt;ReadPrec&lt;/code&gt; 数据类型，这就需要&lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; &lt;/a&gt;扩展。GHC也派生 &lt;code&gt;Read&lt;/code&gt; 通过实施实例 &lt;code&gt;readPrec&lt;/code&gt; 代替 &lt;code&gt;readsPrec&lt;/code&gt; ，并依靠的默认实现 &lt;code&gt;readsPrec&lt;/code&gt; 是在来定义 &lt;code&gt;readPrec&lt;/code&gt; 。GHC添加了这两个额外的方法，仅是因为 &lt;code&gt;ReadPrec&lt;/code&gt; 比 &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; 所基于的类型）更有效。</target>
        </trans-unit>
        <trans-unit id="1bac9e36b9c420f9455517fb66bd240e808467c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类有两个额外的方法， &lt;code&gt;readPrec&lt;/code&gt; 和 &lt;code&gt;readListPrec&lt;/code&gt; ，未在Haskell的2010中，因为它们依赖于 &lt;code&gt;ReadPrec&lt;/code&gt; 数据类型，这就需要&lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;扩展。 GHC也派生 &lt;code&gt;Read&lt;/code&gt; 通过实施实例 &lt;code&gt;readPrec&lt;/code&gt; 代替 &lt;code&gt;readsPrec&lt;/code&gt; ，并依靠的默认实现 &lt;code&gt;readsPrec&lt;/code&gt; 是在来定义 &lt;code&gt;readPrec&lt;/code&gt; 。 GHC添加了这两个额外的方法，仅仅是因为 &lt;code&gt;ReadPrec&lt;/code&gt; 比 &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; 所基于的类型）更有效。</target>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ReadP&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">该 &lt;code&gt;Reader&lt;/code&gt; 单子（也称为环境单子）。表示一种计算，该计算可以从共享环境中读取值，在函数之间传递值，以及在修改后的环境中执行子计算。与使用 &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad 相比，使用 &lt;code&gt;Reader&lt;/code&gt; monad进行这样的计算通常更容易。</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">所述 &lt;code&gt;R{..}&lt;/code&gt; 扩展为 &lt;code&gt;R{a=a}&lt;/code&gt; ，省略 &lt;code&gt;b&lt;/code&gt; 由于记录字段不在范围内，并省略 &lt;code&gt;c&lt;/code&gt; 因为可变 &lt;code&gt;c&lt;/code&gt; 是在范围（除了记录选择的结合 &lt;code&gt;c&lt;/code&gt; ，当然）。</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">该 &lt;code&gt;SPARKS&lt;/code&gt; 统计指的是使用的 &lt;code&gt;Control.Parallel.par&lt;/code&gt; 及相关功能的程序。每一个火花都代表了对 &lt;code&gt;par&lt;/code&gt; 的呼唤; 当火花并行执行时，火花被&amp;ldquo;转换&amp;rdquo;；当发现火花已经被评估并且被垃圾收集器从池中丢弃时，火花被&amp;ldquo;修剪&amp;rdquo;。在执行结束时，将丢弃所有剩余的火花，因此&amp;ldquo;转换&amp;rdquo;加上&amp;ldquo;修剪&amp;rdquo;并不一定总和。</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">在 &lt;code&gt;ST&lt;/code&gt; 单子</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">在 &lt;code&gt;ST&lt;/code&gt; 单子</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">所述 &lt;code&gt;Semigroup&lt;/code&gt; 算子 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 将在 &lt;code&gt;Prelude&lt;/code&gt; ，其与这种操作者自定义局部定义相冲突</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ShortByteString&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">的 &lt;code&gt;ShortByteString&lt;/code&gt; 类型和表示</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;SomeException&lt;/code&gt; 类型是异常类型层级的根。当引发 &lt;code&gt;e&lt;/code&gt; 类型的异常时，它会在 &lt;code&gt;SomeException&lt;/code&gt; 封装在SomeException中。</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">该 &lt;code&gt;StablePtr&lt;/code&gt; 通过释放 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 。这是因为否则很难可靠地释放 &lt;code&gt;StablePtr&lt;/code&gt; ：我们无法在Haskell中释放它，因为如果 &lt;code&gt;takeMVar&lt;/code&gt; 被异步异常中断，则回调将在以后触发。我们无法在C中释放它，因为我们不知道何时释放它（不是 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 返回时，因为这是一个异步调用， &lt;code&gt;StablePtr&lt;/code&gt; 在将来的某个时间使用StablePtr）。</target>
        </trans-unit>
        <trans-unit id="93f61b2e2afac0b4f71ea13ddcca5d653fa2b424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StateT s m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; delegates to the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt;. The &lt;code&gt;acquire&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, and &lt;code&gt;release&lt;/code&gt; arguments given to &lt;code&gt;StateT&lt;/code&gt;'s implementation produce actions of type &lt;code&gt;StateT s m a&lt;/code&gt;, &lt;code&gt;StateT s m b&lt;/code&gt;, and &lt;code&gt;StateT s m c&lt;/code&gt;. In order to run those actions in the base monad, we need to call &lt;code&gt;runStateT&lt;/code&gt;, from which we obtain actions of type &lt;code&gt;m (a, s)&lt;/code&gt;, &lt;code&gt;m (b, s)&lt;/code&gt;, and &lt;code&gt;m (c, s)&lt;/code&gt;. Since each action produces the next state, it is important to feed the state produced by the previous action to the next action.</source>
          <target state="translated">该 &lt;code&gt;StateT s m&lt;/code&gt; 实施 &lt;code&gt;generalBracket&lt;/code&gt; 委托给 &lt;code&gt;m&lt;/code&gt; 实施 &lt;code&gt;generalBracket&lt;/code&gt; 。赋予 &lt;code&gt;StateT&lt;/code&gt; 实现的 &lt;code&gt;acquire&lt;/code&gt; ， &lt;code&gt;use&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 参数会产生 &lt;code&gt;StateT s m a&lt;/code&gt; ， &lt;code&gt;StateT s m b&lt;/code&gt; 和 &lt;code&gt;StateT s m c&lt;/code&gt; 类型的动作。为了在基本monad中运行这些动作，我们需要调用 &lt;code&gt;runStateT&lt;/code&gt; ，从中获取类型为 &lt;code&gt;m (a, s)&lt;/code&gt; ， &lt;code&gt;m (b, s)&lt;/code&gt; 和 &lt;code&gt;m (c, s)&lt;/code&gt; 。由于每个动作都会产生下一个状态，因此将上一个动作所产生的状态馈送到下一个动作是很重要的。</target>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">该 &lt;code&gt;String&lt;/code&gt; 类型和相关的操作。</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;Traversable&lt;/code&gt; 的类</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Tree&lt;/code&gt; 的数据类型有两个构造。使用二进制类型的构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 组合各个构造函数的表示形式。</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Type&lt;/code&gt; 字段包含作为变量基础的类型。目前，它始终是 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; ，但是将来的更改可能允许对此进行改进。</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Type&lt;/code&gt; 字段包含作为变量基础的类型。目前，它始终是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; ，但是将来的更改可能允许对此进行改进。</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">该 &lt;code&gt;UNPACK&lt;/code&gt; 指示编译器，它应该解压构造域的内容到构造本身，消除了一个间接层。例如：</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Version&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;WARNING&lt;/code&gt; 编译指示可以将任意警告附加到特定的函数，类或类型。</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Weak&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">在 &lt;code&gt;[2]&lt;/code&gt; 的装置，该规则是在第2阶段和后续阶段的活性。逆符号 &lt;code&gt;[~2]&lt;/code&gt; 也被接受，表示规则在阶段2之前（但不包括阶段2）一直有效。</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">的 &lt;code&gt;binary&lt;/code&gt; 包是显着的，因为它提供两个纯的，并且高性能串行化。</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">该 &lt;code&gt;buildExpressionParser&lt;/code&gt; 需要的所有参与建设的表达式解析器的复杂性照顾。这是处理前缀符号，后缀增量和基本算术的表达式解析器的示例。</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">在 &lt;code&gt;catch&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">的 &lt;code&gt;cr&lt;/code&gt; 能力，这将光标移动到当前行的第一列中。</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">该 &lt;code&gt;deriving( Sizable )&lt;/code&gt; 相当于说</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">所述 &lt;code&gt;encode&lt;/code&gt; 函数转换缓冲器的元件 &lt;code&gt;from&lt;/code&gt; 所述缓冲器 &lt;code&gt;to&lt;/code&gt; 。应该翻译为许多元素尽可能给出的缓冲区的大小，包括翻译零个元素，如果有或者没有足够的空间 &lt;code&gt;to&lt;/code&gt; ，或 &lt;code&gt;from&lt;/code&gt; 不包含一个完整的多字节序列。</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">该 &lt;code&gt;enumFrom&lt;/code&gt; ...方法在Haskell的等差数列的翻译使用。</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">除通常的错误消息外，Prelude中的 &lt;code&gt;error&lt;/code&gt; 功能还支持打印导致错误的调用堆栈：</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">该 &lt;code&gt;evaluate&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="2fbc5531096df720b55b588e7e44b2f7fb05c108" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forall&lt;/code&gt;-or-nothing rule takes effect in the following places:</source>
          <target state="translated">在 &lt;code&gt;forall&lt;/code&gt; -或全无的规则在以下几个地方的效果：</target>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">当转换为 &lt;code&gt;Int&lt;/code&gt; 时， &lt;code&gt;fromInteger&lt;/code&gt; （因此也来自 &lt;code&gt;fromIntegral&lt;/code&gt; ）是一种特殊情况。 &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; 的值是通过取 &lt;code&gt;(abs x)&lt;/code&gt; 的低⟨n⟩位乘以 &lt;code&gt;x&lt;/code&gt; 的符号（在2的补码⟨n⟩位算术中）得出的。选择此行为的原因是，例如，写入 &lt;code&gt;0xffffffff :: Int&lt;/code&gt; 保留结果 &lt;code&gt;Int&lt;/code&gt; 中的位模式。</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">当在大小较大的整数类型（ &lt;code&gt;Int8&lt;/code&gt; ， &lt;code&gt;Int16&lt;/code&gt; ， &lt;code&gt;Int32&lt;/code&gt; ， &lt;code&gt;Int64&lt;/code&gt; 和无符号 &lt;code&gt;Word&lt;/code&gt; 变体）之间进行转换时， &lt;code&gt;fromIntegral&lt;/code&gt; 函数还保留位模式，请参见库文档中的 &lt;code&gt;Data.Int&lt;/code&gt; 和 &lt;code&gt;Data.Word&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">该 &lt;code&gt;ghc-pkg&lt;/code&gt; 程序可以在下面列出的方式运行。在需要软件包名称的情况下，可以使用包含版本号（例如 &lt;code&gt;network-1.0&lt;/code&gt; ）的完整名称，也可以不使用版本号。命名没有版本号的软件包会匹配该软件包的所有版本。指定的操作将应用于所有匹配的软件包。也可以将与所有版本的软件包都匹配的软件包说明符写为 &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; ，以使多个软件包可以被更清楚地匹配。要与已安装的软件包ID匹配，而不仅仅是软件包名称和版本，请传递 &lt;code&gt;--ipid&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">该 &lt;code&gt;ghc&lt;/code&gt; 包自曝GHC的前端的最给用户，从而允许你写的程序，充分利用它。该库实际上与GHC的内部前端编译驱动程序使用的库相同，因此，您可以编写以编程方式编译源代码并对其进行检查的工具。为了编写诸如IDE或重构工具之类的东西，此类功能很有用。举一个简单的例子，这是一个编译模块的程序，就像ghc本身在调用时默认情况下一样：</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">该 &lt;code&gt;ghci.conf&lt;/code&gt; 文件是打开的首选项（例如，最有用的 &lt;code&gt;:set +s&lt;/code&gt; ），并定义有用的宏。</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">该 &lt;code&gt;handle&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">通过编译 &lt;code&gt;hs-boot&lt;/code&gt; 文件生成的 &lt;code&gt;hi-boot&lt;/code&gt; 与任何其他GHC生成的接口文件（例如 &lt;code&gt;B.hi&lt;/code&gt; ）具有相同的机器生成的二进制格式。您可以使用 &lt;code&gt;ghc --show-iface&lt;/code&gt; 显示其内容。如果为接口文件指定目录，则使用 &lt;code&gt;-ohidir&lt;/code&gt; 标志，这也会影响 &lt;code&gt;hi-boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">该 &lt;code&gt;hsc2hs&lt;/code&gt; 命令可以被用来自动编写的Haskell绑定到C代码的过程的某些部分。它读取具有嵌入式特殊结构的几乎Haskell的源，并基于从某些C头获取的信息，输出处理了这些结构的真实Haskell文件。额外的构造处理从Haskell访问C数据。</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">的 &lt;code&gt;i2d&lt;/code&gt; 功能实际上是一个机器指令; 相比之下，通过中间 &lt;code&gt;Rational&lt;/code&gt; 进行默认转换的成本非常高。</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 在上市成本中心的 &lt;code&gt;cost_centres&lt;/code&gt; 名单。</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">从技术上讲，模块 &lt;code&gt;B&lt;/code&gt; 中的 &lt;code&gt;import A hiding( g )&lt;/code&gt; 是一个错误（&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report，5.3.1&lt;/a&gt;），因为 &lt;code&gt;A&lt;/code&gt; 不导出 &lt;code&gt;g&lt;/code&gt; 。但是，GHC允许这样做，以支持向后兼容；例如，较新版本的 &lt;code&gt;A&lt;/code&gt; 可能会导出 &lt;code&gt;g&lt;/code&gt; ，并且您希望 &lt;code&gt;B&lt;/code&gt; 在两种情况下均能正常工作。</target>
        </trans-unit>
        <trans-unit id="d6ee2a5c41770c7a1baf9d025dcbc42759f0fdd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">从技术上讲，模块 &lt;code&gt;B&lt;/code&gt; 中的 &lt;code&gt;import A hiding( g )&lt;/code&gt; 是错误（&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report，5.3.1&lt;/a&gt;），因为 &lt;code&gt;A&lt;/code&gt; 不导出 &lt;code&gt;g&lt;/code&gt; 。但是，GHC允许这样做，以支持向后兼容；例如，较新版本的 &lt;code&gt;A&lt;/code&gt; 可能会导出 &lt;code&gt;g&lt;/code&gt; ，并且您希望 &lt;code&gt;B&lt;/code&gt; 在两种情况下均能正常工作。</target>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;import&lt;/code&gt; 报关（&lt;a href=&quot;#ghci-import-decl&quot;&gt;控制的是与进口范围&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">该 &lt;code&gt;instance&lt;/code&gt; 关键字是可选的。</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;lazyIOExample&lt;/code&gt; 使用懒惰的I / O，以从磁盘读取，它不适合所有应用程序中的文件，当然不是，如果你需要从具有较高可能性不能套接字阅读。为了满足这些需求，请使用增量输入方法（如 &lt;code&gt;incrementalExample&lt;/code&gt; )。有关如何从Handle中进行增量读取的示例，请参见 &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">该 &lt;code&gt;mapException&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;mask_&lt;/code&gt; 是为了避免之前异步异常 &lt;code&gt;scheduleCallback&lt;/code&gt; 通话，这将泄漏 &lt;code&gt;StablePtr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">该 &lt;code&gt;mdo&lt;/code&gt; 符号删除将明确的负担 &lt;code&gt;rec&lt;/code&gt; 模块中的代码。与普通的 &lt;code&gt;do&lt;/code&gt; 表达式不同，在普通的do表达式中，语句绑定的变量仅在以后的语句的范围内，而 &lt;code&gt;mdo&lt;/code&gt; 表达式中绑定的变量在该表达式的所有语句的范围内。然后，编译器自动识别最小的相互递归相关的语句段，将它们视为用户已将 &lt;code&gt;rec&lt;/code&gt; 限定符环绕在它们周围。</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">机 &lt;code&gt;needle&lt;/code&gt; 参数不能为空。</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">的 &lt;code&gt;nel&lt;/code&gt; 能力，这将光标移动到下一行的第一列中。它的行为就像回车符，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">所述 &lt;code&gt;nubIntOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。例如， &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 可用于有效地对字符和典型的固定数字类型进行小数处理。</target>
        </trans-unit>
        <trans-unit id="238764eaf45a1a62c1753a2837a1022054e829ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">所述 &lt;code&gt;nubIntOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。例如， &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.14.1.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 可用于有效地对字符和典型的固定数字类型进行小数处理。</target>
        </trans-unit>
        <trans-unit id="0766c52e5da98e96b097f0b2e8a0cc9028ac4ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.15.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">所述 &lt;code&gt;nubIntOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。例如， &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.15.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 可用于有效地对字符和典型的固定数字类型进行小数处理。</target>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">所述 &lt;code&gt;nubOrdOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50f7df8b96731582ad5998e199bcd7caa6862256" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ef6fce0bb77b22860c0010c07608d5a890578fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bd6ba4c2792acbb3c2aab713f7ac895331441da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373d721989cc654150bbf0bfb255a4af1891905b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b92d866131bfc652b2f085c78ccedd7098e50a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c77efcf307eb6a39e1b4f69936ca978bcecf7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09ce2ccedbe6bd5ac1d94120db777fbb8337511f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d2e43e335cb4eb09e7735f3bdddf48bef57b356" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52a6515b2ab89354c9fee21d1ff0883f508eeed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c215bc0ca5c8d4414abd0c0e1f3423af0982dbdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">用于显式双向构造的 &lt;code&gt;pat_lhs&lt;/code&gt; 不能使用Record语法。（因为rhs &lt;em&gt;expr&lt;/em&gt;可能构造了不同的数据构造函数。）它可以使用带有多个方程式的守卫。</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">该 &lt;code&gt;qq&lt;/code&gt; quasiquoter将能够看到的定义 &lt;code&gt;f&lt;/code&gt; 从前面的声明组，但不定义 &lt;code&gt;h&lt;/code&gt; 或 &lt;code&gt;k&lt;/code&gt; ，或从随后的宣言基团的任何定义。</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">的 &lt;code&gt;recover&lt;/code&gt; 功能被用于继续无效或不可表示的序列的存在进行解码。这既包括通过 &lt;code&gt;encode&lt;/code&gt; 返回 &lt;code&gt;InvalidSequence&lt;/code&gt; 所检测到的那些，也包括由于输入字节序列似乎被截断而发生的那些。</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">该 &lt;code&gt;return&lt;/code&gt; 功能只需创建一个其传递的价值延续。</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">该 &lt;code&gt;runghc&lt;/code&gt; 命令行的样子：</target>
        </trans-unit>
        <trans-unit id="cebfe6013064a220b5cba39faaac05a83ca046c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">所述 &lt;code&gt;self&lt;/code&gt; 式从外部隐藏; 任何企图申请 &lt;code&gt;_this&lt;/code&gt; ， &lt;code&gt;_inc&lt;/code&gt; 或 &lt;code&gt;_display&lt;/code&gt; 的功能将引发编译时错误。换句话说，&lt;em&gt;GHC仅针对其类型未提及存在量化变量的字段定义记录选择器函数&lt;/em&gt;。（此示例在字段中使用了下划线，但将不会为其定义记录选择器，但这只是编程风格； GHC会忽略它们。）</target>
        </trans-unit>
        <trans-unit id="51e3f0a426cb551b465e32dbdd47361e262cdb1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sequenceA&lt;/code&gt; and &lt;code&gt;sequence&lt;/code&gt; methods</source>
          <target state="translated">该 &lt;code&gt;sequenceA&lt;/code&gt; 和 &lt;code&gt;sequence&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">该 &lt;code&gt;shows&lt;/code&gt; 功能返回预先将输出的函数 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到现有的 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。这允许使用函数组合进行时间常数的级联。</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">该 &lt;code&gt;shows&lt;/code&gt; 功能返回预先将输出的函数 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到现有的 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。这允许使用函数组合进行时间常数的级联。</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">的 &lt;code&gt;sprint&lt;/code&gt; 功能在任何印刷值的末尾添加一个感叹号。使用以下命令运行GHCi：</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">该 &lt;code&gt;state hack&lt;/code&gt; 优化可以导致评价排序不明显的变化，这可能隐藏例外，甚至&lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt;（见，例如，&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;发出＃7411&lt;/a&gt;）。例如，</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;template-haskell&lt;/code&gt; 库提供 &lt;code&gt;Lift&lt;/code&gt; 情况下，对许多常见的数据类型。此外，可以使用&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;语言扩展自动导出 &lt;code&gt;Lift&lt;/code&gt; 实例。有关更多信息，请参见&lt;a href=&quot;#deriving-lift&quot;&gt;派生Lift实例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc491cbafae8602aedcf7deb49e4b74f8a072567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;deriving_extra#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;deriving_extra#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;template-haskell&lt;/code&gt; 库提供 &lt;code&gt;Lift&lt;/code&gt; 情况下，对许多常见的数据类型。此外，可以使用&lt;a href=&quot;deriving_extra#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;语言扩展自动导出 &lt;code&gt;Lift&lt;/code&gt; 实例。有关更多信息，请参见&lt;a href=&quot;deriving_extra#deriving-lift&quot;&gt;派生Lift实例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="979881d56bf63876025a9e6ac559a5d09f689295" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toList&lt;/code&gt; function below lazily transforms a &lt;code&gt;Foldable&lt;/code&gt; structure to a List. Note that this transformation may be lossy, e.g. for a keyed container (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &amp;hellip;) the output stream holds only the values, not the keys. Lossless transformations to/from lists of &lt;code&gt;(key,
 value)&lt;/code&gt; pairs are typically available in the modules for the specific container types.</source>
          <target state="translated">下面的 &lt;code&gt;toList&lt;/code&gt; 函数将 &lt;code&gt;Foldable&lt;/code&gt; 结构懒惰地转换为List。请注意，此转换可能是有损的，例如，对于键控容器（ &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;HashMap&lt;/code&gt; &amp;hellip;），输出流仅包含值，而不包含键。到/从 &lt;code&gt;(key, value)&lt;/code&gt; 对列表的无损转换通常在特定容器类型的模块中可用。</target>
        </trans-unit>
        <trans-unit id="8cedaf35635e98aff14e2be2770e441c0a4ccd4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transformers&lt;/code&gt;-style monad transfomer</source>
          <target state="translated">该 &lt;code&gt;transformers&lt;/code&gt; 式的单子变差动</target>
        </trans-unit>
        <trans-unit id="4db916f09ae9ad82e1c17b85b42a3e324b1b316a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;traverse&lt;/code&gt; and &lt;code&gt;mapM&lt;/code&gt; methods</source>
          <target state="translated">在 &lt;code&gt;traverse&lt;/code&gt; 和 &lt;code&gt;mapM&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 组合子可以例如用于区分标识符和保留字。保留字和标识符都是字母序列。每当我们期望某个保留字，也希望标识符的时候，我们都必须使用 &lt;code&gt;try&lt;/code&gt; 组合器。假设我们写：</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">该 &lt;code&gt;type role&lt;/code&gt; （启用&lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;）申报力参数 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，而不是角色幻象。然后，GHC会检查用户提供的角色，以确保它们不会违反任何承诺。例如，如果用户可以使 &lt;code&gt;BadIdea&lt;/code&gt; 的角色具有代表性，那将是不好的。</target>
        </trans-unit>
        <trans-unit id="3ab97fc80353826963fc8f16937897a7d19ff2bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;rsquo;s role be representational.</source>
          <target state="translated">该 &lt;code&gt;type role&lt;/code&gt; （启用&lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;）申报力参数 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，而不是角色幻象。然后，GHC会检查用户提供的角色，以确保它们不会违反任何承诺。例如，如果用户可以使 &lt;code&gt;BadIdea&lt;/code&gt; 的角色具有代表性，那将是不好的。</target>
        </trans-unit>
        <trans-unit id="bbd3777e534f72ef4343d8ae216222c351c56937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;u&lt;/code&gt; 语句使用 &lt;code&gt;(M.&amp;gt;&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4bd8ddd7070927041be90584a981f460d98709" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x &amp;lt;- u&lt;/code&gt; statement uses &lt;code&gt;(M.&amp;gt;&amp;gt;=)&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;x &amp;lt;- u&lt;/code&gt; 语句使用 &lt;code&gt;(M.&amp;gt;&amp;gt;=)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="163ed70634e5daf67472449520f0d0d1c209a86f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 编译只用在 &lt;code&gt;import&lt;/code&gt; 报关，打破模块循环。&lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中&lt;/a&gt;对此进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 编译只用在 &lt;code&gt;import&lt;/code&gt; 报关，打破模块循环。&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中&lt;/a&gt;对此进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="1c4e367df2b1b94e86aa02176ef763523fb3307a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; annotation must be written in prefix form:</source>
          <target state="translated">在 &lt;code&gt;~&lt;/code&gt; 注释必须写在前缀形式：</target>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">GHC安装随附的&lt;em&gt;全局软件包数据库&lt;/em&gt;，例如 &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">该&lt;em&gt;交互选项&lt;/em&gt;评估在GHCI提示符下输入表达式和命令时适用。</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">第&lt;em&gt;k&lt;/em&gt;个匹配项，后跟字符串的其余部分</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">该&lt;em&gt;加载选项&lt;/em&gt;加载模块时适用</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">每个用户专用的&lt;em&gt;用户软件包数据库&lt;/em&gt;。在Unix系统上，这将是 &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; ，而在Windows上，它将是 &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; 。该 &lt;code&gt;ghc-pkg&lt;/code&gt; 工具知道在哪里这个文件应该被定位，如果不存在，将创建它（请参阅&lt;a href=&quot;#package-management&quot;&gt;包管理（GHC的-PKG命令）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4df33777d071258dc6c9c7cc4bf4b2806b728297" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; type could be further extended with instances of &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;, etc., and could then provide a fully-featured list type, optimised for reuse without space-leaks. If, however, all that's required is space-efficient, re-use friendly iteration, less is perhaps more, and just &lt;code&gt;Foldable&lt;/code&gt; may be sufficient.</source>
          <target state="translated">所述&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;类型可以与实例被进一步扩展 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; ，等等，然后可以提供一个全功能的列表类型，没有空间的泄漏进行再利用优化。但是，如果所需的全部都是节省空间的，可重复使用的友好迭代，则更少可能更多，而仅 &lt;code&gt;Foldable&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="941913194462867445681166d58a9caadf6e06c1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; list structure works as an efficient iterator when used just once. When space-leaks via list reuse are not a concern, and/or memoisation is actually desirable, the regular list implementation is likely to be faster. This is not a suggestion to replace all your uses of &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; with a generative alternative.</source>
          <target state="translated">仅使用一次时，&lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt;列表结构可作为有效的迭代器。当不关心通过列表重用而导致的空间泄漏和/或实际上需要记忆时，常规列表实现可能会更快。这不是建议将您对&lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; 的&lt;/strong&gt;所有使用替换为生成性替代。</target>
        </trans-unit>
        <trans-unit id="c7e1c7ee8fcc39fc1932af678408736014433965" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;code&gt;unFR&lt;/code&gt;&lt;/strong&gt; field of this type is essentially its &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; method with the list as its first rather than last argument. Thus we immediately get a &lt;code&gt;Foldable&lt;/code&gt; instance (and a &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function mapping an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; to a regular list).</source>
          <target state="translated">这种类型的&lt;strong&gt; &lt;code&gt;unFR&lt;/code&gt; &lt;/strong&gt;字段本质上是其 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 方法，该方法将列表作为第一个参数而不是最后一个参数。因此，我们立即得到一个 &lt;code&gt;Foldable&lt;/code&gt; 实例（和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数映射的&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;到正规的列表）。</target>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">的&lt;strong&gt;GHC-PKG&lt;/strong&gt;工具是用于查询和修改包数据库。要查看正在使用的软件包数据库，请使用 &lt;code&gt;ghc-pkg list&lt;/code&gt; 。可以使用&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt;环境变量来修改&lt;strong&gt;ghc-pkg&lt;/strong&gt;知道的数据库堆栈（请参阅&lt;a href=&quot;#ghc-package-path&quot;&gt;GHC_PACKAGE_PATH环境变量&lt;/a&gt;，并在&lt;strong&gt;ghc-pkg&lt;/strong&gt;命令行上使用&lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt;选项。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">该&lt;strong&gt;GV&lt;/strong&gt;和&lt;strong&gt;Ghostview工具&lt;/strong&gt;程序有一个&amp;ldquo;监视文件&amp;rdquo;选项可以使用，因为它运行到查看程序的跟上时代的堆轮廓。只需生成上一部分中所述的增量堆概要文件即可。在您的个人资料上运行&lt;strong&gt;gv&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">ASCII编码是7位编码。此处实现的&lt;em&gt;Char7&lt;/em&gt;编码的工作方式是将Unicode代码点截断为7位，在其前加上0作为前缀，然后将所得的8位编码为单个字节。对于代码点0-127，这对应于ASCII编码。</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">累积单体</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">AccumT单体变压器</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">任何类型</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">二进制类</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">ResolvedBCOs的二进制实例。</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">建设者单体</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">建设者类型</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">C调用 &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; 等效于Haskell调用 &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; ，除了它是</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">仅当GHC在未注册模式下构建时才支持C代码生成器，该模式下GHC生成&amp;ldquo;便携式&amp;rdquo; C代码作为输出，以便于将GHC自身移植到新平台。但是，此模式会产生慢得多的代码，因此不太可能以这种方式构建GHC版本。如果有，那么本地代码生成器可能将不可用。您可以通过调用 &lt;code&gt;ghc --info&lt;/code&gt; 来查看此信息（请参阅&lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">要使用的C编译器（默认值： &lt;code&gt;gcc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e1af0dbad65022684bd70994a6b169612ac3f0f8" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code if the &lt;code&gt;-cpp&lt;/code&gt; option or &lt;code&gt;-XCPP&lt;/code&gt; extension are given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">如果给出了 &lt;code&gt;-cpp&lt;/code&gt; 选项或 &lt;code&gt;-XCPP&lt;/code&gt; 扩展名，则C预处理程序&lt;strong&gt;cpp&lt;/strong&gt;将在Haskell代码上运行。除非您要构建一个包含大量条件编译的大型系统，否则您确实不需要它。</target>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">仅当指定了 &lt;code&gt;-cpp&lt;/code&gt; 选项-cpp选项时，C预处理程序&lt;strong&gt;cpp&lt;/strong&gt;才会在Haskell代码上运行。除非您要构建一个包含大量条件编译的大型系统，否则您确实不需要它。</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">使用Haskell编译器编译C程序。这提供了 &lt;code&gt;HsFFI.h&lt;/code&gt; 的包含路径，该路径自动包含在C程序中。</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">C端接口</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">GC本身所使用的CPU时间</target>
        </trans-unit>
        <trans-unit id="9d849fe5e03e42e4cfc89679d13718f7c8ec55fb" translate="yes" xml:space="preserve">
          <source>The CPU time used during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">并发的非移动GC的标记后暂停阶段所用的CPU时间。</target>
        </trans-unit>
        <trans-unit id="6bd9ffd9c0904c0c2f55fc70386db0a7ddaf3815" translate="yes" xml:space="preserve">
          <source>The Chapter &lt;em&gt;does&lt;/em&gt; allow for implementations to move objects around during &lt;code&gt;unsafe&lt;/code&gt; calls as well. So strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">本章&lt;em&gt;的确&lt;/em&gt;允许实现在 &lt;code&gt;unsafe&lt;/code&gt; 调用过程中移动对象。因此严格遵守Haskell 2010的程序也不能将堆分配的引用传递给 &lt;code&gt;unsafe&lt;/code&gt; FFI调用。</target>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">该章并&lt;em&gt;没有&lt;/em&gt;要求实现切莫从做了同样的 &lt;code&gt;unsafe&lt;/code&gt; 调用，因此严格哈斯克尔2010-符合程序无法传递到堆上分配引用 &lt;code&gt;unsafe&lt;/code&gt; FFI电话要么。</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Char类型和相关操作。</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">字节字符串的Char8接口为ByteString类型提供了一个IsString实例，使您能够使用字符串文字，并将它们隐式打包到ByteStrings中。使用 &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; 启用此功能。</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">约束类</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">Cont单体</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">ContT单体变压器</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">Continuation monad以连续传递样式（CPS）表示计算。在continuation-passing样式函数中，不返回结果，而是将其传递给另一个函数，作为参数接收（延续）。计算是根据嵌套的连续序列构建的，这些序列以最终的连续（通常为 &lt;code&gt;id&lt;/code&gt; ）终止，最终的连续产生了最终的结果。由于连续性是代表计算的未来的函数，因此对连续函数的操纵可以实现对计算的未来的复杂操纵，例如中断中间的计算，中止计算的一部分，重新​​开始计算以及交织执行计算。 Continuation monad使CPS适应monad的结构。</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">覆盖条件。对于每个函数依赖，⟨tvs⟩ &lt;sub&gt;左&lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;右&lt;/sub&gt;，类的，在S（⟨tvs⟩每一种类型的可变&lt;sub&gt;右&lt;/sub&gt;）必须出现在S（⟨tvs⟩ &lt;sub&gt;左&lt;/sub&gt;），其中S是取代映射每个类型将类声明中的变量更改为实例头中的相应类型。</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Cygwin工具旨在在Windows库的顶部提供Unix风格的API，以方便将Unix软件移植到Windows。为此，他们在某个根目录（通常为 &lt;code&gt;/&lt;/code&gt; 是 &lt;code&gt;C:\cygwin\&lt;/code&gt; ）下引入Unix风格的目录层次结构。此外，基于Cygwin API构建的所有内容（包括使用Cygwin的GHC编译的Cygwin工具和程序）都将 &lt;code&gt;/&lt;/code&gt; 作为其文件系统的根，很高兴地假装在典型的unix环境中工作，并找到 &lt;code&gt;/bin&lt;/code&gt; 和 &lt;code&gt;/usr/include&lt;/code&gt; 而不会显式地打扰它们在Windows系统上的实际位置（可能是 &lt;code&gt;C:\cygwin\bin&lt;/code&gt; 和 &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">处理构造函数应用的数据类</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">动态接口提供了对动态类型的基本支持。</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">Either类型,以及相关操作。</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">Error单体(也叫Exception单体)。</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">ErrorT单项式变换器</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">Except单体</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">ExceptT单项式变换器</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">异常类型</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">本节中描述的FFI特性是针对GHC的。如果你使用这些功能,你的代码将不能移植到其他编译器中。</target>
        </trans-unit>
        <trans-unit id="fa5c3008de574108a3fc529118d05f0ae264146f" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI库在随附的库文档中进行了记录；参见例如&lt;a href=&quot;../../libraries/base-4.15.0.0/foreign&quot;&gt;外部&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI库在随附的库文档中进行了记录；参见例如&lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;外部&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="5ed7160bf5541192af12531389c2d242c62248cf" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI库在随附的库文档中进行了记录；参见例如&lt;a href=&quot;../libraries/base-4.14.1.0/foreign&quot;&gt;外部&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">FFI库提供了几种分配内存以供FFI使用的方法，但始终不清楚哪种方法最好。在给定的编译器/平台上，特定类型的分配的效率可能会影响此决定，因此本节旨在阐明GHC如何执行不同类型的分配。</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">FFI规范要求IO monad出现在不同的地方，但是有时可以方便地将IO monad包装为 &lt;code&gt;newtype&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="f1df7ad812566b24077279b5c70b3b3b84e28607" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;#13693&lt;/a&gt;.</source>
          <target state="translated">FFI规范要求实现在通过 &lt;code&gt;hs_exit()&lt;/code&gt; 关闭后支持自身重新初始化，但是GHC当前不支持该初始化。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;＃13693&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">FFI规范要求实现在通过 &lt;code&gt;hs_exit()&lt;/code&gt; 关闭后支持自身重新初始化，但是GHC当前不支持该初始化。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;问题＃13693&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d82e5c0000a3a4523ec1f2606c3f0201a3a2af5" translate="yes" xml:space="preserve">
          <source>The Foldable class represents data structures that can be reduced to a summary value one element at a time. Strict left-associative folds are a good fit for space-efficient reduction, while lazy right-associative folds are a good fit for corecursive iteration, or for folds that short-circuit after processing an initial subsequence of the structure's elements.</source>
          <target state="translated">Foldable类表示可以一次一个元素还原成摘要值的数据结构。严格的左关联折叠适合于空间效率高的还原,而懒惰的右关联折叠则适合于核心cursive迭代,或者适合于处理结构元素的初始子序列后短路的折叠。</target>
        </trans-unit>
        <trans-unit id="c810fb3026eea84c07b1ddbb163add991beb6f3b" translate="yes" xml:space="preserve">
          <source>The GADT return type (&lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe x) -&amp;gt; ...&lt;/code&gt;).</source>
          <target state="translated">GADT返回类型（ &lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe x) -&amp;gt; ...&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">所述GC同步时间，与其他GC统计一起可通过调用 &lt;code&gt;getRTSStats()&lt;/code&gt; 从C函数，或 &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; 从Haskell中。</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC API公开了读取和写入这些文件的功能。</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">GHC RTS目前只有在检测到明确的内存限制(通过RTS标志设置)被超过时,才能从堆溢出中恢复过来。目前,如果不能从操作系统中分配内存,将导致程序立即终止。</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">控制包的GHC命令行选项有:。</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">GHC开发人员在这里闲逛。如果您正在使用GHC API或对GHC的实施有疑问，请随时注意。</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">在处理Haskell源代码（ &lt;code&gt;.hs&lt;/code&gt; 或 &lt;code&gt;.lhs&lt;/code&gt; 文件）时，GHC驱动程序会预定义几个宏。</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">GHC运行时将程序退出视为一种特殊情况，以避免在独立可执行文件退出时等待阻塞的线程。由于该程序及其所有线程将在代码从内存中删除的同时终止，因此不必确保线程先退出。如果要使用此快速松散的 &lt;code&gt;hs_exit()&lt;/code&gt; 版本，可以调用：</target>
        </trans-unit>
        <trans-unit id="cf6aec65a614d7a8b43aacde5373b850e4763ef9" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;命令以这种格式显示模式类型。</target>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;命令以这种格式显示模式类型。</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">GHCi单体升降界面。</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">GHCi调试器提供了一种希望可以快速了解这些错误的方法，而无需修改或重新编译源代码。一种方法是在引发异常的源代码中的位置上设置一个断点，然后使用&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;建立上下文。但是， &lt;code&gt;head&lt;/code&gt; 位于库中，我们不能直接在其上设置断点。因此，GHCi提供了&lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt;标志，该标志会导致抛出异常时评估程序停止运行，并且&lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; 标志&lt;/a&gt;，其工作原理类似，但仅在未捕获的异常时停止。当异常停止时，GHCi的行为将与击中断点时的行为相同，只是它不会向您显示任何源代码位置。因此，这些命令仅与&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;结合使用才真正有用，以便记录导致异常的步骤。例如：</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">获取和放单体</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">Get单体</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">一旦内容被读取,或者出现异常,该句柄就会被关闭。</target>
        </trans-unit>
        <trans-unit id="7aa13d6fda768933256ad6bc36a2d66a70dfef90" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that called functions also have to assume heap-allocated Haskell values may move around arbitrarily in order to allow for GC.</source>
          <target state="translated">Haskell 2010报告指定 &lt;code&gt;safe&lt;/code&gt; FFI调用必须允许外部调用安全地调用Haskell代码。实际上，这意味着被调用的函数还必须假定堆分配的Haskell值可以任意移动以便允许GC。</target>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">Haskell 2010报告指定 &lt;code&gt;safe&lt;/code&gt; FFI调用必须允许外部调用安全地调用Haskell代码。实际上，这意味着垃圾收集器必须能够在这些调用进行时运行，从而随意移动堆分配的Haskell值。</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">Haskell 2010对 &lt;code&gt;Show&lt;/code&gt; 的定义规定，呈现的字符串应仅包含圆括号，这是明确解析结果所必需的。由于历史原因，尽管记录语法比函数应用程序更紧密地绑定，但由GHC派生的 &lt;code&gt;Show&lt;/code&gt; 实例在记录周围包含括号。例如，</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="c0ce36d06fc25e64c6b77302cc8e5115d7e36509" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="f9f5848499bd728182625d195bb7424161811e1c" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;isAlpha&lt;/code&gt; 的Haskell 98定义是：</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">Haskell FFI已指定外国进出口的参数和结果如果是新类型，则将自动展开（FFI附录第3.2节）。 GHC通过自动解包包裹IO monad本身的任何新类型来扩展FFI。更确切地说，无论在FFI规范要求的 &lt;code&gt;IO&lt;/code&gt; 类型，GHC将接受任何NEWTYPE裹包 &lt;code&gt;IO&lt;/code&gt; 型。例如，这些声明是可以的：</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常希望 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 实现等价关系，其中两个比较相等的值不能通过&amp;ldquo; public&amp;rdquo;函数区分，而&amp;ldquo; public&amp;rdquo;函数是一个不允许查看实现细节的函数。例如，对于表示非归一化自然数模100的类型，&amp;ldquo; public&amp;rdquo;函数不会使1和201之间产生差。预期具有以下属性：</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 实现非严格的偏序，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义一个环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskell报告没有定义 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义分隔环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell报告未定义 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 法则。但是，通常会期望 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 实例定义一个欧几里得域，并且在给定合适的欧几里得函数 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的情况下， &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 对具有以下属性：</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常希望 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 实现等价关系，其中两个比较相等的值不能通过&amp;ldquo; public&amp;rdquo;函数区分，而&amp;ldquo; public&amp;rdquo;函数是一个不允许查看实现细节的函数。例如，对于表示非归一化自然数模100的类型，&amp;ldquo; public&amp;rdquo;函数不会使1和201之间产生差。预期具有以下属性：</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskell报告没有定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义分隔环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell报告未定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 法则。但是，通常会期望 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 实例定义一个欧几里得域，并且在给定合适的欧几里得函数 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的情况下， &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 对具有以下属性：</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义一个环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 实现非严格的偏序，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Haskell报告要求，对于中缀运算符 &lt;code&gt;%&lt;/code&gt; ，必须具有以下标识：</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">Haskell报告描述 &lt;code&gt;*&lt;/code&gt; （拼写 &lt;code&gt;Type&lt;/code&gt; 并从Haskell的GHC方言中的 &lt;code&gt;Data.Kind&lt;/code&gt; 导入）是普通数据类型，例如 &lt;code&gt;Int&lt;/code&gt; 。此外，类型构造函数可以带有带箭头的种类。例如， &lt;code&gt;Maybe&lt;/code&gt; 类型 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。未装箱的类型具有一种指定其运行时表示形式的类型。例如，类型 &lt;code&gt;Int#&lt;/code&gt; 具有 &lt;code&gt;TYPE 'IntRep&lt;/code&gt; 而 &lt;code&gt;Double#&lt;/code&gt; 具有 &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; 。这些类型表示 &lt;code&gt;Int#&lt;/code&gt; 的运行时表示形式是机器整数，而 &lt;code&gt;Double#&lt;/code&gt; 的运行时表示形式是机器整数。是机器的双精度浮点数。相反，类型 &lt;code&gt;Type&lt;/code&gt; 实际上只是 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 的同义词。有关 &lt;code&gt;TYPE&lt;/code&gt; 机制的更多详细信息，请参见&lt;a href=&quot;#runtime-rep&quot;&gt;运行时表示多态性一节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">Haskell报告对 &lt;code&gt;deriving&lt;/code&gt; 条款何时合法一事含糊。例如：</target>
        </trans-unit>
        <trans-unit id="90561213a1b6d66157821a9e10425e8dc3a64c9d" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, and &lt;code&gt;Ix&lt;/code&gt; for tuples up to size 15.</source>
          <target state="translated">Haskell的报告仅需要实现来提供的元组类型和其附带的标准实例高达大小15. GHC限制的元组类型的大小，以62和提供的实例 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Bounded&lt;/code&gt; ， &lt;code&gt;Read&lt;/code&gt; ， &lt;code&gt;Show&lt;/code&gt; ，和 &lt;code&gt;Ix&lt;/code&gt; 元组到尺寸15</target>
        </trans-unit>
        <trans-unit id="ac5deab8ae658158332cbfbbabb6e8e4c0757f95" translate="yes" xml:space="preserve">
          <source>The Haskell Report only requires implementations to provide tuple types and their accompanying standard instances up to size 15. GHC limits the size of tuple types to 62 and provides instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt; for tuples up to size 15. However, &lt;code&gt;Ix&lt;/code&gt; instances are provided only for tuples up to size 5.</source>
          <target state="translated">Haskell报告仅要求实现提供最大为15的元组类型及其随附的标准实例。GHC将最大元组类型的大小限制为62，并为最大15的元组提供 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Bounded&lt;/code&gt; ， &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; 的实例。但是， &lt;code&gt;Ix&lt;/code&gt; 实例仅提供给最大为5的元组。</target>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskell报告指定应将一组绑定（在顶层，或在 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 中）分类为强连接的组件，然后按依存关系顺序进行类型检查（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell报告，第4.5.1节&lt;/a&gt;）。在对每个组进行类型检查时，该组中具有显式类型签名的所有活页夹都将放入具有指定多态类型的类型环境中，而所有其他活页夹都将是单态的，直到对该组进行一般化为止（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell报告，第4.5.2节&lt;/a&gt;）。 。</target>
        </trans-unit>
        <trans-unit id="8b75c250a4a929abcdfd7f96fd88dc38f5bfcd9e" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskell报告指定应将一组绑定（在顶层， &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 中）分类为强连接的组件，然后按依存关系顺序进行类型检查（&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell报告第4.5.1节&lt;/a&gt;）。在对每个组进行类型检查时，该组中具有显式类型签名的所有活页夹都将放入具有指定多态类型的类型环境中，而所有其他活页夹都将是单态的，直到对该组进行一般化为止（&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell报告，第4.5.2节&lt;/a&gt;）。 。</target>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">软件包中的Haskell代码可以内置到一个或多个存档库（例如 &lt;code&gt;libHSfoo.a&lt;/code&gt; ）或单个共享库（例如 &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; ）中。对单个共享库的限制是因为程序包系统用于告诉编译器何时应进行共享库间调用而不是共享库内调用（共享库间调用需要额外的时间）间接）。</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">程序被编译或被解释的Haskell实现。</target>
        </trans-unit>
        <trans-unit id="60ce9c55f4fa0cf40f27dcde7ee4087164650d58" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted. On the GHC platform, the value is &quot;ghc&quot;.</source>
          <target state="translated">程序被编译或被解释的Haskell实现。在GHC平台上,该值是 &quot;ghc&quot;。</target>
        </trans-unit>
        <trans-unit id="3bcb6ef9eb76436588cc0d8da0bf323ce2da12ae" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest)</source>
          <target state="translated">Haskell报告因此&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;定义&lt;/a&gt;了 &lt;code&gt;lexp&lt;/code&gt; 非终结符（ &lt;code&gt;*&lt;/code&gt; 表示感兴趣的规则）</target>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Haskell报告&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;定义&lt;/a&gt;了 &lt;code&gt;lexp&lt;/code&gt; 非终结符（ &lt;code&gt;*&lt;/code&gt; 表示感兴趣的规则）：</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Haskell2010报告在&amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;中指定</target>
        </trans-unit>
        <trans-unit id="85d12b1c3d53edaed978aecf46c9e3e3b26b841c" translate="yes" xml:space="preserve">
          <source>The I/O SubSystem to use in the program.</source>
          <target state="translated">程序中要使用的I/O子系统。</target>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">IO单体</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">IOArray类型</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">IOMode类型</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">IORef类型</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。请注意，Char8编码等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用Char8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="49fa9b80f4fa24e3bcc0042f7b61d0c844f15e6b" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。请注意，Char8编码等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用Char8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="6c77ebed88d6a61f3f19c1021d1825a839754219" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。请注意，Char8编码等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用Char8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">InputT单项式变压器</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）编码。此编码将字节直接映射到前256个Unicode代码点，因此不是完整的Unicode编码。尝试使用 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 编码将大于 &lt;code&gt;'\255'&lt;/code&gt; 的字符写入到 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将导致错误。</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）编码。此编码将字节直接映射到前256个Unicode代码点，因此不是完整的Unicode编码。尝试使用 &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 编码将大于 &lt;code&gt;'\255'&lt;/code&gt; 的字符写入到 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将导致错误。</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">列表数据类型及其操作</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">列表单体。</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">ListT单项式变换器</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">ListT单体变换器,对给定的单体增加回溯,必须是换元的。</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">MVar类型</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">Maybe类型,以及相关的操作。</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">MaybeT单项式变换器</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">修改后的朱利安日期是指从UT午夜开始测量的一天的分数。它用来表示UT1,即由地球自转测量的时间,并根据各种晃动进行调整。</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">修改后的朱利安日是一个标准的天数,0是1858-11-17这一天。</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">MonadException类</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">MonadWriter类。</target>
        </trans-unit>
        <trans-unit id="51acf2e9a1f450466332b8327436f6eceb7c3f17" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;exts/monomorphism#monomorphism&quot;&gt;Switching off the Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Monomorphism Restriction已禁用（请参阅&lt;a href=&quot;exts/monomorphism#monomorphism&quot;&gt;关闭Monomorphism Restriction&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Monomorphism Restriction已禁用（请参阅&lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;关闭可怕的Monomorphism Restriction&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">然而,NT内核允许你选择不使用Win32 API的路径预处理。这可以通过在路径中明确使用所需的命名空间来实现。</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">软件包版本控制策略&lt;strong&gt;不适用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">帕特森条件：对于上下文中的每个类约束 &lt;code&gt;(C t1 ... tn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Prelude:一个标准模块。除非有明确的导入语句,或者启用了 NoImplicitPrelude 扩展,否则所有 Haskell 模块都会默认导入 Prelude。</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">Put单体</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">Put单体。一个用于高效构建懒惰字节串的单体。</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">认沽型</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">PutM类型。在高效的 Builder 单体上的 Writer 单体。</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">RTS有很多选择来控制其行为。例如，您可以更改上下文切换间隔，默认的堆大小并启用堆分析。这些选项可以通过各种不同的方式传递给运行时系统。下一节（&lt;a href=&quot;#setting-rts-options&quot;&gt;设置RTS选项&lt;/a&gt;）描述了各种方法，以下几节描述了RTS选项本身。</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">与并发相关的RTS选项在&amp;ldquo; &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;使用并发Haskell&amp;rdquo;中&lt;/a&gt;进行了介绍，而在&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;STS&lt;/a&gt;并行性的RTS选项中则针对并行性进行了描述。</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTS会 &lt;code&gt;-H32m -S&lt;/code&gt; ，如果/在调用 &lt;code&gt;System.Environment.getArgs&lt;/code&gt; 时，其余参数 &lt;code&gt;-f -h foo bar&lt;/code&gt; 将对您的程序可用。</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">RULES机制用于实现公用列表功能的融合（砍伐森林）。如果&amp;ldquo;好消费者&amp;rdquo;消费了&amp;ldquo;好生产者&amp;rdquo;构建的中间清单，则应该完全消除中间清单。</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWS单体</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">RWST单体变压器</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">读者单体</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">ReaderT单项式变换器</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM实现将中止已知无效且需要重新启动的事务。这可能发生在 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 的中间，因此请确保您没有获取任何需要释放的资源（中止事务时忽略异常处理程序）。例如，这包括使用Handles进行任何IO。弄错了可能会导致随机死锁。</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM实现将中止已知无效且需要重新启动的事务。这可能发生在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 的中间，因此请确保您没有获取任何需要释放的资源（中止事务时忽略异常处理程序）。例如，这包括使用Handles进行任何IO。弄错了可能会导致随机死锁。</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">STM的实现经常会多次运行事务,所以如果你的IO有什么副作用,你需要做好准备。</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Safe Haskell &lt;em&gt;安全语言&lt;/em&gt;（由 &lt;code&gt;-XSafe&lt;/code&gt; 启用）保证了以下属性：</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">可以通过传递&lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt;标志来禁用模块的Safe Haskell检查。这在使用源插件进行编译时特别有用，因为运行插件会将模块标记为不安全，然后会导致下游模块无法通过安全检查。</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">选择单体</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">SelectT单项式变换器</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">信号类型</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">国家单体</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">StateT单项式变换器</target>
        </trans-unit>
        <trans-unit id="19f67896d1f6937e580c15a10e0aa19b08a4f845" translate="yes" xml:space="preserve">
          <source>The SubSystem control interface. These methods can be used to disambiguate between the two operations.</source>
          <target state="translated">子系统控制接口。这些方法可以用来区分这两种操作。</target>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">TH状态，由 &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt; 创建</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Typeable类</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">UTC时区。</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-16 Unicode 编码(应使用字节顺序标记来表示endianness)。</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-16 Unicode编码(大写字母)。</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 Unicode编码(litte-endian)</target>
        </trans-unit>
        <trans-unit id="8c4b2968dfc559f607c84276e6deaa90e4bc09b8" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (little-endian)</source>
          <target state="translated">UTF-16Unicode编码(小字段)</target>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 Unicode编码(应使用字节顺序标记来表示endianness)。</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32Unicode编码(大写字母)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32统一码编码(litte-endian)</target>
        </trans-unit>
        <trans-unit id="7aac7a838ca04e2d0239351dada786d53acef1d2" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (little-endian)</source>
          <target state="translated">UTF-32Unicode编码(小字段)</target>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 Unicode编码</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">UTF-8 Unicode编码，带有字节顺序标记（BOM；字节序列0xEF 0xBB 0xBF）。此编码的行为类似于 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; ，只是在输入时，在流的开头忽略BOM序列，而在输出时，在BOM序列的前面。</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">UTF-8 Unicode编码，带有字节顺序标记（BOM；字节序列0xEF 0xBB 0xBF）。此编码的行为类似于 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; ，只是在输入时，在流的开头忽略BOM序列，而在输出时，在BOM序列的前面。</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8编码可以编码&lt;em&gt;所有&lt;/em&gt; Unicode代码点。我们建议始终将其用于编码 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ,除非应用程序确实需要另一种编码。</target>
        </trans-unit>
        <trans-unit id="ad5a08465846c2ed90f1e4740e5e95b9f0ebef47" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8编码可以编码&lt;em&gt;所有&lt;/em&gt;Unicode代码点。我们建议始终将其用于编码 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ,除非应用程序确实需要另一种编码。</target>
        </trans-unit>
        <trans-unit id="bd2c9a45b06c5bc52330c023a465b428ccfa7702" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8编码可以编码&lt;em&gt;所有&lt;/em&gt;Unicode代码点。我们建议始终将其用于编码 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ,除非应用程序确实需要另一种编码。</target>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8编码可以编码所有Unicode代码点。它等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用UTF-8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="51b4cc22b8af376450ca69ff9b57ead5e922d46c" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8编码可以编码所有Unicode代码点。它等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用UTF-8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="56e548216f1a033464f97b8c8251bc89165b536d" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8编码可以编码所有Unicode代码点。它等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用UTF-8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">当前语言环境的Unicode编码。</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">当前locale的Unicode编码,但允许任意不可解码的字节在其中进行循环播放。</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">当前语言环境的Unicode编码，但无法解码的字节将替换为其最接近的视觉匹配。用于&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String中&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 编组函数</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">字符的Unicode常规类别。这依赖于 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例，该实例必须与Unicode标准中显示的类别保持相同的顺序。</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">字符的Unicode常规类别。这依赖于 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例，该实例必须与Unicode标准中显示的类别保持相同的顺序。</target>
        </trans-unit>
        <trans-unit id="b3874853724a4d3f79b5cf848ac2f78cd971528d" translate="yes" xml:space="preserve">
          <source>The Weak Head Normal Form of an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; is a lambda abstraction not a data value, and reuse does not lead to memoisation. Reuse of the iterator above is somewhat contrived, when computing multiple folds over a common list, you should generally traverse a list only &lt;a href=&quot;#multipass&quot;&gt;once&lt;/a&gt;. The goal is to demonstrate that the separate computations of the &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; run efficiently in constant space, despite reuse. This would not be the case with the list &lt;code&gt;[1..10000000]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;的弱头&lt;strong&gt;范式&lt;/strong&gt;是lambda抽象而不是数据值，并且重用不会导致记忆。迭代器的再利用上面是人为，在共同的清单计算多次折叠时，你通常应该遍历只有一个列表&lt;a href=&quot;#multipass&quot;&gt;一次&lt;/a&gt;。目的是证明尽管重复使用， &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 的单独计算在恒定空间中有效运行。列表 &lt;code&gt;[1..10000000]&lt;/code&gt; 不会是这种情况。</target>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Windows目录</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">作家单体</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
