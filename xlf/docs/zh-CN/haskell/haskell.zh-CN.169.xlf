<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，只应使用 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，只应使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 启用，使用 &lt;code&gt;anyclass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 启用，我们获得了NEWTYPE，然后使用 &lt;code&gt;newytype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">当 &lt;code&gt;mappend x x = x&lt;/code&gt; ，应该首选此定义，因为它适用于O（1）而不是O（log n）</target>
        </trans-unit>
        <trans-unit id="385ace8105515b932625b88764546dcae18aded8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\)</source>
          <target state="translated">当 &lt;code&gt;mappend x x = x&lt;/code&gt; ，应该首选此定义，因为它适用于\（\ mathcal {O}（1）\）而不是\（\ mathcal {O}（\ log n）\）</target>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">当 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; ，应该首选此定义，因为它适用于O（1）而不是O（log n）。</target>
        </trans-unit>
        <trans-unit id="01dfa1f0b575553478bb02cbc1f8d40024bd7518" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\).</source>
          <target state="translated">当 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; ，应该首选此定义，因为它适用于\（\ mathcal {O}（1）\）而不是\（\ mathcal {O}（\ log n）\）。</target>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">当GHC找不到类的实例时，它将在它知道的实例中显示一些实例的简短列表。使用此标志，它将打印它知道的&lt;em&gt;所有&lt;/em&gt;实例。</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">当GHC编译使用 &lt;code&gt;foreign export&lt;/code&gt; 或 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 的模块（例如 &lt;code&gt;M.hs&lt;/code&gt; ）时，它将生成 &lt;code&gt;M_stub.h&lt;/code&gt; 供C程序使用。</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">在未注册模式下构建GHC时，只有LLVM和C代码生成器可用。本机代码生成器不会。在未注册模式下，LLVM通常比C后端具有显着的性能优势。</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">使用GHC编译C文件时，GHC会添加软件包include路径，并直接包含 &lt;code&gt;ghcversion.h&lt;/code&gt; 。编译器将从包数据库中的 &lt;code&gt;rts&lt;/code&gt; 包中查找 &lt;code&gt;ghcversion.h&lt;/code&gt; 文件的路径。在某些情况下，编译器的软件包数据库不包含 &lt;code&gt;rts&lt;/code&gt; 软件包，或者一个人希望指定要包含的特定 &lt;code&gt;ghcversions.h&lt;/code&gt; 。此选项可用于指定要包括的 &lt;code&gt;ghcversions.h&lt;/code&gt; 文件的路径。这主要是供GHC的构建系统使用。</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">当GHC尝试解析约束 &lt;code&gt;C Int Bool&lt;/code&gt; 时，它将通过实例化实例声明的头部来尝试将每个实例声明与该约束进行匹配。考虑以下声明：</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">当GHCi在断点处停止时，在提示符下输入的表达式触发第二个断点，新的断点成为&amp;ldquo;当前&amp;rdquo;断点，旧的断点保存在堆栈中。通过这种方式可以建立任意数量的断点上下文。例如：</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">当GC启动时,所有运行中的突变器线程都必须停止并同步。从GC启动到所有突变器线程停止的这段时间称为GC同步阶段。如果这个阶段耗时较长(超过1ms即为长),那么会严重影响整体的吞吐量。</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">当使用&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS选项运行GHC编译的程序时，它将生成一个名为 &lt;code&gt;prog.prof&lt;/code&gt; 的文件。在这种情况下，文件将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="1f106b54cbaaef2571f93c8d0393bd0f543851ad" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="translated">当Monoid的 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 在其第二个参数中 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 惰性状态时，foldMap甚至可以返回来自无界结构的结果。例如，惰性累积使&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;可以有效地序列化大型数据结构并递增生成输出：</target>
        </trans-unit>
        <trans-unit id="adb500e0f063ff278c253fad2463e930413ad240" translate="yes" xml:space="preserve">
          <source>When a Monoid's &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; is lazy in its second argument, &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; can return a result even from an unbounded structure. For example, lazy accumulation enables &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt; to efficiently serialise large data structures and produce the output incrementally:</source>
          <target state="translated">当Monoid的 &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 在其第二个参数中 &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 惰性状态时，foldMap甚至可以返回来自无界结构的结果。例如，惰性累积使&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;可以有效地序列化大型数据结构并递增生成输出：</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">当遇到裸类型变量 &lt;code&gt;a&lt;/code&gt; 时，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;都将分别为 &lt;code&gt;fmap&lt;/code&gt; 和 &lt;code&gt;traverse&lt;/code&gt; 定义生成 &lt;code&gt;f a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">在特定的行和列上设置断点时，GHCi会选择包围该断点设置位置的最小子表达式。注意：GHC认为TAB字符的宽度为1，无论它在哪里出现；换句话说，它计算字符，而不是列。这与某些编辑器的功能匹配，而与其他编辑器的功能不匹配。最好的建议是完全避免在源代码中使用制表符（请参见&lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全检查&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">当在某一行设置断点时,GHCi将断点设置在该行开始和结束的最左边的子表达式上。如果两个完整的子表达式开始于同一列,则选取最长的一个。如果行上没有完整的子表达式,则选择行上开始的最左边的表达式,如果没有,则选择部分或完全覆盖该行的最右边的表达式。</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">当数据类型 &lt;code&gt;T&lt;/code&gt; 是进口的所有构造函数，即 &lt;code&gt;T(..)&lt;/code&gt; ，但已被抽象出口，也就是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">当调用基础POSIX函数的函数失败时，errno代码将转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 。有关可能生成的errno代码的列表，请查阅POSIX文档以获取基础功能。</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">当调用基础POSIX函数的函数失败时，使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 将errno代码转换为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。有关可能生成的errno代码的列表，请查阅POSIX文档以获取基础功能。</target>
        </trans-unit>
        <trans-unit id="eb8e20bccf6e08f777f996c2c39b5d665dcbf299" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">当调用基础POSIX函数的函数失败时，使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 将errno代码转换为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。有关可能生成的errno代码的列表，请查阅POSIX文档以获取基础功能。</target>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">当hs-boot文件 &lt;code&gt;A.hs-boot&lt;/code&gt; 编译 A.hs-boot时，将检查其范围和类型错误。编译其父模块 &lt;code&gt;A.hs&lt;/code&gt; 时，将对两者进行比较，如果两者不一致，则会报告错误。</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数,或许在合并后的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">当在两个地图中找到一个键时,对键和值应用一个函数,并在合并后的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数来产生一个动作,并在合并后的地图中使用其结果。</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数,执行结果的操作,也许在合并的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">导入当前正在编译的程序包提供的模块（即&amp;ldquo; home&amp;rdquo;程序包）时，但未在命令行中明确列出作为目标。对于Cabal有用，以确保GHC不会拾取模块，该模块也未列出 &lt;code&gt;exposed-modules&lt;/code&gt; 或 &lt;code&gt;other-modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">当在范围内找不到名称或包时,请为您可能想要的名称或包提出建议。</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">如果由于实例重叠而导致特定类型类方法调用被认为不安全，并且正在编译的模块使用&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;，编译将失败。对于&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;，不应用限制，对于使用安全推断的模块，它们将被推断为不安全。</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">编译并执行程序时，可以使用 &lt;code&gt;getArgs&lt;/code&gt; 函数访问命令行参数。但是，在ghci中进行测试时，我们不能简单地将参数传递给 &lt;code&gt;main&lt;/code&gt; 函数，因为 &lt;code&gt;main&lt;/code&gt; 函数不会直接接受其参数。</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">编译并执行程序时，可以使用 &lt;code&gt;getArgs&lt;/code&gt; 函数访问命令行参数。但是，我们不能简单地将参数传递给 &lt;code&gt;main&lt;/code&gt; 在ghci中进行测试时 main函数，因为 &lt;code&gt;main&lt;/code&gt; 函数不会直接采用它。</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">当一个字符串被传递到这个标志时,我们会报告所有名称与该字符串共享前缀的函数的信息。</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当类型没有构造函数时，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将使用&lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 强制&lt;/a&gt;使用参数的（底部）值。</target>
        </trans-unit>
        <trans-unit id="d983aaf2b04606b0ab51075f4a016ac754c84212" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;empty_case#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当类型没有构造函数时，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将使用&lt;a href=&quot;empty_case#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 强制&lt;/a&gt;使用参数的（底部）值。</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">当一个类型，在语法上不等同于 &lt;code&gt;a&lt;/code&gt; ，但确实包含 &lt;code&gt;a&lt;/code&gt; ，当遇到，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;递归调用 &lt;code&gt;fmap&lt;/code&gt; 就可以了。同样，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;将递归调用 &lt;code&gt;foldr&lt;/code&gt; 和 &lt;code&gt;foldMap&lt;/code&gt; 。根据上下文， &lt;code&gt;null&lt;/code&gt; 可以递归调用 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;all null&lt;/code&gt; 。例如，给定</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">当一个类型，在语法上不等同于 &lt;code&gt;a&lt;/code&gt; ，但确实包含 &lt;code&gt;a&lt;/code&gt; ，当遇到，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;递归调用 &lt;code&gt;fmap&lt;/code&gt; 就可以了。同样，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;将递归调用 &lt;code&gt;traverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">当存在类型级别的显式 &lt;code&gt;forall&lt;/code&gt; 时，现在提到的每个类型/种类变量也必须在范围内或受 &lt;code&gt;forall&lt;/code&gt; 约束。特别是，与Haskell中的其他地方不同，这意味着自由种类变量不会被隐式绑定。例如：</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">当值必然会 &lt;code&gt;do&lt;/code&gt; -notation上的左侧的模式 &lt;code&gt;&amp;lt;-&lt;/code&gt; 可能不匹配。在这种情况下，此类提供了恢复功能。</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">当发出警告时,会显示控制它的特定警告标志。</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">当一个通配符没有实例化到一个单字型时,它将被泛化,即被一个新的类型变量所取代,例如。</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">当 &lt;code&gt;import&lt;/code&gt; 语句隐藏未导出的实体时。</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">当在类型类实例中声明关联的数据或类型同义词家族实例时，我们（可选）可以将 &lt;code&gt;instance&lt;/code&gt; 关键字放在家族实例中：</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">当异常传播到主程序之外时，Haskell系统将打印关联的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值并退出程序。</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">当异常传播到主程序之外时，Haskell系统将打印关联的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值并退出程序。</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">当存在显式的 &lt;code&gt;forall&lt;/code&gt; 时，提到的&lt;em&gt;所有&lt;/em&gt;不在范围内的类型和种类变量必须由 &lt;code&gt;forall&lt;/code&gt; 绑定：</target>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">当存在显式的 &lt;code&gt;forall&lt;/code&gt; 时，提到的所有不在范围内的&lt;em&gt;类型&lt;/em&gt;变量必须由 &lt;code&gt;forall&lt;/code&gt; 绑定。如有必要，种类变量将被隐式绑定，例如：</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;CT&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 实例时，由类型类定义的按位运算实现与C on &lt;code&gt;t&lt;/code&gt; 上相应的按位运算相同的功能。</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">当的实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 被定义为 &lt;code&gt;CT&lt;/code&gt; ，的值 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 与重合 &lt;code&gt;t_MIN&lt;/code&gt; 和 &lt;code&gt;t_MAX&lt;/code&gt; 中C.</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">当为 &lt;code&gt;CT&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的实例时，由类型类定义的谓词实现与C on &lt;code&gt;t&lt;/code&gt; 上的相应谓词相同的关系。</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;CT&lt;/code&gt; 定义了 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 的实例，则由类型类定义的算术运算将实现与C on &lt;code&gt;t&lt;/code&gt; 上相应的算术运算（如果可用）相同的功能。</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">如果适用，使用 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; 代替此函数几乎总是更好，尽管在某些病理情况下可能会更糟。例如，要微调字符列表，请使用</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">当要求编译一个源文件时,GHC通常会生成两个文件:一个对象文件,一个接口文件。</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">当要求修改数据库时， &lt;code&gt;ghc-pkg&lt;/code&gt; 默认会修改全局数据库。指定 &lt;code&gt;--user&lt;/code&gt; 使其作用于用户数据库，或者 &lt;code&gt;--package-db&lt;/code&gt; 可用于完全作用于另一个数据库。当给出多个这些选项时，最右边的一个将用作操作的数据库。</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">同时给出两个标志时， &lt;code&gt;-&lt;/code&gt; 覆盖 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 覆盖空格。 &lt;code&gt;*&lt;/code&gt; 转换中的负宽度说明符被视为正，但表示左调整标志。</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">当需要绑定类型/种类变量时,必须始终包含这两个foralls,不过如果不需要模式变量,第二个可以留空。例如</target>
        </trans-unit>
        <trans-unit id="b1946e20d1d1096358555ee194ee179a3632a63b" translate="yes" xml:space="preserve">
          <source>When building a shared library, care must be taken to ensure that the resulting object is named appropriately. In particular, GHC expects the name of a shared object to have the form &lt;code&gt;libHS&amp;lt;unit id&amp;gt;-ghc&amp;lt;ghc
version&amp;gt;.&amp;lt;ext&amp;gt;&lt;/code&gt; where &lt;em&gt;unit id&lt;/em&gt; is the unit ID given during compilation via the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag, &lt;em&gt;ghc version&lt;/em&gt; is the version of GHC that produced/consumes the object and &lt;em&gt;ext&lt;/em&gt; is the host system&amp;rsquo;s usual file extension for shared objects.</source>
          <target state="translated">构建共享库时，必须注意确保适当命名命名的对象。特别是，GHC希望共享库的名称采用 &lt;code&gt;libHS&amp;lt;unit id&amp;gt;-ghc&amp;lt;ghc version&amp;gt;.&amp;lt;ext&amp;gt;&lt;/code&gt; ，其中&lt;em&gt;unit id&lt;/em&gt;是在编译过程中通过&lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt;给出的单元ID。-id⟩标志，&lt;em&gt;ghc版本&lt;/em&gt;是产生/使用对象的GHC版本，而&lt;em&gt;ext&lt;/em&gt;是主机系统共享对象的通常文件扩展名。</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">将程序包构建为共享库时，可以使用GHC执行链接步骤。这会将一些细节隐藏在底层链接程序之外，并为GHC支持的所有共享对象变体（DLL，ELF DSO和Mac OS dylib）提供了一个通用接口。共享对象必须以特定的方式命名，其原因有两个：（1）名称必须包含GHC编译器版本，以免两个库变体冲突，它们由GHC的不同版本编译，因此很可能与GHC不兼容关于调用约定，（2）它必须与静态名称不同，否则我们将无法精确地控制链接器以使&lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志起作用，请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">在外部 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 内部调用时，此功能无效。</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">在外部 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 内部调用时，此功能无效。</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">当被调用时，&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; 会&lt;/a&gt;为部分输入&amp;ldquo; string-literal&amp;rdquo;（由&amp;ldquo; type&amp;rdquo;表示）的部分输入&amp;ldquo; string-literal &amp;rdquo;输出&lt;sup&gt;第n&lt;/sup&gt;至&lt;sup&gt;第&lt;/sup&gt; m &lt;sup&gt;个&lt;/sup&gt;完成候选词。当前，仅支持 &lt;code&gt;repl&lt;/code&gt; 域，该域表示将由GHCi在输入提示下以交互方式提供的完成类型。</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">在对 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值进行大小写转换时，请勿使用诸如 &lt;code&gt;map toUpper&lt;/code&gt; 之类的组合符来分别对字符串的每个字符进行大小写转换，因为这会根据某些书写系统的规则产生不正确的结果。此模块的全字符串大小写转换功能（例如 &lt;code&gt;toUpper&lt;/code&gt; ）遵守正确的大小写转换规则。结果，这些功能可以将一个输入字符映射到两个或三个输出字符。有关示例，请参见每个功能的文档。</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">在检查一对封闭型族方程时，GHC试图统一其RHS。如果它们不统一，则这对方程式不会违反注入性注释。如果RHS可以在某些替换下统一（可能为空），则LHS在相同的替换下统一，或者后一个方程式的LHS包含在较早的方程式中。如果两个条件都不满足，GHC报告类型家族不是内射。</target>
        </trans-unit>
        <trans-unit id="d91afb60853a2bed88378f221146e58bb8e15fde" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;exts/partial_type_signatures#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">与&lt;a href=&quot;exts/partial_type_signatures#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;结合使用时，用户可以在查询中插入通配符，并了解每个&amp;ldquo;通配符&amp;rdquo;与实例&amp;ldquo;类型&amp;rdquo;匹配所需的约束。</target>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="translated">与&lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;结合使用时，用户可以在查询中插入通配符，并了解每个&amp;ldquo;通配符&amp;rdquo;与实例&amp;ldquo;类型&amp;rdquo;匹配所需的约束。</target>
        </trans-unit>
        <trans-unit id="aef74d5ed6e34befd39c28303ea99762b0677ced" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;exts/template_haskell#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">当使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;编译模板Haskell代码时，我们不需要先编译不带&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;的模块（请参见&lt;a href=&quot;exts/template_haskell#th-profiling&quot;&gt;将Template Haskell与Profiling一起使用&lt;/a&gt;），因为我们可以在解释器中运行已配置的目标代码。</target>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">当使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;编译Template Haskell代码时，我们不需要先编译不使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;的模块（请参阅&lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;将Template Haskell与Profiling一起使用&lt;/a&gt;），因为我们可以在解释器中运行配置文件。</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">使用&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;编译时，并行编译⟨n⟩个模块。</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="dd600bd791dcd533e241e96d62fd9d5b36e1ddda" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">在为Haskell包创建共享对象时,必须对共享对象进行正确的命名,以便GHC在针对该包进行链接时识别共享对象。请看共享对象名称的混杂。</target>
        </trans-unit>
        <trans-unit id="5fcbc5f9e865e6ce637e24cd8412c50b45fce7f7" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linking against this package. See &lt;a href=&quot;packages#building-packages&quot;&gt;shared object name mangling&lt;/a&gt; for details.</source>
          <target state="translated">为Haskell软件包创建共享库时，必须正确命名共享库，以便GHC在与该软件包链接时能够识别共享库。有关详细信息，请参见&lt;a href=&quot;packages#building-packages&quot;&gt;共享对象名称&lt;/a&gt;处理。</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">在决定是否正确使用这种数据结构时,要考虑:</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">在定义GHCi宏时,当名称可能与内置命令冲突时,有一些重要的行为你应该注意,特别是关于标签完成。</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">在Haskell中设计嵌入式领域特定的语言时，在类型级别 &lt;code&gt;error&lt;/code&gt; 诸如错误之类的东西很有用。这样，EDSL设计人员可能会显示特定于DSL的类型错误，而不是标准的GHC类型错误。</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">当使用&lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt;删除列表符号时，GHC使用模块 &lt;code&gt;GHC.Exts&lt;/code&gt; 中的 &lt;code&gt;fromList&lt;/code&gt; （etc）方法。您无需导入 &lt;code&gt;GHC.Exts&lt;/code&gt; 即可实现。</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">这样做时，我们（可选）可以删除&amp;ldquo; &lt;code&gt;family&lt;/code&gt; &amp;rdquo;关键字。</target>
        </trans-unit>
        <trans-unit id="18b09bd4caf81ecbea6328fe8cec841da926304f" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">启用后，GHC使用&lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;扩展名中的unicode符号打印类型签名。例如，</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">启用后，GHC使用&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;扩展名中的Unicode符号打印类型签名。例如，</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">启用后，GHC使用&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;扩展名中的unicode符号打印类型签名。例如，</target>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">当启用时,GHC也会在警告中打印来自类型检查器的额外信息。例如:</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">启用后,GHC还可以在类型错误中打印类型同义词扩展的类型。例如,用这种类型同义词。</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">启用后，打开对可信任模块 &lt;code&gt;M&lt;/code&gt; 的额外检查，要求将 &lt;code&gt;M&lt;/code&gt; 所在的程序包视为可信任，以便将 &lt;code&gt;M&lt;/code&gt; 视为可信任。</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生成代码时，假设从其他模块导入的实体可能是动态链接的。该标志由&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;自动启用。</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="translated">当优先使用内置命令时，可以使用&lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt; &lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt; &lt;/a&gt;，如 &lt;code&gt;::type 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee90095bc1ddd211ce603181ac23bb488b4bede" translate="yes" xml:space="preserve">
          <source>When however the traversed container is empty, the result is always a singleton of the empty container, the function is never evaluated as there are no input values for it to be applied to.</source>
          <target state="translated">然而,当遍历的容器为空时,结果总是空容器的单子,该函数从不被评估,因为没有输入值可供应用。</target>
        </trans-unit>
        <trans-unit id="6b07da55e3e4a468a7f3850c0886d61befe9f38e" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;exts/package_qualified_imports#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">当合并来自多个来源的软件包时，您可能最终会遇到多个软件包发布具有相同名称的模块的情况。以前，区分这些模块的唯一方法是使用&lt;a href=&quot;exts/package_qualified_imports#package-qualified-imports&quot;&gt;Package限定的import&lt;/a&gt;。但是，自GHC 7.10以来，&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;标志（及其变体）已得到扩展，以允许用户类似于用户可以附加到模块导入的导入列表，来明确控制软件包将哪些模块纳入范围。</target>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">当合并来自多个来源的软件包时，您可能最终会遇到多个软件包发布具有相同名称的模块的情况。以前，区分这些模块的唯一方法是使用&lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package限定的import&lt;/a&gt;。但是，自GHC 7.10起，&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;标志（及其变体）已得到扩展，以允许用户类似于用户可以附加到模块导入的导入列表，来明确控制软件包将哪些模块纳入范围。</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内部调用时，此函数允许引发被屏蔽的异步异常（如果存在）。这等效于执行可中断的操作（请参阅#interruptible），但不涉及任何实际的阻塞。</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">当使用&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt;标志调用时，运行时将以机器可读的JSON格式发出成本中心配置文件。此格式的顶级对象具有以下属性，</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">当与 &lt;code&gt;-g&lt;/code&gt; 标志一起调用时，GHC将产生标准的&lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt;调试信息。几乎所有POSIX兼容目标都使用此格式，调试和性能工具（例如 &lt;code&gt;gdb&lt;/code&gt; ， &lt;code&gt;lldb&lt;/code&gt; 和 &lt;code&gt;perf&lt;/code&gt; ）可以使用此格式来了解GHC编译程序的结构。</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">当启动时，除非&lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt;标志，否则GHCi将按照以下顺序从以下文件中读取并执行命令（如果存在）：</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">在对类型进行种类检查时，GHC在弄清楚如何概括类型的种类时仅考虑用该类型写的内容。</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">当链接一个二进制可执行文件，这就将标志 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 之前的任何 &lt;code&gt;-l&lt;/code&gt; Haskell的图书馆标志和 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 之后</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">当链接一个二进制可执行文件，这就将标志 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 之前的任何 &lt;code&gt;-l&lt;/code&gt; Haskell的图书馆标志和 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 之后（在OS X上，该标志为 &lt;code&gt;-Wl,-all_load&lt;/code&gt; ，没有-Wl，-no &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 等效项。此标志还禁止使用 &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; （在OS X上为-Wl，-dead_strip）。</target>
        </trans-unit>
        <trans-unit id="3818bf88dbd86c201ca5b0d240e8772c4b466f3c" translate="yes" xml:space="preserve">
          <source>When linking a static library (&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt;) GHC links the RTS automatically, you can reverse this behaviour by reversing this flag: &lt;code&gt;-fno-link-rts&lt;/code&gt;.</source>
          <target state="translated">链接静态库（&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;）时，GHC自动链接RTS，您可以通过反转以下标志来反转此行为： &lt;code&gt;-fno-link-rts&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="408951dfca34cc5b21016977e48bc1e9b23d4168" translate="yes" xml:space="preserve">
          <source>When linking shared libraries (&lt;a href=&quot;#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt;) GHC does not automatically link the RTS. This is to allow choosing the RTS flavour (&lt;a href=&quot;#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt;, etc) when linking an executable. However when the shared library is the intended product it is useful to be able to reverse this default. See &lt;a href=&quot;shared_libs#shared-libraries-c-api&quot;&gt;Shared libraries that export a C API&lt;/a&gt; for an usage example.</source>
          <target state="translated">链接共享库（&lt;a href=&quot;#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;）时，GHC不会自动链接RTS。这是为了在链接可执行文件时选择RTS风格（&lt;a href=&quot;#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt;等）。但是，当共享库是预期的产品时，能够逆转该默认值将很有用。有关用法示例&lt;a href=&quot;shared_libs#shared-libraries-c-api&quot;&gt;，&lt;/a&gt;请参见导出C API的共享库。</target>
        </trans-unit>
        <trans-unit id="e65f758cb8818ccee7542109e759d106e5df490b" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;../phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">链接最终程序时，通常不是很必要，但是使用GHC进行链接通常最容易。如果您确实使用GHC，请不要忘记标记&lt;a href=&quot;../phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;，否则GHC会尝试链接到 &lt;code&gt;Main&lt;/code&gt; Haskell模块。</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">链接最终程序时，尽管并非必需，但通常最容易使用GHC进行链接。如果您确实使用了GHC，请不要忘记标记&lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;，否则GHC会尝试链接到 &lt;code&gt;Main&lt;/code&gt; Haskell模块。</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="translated">链接时,链接器可以自动删除所有未引用的部分,从而产生更小的可执行文件。</target>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">链接时，链接器可以自动删除所有未引用的节，从而生成较小的可执行文件。效果类似于&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;，但是效率更高-生成的库文件比&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;小约30％。</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">负载均衡时,我们更倾向于将线程迁移到同一节点上的另一个Capability。</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">当使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;加载源模块时，GHCi通常会查找任何相应的已编译目标文件，并且将尽可能优先使用一个来解释源文件。例如，假设我们有一个由4个模块组成的程序， &lt;code&gt;A&lt;/code&gt; 程序由模块A， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 组成。模块 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 两个进口 &lt;code&gt;D&lt;/code&gt; 只，和 &lt;code&gt;A&lt;/code&gt; 进口既 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">在查看程序执行的剖面图时,我们往往希望能够在执行中标记某些点或阶段,并在剖面图中直观地看到。</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">匹配时，GHC不考虑实例声明的上下文（ &lt;code&gt;context1&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">合并类声明时，我们要求超类和方法完全匹配；但是， &lt;code&gt;MINIMAL&lt;/code&gt; 杂项在逻辑上进行&amp;ldquo;或&amp;rdquo;运算，具有默认签名的方法将与不具有默认签名的方法成功合并。</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="7f8276c2b13d74d9733b0f4b7964761949b296cc" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">当不使用基于cfg的块状布局时,布局由基本块中的最后一个跳转或cfg中块的最重出边决定。</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">当涉及到超载时,结果可能会略微反常。</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">当将任何未提升的数组类型作为参数传递给外部C调用时，外部函数会看到一个指针，该指针指向该数组的有效负载，而不是指向包含该负载的 &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; 堆对象&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;。相比之下，由 &lt;code&gt;foreign import prim&lt;/code&gt; 引入的&lt;a href=&quot;#ffi-prim&quot;&gt;外部Cmm调用&lt;/a&gt;将看到堆对象，而不仅仅是有效负载。这意味着，在某些情况下，外部C函数可能不需要RTS闭包类型的任何知识。以下示例对 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2中&lt;/a&gt;的前三个字节求和，而不使用 &lt;code&gt;Rts.h&lt;/code&gt; 中的任何内容：</target>
        </trans-unit>
        <trans-unit id="a4c7d10b77d99dca5310fa9f2e2f9dfc8d9db49c" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="translated">当将任何未提升的数组类型作为参数传递给外部C调用时，外部函数会看到一个指针，该指针指向该数组的有效负载，而不是指向包含该负载的 &lt;code&gt;StgArrBytes&lt;/code&gt; / &lt;code&gt;StgMutArrPtrs&lt;/code&gt; / &lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; 包含该数组的对象&lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;。相比之下，由 &lt;code&gt;foreign import prim&lt;/code&gt; 引入的&lt;a href=&quot;#ffi-prim&quot;&gt;外部Cmm调用&lt;/a&gt;将看到堆对象，而不仅仅是有效负载。这意味着，在某些情况下，外部C函数可能不需要RTS闭包类型的任何知识。以下示例对 &lt;code&gt;MutableByteArray#&lt;/code&gt; &lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;[2]中&lt;/a&gt;的前三个字节求和，而不使用 &lt;code&gt;Rts.h&lt;/code&gt; 中的任何内容：</target>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">在模式匹配时,每个模式匹配都会为每个存在型变量引入一个新的、不同的、类型。这些类型不能与其他类型统一,也不能逃出模式匹配的范围。例如,这些片段是不正确的。</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">在模式匹配时,这些约束条件可用于匹配主体的放电约束。例如:</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">当与从GADT提取的数据构造函数进行模式匹配时（例如在 &lt;code&gt;case&lt;/code&gt; 表达式中），适用以下规则：</target>
        </trans-unit>
        <trans-unit id="eed65a0801ab307b876b3214608b9b1af66d76f9" translate="yes" xml:space="preserve">
          <source>When preceded but not followed by whitespace, &lt;code&gt;(@)&lt;/code&gt; is treated as a visible type application.</source>
          <target state="translated">如果在 &lt;code&gt;(@)&lt;/code&gt; 之前但不带空格，则将（@）视为可见类型的应用程序。</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">当在记录构造中使用记录通配符时，仅当 &lt;code&gt;f&lt;/code&gt; 在作用域内且未在顶级导入或绑定时才初始化字段 &lt;code&gt;f&lt;/code&gt; 。例如， &lt;code&gt;f&lt;/code&gt; 可以由封闭模式匹配或let / where-binding绑定。例如</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">在报告打孔时,还要打印范围内的约束条件。例如</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">当通过给程序提供 &lt;code&gt;-hr&lt;/code&gt; 选项来请求保持器配置文件时，将生成一个图，该图由保持器集分解。保留集显示为一组成本中心堆栈；因为它通常太大而无法容纳在概要图上，所以每个保留集 &lt;code&gt;prog.prof&lt;/code&gt; 编号并在图表上以缩写形式显示及其编号，并将保留集的完整列表转储到文件prog.prof中。</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">当运行交互式控制台进程（例如Shell，基于控制台的文本编辑器或ghci）时，我们通常希望该进程被允许处理Ctl-C键盘中断，使其看起来合适。例如，尽管大多数程序只是在Ctl-C上退出，但有些程序会专门处理它。为了使这种情况发生，请在 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 选项中使用 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">在此文件中设置语言选项时，通常希望使用&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#ghci-interactive-options&quot;&gt;仅设置用于交互式评估的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">什么时候应该使用Safe Haskell推论，什么时候应该使用显式的&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志？当您对模块的安全性有严格要求时，应使用后一种情况。对于&lt;a href=&quot;#safe-use-cases&quot;&gt;Safe Haskell&lt;/a&gt;的Safe Haskell 的使用，这是最有用的：运行不受信任的代码。安全推论是由普通的Haskell程序员使用的。可能不关心Safe Haskell的用户。</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">当显示哪个标志控制一个警告时,还要显示该警告所包含的各个警告组标志。</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">在解决约束条件时,尽量利用现有的字典急于解决超类。</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">指定 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示时，所有模式的结果类型必须彼此一致。这是一个健全性检查，因为如果类型不一致，则不可能在所有模式上都匹配。</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 明确指定模式同义词的类型时，通用性，存在性或其上下文之一可以保留为空。</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 明确指定模式同义词的类型时，通用性，存在性或其上下文之一可以保留为空。</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">当在断点或单步停止时，GHCi将变量 &lt;code&gt;_result&lt;/code&gt; 绑定到当前活动表达式的值。 &lt;code&gt;_result&lt;/code&gt; 的值可能尚不可用，因为我们已停止对其求值，但是可以强制使用：如果类型已知且可显示，则只需在提示符下输入 &lt;code&gt;_result&lt;/code&gt; 即可显示它。但是，这样做有一个警告：评估 &lt;code&gt;_result&lt;/code&gt; 可能会触发更多的断点，从我们当前停在的断点开始（如果我们停在一个实际的断点，而不是由于&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt;）。因此，在评估 &lt;code&gt;_result&lt;/code&gt; 时可能有必要立即发出&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt;。另外，您可以使用&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;忽略断点。</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">当在断点处停止时，如果尝试评估已经在评估中的变量，则第二次评估将挂起。原因是GHC知道该变量正在评估中，因此新评估只是在继续之前等待结果，但是这当然不会发生，因为第一个评估在断点处停止。Control-C可以中断挂起的评估并返回提示。</target>
        </trans-unit>
        <trans-unit id="41f4622c9a9bbe02a9f4c027c4d5d4cd516225b4" translate="yes" xml:space="preserve">
          <source>When surrounded by whitespace on both sides, &lt;code&gt;(@)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="translated">当两边都由空格包围时， &lt;code&gt;(@)&lt;/code&gt; 将被GHC视为常规的中缀运算符。</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">当&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;启用标志，模块是否被信任的依赖，如果某些包是值得信赖的。包信任度由客户端C调用GHC（即您）决定。</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">当使用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志时&lt;em&gt;，客户机C信任来自程序包P&lt;/em&gt;的&lt;em&gt;模块M，&lt;/em&gt;并且仅在以下情况下：</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 时，GHCi将忽略任何预编译的目标代码并解释该模块。如果您已经加载了许多模块作为目标代码并决定要解释其中的一个模块，则可以使用 &lt;code&gt;:add *M&lt;/code&gt; 指定要解释的 &lt;code&gt;M&lt;/code&gt; （而不是重新加载整个模块）（请注意，这也可能导致其他模块也被解释，因为编译后的模块不能依赖于已解释的模块。</target>
        </trans-unit>
        <trans-unit id="aedbc26d9c8b6dfa0d4dad036dcef71afa8bd612" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-haddock&lt;/code&gt; option is enabled, GHC collects documentation comments and associates them with declarations, function arguments, data constructors, and other syntactic elements. Documentation comments in invalid positions are discarded:</source>
          <target state="translated">当 &lt;code&gt;-haddock&lt;/code&gt; 选项启用，GHC收集文档的评论和他们的声明，函数参数，数据构造，以及其他句法成分同伙。无效位置的文档注释将被丢弃：</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">当 &lt;code&gt;GADTSyntax&lt;/code&gt; 启用扩展，GHC允许你通过给构造函数的类型签名明确地声明一个代数数据类型。例如：</target>
        </trans-unit>
        <trans-unit id="9df18db363cd1745ba8506093666b4dbb4c8cd67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;InterruptibleFFI&lt;/code&gt; 启用扩展，外国通话可以与注释 &lt;code&gt;interruptible&lt;/code&gt; ，而不是 &lt;code&gt;safe&lt;/code&gt; 或 &lt;code&gt;unsafe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">当 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展导通时，上述7分表示法脱糖如下：</target>
        </trans-unit>
        <trans-unit id="b88d963a673ec0ba32ba448653b0c170c75e2ae9" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;exts/template_haskell#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;exts/template_haskell#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">当编译器类型检查源代码时，&lt;a href=&quot;exts/template_haskell#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices和&lt;a href=&quot;exts/template_haskell#th-quasiquotation&quot;&gt;Template Haskell Quasi-quote&lt;/a&gt;将替换为从它们生成的语法树片段。但是，对于在源代码上运行的工具，代码生成器通常比生成的代码更有趣。因此，我们包括了 &lt;code&gt;spliceRunAction&lt;/code&gt; 。在对每个表达式求值之前，将调用该字段。输入经过类型检查，因此语义信息可用于这些语法树片段。如果返回其他表达式，则可以更改生成的代码。</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">当编译器类型检查源代码时，&lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices和&lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quote&lt;/a&gt;将替换为从它们生成的语法树片段。但是，对于在源代码上运行的工具，代码生成器通常比生成的代码更有趣。因此，我们包括了 &lt;code&gt;spliceRunAction&lt;/code&gt; 。在评估每个表达式之前，将在每个表达式上调用此字段。输入经过类型检查，因此语义信息可用于这些语法树片段。如果返回其他表达式，则可以更改生成的代码。</target>
        </trans-unit>
        <trans-unit id="7155c3fb192924591b079e548fd800bda9de1a0b" translate="yes" xml:space="preserve">
          <source>When the demand analysis thinks that the scrutinee does not return (i.e. a bottoming expression)</source>
          <target state="translated">当需求分析认为被审查人不返回时(即抄底的表现)</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">当标志&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;设置为大于 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 时，GHC将提供有效细化孔配合的列表，这些有效细化配合是需要最多 &lt;code&gt;n&lt;/code&gt; 级附加细化的有效孔配合。为完整起见，其中每个层代表孔配合中需要填充的另一个孔。例如，考虑</target>
        </trans-unit>
        <trans-unit id="2ede94233945ceef730a5c52baafcf873f723c3a" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">启用标志&lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; 时&lt;/a&gt;，将报告左侧模式中提及但右侧未使用的类型变量。在左侧多次出现的变量也被视为已使用。为禁止显示警告，未使用的变量应替换为下划线或以下划线作为前缀。以下划线（ &lt;code&gt;_x&lt;/code&gt; ）开头的类型变量被视为普通类型变量。</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">启用标志&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; 时&lt;/a&gt;，将报告左侧模式中提及但右侧未使用的类型变量。左侧多次出现的变量也被视为已使用。为禁止显示警告，未使用的变量应替换为下划线或以下划线开头。以下划线（ &lt;code&gt;_x&lt;/code&gt; ）开头的类型变量被视为普通类型变量。</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">当最后一个类型参数具有幻像角色（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;）时，将不会使用通常的算法来生成派生的 &lt;code&gt;Functor&lt;/code&gt; 实例。相反，整个值将被强制。</target>
        </trans-unit>
        <trans-unit id="d0534d81c2091ec317265f39796ac46bfc114919" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">当最后一个类型参数具有幻像角色（请参见&lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;）时，将不会使用通常的算法来生成派生的 &lt;code&gt;Functor&lt;/code&gt; 实例。相反，整个值将被强制。</target>
        </trans-unit>
        <trans-unit id="5c0e2720d4d44b6279dbfb5714c776d53f456b2a" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt;, the effect in question is to short-circuit the computation on encountering &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当monad &lt;strong&gt; &lt;code&gt;m&lt;/code&gt; &lt;/strong&gt;为 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 时，所讨论的效果是在遇到 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 时使计算短路。</target>
        </trans-unit>
        <trans-unit id="fbd7b3ed9f72374ca75e11634d478bca8f1e358c" translate="yes" xml:space="preserve">
          <source>When the monad &lt;strong&gt;&lt;code&gt;m&lt;/code&gt;&lt;/strong&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, applying &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; to a list of IO actions, performs each in turn, returning a list of the results:</source>
          <target state="translated">当monad &lt;strong&gt; &lt;code&gt;m&lt;/code&gt; &lt;/strong&gt;为 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 时，将 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 应用于IO操作列表，依次执行每个操作，并返回结果列表：</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">当数据或类型实例声明的类型参数的名称无关紧要时，可以将其替换为下划线（ &lt;code&gt;_&lt;/code&gt; ）。这与编写具有唯一名称的类型变量相同。</target>
        </trans-unit>
        <trans-unit id="9438e464295e0f808c720323652b4fe168da340b" translate="yes" xml:space="preserve">
          <source>When the operator is always strict in the second argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` is generally a better choice than &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. When &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; is called with a strict operator, evaluation cannot begin until the last element is reached, by which point a deep stack of pending function applications may have been built up in memory.</source>
          <target state="translated">当运算符在第二个参数中始终严格时，与 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相比， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 通常是更好的选择。当使用严格的运算符调用 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 时，直到到达最后一个元素，评估才可以开始，这时可能已在内存中建立了一大堆待处理的函数应用程序。</target>
        </trans-unit>
        <trans-unit id="3a9f4c1ad6996c1901a0ec2fced4b4100819215e" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">当程序与&lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接时，可以同时从多个OS线程调用 &lt;code&gt;foreign export&lt;/code&gt; 函数。必须像往常一样通过调用 &lt;code&gt;hs_init()&lt;/code&gt; 初始化运行时系统，并且此调用必须在调用任何 &lt;code&gt;foreign export&lt;/code&gt; 函数之前完成。</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">当程序与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接时，可以同时从多个OS线程调用 &lt;code&gt;foreign export&lt;/code&gt; 函数。必须像往常一样通过调用 &lt;code&gt;hs_init()&lt;/code&gt; 初始化运行时系统，并且此调用必须在调用任何 &lt;code&gt;foreign export&lt;/code&gt; 函数之前完成。</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">当程序与&lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt;选项（&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）链接在一起时，可以通过以下几种方式记录运行时事件：</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">当未设置细化级别时,它将只提供有效的孔洞配合建议。</target>
        </trans-unit>
        <trans-unit id="bdff41ed009289d642a16083019ce0168e38ec29" translate="yes" xml:space="preserve">
          <source>When the scrutinee is a GADT and its type rules out some constructors, and others constructors are already handled by the case expression.</source>
          <target state="translated">当被审查者是一个GADT,并且它的类型排除了一些构造函数,而其他构造函数已经被case表达式处理了。</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">当 &lt;code&gt;do&lt;/code&gt; 表达式的语句之间具有依赖关系，而 &lt;code&gt;ApplicativeDo&lt;/code&gt; 无法推断出 &lt;code&gt;Applicative&lt;/code&gt; 类型时，它将使用启发式算法尝试尽可能多地使用 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 。该算法通常找到最佳解决方案，但是在极少数复杂的情况下，它可能会错失良机。有一种算法可以找到最佳解决方案，作为一种选择提供：</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">当类型没有构造函数时，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;将派生其可能的最懒实例。</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;派生一个琐碎的实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 会强制&lt;/a&gt;其参数。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="df5cd675628ff7edd99330931c3924f3651bb0c8" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参见&lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;派生一个琐碎的实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="589660ea440e8fa723f008c0478d09f535adede3" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参阅&lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 会强制&lt;/a&gt;其参数。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">当用户写入</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="translated">当存在右侧时，GHC会推断出与右侧一致的最多态类型。示例：普通数据类型和GADT声明，类声明。在类声明的情况下，&amp;ldquo;右手侧&amp;rdquo;的角色由类方法签名来扮演。</target>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="translated">当没有右手边时，GHC将参数和结果类型默认为 &lt;code&gt;Type&lt;/code&gt; ，除非由种类签名另外指示。示例：数据和开放类型族声明。</target>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">当在一系列语句中存在严格的模式匹配时， &lt;code&gt;ApplicativeDo&lt;/code&gt; 在该语句和其后的语句之间放置 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。可以将序列转换为在其他地方使用 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; ，但是严格模式匹配和以下语句将始终与 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 连接，以保留与标准do-notation相同的严格语义。如果你不希望这样，干脆把 &lt;code&gt;~&lt;/code&gt; 上的图案搭配，使其懒惰。</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">启用此标志并&lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt;，块布局的行为与8.6及更早版本中的相同。</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">当该标志被设置时，可变 &lt;code&gt;it&lt;/code&gt; 不再被设置为先前计算的表达式的结果。</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">启用此优化后,代码生成器将把所有的自递归饱和尾部调用变成局部跳转,而不是函数调用。</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">启用此选项后，将使用操作系统提供的用于设置线程关联性的API将功能\（i \）的OS线程绑定到CPU内核\（i \）。例如在Linux上，GHC使用 &lt;code&gt;sched_setaffinity()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">当这个选项被给出，中间浮点值可以具有&lt;em&gt;更大的&lt;/em&gt;精度/范围比最终类型。通常，这是一件好事，但是某些程序可能依赖于 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 值的精确精度/范围，并且不应在编译时使用此选项。</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">当启用该警告时,将验证以下条件。</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">启用时，您可以使用&lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt;在每个模块的基础上禁止它。有时，您可能特别希望某个函数具有比必要的约束更严格的签名，或者可能使自己留有余地来更改实现而不更改API。在这种情况下，您可以使用无效绑定中的调用按功能禁用警告。例如：</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">在对模块进行类型检查时，GHC会在约束解决方案开始之前调用 &lt;code&gt;tcPluginInit&lt;/code&gt; 。这允许插件在上下文中查找内容，初始化可变状态或打开与外部进程（例如外部SMT求解器）的连接。插件可以返回喜欢的任何类型的结果，该结果将传递到其他两个字段。</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">在对 &lt;code&gt;F a&lt;/code&gt; 的实例声明进行类型检查时，我们需要检查 &lt;code&gt;F&lt;/code&gt; 的超类 &lt;code&gt;C&lt;/code&gt; 是否成立。因此，我们尝试在包含以下理论的理论下约束 &lt;code&gt;C a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ec95daf87bcd42f783483d51860a38231b97dbf8" translate="yes" xml:space="preserve">
          <source>When used as a value, &lt;code&gt;MkT1&lt;/code&gt; is given a multiplicity-polymorphic type: &lt;code&gt;MkT1 :: forall {m} a. a %m -&amp;gt; T1 a&lt;/code&gt;. This makes it possible to use &lt;code&gt;MkT1&lt;/code&gt; in higher order functions. The additional multiplicity argument &lt;code&gt;m&lt;/code&gt; is marked as inferred (see &lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so that there is no conflict with visible type application. When displaying types, unless &lt;code&gt;-XLinearTypes&lt;/code&gt; is enabled, multiplicity polymorphic functions are printed as regular functions (see &lt;a href=&quot;#printing-linear-types&quot;&gt;Printing multiplicity-polymorphic types&lt;/a&gt;); therefore constructors appear to have regular function types.</source>
          <target state="translated">当用作值时， &lt;code&gt;MkT1&lt;/code&gt; 被指定为多重多态类型： &lt;code&gt;MkT1 :: forall {m} a. a %m -&amp;gt; T1 a&lt;/code&gt; 。这样就可以在更高阶的功能中使用 &lt;code&gt;MkT1&lt;/code&gt; 。附加的多重性参数 &lt;code&gt;m&lt;/code&gt; 被标记为推断（请参阅&lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;推断与指定类型变量&lt;/a&gt;），因此与可见类型应用程序不存在冲突。显示类型时，除非启用 &lt;code&gt;-XLinearTypes&lt;/code&gt; ，否则多重性多态函数将作为常规函数&lt;a href=&quot;#printing-linear-types&quot;&gt;打印&lt;/a&gt;（请参阅打印多重性-多态类型）；因此，构造函数似乎具有常规的函数类型。</target>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">当与&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;结合使用时，我们交换衍生实例所基于的实例​​和定义实例的顺序，例如：</target>
        </trans-unit>
        <trans-unit id="199505ee33e09e03773bf8a7300953a302a36417" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="translated">当与&lt;a href=&quot;standalone_deriving#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;结合使用时，我们交换衍生实例所基于的实例​​和定义实例的顺序，例如：</target>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">使用时，使用safe关键字导入的模块必须是受信任的模块，否则将发生编译错误。通过 &lt;code&gt;-XSafe&lt;/code&gt; ， &lt;code&gt;-XTrustworthy&lt;/code&gt; 或 &lt;code&gt;-XUnsafe&lt;/code&gt; 标志之一启用安全导入扩展。使用 &lt;code&gt;-XSafe&lt;/code&gt; 标志时， &lt;code&gt;safe&lt;/code&gt; 关键字是允许的，但没有意义，因为每次导入都被视为安全导入。</target>
        </trans-unit>
        <trans-unit id="1487a7894277e2151eefd4c6ac81aaf61e058adb" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;../utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">在 &lt;code&gt;.hsc&lt;/code&gt; 文件中使用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;（或其他使用哈希符号的扩展名）时（请参阅&lt;a href=&quot;../utils#hsc2hs&quot;&gt;将Haskell接口写入C代码：hsc2hs&lt;/a&gt;），必须将哈希符号加倍（用 &lt;code&gt;##foo&lt;/code&gt; 代替 &lt;code&gt;#foo&lt;/code&gt; ）以避免它们。被视为 &lt;code&gt;hsc2hs&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">在 &lt;code&gt;.hsc&lt;/code&gt; 文件中使用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;（或其他使用哈希符号的扩展名）时（请参阅&lt;a href=&quot;utils#hsc2hs&quot;&gt;将Haskell接口写入C代码：hsc2hs&lt;/a&gt;），必须将哈希符号加倍（用 &lt;code&gt;##foo&lt;/code&gt; 代替 &lt;code&gt;#foo&lt;/code&gt; ）以避免它们。被视为 &lt;code&gt;hsc2hs&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">当使用 &lt;code&gt;-dyno&lt;/code&gt; &lt;code&gt;-dynamic-too&lt;/code&gt; ，选项-dyno， &lt;code&gt;-dynosuf&lt;/code&gt; 和 &lt;code&gt;-dynhisuf&lt;/code&gt; 分别是 &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-osuf&lt;/code&gt; 和 &lt;code&gt;-hisuf&lt;/code&gt; 的对应项，但适用于动态编译。</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">使用 &lt;code&gt;capi&lt;/code&gt; 时，也可以导入值而不是函数。例如，</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">使用 &lt;code&gt;par&lt;/code&gt; 时，一般的经验法则是应在稍后的时间（而不是太快的时间）内进行触发计算。同样，引发的计算不应太小，否则，相对于所获得的并行度，并行分叉的代价将太大。在实践中弄清这些因素是棘手的。</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">当使用文件式交互时,如果在输入字符后立即有一个新行,则会被读取。</target>
        </trans-unit>
        <trans-unit id="e3b100300996ccb1d75762df35aa37649891a202" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, consumes a single character from the input which may be non-printable.</source>
          <target state="translated">当使用文件式交互时,从输入中消耗一个可能是不可打印的字符。</target>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">使用文件样式交互时，如果在读取任何字符之前遇到 &lt;code&gt;EOF&lt;/code&gt; ，则这些函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="4a4385a77afcebb26e3a91b60eea37d30d0eaa80" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">使用文件样式交互时，如果在读取任何字符之前遇到 &lt;code&gt;EOF&lt;/code&gt; ，则它们将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="8389a66f0ad124cb25ad8df28bee52913fc4af75" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">使用文件样式交互时，如果在读取任何字符之前遇到 &lt;code&gt;EOF&lt;/code&gt; ，则它们将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">当使用文件式交互时,该功能在读取输入行时关闭回声。</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">在使用记录时,通常会写一个模式,绑定一个与记录字段同名的变量,如:。</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">当使用终端式交互时,将不等待换行而读取字符。</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">使用终端风格的交互时，如果用户在输入文本为空时按下 &lt;code&gt;Ctrl-D&lt;/code&gt; ，则这些函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="bd410ab3f115e8c24b1b1823fdc91cadf6703bb8" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">使用终端风格的交互时，如果用户在输入文本为空时按下 &lt;code&gt;Ctrl-D&lt;/code&gt; ，则它们将返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab6cf8901d69d58a7db8d885c6657768b53b72bb" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">使用终端风格的交互时，如果用户在输入文本为空时按下 &lt;code&gt;Ctrl-D&lt;/code&gt; ，则它们将返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="translated">使用标志&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 时,&lt;/a&gt; GHC将使用管道生成并与单独的进程进行通信。在某些情况下（例如，在交叉编译时），通过网络进行通信比较有利。GHC为此提供了两个实用程序，可以在 &lt;code&gt;utils&lt;/code&gt; 目录中找到它们。</target>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="translated">当值被用作FFI调用的参数时,即为</target>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">当值在可能不同的机器上运行的不同进程之间进行通信时,地址不再有用,因为每个进程可能使用不同的地址来存储一个给定的值。</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">当我们稍后渲染时,我们会发现这个单元格将跨越多少列或多少行,并可以包含正确的colspan/rowspan命令。</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">写入重载标签时，哈希符号和以下标识符之间必须没有空格。该&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展使用的后缀哈希迹象; 如果同时启用了&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;x#y&lt;/code&gt; 表示 &lt;code&gt;x# y&lt;/code&gt; ，但是如果仅启用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;，则表示 &lt;code&gt;x #y&lt;/code&gt; 。该&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;延伸品牌 &lt;code&gt;(#&lt;/code&gt; 单一语义，所以当&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;启用你必须写一个左括号和一个重载的标签之间的空间，为避免混淆，强烈建议您使用时哈希前加一个空格&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f28f79b3dd940bfa9b2672d60198c0f52c740d0" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">写入重载标签时，哈希符号和以下标识符之间必须没有空格。该&lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展使用的后缀哈希迹象; 如果同时启用了&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;x#y&lt;/code&gt; 表示 &lt;code&gt;x# y&lt;/code&gt; ，但是如果仅启用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;，则表示 &lt;code&gt;x #y&lt;/code&gt; 。该&lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;延伸品牌 &lt;code&gt;(#&lt;/code&gt; 单一语义，所以当&lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;启用你必须写一个左括号和一个重载的标签之间的空间，为避免混淆，强烈建议您使用时哈希前加一个空格&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1502eef4e2dbb983597804aed463fbf9bc83e3f7" translate="yes" xml:space="preserve">
          <source>When written in non-prefix form, &lt;code&gt;(~)&lt;/code&gt; is treated by GHC as a regular infix operator.</source>
          <target state="translated">当以非前缀形式编写时，GHC将 &lt;code&gt;(~)&lt;/code&gt; 视为常规的前缀运算符。</target>
        </trans-unit>
        <trans-unit id="ca0f36236024c993c6fded09cd7fee1e5abbb48f" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;exts/primitives#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">当您&lt;em&gt;真正&lt;/em&gt;渴望获得速度时，您想直接进入&amp;ldquo;原始&amp;rdquo;状态。请参阅&lt;a href=&quot;exts/primitives#glasgow-unboxed&quot;&gt;无盒装类型&lt;/a&gt;有关使用未装箱的类型的一些信息。</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">当您&lt;em&gt;真的&lt;/em&gt;急于追求速度时，又想直接了解&amp;ldquo;原始数据&amp;rdquo;。请参阅&lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;无盒装类型&lt;/a&gt;有关使用未装箱的类型的一些信息。</target>
        </trans-unit>
        <trans-unit id="aa3258481b642a9c233d877f43b12650ffee34bb" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">当您调用一个注释为 &lt;code&gt;safe&lt;/code&gt; （默认）的 &lt;code&gt;foreign import&lt;/code&gt; 函数，并且使用&lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接了程序时，该调用将与其他正在运行的Haskell线程同时运行。如果程序是在没有&lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; 的&lt;/a&gt;情况下链接的，则其他Haskell线程将被阻塞，直到调用返回。</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">当您调用一个被标注为 &lt;code&gt;safe&lt;/code&gt; （默认）的 &lt;code&gt;foreign import&lt;/code&gt; 函数，并且该程序使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接时，该调用将与其他正在运行的Haskell线程同时运行。如果程序链接时没有&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;，则其他Haskell线程将被阻塞，直到调用返回。</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">当你编译一个包含Template Haskell拼接的简单模块时。</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">当您编译导入 &lt;code&gt;Wibble&lt;/code&gt; 的任何模块时，GHC将打印指定的消息。</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">当你编译任何导入和使用任何指定实体的模块时,GHC将打印指定的消息。</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">当您使用 &lt;code&gt;newtype&lt;/code&gt; 定义抽象类型时，您可能希望新类型从其表示形式继承某些实例。在Haskell 98中，可以通过派生它们继承 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Enum&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; 的实例，但是对于任何其他类，您都必须编写一个显式的实例声明。例如，如果您定义</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">将Haskell源模块加载到GHCi中时，通常会将其转换为字节码并使用解释器运行。但是，解释的代码也可以与GHCi中的编译代码一起运行。实际上，通常在GHCi启动时，它会加载 &lt;code&gt;base&lt;/code&gt; 包的编译副本，其中包含 &lt;code&gt;Prelude&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="translated">当你编译一个包含以下内容的模块时</target>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">当你在提示下键入一个表达式时,GHCi会立即评估并打印结果。</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">当你在提示下键入一个表达式时,哪些标识符和类型在范围内?GHCi提供了一种灵活的方式来控制表达式的上下文是如何构造的。</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">当您使用模式匹配时,绑定变量现在可能具有多态类型。例如</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">当您要获取资源时，请先进行一些处理，然后再释放资源，最好使用方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，因为在发生异常的情况下，方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将安装必要的异常处理程序以释放资源。计算。如果引发异常，则 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将重新引发异常（执行发行后）。</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">当您要获取资源时，请先进行一些处理，然后再释放资源，最好使用方 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，因为在发生异常的情况下，方 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将安装必要的异常处理程序以释放资源。计算。如果引发异常，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将重新引发异常（执行发行后）。</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">当您想要定义需要有关源代码的语义信息的插件时，请使用 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 字段。例如，如果您的插件必须确定两个名称是否引用相同的定义，或者必须检查使用语义信息的函数的类型。在这种情况下，您需要使用 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 或 &lt;code&gt;renamedResultAction&lt;/code&gt; 访问语法树的重命名或类型检查版本。</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">当您想要定义使用源代码语法树的插件时，您想覆盖 &lt;code&gt;parsedResultAction&lt;/code&gt; 字段。通过此访问点，您可以访问源代码中有关词法标记和注释以及已编译模块的原始语法树的信息。</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">当您的Haskell程序启动时，RTS会提取在 &lt;code&gt;+RTS&lt;/code&gt; 和 &lt;code&gt;-RTS&lt;/code&gt; 之间括起来的命令行参数。例如：</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">每当在提示符下键入表达式（准确地说是非绑定语句）时，GHCi就会将其值隐式绑定到变量 &lt;code&gt;it&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">每当没有导出列表而定义了一个数据实例时,不管数据族是在本地还是在其他模块中定义的,对应的数据族类型构造函数都会和新的数据构造函数一起导出。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">凡 &lt;code&gt;@Int&lt;/code&gt; 采用可见式应用（&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型的应用程序&lt;/a&gt;），以实例化 &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 。为了使此类型应用程序正常工作， &lt;code&gt;bar&lt;/code&gt; 的默认类型签名必须与非默认签名具有相同的类型变量顺序！但是， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;C'&lt;/code&gt; 不必相同（例如，参见上面依赖此的 &lt;code&gt;Enum&lt;/code&gt; 示例）。</target>
        </trans-unit>
        <trans-unit id="b024d670d888125fe31e9ca369b232e66906c997" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">凡 &lt;code&gt;@Int&lt;/code&gt; 采用可见式应用（&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;可见类型的应用程序&lt;/a&gt;），以实例化 &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 。为了使此类型应用程序正常工作， &lt;code&gt;bar&lt;/code&gt; 的默认类型签名必须与非默认签名具有相同的类型变量顺序！但是， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;C'&lt;/code&gt; 不必相同（例如，参见上面依赖此的 &lt;code&gt;Enum&lt;/code&gt; 示例）。</target>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="translated">其中 &lt;code&gt;TypedHole&lt;/code&gt; 包含有关生成错误时GHC可用的孔的所有信息。</target>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">其中 &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; 是 &lt;code&gt;TcHoleErrors&lt;/code&gt; 模块中提供的便捷函数，用于定义不需要内部状态的插件。</target>
        </trans-unit>
        <trans-unit id="fa5a8e5564838fc8779ef3e81fff81e304d2dcad" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convenience function provided in the &lt;code&gt;GHC.Tc.Errors.Hole&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="translated">其中 &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; 是 &lt;code&gt;GHC.Tc.Errors.Hole&lt;/code&gt; 模块中提供的便捷函数，用于定义不需要内部状态的插件。</target>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">其中 &lt;code&gt;v&lt;/code&gt; 是二进制编码的数据结构。为了重建原始数据，我们使用 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1498debcd36b3f6ddc4c5309c7855ee018a92837" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions in instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">在GHC允许实例声明中进行扩展的地方，我们允许对这种新形式的 &lt;code&gt;class&lt;/code&gt; 进行完全相同的扩展。具体来说，使用&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;，语法变为</target>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="translated">在GHC允许扩展实例声明的地方，我们允许对这种新形式的 &lt;code&gt;class&lt;/code&gt; 进行完全相同的扩展。具体来说，使用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;，语法变为</target>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">在GHC允许扩展实例声明的地方，我们允许对这种新形式的 &lt;code&gt;class&lt;/code&gt; 进行完全相同的扩展。具体来说，使用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; ，语法变为</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">在可能的情况下，应用程序应该改用普通公共接口模块中的函数，例如&lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;。在较低级别扩展ByteString系统的软件包将需要使用此模块。</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">在哪里可以找到用户提供的库...在目录dir之前添加库目录路径。</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">在每个行输入会话的开始和结束时,在哪里读/写历史记录。</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">其中⟨identifier⟩命名当前加载到GHCi中的解释模块中的任何顶层函数(可以使用限定名)。断点将设置在函数的主体上,当函数完全应用时,但在任何模式匹配发生之前。</target>
        </trans-unit>
        <trans-unit id="30f47faad399154cde4ee06e55aadb6d6a7579b0" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied. If the function has several patterns, then a breakpoint will be set on each of them.</source>
          <target state="translated">其中⟨identifier⟩命名当前加载到GHCi中的解释模块中的任何顶级函数(可以使用限定名称)。当函数被完全应用时,断点将被设置在函数主体上。如果函数有多个模式,那么断点将设置在每个模式上。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">在Haskell中，人们可以将 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 视为包含或产生价值的事物，而逆变Functor是可以被视为&lt;em&gt;消费&lt;/em&gt;价值的Functor的事物。</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">列表可以是有限的，也可以是无限的，而序列始终是有限的。结果，序列的长度严格。忽略效率，您可以想象定义了 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64e17f12cf0a73293ad82b3caa4fe2b94113c0b3" translate="yes" xml:space="preserve">
          <source>Whether a data constructor field is linear or not can be customized using the GADT syntax. Given</source>
          <target state="translated">数据构造函数字段是否是线性的,可以使用GADT语法自定义。给定</target>
        </trans-unit>
        <trans-unit id="d859ca679c3f9519d633fadbe164a6690aa53bfc" translate="yes" xml:space="preserve">
          <source>Whether a fold is recursive, corecursive or short-circuiting can depend on both the method chosen to perform the fold and on the operator passed to that method (which may be implicit, as with the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; method of a monoid instance).</source>
          <target state="translated">折叠是递归，核心递归还是短路可以取决于选择执行折叠的方法和传递给该方法的运算符（与隐式实例的 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 方法一样是隐式的）。</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">超线程核心是否应该被计算,这是一个开放性的问题;请自由实验,让我们知道你发现的结果。</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">成本中心是否为恒定申请表格(CAF)</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">匹配是来自原始数据构造函数集还是来自 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示（优先于前者而不是后者）</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">这是否成立取决于你所使用的GHC版本,你所使用的平台,你所使用的数据,以及你所使用的编码,所以一定要自己测试。</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">这个词后面是否要加空格、尾引号等。</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">是否坚持正数加号。</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">是将字段左调整还是零填充。这些是互斥的，其中 &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; 优先。</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">是否显示原始源代码的片段</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">检查 &lt;code&gt;f&lt;/code&gt; 中模式的覆盖范围时应使用哪个 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示？如果我们选择的 &lt;code&gt;COMPLETE&lt;/code&gt; 集合覆盖 &lt;code&gt;MkT1&lt;/code&gt; 和 &lt;code&gt;MkT2&lt;/code&gt; ，然后 &lt;code&gt;f&lt;/code&gt; 是详尽的，但如果我们选择其他 &lt;code&gt;COMPLETE&lt;/code&gt; 集，涵盖 &lt;code&gt;MkT1&lt;/code&gt; 和 &lt;code&gt;MkT2Internal&lt;/code&gt; ，然后 &lt;code&gt;f&lt;/code&gt; 是&lt;em&gt;没有&lt;/em&gt;穷尽的，因为它不能匹配 &lt;code&gt;MkT2Internal&lt;/code&gt; 。解决此难题的一种直观方法是认识到选择前一个 &lt;code&gt;COMPLETE&lt;/code&gt; 集会产生最少数量的未发现模式子句，因此是更好的选择。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fbd9610ee671b95cb3c4896a6a1d851665229835" translate="yes" xml:space="preserve">
          <source>Which can, for example, be specialised to number ranges:</source>
          <target state="translated">例如,可以专门用于数字范围。</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">这使得我们能够以更简洁的风格重写我们的函数。</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">哪一代人在收集垃圾。</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">这表明该孔可以替换为 &lt;code&gt;foldl1 _&lt;/code&gt; 。在不固定孔的同时，这可以帮助用户了解他们有哪些选择。</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">这将产生以下编译时错误。</target>
        </trans-unit>
        <trans-unit id="32045914aee96128fc2bfd16f50a2982f4ee64c2" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is required for type variables from the top of a class or instance declaration to scope over the /bodies/ of the methods, it is not required for the type variables to scope over the /type signatures/ of the methods. For example, the following will be accepted without explicitly enabling &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">虽然&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;需要类型变量从一个类或实例声明顶部的范围在/机构/方法，它不需要类型变量的范围在/类型签名/方法。例如，在不显式启用&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; 的&lt;/a&gt;情况下将接受以下内容：</target>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">虽然 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 将强制评估所有列表元素：</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; 允许通过具有匹配的单引号或双引号集来使用引号（即，方便地转义多个字符），但 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; 不使用引号机制，因此将始终转义任何空白，引号和反斜杠。</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">当 &lt;code&gt;INLINE&lt;/code&gt; 说&amp;ldquo;请向我内联&amp;rdquo;时， &lt;code&gt;INLINABLE&lt;/code&gt; 说&amp;ldquo;请随意向我内联；自行决定&amp;rdquo;。换句话说，选择权留给了GHC，它使用与无编译功能相同的规则。与 &lt;code&gt;INLINE&lt;/code&gt; 不同，该决定是在&lt;em&gt;呼叫站点&lt;/em&gt;做出的，因此会受到内联阈值，优化级别等的影响。</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">当 &lt;code&gt;a + b&lt;/code&gt; 被解析为 &lt;code&gt;(+) a b&lt;/code&gt; 并成为 &lt;code&gt;(+)&lt;/code&gt; 类型运算符的绑定位置时， &lt;code&gt;a * b&lt;/code&gt; 被解析为 &lt;code&gt;a (*) b&lt;/code&gt; 并被拒绝。</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">尽管 &lt;code&gt;n&lt;/code&gt; 在不引入 &lt;code&gt;k&lt;/code&gt; 的情况下使用k，因此违反了规则，但当前已被接受。这是因为 &lt;code&gt;k&lt;/code&gt; 在 &lt;code&gt;n&lt;/code&gt; 被认为是一种可变的，因为它在一种出现签名。实际上，类型变量和种类变量之间的界线是模糊的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">虽然GHC热衷于内嵌函数,但并不盲目内嵌。例如,如果你写</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">尽管Safe Haskell是扩展，但实际上它在GHC的每次编译中都在后台运行。它这样做是为了跟踪模块的类型冲突，以推断其安全性，即使它们未明确使用Safe Haskell也是如此。有关更多详细信息，请参阅&amp;ldquo; &lt;a href=&quot;#safe-inference&quot;&gt;安全Haskell推论&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">尽管Safe Haskell的主要用例正在运行不受信任的代码，但Safe Haskell不会直接提供此代码。相反，Safe Haskell提供了严格的类型安全性。没有Safe Haskell，GHC会允许类型系统有许多异常，这些异常可以颠覆任何抽象。通过提供严格的类型安全性，Safe Haskell使开发人员能够构建自己的库级别沙箱机制来运行不受信任的代码。</target>
        </trans-unit>
        <trans-unit id="def095ee0284bcac4322f43e6852c970ad41b290" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="translated">虽然独立的种类签名确定类型构造函数的种类，但它不能确定其构造性。这对于类型族和类型同义词尤为重要，因为它们不能部分应用。有关Arity的更多信息，请参见&lt;a href=&quot;#type-family-declarations&quot;&gt;类型家族声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0727c03f093cd8f954da72e1d96477371ae2259" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;type_families#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="translated">虽然独立的种类签名确定类型构造函数的种类，但它不能确定其构造性。这对于类型族和类型同义词尤为重要，因为它们不能部分应用。有关Arity的更多信息，请参见&lt;a href=&quot;type_families#type-family-declarations&quot;&gt;类型家族声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">在开发时,有时即使代码中存在类型错误,也希望允许编译成功。考虑以下情况。</target>
        </trans-unit>
        <trans-unit id="c76bcc0e915bb7788c67f5c0d7c2f5a80c7fcbb7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;../ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="translated">虽然通过&lt;a href=&quot;../ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令在GHCi中加载的模块可以使用&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;static&lt;/code&gt; 表达式，但是在REPL上输入的语句则可以不使用。这是GHCi的局限性；有关详情，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;＃12356&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="91465cfe2041d24f0183967b4edb1cd4e56225f7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="translated">虽然通过&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令在GHCi中加载的模块可以使用&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;static&lt;/code&gt; 表达式，但是在REPL上输入的语句则可以不使用。这是GHCi的局限性；有关详情，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;＃12356&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">虽然通过&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令在GHCi中加载的模块可以使用&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;static&lt;/code&gt; 表达式，但在REPL上输入的语句可能不使用。这是GHCi的局限性；有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;问题＃12356&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">在运行程序时,如果开启了剖析功能,GHC会在幕后维护一个成本中心堆栈,并将任何成本(内存分配和时间)归因于成本发生时的任何当前成本中心堆栈。</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在我们先前设置的第2行的断点处停止时，我们使用 &lt;code&gt;:step qsort [1,3]&lt;/code&gt; 开始了新的评估。第一步（在 &lt;code&gt;qsort&lt;/code&gt; 的定义下）后，此新评估停止。提示已更改，现在以 &lt;code&gt;...&lt;/code&gt; 开头，以指示存在已保存的断点，超出了当前的断点。要查看上下文堆栈，请使用&lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="dc8800b1f9d492207f0fef148c021ca763c0e0d1" translate="yes" xml:space="preserve">
          <source>While the examples below are not necessarily the most optimal definitions of the intended functions, they are all cases in which &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` is far more appropriate (as well as more efficient) than the lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管下面的示例不一定是预期功能的最佳定义，但在所有情况下， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `比惰性 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 更合适（也更有效）。</target>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">虽然下列定义被拒绝:</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">尽管这些是标志，但它们也对应于模块可以具有的Safe Haskell模块类型。您可以考虑将它们用作声明模块必须具有的显式协定（或类型）。如果无效，则编译将失败。GHC还将为Safe Haskell推断正确的类型，请参阅&amp;ldquo; &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell推断&amp;rdquo;&lt;/a&gt;部分以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">虽然这些示例看起来很相似，但是没有一个可以成功编译。这是因为最后的类型出现的所有参数， &lt;code&gt;a&lt;/code&gt; 发生在&lt;em&gt;逆变&lt;/em&gt;位置，而不是协变的。</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">虽然这些函数有一个稳定的API,你可以在应用程序中使用这些函数,但请仔细考虑文档中的前提条件;不正确的使用可能会破坏引用的透明度或更糟。</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">虽然这是相当低级的,但它为你提供了如何写出数据的充分灵活性。</target>
        </trans-unit>
        <trans-unit id="e625b4a26a74d86e3769fcae80feac3c80b5c8b0" translate="yes" xml:space="preserve">
          <source>While user-written type or kind variables are specified by default, GHC permits labelling these variables as inferred. By writing the type variable binder in braces as &lt;code&gt;{tyvar}&lt;/code&gt; or &lt;code&gt;{tyvar :: kind}&lt;/code&gt;, the new variable will be classified as inferred, not specified. Doing so gives the programmer control over which variables can be manually instantiated and which can&amp;rsquo;t. Note that the braces do not influence scoping: variables in braces are still brought into scope just the same. Consider for example:</source>
          <target state="translated">虽然默认情况下指定了用户编写的类型或种类变量，但GHC允许将这些变量标记为推断的。通过将大括号中的类型变量活页夹写为 &lt;code&gt;{tyvar}&lt;/code&gt; 或 &lt;code&gt;{tyvar :: kind}&lt;/code&gt; ，新变量将归类为推断的（未指定）。这样做使程序员可以控制哪些变量可以手动实例化，哪些不能手动实例化。请注意，花括号不会影响作用域：花括号中的变量仍会以相同的方式进入范围。考虑例如：</target>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">虽然可以两种方式使用常规模式同义词，但是可以使用 &lt;code&gt;Point&lt;/code&gt; 的七种方式。精确地使用普通记录构造函数的方式。</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="df9fef21f52afbea42c2a537cd033c1f3e472e48" translate="yes" xml:space="preserve">
          <source>Whitespace can be inserted, as in &lt;code&gt;- 123&lt;/code&gt;, to force interpretation as two tokens.</source>
          <target state="translated">如 &lt;code&gt;- 123&lt;/code&gt; ，可以插入空格以强制解释为两个标记。</target>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">为什么会出现链接错误?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">我们为什么需要这个？因为如果从使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程中调用外部库，则它将无法访问任何&lt;em&gt;线程局部状态&lt;/em&gt; -具有每个OS线程特定值的状态变量（请参阅POSIX的 &lt;code&gt;pthread_key_create&lt;/code&gt; 或Win32的 &lt;code&gt;TlsAlloc&lt;/code&gt; ）。因此，某些库（例如OpenGL）将无法通过使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程运行。在使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 创建的线程中，或者从 &lt;code&gt;main&lt;/code&gt; 或从 &lt;code&gt;foreign export&lt;/code&gt; 调用时，它们可以正常工作。</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">为什么我们要这样做呢?主要原因是运行解释代码的 RTS 可以是与 GHC 本身不同的风格(剖析或动态链接)。因此,举个例子。</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">我们为什么要运行已编译的代码？好的，编译后的代码比解释后的代码快大约10倍，但生成时间要长大约2倍（如果启用了优化，则可能会更长）。因此，需要编译不经常更改的程序部分，并对正在积极开发的代码使用解释器，这是值得的。</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">宽度数字也可以在任何修饰符之后和说明符（在此标记为 &lt;code&gt;z&lt;/code&gt; ）之前使用，例如：</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">在类型签名的单型（tau）部分中出现的&lt;em&gt;通配符&lt;/em&gt;是&lt;em&gt;类型通配符&lt;/em&gt;（通常会省略&amp;ldquo; type&amp;rdquo;，因为这是默认的通配符类型）。类型通配符可以实例化为任何单型，例如 &lt;code&gt;Bool&lt;/code&gt; 或 &lt;code&gt;Maybe [Bool]&lt;/code&gt; ，包括函数和种类繁多的类型，例如 &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; Int- &amp;gt; Bool）或 &lt;code&gt;Maybe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9658cea5793b3d031fa20c655bb68dd4c32b903a" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;#11197&lt;/a&gt;.</source>
          <target state="translated">尽管将在正确键入的 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 之后出现错误键入的术语，但将不会输出任何内容。。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;＃11197&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">尽管将在正确键入的 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 之后出现错误键入的术语，但将不会输出任何内容。。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;第11197期&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">将发出两个警告，因为 &lt;code&gt;Zero&lt;/code&gt; 和 &lt;code&gt;Succ&lt;/code&gt; 不会写为 &lt;code&gt;'Zero&lt;/code&gt; 和 &lt;code&gt;'Succ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">Windows GUI-only程序没有stdin、stdout或stderr,所以使用普通的Haskell输入/输出函数会导致你的程序以IO异常的方式失败,比如。</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">仅限Windows:目录链接</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Windows路径也不尽相同。不同种类的路径各有不同的含义。该 &lt;code&gt;MAX_PATH&lt;/code&gt; 限制是不是操作系统，也不是文件系统的限制。这是Win32 API为向后兼容而强制使用的默认名称空间的限制。</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">Windows系统</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows特定的错误：如果文件系统不支持符号链接，则此操作可能失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows特定的错误：如果用户缺乏创建符号链接的特权，则此操作可能会失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; 。如果文件系统不支持符号链接，它也可能会失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，GHC自动将每个数据类型提升为一种类型，并将其（值）构造函数提升为类型构造函数。以下类型</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，Haskell的列表和元组类型被本地提升为种类，并且在类型级别享受相同的方便语法，尽管前面加上了引号：</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，可以将上面的示例重写为：</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; ,&lt;/a&gt;您可以派生任何其他类。编译器将只生成一个没有显式定义的方法的实例声明。这在&lt;a href=&quot;#minimal-pragma&quot;&gt;最小集&lt;/a&gt;为空的类中尤其有用，尤其是在编写&lt;a href=&quot;#generic-programming&quot;&gt;泛型函数时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Data.Data&lt;/code&gt; 中定义的 &lt;code&gt;Data&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 数据类型派生 &lt;code&gt;Foldable&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Data.Foldable&lt;/code&gt; 中定义的 &lt;code&gt;Foldable&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 类型的数据类型派生 &lt;code&gt;Functor&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，可以派生在 &lt;code&gt;GHC.Base&lt;/code&gt; 中定义的 &lt;code&gt;Functor&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">随着&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，可以派生类的实例 &lt;code&gt;Generic&lt;/code&gt; 和 &lt;code&gt;Generic1&lt;/code&gt; ，定义 &lt;code&gt;GHC.Generics&lt;/code&gt; 。您可以使用它们来定义通用函数，如&lt;a href=&quot;#generic-programming&quot;&gt;通用编程中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Lift&lt;/code&gt; 类的实例，该实例在 &lt;code&gt;template-haskell&lt;/code&gt; 包的 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 模块中定义。</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 类型的数据类型派生 &lt;code&gt;Traversable&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;，可以派生在 &lt;code&gt;Data.Traversable&lt;/code&gt; 中定义的 &lt;code&gt;Traversable&lt;/code&gt; 类的实例。由于 &lt;code&gt;Traversable&lt;/code&gt; 实例指示 &lt;code&gt;Functor&lt;/code&gt; 和 &lt;code&gt;Foldable&lt;/code&gt; 的实例，因此您可能也想派生它们，因此&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;暗含了&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;，即使相应的选择器仅在作用域&lt;em&gt;限定的&lt;/em&gt;范围内，您也可以使用&lt;em&gt;不合格的&lt;/em&gt;字段名称。例如，假定与我们前面的示例相同的模块 &lt;code&gt;M&lt;/code&gt; ，这是合法的：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99f7c9801f0ef0a07288415240f5ce1502d72261" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-GHCForeignImportPrim&quot;&gt;&lt;code&gt;GHCForeignImportPrim&lt;/code&gt;&lt;/a&gt;, GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-GHCForeignImportPrim&quot;&gt; &lt;code&gt;GHCForeignImportPrim&lt;/code&gt; &lt;/a&gt;，GHC通过附加的调用约定 &lt;code&gt;prim&lt;/code&gt; 扩展了FFI ，例如：</target>
        </trans-unit>
        <trans-unit id="3633e2ee9e40b7726e0f89355deb245b14e9f8fc" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, both anomalies are resolved:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt;，可以解决两个异常：</target>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; &lt;/a&gt;扩展，GHC接受具有多个分支的条件表达式：</target>
        </trans-unit>
        <trans-unit id="9a679f9cc8ac2f8e0bd4d243711194c8b0678482" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;generics#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">随着&lt;a href=&quot;generics#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，可以派生类的实例 &lt;code&gt;Generic&lt;/code&gt; 和 &lt;code&gt;Generic1&lt;/code&gt; ，定义 &lt;code&gt;GHC.Generics&lt;/code&gt; 。您可以使用它们来定义通用函数，如&lt;a href=&quot;generics#generic-programming&quot;&gt;通用编程中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39f1831d8e85cb1a415e324a97c3fdb0f34ffde3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;, we can give the kind of a datatype written in GADT-syntax (see &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">使用&lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;，我们可以给出用GADT语法编写的数据类型（请参阅&lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="8d75b9ce3d652c231eb22d06b84771c3d1879c4f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XLinearTypes&lt;/code&gt;, you can write &lt;code&gt;f :: a %1 -&amp;gt; b&lt;/code&gt; to mean that &lt;code&gt;f&lt;/code&gt; is a linear function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;. If &lt;a href=&quot;unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; is enabled, the &lt;code&gt;%1 -&amp;gt;&lt;/code&gt; arrow can be written as &lt;code&gt;⊸&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;-XLinearTypes&lt;/code&gt; ，您可以编写 &lt;code&gt;f :: a %1 -&amp;gt; b&lt;/code&gt; 来表示 &lt;code&gt;f&lt;/code&gt; 是从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt; 的线性函数。如果启用了&lt;a href=&quot;unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;%1 -&amp;gt;&lt;/code&gt; 箭头可以写为 &lt;code&gt;⊸&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a0296f22c09085434bc8fbe6087bddeed249a7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-XRecursiveDo&lt;/code&gt;, &lt;code&gt;rec&lt;/code&gt; and &lt;code&gt;mdo&lt;/code&gt; blocks use &lt;code&gt;M.mfix&lt;/code&gt; and &lt;code&gt;M.return&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;-XRecursiveDo&lt;/code&gt; ， &lt;code&gt;rec&lt;/code&gt; 和 &lt;code&gt;mdo&lt;/code&gt; 块使用 &lt;code&gt;M.mfix&lt;/code&gt; 和 &lt;code&gt;M.return&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;-maxN⟨x⟩&lt;/code&gt; ，即 &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; ，运行时将最多选择（x），也受系统上处理器数量的限制。如果需要默认的使用选项 &lt;code&gt;-N&lt;/code&gt; ，则省略（x）是一个错误。</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">对于 &lt;code&gt;hpc-tracer&lt;/code&gt; ，它是8（一个选项卡代表几个空格）。</target>
        </trans-unit>
        <trans-unit id="1f5b790aba3cca991b680469d0ff5aa545bb45ba" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">对于GHC， &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示形式使用&lt;em&gt;固定&lt;/em&gt;内存，这意味着GC无法移动它。对于较大的字符串，通常这样做是正确的，但是对于固定字符串的较小的字符串，这可能导致堆碎片，从而浪费空间。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 型（和 &lt;code&gt;Text&lt;/code&gt; 从类型 &lt;code&gt;text&lt;/code&gt; 包）使用的&lt;em&gt;未锁定的&lt;/em&gt;记忆，使他们不至堆碎片贡献。此外，使用GHC时，小的固定字符串以与普通堆分配相同的方式分配，而不是在单独的固定区域中分配。</target>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">对于GHC， &lt;code&gt;ByteString&lt;/code&gt; 表示形式使用&lt;em&gt;固定&lt;/em&gt;内存，这意味着GC无法移动它。对于较大的字符串，通常这样做是正确的，但是对于固定字符串的较小的字符串，可能会导致堆碎片，从而浪费空间。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 型（和 &lt;code&gt;Text&lt;/code&gt; 从类型 &lt;code&gt;text&lt;/code&gt; 包）使用的&lt;em&gt;未锁定的&lt;/em&gt;记忆，使他们不至堆碎片贡献。此外，使用GHC时，小的固定字符串以与普通堆分配相同的方式分配，而不是在单独的固定区域中分配。</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">对于GHC,内存开销如下,以字数和字节表示(32或64位机器上的字数分别为4和8字节)。</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">对于Unicode文本，使用诸如 &lt;code&gt;map toUpper&lt;/code&gt; 类的组合符来区分字符串的每个字符是不正确的。而是使用此模块中的全字符串大小写转换函数。为了在不同的书写系统中保持正确性，这些功能可以将一个输入字符映射到两个或三个输出字符。</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">运气好的话， &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 将在所有其他所有支持C样式预处理的实现中都未定义。</target>
        </trans-unit>
        <trans-unit id="c44ed7fc274ccaa822b5b3ccf3ecc3bf7adbae81" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;#2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">借助依存类型的功能，它会更加有用（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;＃2431&lt;/a&gt;）。例如，考虑 &lt;code&gt;absurd&lt;/code&gt; 这两个候选定义：</target>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">使用依赖类型的功能，它会更加有用（请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue＃2431&lt;/a&gt;）。例如，考虑 &lt;code&gt;absurd&lt;/code&gt; 这两个候选定义：</target>
        </trans-unit>
        <trans-unit id="1ad7584c8bb969b4ca391280d29051d7fd169de9" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;../using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;../using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于善良的多态性，Haskell程序员可能看不到幕后发生的很多事情。 GHC支持几个标志，这些标志控制如何在错误消息中以及在GHCi提示符下打印类型。有关更多详细信息，请参见&lt;a href=&quot;../using#pretty-printing-types&quot;&gt;类型漂亮打印选项&lt;/a&gt;的讨论。如果您使用的是实物多态性，并且对GHC为什么拒绝（或接受）程序感到困惑，我们建议您打开这些标志，尤其是&lt;a href=&quot;../using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于善良的多态性，Haskell程序员可能看不到幕后发生的很多事情。GHC支持几个标志，这些标志控制如何在错误消息中以及在GHCi提示符下打印类型。有关更多详细信息，请参见&lt;a href=&quot;using#pretty-printing-types&quot;&gt;类型漂亮打印选项&lt;/a&gt;的讨论。如果您使用的是实物多态性，并且对GHC为什么拒绝（或接受）程序感到困惑，我们建议您打开这些标志，尤其是&lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">如果作用域中有多个模块，尤其是多个 &lt;code&gt;*&lt;/code&gt; 形式的模块，则可能会发生名称冲突。Haskell指定仅当使用不明确的标识符时才报告名称冲突，并且GHCi对于在提示符下键入的表达式具有相同的行为。</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">仅使用1代（例如 &lt;code&gt;-G1&lt;/code&gt; ，请参见&lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt;）， &lt;code&gt;-A&lt;/code&gt; 选项指定最小分配区域，因为分配区域的实际大小将根据堆中的数据量进行调整（请参见&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;，如下）。</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">除某些例外情况（请参阅下文）外，安全地创建文件的方式是，攻击者不应使用您的凭据通过将符号链接（在Unix上）放在以下位置，从而导致openTempFile覆盖文件系统上的另一个文件临时文件将被创建。在Unix上，使用 &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_EXCL&lt;/code&gt; 标志来防止这种攻击，但是请注意，NFS文件系统有时不支持 &lt;code&gt;O_EXCL&lt;/code&gt; ，因此，如果您依赖于此行为，则最好仅使用本地文件系统。</target>
        </trans-unit>
        <trans-unit id="79bbc92aef03765c41804036c58a84e7a3f0d5ed" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;扩展，GHC支持本文第二篇中描述的箭头符号，并使用&lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中的组合器对其进行翻译。以下是该符号的简要介绍；除非您阅读过休斯的论文，否则这没有多大意义。</target>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;扩展，GHC支持本文第二篇中介绍的箭头符号，并使用&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中的组合器对其进行翻译。以下是该符号的简要介绍；除非您阅读过休斯的论文，否则这没有多大意义。</target>
        </trans-unit>
        <trans-unit id="6b570873f02bd59cb3d75af7817ea6c7ba50ea43" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;扩展，GHC支持本文第二篇中描述的箭头符号，并使用&lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中的组合器对其进行翻译。以下是该符号的简要介绍；除非您阅读过休斯的论文，否则这没有多大意义。</target>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; &lt;/a&gt;扩展，GHC可以更自由地接受程序中的约束。确切地说，使用此标志，可以将任何&lt;em&gt;类型&lt;/em&gt;的新 &lt;code&gt;Constraint&lt;/code&gt; 作为约束。以下内容具有 &lt;code&gt;Constraint&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt;扩展，GHC允许您声明不带构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt;扩展，GHC允许使用要从中导入模块的包名称来限定导入声明。例如：</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;扩展（按&lt;a href=&quot;#universal-quantification&quot;&gt;词法定义的类型变量&lt;/a&gt;），可以在类型开头之外的其他地方声明类型参数。例如，我们可以具有 &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; ，然后说 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; ，其类型为 &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt;扩展，实例头可以使用类型同义词。与往常一样，使用类型同义词只是编写类型同义词定义的RHS的简写。例如：</target>
        </trans-unit>
        <trans-unit id="35ffad7832c6db23930e6f76ac2898fcc34375fa" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;scoped_type_variables#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;扩展（按&lt;a href=&quot;scoped_type_variables#universal-quantification&quot;&gt;词法定义的类型变量&lt;/a&gt;），可以在类型开头以外的地方声明类型参数。例如，我们可以具有 &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; ，然后说 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; ，其类型为 &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">通过使用&lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;语言标志，GHC扩展了导入声明语法，以在 &lt;code&gt;import&lt;/code&gt; 关键字之后采用可选的 &lt;code&gt;safe&lt;/code&gt; 关键字。此功能是Safe Haskell GHC扩展的一部分。例如：</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">使用 &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; 选项，GHC可以自动生成 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 类的实例。例如，给定声明</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">与 &lt;code&gt;T&lt;/code&gt; 上面的例子中，我们可以结合 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;后&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; ; 这样做不会违反依赖关系的关注。但是，这将违反我们的一般原则，因此 &lt;code&gt;k&lt;/code&gt; 排在第一位。</target>
        </trans-unit>
        <trans-unit id="f729b214bbb92dbc7e8b7e039b0ea25bb3f02fc3" translate="yes" xml:space="preserve">
          <source>With the List monad, &quot;empty&quot; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt;, while with &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. With &lt;strong&gt;&lt;code&gt;Either e a&lt;/code&gt;&lt;/strong&gt; we have an &lt;em&gt;empty&lt;/em&gt; case for each value of &lt;strong&gt;&lt;code&gt;e&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">在List monad中，&amp;ldquo; empty&amp;rdquo;为&lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt;，而在 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。对于&lt;strong&gt; &lt;code&gt;Either e a&lt;/code&gt; &lt;/strong&gt;对于每个&lt;strong&gt; &lt;code&gt;e&lt;/code&gt; &lt;/strong&gt;值，我们都有一个&lt;em&gt;空的&lt;/em&gt;大小写。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">有了上面的 &lt;code&gt;(:~~:)&lt;/code&gt; 声明，它对于所有 &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; 。因此，类型 &lt;code&gt;(:~~:) a&lt;/code&gt; 种类为 &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; 某些 &lt;code&gt;k2&lt;/code&gt; 的类型。然后，GHC无法将这种类型的 &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; &lt;em&gt;重新&lt;/em&gt;合成为永久k2。k2-&amp;gt;根据需要键入。因此，该实例被拒绝为不良实例。</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">通过添加&lt;a href=&quot;#constraint-kind&quot;&gt;一种约束&lt;/a&gt;的扩展，您可以编写更多奇特的超类定义。在这种情况下，超类循环检查更加自由。例如，这可以：</target>
        </trans-unit>
        <trans-unit id="8e20b822830d40ffde03919521d0e6cff6321840" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;constraint_kind#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these cases. For example, this is OK:</source>
          <target state="translated">通过添加了&lt;a href=&quot;constraint_kind#constraint-kind&quot;&gt;一种约束&lt;/a&gt;的扩展，您可以编写更多奇特的超类定义。在这些情况下，超类循环检查更加自由。例如，这可以：</target>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">考虑到使目标 &lt;code&gt;encode&lt;/code&gt; 工作 &lt;code&gt;Tree&lt;/code&gt; 和其它数据类型，我们现在定义为表示类型构造实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">随着 &lt;code&gt;Vec&lt;/code&gt; 种类的改进，像 &lt;code&gt;Vec Int Char&lt;/code&gt; 这样的东西现在已经变种了，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">通过扩展语言&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; ,&lt;/a&gt; GHC取消了对超类约束的所有限制。如果真的&lt;em&gt;是&lt;/em&gt;一个循环，GHC只会扩大到有限的深度。</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">启用此扩展名后， &lt;code&gt;static&lt;/code&gt; 不再是有效的标识符。</target>
        </trans-unit>
        <trans-unit id="c483494822eddb06511b9c2103f30e5e7e71ff07" translate="yes" xml:space="preserve">
          <source>With this flag GHC generates a default alternative with &lt;code&gt;error&lt;/code&gt; in these cases. This is helpful when debugging demand analysis or type checker bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">在这些情况下，GHC会使用此标志生成一个默认的替代方案，但有 &lt;code&gt;error&lt;/code&gt; 。这在调试需求分析或键入检查程序错误（有时可能表现为分段错误）时很有用。</target>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">启用这个标志后,我们使用块中最后一条跳转指令。如果没有这个标志,老算法也会使用最重的出边。</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">使用group语句的这种形式，要求f仅具有类型 &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; ，这将直接用于到目前为止的理解。这种形式的示例如下：</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">在 &lt;code&gt;.ghci&lt;/code&gt; 文件中定义了此宏之后，您可以使用 &lt;code&gt;:source file&lt;/code&gt; 从 &lt;code&gt;file&lt;/code&gt; 中读取GHCi命令。您可以在此Haskell Wiki页面上找到有关 &lt;code&gt;.ghci&lt;/code&gt; 文件的其他建议（并做出贡献！）：&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb160564b2f5fdfa9c709441f91b64c92758b306" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">在 &lt;code&gt;.ghci&lt;/code&gt; 文件中定义了此宏之后，您可以使用 &lt;code&gt;:source file&lt;/code&gt; 从 &lt;code&gt;file&lt;/code&gt; 中读取GHCi命令。您可以在此Haskell Wiki页面上找到有关 &lt;code&gt;.ghci&lt;/code&gt; 文件的其他建议（并做出贡献！）：&lt;a href=&quot;https://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07b653d1a2bfaa93b0073e542432ee5c0e412c45" translate="yes" xml:space="preserve">
          <source>With typed expressions, the type error occurs when &lt;em&gt;constructing&lt;/em&gt; the Template Haskell expression:</source>
          <target state="translated">对于类型化表达式，&lt;em&gt;构造&lt;/em&gt;Template Haskell表达式时会发生类型错误：</target>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">有曲折的切口。</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">在一定程度上，堆空间的更多内存意味着GHC的垃圾回收更少，这意味着更少的编译时间。如果使用 &lt;code&gt;-Rghc-timing&lt;/code&gt; 选项，将获得垃圾收集器报告。（同样，您可以使用便宜的 &lt;code&gt;+RTS -S -RTS&lt;/code&gt; 选项将GC统计信息直接发送到标准错误。）</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用无效字符&amp;ldquo;&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="7908234217d5fcd634ff01a732e900f1963d7319" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数都根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用替换字符&amp;ldquo; ...&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="d2664af2a1458216f4637034b8ac10a76e4c6e6e" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数都根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用替换字符&amp;ldquo; ...&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用无效字符&amp;ldquo;&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="d2e478e972382d28cdc4d59b0f5b4e6ab5fe13da" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数都根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用替换字符&amp;ldquo; ...&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="600646925b44db293829cf7151e09bea6f08885a" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数都根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用替换字符&amp;ldquo; ...&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">没有&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;，如果所有这些定义都在范围内，则提及 &lt;code&gt;foo&lt;/code&gt; 的更新将始终是模棱两可的。启用扩展后，可以使用多个选项来消除更新的歧义：</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">没有&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;，GHC拒绝归纳种类变量。因此，在可能的情况下，它会将种类变量默认为 &lt;code&gt;Type&lt;/code&gt; 。当这不可能时，将发出错误。</target>
        </trans-unit>
        <trans-unit id="2a9c3c68ec886ab1a40dbb182885c56e2b6ca831" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;#11679&lt;/a&gt;.</source>
          <target state="translated">如果没有&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; ,则将&lt;/a&gt;其解析为列表理解。使用&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 可以&lt;/a&gt;将其解析为准报价。但是，由于缺少结束符 &lt;code&gt;|]&lt;/code&gt; ，此解析将失败。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;＃11679&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">如果没有&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; ,则将&lt;/a&gt;其解析为列表理解。使用&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 可以&lt;/a&gt;将其解析为准报价。但是，由于缺乏结束 &lt;code&gt;|]&lt;/code&gt; ，因此该解析将失败。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;问题＃11679&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">如果没有&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项，则将忽略您的 &lt;code&gt;SCC&lt;/code&gt; ；因此，您无需更改即可编译包含 &lt;code&gt;SCC&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">在没有任何参数的情况下,显示应用于在提示符下输入的表达式和命令的当前选项集。</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">在不松开手指的情况下， &lt;code&gt;?cmp&lt;/code&gt; 参数也将传播为 &lt;code&gt;least&lt;/code&gt; 的参数。对于显式参数，默认值是必须始终对参数进行显式传播。使用隐式参数时，默认设置是始终传播它们。</target>
        </trans-unit>
        <trans-unit id="55d043b366c8c5411ad6e6a869f14d78a5f201f3" translate="yes" xml:space="preserve">
          <source>Without newtypes &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; f&lt;/code&gt; equals precomposing with &lt;code&gt;f&lt;/code&gt; (= &lt;code&gt;(. f)&lt;/code&gt;).</source>
          <target state="translated">如果没有新类型，则对 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt; f&lt;/code&gt; 等于由 &lt;code&gt;f&lt;/code&gt; （= &lt;code&gt;(. f)&lt;/code&gt; ）组成。</target>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">如果没有 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示，则不会为未实现任何方法的实例生成警告。</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">如果没有 &lt;code&gt;forall b&lt;/code&gt; ，则类型变量 &lt;code&gt;b&lt;/code&gt; 将在整个实例声明中进行量化，这不是预期的。</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">没有 &lt;code&gt;pattern&lt;/code&gt; 前缀， &lt;code&gt;Zero&lt;/code&gt; 将在导出列表中解释为类型构造函数。</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">见证未装箱的 &lt;code&gt;Proxy#&lt;/code&gt; 值，该值没有运行时表示形式。</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">见证毁灭的痕迹。</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">单词完成</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="70a7003c530361b27dbad2666f3119f63d7aa52c" translate="yes" xml:space="preserve">
          <source>Word32Rep</source>
          <target state="translated">Word32Rep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
        <trans-unit id="6df564da800ea9db332a4e4f70ac3b7baee68108" translate="yes" xml:space="preserve">
          <source>Word64X8#</source>
          <target state="translated">Word64X8#</target>
        </trans-unit>
        <trans-unit id="7d4f09dfc217ef6de83fd0a7817a34a9c524f5f8" translate="yes" xml:space="preserve">
          <source>Word8</source>
          <target state="translated">Word8</target>
        </trans-unit>
        <trans-unit id="1026530b7f2b7d11ceed950f769ae8af9db41c6d" translate="yes" xml:space="preserve">
          <source>Word8#</source>
          <target state="translated">Word8#</target>
        </trans-unit>
        <trans-unit id="46fa1330e06c95858d3c751456971104c43240e6" translate="yes" xml:space="preserve">
          <source>Word8ElemRep</source>
          <target state="translated">Word8ElemRep</target>
        </trans-unit>
        <trans-unit id="bb25378aca5d0bf9417565eddafe0c9955fced88" translate="yes" xml:space="preserve">
          <source>Word8Rep</source>
          <target state="translated">Word8Rep</target>
        </trans-unit>
        <trans-unit id="6d9c171610680a48a7e1adce25e5ef2175c1786b" translate="yes" xml:space="preserve">
          <source>Word8X16#</source>
          <target state="translated">Word8X16#</target>
        </trans-unit>
        <trans-unit id="7d2b3864aa2a328b268de16ec90a676d025166df" translate="yes" xml:space="preserve">
          <source>Word8X32#</source>
          <target state="translated">Word8X32#</target>
        </trans-unit>
        <trans-unit id="420bed9409614065e79233ee278151c88a99c07c" translate="yes" xml:space="preserve">
          <source>Word8X64#</source>
          <target state="translated">Word8X64#</target>
        </trans-unit>
        <trans-unit id="84c6a57a62c9a723bc4c3a3bbe6ffc9a885219d9" translate="yes" xml:space="preserve">
          <source>WordPtr</source>
          <target state="translated">WordPtr</target>
        </trans-unit>
        <trans-unit id="68dc8baeafc9a279622fb5e31be3ed83d95357da" translate="yes" xml:space="preserve">
          <source>WordRep</source>
          <target state="translated">WordRep</target>
        </trans-unit>
        <trans-unit id="7ba9e8f41622b0ccfc835a4f2140ab6eea7b7e9b" translate="yes" xml:space="preserve">
          <source>Work left-to-right through the input list of type variables, with a cursor.</source>
          <target state="translated">用光标从左到右在类型变量的输入列表中工作。</target>
        </trans-unit>
        <trans-unit id="bc1c455e1b31ed1393785a6cdc3045bbb118f243" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解决方法，以便我们可以使用Haskell 98实例 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c02809968c5a04b4bf0b6d24112481a63ca6dca" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解决方法，以便我们可以使用Haskell 98实例 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18b99ada0b9847a43772d5b421ac47cdacf3632e" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解决方法，以便我们可以使用Haskell 98实例 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ab49cd9ef02b20b8f0a395f52a3bac5f961ae20" translate="yes" xml:space="preserve">
          <source>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove &lt;em&gt;all&lt;/em&gt; value lambdas.</source>
          <target state="translated">Worker-wrapper会删除未使用的参数，但是通常我们不会全部删除它们，以免将函数关闭变成笨拙的东西，从而可能造成空间泄漏和/或破坏内联。此标志允许工作程序/包装程序删除&lt;em&gt;所有&lt;/em&gt;值lambda。</target>
        </trans-unit>
        <trans-unit id="61f4d4dd918269bf5a5ff69500737f2e3c652d80" translate="yes" xml:space="preserve">
          <source>Working with equality</source>
          <target state="translated">与平等有关的工作</target>
        </trans-unit>
        <trans-unit id="b7851eadac070ddfea609696fdeb164b7899ebe8" translate="yes" xml:space="preserve">
          <source>Would result in a generated &lt;code&gt;Functor&lt;/code&gt; instance like so:</source>
          <target state="translated">会生成一个如下所示的 &lt;code&gt;Functor&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="6ee562876821329b8991ff4daaadbf4f98ef9b98" translate="yes" xml:space="preserve">
          <source>Wrap a BCO in a &lt;code&gt;AP_UPD&lt;/code&gt; thunk which will be updated with the value of the BCO when evaluated.</source>
          <target state="translated">将BCO包裹在 &lt;code&gt;AP_UPD&lt;/code&gt; 中，将在评估时使用BCO的值进行更新。</target>
        </trans-unit>
        <trans-unit id="16397dd6317efa9c9836ee42453758565f8d25ed" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果在超时之前有结果可用，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="298bd3ed150b3f0eda86e3bd26b9d517dfc0dc76" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则不返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果超时之前有可用结果，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0379570077ecabca08995c42a34f4a46b3ee2ced" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则不返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果超时之前有可用结果，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="769d436eab4aa870cf748d72592199f75a9fdf28" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果在超时之前有结果可用，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052e52e2ec601e51ff67cce14d06f664e23dd732" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;&quot;...&quot;&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;&quot;...&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2463a3964a6d5f90893a0cb4a83e415f58109e" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;'...'&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;'...'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e11d85c98f81ceac1c15ffeb3554f6ef50d942c9" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;(...)&lt;/code&gt;</source>
          <target state="translated">将文档包装在 &lt;code&gt;(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fefcdd75b8d3ceac5767fa9ddb3485c2fae7387b" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;[...]&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;[...]&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="2d9a81e67b5bd2bc5cede4830f07d4ee5769499a" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;{...}&lt;/code&gt;</source>
          <target state="translated">将文档包装在 &lt;code&gt;{...}&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="b5150dc051fd47e830d39a1a10a0d5cede823b6b" translate="yes" xml:space="preserve">
          <source>WrapArrow</source>
          <target state="translated">WrapArrow</target>
        </trans-unit>
        <trans-unit id="c92147ea0c2b0677b7c09751757b19d07bd7b17c" translate="yes" xml:space="preserve">
          <source>WrapMonad</source>
          <target state="translated">WrapMonad</target>
        </trans-unit>
        <trans-unit id="4069d5a8b2d61fc44c53d1d69a1603e75124fe55" translate="yes" xml:space="preserve">
          <source>WrapMonoid</source>
          <target state="translated">WrapMonoid</target>
        </trans-unit>
        <trans-unit id="f72344941ecf4dbf3a6b05f7d128cba499a51fde" translate="yes" xml:space="preserve">
          <source>WrappedArrow</source>
          <target state="translated">WrappedArrow</target>
        </trans-unit>
        <trans-unit id="5424268dd193f61b9e7843ef4109dc2a12bac7a6" translate="yes" xml:space="preserve">
          <source>WrappedMonad</source>
          <target state="translated">WrappedMonad</target>
        </trans-unit>
        <trans-unit id="459140ee141c9d01be26238b973ae1046e530be2" translate="yes" xml:space="preserve">
          <source>WrappedMonoid</source>
          <target state="translated">WrappedMonoid</target>
        </trans-unit>
        <trans-unit id="6f21817c0f554ef006f52930cf8b3fb843bafa13" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">具有更快实现GHC的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 包装器</target>
        </trans-unit>
        <trans-unit id="fb18f208c8e09b8e152ee97be9d763608b85aabc" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">具有更快实现GHC 的 &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; 包装器</target>
        </trans-unit>
        <trans-unit id="f5bae4c947473ab2febca5eb61bfa9da65f60ac7" translate="yes" xml:space="preserve">
          <source>Wrapping an IO action that can throw an error &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">包装可能引发错误 &lt;code&gt;e&lt;/code&gt; 的IO操作：</target>
        </trans-unit>
        <trans-unit id="0d27d9e2d3a2ad251d4892a773947e707db18720" translate="yes" xml:space="preserve">
          <source>Wrapping documents in delimiters</source>
          <target state="translated">用定界符包装文件</target>
        </trans-unit>
        <trans-unit id="48606f4bb9cb6f76c6d45f0aae55cb4f7a999651" translate="yes" xml:space="preserve">
          <source>Write 31-bit character; offset in 4-byte words.</source>
          <target state="translated">写31位字符;偏移量为4字节的字。</target>
        </trans-unit>
        <trans-unit id="132823a14fa0074e9c3549c122a220890e54d9b3" translate="yes" xml:space="preserve">
          <source>Write 8-bit character; offset in bytes.</source>
          <target state="translated">写8位字符;偏移量以字节为单位。</target>
        </trans-unit>
        <trans-unit id="6cfb95525e855d3c2fb90f553acacc9ffd9b1afe" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 写入缓冲区</target>
        </trans-unit>
        <trans-unit id="0296abfbf70a590c6ce425e8d54f6de5c2d195a0" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 写入缓冲区</target>
        </trans-unit>
        <trans-unit id="a30ef0a4dea3adbd954b944a856f0d73077a7fef" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">编写一个 &lt;code&gt;.tix&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2384eda70bde5fbafcdce06c7083ad1f34fba13d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 使用区域设置编码。</target>
        </trans-unit>
        <trans-unit id="641fdc517a3a148a3426445c3e2501afc543647f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19f5831180b0536c875f7fde0710ba2f6b629a3f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="993b7cc9e4c74d2721eedc685664742cc7c82795" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="025b69c4396276807676b294d74b3b70f46bef94" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="2300f23523bc1b33ccbbebf657381c02dd05c86c" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a6e3e08979b85f7f159802afa8ee51f8a4eedd1" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机字节序编写原生 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="100ddab2dd798658dd4fbb44584d4757dded426e" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 使用区域设置编码。</target>
        </trans-unit>
        <trans-unit id="34cb939ce09480dcfa16a616504013b186c6decd" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17ec2c319cd8c0e2c3a0c3951b37ec1585cee156" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="545e766b627e659fd52bff3acf015eb9994ae5c5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f65b44a7ea8883932f7651be10c9246fc522dca8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="ead3e3f2656945a589c0165356d2eb079e613140" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2feadbf9adb1a358b7e0093340ebf583af8879d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端字节序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde29449d3f0108ac52954edaff927f556465b38" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 使用区域设置编码。</target>
        </trans-unit>
        <trans-unit id="3b9ab35d2642c9b5be7308adfb540fe471522384" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb93655e29d96d133136c01dc591f84e22055de5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c67f5d3071082cd12eed2b10946f5237ea28fd6" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cad8d95d64d25782658d6f8b5c3b46df8c39dd8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="b5b24d9d9e097aac96beae3883a886f722fde4c0" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6238f387e14de2e21a90134fdf8ba25fdaaeefb7" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端字节序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59ed5c3f805685b995398b8616a908c0066ad70a" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="ca463eab69a5fff98e0ab2e75dce7ed014b9ab1b" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="3ad21d75c6a544747e2e36fcec12a87a1aebe727" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="a8e6f690eb143ffdbea5335db0be7244660876a2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="244e830bbe30fb0c3258c35cfc26647f07415c80" translate="yes" xml:space="preserve">
          <source>Write a ByteString to a handle, appending a newline byte</source>
          <target state="translated">写一个ByteString到一个句柄,附加一个新行字节。</target>
        </trans-unit>
        <trans-unit id="a70a82a5347cdeed11b696c9567115f30a6a5296" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout</source>
          <target state="translated">写一个ByteString到stdout</target>
        </trans-unit>
        <trans-unit id="e8ad66b8476a9e49cc072f07250605c906e95e94" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout, appending a newline byte</source>
          <target state="translated">写一个ByteString到stdout,附加一个新行字节。</target>
        </trans-unit>
        <trans-unit id="c0c3cc8f4573e40e62c43e8422d4118f97ea3fea" translate="yes" xml:space="preserve">
          <source>Write a Int16 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="9d73a70f9f179a81035be58cee26e559014c575a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="7d8b2b4323c44fde9919abbfb9988c387020100a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Int16。将写入2个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="fb3123d3e54a5bdf6aa5b4391bbf7b28df79fb37" translate="yes" xml:space="preserve">
          <source>Write a Int32 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="7e919ad40c1b9ea38485684cbf74d8a9568b9af7" translate="yes" xml:space="preserve">
          <source>Write a Int32 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="c8c3c578503e8e7468915f61ff1fa6751340cce3" translate="yes" xml:space="preserve">
          <source>Write a Int32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Int32。将写入4个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="b4e181d3a02580a355986a71c12d4507242968cf" translate="yes" xml:space="preserve">
          <source>Write a Int64 in big endian format</source>
          <target state="translated">以大恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="6a15b266b9877bbd729c40ccb87aa3db359c9f58" translate="yes" xml:space="preserve">
          <source>Write a Int64 in little endian format</source>
          <target state="translated">用小恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="001b75a9a615fe6648502bcfe94fd2920ba86af5" translate="yes" xml:space="preserve">
          <source>Write a Int64 in native host order. On a 32 bit machine we write two host order Int32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">按原生主机顺序写一个Int64。在32位的机器上,我们以大恩迪安形式写入两个主机顺序的Int32。将写入8个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="50fde014dba0a50360d764d6c2704238d9a9cb90" translate="yes" xml:space="preserve">
          <source>Write a String using UTF-8 encoding.</source>
          <target state="translated">使用UTF-8编码编写一个字符串。</target>
        </trans-unit>
        <trans-unit id="ca1a04969f07426c1e00b1b3766e301003971851" translate="yes" xml:space="preserve">
          <source>Write a Unicode string to the user's standard output.</source>
          <target state="translated">将Unicode字符串写入用户的标准输出。</target>
        </trans-unit>
        <trans-unit id="de13c62099cbcafc759fb5510fbb414e0c611d13" translate="yes" xml:space="preserve">
          <source>Write a Word16 in big endian format</source>
          <target state="translated">用大字报格式写一篇Word16的文章</target>
        </trans-unit>
        <trans-unit id="1d3480abbd86fc7688fd650a23916c935ed2b876" translate="yes" xml:space="preserve">
          <source>Write a Word16 in little endian format</source>
          <target state="translated">写一个Word16的小恩字格式。</target>
        </trans-unit>
        <trans-unit id="374953a98335b9e84fa5e0a4c035b46b2a892799" translate="yes" xml:space="preserve">
          <source>Write a Word16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Word16。将写入2个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="b1d543a7902bc6e8e15046b66cf37db05811d00c" translate="yes" xml:space="preserve">
          <source>Write a Word32 in big endian format</source>
          <target state="translated">用大英字型写一个Word32的格式。</target>
        </trans-unit>
        <trans-unit id="426bab66f99e758605e62a76ce97b5ce1321c0e7" translate="yes" xml:space="preserve">
          <source>Write a Word32 in little endian format</source>
          <target state="translated">写一个Word32的小恩迪格式。</target>
        </trans-unit>
        <trans-unit id="22533b04aaf4738c420c7810c743da18ca10d4e0" translate="yes" xml:space="preserve">
          <source>Write a Word32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Word32。将写入4个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="d00bd933478ce30ee3627449becbce383505e676" translate="yes" xml:space="preserve">
          <source>Write a Word64 in big endian format</source>
          <target state="translated">用大字报格式写一篇Word64的文章</target>
        </trans-unit>
        <trans-unit id="1ccded859c25705e9ae2dccba946964f2b4b599e" translate="yes" xml:space="preserve">
          <source>Write a Word64 in little endian format</source>
          <target state="translated">写一个Word64的小恩迪格式。</target>
        </trans-unit>
        <trans-unit id="fe8b5771af7a4fe3ab30f772b71da7013250ca90" translate="yes" xml:space="preserve">
          <source>Write a Word64 in native host order. On a 32 bit machine we write two host order Word32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">按原生主机顺序写一个Word64。在32位的机器上,我们写两个主机顺序的Word32,以大恩迪亚形式。将写入8个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="d084d0a0a3ee70356c669bbf84781436e439ab8d" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">将给定偏移量的字符写入数组。返回写入的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的数量。</target>
        </trans-unit>
        <trans-unit id="841f4e3a7f9355477f1154322e4d479f881e0fd9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">将给定偏移量的字符写入数组。返回写入的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的数量。</target>
        </trans-unit>
        <trans-unit id="ead19630563db8c3d93106011641efd62bcf10e9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">将给定偏移量的字符写入数组。返回写入的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的数量。</target>
        </trans-unit>
        <trans-unit id="824db4935989674b3e285858238d002d124cd8b6" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="7382100d9830a823b89994904abbed419d0ca6e4" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="f3d825454d2db1c3d3f226a28bb4ebdfec603097" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="955d70d1572c0c0ab9646927bdac5ea547ae35f8" translate="yes" xml:space="preserve">
          <source>Write a character using UTF-8 encoding.</source>
          <target state="translated">用UTF-8编码写一个字符。</target>
        </trans-unit>
        <trans-unit id="0a40d25653018769760da200e171fb69042b97ba" translate="yes" xml:space="preserve">
          <source>Write a floating point value to a &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将浮点值写入 &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f0e537457e84f16fbaa39fa0827e8c740824c36" translate="yes" xml:space="preserve">
          <source>Write a lazy ByteString efficiently, simply appending the lazy ByteString chunks to the output buffer</source>
          <target state="translated">高效地写入一个懒惰的ByteString,只需将懒惰的ByteString分块追加到输出缓冲区即可。</target>
        </trans-unit>
        <trans-unit id="4a5a6f538364d52e8d401c4fc9299b67f51eb2c1" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">将可存储元素列表写入一个新分配的，可存储值的连续序列中（类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; ，但是用于多个元素）。</target>
        </trans-unit>
        <trans-unit id="cdf3a3bd7d79bb717fec0614e932a3f554e7d129" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker</source>
          <target state="translated">将一个可存储元素列表写入一个新分配的、连续的可存储值序列中,其中结束由给定的结束标记固定下来</target>
        </trans-unit>
        <trans-unit id="46dde6be964e98cc511af24b16c6e57e81e0249e" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ded1b880637c536601d5622865a8ac5bee12d73f" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b15bee858199106a92ca21868dcf92516cce78a" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfd1ae109907abef00a2e666c2fb353f397524eb" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0bbd3fd99a0c8ca169dc0a0800f474e5f53bf14" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a779d08a6f4043a50272816a75acd9ee4cacd4c" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20f4593948df5a33a2e433f875c4b3f08e697cff" translate="yes" xml:space="preserve">
          <source>Write a string the end of a file.</source>
          <target state="translated">在文件末尾写一个字符串。</target>
        </trans-unit>
        <trans-unit id="c180f2e1d927a73773a56afa0d7e8518dedba44e" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="f7e8eefc7a202ba520c173df9a961b393fa4acc7" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f730ea108860688ef12de2017ea9ad535914f4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="45c0c99c259a0bae8a5de169024806ed9278e047" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adfa6ba6c0cf344b0e6e3107b4b376c5c61df5aa" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="10cbb856cec403b79eb6afecd39da04f2c3b3bb4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7142ba8529e9f3798882070ee18b16fa9830450d" translate="yes" xml:space="preserve">
          <source>Write a string to a file. The file is truncated to zero length before writing begins.</source>
          <target state="translated">将一个字符串写入一个文件。在开始写之前,文件被截断为零长度。</target>
        </trans-unit>
        <trans-unit id="1c2990ff65d290d7bbb87a7564d0e4e76c8f8255" translate="yes" xml:space="preserve">
          <source>Write a string to a handle, followed by a newline.</source>
          <target state="translated">将一个字符串写入一个句柄,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="bd7a02731ecdcdf45341edba546df5ac23933c67" translate="yes" xml:space="preserve">
          <source>Write a string to a handle.</source>
          <target state="translated">将一个字符串写入一个句柄。</target>
        </trans-unit>
        <trans-unit id="ece9511f02a82892ce27b96dda3476e25a7fbdb9" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符串写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="f865cedd38348737be2e60d87bff870c9a8dd6d6" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符串写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="ffa575f023b590cb0185153c4e3bb7bcdf3ca8ca" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符串写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="9ddf3308755406ffab4fefd34e1c0f532c36bfca" translate="yes" xml:space="preserve">
          <source>Write a string to the user's standard output, followed by a newline.</source>
          <target state="translated">在用户的标准输出中写入一个字符串,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="d649865e90fcbff9ffe50b1a59105ee5172bcad2" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">给 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 写价值。</target>
        </trans-unit>
        <trans-unit id="9bb0e77531d8dd5855a5dee42f98bdfb66dea502" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;; blocks if the queue is full.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 写一个值；如果队列已满，则阻塞。</target>
        </trans-unit>
        <trans-unit id="9b880d3a6f95fb0643f6f8cb86d9febe4b457c2d" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="502f2a89fe6ab954ea36d4a5f5ae4da0588aaadf" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b003c4b3a259d538a4ba6bcb5c8dd4f54a8c348a" translate="yes" xml:space="preserve">
          <source>Write a value to a memory area regarded as an array of values of the same kind. The following equality holds:</source>
          <target state="translated">将一个值写入一个被视为同类值数组的内存区域。下面的平等关系成立:</target>
        </trans-unit>
        <trans-unit id="2278658d6c531603ea71643e435890480712f25e" translate="yes" xml:space="preserve">
          <source>Write a value to a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">将一个值写入由基地址和偏移量给出的内存位置。下面的等价关系成立:</target>
        </trans-unit>
        <trans-unit id="d2bcb5f72dff224c65e70a09f3049dbb8677df2f" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">将一个向量写入标量数组的指定索引,偏移量以标量元素为单位。</target>
        </trans-unit>
        <trans-unit id="47fbcdcf5427d81f8e800b2a3be52a9b2780f1f2" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array.</source>
          <target state="translated">向可变数组的指定索引写入一个向量。</target>
        </trans-unit>
        <trans-unit id="2cbdaab506338b440edffc79752d43d3b372babf" translate="yes" xml:space="preserve">
          <source>Write an Int16 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="a4e76ca260148b04e485fd2b3ab9435bef6ca68d" translate="yes" xml:space="preserve">
          <source>Write an Int16 in little endian format</source>
          <target state="translated">用小恩迪恩格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="04d7dd93d431136691244f8a8060c6f710b4c9c7" translate="yes" xml:space="preserve">
          <source>Write an Int32 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="ac3eecde6710e67b4fbd62fe5faea7085564b9e9" translate="yes" xml:space="preserve">
          <source>Write an Int32 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="4ecb73c918eeb208591574c27bf43973ceabac8a" translate="yes" xml:space="preserve">
          <source>Write an Int64 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="062b3fd33b7744aa05c8b488aac57bd5719de134" translate="yes" xml:space="preserve">
          <source>Write an Int64 in little endian format</source>
          <target state="translated">用小恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="f3475a216b60f541f9561999947a42033537d47f" translate="yes" xml:space="preserve">
          <source>Write an element in a mutable array</source>
          <target state="translated">在一个可变数组中写入一个元素</target>
        </trans-unit>
        <trans-unit id="3a6dc8d047fec7b46b0233f24f9a28adcd679e26" translate="yes" xml:space="preserve">
          <source>Write an entire list of items to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">把物品的整个清单写到一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="f9599a175165c39f1f29ddd9bb8c7e18497bf06b" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;MutVar#&lt;/code&gt;.</source>
          <target state="translated">编写 &lt;code&gt;MutVar#&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="842c4baf59de10dbe1f4228d4e89548eb6cfad90" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;TVar#&lt;/code&gt;.</source>
          <target state="translated">编写 &lt;code&gt;TVar#&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="a3de1d04f7bf6af5e972546fb7777d6bafc52d88" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">将内存中的数据写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。这完全等同于POSIX &lt;code&gt;write&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="3589adf6c850b011d135abac8239e99774d7263d" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">将内存中的数据写入 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。这完全等同于POSIX &lt;code&gt;write&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="3d30b89159dbe8adf88a13bf3ed9d62236eb08e2" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">将内存中的数据写入 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。这完全等同于POSIX &lt;code&gt;write&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="5c15fb50864a59ead622c1afb8db98eae0916f34" translate="yes" xml:space="preserve">
          <source>Write file in UTF-8 encoding. Parent directory will be created if missing.</source>
          <target state="translated">以UTF-8编码写入文件。如果缺少父目录,将创建父目录。</target>
        </trans-unit>
        <trans-unit id="b7773c80499d5b3f15854fd0b2e72f86ef50f9e8" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定的错误消息写入 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 并以 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="d1dcba72b258ea0ed5115b0f30bfb1d0dcb08793" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定的错误消息写入 &lt;code&gt;&lt;a href=&quot;ghc-io-stdhandles#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 并以 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="4355c147f16522d41a43d5a06119aedec6f7144b" translate="yes" xml:space="preserve">
          <source>Write output from main C-\- pipeline passes to files</source>
          <target state="translated">将主C-管道的输出写到文件上</target>
        </trans-unit>
        <trans-unit id="b96bdb27f817c3c1baec26eb6ded0edc44bb3c99" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定值写入给定存储位置。对齐限制可能适用；见 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77655bd9fbe731998656fdcf621486c02b0a375a" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定值写入给定存储位置。对齐限制可能适用；见 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="babfd98df4815040b9b8feaf92e4a373432b470f" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory</source>
          <target state="translated">将列表元素连续写入内存</target>
        </trans-unit>
        <trans-unit id="c13f0a2faae8bb31701cafde84fa1d469581a021" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory and terminate them with the given marker element</source>
          <target state="translated">将列表元素连续写入内存,并以给定的标记元素结束。</target>
        </trans-unit>
        <trans-unit id="3e02cf61d4db014ee685a86394e5a58900284ddf" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes starting at a given offset.</source>
          <target state="translated">从给定的偏移量开始写入指定数量的字节。</target>
        </trans-unit>
        <trans-unit id="4bfb3401061c515a5bf897d647437c6e727895e8" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes.</source>
          <target state="translated">写入指定数量的字节。</target>
        </trans-unit>
        <trans-unit id="7948630f19859069bae4a14e2c76f2c7020b9d2a" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8756d20514051c6080e747e02c7172e182a101af" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27a7a93b6c3f65c763bd60036589804bd7bf721" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155f12112f4379352bcdee8335e8ff9abd964e75" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the standard output device.</source>
          <target state="translated">将终端输出写入标准输出设备。</target>
        </trans-unit>
        <trans-unit id="2ffb13840f565fd761a331ddc6dc0237d509420b" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将终端输出写入到由给定 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 管理的终端或文件中。</target>
        </trans-unit>
        <trans-unit id="3cd750e768a4d8f40411b104e6eddf083a4f201a" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将终端输出写入到由给定 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 管理的终端或文件中。</target>
        </trans-unit>
        <trans-unit id="354772ef04e9b2d16c5fe14016464a4e279a0ec7" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将终端输出写入到由给定 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 管理的终端或文件中。</target>
        </trans-unit>
        <trans-unit id="4bab7a81286ec426207ad20332db127f5e40c79b" translate="yes" xml:space="preserve">
          <source>Write to specified index of mutable array.</source>
          <target state="translated">写入指定的可变数组索引。</target>
        </trans-unit>
        <trans-unit id="8062d7bf97a30b717d53fc3dbe2d6e2c50919458" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking starting at a given offset. Returns the actual number of bytes written.</source>
          <target state="translated">从给定的偏移量开始,在不阻塞的情况下写入指定数量的字节。返回实际写入的字节数。</target>
        </trans-unit>
        <trans-unit id="faa64ad5644001c4c4dc3bee878a933e8c8aac0e" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking. Returns the actual number of bytes written.</source>
          <target state="translated">无阻塞地写入指定的字节数。返回实际写入的字节数。</target>
        </trans-unit>
        <trans-unit id="74120aff54b3ed793ccfa34d37318c6efb458636" translate="yes" xml:space="preserve">
          <source>Write vector; offset in bytes.</source>
          <target state="translated">写入向量;偏移量(字节)。</target>
        </trans-unit>
        <trans-unit id="fd96182628831a4dab0848bbbb0a8a86256945c3" translate="yes" xml:space="preserve">
          <source>Write vector; offset in scalar elements.</source>
          <target state="translated">写入向量;偏移量为标量元素。</target>
        </trans-unit>
        <trans-unit id="e1f97fa6627971c9b0e683428fd5abfab1ecbdb9" translate="yes" xml:space="preserve">
          <source>Write? (False = read-only)</source>
          <target state="translated">写?(False=只读)</target>
        </trans-unit>
        <trans-unit id="09c7377b67eee34defdc1dd0804c879b090650d2" translate="yes" xml:space="preserve">
          <source>WriteBuffer</source>
          <target state="translated">WriteBuffer</target>
        </trans-unit>
        <trans-unit id="3082b1ffe24322eee941ed215c852cffc7410d42" translate="yes" xml:space="preserve">
          <source>WriteHandle</source>
          <target state="translated">WriteHandle</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="60841bf1ad2d01720515c6eb9b3efbeb2e0f7656" translate="yes" xml:space="preserve">
          <source>WriteMode</source>
          <target state="translated">WriteMode</target>
        </trans-unit>
        <trans-unit id="f5ca54e8210ce7deaf5fa1129a91a1f50f08386a" translate="yes" xml:space="preserve">
          <source>WriteOnly</source>
          <target state="translated">WriteOnly</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="a8f135f9c50f7fe5f7a287362386d791fee8800a" translate="yes" xml:space="preserve">
          <source>Writer operations</source>
          <target state="translated">写字机操作</target>
        </trans-unit>
        <trans-unit id="a123ab5d3541d6386c9d34765c7348e78d2bb09e" translate="yes" xml:space="preserve">
          <source>WriterT</source>
          <target state="translated">WriterT</target>
        </trans-unit>
        <trans-unit id="1cccc800c778fc7aea514948aa922ecafd4399e9" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数组写入指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d30a3e22fd6539c1c9d94fc5b04d15e2c9f7e725" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数组写入指定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ff69c85320ce63f18bed336a41ffa3b0d101a7b3" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数组写入指定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b2b97a0aaa412174782d8ac6874c3f7cc18e81e9" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">将扩展接口文件与普通的enterface文件一起写出来。就像普通的接口文件一样,GHC有一个重新编译检查,以检测过时或丢失的扩展接口文件。</target>
        </trans-unit>
        <trans-unit id="f8ed5cefe0e622b3e54c1d44f041cf244581a4d3" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongside regular interface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">在写出普通接口文件的同时写出扩展接口文件。就像普通的接口文件一样,GHC有一个重新编译检查,以检测过时或丢失的扩展接口文件。</target>
        </trans-unit>
        <trans-unit id="e584f7c39c3d0e184b912ee7be64b91cc4f0e227" translate="yes" xml:space="preserve">
          <source>Writes the line history to the given file. If there is an error when writing the file, it will be ignored.</source>
          <target state="translated">将行历史记录写入给定文件。如果写入文件时出现错误,将被忽略。</target>
        </trans-unit>
        <trans-unit id="82675cd0bc2b58173645fe62ed090db0c903a0d8" translate="yes" xml:space="preserve">
          <source>XdgCache</source>
          <target state="translated">XdgCache</target>
        </trans-unit>
        <trans-unit id="a09516bd6fa5e0d22f97cc882d59eced3f611c61" translate="yes" xml:space="preserve">
          <source>XdgConfig</source>
          <target state="translated">XdgConfig</target>
        </trans-unit>
        <trans-unit id="513936143f60ff489cea943b4d3cf5ff7ec804be" translate="yes" xml:space="preserve">
          <source>XdgConfigDirs</source>
          <target state="translated">XdgConfigDirs</target>
        </trans-unit>
        <trans-unit id="b55b13216c4a49a521787620dab302740b661e55" translate="yes" xml:space="preserve">
          <source>XdgData</source>
          <target state="translated">XdgData</target>
        </trans-unit>
        <trans-unit id="5c87de6a1cfa7e4af282e624345c841e7d8bd0bb" translate="yes" xml:space="preserve">
          <source>XdgDataDirs</source>
          <target state="translated">XdgDataDirs</target>
        </trans-unit>
        <trans-unit id="1fbbfb2eaf00935b6eaff85397e2d3159b40fac3" translate="yes" xml:space="preserve">
          <source>XdgDirectory</source>
          <target state="translated">XdgDirectory</target>
        </trans-unit>
        <trans-unit id="2a60deb694d7c793f949c28507f268cafab38ce5" translate="yes" xml:space="preserve">
          <source>XdgDirectoryList</source>
          <target state="translated">XdgDirectoryList</target>
        </trans-unit>
        <trans-unit id="14824d205a044c81fdecf7f246ad054ed0648b74" translate="yes" xml:space="preserve">
          <source>Year and day format</source>
          <target state="translated">年和日格式</target>
        </trans-unit>
        <trans-unit id="ed289f57da895ead697dd2c01857ff65cfc7ea93" translate="yes" xml:space="preserve">
          <source>Year.</source>
          <target state="translated">Year.</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="520497482bb4d7526496e8edb3018d95cee38510" translate="yes" xml:space="preserve">
          <source>Yes (Explicit)</source>
          <target state="translated">是(明确)</target>
        </trans-unit>
        <trans-unit id="90c557a6b48e6bc7ef30b6f2d5fb9c703c39cf2f" translate="yes" xml:space="preserve">
          <source>Yes (Inferred)</source>
          <target state="translated">是(推断)</target>
        </trans-unit>
        <trans-unit id="86200a8547bb15fb3a4cf8bb1368b37de64fb317" translate="yes" xml:space="preserve">
          <source>Yield &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the given &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; value is valid on the system. This implies that the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; is also system dependent as it is only defined for valid values of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">产量 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果给定的 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 值是系统上的有效。这意味着 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例也与系统有关，因为它仅为 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 的有效值定义。</target>
        </trans-unit>
        <trans-unit id="1f384c9380a1584c25f0df9644ddfab42bb5794c" translate="yes" xml:space="preserve">
          <source>Yield a &lt;em&gt;non-empty&lt;/em&gt; strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">产生一个&lt;em&gt;非空的&lt;/em&gt; strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="711685e6ca2af214ee9e0c03ff3f6e2991b1fffe" translate="yes" xml:space="preserve">
          <source>Yield not to its blasphemous call! Flee traveller! Flee or you will be corrupted and devoured!</source>
          <target state="translated">不要屈服于它那亵渎神灵的召唤!逃吧,旅行者! 逃吧,否则你会被腐蚀和吞噬!逃吧,否则你会被腐蚀和吞噬!</target>
        </trans-unit>
        <trans-unit id="a5cc7a47f6c353cbfbd096e4097551052e651002" translate="yes" xml:space="preserve">
          <source>You can add a module to the scope (via &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt;) only if either (a) it is loaded, or (b) it is a module from a package that GHCi knows about. Using &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;import&lt;/code&gt; to try bring into scope a non-loaded module may result in the message &lt;code&gt;module M is not loaded&lt;/code&gt;.</source>
          <target state="translated">仅当（a）已加载或（b）它是GHCi知道的软件包中的模块时，才可以将模块添加到范围中（通过&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;import&lt;/code&gt; ）。使用&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;import&lt;/code&gt; 尝试将未加载的模块放入范围内可能导致消息 &lt;code&gt;module M is not loaded&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="269b166a8fb9660360ed22bb6ffd6ad1f5dbf714" translate="yes" xml:space="preserve">
          <source>You can add explicit phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; pragma, just like on an &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; pragma; if you do so, the same phase is used for the rewrite rule and the INLINE control of the specialised function.</source>
          <target state="translated">您可以向 &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; pragma 添加显式的相位控制（&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;），就像在&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt; pragma上一样；如果这样做，则重写规则和专用功能的INLINE控制将使用相同的阶段。</target>
        </trans-unit>
        <trans-unit id="76b4dc225411289e9acdbfffaafe383a16ca2930" translate="yes" xml:space="preserve">
          <source>You can add phase control (&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;) to the RULE generated by a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, just as you can if you write a &lt;code&gt;RULE&lt;/code&gt; directly. For example:</source>
          <target state="translated">您可以将相位控制（&lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;）添加到由 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示生成的RULE中，就像直接编写 &lt;code&gt;RULE&lt;/code&gt; 一样。例如：</target>
        </trans-unit>
        <trans-unit id="d19396807b5bb813f8f10443b8f102685ebd9a78" translate="yes" xml:space="preserve">
          <source>You can also define functions at the prompt:</source>
          <target state="translated">你也可以在提示中定义函数。</target>
        </trans-unit>
        <trans-unit id="9f2d6d5ccc9f9a9d9f25489b257a5154dc96e794" translate="yes" xml:space="preserve">
          <source>You can also get this in a more future-proof, machine readable format, with &lt;code&gt;-t --machine-readable&lt;/code&gt;:</source>
          <target state="translated">您还可以通过 &lt;code&gt;-t --machine-readable&lt;/code&gt; ：以更面向未来的，机器可读的格式获取它：</target>
        </trans-unit>
        <trans-unit id="a5b15205797af6957ff9cf5c81b6dc586582e3e9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="translated">您也可以改用独立派生声明（请参阅&lt;a href=&quot;#stand-alone-deriving&quot;&gt;独立派生声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="57941d0a16c36578ea47401b7ab5a6add62861a9" translate="yes" xml:space="preserve">
          <source>You can also use a standalone deriving declaration instead (see &lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;Stand-alone deriving declarations&lt;/a&gt;).</source>
          <target state="translated">您也可以改用独立派生声明（请参阅&lt;a href=&quot;standalone_deriving#stand-alone-deriving&quot;&gt;独立派生声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf82ec7c5c55deb1e4326a6cd0200b4cd6f00276" translate="yes" xml:space="preserve">
          <source>You can annotate modules with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;module&lt;/code&gt; keyword. For example:</source>
          <target state="translated">您可以使用 &lt;code&gt;module&lt;/code&gt; 关键字使用 &lt;code&gt;ANN&lt;/code&gt; 编译注释模块。例如：</target>
        </trans-unit>
        <trans-unit id="bd200064406d69a57200444728341c157a15f8d7" translate="yes" xml:space="preserve">
          <source>You can annotate types with the &lt;code&gt;ANN&lt;/code&gt; pragma by using the &lt;code&gt;type&lt;/code&gt; keyword. For example:</source>
          <target state="translated">您可以使用 &lt;code&gt;type&lt;/code&gt; 关键字使用 &lt;code&gt;ANN&lt;/code&gt; 编译注释类型。例如：</target>
        </trans-unit>
        <trans-unit id="190d499d4f768a4e6267637fa569282ca6b46254" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a forall type:</source>
          <target state="translated">您可以将类型同义词应用于forall类型。</target>
        </trans-unit>
        <trans-unit id="9c64d81db37258386a1e4b81a293b2b44f3418af" translate="yes" xml:space="preserve">
          <source>You can apply a type synonym to a partially applied type synonym:</source>
          <target state="translated">您可以将类型同义词应用到部分应用的类型同义词上。</target>
        </trans-unit>
        <trans-unit id="7ff9739eba78b0ef326aef750e441b5f886825f8" translate="yes" xml:space="preserve">
          <source>You can attach a warning to a function, class, type, or data constructor, with the following top-level declarations:</source>
          <target state="translated">你可以将警告附加到一个函数、类、类型或数据构造函数中,使用以下顶层声明。</target>
        </trans-unit>
        <trans-unit id="f496445edbfd2209c4adb64a23b8653fa9374d16" translate="yes" xml:space="preserve">
          <source>You can build Haskell code into a shared library and make a package to be used by other Haskell programs. The easiest way is using Cabal, simply configure the Cabal package with the &lt;code&gt;--enable-shared&lt;/code&gt; flag.</source>
          <target state="translated">您可以将Haskell代码构建到共享库中，并制作一个程序包以供其他Haskell程序使用。最简单的方法是使用Cabal，只需使用 &lt;code&gt;--enable-shared&lt;/code&gt; 标志配置Cabal软件包。</target>
        </trans-unit>
        <trans-unit id="84f62a92315cdce6616bfcedb52e44f10633e662" translate="yes" xml:space="preserve">
          <source>You can change the messages printed when the runtime system &amp;ldquo;blows up,&amp;rdquo; e.g., on stack overflow. The hooks for these are as follows:</source>
          <target state="translated">您可以更改运行系统&amp;ldquo;爆炸&amp;rdquo;时（例如，在堆栈溢出时）打印的消息。这些挂钩如下：</target>
        </trans-unit>
        <trans-unit id="0d971c05fa641eaafca23d1a4589109ee786b1b8" translate="yes" xml:space="preserve">
          <source>You can check if your GHC is unregisterised by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">您可以通过调用 &lt;code&gt;ghc --info&lt;/code&gt; （请参阅&lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;）来检查您的GHC是否未注册。</target>
        </trans-unit>
        <trans-unit id="4ddf7fef2dbc32cef483b738d74cadfca1ba8b1a" translate="yes" xml:space="preserve">
          <source>You can control GHC&amp;rsquo;s package database stack using the following options:</source>
          <target state="translated">您可以使用以下选项控制GHC的软件包数据库堆栈：</target>
        </trans-unit>
        <trans-unit id="9ad73c7ee3619d8e3b374d0e125dd12d41cec6bc" translate="yes" xml:space="preserve">
          <source>You can define a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; by either defining &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; or by defining both &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可以通过定义 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 或同时定义 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; 来定义 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53d888cce5d1295c1df726fcad67480174d570f2" translate="yes" xml:space="preserve">
          <source>You can disable specific classes, or enable/disable all classes at once:</source>
          <target state="translated">您可以禁用特定的类,也可以同时启用/禁用所有类。</target>
        </trans-unit>
        <trans-unit id="2fbcd80b12cae4ea9adddbab75b6d400e890e23d" translate="yes" xml:space="preserve">
          <source>You can even implement traverse using foldTree:</source>
          <target state="translated">你甚至可以使用foldTree实现traverse。</target>
        </trans-unit>
        <trans-unit id="a260428745d36797e89aab007cfe35565db63b20" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="translated">您可以从&lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;&amp;ldquo;快乐首页&amp;rdquo;&lt;/a&gt;获得 &lt;code&gt;happy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c27857069203c5dd912883a5866ed1ec720c2ef7" translate="yes" xml:space="preserve">
          <source>You can get &lt;code&gt;happy&lt;/code&gt; from &lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;the Happy Homepage&lt;/a&gt;.</source>
          <target state="translated">您可以从&lt;a href=&quot;https://www.haskell.org/happy/&quot;&gt;&amp;ldquo;快乐首页&amp;rdquo;&lt;/a&gt;获得 &lt;code&gt;happy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26072251a75edc8b05b0ea7a052c2c2aab0d70e9" translate="yes" xml:space="preserve">
          <source>You can have an unboxed tuple in a pattern binding, thus</source>
          <target state="translated">你可以在一个模式绑定中拥有一个未装箱的元组,因此</target>
        </trans-unit>
        <trans-unit id="e9c31fd3f547dd66812622d105b2e524f835762e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">但是，您可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 来构建无限的惰性ByteString。</target>
        </trans-unit>
        <trans-unit id="20f45eef250ed5478e99a9bcb99d2a343f22a32e" translate="yes" xml:space="preserve">
          <source>You can however use &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt;, as well as &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt;, to build infinite lazy ByteStrings.</source>
          <target state="translated">但是，您可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cons&quot;&gt;cons&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:repeat&quot;&gt;repeat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 来构建无限的惰性ByteString。</target>
        </trans-unit>
        <trans-unit id="7e461b7e374bf4b1ebdad57b113f09b1939fc459" translate="yes" xml:space="preserve">
          <source>You can identify an orphan module by looking in its interface file, &lt;code&gt;M.hi&lt;/code&gt;, using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;a href=&quot;using#modes&quot;&gt;mode&lt;/a&gt;. If there is a &lt;code&gt;[orphan module]&lt;/code&gt; on the first line, GHC considers it an orphan module.</source>
          <target state="translated">您可以使用 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;a href=&quot;using#modes&quot;&gt;模式&lt;/a&gt;在接口文件 &lt;code&gt;M.hi&lt;/code&gt; 中查找来标识孤立模块。如果第一行上有一个 &lt;code&gt;[orphan module]&lt;/code&gt; ，则GHC会将其视为一个孤立模块。</target>
        </trans-unit>
        <trans-unit id="38974e60b1eeba7a0c51ba486dac9a8715f3e4cb" translate="yes" xml:space="preserve">
          <source>You can include instance declarations as in Haskell; just omit the &amp;ldquo;where&amp;rdquo; part. An instance declaration need not be implemented directly; if an instance can be derived based on instances in the environment, it is considered implemented. For example, the following signature:</source>
          <target state="translated">您可以像在Haskell中那样包含实例声明。只是省略&amp;ldquo; where&amp;rdquo;部分。实例声明不需要直接实现；如果可以根据环境中的实例派生实例，则将其视为已实现。例如，以下签名：</target>
        </trans-unit>
        <trans-unit id="883238e8f9c1b291d24a7f3127451079919bd8ed" translate="yes" xml:space="preserve">
          <source>You can include instance declarations just as in Haskell; but omit the &amp;ldquo;where&amp;rdquo; part.</source>
          <target state="translated">您可以像在Haskell中一样包含实例声明。但忽略&amp;ldquo; where&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="dbe26650bd87158ad61fd3785ea8839ebbef7ad8" translate="yes" xml:space="preserve">
          <source>You can look at particular regions of your profile simply by loading a copy of the &lt;code&gt;.hp&lt;/code&gt; file into a text editor and deleting the unwanted samples. The resulting &lt;code&gt;.hp&lt;/code&gt; file can be run through &lt;code&gt;hp2ps&lt;/code&gt; and viewed or printed.</source>
          <target state="translated">您只需将 &lt;code&gt;.hp&lt;/code&gt; 文件的副本加载到文本编辑器中并删除不需要的样本，即可查看配置文件的特定区域。生成的 &lt;code&gt;.hp&lt;/code&gt; 文件可以通过 &lt;code&gt;hp2ps&lt;/code&gt; 运行并查看或打印。</target>
        </trans-unit>
        <trans-unit id="0c84e4d34de9122e33e533828fb9f8724a21faac" translate="yes" xml:space="preserve">
          <source>You can make &lt;code&gt;stdin&lt;/code&gt; reset itself after every evaluation by giving GHCi the command &lt;code&gt;:set +r&lt;/code&gt;. This works because &lt;code&gt;stdin&lt;/code&gt; is just a top-level expression that can be reverted to its unevaluated state in the same way as any other top-level expression (CAF).</source>
          <target state="translated">您可以在每次评估后通过给GHCi命令 &lt;code&gt;:set +r&lt;/code&gt; 来使 &lt;code&gt;stdin&lt;/code&gt; 自身复位。之所以 &lt;code&gt;stdin&lt;/code&gt; 是因为stdin只是一个顶级表达式，可以以与其他任何顶级表达式（CAF）相同的方式还原到其未评估状态。</target>
        </trans-unit>
        <trans-unit id="e642c86265941a9874870fbd23a160343b970a77" translate="yes" xml:space="preserve">
          <source>You can make GHC diverge by using &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; on an ordinarily-recursive function.</source>
          <target state="translated">您可以通过在常规递归函数上使用 &lt;code&gt;SPECIALISE INLINE&lt;/code&gt; 来使GHC偏离。</target>
        </trans-unit>
        <trans-unit id="d1af34bbd7e2122f7192f46d93908d24a763ec3d" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell 2010 and GHC by:</source>
          <target state="translated">你可以通过以下方式制作同时适用于Haskell 2010和GHC的代码。</target>
        </trans-unit>
        <trans-unit id="410bc62782311c49772c6565c53d200146f4a94c" translate="yes" xml:space="preserve">
          <source>You can make code that works with both Haskell98/Haskell2010 and GHC by:</source>
          <target state="translated">你可以通过以下方式制作同时适用于Haskell98/Haskell2010和GHC的代码。</target>
        </trans-unit>
        <trans-unit id="acfc22cad2a308c7de056289b725564bbb1e0277" translate="yes" xml:space="preserve">
          <source>You can omit any combination of arguments to the tuple, as in the following</source>
          <target state="translated">你可以省略元组的任何参数组合,就像下面的那样</target>
        </trans-unit>
        <trans-unit id="4451b727c18bc51073a4d56eb70e8515e899636b" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="translated">您只能附加到正在编译的模块中顶层声明的实体，并且只能在实体列表中使用不合格的名称。大写名称，如 &lt;code&gt;T&lt;/code&gt; 是指&lt;em&gt;任一&lt;/em&gt;类型构造 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;或&lt;/em&gt;数据构造 &lt;code&gt;T&lt;/code&gt; 或两者如果两者都在范围内。如果两者都在范围内，则当前无法指定一个而不指定另一个（参见fixities &lt;a href=&quot;#infix-tycons&quot;&gt;Infix类型构造函数，类和类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8e643fb8989b6abc3ab3ad51c09cde6dbbb32996" translate="yes" xml:space="preserve">
          <source>You can only attach to entities declared at top level in the module being compiled, and you can only use unqualified names in the list of entities. A capitalised name, such as &lt;code&gt;T&lt;/code&gt; refers to &lt;em&gt;either&lt;/em&gt; the type constructor &lt;code&gt;T&lt;/code&gt;&lt;em&gt;or&lt;/em&gt; the data constructor &lt;code&gt;T&lt;/code&gt;, or both if both are in scope. If both are in scope, there is currently no way to specify one without the other (c.f. fixities &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;).</source>
          <target state="translated">您只能附加到正在编译的模块中顶层声明的实体，并且只能在实体列表中使用不合格的名称。大写名称，如 &lt;code&gt;T&lt;/code&gt; 是指&lt;em&gt;任一&lt;/em&gt;类型构造 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;或&lt;/em&gt;数据构造 &lt;code&gt;T&lt;/code&gt; 或两者如果两者都在范围内。如果两者都在范围内，则当前无法指定一个不包含另一个（参见fixities &lt;a href=&quot;infix_tycons#infix-tycons&quot;&gt;Infix类型构造函数，类和类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f886d18b90cb7daa351868e61fa0d9da62761871" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module &lt;em&gt;that is not part of a mutually-recursive group of modules that includes the module currently being compiled&lt;/em&gt;. Furthermore, all of the modules of the mutually-recursive group must be reachable by non-SOURCE imports from the module where the splice is to be run.</source>
          <target state="translated">如果函数是从另一个模块导入的，则该函数只能在编译时运行，而该模块&lt;em&gt;不是包含当前正在编译的模块的相互递归模块组的一部分&lt;/em&gt;。此外，非递归组中的所有模块都必须可以通过非源导入从要运行拼接的模块中访问。</target>
        </trans-unit>
        <trans-unit id="2006128483b352bda9f0e5cd0d687c4c8519ed68" translate="yes" xml:space="preserve">
          <source>You can only run a function at compile time if it is imported from another module. That is, you can&amp;rsquo;t define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it&amp;rsquo;s hard to implement.)</source>
          <target state="translated">如果功能是从另一个模块导入的，则只能在编译时运行。也就是说，您不能在模块中定义函数，而只能在同一模块的接头内调用它。（这样做很有意义，但是很难实现。）</target>
        </trans-unit>
        <trans-unit id="0f32acc6c773313553a7cd09864edd18e6cff35d" translate="yes" xml:space="preserve">
          <source>You can package up a complete Haskell program as a DLL, to be called by some external (usually non-Haskell) program. This is usually used to implement plugins and the like, and is described below.</source>
          <target state="translated">您可以将一个完整的 Haskell 程序打包成一个 DLL,以便被一些外部 (通常是非 Haskell)程序调用。这通常用于实现插件和类似的东西,下面将对其进行描述。</target>
        </trans-unit>
        <trans-unit id="8f1f2284e872267e26710c33db91da1ce9d66612" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="translated">您可以在GHC评论中&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/RecompilationAvoidance&quot;&gt;了解所有这些工作原理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b48804fb365ae68472ebab1f616e9dd08d1939a" translate="yes" xml:space="preserve">
          <source>You can read about &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance&quot;&gt;how all this works&lt;/a&gt; in the GHC commentary.</source>
          <target state="translated">您可以在GHC评论中&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/recompilation-avoidance&quot;&gt;了解所有这些工作原理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3199ab54d6438266dcddd5dc087118e34b7a0e2d" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">您可以像普通的 &lt;code&gt;do&lt;/code&gt; -notation一样阅读此内容，但是可以使用命令代替monadic表达式。第一行将 &lt;code&gt;x+1&lt;/code&gt; 的值作为输入发送到箭头 &lt;code&gt;f&lt;/code&gt; ，并将其输出与 &lt;code&gt;y&lt;/code&gt; 相匹配。在下一行中，输出将被丢弃。箭头 &lt;code&gt;returnA&lt;/code&gt; 在&lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义为 &lt;code&gt;arr id&lt;/code&gt; 。上面的示例被视为的缩写。</target>
        </trans-unit>
        <trans-unit id="4e9702340c88d3c9a130465b064633bbe3ada3fe" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">您可以像普通的 &lt;code&gt;do&lt;/code&gt; -notation 一样阅读此内容，但是可以使用命令代替monadic表达式。第一行将 &lt;code&gt;x+1&lt;/code&gt; 的值作为输入发送到箭头 &lt;code&gt;f&lt;/code&gt; ，并将其输出与 &lt;code&gt;y&lt;/code&gt; 相匹配。在下一行中，输出将被丢弃。箭头 &lt;code&gt;returnA&lt;/code&gt; 在&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义为 &lt;code&gt;arr id&lt;/code&gt; 。上面的示例被视为的缩写</target>
        </trans-unit>
        <trans-unit id="e35a1b51b1f66368a4527f3e02178b039c453864" translate="yes" xml:space="preserve">
          <source>You can read this much like ordinary &lt;code&gt;do&lt;/code&gt;-notation, but with commands in place of monadic expressions. The first line sends the value of &lt;code&gt;x+1&lt;/code&gt; as an input to the arrow &lt;code&gt;f&lt;/code&gt;, and matches its output against &lt;code&gt;y&lt;/code&gt;. In the next line, the output is discarded. The arrow &lt;code&gt;returnA&lt;/code&gt; is defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module as &lt;code&gt;arr id&lt;/code&gt;. The above example is treated as an abbreviation for</source>
          <target state="translated">您可以像普通的 &lt;code&gt;do&lt;/code&gt; -notation一样阅读此内容，但是可以使用命令代替monadic表达式。第一行将 &lt;code&gt;x+1&lt;/code&gt; 的值作为输入发送到箭头 &lt;code&gt;f&lt;/code&gt; ，并将其输出与 &lt;code&gt;y&lt;/code&gt; 相匹配。在下一行中，输出将被丢弃。箭头 &lt;code&gt;returnA&lt;/code&gt; 在&lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义为 &lt;code&gt;arr id&lt;/code&gt; 。上面的示例被视为的缩写。</target>
        </trans-unit>
        <trans-unit id="1e72e813532509ba13800f35b2a255158378cdcd" translate="yes" xml:space="preserve">
          <source>You can safely replace all the import declarations in &lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; with those found in its respective &lt;code&gt;.imports&lt;/code&gt; file. Why would you want to do that? Because the &amp;ldquo;minimal&amp;rdquo; imports (a) import everything explicitly, by name, and (b) import nothing that is not required. It can be quite painful to maintain this property by hand, so this flag is intended to reduce the labour.</source>
          <target state="translated">您可以将 &lt;code&gt;&lt;em&gt;M&lt;/em&gt;.hs&lt;/code&gt; 所有导入声明安全地替换为其相应的 &lt;code&gt;.imports&lt;/code&gt; 文件中的声明。你为什么想这么做？因为&amp;ldquo;最小&amp;rdquo;导入（a）按名称显式导入所有内容，并且（b）不导入不需要的任何内容。用手维护此属性可能会很痛苦，因此此标志旨在减少人工。</target>
        </trans-unit>
        <trans-unit id="4cd2c20dc8038404cfcf2cb0390b2cee882280b8" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">您可以将 &lt;code&gt;Main.hs&lt;/code&gt; 保存在任意位置，但是如果将其保存在当前目录&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[3]&lt;/a&gt;之外的其他位置，则我们需要在GHCi中更改为正确的目录：</target>
        </trans-unit>
        <trans-unit id="2311eafd5220e927965cb0ade033a0464e40e05e" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;3&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">您可以将 &lt;code&gt;Main.hs&lt;/code&gt; 保存在任意位置，但是如果将其保存在当前目录&lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;3&lt;/a&gt;之外的其他位置，则我们需要在GHCi中更改为正确的目录：</target>
        </trans-unit>
        <trans-unit id="3d11ab0fd694aaac48c2e11aa4e207640df0eae3" translate="yes" xml:space="preserve">
          <source>You can save &lt;code&gt;Main.hs&lt;/code&gt; anywhere you like, but if you save it somewhere other than the current directory &lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3]&lt;/a&gt; then we will need to change to the right directory in GHCi:</source>
          <target state="translated">您可以将 &lt;code&gt;Main.hs&lt;/code&gt; 保存在任意位置，但是如果将其保存在当前目录&lt;a href=&quot;#id7&quot; id=&quot;id6&quot;&gt;[3]&lt;/a&gt;之外的其他位置，则我们需要在GHCi中更改为正确的目录：</target>
        </trans-unit>
        <trans-unit id="6d1cddce0e95133d2f0c91e06c39268e36da2d8c" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;../using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用标志&lt;a href=&quot;../using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt; &lt;/a&gt;禁止显示警告。</target>
        </trans-unit>
        <trans-unit id="ee71858b230e5297e34b408df25cee981faf2858" translate="yes" xml:space="preserve">
          <source>You can suppress the warnings with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt;&lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您可以使用标志&lt;a href=&quot;using-warnings#ghc-flag--Wwarnings-deprecations&quot;&gt; &lt;code&gt;-Wno-warnings-deprecations&lt;/code&gt; &lt;/a&gt;禁止显示警告。</target>
        </trans-unit>
        <trans-unit id="d5b5b508f9d570be456fe99f9c95ddc6eecec794" translate="yes" xml:space="preserve">
          <source>You can turn each Haskell package into a DLL, so that multiple Haskell executables using the same packages can share the DLL files. (As opposed to linking the libraries statically, which in effect creates a new copy of the RTS and all libraries for each executable produced.)</source>
          <target state="translated">您可以将每个 Haskell 包变成一个 DLL,这样使用相同包的多个 Haskell 可执行文件就可以共享 DLL 文件。(与静态链接库不同,静态链接库实际上是为每个可执行文件创建一个新的RTS和所有库的副本。)</target>
        </trans-unit>
        <trans-unit id="6a0144c3e2ac0c6bb9606a34c0cd2ffa74b49390" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; to obtain integer/word timestamps. For example:</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;data-time-clock-posix#t:POSIXTime&quot;&gt;POSIXTime&lt;/a&gt;&lt;/code&gt; 获得整数/字时间戳。例如：</target>
        </trans-unit>
        <trans-unit id="fbf78f5184b54413fec2edf8ed7eaa43cd191246" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a &lt;code&gt;data instance&lt;/code&gt; or &lt;code&gt;newtype instance&lt;/code&gt; declaration.</source>
          <target state="translated">您可以在 &lt;code&gt;data instance&lt;/code&gt; 或 &lt;code&gt;newtype instance&lt;/code&gt; 声明上使用 &lt;code&gt;deriving&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="4aac8ca00f383844bd9a5a98bae02690f26dd140" translate="yes" xml:space="preserve">
          <source>You can use a &lt;code&gt;deriving&lt;/code&gt; clause on a GADT-style data type declaration. For example, these two declarations are equivalent</source>
          <target state="translated">您可以在GADT样式的数据类型声明中使用 &lt;code&gt;deriving&lt;/code&gt; 子句。例如，这两个声明是等效的</target>
        </trans-unit>
        <trans-unit id="b44303f497b7577f2a1611533f1079fe99f952ce" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">如果您手动初始化RTS并通过 &lt;code&gt;-no-hs-main&lt;/code&gt; ,则可以使用外部main函数。另请参阅&lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="243f575d20a545ebc20c87833a714937518039c5" translate="yes" xml:space="preserve">
          <source>You can use an external main function if you initialize the RTS manually and pass &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">如果您手动初始化RTS并通过 &lt;code&gt;-no-hs-main&lt;/code&gt; ,则可以使用外部main函数。另请参阅&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e680225c09eb0b9138a98df5d3c63c9df7449b8c" translate="yes" xml:space="preserve">
          <source>You can use record syntax on a GADT-style data type declaration:</source>
          <target state="translated">你可以在GADT风格的数据类型声明上使用记录语法。</target>
        </trans-unit>
        <trans-unit id="fa6a1ff9acc225bb23ca386352cd635b7095181d" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;exts/rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="translated">您可以使用重命名来提供替代的前奏，例如 &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt; ，代替&lt;a href=&quot;exts/rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable语法和隐式的Prelude导入&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="409585b916d348cb201d92711807df5aad400581" translate="yes" xml:space="preserve">
          <source>You can use renaming to provide an alternate prelude, e.g. &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt;, in lieu of the &lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt; extension.</source>
          <target state="translated">您可以使用重命名来提供替代的前奏，例如 &lt;code&gt;-hide-all-packages -package &quot;basic-prelude (BasicPrelude as Prelude)&quot;&lt;/code&gt; ，代替&lt;a href=&quot;glasgow_exts#rebindable-syntax&quot;&gt;Rebindable语法和隐式的Prelude导入&lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="34cd599ca69b1635630c1789384078026b1631bc" translate="yes" xml:space="preserve">
          <source>You can use strictness annotations, in the obvious places in the constructor type:</source>
          <target state="translated">你可以使用严格性注解,在构造函数类型的明显位置。</target>
        </trans-unit>
        <trans-unit id="ed972027c3bec7c1eb51e6a5766ee6c2d7ade065" translate="yes" xml:space="preserve">
          <source>You can work on an entire module thus:</source>
          <target state="translated">你可以这样对整个模块进行工作。</target>
        </trans-unit>
        <trans-unit id="bf48999c2bd9335885a5b2d5518e8a1da408a898" translate="yes" xml:space="preserve">
          <source>You can wrap a series of foreign function calls that rely on thread-local state with &lt;code&gt;runInBoundThread&lt;/code&gt; so that you can use them without knowing whether the current thread is &lt;em&gt;bound&lt;/em&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;runInBoundThread&lt;/code&gt; 包装依赖于线程局部状态的一系列外部函数调用，以便您可以在不知道当前线程是否&lt;em&gt;绑定的&lt;/em&gt;情况下使用它们。</target>
        </trans-unit>
        <trans-unit id="01f309884997472a9a1052740889026ae8bf67aa" translate="yes" xml:space="preserve">
          <source>You can write a &lt;code&gt;forall&lt;/code&gt; (including overloading) in a type synonym, thus:</source>
          <target state="translated">您可以用类型同义词写一个 &lt;code&gt;forall&lt;/code&gt; （包括重载），因此：</target>
        </trans-unit>
        <trans-unit id="4c8f6089007a930f61ef159774cdb1a472069313" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t have an implicit parameter in the context of a class or instance declaration. For example, both these declarations are illegal:</source>
          <target state="translated">在类或实例声明的上下文中不能有隐式参数。例如，这两个声明都是非法的：</target>
        </trans-unit>
        <trans-unit id="4de126d4c7a597b1d236ebb25b9bb6637ffa49d2" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t pattern-match on an existentially quantified constructor in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; group of bindings. So this is illegal:</source>
          <target state="translated">您不能在 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 绑定组中对现有的量化构造函数进行模式匹配。所以这是非法的：</target>
        </trans-unit>
        <trans-unit id="c72ea2d044d7e8facee1aae8ded417fac4a31d3f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use &lt;code&gt;deriving&lt;/code&gt; to define instances of a data type with existentially quantified data constructors. Reason: in most cases it would not make sense. For example:;</source>
          <target state="translated">您不能使用 &lt;code&gt;deriving&lt;/code&gt; 定义具有存在量化数据构造函数的数据类型实例。原因：在大多数情况下，这没有任何意义。例如：;</target>
        </trans-unit>
        <trans-unit id="f58bc414fc59408f4615033fa5f4af7c26c36eb5" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use existential quantification for &lt;code&gt;newtype&lt;/code&gt; declarations. So this is illegal:</source>
          <target state="translated">不能使用存在量化为 &lt;code&gt;newtype&lt;/code&gt; 声明。所以这是非法的：</target>
        </trans-unit>
        <trans-unit id="3b5cdddee5d2f5aa4dc4f653d99b00c57d60b7ea" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;recursive&lt;/em&gt; binding.</source>
          <target state="translated">您不能在&lt;em&gt;递归&lt;/em&gt;绑定中将未装箱类型的变量绑定。</target>
        </trans-unit>
        <trans-unit id="8fc0d15dc8ae90bf550f66d4910d3cffc3b11e0a" translate="yes" xml:space="preserve">
          <source>You cannot bind a variable with an unboxed type in a &lt;em&gt;top-level&lt;/em&gt; binding.</source>
          <target state="translated">您不能在&lt;em&gt;顶级&lt;/em&gt;绑定中绑定未装箱类型的变量。</target>
        </trans-unit>
        <trans-unit id="2b1b59bb7b1256234d2e287ed8419a725eea98b4" translate="yes" xml:space="preserve">
          <source>You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:</source>
          <target state="translated">你不能定义一个其表示类型(数据构造函数的参数类型)是未装箱类型的newtype。因此,这是非法的。</target>
        </trans-unit>
        <trans-unit id="53d57a9a763d91b8c3c30f9e88b44d16989b4ef8" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;deriving&lt;/code&gt; on a data type declaration; write an &lt;code&gt;instance&lt;/code&gt; declaration instead.</source>
          <target state="translated">您不能对数据类型声明使用 &lt;code&gt;deriving&lt;/code&gt; ；而是写一个 &lt;code&gt;instance&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="6c32b374e885a0b6d9cb00079f7e8613d4b04f29" translate="yes" xml:space="preserve">
          <source>You cannot use a &lt;code&gt;deriving&lt;/code&gt; clause for a GADT; only for an ordinary data type.</source>
          <target state="translated">您不能对GADT 使用 &lt;code&gt;deriving&lt;/code&gt; 子句；仅适用于普通数据类型。</target>
        </trans-unit>
        <trans-unit id="30dbefdf45ec49645c5f83a96844f0e523320cd0" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;lsquo;s data constructors, you have to list it separately.</source>
          <target state="translated">您不能编写 &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; ，即子组件规格不能嵌套。要指定 &lt;code&gt;GMap&lt;/code&gt; 的数据构造函数，您必须单独列出它。</target>
        </trans-unit>
        <trans-unit id="504d8482be9fb213017caf5dad95956603bd628a" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; &amp;mdash; i.e., sub-component specifications cannot be nested. To specify &lt;code&gt;GMap&lt;/code&gt;&amp;rsquo;s data constructors, you have to list it separately.</source>
          <target state="translated">您不能编写 &lt;code&gt;GMapKey(type GMap(..))&lt;/code&gt; ，即子组件规范不能嵌套。要指定 &lt;code&gt;GMap&lt;/code&gt; 的数据构造函数，您必须单独列出它。</target>
        </trans-unit>
        <trans-unit id="801821aa8abcdb27ec906dde72beecfda446438f" translate="yes" xml:space="preserve">
          <source>You construct values of types &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; by applying the constructor to suitable values, just as usual. For example,</source>
          <target state="translated">像往常一样 &lt;code&gt;T1, MonadT, Swizzle&lt;/code&gt; 通过将构造函数应用于适当的值来构造T1，MonadT，Swizzle类型的值。例如，</target>
        </trans-unit>
        <trans-unit id="35e2c1cf685c898a2ffd48135532e04038f5cd4e" translate="yes" xml:space="preserve">
          <source>You could also refactor to a left-fold, to decode in a more streaming fashion, and get the following decoder. It will start to return data without knowing that it can decode all input.</source>
          <target state="translated">你也可以重构为左折,以更流的方式进行解码,得到如下的解码器。它将开始返回数据,而不知道它可以解码所有的输入。</target>
        </trans-unit>
        <trans-unit id="71ec1076802c7edea768f5f032750297cd230b60" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to write a &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">您不必编写 &lt;code&gt;Makefile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="672d8bd48c35b0238c3a6248aa09088d6f74bcfe" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to give a type signature if the lambda bound variable is a constructor argument. Here is an example we saw earlier:</source>
          <target state="translated">如果lambda绑定变量是构造函数参数，则无需提供类型签名。这是我们之前看到的示例：</target>
        </trans-unit>
        <trans-unit id="e18c34733b256b9593b5ee6ff19c7fc0070729c9" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use &lt;code&gt;-fprof-auto&lt;/code&gt; for interpreted modules, annotations are automatically added at a granularity fine enough to distinguish individual call sites. However, you won&amp;rsquo;t see any call stack information for compiled code unless it was compiled with &lt;code&gt;-fprof-auto&lt;/code&gt; or has explicit &lt;code&gt;SCC&lt;/code&gt; annotations (see &lt;a href=&quot;profiling#scc-pragma&quot;&gt;Inserting cost centres by hand&lt;/a&gt;).</source>
          <target state="translated">您无需为解释的模块使用 &lt;code&gt;-fprof-auto&lt;/code&gt; ，注释将自动以足以区分各个调用站点的粒度添加。但是，除非使用 &lt;code&gt;-fprof-auto&lt;/code&gt; 进行编译或具有显式的 &lt;code&gt;SCC&lt;/code&gt; 注释，否则您将看不到任何已编译代码的调用堆栈信息（请参阅&lt;a href=&quot;profiling#scc-pragma&quot;&gt;手动插入成本中心&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31b23007442846d8966d8b9c7845ac06100f1b24" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt;</source>
          <target state="translated">你会得到 &lt;code&gt;:type 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ece0b208425f5c34d6d99b2faf1ff3266b3af5" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro, not the builtin.</source>
          <target state="translated">您将使用定义的宏（而不是内置宏）获得 &lt;code&gt;:type 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55bf28bc378f0c361c15d24c0484d765d31cbd6c" translate="yes" xml:space="preserve">
          <source>You get &lt;code&gt;:type 3&lt;/code&gt; with your defined macro.</source>
          <target state="translated">您将获得 &lt;code&gt;:type 3&lt;/code&gt; 和定义的宏。</target>
        </trans-unit>
        <trans-unit id="351ad6e5432243b3e78e9a641aceba23d847888a" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and a macro &lt;code&gt;:type&lt;/code&gt;, and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">您有一个宏 &lt;code&gt;:time&lt;/code&gt; 和一个宏 &lt;code&gt;:type&lt;/code&gt; ，然后输入 &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b967e14a3b2c88438d391b51a97e44abc37b8a3" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:time&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">您有一个宏 &lt;code&gt;:time&lt;/code&gt; ,然后输入 &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e64bb8bb775010f86695f2cafd801d4cc29f97f" translate="yes" xml:space="preserve">
          <source>You have a macro &lt;code&gt;:type&lt;/code&gt; and enter &lt;code&gt;:t 3&lt;/code&gt;</source>
          <target state="translated">您有一个宏 &lt;code&gt;:type&lt;/code&gt; ,然后输入 &lt;code&gt;:t 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c5292c5b2bc0c1ca9d4ca9e4d5b25bbd9e291c2" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;code&gt;pattern&lt;/code&gt; keyword in an import/export specification to import or export an ordinary data constructor. For example:</source>
          <target state="translated">您也可以在导入/导出规范中使用 &lt;code&gt;pattern&lt;/code&gt; 关键字来导入或导出普通数据构造函数。例如：</target>
        </trans-unit>
        <trans-unit id="f8581425af0954edf998e6f74b1289f4b2aad7a8" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences:</source>
          <target state="translated">你也可以写一个显式指数,它类似于十进制符号中的指数,但有以下区别。</target>
        </trans-unit>
        <trans-unit id="b74a8315c09d21b66a862d09b6cf623f9312b66e" translate="yes" xml:space="preserve">
          <source>You may also write an explicit exponent, which is similar to the exponent in decimal notation with the following differences: - the exponent begins with &lt;code&gt;p&lt;/code&gt; instead of &lt;code&gt;e&lt;/code&gt; - the exponent is written in base &lt;code&gt;10&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16) - the base of the exponent is &lt;code&gt;2&lt;/code&gt; (&lt;strong&gt;not&lt;/strong&gt; 16).</source>
          <target state="translated">您也可以编写一个显式指数，该指数与十进制表示法的指数相似，但有以下区别：-指数以 &lt;code&gt;p&lt;/code&gt; 而不是 &lt;code&gt;e&lt;/code&gt; 开头-指数以 &lt;code&gt;10&lt;/code&gt; 为底（&lt;strong&gt;不是&lt;/strong&gt; 16）-指数的底数为 &lt;code&gt;2&lt;/code&gt; （&lt;strong&gt;不是&lt;/strong&gt; 16）。</target>
        </trans-unit>
        <trans-unit id="fd00758a07ccd8e4012b39a3ffcc36b497dde263" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;../using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="translated">您可以在（非递归，非顶级）模式绑定中绑定未装箱的变量，但是必须使任何此类模式匹配都严格。（不这样做将发出警告&lt;a href=&quot;../using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt; &lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt; &lt;/a&gt;。）例如，而不是：</target>
        </trans-unit>
        <trans-unit id="8707d0873e271cfc9458fd1a9219b507929f88d1" translate="yes" xml:space="preserve">
          <source>You may bind unboxed variables in a (non-recursive, non-top-level) pattern binding, but you must make any such pattern-match strict. (Failing to do so emits a warning &lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt;&lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt;&lt;/a&gt;.) For example, rather than:</source>
          <target state="translated">您可以在（非递归，非顶级）模式绑定中绑定未装箱的变量，但是必须使任何此类模式匹配严格。（不这样做将发出警告&lt;a href=&quot;using-warnings#ghc-flag--Wunbanged-strict-patterns&quot;&gt; &lt;code&gt;-Wunbanged-strict-patterns&lt;/code&gt; &lt;/a&gt;。）例如，而不是：</target>
        </trans-unit>
        <trans-unit id="e5864b6382b64fb2ddff9a22e3cb269048cd1a65" translate="yes" xml:space="preserve">
          <source>You may not mix implicit-parameter bindings with ordinary bindings in a single &lt;code&gt;let&lt;/code&gt; expression; use two nested &lt;code&gt;let&lt;/code&gt;s instead. (In the case of &lt;code&gt;where&lt;/code&gt; you are stuck, since you can&amp;rsquo;t nest &lt;code&gt;where&lt;/code&gt; clauses.)</source>
          <target state="translated">您不能在单个 &lt;code&gt;let&lt;/code&gt; 表达式中混合使用隐式参数绑定和普通绑定。使用两个嵌套的 &lt;code&gt;let&lt;/code&gt; 代替。（在的情况下， &lt;code&gt;where&lt;/code&gt; 你被卡住，因为你不能嵌套 &lt;code&gt;where&lt;/code&gt; 的条款。）</target>
        </trans-unit>
        <trans-unit id="8a15b835542506de56c4f0581f50dc84443c25f1" translate="yes" xml:space="preserve">
          <source>You may omit the &lt;code&gt;$(...)&lt;/code&gt; in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice. For example, you can write</source>
          <target state="translated">您可以在顶层声明拼接中省略 &lt;code&gt;$(...)&lt;/code&gt; 。简单地写一个表达式（而不是声明）就意味着一个拼接。例如，你可以写</target>
        </trans-unit>
        <trans-unit id="2a2636e1eccaa733c43b723cac9f02b969f1c6f5" translate="yes" xml:space="preserve">
          <source>You may put multiple implicit-parameter bindings in a single binding group; but they are &lt;em&gt;not&lt;/em&gt; treated as a mutually recursive group (as ordinary &lt;code&gt;let&lt;/code&gt; bindings are). Instead they are treated as a non-recursive group, simultaneously binding all the implicit parameter. The bindings are not nested, and may be re-ordered without changing the meaning of the program. For example, consider:</source>
          <target state="translated">您可以将多个隐式参数绑定放在一个绑定组中。但它们&lt;em&gt;不&lt;/em&gt;被视为相互递归的组（就像普通的 &lt;code&gt;let&lt;/code&gt; 绑定一样）。而是将它们视为非递归组，同时绑定所有隐式参数。绑定不是嵌套的，可以在不更改程序含义的情况下重新排序。例如，考虑：</target>
        </trans-unit>
        <trans-unit id="69c2bcd249a51f493b6d8defcfa352db2fe97573" translate="yes" xml:space="preserve">
          <source>You may specify an explicit &lt;em&gt;pattern signature&lt;/em&gt;, as we did for &lt;code&gt;ExNumPat&lt;/code&gt; above, to specify the type of a pattern, just as you can for a function. As usual, the type signature can be less polymorphic than the inferred type. For example</source>
          <target state="translated">您可以像在上面的 &lt;code&gt;ExNumPat&lt;/code&gt; 中那样指定显式的&lt;em&gt;模式签名&lt;/em&gt;，以指定模式的类型，就像对函数一样。通常，类型签名可以比推断的类型具有更少的多态性。例如</target>
        </trans-unit>
        <trans-unit id="e235042667b9c56eb4698542652a4ffe747fce1f" translate="yes" xml:space="preserve">
          <source>You may specify that a different program be used for one of the phases of the compilation system, in place of whatever the &lt;code&gt;ghc&lt;/code&gt; has wired into it. For example, you might want to try a different assembler. The following options allow you to change the external program used for a given compilation phase:</source>
          <target state="translated">您可以指定将一个不同的程序用于编译系统的某个阶段，以代替 &lt;code&gt;ghc&lt;/code&gt; 连接到其中的任何程序。例如，您可能想尝试其他汇编器。以下选项使您可以更改用于给定编译阶段的外部程序：</target>
        </trans-unit>
        <trans-unit id="ffee81bdfe61682f0576300599ea43f154d0f848" translate="yes" xml:space="preserve">
          <source>You may want to enable this warning on a clean build or enable &lt;a href=&quot;separate_compilation#ghc-flag--fforce-recomp&quot;&gt;&lt;code&gt;-fforce-recomp&lt;/code&gt;&lt;/a&gt; in order to get reliable results.</source>
          <target state="translated">您可能希望在干净的版本上启用此警告或启用&lt;a href=&quot;separate_compilation#ghc-flag--fforce-recomp&quot;&gt; &lt;code&gt;-fforce-recomp&lt;/code&gt; &lt;/a&gt;以获得可靠的结果。</target>
        </trans-unit>
        <trans-unit id="0c11ae553a6507ead096463536fbbb081dce0652" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="translated">您可能会编写在实例上下文和超类中使用特殊类型的约束的程序，但要这样做，必须使用&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;表示您不介意类型检查器是否无法终止。</target>
        </trans-unit>
        <trans-unit id="b5ea20c910ec7f1464378418d006e17f6554a38c" translate="yes" xml:space="preserve">
          <source>You may write programs that use exotic sorts of constraints in instance contexts and superclasses, but to do so you must use &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; to signal that you don&amp;rsquo;t mind if the type checker fails to terminate.</source>
          <target state="translated">您可能会编写在实例上下文和超类中使用特殊类型的约束的程序，但要这样做，您必须使用&lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;来表示您不介意类型检查器是否无法终止。</target>
        </trans-unit>
        <trans-unit id="d9ac328de126bafdb81fd66142c9606ef9f2bba1" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="translated">您可能还想看看&lt;a href=&quot;http://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;，这是一个用于显示堆配置文件的更高级的工具套件（未随GHC分发）。</target>
        </trans-unit>
        <trans-unit id="1b7c142259a42674ab1afa84950577edf68dc848" translate="yes" xml:space="preserve">
          <source>You might also want to take a look at &lt;a href=&quot;https://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;, a more advanced suite of tools (not distributed with GHC) for displaying heap profiles.</source>
          <target state="translated">您可能还想看看&lt;a href=&quot;https://www.haskell.org/haskellwiki/Hp2any&quot;&gt;hp2any&lt;/a&gt;，这是一个用于显示堆配置文件的更高级的工具套件（未随GHC分发）。</target>
        </trans-unit>
        <trans-unit id="1723e9eaca2c46aa402d493c6d51826bd13e2dec" translate="yes" xml:space="preserve">
          <source>You might find it useful to use Haskell&amp;rsquo;s &lt;code&gt;seq&lt;/code&gt; function to evaluate individual thunks rather than evaluating the whole expression with &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">您可能会发现，使用Haskell的 &lt;code&gt;seq&lt;/code&gt; 函数评估单个重击比使用&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;评估整个表达式有用。例如：</target>
        </trans-unit>
        <trans-unit id="8b2b2c5879599e9fb9784f8ece7db05367147809" translate="yes" xml:space="preserve">
          <source>You might want to use this if you are you have a type class method which returns a constrained type. For example, a type class where one of the methods implements a traversal.</source>
          <target state="translated">如果你有一个返回约束类型的类型类方法,你可能想使用这个方法。例如,一个类型类中的一个方法实现了一个遍历。</target>
        </trans-unit>
        <trans-unit id="7ca17a83d89102130bc3fbe2303f1ff784f0cd26" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;http://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">您必须在 &lt;code&gt;PATH&lt;/code&gt; 上安装LLVM并使其可用，才能使LLVM代码生成器正常工作。特别是，GHC需要能够调用 &lt;code&gt;opt&lt;/code&gt; 和 &lt;code&gt;llc&lt;/code&gt; 工具。其次，如果您运行的是LLVM 3.0或更高版本的Mac OS X，则还需要 &lt;code&gt;PATH&lt;/code&gt; 上可用的&lt;a href=&quot;http://clang.llvm.org&quot;&gt;Clang C编译&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="c7bbe7f9ceeb8533c080ff75b9bb78ac5f1bcaf6" translate="yes" xml:space="preserve">
          <source>You must install and have LLVM available on your &lt;code&gt;PATH&lt;/code&gt; for the LLVM code generator to work. Specifically GHC needs to be able to call the &lt;code&gt;opt&lt;/code&gt; and &lt;code&gt;llc&lt;/code&gt; tools. Secondly, if you are running Mac OS X with LLVM 3.0 or greater then you also need the &lt;a href=&quot;https://clang.llvm.org&quot;&gt;Clang C compiler&lt;/a&gt; compiler available on your &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">您必须在 &lt;code&gt;PATH&lt;/code&gt; 上安装LLVM并将其可用，才能使LLVM代码生成器正常工作。具体来说，GHC需要能够调用 &lt;code&gt;opt&lt;/code&gt; 和 &lt;code&gt;llc&lt;/code&gt; 工具。其次，如果您运行的是LLVM 3.0或更高版本的Mac OS X，那么您还需要 &lt;code&gt;PATH&lt;/code&gt; 上可用的&lt;a href=&quot;https://clang.llvm.org&quot;&gt;Clang C编译&lt;/a&gt;器。</target>
        </trans-unit>
        <trans-unit id="7848640f49a2013635063f5f2a65c426e3adec48" translate="yes" xml:space="preserve">
          <source>You need this when using &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 时需要此功能。</target>
        </trans-unit>
        <trans-unit id="5e3e8cd42cf48f666040b93e9cb7bcb77de13e8f" translate="yes" xml:space="preserve">
          <source>You need to build an &amp;ldquo;installed package info&amp;rdquo; file for passing to &lt;code&gt;ghc-pkg&lt;/code&gt; when installing your package. The contents of this file are described in &lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo: a package specification&lt;/a&gt;.</source>
          <target state="translated">您需要构建一个&amp;ldquo;已安装的软件包信息&amp;rdquo;文件，以便在安装软件包时传递给 &lt;code&gt;ghc-pkg&lt;/code&gt; 。该文件的内容在&lt;a href=&quot;#installed-pkg-info&quot;&gt;InstalledPackageInfo：程序包规范中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="ecae143bd200467151fc11557c8e8ff56f5c8728" translate="yes" xml:space="preserve">
          <source>You only need to enable this extension if the language you&amp;rsquo;re using is Haskell 98, in which a data type must have at least one constructor. Haskell 2010 relaxed this rule to allow data types with no constructors, and thus &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; is enabled by default when the language is Haskell 2010.</source>
          <target state="translated">仅当您使用的语言是Haskell 98时才需要启用此扩展，其中一种数据类型必须至少具有一个构造函数。Haskell 2010放宽了此规则，以允许没有构造函数的数据类型，因此，当语言为Haskell 2010时，默认情况下启用&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe3141ce96bc3bee7e55f9e3720a5ac4bb5237b4" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;../packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="translated">您可能不需要使用此功能，主要是添加了此功能，以便我们可以在API更改时构建软件包的向后兼容版本。在常见情况下，它可能导致脆弱的依赖关系：模块偶尔会从一个软件包移动到另一个软件包，从而使任何符合软件包要求的导入都中断了。另请参见&lt;a href=&quot;../packages#package-thinning-and-renaming&quot;&gt;稀疏和重命名模块&lt;/a&gt;，以消除模块名称之间的歧义。</target>
        </trans-unit>
        <trans-unit id="20e8c6e9c630a979645ea222c79a82dcdd527d41" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t need to use this feature, it was added mainly so that we can build backwards-compatible versions of packages when APIs change. It can lead to fragile dependencies in the common case: modules occasionally move from one package to another, rendering any package-qualified imports broken. See also &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt; for an alternative way of disambiguating between module names.</source>
          <target state="translated">您可能不需要使用此功能，它是主要添加的，以便在API更改时我们可以构建软件包的向后兼容版本。在通常情况下，它可能导致脆弱的依赖关系：模块偶尔会从一个软件包移动到另一个软件包，从而使任何符合软件包要求的导入都中断了。另请参见&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;稀疏和重命名模块&lt;/a&gt;，以消除模块名称之间的歧义。</target>
        </trans-unit>
        <trans-unit id="06a8acb7bef4875c53862bd963dfb3bee4782074" translate="yes" xml:space="preserve">
          <source>You should be careful with your installation function, because the list of passes you give back isn&amp;rsquo;t questioned or double checked by GHC at the time of this writing. An installation function like the following:</source>
          <target state="translated">您应该谨慎使用安装功能，因为在撰写本文时，GHC不会质疑或仔细检查您提供的通过列表。安装功能如下：</target>
        </trans-unit>
        <trans-unit id="c8fb8a0845765453a3b51653e072b1e3775e368f" translate="yes" xml:space="preserve">
          <source>You should not use this module unless you are determined to monkey with the internals, as the functions here do just about nothing to preserve data invariants. You have been warned!</source>
          <target state="translated">你不应该使用这个模块,除非你决定要在内部结构上做手脚,因为这里的函数对保护数据不变性毫无作用。你已经被警告了!</target>
        </trans-unit>
        <trans-unit id="e9580720487f8d0a617fa4e79bebc3170cc9fb48" translate="yes" xml:space="preserve">
          <source>You should think of the object file and the interface file as a pair, since the interface file is in a sense a compiler-readable description of the contents of the object file. If the interface file and object file get out of sync for any reason, then the compiler may end up making assumptions about the object file that aren&amp;rsquo;t true; trouble will almost certainly follow. For this reason, we recommend keeping object files and interface files in the same place (GHC does this by default, but it is possible to override the defaults as we&amp;rsquo;ll explain shortly).</source>
          <target state="translated">您应该将目标文件和接口文件视为一对，因为从某种意义上说，接口文件是目标文件内容的编译器可读描述。如果接口文件和目标文件由于某种原因不同步，那么编译器可能最终会做出关于目标文件的假设，而这些假设是不正确的。麻烦几乎肯定会随之而来。因此，我们建议将目标文件和接口文件放在同一位置（GHC默认情况下会这样做，但是有可能覆盖默认值，我们将在稍后解释）。</target>
        </trans-unit>
        <trans-unit id="c015ba62398898e9130e51965530b85d77f20111" translate="yes" xml:space="preserve">
          <source>You will eventually need all the values stored.</source>
          <target state="translated">你最终会需要所有存储的值。</target>
        </trans-unit>
        <trans-unit id="f1f3422827e73aced4dc67f6bd9053292d8032b6" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="translated">您会认为 &lt;code&gt;g&lt;/code&gt; 的定义肯定会进行类型检查！毕竟 &lt;code&gt;f&lt;/code&gt; 具有完全相同的类型，并且 &lt;code&gt;g=f&lt;/code&gt; 。但是实际上 &lt;code&gt;f&lt;/code&gt; 的类型是实例化的，并且针对 &lt;code&gt;g&lt;/code&gt; 的签名所约束的约束可以解决实例化的约束。因此，在类型不明确的情况下，求解将失败。例如，考虑先前的定义 &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bacaebd47954a76b1781e22db7949543ec0e3fb" translate="yes" xml:space="preserve">
          <source>You would think that the definition of &lt;code&gt;g&lt;/code&gt; would surely typecheck! After all &lt;code&gt;f&lt;/code&gt; has exactly the same type, and &lt;code&gt;g=f&lt;/code&gt;. But in fact &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type is instantiated and the instantiated constraints are solved against the constraints bound by &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s signature. So, in the case an ambiguous type, solving will fail. For example, consider the earlier definition &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt;:</source>
          <target state="translated">您会认为 &lt;code&gt;g&lt;/code&gt; 的定义肯定会进行类型检查！毕竟 &lt;code&gt;f&lt;/code&gt; 具有完全相同的类型，并且 &lt;code&gt;g=f&lt;/code&gt; 。但是实际上 &lt;code&gt;f&lt;/code&gt; 的类型是实例化的，并且实例化的约束是针对 &lt;code&gt;g&lt;/code&gt; 的签名所约束的约束进行求解的。因此，在类型不明确的情况下，求解将失败。例如，考虑先前的定义 &lt;code&gt;f :: C a =&amp;gt; Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a82f52f22d9821ac7862aa36528ae6d83fd3c82d" translate="yes" xml:space="preserve">
          <source>Your GHC must have been built with &lt;code&gt;libdw&lt;/code&gt; support for this to work.</source>
          <target state="translated">您的GHC必须已使用 &lt;code&gt;libdw&lt;/code&gt; 支持构建，才能正常工作。</target>
        </trans-unit>
        <trans-unit id="9519d527689c73f17e39c0b9add443cee365e48f" translate="yes" xml:space="preserve">
          <source>Your code should just work as before when &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; is enabled, provided you use conventional &lt;code&gt;Applicative&lt;/code&gt; instances. However, if you define a &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation, then it will likely get turned into an infinite loop by GHC. For example, if you do this:</source>
          <target state="translated">如果您使用常规的 &lt;code&gt;Applicative&lt;/code&gt; 实例，则您的代码应与启用&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;时一样工作。但是，如果您使用do-notation 定义 &lt;code&gt;Functor&lt;/code&gt; 或 &lt;code&gt;Applicative&lt;/code&gt; 实例，则GHC可能会将其变成无限循环。例如，如果您这样做：</target>
        </trans-unit>
        <trans-unit id="a1183986a9ffb1b2af584571ceb4a326e3d27e31" translate="yes" xml:space="preserve">
          <source>Z NOTATION LEFT IMAGE BRACKET</source>
          <target state="translated">Z 注释 左侧图像框</target>
        </trans-unit>
        <trans-unit id="0c83924bcb1f702fbc698e5e6e9f9116245051fc" translate="yes" xml:space="preserve">
          <source>Z NOTATION RIGHT IMAGE BRACKET</source>
          <target state="translated">Z记号右图篮子。</target>
        </trans-unit>
        <trans-unit id="9ee13b9d7e56ee129a6f6f181a2acc60f3e30fdb" translate="yes" xml:space="preserve">
          <source>Zero and plus:</source>
          <target state="translated">零和加。</target>
        </trans-unit>
        <trans-unit id="e033898555382f2650b269ecbde512101722e511" translate="yes" xml:space="preserve">
          <source>Zero is represented by an empty error and the plus operation executes its second argument if the first fails.</source>
          <target state="translated">零用空错误表示,如果第一个参数失败,则加号操作会执行其第二个参数。</target>
        </trans-unit>
        <trans-unit id="89ce708b7ebe149f5f5bb556542ed3a714814ce1" translate="yes" xml:space="preserve">
          <source>Zero or more.</source>
          <target state="translated">零或更多。</target>
        </trans-unit>
        <trans-unit id="4f2b9ff1bc4646cc78797dbbfc4b21df6589cf65" translate="yes" xml:space="preserve">
          <source>ZeroPad</source>
          <target state="translated">ZeroPad</target>
        </trans-unit>
        <trans-unit id="2700bd76f0516df842fd9e4abb85f8429575d4af" translate="yes" xml:space="preserve">
          <source>ZigZagMode</source>
          <target state="translated">ZigZagMode</target>
        </trans-unit>
        <trans-unit id="e3c3091702d0663b55dd13e13b164ff519e2737a" translate="yes" xml:space="preserve">
          <source>ZipList</source>
          <target state="translated">ZipList</target>
        </trans-unit>
        <trans-unit id="281d4deef155f3f504d99a312a022a397d572373" translate="yes" xml:space="preserve">
          <source>Zipping</source>
          <target state="translated">Zipping</target>
        </trans-unit>
        <trans-unit id="933679db226a72e96000d73f1c7a880b6ddef5ad" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping</source>
          <target state="translated">压缩和解压缩</target>
        </trans-unit>
        <trans-unit id="005dee8618c3540289989daf3c2e77debf4a260b" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping ByteStrings</source>
          <target state="translated">压缩和解压缩ByteStrings。</target>
        </trans-unit>
        <trans-unit id="30dc05c3a24d302f5746bde459be8a25f4a06e2d" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping lists</source>
          <target state="translated">压缩和解压缩列表</target>
        </trans-unit>
        <trans-unit id="07d080af9fb55da8f84a8c1fcaee4852c64bdb52" translate="yes" xml:space="preserve">
          <source>Zipping and unzipping streams</source>
          <target state="translated">压缩和解压缩流</target>
        </trans-unit>
        <trans-unit id="aa0ede24e19b5ea08adf33939b19f9036f4d61de" translate="yes" xml:space="preserve">
          <source>Zips and unzip</source>
          <target state="translated">拉链和解压</target>
        </trans-unit>
        <trans-unit id="826ebf2b3d9d03b6187eb018e001d37252118a80" translate="yes" xml:space="preserve">
          <source>Zl: Separator, Line</source>
          <target state="translated">Zl:分离器,线</target>
        </trans-unit>
        <trans-unit id="0f9a135b374272cc3038eb482b2ccf2620a381ea" translate="yes" xml:space="preserve">
          <source>ZonedTime</source>
          <target state="translated">ZonedTime</target>
        </trans-unit>
        <trans-unit id="53df64e0f183ed18f2af00a3cd4b1e5f59e3ad75" translate="yes" xml:space="preserve">
          <source>Zp: Separator, Paragraph</source>
          <target state="translated">Zp:分隔符,段落</target>
        </trans-unit>
        <trans-unit id="b8543845a37a3bc5a76a7d50c4861b4a9b6ca581" translate="yes" xml:space="preserve">
          <source>Zs: Separator, Space</source>
          <target state="translated">Zs:分离器,空间</target>
        </trans-unit>
        <trans-unit id="aa9593b61dbfb1017fac300f13e25e0141bedc4f" translate="yes" xml:space="preserve">
          <source>[ The actual default definitions employ coercions to optimise out &lt;code&gt;&lt;a href=&quot;data-monoid#v:getSum&quot;&gt;getSum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:getProduct&quot;&gt;getProduct&lt;/a&gt;&lt;/code&gt;. ]</source>
          <target state="translated">[实际的默认定义使用强制来优化 &lt;code&gt;&lt;a href=&quot;data-monoid#v:getSum&quot;&gt;getSum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-monoid#v:getProduct&quot;&gt;getProduct&lt;/a&gt;&lt;/code&gt; 。]</target>
        </trans-unit>
        <trans-unit id="ed9b7c0478a525885fdc0372f59486ef9c26b349" translate="yes" xml:space="preserve">
          <source>[ This is an experimental feature enabled by the new &lt;code&gt;-fexternal-interpreter&lt;/code&gt; flag that was introduced in GHC 8.0.1. It is currently not supported on Windows.]</source>
          <target state="translated">[这是GHC 8.0.1中引入的新 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 标志启用的实验功能。Windows当前不支持它。]</target>
        </trans-unit>
        <trans-unit id="b46e3a168f06b4470b490118d55d7d684c597c5e" translate="yes" xml:space="preserve">
          <source>[1]  &quot;When You Should Use Lists in Haskell (Mostly, You Should Not)&quot;, by Johannes Waldmann, in arxiv.org, Programming Languages (cs.PL), at &lt;a href=&quot;https://arxiv.org/abs/1808.08329&quot;&gt;https://arxiv.org/abs/1808.08329&lt;/a&gt;.</source>
          <target state="translated">[1] Johannes Waldmann在arxiv.org中的&amp;ldquo;何时应该在Haskell中使用列表（大多数情况下，您不应该）&amp;rdquo;，编程语言（cs.PL），在&lt;a href=&quot;https://arxiv.org/abs/1808.08329&quot;&gt;https://arxiv.org/abs/1808.08329&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a82fefb5adab12e07a72eba03b70468034e9d703" translate="yes" xml:space="preserve">
          <source>[1] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="translated">[1] Jeremy Gibbons和Bruno Oliveira撰写的&amp;ldquo;迭代器模式的本质&amp;rdquo;，在《&lt;em&gt;数学结构函数式编程》&lt;/em&gt;，2006年，在线，&lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;网址&lt;/a&gt;为http://www.cs.ox.ac.uk/people/jeremy.gibbons/出版物/＃iterator。</target>
        </trans-unit>
        <trans-unit id="c999771beade54662d4e2bdc8fc42d7c91f4c1a5" translate="yes" xml:space="preserve">
          <source>[2] &quot;The Essence of the Iterator Pattern&quot;, by Jeremy Gibbons and Bruno Oliveira, in &lt;em&gt;Mathematically-Structured Functional Programming&lt;/em&gt;, 2006, online at &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&lt;/a&gt;.</source>
          <target state="translated">[2] Jeremy Gibbons和Bruno Oliveira撰写的&amp;ldquo;迭代器模式的本质&amp;rdquo;，在&lt;em&gt;数学结构化函数编程中&lt;/em&gt;，2006，在线&lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator&quot;&gt;http://www.cs.ox.ac.uk/people/jeremy.gibbons/出版物/＃iterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="694e63c79a81e63a6094fc98085f24b5441b445d" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="translated">[&lt;a href=&quot;language-haskell-th#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</target>
        </trans-unit>
        <trans-unit id="b61777ed6df2c833c2e7f429e9f96972b755bfa6" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;language-haskell-th-syntax#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</source>
          <target state="translated">[&lt;a href=&quot;language-haskell-th-syntax#t:TyVarBndr&quot;&gt;TyVarBndr&lt;/a&gt; ()]</target>
        </trans-unit>
        <trans-unit id="8d3d9a8e3d2cb9184eb7776e15ffceb7ac844db5" translate="yes" xml:space="preserve">
          <source>[AssocDataTypes2005]</source>
          <target state="translated">[AssocDataTypes2005]</target>
        </trans-unit>
        <trans-unit id="3149026df86df09307a54a32b5ebc7072dbf3911" translate="yes" xml:space="preserve">
          <source>[AssocTypeSyn2005]</source>
          <target state="translated">[AssocTypeSyn2005]</target>
        </trans-unit>
        <trans-unit id="27ff8c3223896183bde17540d1a603485152df8f" translate="yes" xml:space="preserve">
          <source>[Example: &lt;code&gt;-n4m&lt;/code&gt; ] When set to a non-zero value, this option divides the allocation area (&lt;code&gt;-A&lt;/code&gt; value) into chunks of the specified size. During execution, when a processor exhausts its current chunk, it is given another chunk from the pool until the pool is exhausted, at which point a collection is triggered.</source>
          <target state="translated">[示例： &lt;code&gt;-n4m&lt;/code&gt; ]当设置为非零值时，此选项将分配区域（ &lt;code&gt;-A&lt;/code&gt; 值）划分为指定大小的块。在执行期间，当处理器耗尽其当前块时，会从池中为其分配另一个块，直到该池耗尽为止，然后触发集合。</target>
        </trans-unit>
        <trans-unit id="fd9c35275c0e496e473d959fc136a682ad3086d9" translate="yes" xml:space="preserve">
          <source>[Generics2010]</source>
          <target state="translated">[Generics2010]</target>
        </trans-unit>
        <trans-unit id="2163465089d2b153e0b8b61b46434eae8e1fe466" translate="yes" xml:space="preserve">
          <source>[Jones1999]</source>
          <target state="translated">[Jones1999]</target>
        </trans-unit>
        <trans-unit id="0c12f0c3c0a3e1aa6318a2e1ca646ed6212245b2" translate="yes" xml:space="preserve">
          <source>[Jones2000]</source>
          <target state="translated">[Jones2000]</target>
        </trans-unit>
        <trans-unit id="5f40289190bf70086cf4ad6fbc3348c060199dc3" translate="yes" xml:space="preserve">
          <source>[Lewis2000]</source>
          <target state="translated">[Lewis2000]</target>
        </trans-unit>
        <trans-unit id="c15f78a0d8a349e988dcf4bdf728980c9aa85b77" translate="yes" xml:space="preserve">
          <source>[TypeFamilies2008]</source>
          <target state="translated">[TypeFamilies2008]</target>
        </trans-unit>
        <trans-unit id="b5891f87311c40fc7e2feb2ed9e6cc0bd4955f76" translate="yes" xml:space="preserve">
          <source>[Vista and later only] The RTS calls the Win32 function &lt;code&gt;CancelSynchronousIo&lt;/code&gt;, which will cause a blocking I/O operation to return with the error &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">[仅适用于Vista和更高版本] RTS调用Win32函数 &lt;code&gt;CancelSynchronousIo&lt;/code&gt; ，这将导致阻塞的I / O操作返回，错误为 &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e646f03d1dbd0ea6ebb7f3338bf711149839b070" translate="yes" xml:space="preserve">
          <source>[this is the default setting] Enable only the &amp;ldquo;safe&amp;rdquo; RTS options: (Currently only &lt;code&gt;-?&lt;/code&gt; and &lt;code&gt;--info&lt;/code&gt;.) Any other RTS options on the command line or in the &lt;code&gt;GHCRTS&lt;/code&gt; environment variable causes the program with to abort with an error message.</source>
          <target state="translated">[这是默认设置]仅启用&amp;ldquo;安全&amp;rdquo; RTS选项：（当前仅 &lt;code&gt;-?&lt;/code&gt; 和 &lt;code&gt;--info&lt;/code&gt; 。）命令行或 &lt;code&gt;GHCRTS&lt;/code&gt; 环境变量中的任何其他RTS选项都会导致程序因错误而中止信息。</target>
        </trans-unit>
        <trans-unit id="34cbcaa3ebb2e1b02bbd040476f4a4192d9188e6" translate="yes" xml:space="preserve">
          <source>\( O(1) \). A singleton sequence.</source>
          <target state="translated">\（O（1）\）。单例序列。</target>
        </trans-unit>
        <trans-unit id="3b0d6be93c20b18b6a203f57ca8cdd843632dbbc" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the left end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\（O（1）\）。在序列的左端添加一个元素。助记符：尖端位于单个元素的三角形。</target>
        </trans-unit>
        <trans-unit id="e29f0dd89cf4b98d9f9940c595b922a5dd21f994" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Add an element to the right end of a sequence. Mnemonic: a triangle with the single element at the pointy end.</source>
          <target state="translated">\（O（1）\）。在序列的右端添加一个元素。助记符：尖端位于单个元素的三角形。</target>
        </trans-unit>
        <trans-unit id="e2f5fbbdc003ed6b6112958c18acd9b5bad4a569" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the left end of a sequence.</source>
          <target state="translated">\（O（1）\）。分析序列的左端。</target>
        </trans-unit>
        <trans-unit id="f32019dd1c2a2c3b992da628e1dbb8fca3a9a405" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Analyse the right end of a sequence.</source>
          <target state="translated">\（O（1）\）。分析序列的右端。</target>
        </trans-unit>
        <trans-unit id="7b89d619c376ded4ba8029ab80cbbe273480461c" translate="yes" xml:space="preserve">
          <source>\( O(1) \). Is this the empty sequence?</source>
          <target state="translated">\（O（1）\）。这是空序列吗？</target>
        </trans-unit>
        <trans-unit id="4043cdf48e14bbc7bef8e182dfe108b0e21704e2" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The empty sequence.</source>
          <target state="translated">\（O（1）\）。空序列。</target>
        </trans-unit>
        <trans-unit id="789a94c6e45150494a843083839c99ddbbcbcb8b" translate="yes" xml:space="preserve">
          <source>\( O(1) \). The number of elements in the sequence.</source>
          <target state="translated">\（O（1）\）。序列中的元素数。</target>
        </trans-unit>
        <trans-unit id="9c9b70cf9a1b94d641385e597a06a4220c6c9d1d" translate="yes" xml:space="preserve">
          <source>\( O(\log n) \). &lt;code&gt;replicate n x&lt;/code&gt; is a sequence consisting of &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log n）\）。 &lt;code&gt;replicate n x&lt;/code&gt; 是由 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 个副本组成的序列。</target>
        </trans-unit>
        <trans-unit id="546ea35cf6dc085674954ee6937f092065e639a0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;xs&lt;/code&gt; at the index &lt;code&gt;i&lt;/code&gt;, shifting the rest of the sequence over.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt; i x xs&lt;/code&gt; 在索引 &lt;code&gt;i&lt;/code&gt; 处将 &lt;code&gt;x&lt;/code&gt; 插入 &lt;code&gt;xs&lt;/code&gt; ，将序列的其余部分移到上方。</target>
        </trans-unit>
        <trans-unit id="0fe577d234433675e32729fdf0c2bc4f8e4d33da" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). A flipped, infix version of &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。翻转的infix版本的 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f1d705d397309f0a39429659216e4009c9399c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Delete the element of a sequence at a given index. Return the original sequence if the index is out of range.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。删除给定索引处序列的元素。如果索引超出范围，则返回原始序列。</target>
        </trans-unit>
        <trans-unit id="5bf003bead51d54a782a3e3daf5bde07395d33e1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Elements of a sequence after the first &lt;code&gt;i&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; yields the whole sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the empty sequence is returned.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。第一个 &lt;code&gt;i&lt;/code&gt; 之后的序列的元素。如果 &lt;code&gt;i&lt;/code&gt; 是负的， &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s&lt;/code&gt; 收益率整个序列。如果序列包含的元素少于 &lt;code&gt;i&lt;/code&gt; 个，则返回空序列。</target>
        </trans-unit>
        <trans-unit id="ca211904aa96b1bd11aefb66842881538beef91d" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Replace the element at the specified position. If the position is out of range, the original sequence is returned.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。在指定位置替换元素。如果位置超出范围，则返回原始序列。</target>
        </trans-unit>
        <trans-unit id="d2ebe26c5fed5338d546b09c50f90bdfc79c5c59" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Split a sequence at a given position. &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。在给定位置分割序列。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt; i s = (&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s, &lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt; i s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9982ecf4ad26d9bf2a275e1e35fdb06d9eb20b1" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。指定位置的元素，从0开始计数。如果指定位置为负或至少为序列长度，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4d4d2f3cb4b284e3cbd0d7773d4efed269d4097" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。指定位置的元素，从0开始计数。如果指定位置为负或至少为序列长度，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="977efb39460c8fb1285fbb4a0ae2081214a7c664" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. If the specified position is negative or at least the length of the sequence, &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。指定位置的元素，从0开始计数。如果指定位置为负或至少为序列长度，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="532d131357cc364ae609f962dfa852c5ecc94891" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The element at the specified position, counting from 0. The argument should thus be a non-negative integer less than the size of the sequence. If the position is out of range, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; fails with an error.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。指定位置的元素，从0开始计数。因此，参数应为小于序列大小的非负整数。如果位置超出范围， &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="31957683248c73c401120fd6ad1cf601736552c0" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). The first &lt;code&gt;i&lt;/code&gt; elements of a sequence. If &lt;code&gt;i&lt;/code&gt; is negative, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; yields the empty sequence. If the sequence contains fewer than &lt;code&gt;i&lt;/code&gt; elements, the whole sequence is returned.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。序列的前 &lt;code&gt;i&lt;/code&gt; 个元素。如果 &lt;code&gt;i&lt;/code&gt; 为负，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt; i s&lt;/code&gt; 空序列。如果序列包含的元素少于 &lt;code&gt;i&lt;/code&gt; 个，则返回整个序列。</target>
        </trans-unit>
        <trans-unit id="3751741ea558f6d0bac38a7743eebeac69c91050" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; can lead to poor performance and even memory leaks, because it does not force the new value before installing it in the sequence. &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; should usually be preferred.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。在指定位置更新元素。如果位置超出范围，则返回原始序列。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust&quot;&gt;adjust&lt;/a&gt;&lt;/code&gt; 可能会导致性能下降，甚至导致内存泄漏，因为在按顺序安装新值之前，它不会强制执行该值。通常应优先选择 &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="899c0369d8a46c9994ff0ff3c2c10f46f7406360" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(i,n-i))) \). Update the element at the specified position. If the position is out of range, the original sequence is returned. The new value is forced before it is installed in the sequence.</source>
          <target state="translated">\（O（\ log（\ min（i，ni）））\）。在指定位置更新元素。如果位置超出范围，则返回原始序列。在按顺序安装新值之前，将强制使用该值。</target>
        </trans-unit>
        <trans-unit id="040c9f3a0d532171b25aefd9fcca6a4a01b60888" translate="yes" xml:space="preserve">
          <source>\( O(\log(\min(n_1,n_2))) \). Concatenate two sequences.</source>
          <target state="translated">\（O（\ log（\ min（n_1，n_2）））\）。连接两个序列。</target>
        </trans-unit>
        <trans-unit id="06b9733d915a81dc3c5e947c773106d127b1fbcf" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two sequences and returns a sequence of corresponding pairs. If one input is short, excess elements are discarded from the right end of the longer sequence.</source>
          <target state="translated">\（O（\ min（n_1，n_2））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接受两个序列，并返回一个对应对的序列。如果一个输入短，则从较长序列的右端丢弃多余的元素。</target>
        </trans-unit>
        <trans-unit id="b0d0c309376140b35e15a12bd8a45bdb90c7b61c" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalizes &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;zipWith (+)&lt;/code&gt; is applied to two sequences to take the sequence of corresponding sums.</source>
          <target state="translated">\（O（\ min（n_1，n_2））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数而不是tupling函数对 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 进行泛化。例如，将 &lt;code&gt;zipWith (+)&lt;/code&gt; 应用于两个序列以获取相应总和的序列。</target>
        </trans-unit>
        <trans-unit id="dbdb161425b4bae8703cd60a4996961e056d4753" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; takes three sequences and returns a sequence of triples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ min（n_1，n_2，n_3））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip3&quot;&gt;zip3&lt;/a&gt;&lt;/code&gt; 接受三个序列，并返回一个类似于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 的三元组序列。</target>
        </trans-unit>
        <trans-unit id="eb3b48ecc1f93c5a7b9927fe5999f5b74e5ec5b7" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; takes a function which combines three elements, as well as three sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ min（n_1，n_2，n_3））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 包含一个将三个元素以及三个序列组合在一起的函数，并返回它们逐点组合的序列，类似于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa10a5a78855dcba7d813e3ee6a207f58661c276" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; takes four sequences and returns a sequence of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ min（n_1，n_2，n_3，n_4））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 接受四个序列，并返回一个类似于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 的四倍序列。</target>
        </trans-unit>
        <trans-unit id="4390799dddf20a6343ea9646879bb16e7f084e8e" translate="yes" xml:space="preserve">
          <source>\( O(\min(n_1,n_2,n_3,n_4)) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; takes a function which combines four elements, as well as four sequences and returns a sequence of their point-wise combinations, analogous to &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（\ min（n_1，n_2，n_3，n_4））\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 包含一个将四个元素以及四个序列组合在一起的函数，并返回它们逐点组合的序列，类似于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="854a5f214f7aa4910183ce26158e2621a9a01034" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the breakpoint index. &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that &lt;em&gt;do not satisfy&lt;/em&gt;&lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\（O（i）\）其中\（i \）是断点索引。应用于谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-sequence#v:breakl&quot;&gt;breakl&lt;/a&gt;&lt;/code&gt; 返回一个对，该对的第一个元素是&lt;em&gt;不满足&lt;/em&gt; &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;xs&lt;/code&gt; 的最长前缀（可能为空），第二个元素是序列的其余部分。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb6c136646637ba26b9e4d03ff183d0f2f7f4e9e" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; returns the suffix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\（O（i）\）其中\（i \）是前缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileL&quot;&gt;dropWhileL&lt;/a&gt; p xs&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt; p xs&lt;/code&gt; 之后剩余的后缀。</target>
        </trans-unit>
        <trans-unit id="cbf309903f09bc7649ddc265c0f3450f702cefc0" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose first element is the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\（O（i）\）其中\（i \）是前缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanl&quot;&gt;spanl&lt;/a&gt;&lt;/code&gt; 应用于谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; ，返回一对其第一个元素是满足 &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;xs&lt;/code&gt; 的最长前缀（可能为空），而第二个元素是该序列的其余部分。</target>
        </trans-unit>
        <trans-unit id="8a5eca9907659b3a43380501559c0f8bf072c551" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the prefix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest prefix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\（O（i）\）其中\（i \）是前缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileL&quot;&gt;takeWhileL&lt;/a&gt;&lt;/code&gt; 应用于谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; ，返回满足 &lt;code&gt;p&lt;/code&gt; 的元素 &lt;code&gt;xs&lt;/code&gt; 的最长前缀（可能为空）。</target>
        </trans-unit>
        <trans-unit id="2527991eb02d123ae97e3053f7be92eb76670670" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; returns the prefix remaining after &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt;.</source>
          <target state="translated">\（O（i）\）其中\（i \）是后缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:dropWhileR&quot;&gt;dropWhileR&lt;/a&gt; p xs&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt; p xs&lt;/code&gt; 之后剩余的前缀。</target>
        </trans-unit>
        <trans-unit id="ca86e7d1bc6e9440039fd89da4b54ce4dc1b17ba" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns a pair whose &lt;em&gt;first&lt;/em&gt; element is the longest &lt;em&gt;suffix&lt;/em&gt; (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt; and the second element is the remainder of the sequence.</source>
          <target state="translated">\（O（i）\）其中\（i \）是后缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:spanr&quot;&gt;spanr&lt;/a&gt;&lt;/code&gt; 应用于谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; ，返回一对其&lt;em&gt;第一个&lt;/em&gt;元素是满足 &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;xs&lt;/code&gt; 的最长&lt;em&gt;后缀&lt;/em&gt;（可能为空），而第二个元素是序列的其余部分。</target>
        </trans-unit>
        <trans-unit id="bcfc88e467626c77e9e30a0a96b1b1973c08c4cc" translate="yes" xml:space="preserve">
          <source>\( O(i) \) where \( i \) is the suffix length. &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt;, applied to a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt;, returns the longest suffix (possibly empty) of &lt;code&gt;xs&lt;/code&gt; of elements that satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">\（O（i）\）其中\（i \）是后缀长度。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:takeWhileR&quot;&gt;takeWhileR&lt;/a&gt;&lt;/code&gt; 应用于谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; ，返回满足 &lt;code&gt;p&lt;/code&gt; 的元素的 &lt;code&gt;xs&lt;/code&gt; 的最长后缀（可能为空）。</target>
        </trans-unit>
        <trans-unit id="89864ca7ad3a975e47d1ac468095d918264767d7" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ log d）\）。该 &lt;code&gt;nubOrd&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; ,它比标准的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="77dbb7bcdeacb5504a0ef6cf2f5ee72db2c1bd02" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ log d）\）。该 &lt;code&gt;nubOrd&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; ,它比标准的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="bd7af8c8ab480cb010c335014cc56785e2da88b4" translate="yes" xml:space="preserve">
          <source>\( O(n \log d) \). The &lt;code&gt;nubOrd&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. By using a &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; internally it has better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ log d）\）。该 &lt;code&gt;nubOrd&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; ,它比标准的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="5fe404a925ef3c49842338c60efd96b745d6f3be" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 按其元素的自然顺序对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。排序是稳定的。如果不需要稳定性，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 可能会稍快一些。</target>
        </trans-unit>
        <trans-unit id="1098d943b88eab1e390e5ed0bde58e02fe11a30b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 根据指定的比较器对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。排序是稳定的。如果不需要稳定性，则 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 可能会稍快一些。</target>
        </trans-unit>
        <trans-unit id="783b6fa9efe8b0aacee689453492ec1f64175be9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="dd5b729298fbee668ec8a880b8bbf7694c81ab2d" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有的性能优势是仅对输入列表中的每个元素进行一次 &lt;code&gt;f&lt;/code&gt; 评估。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="9f12595eeba36c0d952411979b5ac60fb59e8cd3" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有的性能优势是仅对输入列表中的每个元素进行一次 &lt;code&gt;f&lt;/code&gt; 评估。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="76919fecc6589c311cc2f157b3a6e318f7753a16" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 通过其元素的自然顺序，但排序并不稳定。该算法通常更快，并且比 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="9085dac0a56339479accab8408ea49a6a539f2cb" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="7a75f512d7ba326f341d19f6a0cb353e820eb396" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="5073f42496be1bb6dc8bed64e2b8570c51821663" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="20373e1ed680ebc14f4b07924b5b470cc33402e5" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 按其元素的自然顺序对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。排序是稳定的。如果不需要稳定性，则 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 可能会稍快一些。</target>
        </trans-unit>
        <trans-unit id="0eccdd8235b36a805ffa872f4e21e6f3de43dfa9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; according to the specified comparator. The sort is stable. If stability is not required, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; can be slightly faster.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 根据指定的比较器对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。排序是稳定的。如果不需要稳定性，则 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 可能会稍快一些。</target>
        </trans-unit>
        <trans-unit id="72a13ba7d54627091e4ede4aa6ae6a602d067ef1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="7753c3a048f9c8faf7bca750396f1ef7c209569b" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有的性能优势是仅对输入列表中的每个元素进行一次 &lt;code&gt;f&lt;/code&gt; 评估。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="acd7d8c0ce3dcaffab36282e02bea41b69b9bbb6" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 通过比较应用于每个元素的键函数的结果对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 进行排序。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有的性能优势是仅对输入列表中的每个元素进行一次 &lt;code&gt;f&lt;/code&gt; 评估。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="7788d5dd9362fea81aef704f1b25c424829d973e" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by the natural ordering of its elements, but the sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 通过其元素的自然顺序，但排序并不稳定。该算法通常更快，并且比 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 使用更少的内存。</target>
        </trans-unit>
        <trans-unit id="923bbcdf6473777345bf3471e264e87c7325e7e1" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="1626966051459fb3709cd1435e0670a0dbe0a5a9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="fe625859b24c94134c8d7ccfa867fdcaa9306fe9" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; sorts the specified &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; by comparing the results of a key function applied to each element. &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt;, but has the performance advantage of only evaluating &lt;code&gt;f&lt;/code&gt; once for each element in the input list. This is called the decorate-sort-undecorate paradigm, or Schwartzian transform.</source>
          <target state="translated">\（O（n \ log n）\）。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 对指定的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 施加到每个元件通过比较键功能的结果。 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; 相当于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ，但具有仅评估性能优势 &lt;code&gt;f&lt;/code&gt; 一次输入列表中的每个元素。这称为&amp;ldquo;装饰-排序-不装饰&amp;rdquo;范式或Schwartzian变换。</target>
        </trans-unit>
        <trans-unit id="8c993d7ee2b9e07347303a1bfa6fbe29b0033e24" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（n \ log n）\）。的 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 的一般化采用一个任意比较器并对指定的序列进行排序。排序不稳定。该算法通常比 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 更快，并且使用的内存更少。</target>
        </trans-unit>
        <trans-unit id="5c91e61a22ccef5e854b0115e7bae5f82a0d4e39" translate="yes" xml:space="preserve">
          <source>\( O(n \log n) \). A generalization of &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; takes an arbitrary comparator and sorts the specified sequence. The sort is not stable. This algorithm is frequently faster and uses less memory than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（O（n \ log n）\）。的 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSort&quot;&gt;unstableSort&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; 的一般化采用一个任意比较器并对指定的序列进行排序。排序不稳定。该算法通常比 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 更快，并且使用的内存更少。</target>
        </trans-unit>
        <trans-unit id="930890d550afe6b5871128789424f2ee5f748526" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ min（d，W））\）。该 &lt;code&gt;nubInt&lt;/code&gt; 功能删除重复的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 从列表中值。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; ，它比标准的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="c1a5d9655deddf9d1b59afeca8f46744a66f38b7" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ min（d，W））\）。该 &lt;code&gt;nubInt&lt;/code&gt; 功能删除重复的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 从列表中值。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; ，与标准的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数相比，它具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="87cb6746a4d9c74a95424cc23d6dbc2098128a81" translate="yes" xml:space="preserve">
          <source>\( O(n \min(d,W)) \). The &lt;code&gt;nubInt&lt;/code&gt; function removes duplicate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values from a list. In particular, it keeps only the first occurrence of each element. By using an &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; internally, it attains better asymptotics than the standard &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">\（O（n \ min（d，W））\）。该 &lt;code&gt;nubInt&lt;/code&gt; 功能删除重复的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 从列表中值。特别是，它仅保留每个元素的第一次出现。通过在内部使用 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; ，与标准的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 函数相比，它具有更好的渐近性。</target>
        </trans-unit>
        <trans-unit id="603349967cf31a7e7a62cb16fea5e3004150cc9a" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Constructs a sequence by repeated application of a function to a seed value.</source>
          <target state="translated">\（ 上） \）。通过将函数重复应用于种子值来构造序列。</target>
        </trans-unit>
        <trans-unit id="e68f82855a00f85773c90f1119ff0dc9a7c9916f" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Convert a given sequence length and a function representing that sequence into a sequence.</source>
          <target state="translated">\（ 上） \）。将给定的序列长度和表示该序列的函数转换为序列。</target>
        </trans-unit>
        <trans-unit id="28abf92fc465e3c6920cbdd18d990aa00bd50bda" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence consisting of the elements of an &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt;. Note that the resulting sequence elements may be evaluated lazily (as on GHC), so you must force the entire structure to be sure that the original array can be garbage-collected.</source>
          <target state="translated">\（ 上） \）。创建一个由 &lt;code&gt;&lt;a href=&quot;../array-0.5.4.0/data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 的元素组成的序列。请注意，生成的序列元素可能会延迟求值（如在GHC上），因此必须强制整个结构以确保可以对原始数组进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="c7cdb9801d2d28c4375010fb1f7c0579b09caa2d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（ 上） \）。从有限的元素列表创建序列。对于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 类的所有实例，包括 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; ，都有一个相反方向的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="69a0fce5498890ae28d63d4fde0c7bd1e787e9c0" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（ 在） \）。从有限的元素列表中创建一个序列。对于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 类的所有实例（包括 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; )，都有一个相反方向的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="8cf550315a531f6071acc08c1ba13bc0c5e64675" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Create a sequence from a finite list of elements. There is a function &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; in the opposite direction for all instances of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; class, including &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（ 在） \）。从有限的元素列表中创建一个序列。对于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 类的所有实例（包括 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; )，都有一个相反方向的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="1dbfa82306b38fbfc581f7b62fe7f6936fc85d5d" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Intersperse an element between the elements of a sequence.</source>
          <target state="translated">\（ 上） \）。将元素散布在序列的元素之间。</target>
        </trans-unit>
        <trans-unit id="eb33857f95e6abd9b8e92b965742544d371251b4" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all prefixes of this sequence, shortest first. For example,</source>
          <target state="translated">\（ 上） \）。返回此序列所有前缀的序列，最短优先。例如，</target>
        </trans-unit>
        <trans-unit id="e9bb88e43721f0ad090dd3079c9ab2d4f7f5e33e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Returns a sequence of all suffixes of this sequence, longest first. For example,</source>
          <target state="translated">\（ 上） \）。返回该序列所有后缀的序列，最长的序列。例如，</target>
        </trans-unit>
        <trans-unit id="d22fb3ce0a67f04fdebb29f7e29e9664003f24cc" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns a sequence of those elements which satisfy the predicate.</source>
          <target state="translated">\（ 上） \）。所述 &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; 并返回那些满足谓词元素的序列。</target>
        </trans-unit>
        <trans-unit id="95c6f2c5a83a628e74aa5f06545408e2cd588fd6" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a sequence &lt;code&gt;xs&lt;/code&gt; and returns sequences of those elements which do and do not satisfy the predicate.</source>
          <target state="translated">\（ 上） \）。的 &lt;code&gt;&lt;a href=&quot;data-sequence#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词 &lt;code&gt;p&lt;/code&gt; 和序列 &lt;code&gt;xs&lt;/code&gt; 并返回那些和不满足谓词元素序列。</target>
        </trans-unit>
        <trans-unit id="7d2552d02625413aa29e21b7cef52458a7ad4167" translate="yes" xml:space="preserve">
          <source>\( O(n) \). The reverse of a sequence.</source>
          <target state="translated">\（ 上） \）。序列的反向。</target>
        </trans-unit>
        <trans-unit id="ef7cfa6738484ccd222c60ae3aef6fc4d639c58e" translate="yes" xml:space="preserve">
          <source>\( O(n) \). Unzip a sequence using a function to divide elements.</source>
          <target state="translated">\（ 上） \）。使用函数将元素解压缩序列。</target>
        </trans-unit>
        <trans-unit id="652ee9de3d79897676915fbdfd5346a4ef2470da" translate="yes" xml:space="preserve">
          <source>\(IY\) is strictly more specific than \(IX\). That is, \(IY\) is a substitution instance of \(IX\) but not vice versa.</source>
          <target state="translated">\（IY \）严格比\（IX \）更具体。也就是说，\（IY \）是\（IX \）的替换实例，反之亦然。</target>
        </trans-unit>
        <trans-unit id="b689d73e7c786fd5b31eb51ed9d31a3f7d6ae37b" translate="yes" xml:space="preserve">
          <source>\(O \Bigl(\bigl(\frac{n}{c}\bigr) \log c\Bigr)\). &lt;code&gt;chunksOf c xs&lt;/code&gt; splits &lt;code&gt;xs&lt;/code&gt; into chunks of size &lt;code&gt;c&amp;gt;0&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; does not divide the length of &lt;code&gt;xs&lt;/code&gt; evenly, then the last element of the result will be short.</source>
          <target state="translated">\（O \ Bigl（\ bigl（\ frac {n} {c} \ bigr）\ log c \ Bigr）\）。 &lt;code&gt;chunksOf c xs&lt;/code&gt; 将 &lt;code&gt;xs&lt;/code&gt; 拆分为大小 &lt;code&gt;c&amp;gt;0&lt;/code&gt; 的块。如果 &lt;code&gt;c&lt;/code&gt; 不能平均划分 &lt;code&gt;xs&lt;/code&gt; 的长度，那么结果的最后一个元素将很短。</target>
        </trans-unit>
        <trans-unit id="582a393b8e576e364ea06e27da19c1588e6f8fa7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail.</source>
          <target state="translated">\（\ mathcal {O}（1）\）。将列表分解成其头部和尾部。</target>
        </trans-unit>
        <trans-unit id="031813834a74b1dadaec56e6fd8ae694a9b009cf" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Decompose a list into its head and tail. If the list is empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. If the list is non-empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the head of the list and &lt;code&gt;xs&lt;/code&gt; its tail.</source>
          <target state="translated">\（\ mathcal {O}（1）\）。将列表分解成其头部和尾部。如果列表为空，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。如果列表是非空的，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是列表的头部， &lt;code&gt;xs&lt;/code&gt; 是列表的尾部。</target>
        </trans-unit>
        <trans-unit id="ad354cd8847968b00b2b70d0ab031f10259ac4d8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the elements after the head of a list, which must be non-empty.</source>
          <target state="translated">\（\ mathcal {O}（1）\）。提取列表开头之后的元素，该列表必须为非空。</target>
        </trans-unit>
        <trans-unit id="0bb01ec6468606d885dd9ee1c8060cd2be83385b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Extract the first element of a list, which must be non-empty.</source>
          <target state="translated">\（\ mathcal {O}（1）\）。提取列表的第一个元素，该元素必须为非空。</target>
        </trans-unit>
        <trans-unit id="12b99888890a9c61dd2423c0ab81f2913922b24e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(1)\). Test whether a list is empty.</source>
          <target state="translated">\（\ mathcal {O}（1）\）。测试列表是否为空。</target>
        </trans-unit>
        <trans-unit id="a3c4b8cbae0dd17a08092f0d631dbb1998ec6523" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回一个对应对的列表。</target>
        </trans-unit>
        <trans-unit id="d67a45507675d41829f2b315a401c8f71a813ba2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。</target>
        </trans-unit>
        <trans-unit id="46e54d598cbb71de41da91f7c2ee3be9de7f3103" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="2f9bc9e758cd9d84ebcae85def1963ef78822338" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回一个对应对的列表。</target>
        </trans-unit>
        <trans-unit id="ebddb5be372b47ae03039407756f373048cb2ddd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。</target>
        </trans-unit>
        <trans-unit id="70a04ba10cd7908bfb667e9ea8808bd65a186093" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="a317122ad351fffdc3f91dc27c4644052432abf1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回一个对应对的列表。</target>
        </trans-unit>
        <trans-unit id="1591ed7412a271f839bdf25abc39810689968bd2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。</target>
        </trans-unit>
        <trans-unit id="9f4ecf185edfdacf5466e47eba17bbdec5f87190" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="0c24a0e28dddfc47b013aacfbb632c946442d755" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; takes two lists and returns a list of corresponding pairs.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 接收两个列表，并返回一个对应对的列表。</target>
        </trans-unit>
        <trans-unit id="ab086509cd1f632f082e54529945572cafe588de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。</target>
        </trans-unit>
        <trans-unit id="ac827704abebb27add5429489113d21367e8bfa1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; generalises &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; by zipping with the function given as the first argument, instead of a tupling function. For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 通过使用给定的函数作为第一个参数（而不是联结函数）压缩 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 概括化zip。例如，将 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="7f307d8b1e0cbd32bcd450346ba66a44e4cb712a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的前缀。</target>
        </trans-unit>
        <trans-unit id="b43d2bc79af9c74b11d5e44b6386300c12ecd9b3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 功能减退从列表中给定的前缀。如果列表不是以给定的前缀开头，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ;否则，返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 列表的前缀。</target>
        </trans-unit>
        <trans-unit id="8e393f1d74c3927aa5f45e840a9f08cfdf3cfffc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a prefix of the second.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的前缀。</target>
        </trans-unit>
        <trans-unit id="5ca3c12a6796ceba3445b06c35f1a3f5c6f0bdf7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(\min(m,n))\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; function drops the given prefix from a list. It returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the list did not start with the prefix given, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the list after the prefix, if it does.</source>
          <target state="translated">\（\ mathcal {O}（\ min（m，n））\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:stripPrefix&quot;&gt;stripPrefix&lt;/a&gt;&lt;/code&gt; 功能减退从列表中给定的前缀。如果列表不是以给定的前缀开头，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ;否则，返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 列表的前缀。</target>
        </trans-unit>
        <trans-unit id="9021cb823ed71b0f14dc8ecbf8e7fc05cf8940a1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 删除第一次出现的 &lt;code&gt;x&lt;/code&gt; 从其列表的说法。例如，</target>
        </trans-unit>
        <trans-unit id="8adb610253a7c2ed82688fbab8e80176006f21f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；IE，</target>
        </trans-unit>
        <trans-unit id="363f4a1f18a4283de44396530ea1ae5638a488ee" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="ad67b949b37d25627cdf55c54ccc28a0b18567f8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="67fc4e9ba5783a6561249c23c87c89bbdb31dca1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表：</target>
        </trans-unit>
        <trans-unit id="76f5573e311cfeaf9565286d9c2c3ea1988551e9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="ef21d250819db26eff216f0d416504ce30f4d30b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="ee6c9ed9451170ea35359a7d1abb01920f6807cc" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。请注意，与 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 相比，累加函数上的参数顺序是相反的。另请注意</target>
        </trans-unit>
        <trans-unit id="86ed9eb12b027cf32babe2f5b1df3b8c66e3fd04" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;data-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="7a0d2e7ca10638ff9734b38f34a11aa2706ee7e8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="5028c33c05faa97f80685730c0582c0602808e0c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；IE，</target>
        </trans-unit>
        <trans-unit id="cf23c9e5c94b7f7d3b25a474b88633b73cc229b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 形式返回有限列表的长度。它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 的实例，其结果类型可以是任何类型的数字。</target>
        </trans-unit>
        <trans-unit id="74c8e824def72775699108b83220d760c359dce3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="44ebc9c133e22bbd087ec267e56895f09fc21ffd" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="0016bd28f59bebbb241b023933026728dd4c00b7" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表：</target>
        </trans-unit>
        <trans-unit id="ce62be98b53d014c12224d990af1d700ef199e55" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="26b943958809b42bfecfe0570ab9ec6e1dc3b210" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="05c1c326018743c7d31c528075aa75b47a2ea8c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。请注意，与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 相比，累加函数上的参数顺序是相反的。另请注意</target>
        </trans-unit>
        <trans-unit id="4f5e4a2474b3ec55663d6f011ffa981e2950b3c8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="ae8ec2f642139908ce10723399ba124eaef8630f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;&lt;code&gt;x&lt;/code&gt; removes the first occurrence of &lt;code&gt;x&lt;/code&gt; from its list argument. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 删除第一次出现的 &lt;code&gt;x&lt;/code&gt; 从其列表的说法。例如，</target>
        </trans-unit>
        <trans-unit id="62fced33cc5c7b33d9d71684d52fad9722dc973b" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；IE，</target>
        </trans-unit>
        <trans-unit id="fb6a174a1fd7221b3347d6f920afe8052f48daf8" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; returns the length of a finite list as an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt;, the result type of which may be any kind of number.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 形式返回有限列表的长度。它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 的实例，其结果类型可以是任何类型的数字。</target>
        </trans-unit>
        <trans-unit id="2073b0a706335a98075522476b3b9b33b077aa11" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="63e535e383ef8d15b37f8a06cec03c61d0469b34" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="210e580acacdb0184aa961211ec74d91837f67af" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表：</target>
        </trans-unit>
        <trans-unit id="52fd84173341456035d6e7513a533417a0d6d1aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="9a3f84a77af8df2ddd26982298943d6341e5377e" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="4f4d9f0623e9570eb88dd1d9b4c211b4b2a418a2" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。请注意，与 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 相比，累加函数上的参数顺序是相反的。另请注意</target>
        </trans-unit>
        <trans-unit id="125c699b4c4f75c430387e65f7edcfe006396c73" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="9ee3b77945129051b6be71096733cdf6305efae4" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt;, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 应用于谓词和列表，返回满足该谓词的那些元素的列表；IE，</target>
        </trans-unit>
        <trans-unit id="3d986caef25fcce8ec2fbfa2e3a0dc59c42f1882" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;&lt;code&gt;key assocs&lt;/code&gt; looks up a key in an association list.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; &lt;code&gt;key assocs&lt;/code&gt; 在关联列表中查找键。</target>
        </trans-unit>
        <trans-unit id="b0cae18e658efc58958ff752caf95f4308ba98c3" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;f xs&lt;/code&gt; is the list obtained by applying &lt;code&gt;f&lt;/code&gt; to each element of &lt;code&gt;xs&lt;/code&gt;, i.e.,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;f xs&lt;/code&gt; 是通过将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;xs&lt;/code&gt; 的每个元素而获得的列表，即</target>
        </trans-unit>
        <trans-unit id="169fb686f6e4e8af8e1766f55d01ce7bff250ede" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; is similar to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, but returns a list of successive reduced values from the left:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 相似，但是从左侧返回一个连续的递减值的列表：</target>
        </trans-unit>
        <trans-unit id="cb1eac2b935737890f86bee44cbce323a7636c44" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; that has no starting value argument:</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl1&quot;&gt;scanl1&lt;/a&gt;&lt;/code&gt; 是的变体 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 一个没有初始值的参数：</target>
        </trans-unit>
        <trans-unit id="57897d060a78a4637753c44270190af6d990e750" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。注意</target>
        </trans-unit>
        <trans-unit id="99b018f59eeaa79636b5769a631d82b5b1cfd829" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; is the right-to-left dual of &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Note that the order of parameters on the accumulating function are reversed compared to &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;. Also note that</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 是从右到左双 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 。请注意，与 &lt;code&gt;&lt;a href=&quot;prelude#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 相比，累加函数上的参数顺序是相反的。另请注意</target>
        </trans-unit>
        <trans-unit id="2acc454a4bbccf0272c11eb7a8ea8fe3b08cbb6f" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; that has no starting value argument.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr1&quot;&gt;scanr1&lt;/a&gt;&lt;/code&gt; 是一个变种 &lt;code&gt;&lt;a href=&quot;prelude#v:scanr&quot;&gt;scanr&lt;/a&gt;&lt;/code&gt; 已经没有初始值的论点。</target>
        </trans-unit>
        <trans-unit id="5b4f342a6627b5c5e3e98b06ab0d9bb701b238aa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 的严格版本。</target>
        </trans-unit>
        <trans-unit id="1a9d169c8174c14ebced68d4109e796cf850ccf6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 的严格版本。</target>
        </trans-unit>
        <trans-unit id="4564c9defe3967981e219d81f0960c41a9d299c1" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 的严格版本。</target>
        </trans-unit>
        <trans-unit id="93d8c52726c50668f1a0c6fc1fc17ef37152c05a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\（\ mathcal {O}（n）\）。严格累积的 &lt;code&gt;&lt;a href=&quot;data-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="7e4c73b94535ef776519822b6d1a94333ed597de" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\（\ mathcal {O}（n）\）。严格累积的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="d38f78dbd3a76f77afefcc5ac584b11d4b2b52ad" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). A strictly accumulating version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">\（\ mathcal {O}（n）\）。严格累积的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:scanl&quot;&gt;scanl&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="88254de4abf9ef851c7036af3d32cd744fb783fe" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Extract the last element of a list, which must be finite and non-empty.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。提取列表的最后一个元素，该元素必须是有限且非空的。</target>
        </trans-unit>
        <trans-unit id="0d17220655fadec151f041d329764528e84ba57c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). Return all the elements of a list except the last one. The list must be non-empty.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。返回列表中除最后一个元素之外的所有元素。该列表必须为非空。</target>
        </trans-unit>
        <trans-unit id="6453dae020a15d9ae6ff6028cbacc37e5d836953" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-list#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但需要用户提供平等谓语。</target>
        </trans-unit>
        <trans-unit id="a6555cf65a2feeb7c26015cc9026f888f6cd0644" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。特别是，它不返回 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 而是返回任何作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例的类型。但是，它的效率比 &lt;code&gt;&lt;a href=&quot;ghc-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 差。</target>
        </trans-unit>
        <trans-unit id="917fcf0e2a1ba80687d4acabf5ac686a2bcfe6f5" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。所述 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表，并插入该元件到列表中在所述第一位置，在其小于或等于所述下一个元素。特别是，如果列表在调用之前排序，则结果也将排序。这是 &lt;code&gt;&lt;a href=&quot;data-list#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="851047afd0fd3689ecaf18a31831e92a21a0f13c" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表和`点缀的列表的元素之间的元件。例如，</target>
        </trans-unit>
        <trans-unit id="74a281bf3f4c0834f6462b7a209190891fab7531" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。在 &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有最终段，最长的第一。例如，</target>
        </trans-unit>
        <trans-unit id="f5c53e4d9aadaf482e021157b28390aed21001b6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but takes a user-supplied equality predicate.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但需要用户提供平等谓语。</target>
        </trans-unit>
        <trans-unit id="253d3601e9ddce99694b8e80d2efd924994b0ebb" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;. In particular, instead of returning an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, it returns any type which is an instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. It is, however, less efficient than &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericLength&quot;&gt;genericLength&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。特别是，它不返回 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 而是返回任何作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例的类型。但是，它的效率比 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 差。</target>
        </trans-unit>
        <trans-unit id="3d0327046849d2c8bb0ea7e3a381fcc45f6e8524" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; function takes an element and a list and inserts the element into the list at the first position where it is less than or equal to the next element. In particular, if the list is sorted before the call, the result will also be sorted. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表，并插入该元件到列表中在所述第一位置，在其小于或等于所述下一个元素。特别是，如果列表在调用之前排序，则结果也将排序。这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insertBy&quot;&gt;insertBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="c871ded24319659125b4444ddec10e6a07b4af41" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; function takes an element and a list and `intersperses' that element between the elements of the list. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersperse&quot;&gt;intersperse&lt;/a&gt;&lt;/code&gt; 函数采用一个元件和一个列表和`点缀的列表的元素之间的元件。例如，</target>
        </trans-unit>
        <trans-unit id="09ab7824a137d7c905554cd420e9b3f5e69e2fd9" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function returns all final segments of the argument, longest first. For example,</source>
          <target state="translated">\（\ mathcal {O}（n）\）。在 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有最终段，最长的第一。例如，</target>
        </trans-unit>
        <trans-unit id="c3f4251118a59d07862ecb1c293d53b091b0483a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;data-list#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 的非重载版本。</target>
        </trans-unit>
        <trans-unit id="089b1c7aab36fe1e2dc84b70dbf2369dbbad67fa" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n)\). The non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">\（\ mathcal {O}（n）\）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 的非重载版本。</target>
        </trans-unit>
        <trans-unit id="d892a0ba8f3f07fab0bf412e6f60b4b7f33b99e6" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">\（\ mathcal {O}（n ^ 2）\）。该 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="ed48ec637b0d47680fd76b60e08867ddcbbad74a" translate="yes" xml:space="preserve">
          <source>\(\mathcal{O}(n^2)\). The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means `essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">\（\ mathcal {O}（n ^ 2）\）。该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="5e6f80a34a9798cafc6a5db96cc57ba4c4db59c2" translate="yes" xml:space="preserve">
          <source>^</source>
          <target state="translated">^</target>
        </trans-unit>
        <trans-unit id="600e600a68a149108f159e39fce17366d56fc4e6" translate="yes" xml:space="preserve">
          <source>_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">_ &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; _ =' &lt;a href=&quot;data-bool#v:False&quot;&gt;错误&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81245c14fa4af0f8aca817f3aac71e3856bb2e1a" translate="yes" xml:space="preserve">
          <source>_open_osfhandle</source>
          <target state="translated">_open_osfhandle</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="8022fc62249fb25428a03d36552b9662db865b9c" translate="yes" xml:space="preserve">
          <source>a 32-bit floating point number</source>
          <target state="translated">三十二位浮点数</target>
        </trans-unit>
        <trans-unit id="25484eb33e4ca7fa03af08f774aeade1c4ee2d63" translate="yes" xml:space="preserve">
          <source>a 64-bit floating point number</source>
          <target state="translated">64位浮点数</target>
        </trans-unit>
        <trans-unit id="495a1fe000be6a5008ec4d1eb84e2a1d5d084889" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = a</source>
          <target state="translated">一个&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:False&quot;&gt;假&lt;/a&gt; = a</target>
        </trans-unit>
        <trans-unit id="1048dece3526da535f415f1622b9e7f4b2a0f838" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;' &lt;a href=&quot;data-bool#v:True&quot;&gt;真实&lt;/a&gt; =' &lt;a href=&quot;data-bool#v:True&quot;&gt;真实&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8d742293ecc54e41ac09b51fa2b2c86cd8c0847" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;||&lt;/a&gt; a = a</source>
          <target state="translated">一个&lt;a href=&quot;data-type-bool#t:-124--124-&quot;&gt;|| &lt;/a&gt;a = a</target>
        </trans-unit>
        <trans-unit id="dfc3eece5d5fbbfb2557fdd2f1a0de5ec1613686" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt; = '&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; &amp;ldquo; &lt;a href=&quot;data-bool#v:False&quot;&gt;假&lt;/a&gt; =&amp;rdquo; &lt;a href=&quot;data-bool#v:False&quot;&gt;假&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01ba601786bc77082f70fd3b2a119e6f137598d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt; = a</source>
          <target state="translated">一个&lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; ' &lt;a href=&quot;data-bool#v:True&quot;&gt;真&lt;/a&gt; =一个</target>
        </trans-unit>
        <trans-unit id="db482d5c52f88bf9c927868acddf21f43b80bd3f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; a = a</source>
          <target state="translated">a &lt;a href=&quot;data-type-bool#t:-38--38-&quot;&gt;&amp;amp;&amp;amp;&lt;/a&gt; a = a</target>
        </trans-unit>
        <trans-unit id="46a1e8ea1de968dcf4615a18bb4b53b696036bd4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;有界&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="2784769421385712bd50e00b7541bc81e814f56a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;枚举&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="f867947542827acc0d2ea8e0082554ae2d9a293e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;ghc-read#t:Read&quot;&gt;读&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="abf8e156382601d33ab4309b568c53d2699611e4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;有界&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="0375fef85fb75ec4eaea1233da0a84c6a11f70eb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;有界&lt;/a&gt;（a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="04456549f2a5abfaa433721a9e4d30e8a18a7b88" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Bounded&quot;&gt;有界&lt;/a&gt;（a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="a89d1de959bd2ba9abd9673e63ea6a45b095b5bd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;枚举&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="5ce73f6cfcb9fe04f1a9c2ebf0e845f07785c1c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;枚举&lt;/a&gt;（a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="027733db5bec3026113257962749176c09fed167" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Enum&quot;&gt;枚举&lt;/a&gt;（a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="36b1d286e77dd08402089dc786c5d6751384d91a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;prelude#t:Read&quot;&gt;读&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="16c734ad064a036a3668c749c7ed15b1c82c32e7" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;读&lt;/a&gt;（a &lt;a href=&quot;data-type-equality#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="8e9dc88d9d6b9dc3f6810c3cb75f9b31968412fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;读&lt;/a&gt;（a &lt;a href=&quot;data-typeable#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="b047af46bc432fe3a62a3c51785c13516dfb1285" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt; (a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;:~~:&lt;/a&gt; b)</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-126--126-&quot;&gt;~~&lt;/a&gt; b =&amp;gt; &lt;a href=&quot;text-read#t:Read&quot;&gt;读&lt;/a&gt;（a &lt;a href=&quot;type-reflection#t::-126--126-:&quot;&gt;：~~：&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="66da0a7f93a9faeeee0de1ce9988147838ae30bc" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a = '&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;</source>
          <target state="translated">a &lt;a href=&quot;data-type-equality#t:-61--61-&quot;&gt;==&lt;/a&gt; a =' &lt;a href=&quot;data-bool#v:True&quot;&gt;正确&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e53f9d6aefd63368970fd8b1c03f48b2146d52ae" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-124-&quot;&gt;:|&lt;/a&gt; [a] infixr 5</source>
          <target state="translated">a &lt;a id=&quot;v::-124-&quot;&gt;：| &lt;/a&gt;[a]固定器5</target>
        </trans-unit>
        <trans-unit id="c09b5ca0ab45efbf368c8f883aaeb643f25da75f" translate="yes" xml:space="preserve">
          <source>a &lt;a id=&quot;v::-60-&quot;&gt;:&amp;lt;&lt;/a&gt; (&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a) infixr 5</source>
          <target state="translated">a &lt;a id=&quot;v::-60-&quot;&gt;：&amp;lt;&lt;/a&gt;（&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a）固定器5</target>
        </trans-unit>
        <trans-unit id="4366d8309e6c4a93d2e6f9fac58abf7190d747db" translate="yes" xml:space="preserve">
          <source>a SIMD vector type</source>
          <target state="translated">一个SIMD向量类型</target>
        </trans-unit>
        <trans-unit id="2c60a8948409326587e2d80c0533c0b2ba526f53" translate="yes" xml:space="preserve">
          <source>a buffer (whose length may be zero).</source>
          <target state="translated">缓冲区(其长度可能为零)。</target>
        </trans-unit>
        <trans-unit id="6aba5037454fcbe2497a45a925a7bf0909281177" translate="yes" xml:space="preserve">
          <source>a constant function, returning the lowest and highest values the exponent may assume</source>
          <target state="translated">一个常数函数,返回指数的最低值和最高值。</target>
        </trans-unit>
        <trans-unit id="5b9c7de41a1536a2cf821f605e86c2793f6bd4c5" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">常数函数，返回的位数 &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; 在有效数</target>
        </trans-unit>
        <trans-unit id="cde248066dbb28c999a2778ce818e55f0128d213" translate="yes" xml:space="preserve">
          <source>a constant function, returning the number of digits of &lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; in the significand</source>
          <target state="translated">常数函数，返回的位数 &lt;code&gt;&lt;a href=&quot;prelude#v:floatRadix&quot;&gt;floatRadix&lt;/a&gt;&lt;/code&gt; 在有效数</target>
        </trans-unit>
        <trans-unit id="a633e2dd8b55ec1e8c7eb858ebb8fa756f27e31c" translate="yes" xml:space="preserve">
          <source>a constant function, returning the radix of the representation (often &lt;code&gt;2&lt;/code&gt;)</source>
          <target state="translated">常量函数，返回表示形式的基数（通常为 &lt;code&gt;2&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="2d112c21b644b5118250a8a70b2538ed21ba15e3" translate="yes" xml:space="preserve">
          <source>a decoding error, if the input begins with an invalid byte sequence in this Handle's encoding.</source>
          <target state="translated">解码错误,如果输入以无效的字节序列开始,在这个句柄的编码中。</target>
        </trans-unit>
        <trans-unit id="13d51f2874011f80c0fda1c8dd64f87141fd6f14" translate="yes" xml:space="preserve">
          <source>a default value</source>
          <target state="translated">默认值</target>
        </trans-unit>
        <trans-unit id="efc6e377ad13780bc21173cedd26de2bc7744fdb" translate="yes" xml:space="preserve">
          <source>a function converting a valid digit character to an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将有效数字字符转换为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的函数</target>
        </trans-unit>
        <trans-unit id="64e5fba578c7d1891365516501058a16fc9e7609" translate="yes" xml:space="preserve">
          <source>a function that can show unsigned values</source>
          <target state="translated">一个可以显示无符号值的函数</target>
        </trans-unit>
        <trans-unit id="4ad166b7834c36795a4fe596e5997879628c7a69" translate="yes" xml:space="preserve">
          <source>a handler for errors in the inner computation</source>
          <target state="translated">对内部计算中的错误进行处理</target>
        </trans-unit>
        <trans-unit id="c3c5aa9d0619cb64fabfcd8bc2312b400a6ca3c8" translate="yes" xml:space="preserve">
          <source>a handler for exceptions in the inner computation</source>
          <target state="translated">内部计算中的异常处理程序</target>
        </trans-unit>
        <trans-unit id="e9b3db5689251b32a019d1c409373cee04ec49ff" translate="yes" xml:space="preserve">
          <source>a list of &lt;em&gt;associations&lt;/em&gt; of the form (&lt;em&gt;index&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;). Typically, this list will be expressed as a comprehension. An association &lt;code&gt;(i, x)&lt;/code&gt; defines the value of the array at index &lt;code&gt;i&lt;/code&gt; to be &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">格式（&lt;em&gt;index&lt;/em&gt;，&lt;em&gt;value&lt;/em&gt;）的&lt;em&gt;关联&lt;/em&gt;列表。通常，此列表将表示为理解。关联 &lt;code&gt;(i, x)&lt;/code&gt; 将索引 &lt;code&gt;i&lt;/code&gt; 处的数组的值定义为 &lt;code&gt;x&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1838769c938ccda3c38c195704df00e6f8f9cac3" translate="yes" xml:space="preserve">
          <source>a list of declarations at top level; the spliced expression must have type &lt;code&gt;Q [Dec]&lt;/code&gt;</source>
          <target state="translated">顶层声明清单；拼接的表达式必须具有 &lt;code&gt;Q [Dec]&lt;/code&gt; 类型[Dec]</target>
        </trans-unit>
        <trans-unit id="c84a8e03c639e4b99b736533f6ce0d75c3d436cc" translate="yes" xml:space="preserve">
          <source>a nested BCO</source>
          <target state="translated">嵌套式BCO</target>
        </trans-unit>
        <trans-unit id="dacf656c29af63ede7d5a66eb4c195cb7d68d27c" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the first map is passed to &lt;code&gt;only1&lt;/code&gt; and the output is added to the result;</source>
          <target state="translated">仅在第一个映射中存在的非空子树传递给 &lt;code&gt;only1&lt;/code&gt; ，并将输出添加到结果中；</target>
        </trans-unit>
        <trans-unit id="9431cc2ffae3083c6fd4eb94123849e01bcd09de" translate="yes" xml:space="preserve">
          <source>a nonempty subtree present only in the second map is passed to &lt;code&gt;only2&lt;/code&gt; and the output is added to the result.</source>
          <target state="translated">仅在第二个映射中存在的非空子树被传递给 &lt;code&gt;only2&lt;/code&gt; ，并将输出添加到结果中。</target>
        </trans-unit>
        <trans-unit id="b079c712d0fda010c398b8b4fc564c5d93d60fd1" translate="yes" xml:space="preserve">
          <source>a pair of &lt;em&gt;bounds&lt;/em&gt;, each of the index type of the array. These bounds are the lowest and highest indices in the array, in that order. For example, a one-origin vector of length &lt;code&gt;10&lt;/code&gt; has bounds &lt;code&gt;(1,10)&lt;/code&gt;, and a one-origin &lt;code&gt;10&lt;/code&gt; by &lt;code&gt;10&lt;/code&gt; matrix has bounds &lt;code&gt;((1,1),(10,10))&lt;/code&gt;.</source>
          <target state="translated">一对&lt;em&gt;范围&lt;/em&gt;，数组的每个索引类型。这些边界按该顺序是数组中的最低和最高索引。例如，长度为 &lt;code&gt;10&lt;/code&gt; 的一元向量具有边界 &lt;code&gt;(1,10)&lt;/code&gt; ，而长度为 &lt;code&gt;10&lt;/code&gt; 乘 &lt;code&gt;10&lt;/code&gt; 的一元向量矩阵具有边界 &lt;code&gt;((1,1),(10,10))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba8e826714a73899830f6ab608075ff579906dbb" translate="yes" xml:space="preserve">
          <source>a pattern; the spliced pattern must have type &lt;code&gt;Q Pat&lt;/code&gt;</source>
          <target state="translated">一种模式; 拼接图案必须具有 &lt;code&gt;Q Pat&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="684672734eb2f9a021c25216014476296b90b11e" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">由严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示的预先存在的数据块</target>
        </trans-unit>
        <trans-unit id="73059a8046b1c205b18c2f7d1b925674ed55a915" translate="yes" xml:space="preserve">
          <source>a pre-existing chunks of data represented by a strict &lt;code&gt;ByteString&lt;/code&gt;</source>
          <target state="translated">由严格的 &lt;code&gt;ByteString&lt;/code&gt; 表示的预先存在的数据块</target>
        </trans-unit>
        <trans-unit id="12724a459ab10a8829360de4d06541b3e47dba30" translate="yes" xml:space="preserve">
          <source>a predicate distinguishing valid digits in this base</source>
          <target state="translated">辨别有效数字的谓词。</target>
        </trans-unit>
        <trans-unit id="c68f4a2495d7173548e9a09cb2324b41dff54f59" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path</source>
          <target state="translated">的相对路径。</target>
        </trans-unit>
        <trans-unit id="8fed21137ffe5d0c7090ea916a8c3a6106462526" translate="yes" xml:space="preserve">
          <source>a relative path that is appended to the path; if empty, the base path is returned</source>
          <target state="translated">附加到路径上的相对路径;如果为空,则返回基本路径。</target>
        </trans-unit>
        <trans-unit id="02e6f3d317a5b730213d444073c4a9d995df7da7" translate="yes" xml:space="preserve">
          <source>a restricted append-only version of a state monad transformer or</source>
          <target state="translated">仅限附加版本的状态单体变换器或或</target>
        </trans-unit>
        <trans-unit id="00cd8647e896b38e11fdde37050fe414990bbb27" translate="yes" xml:space="preserve">
          <source>a simplified AST</source>
          <target state="translated">简体字</target>
        </trans-unit>
        <trans-unit id="0f5ca64142ff0bb325d5429f5831baee94016b9b" translate="yes" xml:space="preserve">
          <source>a standard &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instance may be defined as</source>
          <target state="translated">标准 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 实例可以定义为</target>
        </trans-unit>
        <trans-unit id="af4e0527aa2daaff6ce8c67a4930a298ed4dbc12" translate="yes" xml:space="preserve">
          <source>a string describing the &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, e.g. the file path for a file. Used in error messages.</source>
          <target state="translated">描述 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的字符串，例如文件的文件路径。在错误消息中使用。</target>
        </trans-unit>
        <trans-unit id="32ae1817dace426c93d098fe2524e0f3abe3aa1a" translate="yes" xml:space="preserve">
          <source>a string literal denoting a common prefix to be added to the returned completion candidates.</source>
          <target state="translated">字符串,表示要添加到返回的完成候选人中的共同前缀。</target>
        </trans-unit>
        <trans-unit id="654558a0452dc0b9f151efdec13bb4d9e7dd1b7f" translate="yes" xml:space="preserve">
          <source>a string that can be passed to &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; to create an equivalent &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个可以传递给 &lt;code&gt;&lt;a href=&quot;system-io#v:mkTextEncoding&quot;&gt;mkTextEncoding&lt;/a&gt;&lt;/code&gt; 的字符串，以创建等效的 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b85621828f70ac37a526068e8083c87be9c3be28" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//IGNORE&lt;/code&gt;, e.g. &lt;code&gt;UTF-8//IGNORE&lt;/code&gt;, will cause all illegal sequences on input to be ignored, and on output will drop all code points that have no representation in the target encoding.</source>
          <target state="translated">&lt;code&gt;//IGNORE&lt;/code&gt; 的后缀，例如 &lt;code&gt;UTF-8//IGNORE&lt;/code&gt; ，将导致输入上的所有非法序列被忽略，而输出上的所有非法序列将丢弃目标编码中没有任何表示形式的所有代码点。</target>
        </trans-unit>
        <trans-unit id="c776055d334ae6a629010d30b766a23c8aa3fde8" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//ROUNDTRIP&lt;/code&gt; will use a PEP383-style escape mechanism to represent any invalid bytes in the input as Unicode codepoints (specifically, as lone surrogates, which are normally invalid in UTF-32). Upon output, these special codepoints are detected and turned back into the corresponding original byte.</source>
          <target state="translated">&lt;code&gt;//ROUNDTRIP&lt;/code&gt; 的后缀将使用PEP383样式的转义机制将输入中的任何无效字节表示为Unicode代码点（特别是作为单独的替代，通常在UTF-32中是无效的）。在输出时，将检测这些特殊代码点并将其转回相应的原始字节。</target>
        </trans-unit>
        <trans-unit id="8e864fd0038b9dc298144ef97f622ae11f451d8b" translate="yes" xml:space="preserve">
          <source>a suffix of &lt;code&gt;//TRANSLIT&lt;/code&gt; will choose a replacement character for illegal sequences or code points.</source>
          <target state="translated">&lt;code&gt;//TRANSLIT&lt;/code&gt; 的后缀将为非法序列或代码点选择一个替换字符。</target>
        </trans-unit>
        <trans-unit id="3397cb671916c002d3ff115ddde37cc1a14cdaba" translate="yes" xml:space="preserve">
          <source>a suitable instance would be</source>
          <target state="translated">适例为</target>
        </trans-unit>
        <trans-unit id="db956082ebbae6d6af67d17e3acdaaae903feef0" translate="yes" xml:space="preserve">
          <source>a suitable instance would be:</source>
          <target state="translated">一个合适的例子是:</target>
        </trans-unit>
        <trans-unit id="d80c6eecdcbcce1a1bc8b7bef1f178ffa9e415f5" translate="yes" xml:space="preserve">
          <source>a type variable that names the result of a type family. Syntax: &lt;code&gt;= tyvar&lt;/code&gt; or &lt;code&gt;= (tyvar :: kind)&lt;/code&gt;. The type variable must be fresh.</source>
          <target state="translated">类型变量，它命名类型族的结果。语法： &lt;code&gt;= tyvar&lt;/code&gt; 或 &lt;code&gt;= (tyvar :: kind)&lt;/code&gt; 。类型变量必须是新鲜的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
