<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">关闭重新编译检查。编译单个文件时（即，使用&lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 时&lt;/a&gt;），任何 &lt;code&gt;-ddump-X&lt;/code&gt; 选项都暗含了这一点。</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">关闭&amp;ldquo;状态黑客&amp;rdquo;，将带有 &lt;code&gt;State#&lt;/code&gt; 令牌作为参数的任何lambda 都视为一次输入，因此可以将其中的内容内联。这可以提高IO和ST monad代码的性能，但是存在减少共享的风险。</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">关闭胁迫优化器</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">关闭胁迫优化器。</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">关闭状态黑客whereby任何以现实世界的状态令牌作为参数的lambda都被认为是单入。因此可以在它里面内联东西。</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">打开&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;渴望的黑洞&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">在需求分析器中开启CPR分析。</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在需求分析器中打开CPR分析。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">打开Haskell程序覆盖工具</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">打开呼叫模式专门化；请参阅&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskell程序的调用模式专用化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">开启调试打印(更详细)。</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">启用完全懒惰（向外浮动绑定）。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">在核心级别启用GHC中的重量级内部通过完整性检查。（它检查GHC的健全性，而不是您的健全性。）</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">开启内部安全检查</target>
        </trans-unit>
        <trans-unit id="dc3c205a62aa2d2da8175eab4c4b97ecb966fe59" translate="yes" xml:space="preserve">
          <source>Turn on linearity checking in GHC. Currently, some optimizations in GHC might not preserve linearity and they valid programs might fail Linear Core Lint. In the near future, this option will be removed and folded into normal Core Lint.</source>
          <target state="translated">在GHC中开启线性检查。目前,GHC中的一些优化可能不会保留线性,它们的有效程序可能会在Linear Core Lint中失败。在不久的将来,这个选项将被删除,并被合并到正常的Core Lint中。</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">开启GHCi中的装订结果打印。</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">开启剖析</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">开启从其他模块导入的重载函数的专用化。</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">开启重载函数的特殊化,无论其大小,如果可以展开的话。</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开重载函数的专用化。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="186b5bba16e6ae8eb15a9abb5dd5b71128ae5773" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt;&lt;code&gt;-fworker-wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">打开严格性分析。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。意味着&lt;a href=&quot;using-optimisation#ghc-flag--fworker-wrapper&quot;&gt; &lt;code&gt;-fworker-wrapper&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">打开严格性分析。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。意味着 &lt;code&gt;-fworker-wrapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开SpecConstr转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开浮动转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开自由案例转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">打开自由案例转换。这将在其自己的RHS中一次展开递归函数，以避免重复分析自由变量。它有点像调用模式专用程序（&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt;），但是它提供的是自由变量而不是参数。</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">打开静态参数转换，该转换将递归函数转换为具有局部递归循环的非递归函数。参见&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos博士论文的&lt;/a&gt;第7章。</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">开启静态参数转换。</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">开启ticky-ticky特征分析</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将饱和的自递归尾调用转换为生成的程序集中的局部跳转。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="817ee37f90284803efb9153022786df4682fbe53" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将类型错误转换为警告，&lt;a href=&quot;exts/defer_type_errors#defer-type-errors&quot;&gt;将错误推迟到runtime&lt;/a&gt;。隐含&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。另请参见&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将类型错误转换为警告，&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;将错误推迟到runtime&lt;/a&gt;。隐含&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。另请参见&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">打开启用特殊语法的选项&lt;em&gt;可能会&lt;/em&gt;导致有效的Haskell 98代码无法编译，可能是因为它使用的变量名已成为保留字。本节列出了语言扩展&amp;ldquo;偷走&amp;rdquo;的语法。我们使用Haskell 98词法语法的符号和非终结符名称（请参阅Haskell 98报告）。我们仅在此处列出可能会影响现有工作程序的语法更改（即&amp;ldquo;被盗&amp;rdquo;语法）。其中许多扩展都将启用新的无上下文语法，但是在所有情况下，如果未启用该选项，则使用新语法编写的程序将无法编译。</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">车削图案成无可辩驳那些需要 &lt;code&gt;~(~p)&lt;/code&gt; 或 &lt;code&gt;(~ ~p)&lt;/code&gt; 时 &lt;code&gt;Strict&lt;/code&gt; 被启用。</target>
        </trans-unit>
        <trans-unit id="c36dca2d0bb2acce2b8d943939d7c270f3396cfe" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">启用 &lt;code&gt;Strict&lt;/code&gt; 时，将模式转换为不可辩驳的模式需要 &lt;code&gt;~(~p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">通过将终结器（由monadic操作指定）与引用关联，可以将普通内存引用转换为外来对象。在删除对 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的最后一个引用之后的一段时间，存储管理器将在单独的线程中启动终结器。不能保证及时性，实际上也不能保证终结器将最终运行。</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">通过将终结器（由monadic操作指定）与引用关联，可以将普通内存引用转换为外来对象。在删除对 &lt;code&gt;ForeignPtr&lt;/code&gt; 的最后一个引用之后的一段时间，存储管理器将在单独的线程中启动终结器。不能保证及时性，实际上也不能保证终结器将最终运行。</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">将一个普通的内存引用转化为一个外来指针,并将一个终结器与该引用关联。最终处理程序将在最后一个外来对象的引用被删除后执行。虽然不能保证及时性,但是定标器会在程序退出前执行。</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">关闭所有文本属性。该功能将始终成功,但在不支持文本属性的终端中没有效果。</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">关闭所有警告，包括标准警告和&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;启用的警告。</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">打开所有指示潜在可疑代码的警告选项。&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;&lt;em&gt;未&lt;/em&gt;启用的警告是</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">在输出给定文本前开启粗体模式,然后关闭所有属性。</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">开启编译器支持的每一个警告。</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">在输出给定文本前开启突出模式,然后关闭。</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">在输出给定文本前开启下划线模式,然后关闭。</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">开启未来默认启用的警告,但在正常编译中暂时保持关闭。这使得那些急于让自己的代码与未来兼容的库作者,可以在产生警告之前就适应新特性。</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">两个命令行选项控制是否读取启动文件文件。</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">有两点要注意。</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">如果对于所有可能的替换,两个类型不能还原成一个共同的还原物,则认为这两个类型是分开的。</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">产生两种类型的消息：以 &lt;code&gt;***&lt;/code&gt; 开头的消息确实表示编译阶段的开始，而以 &lt;code&gt;!!!&lt;/code&gt; 开头的消息则表示！标记过程的结束，并伴随分配和运行时统计信息。</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">字型</target>
        </trans-unit>
        <trans-unit id="0ff156671a95e7d7958f54c3801c9a78059e1834" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">如果自变量的名称无关紧要，则可以用下划线（ &lt;code&gt;_&lt;/code&gt; ）替换类型自变量。这与使用唯一名称编写类型变量相同。启用&lt;a href=&quot;../using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;标志时，可以将未使用的类型参数替换为下划线或以下划线作为前缀，以避免发出警告。规则与&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">如果参数名称无关紧要，则类型参数可以用下划线（ &lt;code&gt;_&lt;/code&gt; ）替换。这与使用唯一名称编写类型变量相同。启用&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;标志时，可以将未使用的类型参数替换为下划线或在其下加上前缀，以避免发出警告。规则与&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">类型检查器将允许孔的推断类型。</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I/O提供者的类型类。</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">需要启用自己的扩展名的类型类，例如&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#deriving-extra&quot;&gt;派生额外类的实例（Data等）&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="926bf298afdb2d507c3bd7a1413520e17a01edb6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">需要启用自己的扩展名的类型类，例如&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#deriving-extra&quot;&gt;派生额外类的实例（Data等）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="561c814be6dae335c98b673227b1a4d073e164e6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">需要启用自己的扩展名的类型类，例如&lt;a href=&quot;deriving_extra#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;派生额外类的实例（Data等）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">类型构造函数应用于涉及所有人的类型（如果关闭了&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ccd8b1a39bf697129dfe9925ae54f15bbbb0a75a" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">类型构造函数应用于涉及所有人的类型（如果关闭了&lt;a href=&quot;impredicative_types#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">类型构造器</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">类型构造函数和类;Haskell 目前将它们放在同一个名称空间。</target>
        </trans-unit>
        <trans-unit id="f4cb9160c66acee90d4523d170727eb5eabf6f68" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. #14605).</source>
          <target state="translated">&quot;forall &quot;下的类型平等不能推迟(参考文件#14605);</target>
        </trans-unit>
        <trans-unit id="9fc11fe5ce4f23f06fca295618c3b4ba02ddb103" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;#14605&lt;/a&gt;).</source>
          <target state="translated">在&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14605&quot;&gt;Forall&lt;/a&gt;下的类型相等性不能被延迟（参见＃14605）。</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">&quot;forall &quot;下的类型平等不能推迟(参见Trac #14605)。</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">平等类型</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">类型族有三种形式。(1)它们可以被定义为toplevel上的开放族,(2)它们可以被定义为toplevel上的封闭族,或(3)它们可以出现在类型类中(在这种情况下,它们被称为关联类型同义词)。toplevel族更通用,因为它们没有类型索引与类参数一致的要求。然而,关联类型同义词可以导致更清晰的结构化代码,如果一些类型实例被--可能是意外地--省略了,编译器会发出警告。在下文中,我们总是先讨论一般的toplevel形式,然后再讨论放在关联类型上的附加约束。注意,封闭的关联类型同义词是不存在的。</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">类型族由语言扩展&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;启用。有关在GHC中使用类型族的其他信息，请参见&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;有关类型族的Haskell Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f76f6ce50fb342101781212e18ae010ee327b2c4" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">类型族由语言扩展&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;启用。有关在GHC中使用类型族的更多信息，请参见&lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;有关类型族的Haskell Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">类型族要求我们扩展实例头形式的规则，这&lt;a href=&quot;#flexible-instance-head&quot;&gt;在实例头的宽松规则&lt;/a&gt;中给出。特别：</target>
        </trans-unit>
        <trans-unit id="f4251de5d3214c46072d1ab7da575f6b1ff192df" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;instances#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">类型族要求我们扩展实例头形式的规则，这&lt;a href=&quot;instances#flexible-instance-head&quot;&gt;在实例头的宽松规则&lt;/a&gt;中给出。具体来说：</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">类型族声明没有右侧，但是GHC必须仍然为 &lt;code&gt;F&lt;/code&gt; 推断一种。由于没有约束，因此可以推断 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; ，但这似乎&lt;em&gt;太多&lt;/em&gt;态了。因此，GHC将那些完全不受约束的种类变量默认为 &lt;code&gt;Type&lt;/code&gt; ，我们得到 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; 。您仍然可以使用种类签名将 &lt;code&gt;F&lt;/code&gt; 声明为种类多态：</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">只有当适当的族声明在范围内时,类型族实例声明才是合法的--就像类实例要求类声明可见一样。此外,每个实例声明必须符合其族声明所确定的种类,实例声明中的类型参数数量必须与族声明中的类型参数数量一致。最后,类型实例的右侧必须是单型(即不得包括foralls),在扩展了所有饱和的凡型同义词后,除了族同义词外,不得留下任何同义词。</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">家庭结果类型</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">类型家族结果签名</target>
        </trans-unit>
        <trans-unit id="c9902ea99522cdd8d23085400914695929774e22" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;#10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;#10946&lt;/a&gt;)</source>
          <target state="translated">键入输入接头孔（见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;＃10945&lt;/a&gt;和&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;＃10946&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">在输入接头类型孔（见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;问题＃10945&lt;/a&gt;和&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;问题＃10946&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="276b31a5f89d022c33dce55c2768f21e907ef802" translate="yes" xml:space="preserve">
          <source>Type lookup</source>
          <target state="translated">类型查询</target>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">可用于支持 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的设备的类型（另请参见 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; ）。标准库通过Posix文件操作（带有文件描述符（请参见 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; ））来创建 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ,其中FD是基础 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">从格式字符串中解析修饰符的函数类型。</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">类型代表</target>
        </trans-unit>
        <trans-unit id="d476627bc725ea2b4474151d280a2bff44c61eb5" translate="yes" xml:space="preserve">
          <source>Type representing 128-bit Unicode subset bitfields, as the &lt;code&gt;base&lt;/code&gt; package does include a module exporting a 128-bit unsigned integer type.</source>
          <target state="translated">表示128位Unicode子集位域的类型，因为 &lt;code&gt;base&lt;/code&gt; 包确实包括一个导出128位无符号整数类型的模块。</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">表示&lt;em&gt;原始&lt;/em&gt;任意精度自然数的类型</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">代表GMP肢体的类型</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">表示任意精度非负整数的类型。</target>
        </trans-unit>
        <trans-unit id="07805eadc38f7082f8142805c647fecdc2fe145b" translate="yes" xml:space="preserve">
          <source>Type representing locale data</source>
          <target state="translated">代表区域数据的类型</target>
        </trans-unit>
        <trans-unit id="04f3c2b34d933ed0082ee4d9a77619193e0fa0ae" translate="yes" xml:space="preserve">
          <source>Type signature declarations for functions, values, and class methods</source>
          <target state="translated">函数、值和类方法的类型签名声明。</target>
        </trans-unit>
        <trans-unit id="1e453cabd9572ae7f533e9e17c78f4446cb10208" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt; constructors</source>
          <target state="translated">&lt;a href=&quot;gadt#gadt&quot;&gt;通用代数数据类型（GADT）&lt;/a&gt;构造函数的类型签名</target>
        </trans-unit>
        <trans-unit id="b796829535549c68436fd73f285f127abfd7701a" translate="yes" xml:space="preserve">
          <source>Type signatures for &lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pattern_synonyms#pattern-synonyms&quot;&gt;模式同义词的&lt;/a&gt;类型签名</target>
        </trans-unit>
        <trans-unit id="27011d116ac3ec121518ae6e931cca052bc0fc9e" translate="yes" xml:space="preserve">
          <source>Type signatures in a &lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt; or &lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZE instance pragma&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;pragmas#specialize-pragma&quot;&gt;SPECIALIZE编译指示&lt;/a&gt;或&lt;a href=&quot;pragmas#specialize-instance-pragma&quot;&gt;SPECIALIZE实例编译指示中&lt;/a&gt;键入签名</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">类型拼接:类型拼接中只支持匿名通配符。命名通配符和约束外通配符不支持。</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">类型同义词族可能不会出现在一个实例头中(根本不会)。</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">为构造体编码元信息的类型同义词。</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">为数据类型编码元信息的类型同义词。</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">为记录选择器编码元信息的同义词类型。</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">编码递归的类型同义词（ &lt;code&gt;Type&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">类型同义词</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">类型同义词就像类型级别的宏一样，但是Haskell 98在单个同义词声明上强加了许多规则。通过&lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt;扩展，GHC &lt;em&gt;仅在扩展类型同义词后才&lt;/em&gt;对类型进行有效性检查。这意味着GHC在类型同义词方面比Haskell 98更加自由。</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">类型通配符也可以通过在下划线后加上一个标识符后缀 &lt;code&gt;_a&lt;/code&gt; 来命名。这些被称为&lt;em&gt;命名通配符&lt;/em&gt;。在一个类型签名中出现的所有相同名称的通配符将统一为同一类型。例如：</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">类型检查和重命名</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">类型类和隐式参数约束</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">类型级 &quot;和&quot;</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">类型级别为&amp;ldquo; not&amp;rdquo;。从 &lt;code&gt;4.10.0.0&lt;/code&gt; 开始的单射型族。</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">类型级 &quot;或&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">类型级别&lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;。 &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">铸型安全</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">使用命题平等的类型安全转换</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">使用表征平等的类型安全投射</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
        <trans-unit id="0ff4704cf9871d172e46093c902963c62493a59a" translate="yes" xml:space="preserve">
          <source>TypeFamilyHead</source>
          <target state="translated">TypeFamilyHead</target>
        </trans-unit>
        <trans-unit id="074e8ef03d4629b59466a2657ccae4e537c30d86" translate="yes" xml:space="preserve">
          <source>TypeInType</source>
          <target state="translated">TypeInType</target>
        </trans-unit>
        <trans-unit id="3e43198a1e6eec381f4d9a60cfec193b835e2b96" translate="yes" xml:space="preserve">
          <source>TypeLitNat</source>
          <target state="translated">TypeLitNat</target>
        </trans-unit>
        <trans-unit id="ab5cc289c62cf3f22557ac72519f3c08dfbfa2dd" translate="yes" xml:space="preserve">
          <source>TypeLitSymbol</source>
          <target state="translated">TypeLitSymbol</target>
        </trans-unit>
        <trans-unit id="7f2923c4751f8935c12b50c7a13c90ec460b9a65" translate="yes" xml:space="preserve">
          <source>TypeOperators</source>
          <target state="translated">TypeOperators</target>
        </trans-unit>
        <trans-unit id="127efaa98624e5386e6a57b6846ecf29edc5596f" translate="yes" xml:space="preserve">
          <source>TypeQ</source>
          <target state="translated">TypeQ</target>
        </trans-unit>
        <trans-unit id="97dd0a1ff386b68a6a4f4b903b4e8e20ccdf5f41" translate="yes" xml:space="preserve">
          <source>TypeRep</source>
          <target state="translated">TypeRep</target>
        </trans-unit>
        <trans-unit id="4923be1ff37db9ead0d3ce6f70368f3d9cb65db0" translate="yes" xml:space="preserve">
          <source>TypeSynonymInstances</source>
          <target state="translated">TypeSynonymInstances</target>
        </trans-unit>
        <trans-unit id="2e8fb009fca3a1778df4dee9b6ede33b60b37c30" translate="yes" xml:space="preserve">
          <source>Typeable</source>
          <target state="translated">Typeable</target>
        </trans-unit>
        <trans-unit id="40fb2a246a44fdd76a25bc4dee91c9b12c42ad29" translate="yes" xml:space="preserve">
          <source>Typeclass</source>
          <target state="translated">Typeclass</target>
        </trans-unit>
        <trans-unit id="a8e6ea3785b64f099cfa5c96f73972ea0e5a388d" translate="yes" xml:space="preserve">
          <source>Typeclass of &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;-formattable values. The &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; method takes a value and a field format descriptor and either fails due to a bad descriptor or produces a &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; as the result. The default &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; expects no modifiers: this is the normal case. Minimal instance: &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; -formattable 值的类型类。该 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 方法需要一个值和字段格式描述符和任一失败，由于坏的描述符或产生 &lt;code&gt;&lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;&lt;/code&gt; 作为结果。默认的 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 不需要任何修饰符：这是正常情况。最小实例： &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26ab741c0b6c1149ecdfc5c0b36d8ccc700d5b32" translate="yes" xml:space="preserve">
          <source>Typed TH quotes on the other hand are perfectly compatible with the eager application of rebindable syntax rules, and GHC will therefore process any such quotes according to the rebindable syntax rules whenever the &lt;code&gt;RebindableSyntax&lt;/code&gt; extension is turned on in the modules where such quotes appear.</source>
          <target state="translated">另一方面，键入的TH引号与可重新绑定语法规则的急切应用完全兼容，因此，只要在出现此类引用的模块中打开 &lt;code&gt;RebindableSyntax&lt;/code&gt; 扩展名，GHC就会根据可重新绑定语法规则来处理任何此类引号。</target>
        </trans-unit>
        <trans-unit id="a9b0eb1a7576e399628fdc3f0014f73ffc225afc" translate="yes" xml:space="preserve">
          <source>Typed expression splices: the same wildcards as in (untyped) expression splices are supported.</source>
          <target state="translated">类型化表达式拼接:支持与(非类型化)表达式拼接中相同的通配符。</target>
        </trans-unit>
        <trans-unit id="c10bf0f7958e4932169a9efbd5924f628c46f331" translate="yes" xml:space="preserve">
          <source>Typed expressions</source>
          <target state="translated">类型化的表达式</target>
        </trans-unit>
        <trans-unit id="3e24cfa370c748c1f34054356703adda13ee79c0" translate="yes" xml:space="preserve">
          <source>Typed holes are a feature of GHC that allows special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;), to be used as expressions. During compilation these holes will generate an error message that describes which type is expected at the hole&amp;rsquo;s location, information about the origin of any free type variables, and a list of local bindings that might help fill the hole and bindings in scope that fit the type of the hole that might help fill the hole with actual code. Typed holes are always enabled in GHC.</source>
          <target state="translated">键入孔是GHC的一项功能，它允许使用特殊的占位符（以&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;_foo&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;_bar&lt;/code&gt; &amp;rdquo;）开头的表达式用作表达式。在编译过程中，这些孔将生成一条错误消息，描述在孔的位置应使用哪种类型，有关任何自由类型变量的起源的信息以及可以帮助填充孔的局部绑定列表以及适合该类型的范围的绑定可能有助于用实际代码填充漏洞的漏洞。GHC中始终启用打孔。</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a56497f57a4c65ed19388200c5c29fe14b9f29e1" translate="yes" xml:space="preserve">
          <source>Types and functions for UTC and UT1</source>
          <target state="translated">UTC和UT1的类型和功能</target>
        </trans-unit>
        <trans-unit id="7005254a2a8a6ae56b5da2106d2a7390dfa74f52" translate="yes" xml:space="preserve">
          <source>Types and functions for dealing with encoding and decoding errors in Unicode text.</source>
          <target state="translated">处理Unicode文本中编码和解码错误的类型和功能。</target>
        </trans-unit>
        <trans-unit id="a2c52d7c6cf4bc87e6f29125e9f05a6c3ab0de78" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs</source>
          <target state="translated">引用远程GHCi中的远程对象的类型。有关更多详细信息，请参见编译器&lt;em&gt;GHC&lt;/em&gt; Runtime / Interpreter.hs中的[外部GHCi指针]。</target>
        </trans-unit>
        <trans-unit id="b5fa0ad82cb92df6a78d9d90490a6174d9700473" translate="yes" xml:space="preserve">
          <source>Types for referring to remote objects in Remote GHCi. For more details, see Note [External GHCi pointers] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs</source>
          <target state="translated">在远程GHCi中引用远程对象的类型。有关更多详细信息，请参见编译器&lt;em&gt;ghci&lt;/em&gt; GHCi.hs中的[外部GHCi指针]</target>
        </trans-unit>
        <trans-unit id="5580e68a19fcd07f6f63b4ef4e2909db886ab488" translate="yes" xml:space="preserve">
          <source>Types for specifying how text encoding/decoding fails</source>
          <target state="translated">用于指定文本编码/解码失败的类型。</target>
        </trans-unit>
        <trans-unit id="7cbee61c2faa6400b77721042e85c6886eb1b3e4" translate="yes" xml:space="preserve">
          <source>Types of I/O error</source>
          <target state="translated">I/O错误类型</target>
        </trans-unit>
        <trans-unit id="f0320286a762dea4d157070a0b18d0bf262e2900" translate="yes" xml:space="preserve">
          <source>Types, and class constraints, can be written infix. For example</source>
          <target state="translated">类型和类的约束,都可以写成infix。例如</target>
        </trans-unit>
        <trans-unit id="244a23d239a744b67869603db5aa7a8a108d006d" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">典型应用： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.13.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2b54a022fd50a70fd5342e23351e38dc98cf9e0" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">典型应用： &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.14.1.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f47fb4e5fc6ce9d393da5169defdd4830664a47" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">典型应用： &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;../base-4.15.0.0/prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6125766e1667a0dc730d60edd60595e68e0998" translate="yes" xml:space="preserve">
          <source>Typical usage: &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">典型应用： &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f931421ae1bb4e608cfffd3d56162d588a8834" translate="yes" xml:space="preserve">
          <source>Typically GHCi will show only the number of modules that it loaded after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command. With this flag, GHC will also list the loaded modules&amp;rsquo; names. This was the default behavior prior to GHC 8.2.1 and can be useful for some tooling users.</source>
          <target state="translated">通常，GHCi将仅显示在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令之后加载的模块数量。使用此标志，GHC还将列出已加载模块的名称。这是GHC 8.2.1之前的默认行为，对某些工具用户很有用。</target>
        </trans-unit>
        <trans-unit id="fbc4cfc97456201bcbb7c532592eda4f36c7e91c" translate="yes" xml:space="preserve">
          <source>Typically this &lt;code&gt;GSerialize&lt;/code&gt; class will not be exported, as it only makes sense to have instances for the representation types.</source>
          <target state="translated">通常，将不会导出该 &lt;code&gt;GSerialize&lt;/code&gt; 类，因为只有表示形式类型的实例才有意义。</target>
        </trans-unit>
        <trans-unit id="72dcc23bd7878a3f40b67b09ecb95c71f87fb8c1" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten.</source>
          <target state="translated">单独键入 &lt;code&gt;:def&lt;/code&gt; 会列出当前定义的宏。尝试重新定义现有命令名称会导致错误，除非 &lt;code&gt;:def!&lt;/code&gt; 使用form，在这种情况下，具有该名称的旧命令将被静默覆盖。</target>
        </trans-unit>
        <trans-unit id="03049aa8714feb7c10314b4dd7463192a8695411" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">单独键入 &lt;code&gt;:def&lt;/code&gt; 会列出当前定义的宏。尝试重新定义现有命令名称会导致错误，除非 &lt;code&gt;:def!&lt;/code&gt; 使用form，在这种情况下，具有该名称的旧命令将被静默覆盖。但是，对于内置命令，仍可以通过在命令名称前加双冒号（例如 &lt;code&gt;::load&lt;/code&gt; ）来使用旧命令。这是不可能重新定义的命令 &lt;code&gt;:{&lt;/code&gt; ， &lt;code&gt;:}&lt;/code&gt; 和 &lt;code&gt;:!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e5374291987ed29812b27d3b5a192b78251690" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;:def&lt;/code&gt; on its own lists the currently-defined macros. Attempting to redefine an existing command name results in an error unless the &lt;code&gt;:def!&lt;/code&gt; form is used, in which case the old command with that name is silently overwritten. However for builtin commands the old command can still be used by preceeding the command name with a double colon (eg &lt;code&gt;::load&lt;/code&gt;). It&amp;rsquo;s not possible to redefine the commands &lt;code&gt;:{&lt;/code&gt;, &lt;code&gt;:}&lt;/code&gt; and &lt;code&gt;:!&lt;/code&gt;.</source>
          <target state="translated">单独键入 &lt;code&gt;:def&lt;/code&gt; 会列出当前定义的宏。尝试重新定义现有命令名称会导致错误，除非 &lt;code&gt;:def!&lt;/code&gt; 使用form，在这种情况下，具有该名称的旧命令将被静默覆盖。但是，对于内置命令，仍可以通过在命令名称前加上双冒号（例如 &lt;code&gt;::load&lt;/code&gt; ）来使用旧命令。这是不可能重新定义的命令 &lt;code&gt;:{&lt;/code&gt; ， &lt;code&gt;:}&lt;/code&gt; 和 &lt;code&gt;:!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a380e5db1ec24a6a91d28381a66d5665dba31c2" translate="yes" xml:space="preserve">
          <source>Typing: If ⟨exp⟩ has type ⟨T1⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩ and ⟨pat⟩ matches a ⟨T2⟩, then the whole view pattern matches a ⟨T1⟩.</source>
          <target state="translated">键入：如果⟨exp⟩的类型为⟨T1⟩- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨T2⟩，并且⟨pat⟩与⟨T2⟩匹配，则整个视图模式与⟨T1⟩匹配。</target>
        </trans-unit>
        <trans-unit id="24b302f5a735a69a8b9ba233ec702fe31fd00c63" translate="yes" xml:space="preserve">
          <source>U1</source>
          <target state="translated">U1</target>
        </trans-unit>
        <trans-unit id="a8d7fd6a76417ab647f8d8fa5c07399d3b79ee63" translate="yes" xml:space="preserve">
          <source>UAddr</source>
          <target state="translated">UAddr</target>
        </trans-unit>
        <trans-unit id="78ab6083abe9df189496de94a58ccb0d4eb4a56f" translate="yes" xml:space="preserve">
          <source>UArray</source>
          <target state="translated">UArray</target>
        </trans-unit>
        <trans-unit id="7f21fdd64775282d97bf00c9ca8e8405b807e74b" translate="yes" xml:space="preserve">
          <source>UCHAR</source>
          <target state="translated">UCHAR</target>
        </trans-unit>
        <trans-unit id="8b101f49d46272e31b5ba7171610ec3d6c1e2b54" translate="yes" xml:space="preserve">
          <source>UChar</source>
          <target state="translated">UChar</target>
        </trans-unit>
        <trans-unit id="43946f1efc1b2a75244305a241b3665d50475303" translate="yes" xml:space="preserve">
          <source>UDouble</source>
          <target state="translated">UDouble</target>
        </trans-unit>
        <trans-unit id="3edc70483a381cca079dc023cf3096fe6750a38b" translate="yes" xml:space="preserve">
          <source>UFloat</source>
          <target state="translated">UFloat</target>
        </trans-unit>
        <trans-unit id="c710015e919de9398203f722f1db05a3c86586b2" translate="yes" xml:space="preserve">
          <source>UINT</source>
          <target state="translated">UINT</target>
        </trans-unit>
        <trans-unit id="db37a94db2ae5203a3708accea85d32d3c958e7e" translate="yes" xml:space="preserve">
          <source>UINT32</source>
          <target state="translated">UINT32</target>
        </trans-unit>
        <trans-unit id="3f2f073dc8e5d6347e3222fc44f034ebea308d84" translate="yes" xml:space="preserve">
          <source>UINT64</source>
          <target state="translated">UINT64</target>
        </trans-unit>
        <trans-unit id="ff85ccc79dc26d56bd24e1879eed03562a6fc6b4" translate="yes" xml:space="preserve">
          <source>UINT_PTR</source>
          <target state="translated">UINT_PTR</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="97a5a303674f079e7149593fff8ef1e3e8389241" translate="yes" xml:space="preserve">
          <source>ULONG</source>
          <target state="translated">ULONG</target>
        </trans-unit>
        <trans-unit id="d2cf8ae8cc99c4b7100d4b971ec75a50e14fda1e" translate="yes" xml:space="preserve">
          <source>ULONG32</source>
          <target state="translated">ULONG32</target>
        </trans-unit>
        <trans-unit id="2d38af495bc94e414019aaafb693e22712716988" translate="yes" xml:space="preserve">
          <source>ULONG64</source>
          <target state="translated">ULONG64</target>
        </trans-unit>
        <trans-unit id="172d0f1733b4b4e189ef0a8bd989c1df79a0a4ad" translate="yes" xml:space="preserve">
          <source>ULONG_PTR</source>
          <target state="translated">ULONG_PTR</target>
        </trans-unit>
        <trans-unit id="92f8d734a054faa5854ec44e1923ff5867ef42ae" translate="yes" xml:space="preserve">
          <source>UNIX-style formatting</source>
          <target state="translated">UNIX风格的格式化</target>
        </trans-unit>
        <trans-unit id="2eb5e103de68431585f421ef220db04767f7ba61" translate="yes" xml:space="preserve">
          <source>UNIX-style parsing</source>
          <target state="translated">UNIX风格的解析</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="95694b86c9d37ae5849026b15800b16e458b0df0" translate="yes" xml:space="preserve">
          <source>URec</source>
          <target state="translated">URec</target>
        </trans-unit>
        <trans-unit id="77b169462df86e1c5aedf20d7b1a20e282333aa5" translate="yes" xml:space="preserve">
          <source>USERPROFILE environment variable.</source>
          <target state="translated">USERPROFILE环境变量。</target>
        </trans-unit>
        <trans-unit id="63e558d691ebae5862cec7aa8ac03ad3a1478cfc" translate="yes" xml:space="preserve">
          <source>USHORT</source>
          <target state="translated">USHORT</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="4cb9de204b5c73618b7be72527d84e114cc9d671" translate="yes" xml:space="preserve">
          <source>UTC is time as measured by a clock, corrected to keep pace with the earth by adding or removing occasional seconds, known as &quot;leap seconds&quot;. These corrections are not predictable and are announced with six month's notice. No table of these corrections is provided, as any program compiled with it would become out of date in six months.</source>
          <target state="translated">世界协调时是指由时钟测量的时间,通过增加或删除偶尔出现的秒数(称为 &quot;闰秒&quot;)进行修正,以跟上地球的步伐。这些修正是不可预测的,并在六个月前宣布。没有提供这些更正的表格,因为用它编制的任何程序都会在六个月内过时。</target>
        </trans-unit>
        <trans-unit id="2f8fd2ae6171d356d37592b428a7472153ac6c7c" translate="yes" xml:space="preserve">
          <source>UTCTime</source>
          <target state="translated">UTCTime</target>
        </trans-unit>
        <trans-unit id="16faea8ad3a55af18ec4c289c3edcd975c20d0b8" translate="yes" xml:space="preserve">
          <source>UTF-16 (as used on Windows systems).</source>
          <target state="translated">UTF-16(Windows系统使用)。</target>
        </trans-unit>
        <trans-unit id="4c077f1764058778dde0d28028b1640ee7c397ac" translate="yes" xml:space="preserve">
          <source>UTF-16 Codecs for the IO library</source>
          <target state="translated">IO库的UTF-16编解码器</target>
        </trans-unit>
        <trans-unit id="5665eacf0693e62a4f7712f2e963fa3cb8bca4ae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16代理代码点未包含在Unicode标量值集中，但不幸的是，Haskell 承认其为有效 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。它们不能在 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中表示。此函数将那些代码点重新映射到Unicode替换字符（U + FFFD，''），并使其他代码点保持不变。</target>
        </trans-unit>
        <trans-unit id="62cdcaea7e563aff141140dcd64fe723c057ad8d" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16代理代码点未包含在Unicode标量值集中，但不幸的是，Haskell承认其为有效 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。它们不能在 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中表示。此函数将这些代码点重新映射到Unicode替换字符（U + FFFD，' '），并使其他代码点保持不变。</target>
        </trans-unit>
        <trans-unit id="9f5128ce869af750fe326f9013d7f2423f34ccae" translate="yes" xml:space="preserve">
          <source>UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values by Haskell. They cannot be represented in a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged.</source>
          <target state="translated">UTF-16代理代码点未包含在Unicode标量值集中，但不幸的是，Haskell承认其为有效 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。它们不能在 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 中表示。此函数将这些代码点重新映射到Unicode替换字符（U + FFFD，' '），并使其他代码点保持不变。</target>
        </trans-unit>
        <trans-unit id="5d917769493a54382b65e50b279329a9344690b1" translate="yes" xml:space="preserve">
          <source>UTF-32 (the C compiler defines &lt;code&gt;201605L&lt;/code&gt;), or</source>
          <target state="translated">UTF-32（C编译器定义 &lt;code&gt;201605L&lt;/code&gt; ），或</target>
        </trans-unit>
        <trans-unit id="854e15ff4be42fae1ff8c7fb8c10cdc2c177ba36" translate="yes" xml:space="preserve">
          <source>UTF-32 Codecs for the IO library</source>
          <target state="translated">IO库的UTF-32编解码器</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="37a41f96a793664e92dc44b397d82e864c6bbd46" translate="yes" xml:space="preserve">
          <source>UTF-8 Codec for the IO library</source>
          <target state="translated">IO库的UTF-8编解码器</target>
        </trans-unit>
        <trans-unit id="8d41e6620a06998e7e74776be3a2672ad12aaa66" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6476e4ebd7d465ca35fd2bf19d6fbce5908bd12" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7eb34db31e9392459f63eb077bb3f212ab1af60" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0c0cd4179d49f23f7a3bf2bc61e8abbec66b800" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a56714f6e98c5c1a765732fe18ea00295cc6fbfa" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dae2c4b8b30ebe563e4e1fec9abe5214e0622a59" translate="yes" xml:space="preserve">
          <source>UTF-8 encode a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">UTF-8编码 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e66eae2fc6a96a1729848d37d9b93a495e2b1958" translate="yes" xml:space="preserve">
          <source>UWord</source>
          <target state="translated">UWord</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">单元否定。</target>
        </trans-unit>
        <trans-unit id="87c537c6f19502c79261326e0bcf549009e63301" translate="yes" xml:space="preserve">
          <source>Unary negation. Since the negative &lt;code&gt;Int#&lt;/code&gt; range extends one further than the positive range, &lt;code&gt;negateInt#&lt;/code&gt; of the most negative number is an identity operation. This way, &lt;code&gt;negateInt#&lt;/code&gt; is always its own inverse.</source>
          <target state="translated">一元否定。由于负 &lt;code&gt;Int#&lt;/code&gt; 范围比正范围扩大了一个范围， &lt;code&gt;negateInt#&lt;/code&gt; ，最大负数的negateInt＃是标识运算。这样， &lt;code&gt;negateInt#&lt;/code&gt; 始终是其自身的逆。</target>
        </trans-unit>
        <trans-unit id="2df091d96696a6761fe09148bfdbcee91a798d7d" translate="yes" xml:space="preserve">
          <source>Unbound data constructors used in expressions behave exactly as above. However, unbound data constructors used in &lt;em&gt;patterns&lt;/em&gt; cannot be deferred, and instead bring compilation to a halt. (In implementation terms, they are reported by the renamer rather than the type checker.)</source>
          <target state="translated">表达式中使用的未绑定数据构造函数的行为完全相同。但是，不能推迟使用&lt;em&gt;模式中&lt;/em&gt;使用的未绑定数据构造函数，而是停止编译。（在实现方面，它们由重命名器而不是类型检查器报告。）</target>
        </trans-unit>
        <trans-unit id="9049099bd1356e2b34f95b9747b190e51f0a36b0" translate="yes" xml:space="preserve">
          <source>Unbound identifiers with the same name are never unified, even within the same function, but shown individually. For example:</source>
          <target state="translated">同名的非绑定标识符即使在同一个函数内也从不统一,而是单独显示。例如:</target>
        </trans-unit>
        <trans-unit id="2f1627f59b22afb759acb35503f6337e9c4c895a" translate="yes" xml:space="preserve">
          <source>Unbounded channels.</source>
          <target state="translated">不受限制的渠道。</target>
        </trans-unit>
        <trans-unit id="d03b993f9203e9dae9e61b362f008be4381a648e" translate="yes" xml:space="preserve">
          <source>Unboxed arrays</source>
          <target state="translated">未装箱的数组</target>
        </trans-unit>
        <trans-unit id="56cb77471192863f11d27c2de3b8fa29f43e70b1" translate="yes" xml:space="preserve">
          <source>Unboxed immutable arrays.</source>
          <target state="translated">开箱的不可变数组。</target>
        </trans-unit>
        <trans-unit id="2aa04c668d583672e063948de2c1a768fe11553b" translate="yes" xml:space="preserve">
          <source>Unboxed representation types</source>
          <target state="translated">未装箱的代表类型</target>
        </trans-unit>
        <trans-unit id="dd649dca9ccfcb0236fe154a419fdf07086a983b" translate="yes" xml:space="preserve">
          <source>Unboxed sum data constructor</source>
          <target state="translated">未装箱的和数据构造函数</target>
        </trans-unit>
        <trans-unit id="97a10e27338aec3a003f59edcf6ef410c80641a0" translate="yes" xml:space="preserve">
          <source>Unboxed sum type constructor</source>
          <target state="translated">未装箱的和类型构造函数</target>
        </trans-unit>
        <trans-unit id="24fca97998eebced6e5644295e7a0d139f93456e" translate="yes" xml:space="preserve">
          <source>Unboxed sums are &amp;ldquo;unboxed&amp;rdquo; in the sense that, instead of allocating sums in the heap and representing values as pointers, unboxed sums are represented as their components, just like unboxed tuples. These &amp;ldquo;components&amp;rdquo; depend on alternatives of a sum type. Like unboxed tuples, unboxed sums are lazy in their lifted components.</source>
          <target state="translated">未装箱的总和在某种意义上是&amp;ldquo;未装箱的&amp;rdquo;，其含义是，未装箱的总和像未装箱的元组一样被表示为它们的组成部分，而不是在堆中分配总和并将值表示为指针。这些&amp;ldquo;成分&amp;rdquo;取决于总和类型的替代方案。像未装箱的元组一样，未装箱的总和在它们的提升分量中是懒惰的。</target>
        </trans-unit>
        <trans-unit id="da43c5db4c48a2614146aab275d3c450e7579b03" translate="yes" xml:space="preserve">
          <source>Unboxed tuple data constructor</source>
          <target state="translated">未装箱的元组数据构造函数</target>
        </trans-unit>
        <trans-unit id="4b0c75d87c461fd4cbfd4b9516e3165c420899ff" translate="yes" xml:space="preserve">
          <source>Unboxed tuple type constructor</source>
          <target state="translated">未装箱的元组类型构造函数</target>
        </trans-unit>
        <trans-unit id="39c7cca5b4d7f980a01917a1438349d9ea99ed9b" translate="yes" xml:space="preserve">
          <source>Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in &lt;code&gt;primops.txt.pp&lt;/code&gt; return unboxed tuples. In particular, the &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt; monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.</source>
          <target state="translated">未装箱的元组用于需要返回多个值的函数，但是它们避免了通常与使用完整元组关联的堆分配。返回未装箱的元组时，组件将直接放入寄存器或堆栈中；未装箱的元组本身没有复合表示。 &lt;code&gt;primops.txt.pp&lt;/code&gt; 中列出的许多基本操作都返回未装箱的元组。特别是， &lt;code&gt;IO&lt;/code&gt; 和 &lt;code&gt;ST&lt;/code&gt; 单子使用未装箱的元组，以避免在操作序列期间进行不必要的分配。</target>
        </trans-unit>
        <trans-unit id="ed095a67c7dac513f9801658e42edf86f068e20a" translate="yes" xml:space="preserve">
          <source>Unboxed tuples aren&amp;rsquo;t really exported by &lt;code&gt;GHC.Exts&lt;/code&gt;; they are a syntactic extension (&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;). An unboxed tuple looks like this:</source>
          <target state="translated">&lt;code&gt;GHC.Exts&lt;/code&gt; 并没有真正输出未装箱的元组；它们是语法扩展（&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;）。未装箱的元组如下所示：</target>
        </trans-unit>
        <trans-unit id="6dc6698adabda63cc8b5a7e3cdf7aebe0aa330c8" translate="yes" xml:space="preserve">
          <source>Unboxed tuples can be used for multi-arity alternatives. For example:</source>
          <target state="translated">未装箱的元组可以用于多性别的替代。例如:</target>
        </trans-unit>
        <trans-unit id="aaf4cf051bde1d4837c0c90f8d330d3debcebecb" translate="yes" xml:space="preserve">
          <source>Unboxed types correspond to the &amp;ldquo;raw machine&amp;rdquo; types you would use in C: &lt;code&gt;Int#&lt;/code&gt; (long int), &lt;code&gt;Double#&lt;/code&gt; (double), &lt;code&gt;Addr#&lt;/code&gt; (void *), etc. The &lt;em&gt;primitive operations&lt;/em&gt; (PrimOps) on these types are what you might expect; e.g., &lt;code&gt;(+#)&lt;/code&gt; is addition on &lt;code&gt;Int#&lt;/code&gt;s, and is the machine-addition that we all know and love&amp;mdash;usually one instruction.</source>
          <target state="translated">未装箱的类型对应于您将在C中使用的&amp;ldquo;原始计算机&amp;rdquo;类型： &lt;code&gt;Int#&lt;/code&gt; （长整数）， &lt;code&gt;Double#&lt;/code&gt; （双精度）， &lt;code&gt;Addr#&lt;/code&gt; （无效*）等。这些类型上的&lt;em&gt;原始操作&lt;/em&gt;（PrimOps）就是您所需要的可能会期望 例如， &lt;code&gt;(+#)&lt;/code&gt; 是 &lt;code&gt;Int#&lt;/code&gt; 的加法，并且是我们都知道和喜欢的机器加法-通常是一条指令。</target>
        </trans-unit>
        <trans-unit id="94297f2cb5d15e87f00e136087b5e28e1ec12634" translate="yes" xml:space="preserve">
          <source>UnboxedSums</source>
          <target state="translated">UnboxedSums</target>
        </trans-unit>
        <trans-unit id="7c1b45d712d0b6864323ebefc5430714cce43006" translate="yes" xml:space="preserve">
          <source>UnboxedTuples</source>
          <target state="translated">UnboxedTuples</target>
        </trans-unit>
        <trans-unit id="1c00c43be5ef32bb2c58214859766bddcb001ee1" translate="yes" xml:space="preserve">
          <source>Unchecked access</source>
          <target state="translated">未勾选的访问</target>
        </trans-unit>
        <trans-unit id="94184bea267f4505d495b4d4d6947698b708d718" translate="yes" xml:space="preserve">
          <source>Unchecked floating-point arithmetic</source>
          <target state="translated">未选中的浮点运算。</target>
        </trans-unit>
        <trans-unit id="5a7ea60a6f45e07dcb8218b1e7485ce758f557f0" translate="yes" xml:space="preserve">
          <source>Unchecked read of an immutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">对一个不可变数组进行未选中的读取。可能返回垃圾信息或在越界访问时崩溃。</target>
        </trans-unit>
        <trans-unit id="8b2a1b6fe721a10cd0610eba2242b579bad0bb5f" translate="yes" xml:space="preserve">
          <source>Unchecked write of a mutable array. May return garbage or crash on an out-of-bounds access.</source>
          <target state="translated">未选中写入一个可变数组。在越界访问时可能返回垃圾或崩溃。</target>
        </trans-unit>
        <trans-unit id="e7cc6f93ca7453c5d92325af29e3d26b1dae45e7" translate="yes" xml:space="preserve">
          <source>Unclutter the list of valid hole fits by not showing provenance nor type applications of suggestions.</source>
          <target state="translated">通过不显示出处也不显示建议的类型应用来疏通有效的孔洞配合列表。</target>
        </trans-unit>
        <trans-unit id="92d9913ec326ea74caabbca08223befd12ff0d41" translate="yes" xml:space="preserve">
          <source>UndecidableInstances</source>
          <target state="translated">UndecidableInstances</target>
        </trans-unit>
        <trans-unit id="dcba899dfe07dc0580f1fd4d4e2b04b64512a67c" translate="yes" xml:space="preserve">
          <source>UndecidableSuperClasses</source>
          <target state="translated">UndecidableSuperClasses</target>
        </trans-unit>
        <trans-unit id="524a80e3cff00c5e0580dc9263ab4a88165efc16" translate="yes" xml:space="preserve">
          <source>Undefine a symbol in the C pre-processor</source>
          <target state="translated">在C语言预处理器中取消定义一个符号。</target>
        </trans-unit>
        <trans-unit id="d43a17d536b34a95ec352c02a0e1fa2bfac08b1a" translate="yes" xml:space="preserve">
          <source>Undefine macro ⟨symbol⟩ in the usual way.</source>
          <target state="translated">用通常的方法取消定义宏⟨symbol⟩。</target>
        </trans-unit>
        <trans-unit id="cc16de424326616c4ed48a51f05170fb404dcb0e" translate="yes" xml:space="preserve">
          <source>Undefines the user-defined command ⟨name⟩ (see &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; above).</source>
          <target state="translated">取消定义用户定义的命令&amp;ldquo;名称&amp;rdquo;（请参见上文&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="739d95b825e4aa989aff734d85f2e64f070e8d07" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt;, negated literals are desugared without &lt;code&gt;negate&lt;/code&gt;. That is, &lt;code&gt;-123&lt;/code&gt; stands for &lt;code&gt;fromInteger (-123)&lt;/code&gt; rather than &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. This makes &lt;a href=&quot;#extension-LexicalNegation&quot;&gt;&lt;code&gt;LexicalNegation&lt;/code&gt;&lt;/a&gt; a valid replacement for &lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; 下&lt;/a&gt;，否定的字面量将被否定而不加 &lt;code&gt;negate&lt;/code&gt; 。也就是说， &lt;code&gt;-123&lt;/code&gt; 代表 &lt;code&gt;fromInteger (-123)&lt;/code&gt; 而不是 &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; 。这使得&lt;a href=&quot;#extension-LexicalNegation&quot;&gt; &lt;code&gt;LexicalNegation&lt;/code&gt; &lt;/a&gt;可以有效替代&lt;a href=&quot;negative_literals#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="548a3041dcf33dfa2cebed472eb6cc52a0efe3ba" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 下&lt;/a&gt;，类型中的 &lt;code&gt;*&lt;/code&gt; 既不是运算符也不是名称，它是代表 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 的特殊语法。这意味着像 &lt;code&gt;Either * Char&lt;/code&gt; 这样的表达式将被解析为 &lt;code&gt;Either (*) Char&lt;/code&gt; 而不是 &lt;code&gt;(*) Either Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9357dbe3d4862458ad80f085c14206fe2d8eac4b" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;-XStarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;-XStarIsType&lt;/code&gt; 下&lt;/a&gt;，类型中的 &lt;code&gt;*&lt;/code&gt; 既不是运算符，也不是名称，它是代表 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 的特殊语法。这意味着将像 &lt;code&gt;Either * Char&lt;/code&gt; 这样的表达式解析为 &lt;code&gt;Either (*) Char&lt;/code&gt; 而不是 &lt;code&gt;(*) Either Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c0d27dce34085e806931a10af8a883394beb69a" translate="yes" xml:space="preserve">
          <source>Under &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;*&lt;/code&gt; in types is not an operator nor even a name, it is special syntax that stands for &lt;code&gt;Data.Kind.Type&lt;/code&gt;. This means that an expression like &lt;code&gt;Either * Char&lt;/code&gt; is parsed as &lt;code&gt;Either (*)
Char&lt;/code&gt; and not &lt;code&gt;(*) Either Char&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; 下&lt;/a&gt;，类型中的 &lt;code&gt;*&lt;/code&gt; 既不是运算符也不是名称，它是代表 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 的特殊语法。这意味着像 &lt;code&gt;Either * Char&lt;/code&gt; 这样的表达式将被解析为 &lt;code&gt;Either (*) Char&lt;/code&gt; 而不是 &lt;code&gt;(*) Either Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83acc7e2fcd190b9029f0366e2b5f34e8c87d524" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries /do not support/ locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">在GHC 6.10和更早的版本下,系统I/O库/不支持/本地敏感的I/O或行结束转换。在这些版本的GHC上,该库中的函数全部使用UTF-8。这在实践中意味着什么?</target>
        </trans-unit>
        <trans-unit id="45aadb84db37059cb048a3619c050dc25846d7f8" translate="yes" xml:space="preserve">
          <source>Under GHC 6.10 and earlier, the system I/O libraries do not support locale-sensitive I/O or line ending conversion. On these versions of GHC, functions in this library all use UTF-8. What does this mean in practice?</source>
          <target state="translated">在GHC 6.10和更早的版本下,系统I/O库不支持本地敏感的I/O或行结束转换。在这些版本的GHC上,该库中的函数全部使用UTF-8。这在实践中意味着什么?</target>
        </trans-unit>
        <trans-unit id="6a35d752fd9cbd386bd76776c4f13c497a1eeb9e" translate="yes" xml:space="preserve">
          <source>Under GHC, a rewrite rule will transform break (==) into a call to the specialised breakByte:</source>
          <target state="translated">在GHC下,重写规则会将break(==)转化为对专用breakByte的调用。</target>
        </trans-unit>
        <trans-unit id="b507369e223691105dbfe5a381bf76a0cf2dc2da" translate="yes" xml:space="preserve">
          <source>Under Mac OS X debug information is kept apart from the executable. After compiling the executable you&amp;rsquo;ll need to use the &lt;code&gt;dsymutil&lt;/code&gt; utility to extract the debugging information and place them in the debug archive,</source>
          <target state="translated">在Mac OS X下，调试信息与可执行文件分开存放。编译可执行文件后，您需要使用 &lt;code&gt;dsymutil&lt;/code&gt; 实用程序来提取调试信息并将其放入调试档案中，</target>
        </trans-unit>
        <trans-unit id="0c9448e4f1f1bc1a4848bdf810185f068342adf0" translate="yes" xml:space="preserve">
          <source>Under most circumstances, you cannot use standalone deriving to create an instance for a data type whose constructors are not all in scope. This is because the derived instance would generate code that uses the constructors behind the scenes, which would break abstraction.</source>
          <target state="translated">在大多数情况下,你不能使用独立的派生来创建一个数据类型的实例,这个数据类型的构造函数并不都在范围内。这是因为派生实例会生成在幕后使用构造函数的代码,这将破坏抽象性。</target>
        </trans-unit>
        <trans-unit id="befde3cad169af590a27942ec587ed85bf818337" translate="yes" xml:space="preserve">
          <source>Underflow</source>
          <target state="translated">Underflow</target>
        </trans-unit>
        <trans-unit id="73d89b3a81eb250a4b44258aed0e8fed46b29f5a" translate="yes" xml:space="preserve">
          <source>Underlying monadic value</source>
          <target state="translated">基本一元价值</target>
        </trans-unit>
        <trans-unit id="c982cc09160648fab8b183af5c0c2149ea73000b" translate="yes" xml:space="preserve">
          <source>Underlying untyped Template Haskell expression</source>
          <target state="translated">底层非类型模板Haskell表达式</target>
        </trans-unit>
        <trans-unit id="c21c7d09d002fd765aab0ed41ec3c61f09c3bb52" translate="yes" xml:space="preserve">
          <source>Unfolding</source>
          <target state="translated">Unfolding</target>
        </trans-unit>
        <trans-unit id="a400d187aefff9554f2dba096d918bdfffe6746c" translate="yes" xml:space="preserve">
          <source>Unfolding ByteStrings</source>
          <target state="translated">展开ByteStrings</target>
        </trans-unit>
        <trans-unit id="27df4ee6ad39c049fab42c4d04ccfca737a63344" translate="yes" xml:space="preserve">
          <source>Unfolding constructor applications</source>
          <target state="translated">展开式构造函数应用</target>
        </trans-unit>
        <trans-unit id="d3b9185e6a4c71709e29813b48ffdc7956f41b7a" translate="yes" xml:space="preserve">
          <source>Unfortunately DWARF isn&amp;rsquo;t expressive enough to fully describe the code that GHC produces. This is most apparent in the case of line information, where GHC is forced to choose some between a variety of possible originating source locations. This limits the usefulness of DWARF information with traditional statistical profiling tools. For profiling it is recommended that one use the extended debugging information. See the &lt;em&gt;Profiling&lt;/em&gt; section below.</source>
          <target state="translated">不幸的是，DWARF的表达能力不足以完全描述GHC生成的代码。这在线路信息的情况下最为明显，在线路信息中，GHC被迫在各种可能的始发源位置之间进行选择。这限制了DWARF信息与传统统计分析工具的有用性。为了进行分析，建议使用扩展的调试信息。请参阅下面的&lt;em&gt;分析&lt;/em&gt;部分。</target>
        </trans-unit>
        <trans-unit id="6af016495fc0911fc823f78e0cef0cecf47d4281" translate="yes" xml:space="preserve">
          <source>Unfortunately not. We haven&amp;rsquo;t implemented it yet. Please compile any offending modules by hand before loading them into GHCi.</source>
          <target state="translated">不幸的是没有。我们尚未实现。在将任何有问题的模块加载到GHCi中之前，请先手动对其进行编译。</target>
        </trans-unit>
        <trans-unit id="f8fc2ac28fcbb9012b214aa245e8b7f0b3808aac" translate="yes" xml:space="preserve">
          <source>Uni</source>
          <target state="translated">Uni</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="a1d3d5a32e8c988012ad8507f17107abf2db03c5" translate="yes" xml:space="preserve">
          <source>Unicode General Categories (column 2 of the UnicodeData table) in the order they are listed in the Unicode standard (the Unicode Character Database, in particular).</source>
          <target state="translated">Unicode通用类别(UnicodeData表的第2列)按照Unicode标准(特别是Unicode字符数据库)中的顺序排列。</target>
        </trans-unit>
        <trans-unit id="0b1cd569a3121684aa423894fbcbdf345cc5b88e" translate="yes" xml:space="preserve">
          <source>Unicode Roman numerals are &quot;numbers&quot; as well:</source>
          <target state="translated">Unicode罗马数字也是 &quot;数字&quot;。</target>
        </trans-unit>
        <trans-unit id="97fd6e9e895c72b521ac2e308c742d79b142fbcd" translate="yes" xml:space="preserve">
          <source>Unicode alternative</source>
          <target state="translated">统一码替代品</target>
        </trans-unit>
        <trans-unit id="a65c9d80435c08abe776fbae85509e93cf7c4cbf" translate="yes" xml:space="preserve">
          <source>Unicode characters are divided into letters, numbers, marks, punctuation, symbols, separators (including spaces) and others (including control characters).</source>
          <target state="translated">Unicode字符分为字母、数字、标记、标点符号、符号、分隔符(包括空格)和其他(包括控制字符)。</target>
        </trans-unit>
        <trans-unit id="5fb07603277143928d306b764aee2aa5fcca7a63" translate="yes" xml:space="preserve">
          <source>Unicode encoding/decoding</source>
          <target state="translated">统一码编码/解码</target>
        </trans-unit>
        <trans-unit id="f9e742f9d39fd05cf65c9f6a96d4c36b5ffd45b2" translate="yes" xml:space="preserve">
          <source>Unicode encodings</source>
          <target state="translated">统一码编码</target>
        </trans-unit>
        <trans-unit id="1d3197d948b5d54120c87a9dc026e98f7afb2329" translate="yes" xml:space="preserve">
          <source>Unicode general categories</source>
          <target state="translated">统一码通用类别</target>
        </trans-unit>
        <trans-unit id="b3471a7cade0200813e7f5a65bfc13c08a37abb4" translate="yes" xml:space="preserve">
          <source>UnicodeException</source>
          <target state="translated">UnicodeException</target>
        </trans-unit>
        <trans-unit id="28994769bba962bb066d22d1fcd75c46baf1f910" translate="yes" xml:space="preserve">
          <source>UnicodeSubsetBitfield</source>
          <target state="translated">UnicodeSubsetBitfield</target>
        </trans-unit>
        <trans-unit id="416bfa34f2ec7dc6a0e57308141fdf8712f09250" translate="yes" xml:space="preserve">
          <source>UnicodeSyntax</source>
          <target state="translated">UnicodeSyntax</target>
        </trans-unit>
        <trans-unit id="9d591225a789a1e2dd25c12959566ecdbe116b67" translate="yes" xml:space="preserve">
          <source>Unidir</source>
          <target state="translated">Unidir</target>
        </trans-unit>
        <trans-unit id="21d169e1e1ba8ff5f3db678f5a3a331dbf85a922" translate="yes" xml:space="preserve">
          <source>Unidirectional</source>
          <target state="translated">Unidirectional</target>
        </trans-unit>
        <trans-unit id="857d540c20885058e9036f20ddbdbb0f3967a8b4" translate="yes" xml:space="preserve">
          <source>Unidirectional synonyms can only be used in a pattern context and are defined as follows:</source>
          <target state="translated">单向同义词只能在模式上下文中使用,定义如下。</target>
        </trans-unit>
        <trans-unit id="b5d9701d585a57c337e54ac1677953d5a0ec923f" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original output history on entering the continuation.</source>
          <target state="translated">将 &lt;code&gt;callCC&lt;/code&gt; 操作统一提升到新monad。此版本在输入延续时会回滚到原始输出历史记录。</target>
        </trans-unit>
        <trans-unit id="79444c001b62604780520e1d8cc531b07ad38937" translate="yes" xml:space="preserve">
          <source>Uniform lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version rolls back to the original state on entering the continuation.</source>
          <target state="translated">将 &lt;code&gt;callCC&lt;/code&gt; 操作统一提升到新monad。该版本在进入延续时会回滚到原始状态。</target>
        </trans-unit>
        <trans-unit id="f92d78e3b22bfa68fdbc9865cf302e8784a6ed59" translate="yes" xml:space="preserve">
          <source>Uninhabited data type</source>
          <target state="translated">无人居住的数据类型</target>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="5cb05b9c841af29c6d7076675127c6f1751b1611" translate="yes" xml:space="preserve">
          <source>Uniq</source>
          <target state="translated">Uniq</target>
        </trans-unit>
        <trans-unit id="87c6f410754d2f5d42cbccc33576be0d5edc865c" translate="yes" xml:space="preserve">
          <source>Unique</source>
          <target state="translated">Unique</target>
        </trans-unit>
        <trans-unit id="6740271407e0346633d83d694dccd887dc851ab1" translate="yes" xml:space="preserve">
          <source>Unique index for datatype constructors, counting from 1 in the order they are given in the program text.</source>
          <target state="translated">数据类型构造函数的唯一索引,按照程序文本中给出的顺序从1开始计算。</target>
        </trans-unit>
        <trans-unit id="0cdacf36b6c56119b440b93ba791e8060793975b" translate="yes" xml:space="preserve">
          <source>Unique objects</source>
          <target state="translated">独特的对象</target>
        </trans-unit>
        <trans-unit id="e9681f3eecc02057c1930f3e437fac4c4dc0a528" translate="yes" xml:space="preserve">
          <source>Unit: used for constructors without arguments</source>
          <target state="translated">单位:用于无参数的构造函数</target>
        </trans-unit>
        <trans-unit id="e5c5ea9f2e8d47273274318044fa87be4d1553ac" translate="yes" xml:space="preserve">
          <source>Universal Time</source>
          <target state="translated">世界时间</target>
        </trans-unit>
        <trans-unit id="3ccc8ae980014996c3ba2b246d1968e7182cd21b" translate="yes" xml:space="preserve">
          <source>Universal combining function</source>
          <target state="translated">通用组合功能</target>
        </trans-unit>
        <trans-unit id="9b649bd37c2b26f2b1eea5d886435ad1639c3dcd" translate="yes" xml:space="preserve">
          <source>UniversalTime</source>
          <target state="translated">UniversalTime</target>
        </trans-unit>
        <trans-unit id="3188f36c5a9baab0220303d08a37a90ed3c179ef" translate="yes" xml:space="preserve">
          <source>Unix systems</source>
          <target state="translated">Unix系统</target>
        </trans-unit>
        <trans-unit id="904813cf231fd43102ff510ba028e64ed13e11f0" translate="yes" xml:space="preserve">
          <source>Unless otherwise documented:</source>
          <target state="translated">除非另有记载。</target>
        </trans-unit>
        <trans-unit id="8642dfb2a45b656d6cf0f11c976548175dd112cc" translate="yes" xml:space="preserve">
          <source>Unlifted</source>
          <target state="translated">Unlifted</target>
        </trans-unit>
        <trans-unit id="02139489e61ee59e21afe01951fcc0f2d3926eef" translate="yes" xml:space="preserve">
          <source>UnliftedFFITypes</source>
          <target state="translated">UnliftedFFITypes</target>
        </trans-unit>
        <trans-unit id="5b45d2b7d96fbef96a9bc758815c76e0e2e71a5f" translate="yes" xml:space="preserve">
          <source>UnliftedNewtypes</source>
          <target state="translated">UnliftedNewtypes</target>
        </trans-unit>
        <trans-unit id="86de4c205eb285a93150c129623bae5eb391405f" translate="yes" xml:space="preserve">
          <source>UnliftedRep</source>
          <target state="translated">UnliftedRep</target>
        </trans-unit>
        <trans-unit id="05387fc15f74919cf9fdeff901519828076433b8" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; cannot be used on data types containing a function type on the right-hand side.</source>
          <target state="translated">与&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;不同，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;不能用于右侧包含函数类型的数据类型。</target>
        </trans-unit>
        <trans-unit id="9ec0ce71b212aa99a2244669feec22e6979c5a4f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is not implied by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt;. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</source>
          <target state="translated">不同于&lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;不被暗示&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;。做出此决定的理由是，与术语级模式名称不同，类型名称通常是出于文档目的而明确选择的，因此在类型名称中使用下划线会使文档难以阅读。</target>
        </trans-unit>
        <trans-unit id="9588771c39f566dc9284aa81dce97aa98380c66a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">与&amp;ldquo; &lt;a href=&quot;#typed-holes&quot;&gt;类型化孔&amp;rdquo;&lt;/a&gt;不同，&amp;ldquo; 类型孔&amp;rdquo;会使程序不完整，并且在评估它们时会产生错误，而对于类型签名中的孔则不必如此。类型检查器能够（在大多数情况下）对具有或不具有类型签名的绑定进行类型检查。部分类型签名弥合了两个极端之间的鸿沟，程序员可以选择对类型的哪些部分进行注释，以及将哪些留给类型检查器进行推断。</target>
        </trans-unit>
        <trans-unit id="0b99ca092888b44bba510df4577b6b4d2d84d797" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;typed_holes#typed-holes&quot;&gt;Typed Holes&lt;/a&gt;, which make the program incomplete and will generate errors when they are evaluated, this needn&amp;rsquo;t be the case for holes in type signatures. The type checker is capable (in most cases) of type-checking a binding with or without a type signature. A partial type signature bridges the gap between the two extremes, the programmer can choose which parts of a type to annotate and which to leave over to the type-checker to infer.</source>
          <target state="translated">与&amp;ldquo;&lt;a href=&quot;typed_holes#typed-holes&quot;&gt;类型化孔&amp;rdquo;&lt;/a&gt;不同，&amp;ldquo;类型孔&amp;rdquo;会使程序不完整，并且在评估它们时会产生错误，而对于类型签名中的孔则不必如此。类型检查器能够（在大多数情况下）对带有或不带有类型签名的绑定进行类型检查。部分类型签名弥合了两个极端之间的鸿沟，程序员可以选择对类型的哪些部分进行注释，以及将哪些留给类型检查器进行推断。</target>
        </trans-unit>
        <trans-unit id="d404ca61d5a715fd529bb048e306eac1275e0be5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;, this option does NOT cause package ⟨pkg⟩ to be linked into the resulting executable or shared object.</source>
          <target state="translated">与 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 不同，此选项不会导致将⟨pkg⟩链接到生成的可执行文件或共享库中。</target>
        </trans-unit>
        <trans-unit id="1acefef11c592c3d3f17d3c7be838d89128c3315" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 不同，此函数不对参数进行Unicode解码。您将获得操作系统传递给程序的确切字节。要将自变量解释为文本，应应用一些Unicode解码。</target>
        </trans-unit>
        <trans-unit id="897acea06a039f9d84c343986efe70490281cb9e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 不同，此函数不对参数进行Unicode解码。您将获得OS传递给程序的确切字节。要将自变量解释为文本，应应用一些Unicode解码。</target>
        </trans-unit>
        <trans-unit id="05566e43d5c34bd670cdfbd05fbe866ec3e61186" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, this function does no Unicode decoding of the arguments; you get the exact bytes that were passed to the program by the OS. To interpret the arguments as text, some Unicode decoding should be applied.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 不同，此函数不对参数进行Unicode解码。您将获得OS传递给程序的确切字节。要将自变量解释为文本，应应用一些Unicode解码。</target>
        </trans-unit>
        <trans-unit id="bd4e4ff32086d994ad37eddbf8517bcc52472a7b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, this can be used to retrieve an element without forcing it. For example, to insert the fifth element of a sequence &lt;code&gt;xs&lt;/code&gt; into a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; at key &lt;code&gt;k&lt;/code&gt;, you could use</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 不同，它可用于检索元素而无需强制。例如，要将序列 &lt;code&gt;xs&lt;/code&gt; 的第五个元素插入键 &lt;code&gt;k&lt;/code&gt; 处的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 中，可以使用</target>
        </trans-unit>
        <trans-unit id="89f9aac36a458d5958d7d9a2bc209869dd9e0111" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; type constructors do not map to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;. They are defined directly, as follows:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 类型的构造函数不会映射到 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 。它们是直接定义的，如下所示：</target>
        </trans-unit>
        <trans-unit id="2e1400b4a387ddd47964b16ed92dc51a65a21d9a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 指的是编译器为数据构造器字段选择的严格性，它可能与源代码中编写的不同。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c1964f70216a8e1c70dcdc64cbaedc2bf1867ae" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; refers to the strictness that the compiler chooses for a data constructor field, which may be different from what is written in source code. See &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 指的是编译器为数据构造器字段选择的严格性，它可能与源代码中编写的不同。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyConStrictness&quot;&gt;reifyConStrictness&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef1eaf78214b10e7045c65146fa5532f8c3f3e14" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 不同，此功能永远不会失败。如果功能不存在或设置为false，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="255633d21e505289c6e8c6e3a244c4a2c1e30045" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 不同，此功能永远不会失败。如果功能不存在或设置为false，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6ac906b2e87deb1331972ed52f86a854e2d6b08" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt;, this capability never fails; it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; if the capability is absent or set to false, and returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGuardFlag&quot;&gt;tiGuardFlag&lt;/a&gt;&lt;/code&gt; 不同，此功能永远不会失败。如果功能不存在或设置为false，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9055ff7794bcb0b3cd85d08c18a0bc07df718029" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;INLINE&lt;/code&gt;, it is OK to use an &lt;code&gt;INLINABLE&lt;/code&gt; pragma on a recursive function. The principal reason do to so to allow later use of &lt;code&gt;SPECIALISE&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;INLINE&lt;/code&gt; 不同，可以在递归函数上使用 &lt;code&gt;INLINABLE&lt;/code&gt; 编译指示。这样做的主要原因是允许以后使用 &lt;code&gt;SPECIALISE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e861e82acc7f14c2da4b67efcccf071159b37de4" translate="yes" xml:space="preserve">
          <source>Unlike C &lt;code&gt;printf(3)&lt;/code&gt;, the formatting of this &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; is driven by the argument type; formatting is type specific. The types formatted by &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; &quot;out of the box&quot; are:</source>
          <target state="translated">与C &lt;code&gt;printf(3)&lt;/code&gt; 不同，此 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的格式由参数类型驱动；格式是特定于类型的。用 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 格式&amp;ldquo;开箱即用&amp;rdquo; 格式化的类型是：</target>
        </trans-unit>
        <trans-unit id="822d212fad8aaf79fe48fb52b7ebba6d9f068e32" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)</source>
          <target state="translated">与附加到 &lt;code&gt;data&lt;/code&gt; 声明的 &lt;code&gt;deriving&lt;/code&gt; 声明不同，GHC不限制数据类型的形式。相反，GHC只是为指定的类生成适当的样板代码，并对其进行类型检查。如果有类型错误，那就是您的问题。（如果发生类型错误，GHC将向您显示令人反感的代码。）</target>
        </trans-unit>
        <trans-unit id="e2d675265d1e9b5ebb6d33cbfd2b5818fa8d06b3" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">与附加到 &lt;code&gt;data&lt;/code&gt; 声明的 &lt;code&gt;deriving&lt;/code&gt; 声明不同，实例可以比数据类型更具体（假设您还&lt;a href=&quot;#instance-rules&quot;&gt;对实例上下文&lt;/a&gt;使用&lt;a href=&quot;#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt;，Relaxed规则）。考虑一下</target>
        </trans-unit>
        <trans-unit id="b63d1a43428a8154e612e52025ecfc75af2b7757" translate="yes" xml:space="preserve">
          <source>Unlike a &lt;code&gt;deriving&lt;/code&gt; declaration attached to a &lt;code&gt;data&lt;/code&gt; declaration, the instance can be more specific than the data type (assuming you also use &lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt;&lt;code&gt;FlexibleInstances&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;instances#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;). Consider for example</source>
          <target state="translated">与附加到 &lt;code&gt;data&lt;/code&gt; 声明的 &lt;code&gt;deriving&lt;/code&gt; 声明不同，该实例可以比数据类型更具体（假设您还&lt;a href=&quot;instances#instance-rules&quot;&gt;对实例上下文&lt;/a&gt;使用&lt;a href=&quot;instances#extension-FlexibleInstances&quot;&gt; &lt;code&gt;FlexibleInstances&lt;/code&gt; &lt;/a&gt;，Relaxed规则）。考虑一下</target>
        </trans-unit>
        <trans-unit id="e94fcd606b07271129ee53f7579bff16996d2e37" translate="yes" xml:space="preserve">
          <source>Unlike a Haskell-98-style data type declaration, the type variable(s) in the &amp;ldquo;&lt;code&gt;data Set a where&lt;/code&gt;&amp;rdquo; header have no scope. Indeed, one can write a kind signature instead:</source>
          <target state="translated">与Haskell-98样式的数据类型声明不同，&amp;ldquo; &lt;code&gt;data Set a where&lt;/code&gt; &amp;rdquo;标头中的类型变量没有作用域。确实，可以改写一种善意的签名：</target>
        </trans-unit>
        <trans-unit id="d15facd9212fb40624ed67a1a3dac71c37d65618" translate="yes" xml:space="preserve">
          <source>Unlike expression and declaration type signatures, pattern type signatures are not implicitly generalised. The pattern in a &lt;em&gt;pattern binding&lt;/em&gt; may only mention type variables that are already in scope. For example:</source>
          <target state="translated">与表达式和声明类型签名不同，模式类型签名不是隐式概括的。&lt;em&gt;模式绑定&lt;/em&gt;中的&lt;em&gt;模式&lt;/em&gt;只能提及范围内的类型变量。例如：</target>
        </trans-unit>
        <trans-unit id="6f7bdadab6da6a387044d423d8a6e43eccb971ac" translate="yes" xml:space="preserve">
          <source>Unlike in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, the instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; refers to &lt;code&gt;encode'&lt;/code&gt;, not &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="translated">与在 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 中不同， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的实例是&amp;ldquo; &lt;code&gt;encode'&lt;/code&gt; 而不是&amp;ldquo; &lt;code&gt;encode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a23057942854a08eb5e6d0e2e84f25f90f7394f0" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices of the form &lt;code&gt;$(...)&lt;/code&gt;, declaration quasi-quotes do not cause a declaration group break. See &lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt; for more information.</source>
          <target state="translated">与形式 &lt;code&gt;$(...)&lt;/code&gt; 普通声明拼接不同，声明准引号不会导致声明组中断。有关更多信息，请参见&lt;a href=&quot;#th-syntax&quot;&gt;语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cd0c6a2c2ff514ddc9d128c7471e1ec6efddc93" translate="yes" xml:space="preserve">
          <source>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by &lt;code&gt;reify&lt;/code&gt; from a declaration quasiquoter will not include anything from the quasiquoter&amp;rsquo;s declaration group.</source>
          <target state="translated">与普通的声明接头不同，声明准引号不会引起中断。在处理声明组的其余部分之前，将扩展这些准引用，并将它们生成的声明合并到周围的声明组中。因此，通过看到的类型的环境 &lt;code&gt;reify&lt;/code&gt; ，从一个声明quasiquoter将不包括从quasiquoter的声明类的话。</target>
        </trans-unit>
        <trans-unit id="23764803cb059caa49d708a6b67c530ad09e8222" translate="yes" xml:space="preserve">
          <source>Unlike other declarations, for which only the entities declared in a signature file are brought into scope, instances from the implementation are always brought into scope, even if they were not declared in the signature file. This means that a module may typecheck against a signature, but not against a matching implementation. You can avoid situations like this by never defining orphan instances inside a package that has signatures.</source>
          <target state="translated">与其他声明不同的是,只有在签名文件中声明的实体才会被纳入作用域,而实现中的实例总是被纳入作用域,即使它们没有在签名文件中声明。这意味着一个模块可以对签名进行类型检查,但不能对匹配的实现进行检查。你可以避免这样的情况,永远不要在有签名的包中定义孤儿实例。</target>
        </trans-unit>
        <trans-unit id="597c7f9ea0c6e86579770ef9d59523f0d75fb167" translate="yes" xml:space="preserve">
          <source>Unlike other removal functions, this function will also attempt to delete files marked as read-only or otherwise made unremovable due to permissions. As a result, if the removal is incomplete, the permissions or attributes on the remaining files may be altered. If there are hard links in the directory, then permissions on all related hard links may be altered.</source>
          <target state="translated">与其他删除功能不同的是,该功能还将尝试删除标记为只读或因权限而无法删除的文件。因此,如果删除不完全,剩余文件的权限或属性可能会被改变。如果目录中存在硬链接,那么所有相关硬链接的权限可能会被改变。</target>
        </trans-unit>
        <trans-unit id="4457728427c26c787e87ceb48b1b248cdd0cff88" translate="yes" xml:space="preserve">
          <source>Unlike other similarly named functions, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; does not use &lt;code&gt;SearchPath&lt;/code&gt; from the Win32 API. The behavior of this function on Windows is therefore equivalent to those on non-Windows platforms.</source>
          <target state="translated">与其他类似命名的函数不同， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutablesInDirectories&quot;&gt;findExecutablesInDirectories&lt;/a&gt;&lt;/code&gt; 不使用Win32 API中的 &lt;code&gt;SearchPath&lt;/code&gt; 。因此，此功能在Windows上的行为等同于非Windows平台上的行为。</target>
        </trans-unit>
        <trans-unit id="06300c11959df3c55eab5253ee8af1fdd51c9a69" translate="yes" xml:space="preserve">
          <source>Unlike regular modules, the defined entities of a signature include not only those written in the local &lt;code&gt;hsig&lt;/code&gt; file, but also those from inherited signatures (as inferred from the &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; flags). These entities are not considered in scope when typechecking the local &lt;code&gt;hsig&lt;/code&gt; file, but are available for import by any module or signature which imports the signature. The one exception to this rule is the export list, described below.</source>
          <target state="translated">与常规模块不同，签名的定义实体不仅包括写在本地 &lt;code&gt;hsig&lt;/code&gt; 文件中的实体，还包括继承的签名中的实体（从 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; 标志推断出）。在对本地 &lt;code&gt;hsig&lt;/code&gt; 文件进行类型检查时，这些实体不在范围内，但是可以由导入签名的任何模块或签名来导入。此规则的一个例外是导出列表，如下所述。</target>
        </trans-unit>
        <trans-unit id="b445b71f37755ceafc44164842f3cafdfc51ad7e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">不同于 &lt;code&gt;forall&lt;/code&gt; 的形式中，输入变量 &lt;code&gt;a&lt;/code&gt; 从 &lt;code&gt;f&lt;/code&gt; 的签名不超过作用域 &lt;code&gt;f&lt;/code&gt; 的方程（组）。受模式签名约束的类型变量 &lt;code&gt;aa&lt;/code&gt; 的作用域位于 &lt;code&gt;f&lt;/code&gt; 方程的右侧。（因此，无需使用不同的类型变量；使用 &lt;code&gt;a&lt;/code&gt; 等效。）</target>
        </trans-unit>
        <trans-unit id="b933a24b64cdbef2c38c5866a81b259e2fd9806b" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;forall&lt;/code&gt; form, type variable &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s signature is not scoped over &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation(s). Type variable &lt;code&gt;aa&lt;/code&gt; bound by the pattern signature is scoped over the right-hand side of &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s equation. (Therefore there is no need to use a distinct type variable; using &lt;code&gt;a&lt;/code&gt; would be equivalent.)</source>
          <target state="translated">不同于 &lt;code&gt;forall&lt;/code&gt; 的形式中，输入变量 &lt;code&gt;a&lt;/code&gt; 从 &lt;code&gt;f&lt;/code&gt; 的签名不超过作用域 &lt;code&gt;f&lt;/code&gt; 的方程（组）。受模式签名限制的类型变量 &lt;code&gt;aa&lt;/code&gt; 的作用范围位于 &lt;code&gt;f&lt;/code&gt; 方程的右侧。（因此，无需使用不同的类型变量；使用 &lt;code&gt;a&lt;/code&gt; 等效。）</target>
        </trans-unit>
        <trans-unit id="07937d8189c5060ed5381ab32883c57e83ee831e" translate="yes" xml:space="preserve">
          <source>Unlike the associated type family declaration itself, the type variables of the default instance are independent of those of the parent class.</source>
          <target state="translated">与关联的类型族声明本身不同,默认实例的类型变量与父类的类型变量无关。</target>
        </trans-unit>
        <trans-unit id="69f4d9a01fb6d7ddab12b0c937f801a23fbb7f34" translate="yes" xml:space="preserve">
          <source>Unlike the default definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt;, it is defined for 0 and so it should be preferred where possible.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 的默认定义不同，它是为0定义的，因此应尽可能首选它。</target>
        </trans-unit>
        <trans-unit id="865d4045d80f8564c6ad3ca37c512ab3a0dd4aa4" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与前面的示例不同，当前无法使用&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;手动解决歧义。</target>
        </trans-unit>
        <trans-unit id="77dcfd6345308258ebb060f9ef483bfd2e2232d6" translate="yes" xml:space="preserve">
          <source>Unlike the previous examples, it is not currently possible to resolve the ambiguity manually by using &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与前面的示例不同，当前无法使用&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;手动解决歧义。</target>
        </trans-unit>
        <trans-unit id="9b6cc89d8ca2d4d98a8cd94a124ce20e53b59f2e" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;. It can alternatively be:</source>
          <target state="translated">与普通数据定义不同，数据族的结果类型不必为 &lt;code&gt;Type&lt;/code&gt; 。它也可以是：</target>
        </trans-unit>
        <trans-unit id="737888d68afa4f88e72ac4273f546c5a3360f81f" translate="yes" xml:space="preserve">
          <source>Unlike with ordinary data definitions, the result kind of a data family does not need to be &lt;code&gt;Type&lt;/code&gt;: it can alternatively be a kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;). Data instances&amp;rsquo; kinds must end in &lt;code&gt;Type&lt;/code&gt;, however.</source>
          <target state="translated">与普通数据定义不同，数据族的结果类型不必是 &lt;code&gt;Type&lt;/code&gt; ：它也可以是一个类型变量（使用&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;）。数据实例的种类必须以 &lt;code&gt;Type&lt;/code&gt; 结尾。</target>
        </trans-unit>
        <trans-unit id="7946e2babfb31beb0cce042d8dd3c699ab7f6a8e" translate="yes" xml:space="preserve">
          <source>Unlikely :-) A useful be-more-paranoid option to give to GHC is &lt;code&gt;-dcore-lint&lt;/code&gt;-dcore-lint option; this causes a &amp;ldquo;lint&amp;rdquo; pass to check for errors (notably type errors) after each Core-to-Core transformation pass. We run with &lt;code&gt;-dcore-lint&lt;/code&gt; on all the time; it costs about 5% in compile time.</source>
          <target state="translated">不太可能:-)给予GHC有用的be-more-paranoid选项是 &lt;code&gt;-dcore-lint&lt;/code&gt; -dcore-lint选项；这会导致在每次Core-to-Core转换通过之后，&amp;ldquo; lint&amp;rdquo;通过检查错误（尤其是类型错误）。我们一直都在使用 &lt;code&gt;-dcore-lint&lt;/code&gt; ；它花费大约5％的编译时间。</target>
        </trans-unit>
        <trans-unit id="1526a17ee7570e6235eb76a6fef8ce4b6d9a3486" translate="yes" xml:space="preserve">
          <source>Unlock</source>
          <target state="translated">Unlock</target>
        </trans-unit>
        <trans-unit id="3b8f8d955c9b7f88d2d430a6fbd48f07e8b6555d" translate="yes" xml:space="preserve">
          <source>Unlock the semaphore.</source>
          <target state="translated">解锁信号体。</target>
        </trans-unit>
        <trans-unit id="1cd4113e1e43e9853f32e740b4dd9283a784af37" translate="yes" xml:space="preserve">
          <source>Unlocks a given range in a file handle, To unlock an entire file use 0xFFFFFFFFFFFFFFFF for size and 0 for offset.</source>
          <target state="translated">解锁文件句柄中给定的范围,要解锁整个文件,大小用0xFFFFFFFFFFFF,偏移用0。</target>
        </trans-unit>
        <trans-unit id="902f2805ba20ce5f892f5f33360fcdd69a38eafb" translate="yes" xml:space="preserve">
          <source>Unmasked</source>
          <target state="translated">Unmasked</target>
        </trans-unit>
        <trans-unit id="cc6650b603c5c0ea0f873838ead84fd4b5b2f977" translate="yes" xml:space="preserve">
          <source>Unpack the elements of a vector into an unboxed tuple. #</source>
          <target state="translated">将向量的元素解包成一个未装箱的元组。#</target>
        </trans-unit>
        <trans-unit id="f45849052f775de0ca7ba2014ab45df8d98aa51a" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">解包构造函数字段仅应与&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id16&quot; id=&quot;id15&quot;&gt; [1]&lt;/a&gt;结合使用，以便向编译器公开展开内容，以便可以尽可能频繁地删除重新装箱。例如：</target>
        </trans-unit>
        <trans-unit id="f6f9c62709d24e188cc2de205e309b7f76b6e3bf" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt;[1]&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">解包构造函数字段仅应与&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id91&quot; id=&quot;id90&quot;&gt; [1]&lt;/a&gt;结合使用，以便向编译器公开展开内容，以便可以尽可能频繁地删除重新装箱。例如：</target>
        </trans-unit>
        <trans-unit id="186ac86a8a426917ea872e83fd56ac894b4b2cf2" translate="yes" xml:space="preserve">
          <source>Unpacking constructor fields should only be used in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt;1&lt;/a&gt;, in order to expose unfoldings to the compiler so the reboxing can be removed as often as possible. For example:</source>
          <target state="translated">拆包构造函数字段仅应与&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#id93&quot; id=&quot;id92&quot;&gt; 1&lt;/a&gt;结合使用，以便向编译器公开展开内容，以便可以尽可能经常地删除重新装箱。例如：</target>
        </trans-unit>
        <trans-unit id="1a9a082ee76ad3d4406b6dd0d0891c9553bc0d38" translate="yes" xml:space="preserve">
          <source>Unregister an active timeout.</source>
          <target state="translated">取消注册一个活动超时。</target>
        </trans-unit>
        <trans-unit id="e9504a1e28553feaf1224a031b0767c5e24517b0" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation can be useful when porting GHC to a new machine, since it reduces the prerequisite tools to &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; and nothing more, and furthermore the amount of platform-specific code that needs to be written in order to get unregisterised compilation going is usually fairly small.</source>
          <target state="translated">将GHC移植到新计算机时，未注册的编译很有用，因为它将先决条件工具减少到 &lt;code&gt;gcc&lt;/code&gt; ， &lt;code&gt;as&lt;/code&gt; 和 &lt;code&gt;ld&lt;/code&gt; ，仅此而已，此外，还需要编写平台特定的代码量才能获得未注册的编译。通常情况下规模很小。</target>
        </trans-unit>
        <trans-unit id="dbff9e9dc3cf5e9ee81b6a6d8db9918d35a26bed" translate="yes" xml:space="preserve">
          <source>Unregisterised compilation cannot be selected at compile-time; you have to build GHC with the appropriate options set. Consult the GHC Building Guide for details.</source>
          <target state="translated">在编译时不能选择未注册的编译;你必须使用适当的选项设置来构建GHC。详情请参考GHC构建指南。</target>
        </trans-unit>
        <trans-unit id="ca66248420ad1912a2a95b83e1e2c85f11c52168" translate="yes" xml:space="preserve">
          <source>Unsafe</source>
          <target state="translated">Unsafe</target>
        </trans-unit>
        <trans-unit id="4a2f98011fe504349513b1f09c5c052c2e96e8f4" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">不安全的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始，返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 。这省略了边界检查，这意味着程序员有义务确保以其他方式检查边界。</target>
        </trans-unit>
        <trans-unit id="0dd91a3653dbdf62b055e276b77befee135ac9fe" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">不安全的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始，返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 。这省略了边界检查，这意味着程序员有义务确保以其他方式检查边界。</target>
        </trans-unit>
        <trans-unit id="0e304ea4f61d467cda0009f4bab7e4e8c2092dcc" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; index (subscript) operator, starting from 0, returning a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; This omits the bounds check, which means there is an accompanying obligation on the programmer to ensure the bounds are checked in some other way.</source>
          <target state="translated">不安全的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 索引（下标）运算符，从0开始，返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 。这省略了边界检查，这意味着程序员有义务确保以其他方式检查边界。</target>
        </trans-unit>
        <trans-unit id="e55c2ba804dd339a0824a6746b1d478621fe6af8" translate="yes" xml:space="preserve">
          <source>Unsafe &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作不安全</target>
        </trans-unit>
        <trans-unit id="1804d52485698b7ab99bc85550d8574dc5e3223d" translate="yes" xml:space="preserve">
          <source>Unsafe API Only.</source>
          <target state="translated">只有不安全的API。</target>
        </trans-unit>
        <trans-unit id="929444982a786a3b3d6195dff840214a59813e0b" translate="yes" xml:space="preserve">
          <source>Unsafe API.</source>
          <target state="translated">不安全的API。</target>
        </trans-unit>
        <trans-unit id="1ad1dfd8c1d43724099c7d74cf10393e4b7e2fc9" translate="yes" xml:space="preserve">
          <source>Unsafe IO operations</source>
          <target state="translated">不安全的IO操作</target>
        </trans-unit>
        <trans-unit id="2e63719dae10937b05aa3be17e1f0f0af79e6f2e" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 之间的不安全转换。这是一个空操作，并且会无声地截断为8位Chars&amp;gt;'255'。它为ByteString构造提供了方便。</target>
        </trans-unit>
        <trans-unit id="051c814b3361ac5063677f84f8043980e0deb4d4" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 之间不安全的转换。这是无操作的，并且会无声地截断为8位Chars&amp;gt;'255'。它为ByteString构造提供了方便。</target>
        </trans-unit>
        <trans-unit id="8241dd25799379ccded94491ee5eb28c3782621d" translate="yes" xml:space="preserve">
          <source>Unsafe conversion between &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;. This is a no-op and silently truncates to 8 bits Chars &amp;gt; '255'. It is provided as convenience for ByteString construction.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 之间不安全的转换。这是无操作的，并且会无声地截断为8位Chars&amp;gt;'255'。它为ByteString构造提供了方便。</target>
        </trans-unit>
        <trans-unit id="b73be1b54132992ff041e34ae070dde1fb960bba" translate="yes" xml:space="preserve">
          <source>Unsafe conversion code</source>
          <target state="translated">不安全的转换代码</target>
        </trans-unit>
        <trans-unit id="163edb3c1def98928bd5f4858359e0e0ba9d4b21" translate="yes" xml:space="preserve">
          <source>Unsafe conversion for decimal digits.</source>
          <target state="translated">小数点位的不安全转换。</target>
        </trans-unit>
        <trans-unit id="8e1ff2612e7d854020e10b3d3b36d74fbd9cd65b" translate="yes" xml:space="preserve">
          <source>Unsafe functions</source>
          <target state="translated">不安全功能</target>
        </trans-unit>
        <trans-unit id="2ccc22d5296723bf78d52f0e5432593f86660059" translate="yes" xml:space="preserve">
          <source>Unsafe general combining function</source>
          <target state="translated">不安全的一般组合功能</target>
        </trans-unit>
        <trans-unit id="9864d3a94f4afb983bb1b979ff62b900e924fd12" translate="yes" xml:space="preserve">
          <source>Unsafe low-level operations</source>
          <target state="translated">不安全的低级操作</target>
        </trans-unit>
        <trans-unit id="4c84437a853ee0a263a2128827f73358c00f701b" translate="yes" xml:space="preserve">
          <source>Unsafe operations</source>
          <target state="translated">不安全操作</target>
        </trans-unit>
        <trans-unit id="d897903ce6ca852a862bb42ee05a2321d0b71d9e" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an Array.</source>
          <target state="translated">对一个数组中的元素进行不安全的、机器级的原子比较和交换。</target>
        </trans-unit>
        <trans-unit id="5f01ef3f9963b0e9162caa23773fd9c03da561ee" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array.</source>
          <target state="translated">对数组中的元素进行不安全的机器级原子比较和交换。</target>
        </trans-unit>
        <trans-unit id="da875dda0af919ad5cb1b82f3bb406408186e93d" translate="yes" xml:space="preserve">
          <source>Unsafe, machine-level atomic compare and swap on an element within an array. See the documentation of &lt;code&gt;casArray#&lt;/code&gt;.</source>
          <target state="translated">在数组中的元素上进行不安全的机器级原子比较和交换。请参阅 &lt;code&gt;casArray#&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="23605c5b9ae4700123f875a656e77bc71e5d4742" translate="yes" xml:space="preserve">
          <source>Unsafe.Coerce</source>
          <target state="translated">Unsafe.Coerce</target>
        </trans-unit>
        <trans-unit id="63d2c6f9ecdfa3c8e1f8b40433e3d3b53557b684" translate="yes" xml:space="preserve">
          <source>UnsafeShift</source>
          <target state="translated">UnsafeShift</target>
        </trans-unit>
        <trans-unit id="35f4214602b8699ce1216c3d3a7141e959379206" translate="yes" xml:space="preserve">
          <source>Unsafely convert an untyped code representation into a typed code representation.</source>
          <target state="translated">不安全地将一个非类型化的代码表示转换成类型化的代码表示。</target>
        </trans-unit>
        <trans-unit id="7390aa47d06ecf661a083cdb4c0a11930fc547be" translate="yes" xml:space="preserve">
          <source>Unsafely performs IO in the STM monad. Beware: this is a highly dangerous thing to do.</source>
          <target state="translated">在STM单体中不安全地执行IO。小心:这是一件非常危险的事情。</target>
        </trans-unit>
        <trans-unit id="aa0e468d81cdfb7797b46f3cfbe92285b8c0656b" translate="yes" xml:space="preserve">
          <source>UnsatisfiedConstraints</source>
          <target state="translated">UnsatisfiedConstraints</target>
        </trans-unit>
        <trans-unit id="b570c31cfc9e1525756bea752d3f5378fbd40609" translate="yes" xml:space="preserve">
          <source>Unsets certain options. See &lt;a href=&quot;#ghci-set&quot;&gt;The :set and :seti commands&lt;/a&gt; for a list of available options.</source>
          <target state="translated">取消设置某些选项。有关可用选项的列表，请参见&lt;a href=&quot;#ghci-set&quot;&gt;：set和：seti命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e5387ceda9c1b244093608d8f5bbf329289a392" translate="yes" xml:space="preserve">
          <source>Unsigned integer types.</source>
          <target state="translated">无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="15d0066b74b820208c4e67dd995d745f22ff8b1c" translate="yes" xml:space="preserve">
          <source>Unsigned integral types</source>
          <target state="translated">无符号积分类型</target>
        </trans-unit>
        <trans-unit id="0e683d0c1771359f194744b32634eb2816c4aba7" translate="yes" xml:space="preserve">
          <source>Unsound</source>
          <target state="translated">Unsound</target>
        </trans-unit>
        <trans-unit id="1afd000d072edf5c9a0c898690bcf0eb48c73be4" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Unsound Sound</source>
          <target state="translated">无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声。</target>
        </trans-unit>
        <trans-unit id="ad6bfcbce4213c08e4e664178dc9b7272c478b19" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound Sound</source>
          <target state="translated">无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声无声。</target>
        </trans-unit>
        <trans-unit id="d5fc19d20b078f2546ad7041f570431236521a3c" translate="yes" xml:space="preserve">
          <source>Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Unsound Sound</source>
          <target state="translated">不响 不响 不响 不响 不响 不响 不响 不响 不响 不响 不响 不响 不响 不响 声音</target>
        </trans-unit>
        <trans-unit id="e9b9c22eade05319854ce1cdcc767667ce930aec" translate="yes" xml:space="preserve">
          <source>Unstable snapshot releases are named &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt;. where &lt;code&gt;YYYYMMDD&lt;/code&gt; is the date of the sources from which the snapshot was built. For example, &lt;code&gt;6.7.20040225&lt;/code&gt; would be a snapshot of the HEAD before the creation of the &lt;code&gt;6.8&lt;/code&gt; branch.</source>
          <target state="translated">不稳定的快照发行版名为 &lt;code&gt;x.y.YYYYMMDD&lt;/code&gt; 。其中 &lt;code&gt;YYYYMMDD&lt;/code&gt; 是从其构建快照的源的日期。例如， &lt;code&gt;6.7.20040225&lt;/code&gt; 将是 &lt;code&gt;6.8&lt;/code&gt; 分支创建之前HEAD的快照。</target>
        </trans-unit>
        <trans-unit id="373738bf142634e8e0dbabff8a938293663b328c" translate="yes" xml:space="preserve">
          <source>Unstreaming</source>
          <target state="translated">Unstreaming</target>
        </trans-unit>
        <trans-unit id="0a4adcf14688819a74c324ec71080a0f50ecc9d1" translate="yes" xml:space="preserve">
          <source>UnsupportedOperation</source>
          <target state="translated">UnsupportedOperation</target>
        </trans-unit>
        <trans-unit id="b3573ff37e8ab6eec0c7b76d222c391fd7fc4b0d" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">解开状态monad计算的函数。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="dc1e17125720aceb3cede9a397f7f6e537e85241" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">解开状态monad计算的函数。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="33964687cef4a0572a11fc515789a6d8366599b4" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">解开状态monad计算的函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="e2057c9bc72225f9086a4e989d696e8995930bfa" translate="yes" xml:space="preserve">
          <source>Unwrap a state monad computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">解开状态monad计算的函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="ea52fd4b682160e248727bb92f76eca80e1a4842" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将编写器计算作为（结果，输出）对解包。（的逆 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96e4d767723784751cda063eb47114da43bc353b" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将编写器计算作为（结果，输出）对解包。（的逆 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ec5d83ec2dbad8875a7ab9032145f16380b2713f" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将编写器计算作为（结果，输出）对解包。（的逆 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eb2311da15c44fced6ec19017f698cf0da1fd04a" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将编写器计算作为（结果，输出）对解包。（的逆 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="61be95428c0873884060ddea20acadc6af8e44d8" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将编写器计算作为（结果，输出）对解包。（的逆 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#v:writer&quot;&gt;writer&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a7b78bffc2f09872eafde186a7e64a02f9ce1502" translate="yes" xml:space="preserve">
          <source>Unwrap a writer computation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">解包编写器计算。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#v:writerT&quot;&gt;writerT&lt;/a&gt;&lt;/code&gt; 的逆。）</target>
        </trans-unit>
        <trans-unit id="f2e39dac134e08f335a2b0e3e50b9b76c674574f" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWS计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="6fe0545b79d1cecd8b1a757466d50502955540d8" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWS计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="e90c4a46b0377f59faa429f1568928e49344a24a" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWS计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="a9e19ebd4bf17f3e5101a8ce003af6477d70170c" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWS计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-lazy#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="2644b7747be90f51535d6476569dc41fd793744d" translate="yes" xml:space="preserve">
          <source>Unwrap an RWS computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWS计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-strict#v:rws&quot;&gt;rws&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="60f474ea604d8eeb4374ae5afe4e53944954d231" translate="yes" xml:space="preserve">
          <source>Unwrap an RWST computation as a function. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将RWST计算解包为函数。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-rws-cps#v:rwsT&quot;&gt;rwsT&lt;/a&gt;&lt;/code&gt; 的反函数。）</target>
        </trans-unit>
        <trans-unit id="8f98e2ac9e2d748b70021352a635e8ef794ef05f" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation as a (result, output) pair. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">将累积计算解开为（结果，输出）对。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#v:accum&quot;&gt;accum&lt;/a&gt;&lt;/code&gt; 的倒数。）</target>
        </trans-unit>
        <trans-unit id="820c88e1c78e627590ad260b28a7707ed0558640" translate="yes" xml:space="preserve">
          <source>Unwrap an accumulation computation.</source>
          <target state="translated">解开积聚计算。</target>
        </trans-unit>
        <trans-unit id="2197473bde49255cd6618b199e4bc1a3de0d25e5" translate="yes" xml:space="preserve">
          <source>Unzip a sequence of pairs.</source>
          <target state="translated">解压一序列的对。</target>
        </trans-unit>
        <trans-unit id="d6c94435f616ce33704a63b12b13869b2055fe6c" translate="yes" xml:space="preserve">
          <source>Update a source position given a character. If the character is a newline ('\n') or carriage return ('\r') the line number is incremented by 1. If the character is a tab ('t') the column number is incremented to the nearest 8'th column, ie. &lt;code&gt;column + 8 -
 ((column-1) `mod` 8)&lt;/code&gt;. In all other cases, the column is incremented by 1.</source>
          <target state="translated">给定字符更新源位置。如果字符是换行符（'\ n'）或回车符（'\ r'），则行号增加1。如果字符是制表符（'t'），则列号增加到最接近的8'第列，即。 &lt;code&gt;column + 8 - ((column-1) `mod` 8)&lt;/code&gt; 。在所有其他情况下，该列将递增1。</target>
        </trans-unit>
        <trans-unit id="ccafe26aeb5d542f797ce6d7bdcc125f7297b7b0" translate="yes" xml:space="preserve">
          <source>Update an active timeout to fire in the given number of microseconds.</source>
          <target state="translated">更新活动超时,在给定的微秒数内发射。</target>
        </trans-unit>
        <trans-unit id="fe1ade2fe693811ed537bfc473a8a30ed8b8b5a3" translate="yes" xml:space="preserve">
          <source>UppercaseLetter</source>
          <target state="translated">UppercaseLetter</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="72a232f54a91a95c710346e72e4c91d976431058" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt;&quot; to compute the exact number of bytes written in advance for &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt;. In case of &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; will write and report zero bytes written, whereas &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; report one byte.</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt; &lt;em&gt;i&lt;/em&gt; 256#&lt;/code&gt; &amp;rdquo;来计算 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; /= 0&lt;/code&gt; 预先写入的确切字节数。在 &lt;code&gt;&lt;em&gt;i&lt;/em&gt; == 0&lt;/code&gt; 情况下， &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 将写入并报告写入的零字节，而 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 报告一个字节。</target>
        </trans-unit>
        <trans-unit id="25759557c641b7c83447c73b3afcbb7529fa6edc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt;&lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt;&lt;/a&gt; to select the program to use as the preprocessor. When invoked, the ⟨cmd⟩ pre-processor is given at least three arguments on its command-line: the first argument is the name of the original source file, the second is the name of the file holding the input, and the third is the name of the file where ⟨cmd⟩ should write its output to.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--pgmF%20%E2%9F%A8cmd%E2%9F%A9&quot;&gt; &lt;code&gt;-pgmF ⟨cmd⟩&lt;/code&gt; &lt;/a&gt;选择要用作预处理程序的程序。调用cmd预处理器时，会在命令行上为它提供至少三个参数：第一个参数是原始源文件的名称，第二个参数是保存输入的文件的名称，第三个参数是⟨cmd⟩应该将其输出写入到的文件的名称。</target>
        </trans-unit>
        <trans-unit id="0b4372542a118b48b81e477bf6a20ba6b09913d2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;或-ddump-rule-rewrites可以详细了解正在触发哪些规则。如果添加&lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt;则会得到更详细的清单。</target>
        </trans-unit>
        <trans-unit id="e56a9d5c91f6126fe3042d4f398b5871676f85bf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">使用&lt;a href=&quot;../debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt;查看&lt;em&gt;此模块&lt;/em&gt;中定义的规则。这包括由专业化过程生成的规则，但不包括从其他模块导入的规则。</target>
        </trans-unit>
        <trans-unit id="b11f0cc2df4b4a340cba4cb75322d6acc2d731d3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;查看正在触发的规则。如果添加&lt;a href=&quot;../debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt;则会得到更详细的清单。</target>
        </trans-unit>
        <trans-unit id="0a74fc84a08bb050a8c0f9d9847a761164de8655" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; to see in great detail what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a still more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;或-ddump-rule-rewrites可以详细了解正在触发哪些规则。如果添加&lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt;则会得到更详细的清单。</target>
        </trans-unit>
        <trans-unit id="31bfae0475a23191547214f74e349943e83d21e0" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt;&lt;code&gt;-ddump-rules&lt;/code&gt;&lt;/a&gt; to see the rules that are defined &lt;em&gt;in this module&lt;/em&gt;. This includes rules generated by the specialisation pass, but excludes rules imported from other modules.</source>
          <target state="translated">使用&lt;a href=&quot;debugging#ghc-flag--ddump-rules&quot;&gt; &lt;code&gt;-ddump-rules&lt;/code&gt; &lt;/a&gt;查看&lt;em&gt;此模块&lt;/em&gt;中定义的规则。这包括由专业化遍次生成的规则，但不包括从其他模块导入的规则。</target>
        </trans-unit>
        <trans-unit id="c1b3e1b5c3fa8b32869bb0120876b5d5da5603bc" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules are being fired. If you add &lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt;&lt;code&gt;-dppr-debug&lt;/code&gt;&lt;/a&gt; you get a more detailed listing.</source>
          <target state="translated">使用&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;查看正在触发的规则。如果添加&lt;a href=&quot;debugging#ghc-flag--dppr-debug&quot;&gt; &lt;code&gt;-dppr-debug&lt;/code&gt; ,&lt;/a&gt;则会得到更详细的清单。</target>
        </trans-unit>
        <trans-unit id="b771ec12132aa2e0c2b47e42c8669142adcb966c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, and avoid interruptible operations. In order to do this, we have to know which operations are interruptible. It is impossible to know for any given library function whether it might invoke an interruptible operation internally; so instead we give a list of guaranteed-not-to-be-interruptible operations below.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，并避免可中断的操作。为此，我们必须知道哪些操作是可中断的。对于任何给定的库函数，都不可能知道它是否可能在内部调用可中断的操作。因此，我们在下面提供了一个保证不会中断的操作列表。</target>
        </trans-unit>
        <trans-unit id="57ec9ad7fbe9ded694e2e346c6b70bfb493d9263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. This is generally not recommended, unless you can guarantee that any interruptible operations invoked during the scope of &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; can only ever block for a short time. Otherwise, &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; is a good way to make your program deadlock and be unresponsive to user interrupts.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 。通常不建议这样做，除非可以保证在 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 范围内调用的任何可中断操作只能阻塞很短的时间。否则， &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 是使程序死锁并且对用户中断无响应的好方法。</target>
        </trans-unit>
        <trans-unit id="9560818c30df433ea1d8321d618a619a497012b8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; to avoid this problem.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef-39-&quot;&gt;atomicModifyIORef'&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicWriteIORef&quot;&gt;atomicWriteIORef&lt;/a&gt;&lt;/code&gt; 可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="32aaf763496559c71074751f07941cee5db7b2fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:First&quot;&gt;First&lt;/a&gt; a)&lt;/code&gt; 从&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;获取 &lt;code&gt;&lt;a href=&quot;data-monoid#v:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="0965bb3313f69c3f81efc222ad17894b547d4f4f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; to get the behavior of &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt; (&lt;a href=&quot;data-semigroup#t:Last&quot;&gt;Last&lt;/a&gt; a)&lt;/code&gt; 从&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;获取 &lt;code&gt;&lt;a href=&quot;data-monoid#v:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 的行为</target>
        </trans-unit>
        <trans-unit id="6e13d276c8e0d029eae5978336ac0693463e26ce" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">将 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 用作任何调用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的函数 &lt;code&gt;foo&lt;/code&gt; 的编译指示。如果呼叫是内联的，则I / O可能会执行多次。</target>
        </trans-unit>
        <trans-unit id="25c751dae0926d2f7b6e06f66b29b041f9b1c1c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">将 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 用作任何调用 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的函数 &lt;code&gt;foo&lt;/code&gt; 的编译指示。如果呼叫是内联的，则I / O可能会执行多次。</target>
        </trans-unit>
        <trans-unit id="512fb5121eabf3e465918becf9c349f15bf52375" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; as a pragma on any function &lt;code&gt;foo&lt;/code&gt; that calls &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. If the call is inlined, the I/O may be performed more than once.</source>
          <target state="translated">将 &lt;code&gt;{-# NOINLINE foo #-}&lt;/code&gt; 用作任何调用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的函数 &lt;code&gt;foo&lt;/code&gt; 的编译指示。如果呼叫是内联的，则I / O可能会执行多次。</target>
        </trans-unit>
        <trans-unit id="8d8958d144abe494ec2ceac7996d592080bc32ae" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;strip&lt;/strong&gt; on your executables.</source>
          <target state="translated">在可执行文件上使用&lt;strong&gt;strip&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="aaebd479a4ffe804021ed586cb29ed1e63a61ba4" translate="yes" xml:space="preserve">
          <source>Use GHC&amp;rsquo;s &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; rather than compiling via LLVM. &lt;code&gt;-fasm&lt;/code&gt; is the default.</source>
          <target state="translated">使用GHC的&lt;a href=&quot;codegens#native-code-gen&quot;&gt;本机代码生成器，&lt;/a&gt;而不是通过LLVM进行编译。 &lt;code&gt;-fasm&lt;/code&gt; 是默认设置。</target>
        </trans-unit>
        <trans-unit id="37bef6dae0e3c404226f866a87bb48ee5a6ad08b" translate="yes" xml:space="preserve">
          <source>Use GHCi&amp;rsquo;s extended default rules in a normal module.</source>
          <target state="translated">在普通模块中使用GHCi的扩展默认规则。</target>
        </trans-unit>
        <trans-unit id="559c9b9fd04f1e3041713b6f2cf9e35cff9d879f" translate="yes" xml:space="preserve">
          <source>Use GHCi's extended default rules in a normal module.</source>
          <target state="translated">在普通模块中使用GHCi的扩展默认规则。</target>
        </trans-unit>
        <trans-unit id="04d5949406943eaf29d4718abd7e8752c49273b7" translate="yes" xml:space="preserve">
          <source>Use STM. Since a transaction is always either completely executed or not at all, transactions are a good way to maintain invariants over state in the presence of asynchronous (and indeed synchronous) exceptions.</source>
          <target state="translated">使用STM。由于事务总是要么完全执行,要么根本不执行,所以事务是在异步(实际上是同步)异常的情况下保持状态不变的好方法。</target>
        </trans-unit>
        <trans-unit id="f35f11885972458dd5435b0c60945844fa1cf70e" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:ForeignHValue&quot;&gt;ForeignHValue&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="338f9df27e568de9a873343298f1ee5a259c53a9" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; evidence.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 作为可 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 证据。</target>
        </trans-unit>
        <trans-unit id="746a26a0ae875d24d6db1c324d9b7183d086ea3c" translate="yes" xml:space="preserve">
          <source>Use a POSIX I/O Sub-System</source>
          <target state="translated">使用POSIX I/O子系统</target>
        </trans-unit>
        <trans-unit id="eafe0f628bdb243fb3b0edbccb0c80d5e94c239c" translate="yes" xml:space="preserve">
          <source>Use a bigger heap!</source>
          <target state="translated">使用更大的堆!</target>
        </trans-unit>
        <trans-unit id="48d50a26d4092a032e5ec1812697e2ae5f2493e9" translate="yes" xml:space="preserve">
          <source>Use a compacting algorithm for collecting the oldest generation. By default, the oldest generation is collected using a copying algorithm; this option causes it to be compacted in-place instead. The compaction algorithm is slower than the copying algorithm, but the savings in memory use can be considerable.</source>
          <target state="translated">使用压缩算法来收集最老的一代。默认情况下,最老的一代是使用复制算法收集的;这个选项会使其就地压缩。压实算法比复制算法慢,但可以节省大量的内存使用。</target>
        </trans-unit>
        <trans-unit id="939b950f9853220f1f4457399d66662e4cd19c03" translate="yes" xml:space="preserve">
          <source>Use a slower but better algorithm for ApplicativeDo</source>
          <target state="translated">使用更慢但更好的算法来应用Do</target>
        </trans-unit>
        <trans-unit id="77ea136d96ab55918616e2de414adfe26e040bbf" translate="yes" xml:space="preserve">
          <source>Use a small box for the title.</source>
          <target state="translated">用一个小方框做标题。</target>
        </trans-unit>
        <trans-unit id="b52135628f58b3a037f43c82033c20d263ba93a5" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors.</source>
          <target state="translated">使用字典选择器的特殊需求变压器。</target>
        </trans-unit>
        <trans-unit id="3c6a33f2bd018cb8aaf8733cbb07dec137c9b267" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Always enabled by default.</source>
          <target state="translated">为字典选择器使用特殊的需求变压器。默认情况下总是启用。</target>
        </trans-unit>
        <trans-unit id="b25b503bf1e131032b9194d35870945071ac8245" translate="yes" xml:space="preserve">
          <source>Use a special demand transformer for dictionary selectors. Behaviour is unconditionally enabled starting with 9.2</source>
          <target state="translated">对字典选择器使用特殊的需求变压器。从9.2开始无条件启用该行为。</target>
        </trans-unit>
        <trans-unit id="9c0adf8c16cf722d99aad385f8f59801bd334547" translate="yes" xml:space="preserve">
          <source>Use an explicit type signature on the record expression, as in:</source>
          <target state="translated">在记录表达式上使用显式类型签名,如:。</target>
        </trans-unit>
        <trans-unit id="292fc35c66c20d657884010ef14bdc8af40861f8" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasAddrAddr# location expected desired s</source>
          <target state="translated">用作：s-&amp;gt; atomicCasAddrAddr＃位置期望的期望s</target>
        </trans-unit>
        <trans-unit id="ff515038361d9bf7c3d5fdf1f946a7c3b1673ee7" translate="yes" xml:space="preserve">
          <source>Use as: s -&amp;gt; atomicCasWordAddr# location expected desired s</source>
          <target state="translated">用作：s-&amp;gt; atomicCasWordAddr＃所需的期望位置s</target>
        </trans-unit>
        <trans-unit id="9253a45a0ac7d8f0b34981a4a8e896e300094aae" translate="yes" xml:space="preserve">
          <source>Use colors in error messages</source>
          <target state="translated">在错误信息中使用颜色</target>
        </trans-unit>
        <trans-unit id="f17361b13fb3a2074cdb146eaa615b5c6cb69427" translate="yes" xml:space="preserve">
          <source>Use current directory for the GHCi command history file &lt;code&gt;.ghci-history&lt;/code&gt;.</source>
          <target state="translated">将当前目录用于GHCi命令历史记录文件 &lt;code&gt;.ghci-history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60cf6b84707199f4795abe12d1ae35ef2d41e1d1" translate="yes" xml:space="preserve">
          <source>Use decimal notation for values between &lt;code&gt;0.1&lt;/code&gt; and &lt;code&gt;9,999,999&lt;/code&gt;, and scientific notation otherwise.</source>
          <target state="translated">对于介于 &lt;code&gt;0.1&lt;/code&gt; 和 &lt;code&gt;9,999,999&lt;/code&gt; 之间的值，请使用十进制表示法；否则，请使用科学计数法。</target>
        </trans-unit>
        <trans-unit id="8a0a45ab79448b01d6ee5ed7e5abdb75681dee62" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用文件样式的交互，从给定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中读取输入。</target>
        </trans-unit>
        <trans-unit id="babd2ff76089a3d1f8aa9f2a697eb17aef342e31" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用文件样式的交互，从给定的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中读取输入。</target>
        </trans-unit>
        <trans-unit id="a9390e87846d6a93528abe67fa5bb72b908f7c7f" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用文件样式的交互，从给定的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中读取输入。</target>
        </trans-unit>
        <trans-unit id="316508bd71c0c5222c8f5a0b92e83093f7ef8d81" translate="yes" xml:space="preserve">
          <source>Use file-style interaction, reading input from the given file.</source>
          <target state="translated">使用文件式交互,从给定文件中读取输入。</target>
        </trans-unit>
        <trans-unit id="3e83731aa81291c66034e6c2f8713ae82f0abfb1" translate="yes" xml:space="preserve">
          <source>Use foreign export declarations to export the Haskell functions you want to call from the outside. For example:</source>
          <target state="translated">使用对外导出声明来导出你想从外部调用的Haskell函数。例如</target>
        </trans-unit>
        <trans-unit id="d25d6807c73eb047cf28c6f6c34e364514a196a6" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将其用作资源限制。请参阅 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc73e0426aece56e09a684e49c4bbc54078eb05" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将其用作资源限制。请参阅 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59ab30f8bb5418fd366c74cb8d2d5172978bb6f9" translate="yes" xml:space="preserve">
          <source>Use it as a resource limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将其用作资源限制。请参阅 &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b82fc19a9b21a0e738f7458d40e3287caf342b3" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 将其用作简单的分析机制。</target>
        </trans-unit>
        <trans-unit id="6d18f84af3a8332dfa6f2cefc28870581d3c1af0" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 将其用作简单的分析机制。</target>
        </trans-unit>
        <trans-unit id="cba5ffe9e5bbc4089ab256ab21a6e1f61feb47e5" translate="yes" xml:space="preserve">
          <source>Use it as a simple profiling mechanism, with &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;system-mem#v:getAllocationCounter&quot;&gt;getAllocationCounter&lt;/a&gt;&lt;/code&gt; 将其用作简单的分析机制。</target>
        </trans-unit>
        <trans-unit id="cbe36f44a27a0189506ed9bcc5455131593cc6b7" translate="yes" xml:space="preserve">
          <source>Use load-balancing in the parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ disables load-balancing entirely.</source>
          <target state="translated">在并联 GC 中使用负载平衡,在 ⟨gen⟩和更高版本中。省略了⟨gen⟩,则完全不使用负载平衡。</target>
        </trans-unit>
        <trans-unit id="b2fcd08dc2fdbb61836f1f89ef8e9fbe1cfdf541" translate="yes" xml:space="preserve">
          <source>Use more memory:</source>
          <target state="translated">使用更多的内存。</target>
        </trans-unit>
        <trans-unit id="6eaea9f8fe75d7534bd9ba845082e28f6577e255" translate="yes" xml:space="preserve">
          <source>Use of this type is discouraged. Note the following equivalence:</source>
          <target state="translated">不鼓励使用这种类型。请注意以下等价物:</target>
        </trans-unit>
        <trans-unit id="4eb452a5c138ef6d6999a87a31eb6eb9a345911f" translate="yes" xml:space="preserve">
          <source>Use parallel GC in generation ⟨gen⟩ and higher. Omitting ⟨gen⟩ turns off the parallel GC completely, reverting to sequential GC.</source>
          <target state="translated">在⟨gen⟩及以上的世代中使用并行GC。省略⟨gen⟩完全关闭并行GC,恢复到顺序GC。</target>
        </trans-unit>
        <trans-unit id="1de741d6efbec754e80e7e93becb988786a18010" translate="yes" xml:space="preserve">
          <source>Use platform native Sub-System. For unix OSes this is the same as IoPOSIX, but on Windows this means use the Windows native APIs for I/O, including IOCP and RIO.</source>
          <target state="translated">使用平台本地子系统。对于unix操作系统来说,这和IoPOSIX是一样的,但在Windows上,这意味着使用Windows本地API来进行I/O,包括IOCP和RIO。</target>
        </trans-unit>
        <trans-unit id="56b1d864443428aa9218cc82070c092c301dc501" translate="yes" xml:space="preserve">
          <source>Use posix setgid to set child process's group id; does nothing on other platforms.</source>
          <target state="translated">使用posix setgid设置子进程的组ID;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="39925d946ab1c9c0725df1e4920b81ccd158d12d" translate="yes" xml:space="preserve">
          <source>Use posix setsid to start the new process in a new session; does nothing on other platforms.</source>
          <target state="translated">使用 posix setsid 在新的会话中启动新进程;在其他平台上不做任何事情。</target>
        </trans-unit>
        <trans-unit id="cf6e7dcdcd547e2f6790215eda406e40ab63d1d5" translate="yes" xml:space="preserve">
          <source>Use posix setuid to set child process's user id; does nothing on other platforms.</source>
          <target state="translated">使用posix setuid设置子进程的用户ID;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="14976703db8bc962fb6e74a997ae61f1d13d892f" translate="yes" xml:space="preserve">
          <source>Use previous parameters. By default, the PostScript graph is automatically scaled both horizontally and vertically so that it fills the page. However, when preparing a series of graphs for use in a presentation, it is often useful to draw a new graph using the same scale, shading and ordering as a previous one. The &lt;code&gt;-p&lt;/code&gt; flag causes the graph to be drawn using the parameters determined by a previous run of &lt;code&gt;hp2ps&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;. These are extracted from &lt;code&gt;file@.aux&lt;/code&gt;.</source>
          <target state="translated">使用以前的参数。默认情况下，PostScript图形会自动在水平和垂直方向上缩放，以使其充满页面。但是，在准备用于演示的一系列图形时，使用与上一个图形相同的比例，阴影和顺序绘制新图形通常会很有用。的 &lt;code&gt;-p&lt;/code&gt; 标志导致使用通过的先前运行中确定的参数来描绘的曲线图 &lt;code&gt;hp2ps&lt;/code&gt; 上 &lt;code&gt;file&lt;/code&gt; 。这些是从 &lt;code&gt;file@.aux&lt;/code&gt; 中提取的。</target>
        </trans-unit>
        <trans-unit id="99aacaeb246dcd6fd6f08321e48778f7a8f45355" translate="yes" xml:space="preserve">
          <source>Use static Haskell libraries</source>
          <target state="translated">使用静态Haskell库</target>
        </trans-unit>
        <trans-unit id="92cedb657ea08377a2d0891b88a0e7c40ed55ee1" translate="yes" xml:space="preserve">
          <source>Use strictness annotations:</source>
          <target state="translated">使用严格性注释。</target>
        </trans-unit>
        <trans-unit id="fa085a6df8595e3f12af85a3f58c8a624eb4c73a" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">即使 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 不是终端，也应尽可能使用终端风格的交互。</target>
        </trans-unit>
        <trans-unit id="6c701d48b2ddc2ad9f38319eaef995257ab48d8b" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">即使 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 不是终端，也应尽可能使用终端风格的交互。</target>
        </trans-unit>
        <trans-unit id="702fcd88a46378df6ea71ccb1190fa14cbe9bac6" translate="yes" xml:space="preserve">
          <source>Use terminal-style interaction whenever possible, even if &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; and/or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; are not terminals.</source>
          <target state="translated">即使 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 和/或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 不是终端，也应尽可能使用终端风格的交互。</target>
        </trans-unit>
        <trans-unit id="e3e92ec8a74dacde2eaa4a5a97ab32c527f59c0d" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt;</source>
          <target state="translated">使用本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3b4f48cb9a708494d358733ee6311bb2890a74d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;MonadFail.fail&lt;/code&gt; instead of the legacy &lt;code&gt;Monad.fail&lt;/code&gt; function when desugaring refutable patterns in &lt;code&gt;do&lt;/code&gt; blocks.</source>
          <target state="translated">当在 &lt;code&gt;do&lt;/code&gt; 块中取消可重复使用的模式时，请使用 &lt;code&gt;MonadFail.fail&lt;/code&gt; 而不是旧版 &lt;code&gt;Monad.fail&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="6d4d3a4fd4f7e397d42bb7af957939ab364ef83c" translate="yes" xml:space="preserve">
          <source>Use the C code generator. Only supposed in unregisterised GHC builds.</source>
          <target state="translated">使用C代码生成器。只有在未注册的GHC构建中才应该使用。</target>
        </trans-unit>
        <trans-unit id="3b6c94c81606492d87dce6da844389bd6d123781" translate="yes" xml:space="preserve">
          <source>Use the Haskell 2010 language variant.</source>
          <target state="translated">使用Haskell 2010语言变体。</target>
        </trans-unit>
        <trans-unit id="66e695e59e51ae41d59efa1f0452144c08e51e4d" translate="yes" xml:space="preserve">
          <source>Use the Haskell 98 language variant.</source>
          <target state="translated">使用Haskell 98语言变体。</target>
        </trans-unit>
        <trans-unit id="0627207e13b5374967883369ea83fa36b1b2d8d1" translate="yes" xml:space="preserve">
          <source>Use the OS&amp;rsquo;s affinity facilities to try to pin OS threads to CPU cores.</source>
          <target state="translated">使用操作系统的关联性功能尝试将操作系统线程固定到CPU内核。</target>
        </trans-unit>
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">使用编译器标志 &lt;code&gt;-fno-cse&lt;/code&gt; 可以防止在模块上执行常见的子表达式消除，这可能会使原本应该分开的两个副作用结合在一起。一个很好的示例是使用多个全局变量（例如下面的示例中的 &lt;code&gt;test&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7fe585682db3ba3c0e51a716fd4585abd8b10372" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">使用调试标志&lt;a href=&quot;../debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;可以查看触发了哪些规则。如果您需要更多信息，则&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;将向您显示每个单独的规则触发，而&lt;a href=&quot;../debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;也将显示重写前后的代码。</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">使用调试标志&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;可以查看触发了哪些规则。如果需要更多信息，则&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;显示每个单独的规则触发，&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;还显示重写前后的代码。</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">使用调试运行时</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用图形着色寄存器分配器在本机代码生成器中分配寄存器。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">在本机代码生成器中使用迭代凝聚图着色寄存器分配器。</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">在输入和输出上使用本机换行表示。</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">使用新的基于cfg的区块布局算法。</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">在⟨file⟩或 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; 软件包环境。如果设置为 &lt;code&gt;-&lt;/code&gt; 不读取软件包环境。</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">使用私用转义机制,试图让非法序列被绕过。</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">使用可执行程序上的运行时标志&lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;可以查看使用 &lt;code&gt;-with-rtsopts&lt;/code&gt; 设置的选项。</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">使用指定的包环境。</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">使用附带的手柄</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">使用线程运行时</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">使用被推送到记录更新中的类型,如下所示。</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">创建进程时使用windows的CREATE_NEW_CONSOLE标志;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">创建进程时使用windows的DETACHED_PROCESS标志;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;仅&lt;/em&gt;在极少数情况下由于使用绑定线程而实际导致性能下降的情况下，&lt;em&gt;才&lt;/em&gt;使用此功能。不需要绑定主线程并&lt;em&gt;大量&lt;/em&gt;使用并发性的程序（例如Web服务器），可能要将其 &lt;code&gt;main&lt;/code&gt; 操作包装在 &lt;code&gt;runInUnboundThread&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">使用该函数是为了实现基于文本格式(如JSON或HTML)的高效编码器。</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此函数从较小的（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 创建 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，或者如果您需要确保 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 不与 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 生成的块共享，则使用此函数。</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此函数从较小的（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 创建 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，或者如果您需要确保 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 不与 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 生成的块共享，则使用此函数。</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">使用此策略来生成惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,其块在生成后立即被丢弃。例如，如果仅生成它们以将它们写入网络套接字。</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">使用此策略来生成懒惰的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,其块很可能在一个垃圾回收中仍然存在。此策略会修剪填充不足一半的缓冲区，以避免溢出过多的内存。</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">使用未装箱的类型(GHC扩展)。</target>
        </trans-unit>
        <trans-unit id="b123b85d967a1500e8666eb4e128ba145310fa7f" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">打印表达式，类型和种类时，请使用unicode语法。另请参见&lt;a href=&quot;exts/unicode_syntax#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">打印表达式，类型和种类时，请使用unicode语法。另请参见&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">打印表达式，类型和种类时，请使用unicode语法。另请参见&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc21fce3863bcaec7184d0faa94b76871818b8de" translate="yes" xml:space="preserve">
          <source>Use whitespace to determine whether the minus sign stands for negation or subtraction.</source>
          <target state="translated">用空格来确定减号是代表否定还是减法。</target>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">使用⟨cmd⟩作为C编译器。</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">使用⟨cmd⟩作为C编译器。</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">将⟨cmd⟩用作C预处理器（仅与 &lt;code&gt;-cpp&lt;/code&gt; 配合使用）</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为C预处理程序（仅与 &lt;code&gt;-cpp&lt;/code&gt; 配合使用）。</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">使用⟨cmd⟩作为DLL生成器。</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">使用⟨cmd⟩作为DLL生成器。</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">使用⟨cmd⟩作为LLVM编译器。</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">使用⟨cmd⟩作为LLVM编译器。</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">使用⟨cmd⟩作为LLVM优化器。</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">使用⟨cmd⟩作为LLVM优化器。</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">使用⟨cmd⟩作为汇编器。</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">使用⟨cmd⟩作为汇编器。</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool的命令（仅适用于&lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool的命令（仅用于 &lt;code&gt;-staticlib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">使用⟨cmd⟩作为外部解释器命令（请参阅&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程中运行解释器&lt;/a&gt;）。默认值： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 如果&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;启用， &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 如果&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;启用或 &lt;code&gt;ghc-iserv&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">使用⟨cmd⟩作为外部解释器命令（请参阅：&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程中运行解释器&lt;/a&gt;）。默认值： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 如果 &lt;code&gt;-prof&lt;/code&gt; 启用， &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 如果 &lt;code&gt;-dynamic&lt;/code&gt; 启用或 &lt;code&gt;ghc-iserv&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">使用⟨cmd⟩作为外部解释器命令。</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool命令（仅当使用&lt;a href=&quot;#ghc-flag--staticlib&quot;&gt; &lt;code&gt;-staticlib&lt;/code&gt; 时&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool命令（仅当使用 &lt;code&gt;-staticlib&lt;/code&gt; 时）。</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">使用⟨cmd⟩作为链接器。</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="translated">合并对象文件时使用⟨cmd⟩作为链接器。</target>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="translated">当合并对象文件时,使用⟨cmd⟩作为链接器(例如,当生成连接对象以加载到GHCi时)。</target>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">使用⟨cmd⟩作为链接器。</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">使用⟨cmd⟩作为识字前处理程序。</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">使用⟨cmd⟩作为识字前处理程序。</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为预处理器（仅适用于&lt;a href=&quot;#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="translated">使用⟨cmd⟩作为预处理器（仅适用于&lt;a href=&quot;phases#ghc-flag--F&quot;&gt; &lt;code&gt;-F&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">使用⟨cmd⟩作为预处理器（仅适用于 &lt;code&gt;-F&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">使用&amp;ldquo; cmd&amp;rdquo;作为预处理器（仅用于 &lt;code&gt;-F&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">使用⟨cmd⟩作为Windows上嵌入清单的程序。</target>
        </trans-unit>
        <trans-unit id="06f092be8a595002e75e8cde42011af9133ed460" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath&lt;/code&gt; into mach-o dylibs on macOS</source>
          <target state="translated">使用⟨cmd⟩作为程序将运行 &lt;code&gt;runpath&lt;/code&gt; 注入到macOS上的mach-o dylib中</target>
        </trans-unit>
        <trans-unit id="2aa3b14fe034bb785dbc95f7e2f098debf4b70be" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inject &lt;code&gt;runpath``s into mach-o dynamic
libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; call.</source>
          <target state="translated">使用``cmd''作为程序将运行 &lt;code&gt;runpath``s into mach-o dynamic libraries and executables.&amp;nbsp; As detected by the ``otool&lt;/code&gt; 注入到mach-o动态库和可执行文件中。由``otool调用检测到。</target>
        </trans-unit>
        <trans-unit id="e75123a572cd455ff35b1a2ec2ba9af921d11a57" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dylibs on macOS</source>
          <target state="translated">在macOS上使用⟨cmd⟩作为检查mach-o dylibs的程序。</target>
        </trans-unit>
        <trans-unit id="5b79c5d224e16858a476d6f862fdbc459ee62882" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to inspect mach-o dynamic libraries and executables to read the dynamic library dependencies. We will compute the necessary &lt;code&gt;runpath``s to embed for the dependencies based on the
result of the ``otool&lt;/code&gt; call.</source>
          <target state="translated">使用&amp;ldquo; cmd&amp;rdquo;作为程序来检查mach-o动态库和可执行文件以读取动态库依赖项。我们将 &lt;code&gt;runpath``s to embed for the dependencies based on the result of the ``otool&lt;/code&gt; 调用的结果计算必要的运行路径以嵌入依赖项。</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">使用&amp;ldquo; cmd&amp;rdquo;作为用于在Windows上嵌入清单的程序。通常，这是GHC安装随附的程序 &lt;code&gt;windres&lt;/code&gt; 。见 &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 的&lt;a href=&quot;#options-linker&quot;&gt;选项链接的影响&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">使用⟨cmd⟩作为分割器。</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">用⟨cmd⟩作为分割器。</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">使用⟨file⟩作为makefile。</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">使用⟨file⟩作为生成文件，而不是 &lt;code&gt;makefile&lt;/code&gt; 或 &lt;code&gt;Makefile&lt;/code&gt; 。如果⟨file⟩不存在，则 &lt;code&gt;mkdependHS&lt;/code&gt; 创建它。我们经常使用 &lt;code&gt;-dep-makefile .depend&lt;/code&gt; 放于依赖 &lt;code&gt;.depend&lt;/code&gt; 然后 &lt;code&gt;include&lt;/code&gt; 文件 &lt;code&gt;.depend&lt;/code&gt; 到 &lt;code&gt;Makefile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">运行程序时使用⟨x⟩同时线程。</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">由 GHCi 用于为一组交互式绑定添加一个 SPT 条目。</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">用于'x等,但程序员不能使用。</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">用于编译器生成的错误信息;编码可节省字符串垃圾的字节。</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">用于标记参数的出现。</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">用来表示超载和非超载的字数。我们目前还没有一个很好的方法来表示非过载的字元。也许这并不重要?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n,n'..]&lt;/code&gt; 与 &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 一个可能的实现是 &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; ， &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; ， &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 和 &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 例如：</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n,n'..m]&lt;/code&gt; 与 &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; ，一种可能的实现是 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; ， &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; ， &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 和 &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 例如：</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n..]&lt;/code&gt; 与 &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; ，一个可能的实现是 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n..m]&lt;/code&gt; 与 &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; ，一个可能的实现是 &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">曾经表示一个Fast String片段,但现在已经废弃,与Str构造函数相同。</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">用于与结合使用的有用组合子 &lt;code&gt;xxxBy&lt;/code&gt; 家族的从功能&lt;a href=&quot;data-list&quot;&gt;Data.List模块&lt;/a&gt;，例如：</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">有用的错误处理功能</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">对于定义NF = WHNF的类型定义 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">对于需要垃圾收集的长期分配很有用。如果您打算将指向内存中存储的数据外资结构，那么 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;一个很好的选择，但是。</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">当分配打算在给定的 &lt;code&gt;IO&lt;/code&gt; 计算范围内使用时，对于短期分配很有用。在往来于FFI功能的数据中编组数据时，通常使用这种分配。</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">有用的是:</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">有用的函数和组合器。</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">有用的功能。</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">有用的辅助功能</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">编写实例的有用助手</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">由不变量产生的有用属性。</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">用户环境</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">用户互动功能</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">用户名称</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">用户偏好</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">用户定义的运算符标有香蕉括号，而不是新的 &lt;code&gt;form&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">用户自定义类型错误</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">用户提供的比较（替换 &lt;code&gt;Ord&lt;/code&gt; 上下文）</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">用户提供的相等性（替换 &lt;code&gt;Eq&lt;/code&gt; 上下文）</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">用户可以使用GHC内部用于计算指纹的相同功能。所述&lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt;模块提供有用的功能，用于构建指纹。例如，将 &lt;code&gt;fingerprintFingerprints&lt;/code&gt; 和 &lt;code&gt;fingerprintString&lt;/code&gt; 结合在一起，可以轻松地对插件的参数进行幼稚的指纹识别。</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">用户可以使用 &lt;code&gt;~/.haskeline&lt;/code&gt; 文件来自定义界面；有关更多信息，请参见&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">用户可以定义自己的 &lt;code&gt;HasField&lt;/code&gt; 实例，前提是它们与内置的约束求解行为不冲突。这允许为没有虚拟字段的数据类型定义&amp;ldquo;虚拟&amp;rdquo;记录字段。</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">用户可以提供 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 的自定义实例，这些实例应符合以下规则：</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">这个功能的用户应编译 &lt;code&gt;-threaded&lt;/code&gt; 如果他们想其他的Haskell线程来保持，而在readProcess的结果等待运行。</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">用户很可能想要 &lt;code&gt;~&lt;/code&gt; ，但如果GHC先验地无法知道这两种类型的兴趣相同，则 &lt;code&gt;~~&lt;/code&gt; 可用。有证据表明 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; 告诉GHC都认为 &lt;code&gt;k1&lt;/code&gt; 和 &lt;code&gt;k2&lt;/code&gt; 是相同的，并且 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是相同的。</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">字段的使用始终是明确的，因为它们提到了构造函数，包括构造和模式匹配，可以自由使用重复的字段名称。例如，以下内容是允许的（就像&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="0265064a73ec5c4a274e96b0ad1d58643baccfe3" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">字段的使用始终是明确的，因为它们提到了构造函数，包括构造和模式匹配，可以自由使用重复的字段名称。例如，允许以下内容（与&lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="translated">对所有世代使用世代复制的垃圾收集器。这是默认的。</target>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">使用8位字符</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#newtype-deriving&quot;&gt;newtype的Generalized派生实例&lt;/a&gt;），程序员可以获取类的现有实例，并将它们&amp;ldquo;提升&amp;rdquo;到该类的实例中以获取新类型。但是，这并不总是安全的。例如，考虑以下内容：</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每当&lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;或--show-iface⟨fileG打印时，使用&lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt; &lt;code&gt;-fprint-axiom-incomps&lt;/code&gt; 会&lt;/a&gt;告诉GHC显示封闭型族方程之间的不兼容性。</target>
        </trans-unit>
        <trans-unit id="ec190b27f84b5eb38a386fb9b591e8f3127b6c54" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 会&lt;/a&gt;告诉GHC在打印时区分其相等关系。例如， &lt;code&gt;~&lt;/code&gt; 是齐次提升的等式（其参数的种类相同），而 &lt;code&gt;~~&lt;/code&gt; 是异构提升的等式（其参数的种类可能不同），而 &lt;code&gt;~#&lt;/code&gt; 是异构的未提升的等式（GHC的内部相等关系）。解算器。通常，用户无需担心这里的细微差别。 &lt;code&gt;~&lt;/code&gt; 可能就是您想要的。没有&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;，GHC将所有这些都打印为 &lt;code&gt;~&lt;/code&gt; 。另请参阅&lt;a href=&quot;exts/equality_constraints#equality-constraints&quot;&gt;平等约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 会&lt;/a&gt;告诉GHC在打印时区分其相等关系。例如， &lt;code&gt;~&lt;/code&gt; 是齐次提升的等式（其参数的种类相同），而 &lt;code&gt;~~&lt;/code&gt; 是异构提升的等式（其参数的种类可能不同），而 &lt;code&gt;~#&lt;/code&gt; 是异构的未提升的等式，GHC的内部相等关系解算器。通常，用户无需担心此处的细微差别。 &lt;code&gt;~&lt;/code&gt; 可能就是您想要的。没有&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;，GHC将所有这些都打印为 &lt;code&gt;~&lt;/code&gt; 。另请参阅&lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;平等约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt;可以使GHC打印强制类型。当试图证明不同类型的类型之间的相等性时，GHC使用类型级别的强制。用户很少需要看到这些内容，因为它们本来就是内部的。</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;使得GHC打印明确 &lt;code&gt;forall&lt;/code&gt; 在一个类型的顶层量化; 通常这是被抑制的。例如，在GHCi中：</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;可以使GHC打印类型的实参类型，这些类型通常被抑制。当您使用种类多态性时，这可能很重要。例如：</target>
        </trans-unit>
        <trans-unit id="b89399a162079f667d1fdc83d81ed74335bde10d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">使用&lt;a href=&quot;../ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;可能会导致一个结论，即 &lt;code&gt;myLength1&lt;/code&gt; 的类型签名中的所有类型变量都不可用于类型应用程序。但是，这不是真的！如果您想要有关可见类型应用程序属性的最准确信息，请确保使用&lt;a href=&quot;../ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">使用&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;可能会导致一个结论，即 &lt;code&gt;myLength1&lt;/code&gt; 的类型签名中的所有类型变量都不可用于类型应用程序。但是，这不是真的！如果您想要有关可见类型应用程序属性的最准确信息，请确保使用&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">使用&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;可能会导致一个结论，即 &lt;code&gt;myLength1&lt;/code&gt; 的类型签名中的所有类型变量都不可用于类型应用程序。但是，这不是真的！如果您想要有关可见类型应用程序属性的最准确信息，请确保使用&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6570d089faca67f533b154812bbbc95cc61616d4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">使用&lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;newtype的Generalized派生实例&lt;/a&gt;），程序员可以获取类的现有实例，并将它们&amp;ldquo;提升&amp;rdquo;到该类的实例中以获得新类型。但是，这并不总是安全的。例如，考虑以下内容：</target>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">与&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;结合使用&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;确实是一个好主意，因为否则，多余的打包和解包将不会被优化。实际上，即使&lt;em&gt;使用&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;可能也会降低性能，但这是不可能的（如果您遇到这种情况，请告诉我们）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a922b4d719b40ab46b07c97a191b43983233d5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 对Haskell运行时系统的调度行为没有任何影响。常见的误解是，在进行外部调用时，需要使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 来避免阻塞所有Haskell线程。事实并非如此。为了在不阻塞所有Haskell线程（使用GHC）的情况下进行外部调用，只需在链接程序时使用 &lt;code&gt;-threaded&lt;/code&gt; 选项，并确保未将外部导入标记为 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器不排除可能尝试嵌套事务的程序，这意味着程序员必须特别小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="96c07fa0636126bb91dda25884d1c1fbe2b0138a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器不排除可能尝试嵌套事务的程序，这意味着程序员必须特别小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">在大多数情况下，使用 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; 的快捷方式：</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab3deb78b20e89efa13a9a442f13a5722f047491" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="b96ae088c649d5a06c694f9e9ee5ee9dc8687a02" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="5d111b0d48c558b38badb2c9405749a987627b42" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="b2172f3ccd962a6ecd9b4cc15ce3cf95a1be7eb5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="f674202704940c277740f7f4ae49cd37b3a5f78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt;' can be understood as the pseudo-&lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：&amp;ldquo; &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt; &amp;rdquo;可以理解为伪 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="c7b459af09ae8043d5f7b1a6c9159131c0b0fd22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：&amp;ldquo; &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt; &amp;rdquo;可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="a4087f9008dd31f8281176bc7c8f4d1d90f9e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="1570094d52e557732c703a05b9b1c145c2dd064a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="41f501d2ca81d0c4860698f021f0de3ecdc4a0f4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="108f9b97edb22ce149c8927414975f8505b7580d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="2c837790b7d1462717c4308d600ad3e92eeaf1c9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt; &amp;rdquo;可以理解为 &lt;code&gt;do&lt;/code&gt; 表情</target>
        </trans-unit>
        <trans-unit id="14c32ccf8b63eb011e4dfda0a4088dddc4bcbb92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="ffd6b1455603f9e6df9249daef0be0bed100da03" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA&quot;&gt;liftA&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="e2a8dbc4ffe0ccbf1d373d624329159d46946500" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="72b865211f58b24998cdf3ed8e08bdcf5e692e5e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="00a3efcb29a05c36224847d355496627fce12e1f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="9165dbc2c9969c24f2215ef6972a0880bb8278cb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="6e4a4d9eb30eacc6d2b8ca81bb1bd234ce8594a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="c8ccbb1fb2ddb1f53f896c4cc85e9a37ce0b41f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="3fce8cbc36fc6d6dcdd6a6150d8297a2eb75e02c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="1004bfc9a7477fe977e15f814e05ceb1b205da67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="71cb9307570de629188fffa91efa031876cc2110" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="774bbfc5e54c815dbed906d0f74123e150de4f6c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="69d911e731ca95c1fd9a07c919774126a522e977" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="84196a31a9d5c8e34d17aa2ef18dc24c40e44aab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="5b25d8a860bc159c6b22d827207b11014882905b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="8a06315a7f9f08f9387659d3c5c4197621c13971" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="64871c74d2047073bc61343ed982993443145244" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="7235239be554865a0935a618eb2b2336543f4705" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="6309b1896f5220de1092c0929134f7a07019870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="2a548000114a6581f99bb89aac62e4c4178082e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="translated">使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; ：' &lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt; '可以理解为 &lt;code&gt;do&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="a6203018fe62d6ff03754e5bb607909a52d373ff" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">使用字节串为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 的小号</target>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">使用字节串为 &lt;code&gt;CString&lt;/code&gt; 的小号</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">将ByteStrings作为CStrings使用</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">用CStrings的函数来使用ByteStrings。</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">使用不带 &lt;code&gt;-threaded&lt;/code&gt; 选项的GHC ，尽管I / O操作不会，所有外部调用都将阻塞系统中的所有其他Haskell线程。使用 &lt;code&gt;-threaded&lt;/code&gt; 选项，只有具有 &lt;code&gt;unsafe&lt;/code&gt; 属性的外部调用才会阻塞所有其他线程。</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">在共享库名称中使用GHC的版本号可以将由不同GHC版本编译的不同库版本安装在标准系统位置，例如* nix &lt;code&gt;/usr/lib&lt;/code&gt; 下。要获取GHC的版本号，请调用 &lt;code&gt;ghc --numeric-version&lt;/code&gt; 并使用其输出代替⟨GHCVersion⟩。另请参阅&lt;a href=&quot;phases#options-codegen&quot;&gt;影响代码生成的选项，&lt;/a&gt;以了解如何为共享对象链接准备对象文件。</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">结合使用&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，可以使用&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;框架轻松进行数据类型通用编程。本节简要介绍了操作方法。</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">结合使用&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，您可以使用&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;框架轻松进行数据类型通用编程。本节简要介绍了操作方法。</target>
        </trans-unit>
        <trans-unit id="2c82c05e8fe15e1579841159f1a517a26f5bffb8" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">结合使用&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;default_signatures#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，您可以使用&lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;框架轻松进行数据类型通用编程。本节简要介绍了操作方法。</target>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">使用依赖本地的编码</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">使用软件包并 &lt;code&gt;--make&lt;/code&gt; ：如果您使用--make或GHCi，则大多数已安装的软件包将自动提供给您的程序，而无需任何其他选择。下面的&amp;ldquo; &lt;a href=&quot;#using-packages&quot;&gt;使用软件包&amp;rdquo;&lt;/a&gt;中介绍了此规则的例外情况。</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">使用零的值会完全禁用RTS时钟,并会禁用依赖它的定时器:上下文切换定时器和堆分析定时器。上下文切换仍然会发生,但确定地以比正常速度快得多的速率进行。禁用间隔定时器对调试很有用,因为它消除了运行时非确定性的来源。</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="translated">使用孔洞拟合插件,你可以扩展有效孔洞拟合建议的行为,使用如Hoogle或其他外部工具来寻找和/或合成有效的孔洞拟合,其类型孔洞的信息与GHC使用的相同。</target>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">使用记录选择器</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;标志，可以并行编译模块。指定 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; 以并行编译⟨n⟩个作业。如果省略⟨n⟩，则默认为处理器数量。</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">使用 &lt;code&gt;module&lt;/code&gt; 命令的 &lt;code&gt;+&lt;/code&gt; 形式将模块添加到当前作用域，并 &lt;code&gt;-&lt;/code&gt; 删除它们。如果没有 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; ，则当前作用域将由指定的模块集替换。请注意，如果您使用此表单并省略 &lt;code&gt;Prelude&lt;/code&gt; ，则会自动添加隐式的 &lt;code&gt;Prelude&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="dcd0ac8cbd97b2347e8fe4749682a842e661035c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt;, the following functions:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:Except&quot;&gt;Except&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 实例，以下功能：</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="translated">使用该功能预计会使程序速度稍慢。</target>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">通常，只有在切换线程时，GHC才会使一个黑洞（thunk）进入黑洞。一旦输入了thunk，该标志便使其生效。请参阅&lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;共享内存多处理器上的Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">通常是用户的真实姓名(pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">通常，该文件应以模块名称命名，并用目录分隔符替换模块名称中的点。例如，在Unix系统上，模块 &lt;code&gt;A.B.C&lt;/code&gt; 应该放置在相对于某些基本目录的文件 &lt;code&gt;A/B/C.hs&lt;/code&gt; 中。如果该模块不打算由另一个模块（例如 &lt;code&gt;Main&lt;/code&gt; ）导入，则可以随意使用任何文件名。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">调用Win32 API的实用工具</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">用于原始码垛的工具</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">用于对C字符串进行初值化处理的工具。</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">用于对Windows的C语言字符串进行原始marshalling的工具。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">文件的实用功能</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;foreign import safe&lt;/code&gt; FFI调用的有效参数： &lt;code&gt;ByteArray#&lt;/code&gt; 和 &lt;code&gt;MutableByteArray#&lt;/code&gt; 。字节数组必须&lt;a href=&quot;#pinned-byte-arrays&quot;&gt;固定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="translated">&lt;code&gt;foreign import unsafe&lt;/code&gt; FFI调用的有效参数： &lt;code&gt;Array#&lt;/code&gt; ， &lt;code&gt;SmallArray#&lt;/code&gt; ， &lt;code&gt;ArrayArray#&lt;/code&gt; ， &lt;code&gt;ByteArray#&lt;/code&gt; 以及这些类型的可变对象。</target>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">当细化级别 &lt;code&gt;&amp;gt;= 2&lt;/code&gt; 时，有效细化孔配合的有效列表通常会变大，而诸如 &lt;code&gt;head _ _&lt;/code&gt; 或 &lt;code&gt;fst _ _&lt;/code&gt; 类的孔是有效细化，但由于一个或多个孔不大可能相关它们仍然是完全开放的，因为这些孔的类型和种类都完全不受提议的标识符的约束。默认情况下，不报告此类漏洞。通过打开此标记，这些孔将包含在有效细化孔配合列表中。</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;name&lt;/code&gt; 。这种方法说明了使用 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; 优于 &lt;code&gt;return&lt;/code&gt; 的优势。我们通过延续 &lt;code&gt;validateName&lt;/code&gt; ，并中断执行 &lt;code&gt;Cont&lt;/code&gt; 从块&lt;em&gt;内&lt;/em&gt;的 &lt;code&gt;validateName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="7e3d80a59e713df86b771fc1d2dd18a3958c972f" translate="yes" xml:space="preserve">
          <source>Validation use-case</source>
          <target state="translated">验证用例</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">填充此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 时计算的值。</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类编码的值始终以网络顺序（大字节序）形式进行编码，并且编码后的数据应在机器字节序，字长或编译器版本之间可移植。例如，使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类编码的数据可以写在任何机器上，而可以在任何其他机器上读回。</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">使用函数 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; 可以将 &lt;code&gt;TExp a&lt;/code&gt; 类型的值转换为 &lt;code&gt;Exp&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">香草类型同义词的声明与Haskell中的完全一样。</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">类型应用中不可用的变量优先。</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">根据ScopedSort（&lt;a href=&quot;#scopedsort&quot;&gt;指定变量的&lt;/a&gt;排序）对未由用户明确指定排序的变量进行排序。</target>
        </trans-unit>
        <trans-unit id="d7cf04f66b938e191f936b1736b7f07717f7def2" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;type_applications#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="translated">根据ScopedSort（&lt;a href=&quot;type_applications#scopedsort&quot;&gt;指定变量的&lt;/a&gt;排序）对未由用户明确指定排序的变量进行排序。</target>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">用户没有给定明确排序的变量,会根据范围排序(ScopedSort)进行排序。</target>
        </trans-unit>
        <trans-unit id="ce923a612b2be3e0d26e1de671e160005bec40d5" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">（&amp;gt;&amp;gt;）的变体，可以将有效的计算注入代码生成中。</target>
        </trans-unit>
        <trans-unit id="7e69428f906bf03a78f1b42caa4156197b506c43" translate="yes" xml:space="preserve">
          <source>Variant of (&amp;gt;&amp;gt;=) which allows effectful computations to be injected into code generation.</source>
          <target state="translated">（&amp;gt;&amp;gt; =）的变体，可以将有效的计算注入代码生成中。</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">具有 &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; 具有的&amp;ldquo;重新排序的障碍&amp;rdquo;属性的 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 体。</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 样式样式的 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 样式样式的 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">允许实例重叠的品种。</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">确认操作系统版本</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">版本信息</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">你的电脑的版本信息。</target>
        </trans-unit>
        <trans-unit id="e16193c9fa0396ab60a71b729b4a04cd813d0d61" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; without any value being passed to the second and third actions.</source>
          <target state="translated">没有任何值传递到第二个和第三个动作的方 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="74c019334e2fff57ca4e39f259c2452610b715a1" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="1e7284b212c3e18b15655fd8a93f4230611c203f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 构建 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">构造 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 的版本</target>
        </trans-unit>
        <trans-unit id="3383f2c0a3a8b49db2500fd0baa98b81bb0d0957" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="9d7b173a0dcac34771410bf511deb7fb53172de2" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 尺度的模</target>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 尺度的模</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="bcd38df7c17761d370b1e5803d31bed7f709a369" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="1c0304fc532fda6e0a0fb66673b691dbdd8f5987" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22b9c46cdd68688219fc77a7a7a0110bec5346a6" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="e9f8dae2a07adfa71cf9369406dff32b07be5f54" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">在 &lt;code&gt;nextPrimeInteger&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本</target>
        </trans-unit>
        <trans-unit id="0ebfec0d93e79f27fbe5c6446dcd99376cb8889b" translate="yes" xml:space="preserve">
          <source>Version of Unicode standard used by &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 使用的Unicode标准版本。</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">版本方案是多种多样的,所以这个库提供的版本表示是为了在完全的通用性和固定一个特定的版本方案之间做一个折衷,前者几乎没有合理的通用功能可以提供,后者可能限制性太强。</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="7c6f1ef6ee2199899662d0306223ad7c19cd46c1" translate="yes" xml:space="preserve">
          <source>Very unsafe coercion</source>
          <target state="translated">非常不安全的胁迫</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">一个序列的左端视图。</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">序列右端视图。</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">查看模式</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">视图模式由语言扩展&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;启用。可以在&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki页面&lt;/a&gt;上找到更多信息和视图模式示例。</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">视图模式由语言扩展&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;启用。可以在&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki页面&lt;/a&gt;上找到更多信息和视图模式示例。</target>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">视图模式有点像模式卫士,可以嵌套在其他模式中。它们是一种针对抽象类型的值进行模式匹配的便捷方式。例如,在编程语言的实现中,我们可以将语言类型的语法表示如下。</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">视图模式允许在模式内调用视图函数并与结果进行匹配。</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">事实上,所有的数据构造函数,甚至是那些具有丰富种类的构造函数,都可以被推广。这个规则只有几个例外。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">Void:用于没有构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：此函数可能会生成损坏的地图，其结果可能取决于其输入的内部结构。用户应首选 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：此函数可能会生成损坏的地图，其结果可能取决于其输入的内部结构。用户应首选 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">警告:普通非原始 Haskell 类型的弱指针特别脆弱,因为编译器可以自由地优化或复制底层数据结构。因此,试图在普通的 Haskell 类型上放置一个定型器,很可能导致定型器比你预期的更早运行。对于缓存和备忘录表来说,这并不是一个问题,因为在这些地方,早期的定稿是良性的。</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">等到有单位的时候</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">等待指定数量的产品上市</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">等待 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; （又名&lt;strong&gt;P&lt;/strong&gt;操作）。</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">等待信号</target>
        </trans-unit>
        <trans-unit id="572c89962b6ad39f8a6c6c966a575192e24a760d" translate="yes" xml:space="preserve">
          <source>Waits for one key to be pressed, then returns. Ignores the value of the specific key.</source>
          <target state="translated">等待一个键被按下,然后返回。忽略特定键的值。</target>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">等待指定的进程终止,并返回其退出代码。</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">警告类型签名中的类约束,可以使用顶层实例声明来简化。</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">警告类型签名中的类约束,可以使用顶层实例声明来简化。例如:</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="translated">当没有使用任何绑定变量时,警告记录通配符匹配。</target>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="translated">当通配符没有绑定任何模式时,警告记录通配符匹配。</target>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">警告如果 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 向后定义（即 &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">如果向后定义 &lt;code&gt;(*&amp;gt;)&lt;/code&gt; （即 &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ），则发出警告。</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">如果向后定义了 &lt;code&gt;fail&lt;/code&gt; 则发出警告（即 &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">警告是否向后定义了 &lt;code&gt;pure&lt;/code&gt; （即 &lt;code&gt;pure = return&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">如果一个模式绑定根本没有绑定任何变量,则发出警告,除非它是一个孤零零的通配符模式,或者是一个被撞的模式。例如</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">如果使用了一个被推广的数据构造函数,而在其名称前没有打勾,则发出警告。</target>
        </trans-unit>
        <trans-unit id="086bb0536ea1d969c7c5649822f9159c7df38091" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">如果重写规则可能无法触发，则发出警告，因为该函数可能在规则触发之前就已内联。请参阅&lt;a href=&quot;exts/rewrite_rules#rules-inline&quot;&gt;规则如何与INLINE / NOINLINE编译指示交互&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">如果重写规则可能无法触发，则发出警告，因为该函数可能在规则触发之前就已内联。请参阅&lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;规则如何与INLINE / NOINLINE编译指示交互&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非规范的 &lt;code&gt;Applicative&lt;/code&gt; 或 &lt;code&gt;Monad&lt;/code&gt; 实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非 &lt;code&gt;MonadFail&lt;/code&gt; &lt;code&gt;Monad&lt;/code&gt; 或MonadFail实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非规范的 &lt;code&gt;Semigroup&lt;/code&gt; 或 &lt;code&gt;Monoid&lt;/code&gt; 实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">当GHCi无法加载共享库时发出警告，它推断它应该在加载软件包并分析目标软件包描述的库外节时加载。</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCi无法加载共享库时发出警告。</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="translated">当GHCi无法加载共享库时发出警告。</target>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">当遇到延迟的范围外变量时发出警告。</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">在没有 &lt;code&gt;MonadFail&lt;/code&gt; 实例的do-block中使用可故障模式时发出警告。</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">当定义与将来将 &lt;code&gt;Semigroup&lt;/code&gt; 包含到标准类型类中时发生冲突时发出警告。</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">在将&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;与不支持的LLVM版本一起使用时发出警告。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">警告：如果给定的 &lt;code&gt;Vertex&lt;/code&gt; 不存在，则 &lt;code&gt;nodeFromVertex&lt;/code&gt; 函数将导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">警告:此功能有几个缺点(见文档)。这个函数有几个缺点(见文档)。请考虑使用Control.Concurrent.threadDelay代替。</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">警告：如果边缘列表中的顶点不在给定的 &lt;code&gt;Bounds&lt;/code&gt; 之内，则此函数将导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">警告,这是一个不稳定的接口。这是一个不稳定的接口。</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">警告:换行符和制表符不被视为分隔符。</target>
        </trans-unit>
        <trans-unit id="ee168ab9a58029df5beac805f3270bcfd9fe72d2" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">警告：由于 &lt;code&gt;&lt;a href=&quot;ghc-event#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; 是从I / O管理器调用的，因此它不能长时间抛出异常或阻塞。特别要提防 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; ：如果目标线程正在进行外部调用，则这些函数将阻塞，直到调用完成。</target>
        </trans-unit>
        <trans-unit id="6d01607b3c9e9f53fb1f960cc714c8c6dd8da973" translate="yes" xml:space="preserve">
          <source>Warning: since the &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; is called from the I/O manager, it must not throw an exception or block for a long period of time. In particular, be wary of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;: if the target thread is making a foreign call, these functions will block until the call completes.</source>
          <target state="translated">警告：由于 &lt;code&gt;&lt;a href=&quot;ghc-event-timeout#t:TimeoutCallback&quot;&gt;TimeoutCallback&lt;/a&gt;&lt;/code&gt; 是从I / O管理器调用的，因此它不能长时间抛出异常或阻塞。特别要提防 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; ：如果目标线程正在进行外部调用，则这些函数将阻塞，直到调用完成。</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*这个模块是内部模块,如果你发现你需要它,请联系维护者,并说明你想做什么,并讨论你在公共API中需要什么。如果你发现你需要它,请联系维护者,解释你正在尝试做什么,并讨论你在公共API中需要什么。这一点很重要,因为该模块可能在未来的版本中根本不会被暴露。</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*这个模块是内部模块,如果你发现你需要它,那么请联系维护者,说明你想做什么,并讨论你在公共API中需要什么。如果你发现你需要它,那么请联系维护者,解释你正在尝试做什么,并讨论你在公共API中需要什么。这一点很重要,因为该模块可能在未来的版本中根本不会被暴露。</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">对于(a)在定义模块中的使用,(b)在类实例中定义方法,以及(c)在导出列表中的使用,不报告警告和废弃。后者减少了在一个库中,一个模块将其他几个模块的导出集合起来再导出的虚假投诉。</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告仅被视为警告，而不是错误。这是默认设置，但是对否定&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;标志很有用。</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告仅被视为警告，而不是错误。这是默认设置，但对否定&lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;标志很有用。</target>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="translated">警告对核心库模块的合格导入,这些模块在未来的GHC版本中可能会发生变化。目前该警告涵盖了以下模块。</target>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">该程序是否使用GHC 的&lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;未注册&amp;rdquo;&lt;/a&gt;版本进行编译？（即，没有编译特定于平台的优化的GHC版本，通常是因为这是当前不支持的平台。）除非您使用GHC的实验版本，否则该值通常为no。</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过将对缓冲区写入的控制权完全移交给实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ,我们实现了（1）。只是告诉此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 缓冲区的开始和结束（以 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 表示）。然后， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 可以 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 希望的任何方式写入此BufferRange的前缀。如果 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 完成后， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 是满的，或字节的长序列应该被直接插入，则 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 信号这对使用它的调用者 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">我们通过要求每一个实现（2） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 由实施 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ，需要一个延续 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ，它与更新的要求 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 它完成之后。因此，在函数调用中只需传递两个指针即可实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的串联。而且，许多 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 都是完全内联的，这使编译器可以对它们进行排序，而无需调用函数，也无需装箱。</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">我们还建议使用&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;来分析并行程序。它提供了用于可视化并行执行的GUI，是对GHC随附的时间和空间分析功能的补充。</target>
        </trans-unit>
        <trans-unit id="c301d61ee67c2ed79282027770ed709d177658e3" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">我们还建议使用&lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;来分析并行程序。它提供了用于可视化并行执行的GUI，是对GHC随附的时间和空间分析功能的补充。</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">我们也希望解除的操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 通过两个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 。对于 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; 的操作，我们知道 &lt;code&gt;throwE e&lt;/code&gt; 是一个简单的动作，因此我们可以通过两个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; s 通过两个monad变压器将其提升到 &lt;code&gt;InterpM&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">实际上，我们在这里使用 &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; 和更具体的类型</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">我们不仅限于单个模块：GHCi可以将 &lt;code&gt;*&lt;/code&gt; 和非 &lt;code&gt;*&lt;/code&gt; 形式的任意组合的多个模块合并在一起。GHCi合并了所有这些模块的作用域，以形成在提示时有效的作用域。</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">我们称其为过程或箭头抽象。与lambda表达式一样，变量 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;proc&lt;/code&gt; -expression中绑定的新变量。它指的是箭头的输入。在上面的示例中， &lt;code&gt;-&amp;lt;&lt;/code&gt; 不是标识符，而是新的保留符号，用于根据箭头类型的表达式和要作为该箭头的输入提供的表达式来构建命令。（怪异的外观稍后会更有意义。）可以将其视为类似于箭头的应用。上面的示例等效于Haskell表达式</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">我们也可以使用Writer定义一个基元。</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">我们也可以用类似的方式导出构造函数类的实例。例如,假设我们已经实现了状态和失败的单体变换器,这样就可以实现</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">我们也可以直接将一个值序列化到一个Handle或一个文件,或从一个Handle或文件序列化。</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">我们还可以生成源码的标记版本。</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">我们也可以引用包含空格等字符的参数,它们被当作 Haskell 字符串处理,或者我们可以直接使用 Haskell 列表语法。</target>
        </trans-unit>
        <trans-unit id="3c5f88dde35a93a41c4cb3d95351a5898162e27d" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; example above.</source>
          <target state="translated">我们还可以使用它来对严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 进行十六进制编码，如上面的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-ascii#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; 示例所示。</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">我们还可以使用它来对严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 进行十六进制编码，如上面的 &lt;code&gt;byteStringHex&lt;/code&gt; 示例所示。</target>
        </trans-unit>
        <trans-unit id="1ce8823816dc5997208d0d3df16b93ce9755a58f" translate="yes" xml:space="preserve">
          <source>We can carry this further, and define more non-default methods...</source>
          <target state="translated">我们可以进一步进行,并定义更多的非默认方法......</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">现在我们可以检查是否像预期的那样重构了 &lt;code&gt;x&lt;/code&gt; 的类型，并且使用它也重构了 &lt;code&gt;f&lt;/code&gt; 的类型：</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">我们可以清楚地看到我们正在转换为&lt;em&gt;二进制&lt;/em&gt;格式。具有127以上的Unicode代码点的'&amp;lambda;'和'&amp;ouml;'字符被扩展为它们对应的UTF-8多字节表示形式。</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 多次组合多个基元。</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 多次组合多个基元。</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 函数将列表中的多个值组合为一个值。请注意，我们必须在此处指定类型，因为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 在几种不同的操作下是一个monoid：</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">我们可以编译 &lt;code&gt;D&lt;/code&gt; ，然后加载整个程序，如下所示：</target>
        </trans-unit>
        <trans-unit id="6673177b0a5b4448a0b279c9a7468bd7b3f97bc2" translate="yes" xml:space="preserve">
          <source>We can convert a regular list to an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; with:</source>
          <target state="translated">我们可以通过以下方式将常规列表转换为&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">我们可以定义一个从文件中读取GHCi输入的命令。这对于创建一组我们想要重复加载到 GHCi 会话中的绑定可能很有用。</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">我们可以定义一个解析器，该解析器也可以通过添加 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 转换器来计数：</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">我们可以通过修改 &lt;code&gt;pat_lhs&lt;/code&gt; 的形式来定义前缀，中缀或记录模式同义词。这些的语法如下：</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">我们可以通过转换为常规理解来定义并行列表理解。这是基本思想：</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">我们可以通过在 &lt;code&gt;[]&lt;/code&gt; monad上添加一个状态（需要解析的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）来定义这样的解析器monad，它提供了不确定性：</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">我们可以通过在 &lt;code&gt;[]&lt;/code&gt; monad上添加一个状态（待解析的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）来定义这样的解析器monad，它提供了不确定性：</target>
        </trans-unit>
        <trans-unit id="df8374e1acf095dee848a44f1577d87dbc000a3e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">我们可以通过在 &lt;code&gt;[]&lt;/code&gt; monad上添加一个状态（待解析的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）来定义这样的解析器monad，它提供了不确定性：</target>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">我们可以使用下面的实例将这种类型的值编码成字节串,它通过递归分解结构来进行序列化。</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">如果newtype是最后一个类参数，我们甚至可以派生多参数类的实例。在这种情况下，该类的&amp;ldquo;部分应用程序&amp;rdquo;出现在 &lt;code&gt;deriving&lt;/code&gt; 子句中。例如，给定类</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">相反，我们可以创建一个新类型的 &lt;code&gt;App&lt;/code&gt; （其中 &lt;code&gt;App f a&lt;/code&gt; 和 &lt;code&gt;f a&lt;/code&gt; 在内存中表示相同），并使用&lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;显式启用此模式的使用：</target>
        </trans-unit>
        <trans-unit id="34d5422d9cdcd8f1fd638150c60756059c44e629" translate="yes" xml:space="preserve">
          <source>We can lift &lt;code&gt;append&lt;/code&gt; and apply it to &lt;code&gt;f0&lt;/code&gt; to get:</source>
          <target state="translated">我们可以提升 &lt;code&gt;append&lt;/code&gt; 并将其应用于 &lt;code&gt;f0&lt;/code&gt; 以获得：</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">现在，我们可以将 &lt;code&gt;MismatchedParentheses&lt;/code&gt; 异常捕获为 &lt;code&gt;MismatchedParentheses&lt;/code&gt; ， &lt;code&gt;SomeFrontendException&lt;/code&gt; 或 &lt;code&gt;SomeCompilerException&lt;/code&gt; ，但不能捕获其他类型，例如 &lt;code&gt;IOException&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">我们现在可以检查评估步骤的历史。</target>
        </trans-unit>
        <trans-unit id="a6f3e30515c510be759d2caa31d207bd8d44a8cd" translate="yes" xml:space="preserve">
          <source>We can only make field selectors for pattern synonym records that do not mention any existential type variables whatsoever in their types, per &lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;Record Pattern Synonyms&lt;/a&gt;. (This is a stronger requirement than for GADT records, whose types can mention existential type variables provided that they are also mentioned in the return type.) We can see that &lt;code&gt;unP2&lt;/code&gt; cannot be used as a top-level field selector since its type has a free type variable &lt;code&gt;n&lt;/code&gt;, which is existential. &lt;code&gt;unP1&lt;/code&gt; is fine, on the other hand, as its type only has one free variable, the universal type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">根据&amp;ldquo;&lt;a href=&quot;pattern_synonyms#record-patsyn&quot;&gt;记录模式同义词&amp;rdquo;&lt;/a&gt;，我们只能为模式同义词记录创建字段选择器，该模式选择器的类型中不提及任何存在的类型变量。 （这比对GADT记录的要求要强，GADT记录的类型可以提及存在类型变量，但前提是它们也必须在返回类型中提及。）我们可以看到，由于 &lt;code&gt;unP2&lt;/code&gt; 的类型具有一个自由类型变量 &lt;code&gt;n&lt;/code&gt; ，它是存在的。另一方面， &lt;code&gt;unP1&lt;/code&gt; 很好，因为其类型只有一个自由变量，即通用类型变量 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">我们可以向EvalStmt传递简单的表达式,由值和应用组成。这使得我们可以将语句包装到另一个函数中执行,GHCi用它来实现:set args和:set prog。将来可能值得对这个小语言进行扩展。</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">我们可以通过从类声明中删除空成员来避开这个特殊问题。然而,虽然剩下的成员,插入和成员,没有模棱两可的类型,但当我们尝试使用它们时,仍然会遇到问题。例如,考虑以下两个函数。</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">我们可以使用单子组合器简化 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 实例的编写：</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">我们可以通过将后两个命令应用于普通表达式,来提供它们所需的额外输入,如在</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">然后我们可以使用 &lt;code&gt;HeadC&lt;/code&gt; 在表达和图案背景。在模式上下文中，它将匹配长度至少为一个的任何列表的头部。在表达式上下文中，它将构造一个单例列表。</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">因此，我们可以将类型 &lt;code&gt;P&lt;/code&gt; （具有构造函数 &lt;code&gt;MkP&lt;/code&gt; ）与提升的数据构造器 &lt;code&gt;'P&lt;/code&gt; （类型为 &lt;code&gt;Prom&lt;/code&gt; ）区分开来。</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">我们可以对此签名进行类型检查 &lt;code&gt;A&lt;/code&gt; ，也可以使用提供以下声明的模块实例化 &lt;code&gt;Str&lt;/code&gt; 。有关如何实例化签名的更深入的讨论，请参考Cabal的文档。</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">我们可以将do-notation与作为 &lt;code&gt;Applicative&lt;/code&gt; 和 &lt;code&gt;Functor&lt;/code&gt; 实例的类型一起使用，但不能用于 &lt;code&gt;Monad&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">例如,我们可以使用它将固定值前置和/或追加到基元中。</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">我们可以使用levity多态性来达到有 &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的良好效果，其类型如下：</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">我们可以使用以下函数来提取碎片。</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">使用GHCi时，我们可以使用探查器来收集堆栈跟踪（请参阅GHCi中的&lt;a href=&quot;#ghci-stack-traces&quot;&gt;堆栈跟踪&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">我们可以用它来寻找一个列表中最长的条目。</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">我们可以用它来寻找一个列表中最短的条目。</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">我们无法在可能使用它们的模块中定义这些功能（例如&lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;），因为神奇的有线输入类型将与类型检查器弄清楚的内容混淆。</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">我们可以定义自己的运营商</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">我们可以使用三个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作提升到 &lt;code&gt;InterpM&lt;/code&gt; ，但是 &lt;code&gt;InterpM&lt;/code&gt; 自动是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 的实例，因此我们可以使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">我们可以使用三个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作提升到 &lt;code&gt;InterpM&lt;/code&gt; ，但是 &lt;code&gt;InterpM&lt;/code&gt; 自动是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 的实例，因此我们可以使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="b98be665de6d96e1b325862bf69bb2db5b4de5f2" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">我们可以使用三个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作提升到 &lt;code&gt;InterpM&lt;/code&gt; ，但是 &lt;code&gt;InterpM&lt;/code&gt; 自动是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 的实例，因此我们可以使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">我们无法给 &lt;code&gt;f0&lt;/code&gt; 足够的输入来解码任何内容，因此它返回了一个空字符串。一旦我们在输入的最后一个字节中输入第二个延续 &lt;code&gt;f1&lt;/code&gt; ，它将取得进展。</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">我们可以模拟 &lt;code&gt;if&lt;/code&gt; 通过定义</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">我们可以尝试将 &lt;code&gt;g&lt;/code&gt; 应用于 &lt;code&gt;x&lt;/code&gt; 。但是，这将不起作用，因为 &lt;code&gt;g&lt;/code&gt; 需要一个类型为 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;x :: b&lt;/code&gt; 。更糟糕的是，我们不能将 &lt;code&gt;x&lt;/code&gt; 转换为类型 &lt;code&gt;a&lt;/code&gt; ，因为 &lt;code&gt;f&lt;/code&gt; 也需要类型 &lt;code&gt;a&lt;/code&gt; 的参数！简而言之，没有好的方法可以使这项工作。</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">我们创建两个类型为 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值，一个使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数，另一个使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数。然后，我们应用 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 函数（如果有 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）或&amp;ldquo; times-two&amp;rdquo;函数（如果有 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）&amp;ldquo;要么&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">我们创建两个类型为 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值，一个使用 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数，另一个使用 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数。然后，我们应用 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 函数（如果有 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）或&amp;ldquo; times-two&amp;rdquo;函数（如果有 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）&amp;ldquo;要么&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">我们在下表中演示我们的UTF-8 CSV编码功能。</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">我们没有得到 &lt;code&gt;C&lt;/code&gt; 的编译版本！发生了什么？嗯，在GHCi中，一个已编译的模块可能仅依赖于其他已编译的模块，在这种情况下， &lt;code&gt;C&lt;/code&gt; 依赖于 &lt;code&gt;D&lt;/code&gt; ，后者没有目标文件，因此GHCi也拒绝了 &lt;code&gt;C&lt;/code&gt; 的目标文件。好的，让我们也编译 &lt;code&gt;D&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">我们没有得到 &lt;code&gt;C&lt;/code&gt; 的编译版本！发生了什么？嗯，在GHCi中，一个已编译的模块可能仅依赖于其他已编译的模块，在这种情况下， &lt;code&gt;C&lt;/code&gt; 依赖于 &lt;code&gt;D&lt;/code&gt; ，而D没有目标文件，因此GHCi也拒绝了 &lt;code&gt;C&lt;/code&gt; 的目标文件。好的，所以我们还要编译 &lt;code&gt;D&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">我们区分三种通配符。</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">我们不会忽略 &lt;code&gt;E3&lt;/code&gt; 的论点，因为 &lt;code&gt;a&lt;/code&gt; 并不是普遍多态的。在 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;E3&lt;/code&gt; （隐含）存在性量化的，所以它是不一样的最后一个类型参数 &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">我们不会忽略 &lt;code&gt;E1&lt;/code&gt; 或 &lt;code&gt;E4&lt;/code&gt; 的参数，因为即使 &lt;code&gt;(a ~ Int)&lt;/code&gt; ， &lt;code&gt;Int&lt;/code&gt; 在语法上也不等效于 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">我们不建议用困难的方式构建软件包。相反，请尽可能使用&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;基础架构。如果您的程序包特别复杂或需要大量配置，那么您可能不得不退回到低级机制，因此以下是那些勇敢者的一些提示。</target>
        </trans-unit>
        <trans-unit id="1756ea7351d5c75b6ae409dae0c3a8cdf9b2c46f" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">我们不建议用困难的方式构建软件包。相反，请尽可能使用&lt;a href=&quot;https://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;基础架构。如果您的程序包特别复杂或需要大量配置，则您可能不得不退回到低级机制，因此，以下是一些勇敢者的一些提示。</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">我们在日常工作中不使用 &lt;code&gt;-O*&lt;/code&gt; 标志。我们使用 &lt;code&gt;-O&lt;/code&gt; 来获得可观的速度；例如，当我们想要测量某物时。当我们想休息时，我们倾向于使用 &lt;code&gt;-O2&lt;/code&gt; （并且我们会大量喝咖啡休息时间）。</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们要么得到证据证明该函数已使用相同的类型级别数字实例化，要么得到 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们要么得到证据，要么使用相同的类型级别符号或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 实例化了此函数。</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">我们只评估了 &lt;code&gt;_t1&lt;/code&gt; 实体，显示了列表的开头，而尾部是另一个绑定到 &lt;code&gt;_t2&lt;/code&gt; 的实体。该 &lt;code&gt;seq&lt;/code&gt; 的功能是有点不方便在这里使用，所以你可能需要使用&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;（！作为练习留给读者）做出更好的接口。</target>
        </trans-unit>
        <trans-unit id="9fdb86aff4e68170d19ff52b844aa793fc663425" translate="yes" xml:space="preserve">
          <source>We extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">我们用两种额外的形式扩展 &lt;code&gt;class&lt;/code&gt; （警告：这是一个相当混乱的命名非终端符号），即恰好可以出现在实例声明中的形式</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">我们找出当前功能编号并将其传递给C。这将传递回 &lt;code&gt;hs_try_putmvar&lt;/code&gt; ，并帮助RTS知道应该尝试对 &lt;code&gt;tryPutMVar&lt;/code&gt; 进行操作的功能。如果您不在乎，则可以将 &lt;code&gt;-1&lt;/code&gt; 作为功​​能传递给 &lt;code&gt;hs_try_putmvar&lt;/code&gt; ，它将选择任意一个。</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">我们有 &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; ， &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; 和 &lt;code&gt;x :: b&lt;/code&gt; 。使用这些，我们必须以某种方式用 &lt;code&gt;Int&lt;/code&gt; 类型的值填充孔（用下划线表示）。我们有什么选择？</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">除了人为设计的程序之外，我们再也没有找到其他可使GHC产生差异的程序，而解决该问题将在每次编译时带来额外的开销。因此，该错误仍未修复。&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;《 GHC内衬的秘密》&lt;/a&gt;还有更多背景知识。</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">我们推断这些种类。</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">我们在内部用一个类型为</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">我们用 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 事件标记新样本的开始，</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">我们也需要，如果我们检测到它们的编码序列时信号无效字符 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s转换 &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 是因为该 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; 模式创建这些对往返通过我们内部的UTF-16编码字节。</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">我们将来可能会改变这个功能的语法和语义。</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;提供&lt;/a&gt; HEAD的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;提供&lt;/a&gt;HEAD的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c79f15081f54da10e6044689f529ce2f478e6d97" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;https://www.haskell.org/ghc/dist/current/dist/&quot;&gt;提供&lt;/a&gt;HEAD的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;提供&lt;/a&gt;当前稳定分支的快照版本供下载，最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;提供&lt;/a&gt;当前稳定分支的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8f550102596507541eecd8fea3584501d85066c" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;https://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;提供&lt;/a&gt;当前稳定分支的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">前面我们提到过，惰性计算（即thunk）会在创建当前堆栈时捕获当前堆栈，并在对其进行评估时恢复该堆栈。那顶级的混蛋呢？它们是在程序编译时&amp;ldquo;创建&amp;rdquo;的，那么我们应该给它们提供什么堆栈？顶级thunk的技术名称是CAF（&amp;ldquo;常量申请表&amp;rdquo;）。 GHC为模块中的每个CAF分配一个由单个成本中心 &lt;code&gt;M.CAF&lt;/code&gt; 组成的堆栈，其中 &lt;code&gt;M&lt;/code&gt; 是模块的名称。也可以使用&lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;选项为每个CAF提供不同的堆栈。当使用&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 进行&lt;/a&gt;编译时（这是&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 的&lt;/a&gt;默认设置，这尤其有用）以及更高版本），因为功能体内的常量将被提升到顶级并成为CAF。您可能需要咨询Core（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）以确定这些CAF对应的内容。</target>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">前面我们提到过，惰性计算（即thunk）在创建当前堆栈时会捕获它们，并在对其进行评估时恢复该堆栈。那顶级的混蛋呢？它们是在程序编译时&amp;ldquo;创建&amp;rdquo;的，那么我们应该给它们什么堆栈？顶级thunk的技术名称是CAF（&amp;ldquo;常量申请表&amp;rdquo;）。 GHC为模块中的每个CAF分配一个由单个成本中心 &lt;code&gt;M.CAF&lt;/code&gt; 组成的堆栈，其中 &lt;code&gt;M&lt;/code&gt; 是模块的名称。也可以使用&lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;选项为每个CAF提供不同的堆栈。当使用&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 进行&lt;/a&gt;编译时（这是&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 的&lt;/a&gt;默认设置，这尤其有用）以及更高版本），因为功能体内的常量将被提升到顶层并成为CAF。您可能需要咨询Core（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）以确定这些CAF对应什么。</target>
        </trans-unit>
        <trans-unit id="7ac173e2f1e3e157189bce46a9d6b1220792bdd5" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">我们更喜欢（B）。为什么？因为GHC可以找出 &lt;code&gt;(True :~: False)&lt;/code&gt; 是空类型。因此（B）没有偏见，GHC可以使用&lt;a href=&quot;../using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;进行编译。另一方面，（A）看起来很危险，并且GHC不会检查以确保实际上永远不会调用该函数。</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">我们非常喜欢（B）。为什么？因为GHC可以确定 &lt;code&gt;(True :~: False)&lt;/code&gt; 是空类型。因此（B）没有偏见，GHC可以使用&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;进行编译。另一方面，（A）看起来很危险，GHC不会检查以确保实际上永远不会调用该函数。</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">我们更喜欢（B）。为什么？因为GHC可以找出 &lt;code&gt;(True :~: False)&lt;/code&gt; 是空类型。因此（B）没有偏见，GHC可以使用&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;进行编译。另一方面，（A）看起来很危险，并且GHC不会检查以确保实际上永远不会调用该函数。</target>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">我们通常用 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 事件标记新样本的开始，</target>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">现在，我们为实际的 &lt;code&gt;encode&lt;/code&gt; 功能定义 &lt;code&gt;Encode&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">现在我们详细解释一下hpc的主要模式。</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">我们最初为作用域中的所有变量提供了绑定,而不是仅仅为表达式的自由变量提供绑定,但我们发现这大大影响了性能,因此目前只对自由变量进行了限制。</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">我们 &lt;code&gt;hs_init()&lt;/code&gt; &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; 的引用传递给hs_init（），以便它可以分隔出RTS的任何参数（即 &lt;code&gt;+RTS...-RTS&lt;/code&gt; 之间的那些参数）。</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">如果找不到文件或者读取失败,我们就退出。(对haddock或其他客户来说是一个方便的例程)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">我们建议编译旨在与&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;标志并行运行的任何代码。</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">我们建议在标准Windows控制台中运行GHCi：从GHC安装程序添加的开始菜单项中选择 &lt;code&gt;GHCi&lt;/code&gt; 选项，或使用 &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; 获取Windows控制台并从那里调用 &lt;code&gt;ghci&lt;/code&gt; （只要它在您的 &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">我们将分支表示为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的列表，因此版本3.2.1变为[3,2,1]。字典顺序（即的默认实例 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;[Int]&lt;/code&gt; ）给出分支的自然顺序。</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">我们重用关键字 &lt;code&gt;default&lt;/code&gt; 来表示签名仅适用于default方法；定义的情况下，当 &lt;code&gt;Enum&lt;/code&gt; 类，原始类型 &lt;code&gt;[a]&lt;/code&gt; 的 &lt;code&gt;enum&lt;/code&gt; 仍然适用。但是，当提供一个空实例时，将填充默认实现 &lt;code&gt;(map to genum)&lt;/code&gt; ，并使用类型 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 类型检查。</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">我们重写 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; 的连续用法，以使绑定检查融合在一起。例如，</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">我们运行以下关于GHC的邮件列表。我们鼓励你加入,如果你觉得合适的话。</target>
        </trans-unit>
        <trans-unit id="f1dbba1856e51980e45e786acb354e0d1d1df7c9" translate="yes" xml:space="preserve">
          <source>We say that a variable whose multiplicity constraint is &lt;code&gt;Many&lt;/code&gt; is &lt;em&gt;unrestricted&lt;/em&gt;.</source>
          <target state="translated">我们说其多重性约束为 &lt;code&gt;Many&lt;/code&gt; 的变量是&lt;em&gt;不受限制的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">我们说&lt;em&gt;指定&lt;/em&gt;了 &lt;code&gt;f&lt;/code&gt; 中的类型变量，而&lt;em&gt;推断&lt;/em&gt;了 &lt;code&gt;g&lt;/code&gt; 中的类型变量。一般规则是：如果用户在源程序中编写了类型变量，则将其&lt;em&gt;指定&lt;/em&gt;；如果不是，则&lt;em&gt;推断为&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86eabd9ae7f589e2df7e5f7c967151a67519bb49" translate="yes" xml:space="preserve">
          <source>We see that a lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;g e&lt;/code&gt; endomorphisms, with &lt;code&gt;f'&lt;/code&gt; as as the operator, in fact yields a strict left fold, that avoids building a deep chain of intermediate thunks:</source>
          <target state="translated">我们看到，一个懒惰 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似的的 &lt;code&gt;g e&lt;/code&gt; 同态，与 &lt;code&gt;f'&lt;/code&gt; 作为为运营商，实际上产生了严格的左折叠，避免建筑中间的thunk深刻链：</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">我们在 &lt;code&gt;map&lt;/code&gt; 上设置一个断点，并调用它。</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">强烈建议您在编译要在多个内核上进行概要分析的程序时使用&lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt;，因为条目计数也存储在共享内存中，并且在多个内核上连续更新它们的速度非常慢。</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">然后，我们使用新的Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; 标志编译 &lt;code&gt;Danger&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">我们用两种额外的形式扩展 &lt;code&gt;class&lt;/code&gt; （警告：这是一个相当混乱的命名非终端符号），即恰好可以出现在实例声明中的形式</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">我们使用默认签名来简化GHC（&lt;a href=&quot;#generic-programming&quot;&gt;通用编程&lt;/a&gt;）中的通用编程。</target>
        </trans-unit>
        <trans-unit id="688e02acbe0a3ecd6d1989ae0fb801ec38f3ebed" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;generics#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">我们使用默认签名来简化GHC（&lt;a href=&quot;generics#generic-programming&quot;&gt;通用编程&lt;/a&gt;）中的通用编程。</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">我们使用 &lt;code&gt;criterion&lt;/code&gt; 库（&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）在下表中对我们的编码功能的效率进行基准测试。</target>
        </trans-unit>
        <trans-unit id="1dae9d07b3904219cff50bee9567703d83f53689" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">我们使用 &lt;code&gt;criterion&lt;/code&gt; 库（&lt;a href=&quot;https://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）在下表中对我们的编码功能的效率进行基准测试。</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">我们使用延续 &lt;code&gt;f0&lt;/code&gt; 解码我们的第二个数据包。</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">我们使用以下导入并缩写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 来简化阅读。</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">我们使用以下导入并缩写 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 来简化阅读。</target>
        </trans-unit>
        <trans-unit id="22f0961872a4ad51f0a43371524e8f12b244e439" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">我们使用以下导入并缩写 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 来简化阅读。</target>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">我们希望您将这种行为报告为错误，以便我们可以尝试纠正它。</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">我们已经用 &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt; 了GHC专用位（__GLASGOW_HASKELL__）；其余代码应可在支持FFI标准的Haskell实现中移植。</target>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">我们已经用 &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; 包围了特定于GHC的位；其余代码应可在支持FFI标准的Haskell实现中移植。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">弱指针对于缓存和备忘录表特别有用。要建立一个备忘表,你要建立一个从函数参数(键)到其结果(值)的数据结构映射。当你把函数应用到一个新的参数时,你首先要检查键/值对是否已经在备忘录表中。关键的一点是,备忘录表本身不应保持键和值的活力。所以表中应该包含一个指向键的弱指针,而不是一个普通的指针。指向值的指针不能是弱指针,因为对值的唯一引用可能确实来自备忘录表。</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">弱的指针。</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">弱化对ThreadIds的引用</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">欢迎使用GHC用户指南</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="translated">递归函数以及相互递归的函数组又如何呢？费用归于何处？好的，尽管GHC确实保留有关哪些函数组递归调用的信息，但是该信息不会显示在基本时间和分配配置文件中，而是将调用图按如下所示展平为树：在当前堆栈上其他地方发生的事件不会将另一个条目压入堆栈，而是将此调用的费用汇总到调用方&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">递归函数和相互递归的函数组呢？费用归于何处？好的，尽管GHC确实保留有关哪些函数组递归调用的信息，但是该信息不会显示在基本时间和分配配置文件中，而是将调用图按如下所示展平为树：如果发生在当前堆栈的其他位置，则不会将另一个条目压入堆栈，而是将此调用的费用汇总到调用方&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">我们在原始定义中遇到的歧义问题如何处理？空函数的类型仍然为 &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; ，但是不再需要将其视为模棱两可的类型：尽管变量 &lt;code&gt;e&lt;/code&gt; 不在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号的右侧，但是 &lt;code&gt;Collects&lt;/code&gt; 类的依赖项告诉我们它由 &lt;code&gt;ce&lt;/code&gt; 唯一确定，它确实出现在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号的右侧。因此，使用空的上下文仍然可以提供足够的信息来确定 &lt;code&gt;ce&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; 的类型，没有歧义。更一般地说，如果类型在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的左侧包含一个变量，而该变量不是由右侧的变量唯一地（直接或间接地）确定的，则只需将其视为模棱两可的。</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">实际发生的是GHCi对表达式进行类型检查，如果它没有 &lt;code&gt;IO&lt;/code&gt; 类型，则将其转换为以下形式：表达式 &lt;code&gt;e&lt;/code&gt; 变为</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">使用 &lt;code&gt;Foo&lt;/code&gt; 类型的值可以做什么？特别是，当我们在 &lt;code&gt;MkFoo&lt;/code&gt; 上进行模式匹配时会发生什么？</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">为x&amp;ldquo;提供&amp;rdquo;显式类型是什么意思？您可以通过使用模式类型签名（&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法作用域类型变量&lt;/a&gt;）直接为x提供类型签名来实现，从而：</target>
        </trans-unit>
        <trans-unit id="91ea760880e6d9bd2555f022fdf2a6393ee5b3e8" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">为x&amp;ldquo;提供&amp;rdquo;显式类型是什么意思？您可以通过使用模式类型签名（按&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;词法作用域定义的类型变量&lt;/a&gt;）直接为x提供类型签名来做到这一点，从而：</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">安全是什么意思？导入使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的模块不应更改无需导入模块即可正常编译的代码的含义。这是Safe Haskell属性，称为&lt;em&gt;语义一致性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">对于类型构造函数，什么才算是&amp;ldquo;完整的用户提供的种类签名&amp;rdquo;？这些是以下形式：</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">这与&lt;em&gt;存在&lt;/em&gt;量化有什么关系？简单地说， &lt;code&gt;MkFoo&lt;/code&gt; 具有（几乎）同构类型</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">如果我们要定义范围超过类型构造函数的泛型类（例如 &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; ），该怎么办？</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; 是什么类型？可能会说&amp;ldquo;全 &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; &amp;gt; k-&amp;gt; Type，但这不是很正确，因为这将允许使用诸如ProxyKVis Bool Int之类的不正确的东西，由于 &lt;code&gt;Int&lt;/code&gt; 不是 &lt;code&gt;Bool&lt;/code&gt; 类型，因此应将其拒绝。关键的观察结果是第二个参数的类型&lt;em&gt;取决于&lt;/em&gt;第一个参数。GHC在它为 &lt;code&gt;ProxyKVis&lt;/code&gt; 提供的语法中指出了这种依赖性：</target>
        </trans-unit>
        <trans-unit id="39c87b0db40f56398a44a5dc90aefe416e407bb2" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depends&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ProxyKVis&lt;/code&gt; 是什么类型？可能会说&amp;ldquo;全 &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt; &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt; &amp;gt; k-&amp;gt; Type，但这不是很正确，因为这将允许使用诸如ProxyKVis Bool Int之类的错误内容，由于 &lt;code&gt;Int&lt;/code&gt; 不是 &lt;code&gt;Bool&lt;/code&gt; 类型，因此应拒绝使用。关键的观察结果是第二个参数的类型&lt;em&gt;取决于&lt;/em&gt;第一个参数。 GHC在它为 &lt;code&gt;ProxyKVis&lt;/code&gt; 提供的语法中指出了这种依赖性：</target>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">结果类型中的&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;是什么？显然，我们不是这个意思：</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">它是什么类型的拼接</target>
        </trans-unit>
        <trans-unit id="658954d7cdd84a10f186220aa5a43363b9844f19" translate="yes" xml:space="preserve">
          <source>What remains to be done is an inductive step beyond the empty and singleton cases. For a concrete &lt;code&gt;Traversable&lt;/code&gt; functor &lt;code&gt;T&lt;/code&gt; we need to be able to extend our structure incrementally by filling in holes. We can view a partially built structure &lt;strong&gt;&lt;code&gt;t0 :: T a&lt;/code&gt;&lt;/strong&gt; as a function &lt;strong&gt;&lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; that takes one more element &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; to insert into the container to the right of the existing elements to produce a larger structure. Conversely, we can view an element &lt;code&gt;a&lt;/code&gt; as a function &lt;strong&gt;&lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt;&lt;/strong&gt; of a partially built structure that inserts the element to the left of the existing elements.</source>
          <target state="translated">剩下要做的是超越空和单例的归纳步骤。对于一个具体的 &lt;code&gt;Traversable&lt;/code&gt; 的函子 &lt;code&gt;T&lt;/code&gt; ，我们需要能够在孔中填充逐步扩大我们的结构。我们可以将部分构建的结构&lt;strong&gt; &lt;code&gt;t0 :: T a&lt;/code&gt; &lt;/strong&gt;视为函数&lt;strong&gt; &lt;code&gt;append :: a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt;，该结构需要一个以上的元素&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;插入到现有元素右侧的容器中，以产生更大的结构。相反，我们可以将元素 &lt;code&gt;a&lt;/code&gt; 看作是部分构建的结构的函数&lt;strong&gt; &lt;code&gt;prepend :: T a -&amp;gt; T a&lt;/code&gt; &lt;/strong&gt;，该结构将元素插入到现有元素的左侧。</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">给定的类型参数应该扮演什么角色？ GHC执行角色推断，以确定每个参数的正确角色。它从一些基本事实开始： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; 具有两个表示参数； &lt;code&gt;(~)&lt;/code&gt; 有两个标称参数；所有类型族的参数都是标称值；并且所有类似GADT的参数都是标称值。然后，将这些事实传播到使用这些类型的所有地方。数据类型和同义词的默认角色是幻影；类的默认角色是名义角色。因此，对于数据类型和同义词，任何在右侧未使用（或仅在幻像位置的其他类型中使用）的参数都是幻像。每当在代表位置使用参数时（即，将其用作相应变量位于代表角色的构造函数的类型参数时），我们会将其角色从幻像提升为代表角色。同样，在标称位置使用参数时，其作用会升级为标称。我们绝不会将角色从名义降级为幻像或表象，或从表象降级为幻象。这样，我们就可以推断出每个参数的最一般的作用。</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">应该怎样 &lt;code&gt;Tricky&lt;/code&gt; 的角色是什么？乍一看，似乎 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都应该代表角色，因为两者都在右侧使用，并且都不涉及类型族。但是，这将是错误的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">应该怎样 &lt;code&gt;Tricky&lt;/code&gt; 的角色是什么？乍一看，似乎 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都应该代表角色，因为两者都在右侧使用，并且都不涉及类型家族。但是，这将是错误的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCi应该怎么做？严格来说，程序是模棱两可的。 &lt;code&gt;show (reverse [])&lt;/code&gt; （这是GHCi在这里计算的）的类型为 &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; ，其显示方式取决于类型 &lt;code&gt;a&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">如果将多个 &lt;code&gt;COMPLETE&lt;/code&gt; 集应用于单个模式集，应该怎么办？考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">我们收集的是什么样的堆资料?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskell编译器正确产生什么取决于所使用的后端代码生成器。有关更多详细信息，请参见&lt;a href=&quot;codegens#code-generators&quot;&gt;GHC后端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">用户在派生一个实例时明确要求的内容。</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">这让我们可以做的是把异构的值和一堆操作它们的函数打包在一起,然后以统一的方式处理这个包的集合。你可以用这种方式来表达不少类似面向对象的编程。</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">最后该怎么做。</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">如何处理 &lt;code&gt;m1&lt;/code&gt; 中的键而不是 &lt;code&gt;m2&lt;/code&gt; 中的键</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">如何处理 &lt;code&gt;m2&lt;/code&gt; 中的键而不是 &lt;code&gt;m1&lt;/code&gt; 中的键</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 中的键怎么办</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">如何处理非选项后的选项</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">该怎么处理文字。</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">我们展示的内容可以与任何 &lt;code&gt;make&lt;/code&gt; 搭配使用。</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">不同之处在于，我们现在使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 来引用参数（该参数以前 &lt;code&gt;a&lt;/code&gt; ），没有在任何地方按名称明确提及。并且我们使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 来引用 &lt;code&gt;Tree a&lt;/code&gt; 的递归使用。</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">无论目标线程在异常发生时正在做什么工作,都不会丢失:计算被暂停,直到另一个线程需要。</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;启用，使用 &lt;code&gt;anyclass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">当&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;启用时，一个模糊的领域必须出口作为其数据类型的一部分，而不是在顶层。例如，以下内容合法：</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">当&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，类型和种类变量可以explicily在相关的数据或类型的家庭情况必然以同样的方式（和相同限制）的&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;或&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;。例如，采用以上所述，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">当&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，左手侧使用的类型和种类变量可以明确的约束。例如：</target>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">当&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，在左侧使用种类或类型的变量可以明确的约束。例如：</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;启用，我们获得了NEWTYPE，然后使用 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">当&lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt;已启用，GHC打印 &lt;code&gt;RuntimeRep&lt;/code&gt; 类型变量轻浮，多态类型。否则，GHC将默认将它们设置为 &lt;code&gt;LiftedRep&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="5cd8e7617284a82575e75959536dc8754f27decc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;启用，使用 &lt;code&gt;anyclass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a39604dbdf930eeb49569712f91ae6fd1a07491" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicitly bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">当&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，类型和种类变量可以明确相关的数据或类型的家庭情况必然以同样的方式（和相同限制）的&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;或&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;。例如，采用以上所述，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="37685117656dc05c88d241b88847cf56b98f6523" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">当&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，左手侧使用的类型和种类变量可以明确的约束。例如：</target>
        </trans-unit>
        <trans-unit id="1700d840d06c00c9fb0b89fd7a848535205dcc1d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">当&lt;a href=&quot;exts/explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，明确量化类型变量也可以认定为闲置。例如：</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">当&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，明确量化类型变量也可以认定为闲置。例如：</target>
        </trans-unit>
        <trans-unit id="5311fb9fec0c8a69090b42668184cdd614a4ed78" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">当&lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;启用，我们获得了NEWTYPE，然后使用 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">当&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;启用，推断变量打印在括号中。因此，上一个示例中的数据构造函数 &lt;code&gt;Proxy&lt;/code&gt; 的类型将为 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; 。我们可以在GHCi会话中观察到这种行为：</target>
        </trans-unit>
        <trans-unit id="7e630e40474031593156647d2e58d26eafbc9c93" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-pgmc&lt;/code&gt; is used, GHC by default will never pass the &lt;code&gt;-no-pie&lt;/code&gt; command line flag. The rationale is that it is not known whether the specified compiler will support it. This flag can be used to indicate that &lt;code&gt;-no-pie&lt;/code&gt; is supported. It has to be passed after &lt;code&gt;-pgmc&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;-pgmc&lt;/code&gt; 时，默认情况下，GHC永远不会通过 &lt;code&gt;-no-pie&lt;/code&gt; 命令行标志。理由是尚不清楚指定的编译器是否支持它。此标志可用于指示支持 &lt;code&gt;-no-pie&lt;/code&gt; 。它必须在 &lt;code&gt;-pgmc&lt;/code&gt; 之后传递。</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
