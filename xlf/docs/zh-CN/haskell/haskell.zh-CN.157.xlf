<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="39accf2eb466f5f7950fa262a0b934abef85ea1f" translate="yes" xml:space="preserve">
          <source>Indicates if unlocking was successful, if not query getLastError.</source>
          <target state="translated">表示是否解锁成功,如果不成功则查询getLastError。</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">表示本次RunTH结束,下一条消息将是RunTH的结果(QResult)。</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">间接访问包括两个特殊目录 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 以及任何符号链接（和Windows上的连接点）。输入路径不必指向现有文件或目录。规范化是在指向现有文件或目录的路径的最长前缀上执行的。未指向现有文件或目录的路径的其余部分仍将被规范化，但由于无法在不存在的路径上执行，无法进行大小写规范化和间接删除。</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">构造函数的各个字段： &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">默认为本地绑定推导出较少的多态类型。</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="0fb53a8fadb337cee5f4d84c1662f6c7a3cd7d5a" translate="yes" xml:space="preserve">
          <source>Inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example is &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">推断的变量以大括号显示。因此，上一个示例中的数据构造函数 &lt;code&gt;Proxy&lt;/code&gt; 的类型为 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; 。我们可以在GHCi会话中观察到以下行为：</target>
        </trans-unit>
        <trans-unit id="89d01d742994f65d06832b042946ae6540ea435b" translate="yes" xml:space="preserve">
          <source>InferredSpec</source>
          <target state="translated">InferredSpec</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">从其他类型推断平等</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">推断并打印&amp;ldquo;类型&amp;rdquo;的类型。后者可以是任意类型表达式，包括类型构造函数（例如 &lt;code&gt;Either Int&lt;/code&gt; )的部分应用程序。实际上，&lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt;甚至允许您编写类型同义词的部分应用程序（通常是不允许的），这样可以工作：</target>
        </trans-unit>
        <trans-unit id="b107164b72629a12fc9de20620c30233bc8a18cb" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;exts/type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">推断并打印&amp;ldquo;表达式&amp;rdquo;的类型，但不必摆弄类型变量或类约束。当您使用&lt;a href=&quot;exts/type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;并注意指定的类型变量（适用于类型应用程序）和推断的类型变量（不可用）之间的区别时，这很有用。此模式有时会打印出可以轻松解决的约束（例如 &lt;code&gt;Show Int&lt;/code&gt; ），但是解决这些约束可能会影响类型变量，因此GHC会拒绝使用。</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">推断并打印&amp;ldquo;表达式&amp;rdquo;的类型，但不必摆弄类型变量或类约束。当您使用&lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;并注意指定的类型变量（适用于类型应用程序）和推断的类型变量（不可用）之间的区别时，这很有用。此模式有时会打印出可以轻松解决的约束（例如 &lt;code&gt;Show Int&lt;/code&gt; ），但是解决这些约束可能会影响类型变量，因此GHC会拒绝使用。</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">推断并打印&amp;ldquo;表达式&amp;rdquo;的类型，并在可能的情况下默认使用类型变量。在此模式下，如果推断的类型受任何交互式类（ &lt;code&gt;Num&lt;/code&gt; ， &lt;code&gt;Show&lt;/code&gt; ， &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Foldable&lt;/code&gt; 或 &lt;code&gt;Traversable&lt;/code&gt; ）的约束，则约束类型变量将根据&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;下描述的规则默认设置。当推断的类型非常通用时（例如 &lt;code&gt;foldr&lt;/code&gt; ），此模式非常有用，并且可能有助于查看更具体的实例。</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">推断并打印⟨expression⟩的类型,包括多态类型的显式forall量化器。所报告的类型是为赋值给表达式的变量所推断的类型,但没有应用单态限制。</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">无限字节字符串</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">无限清单</target>
        </trans-unit>
        <trans-unit id="51da236acb5f8cdb6fe7b72a8257afecb4400026" translate="yes" xml:space="preserve">
          <source>Infinite structures</source>
          <target state="translated">无限结构</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="1a2524f2cdc191259a8cb8d6d990ea9482634447" translate="yes" xml:space="preserve">
          <source>Infix version of &lt;code&gt;&lt;a href=&quot;ghc-io-subsystem#v:conditional&quot;&gt;conditional&lt;/a&gt;&lt;/code&gt;. posix &lt;a href=&quot;!&quot;&gt;!&lt;/a&gt; windows == conditional posix windows</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-subsystem#v:conditional&quot;&gt;conditional&lt;/a&gt;&lt;/code&gt; 句的中缀版本。posix &lt;a href=&quot;!&quot;&gt;！&lt;/a&gt;Windows ==条件posix Windows</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">非正式地， &lt;code&gt;Strict&lt;/code&gt; 语言扩展默认情况下将函数，数据类型和绑定设置为严格，通过在变量前面添加 &lt;code&gt;~&lt;/code&gt; 来允许可选的惰性。这从本质上扭转了默认情况，即懒惰是默认设置，可以通过添加 &lt;code&gt;!&lt;/code&gt; 在变量前面。</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">非正式地，默认情况下， &lt;code&gt;StrictData&lt;/code&gt; 语言扩展将数据类型声明更改为严格，允许在字段前面添加 &lt;code&gt;~&lt;/code&gt; 以使字段变得懒惰。</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">非正式地,如果我们有一个封闭的表达式</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">信息保存</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">有关接收到的信号的信息（源自 &lt;code&gt;siginfo_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">关于有幸运行你的程序的主机系统的特性信息。</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">关于你的电脑的信息。</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">特定于特定信号类型的信息（源自 &lt;code&gt;siginfo_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">继承父级的手柄</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">初始化一个面向行的用户交互会话。</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">将terminfo库初始化到给定的终端条目。</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;TERM&lt;/code&gt; 环境变量初始化terminfo库。如果未设置 &lt;code&gt;TERM&lt;/code&gt; ，则使用通用的最小条目 &lt;code&gt;dumb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">初始化您的&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;。这是可选的。</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">在单项型中注入一个值。</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">内射类型族通过 &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; 语言扩展启用。此扩展暗含 &lt;code&gt;-XTypeFamilies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">注射性注释</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">注射性注解添加在类型族头后,由两部分组成。</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">内联 &lt;code&gt;memcpy&lt;/code&gt; 调用，如果它们生成的伪指令不超过n个。</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">内联 &lt;code&gt;memset&lt;/code&gt; 调用，如果它们生成的伪指令不超过n个。</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">输入/输出</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">输入功能</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">输入字符串。</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">输入文本。</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">在底部表达式之后插入 &lt;code&gt;error&lt;/code&gt; 表达式；在调试编译器时很有用。</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">在向量的指定位置插入一个标量。</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; &amp;ldquo; &lt;code&gt;forall&lt;/code&gt; &amp;rdquo;被视为关键字，而与其他任何标志设置无关。此外，在&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;内部，自动启用了语言扩展&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;；请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法作用域类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94d741748ca5ae1bc40ce11d1afc506bcc3344ad" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt; &amp;ldquo; &lt;code&gt;forall&lt;/code&gt; &amp;rdquo;被视为关键字，而与其他任何标志设置无关。此外，在&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;内部，自动启用了语言扩展&lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;；请参阅&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;词法作用域类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;RULE&lt;/code&gt; 内部，&amp;ldquo; &lt;code&gt;forall&lt;/code&gt; &amp;rdquo;被视为关键字，而与其他任何标志设置无关。此外，在规则内部，语言扩展名&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;被自动启用。请参见&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法范围类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">在一个拼接内部,你只能调用导入模块中定义的函数,而不能调用同一模块中其他地方定义的函数。请注意,除了在顶层(在任何其他声明之外),任何地方都不允许声明拼接。</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">受论文《&lt;em&gt;具有重载和高阶多态性的函数编程》的&lt;/em&gt;启发，马克&amp;middot;P&amp;middot;琼斯（Mark P Jones）（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;），高级函数编程学院，1995年。</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">受论文《&lt;em&gt;具有重载和高阶多态性的功能编程》的&lt;/em&gt;启发，马克&amp;middot;P&amp;middot;琼斯（Mark P Jones）（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;），《功能编程高级学院》，1995年。</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">安装用于捕获^C的标准信号处理程序,它只是在目标线程中抛出一个异常。当前的目标线程是传递给installSignalHandlers的MVar中列表头部的线程。</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">也可以使用安全控制面板为系统全局关闭安装程序检测，但是默认情况下，GHC生成的二进制文件不依赖于已禁用安装程序检测的用户。</target>
        </trans-unit>
        <trans-unit id="221ab4fc522872824cd72443453566a64d62e095" translate="yes" xml:space="preserve">
          <source>Instance declarations</source>
          <target state="translated">实例声明</target>
        </trans-unit>
        <trans-unit id="799a53eb0cd003248b751073c77a5d5c34971dc1" translate="yes" xml:space="preserve">
          <source>Instance declarations are not allowed to be declared with nested &lt;a href=&quot;#id7&quot;&gt;&lt;span id=&quot;id8&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s or &lt;a href=&quot;#id9&quot;&gt;&lt;span id=&quot;id10&quot;&gt;``&lt;/span&gt;&lt;/a&gt;=&amp;gt;``s. For example, this would be rejected:</source>
          <target state="translated">实例声明不允许使用嵌套声明&lt;a href=&quot;#id7&quot;&gt;&lt;span id=&quot;id8&quot;&gt;``&lt;/span&gt;&lt;/a&gt; forall``s或&lt;a href=&quot;#id9&quot;&gt;&lt;span id=&quot;id10&quot;&gt;``&lt;/span&gt;&lt;/a&gt; =&amp;gt;``秒。例如，这将被拒绝：</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">实例声明只有在它们的头部完全相同的情况下才会被合并,所以有可能出现这样的情况:GHC认为一个签名中的实例是重叠的,即使它们是以非重叠的方式实现的。如果这给你带来了问题,请给我们打个招呼。</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">数据和新类型族的实例声明与标准数据和新类型声明非常相似。仅有的两个区别是关键字 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 后跟 &lt;code&gt;instance&lt;/code&gt; ，并且某些或所有类型参数可以是非变量类型，但可能不包含所有类型或类型同义词族。但是，通常在类型参数中允许使用数据族，并且只要它们被完全应用并扩展为本身允许的类型，就允许类型同义词，这与在类实例参数中出现类型同义词所必需的完全相同。例如， &lt;code&gt;GMap&lt;/code&gt; 的 &lt;code&gt;Either&lt;/code&gt; 实例是</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">类型族的实例声明与标准类型同义词声明非常相似。仅有的两个区别是关键字 &lt;code&gt;type&lt;/code&gt; 后面是 &lt;code&gt;instance&lt;/code&gt; ，并且某些或所有类型参数可以是非变量类型，但可能不包含所有类型或类型同义词族。但是，通常允许使用数据族，并且只要类型同义词完全应用并扩展为可允许的类型，就允许类型同义词-这些要求与数据实例完全相同。例如， &lt;code&gt;Elem&lt;/code&gt; 的 &lt;code&gt;[e]&lt;/code&gt; 实例是</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">实例详情</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">实例查询</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">实例类似于 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，例如给定数据类型</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">实例类似于 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，例如给定数据类型</target>
        </trans-unit>
        <trans-unit id="85623227591bc8f2cac930639d86e2c526f030d5" translate="yes" xml:space="preserve">
          <source>Instances can be derived automatically by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; extension. For example, a derived instance for a binary tree might be:</source>
          <target state="translated">通过启用 &lt;code&gt;DeriveFoldable&lt;/code&gt; 扩展名可以自动派生实例。例如，二叉树的派生实例可能是：</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">实例详情</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">可以为组成类型在 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 中的任何用户定义数据类型派生 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例。数据声明中构造函数的声明顺序确定派生 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例中的顺序。的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 数据类型允许单个比较，以确定两个对象的精确顺序。</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">可以为任何枚举类型（其构造函数没有字段的类型）派生 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 的实例。假定将 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt; 从fromEnum左右编号。有关更多详细信息，请参见&lt;em&gt;Haskell报告的&lt;/em&gt;第10章。</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">可以为任何枚举类型（其构造函数没有字段的类型）派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 的实例。假定将 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt; 从fromEnum左右编号。有关更多详细信息，请参见&lt;em&gt;Haskell报告的&lt;/em&gt;第10章。</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">可以为组成类型在 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 中的任何用户定义数据类型派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例。数据声明中构造函数的声明顺序确定派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例中的顺序。的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 数据类型允许单个比较，以确定两个对象的精确顺序。</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">实例 &lt;code&gt;Monoid&lt;/code&gt; 也应该是实例 &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">Binary的实例应满足以下属性。</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">这些类的实例可以由GHC带有&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;扩展名派生，并且对于能够自动定义通用实例是必需的。</target>
        </trans-unit>
        <trans-unit id="65c1e5f128f1f1839602ec922ecbb3d89a2bfa33" translate="yes" xml:space="preserve">
          <source>Instances should ensure that, in the following code:</source>
          <target state="translated">实例应确保,在下面的代码中。</target>
        </trans-unit>
        <trans-unit id="60ec83a7328fd0f4c726f4dd91a7d148a7b39c03" translate="yes" xml:space="preserve">
          <source>Instances should obey the following law:</source>
          <target state="translated">实例应遵守以下规律。</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">实例应满足以下法律，该法律规定 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 是monad的转换器：</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">实例应满足以下规律:</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">实例应满足以下条件:</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">实例应满足规律。</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">该实现提供了两种形式 &lt;code&gt;-&amp;lt;&lt;/code&gt; （一阶）和 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; （高阶），而不是带有两种翻译的单一形式的箭头应用程序（箭头尾）。</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">GHC不是创建一个可执行文件,而是产生一个带有这个链接器标志的共享对象。根据操作系统的目标,这可能是一个ELF DSO,一个Windows DLL,或者一个Mac OS dylib。GHC将操作系统的细节隐藏在这个统一标志之下。</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；当在 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数然后引用 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="4d75fde1ad8ce1fe9457a9340d10b92d1fe2f1c4" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了一个虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；在 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数随后引用 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 的参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；当在 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数然后引用 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="f408254609f2594f75fbcdb0b71c211f8a49859f" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了一个虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；在 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数随后引用 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 的参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">代替重新使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; ，使用单独的数据族 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; 来标记常见的未提升类型的出现：</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">而是使用 &lt;code&gt;case&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">相反，我们可以使用&lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt;命令。这可以运行范围内的任何 &lt;code&gt;main&lt;/code&gt; ，并且将任何参数与命令行参数一样对待，例如：</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">相反，我们提供了一个 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 函数，可以这样使用：</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">相反,你应该只捕捉你真正想要的异常。在这种情况下,这可能会比 &quot;任何IO异常 &quot;更具体;一个权限错误可能也希望以不同的方式处理。相反,你可能会想要这样的东西。</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">相反，您必须将 &lt;code&gt;foo&lt;/code&gt; 作为类操作编写，因此：</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="translated">指示&lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;尽可能使用 &lt;code&gt;Show&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">指示链接器生成一个与位置无关的可执行文件。</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">指示GHC考虑一个值特别便宜的内联。</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示GHC使用平台的本机矢量寄存器在函数调用期间传递矢量参数。与所有向量支持一样，这需要&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">指示GHC驱动程序不要删除其通常保存在 &lt;code&gt;/tmp&lt;/code&gt; 中的任何临时文件（或可能保存在其他地方；请参阅&lt;a href=&quot;#temp-files&quot;&gt;重定向临时文件&lt;/a&gt;）。使用 &lt;code&gt;-v&lt;/code&gt; 运行GHC 将向您显示在此过程中生成了哪些临时文件。</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="translated">指示LLVM代码生成器用垃圾填充无效的STG寄存器，而不是在调用中使用 &lt;code&gt;undef&lt;/code&gt; 。这使得捕获细微的代码生成器和运行时系统错误（例如，参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;＃11487&lt;/a&gt;）更加容易。</target>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">指示LLVM代码生成器用垃圾填充无效的STG寄存器，而不是在调用中使用 &lt;code&gt;undef&lt;/code&gt; 。这使得捕获细微的代码生成器和运行时系统错误更加容易（例如，参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue＃11487&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">指示编译器不要内联一个值。</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">指示编译器不要解包一个构造函数字段。</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">指示编译器将构造函数字段的内容解包到构造函数本身。</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">指示简化程序在继续进行空的案例分析时发出 &lt;code&gt;error&lt;/code&gt; 表达式（应该从底部开始，因此不返回）。当调试有时可能表现为分段错误的需求分析错误时，这很有用。</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">没有足够的资源来执行这项行动。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">Int结果</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="4764bca69c81c35d030020e51edddf17222f768e" translate="yes" xml:space="preserve">
          <source>Int32Rep</source>
          <target state="translated">Int32Rep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">整数结果</target>
        </trans-unit>
        <trans-unit id="5b14f5b085db1d133e9ea53c0ae99ca5b12454fa" translate="yes" xml:space="preserve">
          <source>Integers are stored in a kind of sign-magnitude form, hence do not expect two's complement form when using bit operations.</source>
          <target state="translated">整数是以一种符号大小的形式存储的,因此在使用位运算时,不要期待二的补码形式。</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">整数,支持整数除法。</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">整体类型</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">积分类型与指针之间的无损转换。</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">适用于带钉的阵列,否则非常不安全!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">交互模式-通常在运行 &lt;code&gt;ghci&lt;/code&gt; 时使用 ; 有关详细信息，请参见&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">交互模式，也可以作为&lt;strong&gt;ghci使用&lt;/strong&gt;。&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCi&lt;/a&gt;中更详细地描述了交互模式。</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">互动会议</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">由Haskell编译器产生的中间C文件。</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">加工管道中的中间结果。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">argv的内部编码</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">RTS用于运行火花的内部功能。</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">内部职能</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">内部执行</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">内部模块总是会随着版本的变化而变化。</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">内部模块总是会随着版本的变化而变化。这个模块的内容也是依赖于平台的,因此在Hackage文档中显示的内容可能会与您系统中实际可用的内容有所不同。</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">ShortByteString的内部表示</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">内部资料:支持ByteString FilePaths。</target>
        </trans-unit>
        <trans-unit id="cd6b4c82116a3ab03a952912381612ba9253116d" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC的内部仍然是第三个相等关系 &lt;code&gt;(~#)&lt;/code&gt; 。它是异构的（例如 &lt;code&gt;~~&lt;/code&gt; ），仅在内部使用。仅当启用&lt;a href=&quot;../using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;时，它才可能出现在错误消息和其他输出中。</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC的内部仍然是第三个相等关系 &lt;code&gt;(~#)&lt;/code&gt; 。它是异构的（如 &lt;code&gt;~~&lt;/code&gt; ），仅在内部使用。仅当启用&lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;时，它才可能出现在错误消息和其他输出中。</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 是缓冲区填充功能。它们由&lt;em&gt;驱动程序&lt;/em&gt;执行，该&lt;em&gt;驱动程序&lt;/em&gt;为它们提供了要填充的实际缓冲区。一旦使用缓冲区调用， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 就会对其进行填充，并向驱动程序返回信号，告知其已完成，已经填充了当前缓冲区或想要直接插入对内存块的引用。在最后两种情况下， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 还返回一个延续性 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，驱动程序可以调用它来填充下一个缓冲区。在这里，我们提供了满足几乎所有用例的两个驱动程序。有关微调它们的信息，请参见&lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">在内部，构建器通过逐个填充数组来构造惰性 &lt;code&gt;Text&lt;/code&gt; 。随着每个缓冲区的填充，它会被&amp;ldquo;弹出&amp;rdquo;，成为生成的惰性 &lt;code&gt;Text&lt;/code&gt; 的新块。这一切对 &lt;code&gt;Builder&lt;/code&gt; 的用户都是隐藏的。</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型表示为 &lt;code&gt;Word16&lt;/code&gt; UTF-16代码单元的数组。构造函数中的offset和length字段使用这些单位，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 的单位。</target>
        </trans-unit>
        <trans-unit id="52f341c327dc6a2b9f9f6adb900102322209af62" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型表示为 &lt;code&gt;Word16&lt;/code&gt; UTF-16代码单元的数组。构造函数中的offset和length字段使用这些单位，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 的单位。</target>
        </trans-unit>
        <trans-unit id="a667adfd3c426aaf0343e5e70da079f910efcf93" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型表示为 &lt;code&gt;Word16&lt;/code&gt; UTF-16代码单元的数组。构造函数中的offset和length字段使用这些单位，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 的单位。</target>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">在内部,这个函数每次从低级缓冲抽象中读取一个分块,并在整个文件被读取后将这些分块连成一个字符串。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; 模块的内部</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">与本地代码的互操作性</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 解释为1位位域</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 解释为1位位域</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">解释者单体</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">将标志解释为具体的值</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">将标志解释为选项记录的转换。</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">进程间通信</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">可中断的业务</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="a6ee111a4a83b6eb2aa173dcd6b41a0a9e1f3bf2" translate="yes" xml:space="preserve">
          <source>Interrupts the current wait of the I/O manager if it is currently blocked. This instructs it to re-read how much it should wait and to process any pending events. @since 4.15</source>
          <target state="translated">如果I/O管理器当前被阻塞,则中断其当前的等待。这将指示它重新读取应该等待的时间,并处理任何未决事件。从4.15开始</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">引进和消除 &lt;code&gt;ByteString&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">引入量化的约束条件主要有两个好处。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">引入LLVM,用垃圾填满死的STG寄存器。</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">直观地讲,它是一个双叉子,第一个和第二个参数都是共变的。</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">直观地，&lt;em&gt;产生&lt;/em&gt;了协变类型，而&lt;em&gt;消耗&lt;/em&gt;了协变类型。 Haskell中的大多数类型都是协变的，但是函数类型的特殊之处在于，函数箭头的左侧反转了方差。如果函数类型 &lt;code&gt;CovFun1&lt;/code&gt; &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 出现在协变位置（例如，上面的CovFun1），则 &lt;code&gt;a&lt;/code&gt; 处于协变位置， &lt;code&gt;b&lt;/code&gt; 处于协变位置。类似地，如果 &lt;code&gt;CovFun2&lt;/code&gt; &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 出现在 &lt;code&gt;a&lt;/code&gt; 协变位置（例如，上面的CovFun2），则 &lt;code&gt;a&lt;/code&gt; 处于一个协变位置，而 &lt;code&gt;b&lt;/code&gt; 处于一个协变位置。</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="f30f94b5e7824cc91a857050e0c882e98ceaff86" translate="yes" xml:space="preserve">
          <source>Invariant (canonical representation): higher Word# is non-zero.</source>
          <target state="translated">不变性(规范表示):高位字#是非零。</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">不变式：使用 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 时，如果值不适用于 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">不变式：使用 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 时，如果值不适用于 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca711904cd0afb5b4429984b51cd06c6731bc80" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">不变式：如果 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; 值不适合 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt; ,则使用IP和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4be325aac9fdf79f01267a725e7d6afb3b543711" translate="yes" xml:space="preserve">
          <source>Invariant: A &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; must not be associated with more than one set of finalizers. For example, this is sound:</source>
          <target state="translated">不变： &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 不得与一组以上的终结器关联。例如，这是声音：</target>
        </trans-unit>
        <trans-unit id="e47339e1c6fcd41f40ed2907ae6002b9cec9f6cc" translate="yes" xml:space="preserve">
          <source>Invariant: The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; in the parent &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is an interior pointer into this &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不变式： &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 父 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 是一个内部指针到这个 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="668f4200fec0082e9da84453223afa7cc5f74c18" translate="yes" xml:space="preserve">
          <source>Invariant: The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; is pinned, so the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; does not get invalidated by the GC moving the byte array.</source>
          <target state="translated">不变的： &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 是固定的，因此 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 不会因为GC移动字节数组而变得无效。</target>
        </trans-unit>
        <trans-unit id="d89008df010ecfe1f3e53e4fcbfa9a63476eae95" translate="yes" xml:space="preserve">
          <source>Invariant: numbers &amp;lt;= 0xffffffffffffffff use the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Natural.html#v:NS&quot;&gt;NS&lt;/a&gt;&lt;/code&gt; constructor</source>
          <target state="translated">不变式：数字&amp;lt;= 0xffffffffffffffff使用 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Natural.html#v:NS&quot;&gt;NS&lt;/a&gt;&lt;/code&gt; 构造函数</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">所有函数都必须保持的不变量。</target>
        </trans-unit>
        <trans-unit id="d29df8c63e237c937395d3a2b73f553b2eedce66" translate="yes" xml:space="preserve">
          <source>Invoke a finalizer once a foreign pointer becomes unreachable.</source>
          <target state="translated">一旦外来指针无法到达,就调用定标器。</target>
        </trans-unit>
        <trans-unit id="2306eeb4a0ccc3ac5701782ba0b1a5d4ccbb6396" translate="yes" xml:space="preserve">
          <source>IoNative</source>
          <target state="translated">IoNative</target>
        </trans-unit>
        <trans-unit id="0ed195ad462ef61e760c5ac5c767ddb7f63f43d3" translate="yes" xml:space="preserve">
          <source>IoPOSIX</source>
          <target state="translated">IoPOSIX</target>
        </trans-unit>
        <trans-unit id="96608860edbeb0fe5691c8761e4f0a05b3d1fe32" translate="yes" xml:space="preserve">
          <source>Irrefutable patterns must be written in prefix form:</source>
          <target state="translated">不可反驳的模式必须以前缀形式书写。</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">是 &lt;code&gt;Tricky Nom Age&lt;/code&gt; 表象等于 &lt;code&gt;Tricky Nom Int&lt;/code&gt; ？没有！前者存储 &lt;code&gt;Char&lt;/code&gt; ，后者存储 &lt;code&gt;Bool&lt;/code&gt; 。解决方案是要求所有参数键入变量以具有名义角色。因此，GHC会推断 &lt;code&gt;a&lt;/code&gt; 代表角色但 &lt;code&gt;b&lt;/code&gt; 象征角色。</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">一个FilePath是否有效,也就是说,你可以创建一个类似的文件吗?这个函数检查无效名称和无效字符,但不检查是否超过长度限制,因为这些通常取决于文件系统。</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">路径是相对的,还是固定在根上?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">元素是一种驱动力吗?</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">一个项目是目录还是最后一个字符是路径分隔符?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">是否启用了事件追踪?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="90aec48d5d510f6afeff95f6a4779d93a0f6d310" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="a17deabcb706cd08d6fb17b66ea46acf00398ab4" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="476e0bb47bf942bb152bfeaaa1e1a912cbba5ab8" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及其他许多常见情况下，生成的monad已经被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">这个字符是文件分隔符吗?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">这个角色是扩展角色吗?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">手柄是否连接到终端?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 返回的实例列表是非空的吗？</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 返回的实例列表是非空的吗？</target>
        </trans-unit>
        <trans-unit id="0d2adc690f10a7f72a0ff52f81eef4c6e91e521a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity by looking at the surrounding whitespace:</source>
          <target state="translated">这是中缀函数&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;还是带爆炸模式的&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;的定义？GHC通过查看周围的空白解决了这种歧义：</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">这是中缀函数&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;还是带爆炸模式的&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;的定义？GHC解决了这种歧义，支持后者。如果要在启用爆炸模式的情况下定义 &lt;code&gt;(!)&lt;/code&gt; ，则必须使用前缀表示法：</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">这是孤立模块吗？显然不是，因为 &lt;code&gt;T&lt;/code&gt; 是在同一模块中声明的。但是，假设类 &lt;code&gt;E&lt;/code&gt; 具有功能依赖性：</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">该计划是否与GHC RTS相关联？（始终为&amp;ldquo;是&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">这个时区就这样坚持到了夏天吗?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">按照无序的格里高利历,今年是闰年吗?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">按照无序的朱利安历,今年是闰年吗?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">是转化为。</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">在单项计算中用于开始异常处理。</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">隔离解码器以固定的字节数进行操作，如果消耗较少的字节或尝试消耗更多的字节，则会失败。如果给定的解码器失败， &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 也会失败。与 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; 的偏移量将相对于 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 的开始，而不是输入的绝对值。</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">如果被编译的模块被标记为-XTrustworthy,但它可能被标记为-XSafe,一个更有信息量的绑定,则发出警告。可以用来检测一旦安全的 Haskell 绑定是否可以随着依赖关系的更新而改进。</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">如果正在编译的模块被认为是安全的,则发出警告。当使用安全推理时,应该用来检查模块的安全类型。</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="translated">如果正在编译的模块被认为是安全的,则发出警告。当使用安全推理时,应该用来检查模块的安全类型。如果模块被明确标记为安全,则不会发出警告。</target>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">如果正在编译的模块被认为是不安全的,则发出警告。当使用安全推理时,应该用来检查模块的安全类型。</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">它出现在绑定至少一个使用过的变量的右手边,该变量被用于</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">它也可以放在类型级函数的右侧,为无效的情况提供一个错误。</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">它还可以通过第三种方式提供帮助：与&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 一起使用&lt;/a&gt;（请参阅&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;）时，可以在构造函数中将严格的字段拆包或拆箱，并且可能会进行一个或多个间接级别被删除。仅对单构造函数数据类型进行解压缩（例如， &lt;code&gt;Int&lt;/code&gt; 是一个不错的选择）。</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">它可以用任何方式，任何超类集和方法来实现。但是，不允许依赖抽象类的模块定义实例（从GHC 8.2开始，不检查此限制，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;＃13086&lt;/a&gt;。）这些声明可以由 &lt;code&gt;Constraint&lt;/code&gt; 类型的同义词实现。如果要对函数约束进行参数化，这将很有用。例如，使用 &lt;code&gt;ConstraintKinds&lt;/code&gt; 扩展，此类型同义词是上述签名的有效实现：</target>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">它可以用任何方式，任何超类和方法来实现。但是，不允许依赖抽象类的模块定义实例（从GHC 8.2开始，不检查此限制，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;问题＃13086&lt;/a&gt;。）这些声明可以由 &lt;code&gt;Constraint&lt;/code&gt; 类型的同义词实现。如果要对函数约束进行参数化，这将很有用。例如，使用 &lt;code&gt;ConstraintKinds&lt;/code&gt; 扩展，此类型同义词是上述签名的有效实现：</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它可以用作基础monad，可以将一系列monad变压器应用于该monad以构造复合monad。大多数monad转换器模块包括将转换器应用于 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的特殊情况。例如， &lt;code&gt;State s&lt;/code&gt; 是 &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">它可以与由漏子或单子类参数化的函数一起使用。</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">有时，有效孔配合的名称和类型可能不足以实现该配合的含义。如果提供了适合的文档，则此标志会将其添加到消息中（并且使用 &lt;code&gt;-haddock&lt;/code&gt; 标志编译了函数所在的模块）。</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">确实存在绑定类型变量&lt;em&gt;一定不在&lt;/em&gt;范围内似乎很奇怪。相比之下，通常名称绑定仅在同名外部变量的范围内产生阴影（&amp;ldquo;打洞&amp;rdquo;）。但是我们必须有&lt;em&gt;某种&lt;/em&gt;方法将这些类型变量带入范围，否则我们将无法在后续的类型签名中命名存在绑定的类型变量。</target>
        </trans-unit>
        <trans-unit id="cd0b20dc53b3f56118493854441da04b5d5caf19" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallel on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">它启用了&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;，从而允许线程在多处理器或多核计算机上并行运行。请参阅&lt;a href=&quot;#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">它启用了&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;，从而允许线程在多处理器或多核计算机上并行运行。请参阅&lt;a href=&quot;#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">它启用了 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS选项，该选项允许线程在多处理器或多核计算机上并行运行。请参阅&lt;a href=&quot;using-concurrent#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">它保证了每次施力的结果都是以弱头正常的形式进行的。</target>
        </trans-unit>
        <trans-unit id="6cc40bdad8257aec1a113a8cf6c4f9244f5bbe8e" translate="yes" xml:space="preserve">
          <source>It forces the result of each application of the function to weak head normal form (WHNF) before proceeding.</source>
          <target state="translated">它将每次应用函数的结果强制为弱头正态形式(WHNF)后再进行。</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">它具有比 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 更低的内存开销，并且不会导致堆碎片。可以将其转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 或从ByteString转换（以复制字符串数据为代价）。它支持很少的其他操作。</target>
        </trans-unit>
        <trans-unit id="4477cc94d81fac95238764279438f0a0ecec3424" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">它具有比 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 更低的内存开销，并且不会导致堆碎片。可以将其转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 或从ByteString转换（以复制字符串数据为代价）。它支持很少的其他操作。</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="translated">它已被复制到一个紧凑的区域中。 &lt;code&gt;ghc-compact&lt;/code&gt; 和 &lt;code&gt;compact&lt;/code&gt; 的文档描述了此过程。</target>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">它忽略了闰秒,所以它不一定是一个固定的时钟时间量。例如,23:00 UTC+2小时的NominalDiffTime=01:00 UTC (+1天),不管是否有闰秒的间隔。</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">这是&lt;em&gt;你的责任&lt;/em&gt;，以确保 &lt;code&gt;intLookup&lt;/code&gt; 真正表现为一个专业版本 &lt;code&gt;genericLookup&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">它是&lt;em&gt;根集&lt;/em&gt;的成员。</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。比&lt;em&gt;groupBy（==）&lt;/em&gt;快40％&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。如果在第一个列表和第二个列表中均找到该元素，则将使用第一个列表中的元素。</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。如果在第一个列表和第二个列表中均找到该元素，则将使用第一个列表中的元素。</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">它是一个弱指针对象,其密钥是可以到达的。</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">库作者也可以指示GHC非常积极地执行呼叫模式专业化。对于某些高度优化的库而言，这是必需的，我们可能希望对其进行专化，而不考虑专长的数量或代码的大小。例如，考虑 &lt;code&gt;vector&lt;/code&gt; 库中的简化用例：</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">也可以通过不同的标准来分解堆在这些状态中的一个或多个状态,通过传记来限制配置文件。例如,按生产者来显示堆中处于拖动或无效状态的部分。</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">也可以将运行时整数或字符串值转换为相应的类型级别文字。当然，结果类型文字在编译时将是未知的，因此将其隐藏在存在类型中。可以通过将 &lt;code&gt;someNatVal&lt;/code&gt; 用于整数，将 &lt;code&gt;someSymbolVal&lt;/code&gt; 用于字符串来执行转换：</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">也可以定义模式同义词,它的行为就像记录构造函数一样。这样做的语法如下。</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">也可以在导出列表中使用特殊标记 &lt;code&gt;..&lt;/code&gt; 来表示当前捆绑的所有构造函数。例如，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="translated">如果 &lt;code&gt;qualified&lt;/code&gt; 在阳性前后都出现，这是一个错误。</target>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">可以想象将来会放宽此限制，但是（在撰写本文时）尚不清楚围绕此场景的困难是否是理论上的（推断这种依赖性将意味着我们的类型系统没有主体类型）或仅是实际的（鉴于GHC的实现，很难推断出这种依赖性）。因此，GHC可以轻松解决问题，并且需要用户的一点帮助。</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">它当前以 &lt;code&gt;Array ix (TVar e)&lt;/code&gt; ，但是将来可能会被更有效的实现方式替代（但是接口将保持不变）。</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">它是由一个可到达的对象直接指向的,而不是一个弱指针对象。</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">它通过扩展名&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; 编译指示启用。（相同的扩展名启用了 &lt;code&gt;mdo&lt;/code&gt; -notation和 &lt;code&gt;do&lt;/code&gt; 内部的 &lt;code&gt;rec&lt;/code&gt; 块的使用。表达式。）</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;data-list#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;data-list#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;ghc-list#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;ghc-list#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;prelude#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;prelude#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">该运算符必须在 &lt;code&gt;e&lt;/code&gt; 中是多态的（表示输入到命令的环境以及从其到子命令的环境）并满足相应的自然属性</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">预计这一操作将在未来的Haskell修订版中被取代。</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">它是出口的,或</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">&lt;em&gt;可能&lt;/em&gt;存在重叠的&lt;em&gt;可能&lt;/em&gt;（例如，同时声明（A）和（B））；仅当特定约束匹配多个时，才报告错误。</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">重要的是要注意 &lt;code&gt;-O*&lt;/code&gt; 标志大致等同于 &lt;code&gt;-f*&lt;/code&gt; 标志的组合。因此， &lt;code&gt;-O*&lt;/code&gt; 和 &lt;code&gt;-f*&lt;/code&gt; 标志的效果取决于它们在命令行上出现的顺序。</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="translated">它是大对象。目前,GHC对大对象的定义是:至少有4KB块的80%大(即至少3277字节)。</target>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">有必要进行迭代，而不是使用方程式函数定义。当与 &lt;code&gt;t&lt;/code&gt; 匹配时情况甚至更糟被埋在另一个模式的深处。</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">它没有比使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 更快</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它没有比使用 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">并不总是需要为所有的通用表示类型提供实例,但省略实例会限制函数工作的数据类型集。</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">不能保证最终的定标器最终会运行,而且当程序退出时,不会尝试运行未完成的定标器。因此,不应该依靠最终处理程序来清理资源--除了最终处理程序之外,还应该采用其他方法(例如异常处理程序)。</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">不建议将Makefile的所有内容都移到源文件中，但是在某些情况下， &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译指示是正确的选择。（如果使用&lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt;并在模块中具有 &lt;code&gt;OPTION&lt;/code&gt; 标志，则 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 将放入生成的 &lt;code&gt;.hc&lt;/code&gt; 文件中）。</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">这是很方便的同时使用这些功能 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">这是很方便的同时使用这些功能 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">通常情况下,改变交互式选项是很有用的,而不需要将该选项也应用到已加载的模块中。例如</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">声明 &lt;code&gt;IsList&lt;/code&gt; 的新实例非常好，这样列表符号对于全新的数据类型很有用。这是几个示例实例：</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">允许使用GADT样式的语法声明普通的代数数据类型。使GADT成为GADT的原因不是语法，而是其结果类型不只是 &lt;code&gt;T a b&lt;/code&gt; 的数据构造函数的存在。</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">拼接有可能扩展到一个表达式,该表达式包含的名称在拼接处不在范围内。作为一个例子,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">定义关联类型的类可以为关联类型实例指定一个默认值。所以,例如,这是确定的。</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">通过使用软件包，您可能最终得到一个包含两个具有相同名称的模块的程序：也许您使用了具有&lt;em&gt;隐藏&lt;/em&gt;模块 &lt;code&gt;M&lt;/code&gt; 的软件包 &lt;code&gt;P&lt;/code&gt; ，并且程序中也存在模块 &lt;code&gt;M&lt;/code&gt; 。或者您使用的软件包的依赖项包含一些重叠的模块。由于其他软件包的依赖性，该程序甚至可能包含某个软件包的多个版本。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">可以要求RTS提供一些有关其自身的信息。为此，请使用&lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;标志，例如</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 类型，可以捕获所有异常：</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">可以用 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 链接 &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="de29d8a86d26aa4a500950a6e0de53b7d124ad27" translate="yes" xml:space="preserve">
          <source>It is possible to extract a value of type &lt;code&gt;m Exp&lt;/code&gt; from &lt;code&gt;Code m a&lt;/code&gt; using the &lt;code&gt;unTypeCode :: Code m a -&amp;gt; m Exp&lt;/code&gt; function.</source>
          <target state="translated">可以使用 &lt;code&gt;unTypeCode :: Code m a -&amp;gt; m Exp&lt;/code&gt; 函数从 &lt;code&gt;Code m a&lt;/code&gt; 提取类型为 &lt;code&gt;m Exp&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">在类型或类声明中引入的类型变量之间有可能得到复杂的依赖关系。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="dedaac9870154cb1e43ca5bf912ba5696270690e" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;../runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">可以从运行时统计信息中收集一些有关 &lt;code&gt;par&lt;/code&gt; 工作情况的信息。请参阅&lt;a href=&quot;../runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">可以从运行时统计信息中收集一些有关 &lt;code&gt;par&lt;/code&gt; 工作情况的信息。请参阅&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82c8e6ba79f13f4308db35903d0f8010b8c6598a" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;exts/ffi#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">可以在其他不是用Haskell编写的程序中加载GHC生成的共享库，因此它们适合用作插件。当然，要构建插件，您将必须使用FFI导出C函数并遵循有关初始化RTS的规则。请参阅&lt;a href=&quot;exts/ffi#ffi-library&quot;&gt;制作可从外部代码调用的Haskell库&lt;/a&gt;。特别是，您可能需要从共享库中导出C函数，以在调用任何Haskell函数之前初始化插件。</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">可以在其他不是用Haskell编写的程序中加载GHC生成的共享库，因此它们适合用作插件。当然，要构建插件，您将必须使用FFI导出C函数并遵循有关初始化RTS的规则。请参阅&lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;制作可从外部代码调用的Haskell库&lt;/a&gt;。特别是，您可能需要从共享库中导出C函数，以在调用任何Haskell函数之前初始化插件。</target>
        </trans-unit>
        <trans-unit id="a1594eefc0a39a04b21198840922dcc7bcda370e" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;../debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">通过使用&lt;a href=&quot;../debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt;可以看到实际的翻译，但请注意，输出非常冗长。</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">通过使用&lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt;可以看到实际的翻译，但请注意，输出非常冗长。</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">可以使用调试器来检查函数值。当我们处于断点处,一个函数处于范围内时,调试器不能向你展示它的源代码;但是,通过将它应用于一些参数并观察结果,可以得到一些信息。</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">可以写一个数据类型,它在语法上有一个CUSK(根据上面的规则),但实际上需要一些推理。作为一个非常简单的例子,考虑一下</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">假设您将源文件命名为与模块相同，则设置 &lt;code&gt;Makefile&lt;/code&gt; 与GHC一起使用非常简单。从而：</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">建议将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 设置为二进制和 &lt;code&gt;BlockBuffering&lt;/code&gt; 模式。请参见 &lt;code&gt;hSetBinaryMode&lt;/code&gt; 和 &lt;code&gt;hSetBuffering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">建议将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 设置为二进制和 &lt;code&gt;BlockBuffering&lt;/code&gt; 模式。请参见 &lt;code&gt;hSetBinaryMode&lt;/code&gt; 和 &lt;code&gt;hSetBuffering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9cf0e87fcc8c4aca3617d4a5dc0deb83f6cef9b" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; mode. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBuffering&quot;&gt;hSetBuffering&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">建议将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 设置为二进制和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; 模式。请参见 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:hSetBuffering&quot;&gt;hSetBuffering&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">强制使用 &lt;code&gt;C&lt;/code&gt; 的每种方法都是安全的。也就是说，缺少的最后一个参数 &lt;code&gt;C&lt;/code&gt; 不是以任何名义角色使用 &lt;code&gt;C&lt;/code&gt; 的方法。（请参阅&lt;a href=&quot;#roles&quot;&gt;角色&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9dae310ee0c9c0d6c351f210e6b5d84bf1211c9d" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;roles#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">强制使用 &lt;code&gt;C&lt;/code&gt; 的每种方法都是安全的。也就是说，缺少的最后一个参数 &lt;code&gt;C&lt;/code&gt; 不是以任何名义角色使用 &lt;code&gt;C&lt;/code&gt; 的方法。（请参阅&lt;a href=&quot;roles#roles&quot;&gt;角色&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">强制使用 &lt;code&gt;C&lt;/code&gt; 的每种方法都是安全的。也就是说，缺少的最后一个参数 &lt;code&gt;C&lt;/code&gt; 不是以任何名义角色使用 &lt;code&gt;C&lt;/code&gt; 的方法。（请参阅&lt;a href=&quot;#roles&quot;&gt;角色&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">在对外调用过程中临时修改浮点单位状态是安全的,因为对外调用永远不会被GHC抢先。</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">它类似于 &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; ,但速度较慢。它的优点是与C兼容。</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;派生实例时，有时必须启用其他语言扩展。例如，考虑使用&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;语法的简单类和实例：</target>
        </trans-unit>
        <trans-unit id="1600f03c1044e49fbd598b16e83434840c44835b" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;派生实例时，有时必须启用其他语言扩展。例如，考虑使用&lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;语法的简单类和实例：</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">有时使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 构造参数名称很有用以确保我们从正确的名称空间进行验证。例如，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">有时使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 构造自变量名称很有用，以确保我们从正确的名称空间进行验证。例如，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">如果可能的话，强烈建议使用&lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;的更安全的monadic API ，而不要使用此模块的显式状态管理功能。</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">它适合用作需要在内存中保留许多短字符串的代码的内部表示形式，但&lt;em&gt;不应&lt;/em&gt;用作交换类型。也就是说，一般不应在公共API中使用它。的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 类型通常更适合于使用的接口; 它更加灵活，并且支持多种操作。</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">它适用于纯代码。在IO上下文中，使用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">它是一个弱指针对象的值或定标,其键是可以到达的。</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">哪个线程接收此异常是不确定的。GHC当前将其扔给接收 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 的同一线程，但是将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">哪个线程接收此异常是不确定的。GHC当前将其扔给接收 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 的同一线程，但是将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">与GH的其他非 &lt;code&gt;INLINE&lt;/code&gt; 函数一样，如果最终调用 &lt;code&gt;f&lt;/code&gt; 的非内联版本，则GHC可以优化INLINE函数 &lt;code&gt;f&lt;/code&gt; 的定义非常有用。但是我们不想内联 &lt;code&gt;f&lt;/code&gt; 的&lt;em&gt;优化&lt;/em&gt;版本； &lt;code&gt;INLINE&lt;/code&gt; 编译指示的主要原因是要在 &lt;code&gt;f&lt;/code&gt; 的RHS中公开具有重写规则的函数，并且如果这些函数没有被优化，那就不好了。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">与GH的其他非 &lt;code&gt;INLINE&lt;/code&gt; 函数一样，如果最终调用 &lt;code&gt;f&lt;/code&gt; 的非内联版本，则GHC可以优化INLINE函数 &lt;code&gt;f&lt;/code&gt; 的定义，这很有用。但是我们不想内联 &lt;code&gt;f&lt;/code&gt; 的&lt;em&gt;优化&lt;/em&gt;版本；进行 &lt;code&gt;INLINE&lt;/code&gt; 编译的一个主要原因是要在 &lt;code&gt;f&lt;/code&gt; 的RHS中公开具有重写规则的功能，如果这些功能没有被优化，那就不好了。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3b833a6a7471fbafdafb50780dec24992986833" translate="yes" xml:space="preserve">
          <source>It is useful for modelling any computation that is allowed to fail.</source>
          <target state="translated">它对于模拟任何允许失败的计算都是有用的。</target>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 视为不是完全防止异步异常的方法，而是将其从异步模式切换为轮询模式的方法很有用。异步异常的主要困难是它们通常可以在任何地方发生，但是在 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，异步异常仅由可中断的操作（或调用其他可中断的操作）引发。在许多情况下，这些操作本身可能会引发异常，例如I / O错误，因此调用者通常会准备好处理由于该操作引起的异常。要对 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 中的异步异常执行显式轮询，请使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="translated">值得一提的是，&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;是&lt;em&gt;不是&lt;/em&gt;需要给数据家庭本身返回涉及多种 &lt;code&gt;TYPE&lt;/code&gt; ，如 &lt;code&gt;FooKey&lt;/code&gt; 和 &lt;code&gt;BarType&lt;/code&gt; 的例子以上。仅对于新类型 &lt;code&gt;newtype instance&lt;/code&gt; 声明（例如，上面的 &lt;code&gt;FooKeyBoolC&lt;/code&gt; 和 &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; ）才需要该扩展。</target>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">对于共享对象，值得注意的是，当每个包都构建为单个共享对象文件时，由于对共享对象的引用需要额外的间接调用，因此包内引用比包间引用便宜。当然，这也适用于 &lt;code&gt;main&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="54a6b23a21fda9c044fe0d97ce9ef235ca220f49" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;../win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">并非总是可能会强行终止Haskell线程：例如，该线程当前可能正在执行外部调用，而我们没有办法强制完成外部调用。此外，运行时必须假定在最坏的情况下Haskell代码和运行时将要从内存中删除（例如，如果这是&lt;a href=&quot;../win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;，则通常在卸载DLL之前会调用 &lt;code&gt;hs_exit()&lt;/code&gt; ）。因此， &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;等待所有未完成的外部调用返回，然后才能返回自身。</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">并非总是可能会强行终止Haskell线程：例如，该线程当前可能正在执行外部调用，而我们无法强制外部调用完成。此外，运行时必须假定在最坏的情况下Haskell代码和运行时将要从内存中删除（例如，如果这是&lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;，则通常在卸载DLL之前会调用 &lt;code&gt;hs_exit()&lt;/code&gt; ）。因此 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;等待所有未完成的外部调用返回，然后才能返回自身。</target>
        </trans-unit>
        <trans-unit id="8458bc24663504817189be36256a7f90d9fdfdc9" translate="yes" xml:space="preserve">
          <source>It loops indefinitely; every time a key is pressed, it will print that key as it was recognized by Haskeline. Pressing Ctrl-C will stop the loop.</source>
          <target state="translated">它无限循环;每按一次键,它就会打印出Haskeline识别的那个键。按Ctrl-C可以停止循环。</target>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">它还可能会输出一个C文件，其中包含要链接到程序中的其他C函数，以及一个C头文件，该文件头包含在Haskell模块将被编译到的C代码中（通过C编译时）和C文件中。 。这两个文件是在使用 &lt;code&gt;#def&lt;/code&gt; 构造时创建的（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="translated">它可能会出现诱人使用 &lt;code&gt;DllMain&lt;/code&gt; 调用 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; ，但这是不行的（特别是如果你有编译 &lt;code&gt;-threaded&lt;/code&gt; ）。在 &lt;code&gt;DllMain&lt;/code&gt; 期间可以执行哪些操作有严格的限制，并且 &lt;code&gt;hs_init&lt;/code&gt; 违反了这些限制，这可能导致您的DLL在启动过程中冻结（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;＃3605&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">它可能会出现诱人使用 &lt;code&gt;DllMain&lt;/code&gt; 调用 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; ，但这是不行的（特别是如果你有编译 &lt;code&gt;-threaded&lt;/code&gt; ）。在 &lt;code&gt;DllMain&lt;/code&gt; 期间可以执行哪些操作有严格的限制，并且 &lt;code&gt;hs_init&lt;/code&gt; 违反了这些限制，这可能导致您的DLL在启动过程中冻结（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;问题＃3605&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">可能需要指出的是,假设</target>
        </trans-unit>
        <trans-unit id="f48419fb8305c7fcc0e8958cac1ac07d41e90892" translate="yes" xml:space="preserve">
          <source>It may still terminate under one of the following conditions:</source>
          <target state="translated">有下列情况之一的,仍可终止:</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">似乎&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; 和&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 会&lt;/a&gt;做类似的事情：您可以同时使用两者将模块引入作用域。但是，有一个非常重要的区别。GHCi与两套模块有关：</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">必须是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 具有相同的种类。还要注意， &lt;code&gt;b&lt;/code&gt; 以 &lt;code&gt;c&lt;/code&gt; 的类型隐式声明。因此，根据我们的一般原则， &lt;code&gt;b&lt;/code&gt; 必须&lt;em&gt;在&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。但是， &lt;code&gt;b&lt;/code&gt; &lt;em&gt;取决于&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 。因此，我们以适当的错误消息拒绝 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">必须是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 具有相同的种类。还要注意， &lt;code&gt;b&lt;/code&gt; 是 &lt;code&gt;c&lt;/code&gt; 的隐式声明。因此，根据我们的一般原则， &lt;code&gt;b&lt;/code&gt; 必须&lt;em&gt;在&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。但是， &lt;code&gt;b&lt;/code&gt; &lt;em&gt;取决于&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 。因此，我们以适当的错误消息拒绝 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">它返回实际读取的字节数。如果在读取任何数据之前已达到EOF（或 &lt;code&gt;count&lt;/code&gt; 为零），则该值为零。</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">事实证明，这样的递归绑定确实适用于各种monad，但不是全部。特别是，从这种意义上讲，递归需要底层 &lt;code&gt;mfix&lt;/code&gt; 的定点运算符，该常量由 &lt;code&gt;MonadFix&lt;/code&gt; 类的mfix方法捕获，该类在 &lt;code&gt;Control.Monad.Fix&lt;/code&gt; 中定义如下：</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="translated">它是由 &lt;code&gt;newPinnedByteArray#&lt;/code&gt; 分配的。</target>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">它将在启动GHCi的当前文件夹中创建 &lt;code&gt;.ghci-history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">然后，它将适当地将各个条目和成对的条目传递给 &lt;code&gt;g1&lt;/code&gt; ， &lt;code&gt;g2&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">对于GHCi，最好记录每个模块中的默认设置，并使用&amp;ldquo;当前&amp;rdquo;模块（无论是哪个）的默认设置。</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">使用远程安装的磁盘在快速的计算机上进行&lt;em&gt;编译&lt;/em&gt;是非常明智的。然后&lt;em&gt;链接&lt;/em&gt;到直接安装了磁盘的慢速计算机上。</target>
        </trans-unit>
        <trans-unit id="8a7b6b7d9f87d44e8662ce4bef918aef2f8488ae" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;exts/let_generalisation#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">如果将&lt;a href=&quot;exts/let_generalisation#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;也应用于加载的模块，也是不希望的：这可能会导致编译错误，但更常见的是，它将导致额外的重新编译，因为GHC认为由于标志已更改，因此需要重新编译模块。</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">如果&lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;也要应用于加载的模块，那将是不希望的：这可能会导致编译错误，但更常见的是，它将导致额外的重新编译，因为GHC认为由于标志已更改，因此需要重新编译模块。</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">如果函数严格限制为单构造函数类型（一种只有一个数据构造函数的类型；例如，元组是单构造函数类型），那就更好了。</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">可以使用新的 &lt;code&gt;rec&lt;/code&gt; 关键字进行相互递归绑定，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">可以肯定地说 &lt;code&gt;a==b&lt;/code&gt; 或 &lt;code&gt;p==q&lt;/code&gt; ，但是 &lt;code&gt;a==q&lt;/code&gt; 是错误的，因为它等同于两个 &lt;code&gt;Baz1&lt;/code&gt; 构造函数产生的两种不同类型。</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">丑陋而缓慢。</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">建议避免为小整数调用 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; ，因为此函数当前会将它们转换为msbf中的大整数，以调用 &lt;code&gt;mpz_export()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">值得注意的是，如果对于某些 &lt;code&gt;(x,y)&lt;/code&gt; ， &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt; ，结果的大小可能会更小</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">项目(IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">迭代结构</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">J. Nievergelt和EM Reingold，&amp;ldquo; &lt;em&gt;有限平衡的二叉搜索树&lt;/em&gt; &amp;rdquo;，SIAM计算杂志2（1），1973年3月。</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">约翰&amp;middot;蒂贝尔（Johan Tibell）&amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">加入一个驱动器和其余的路径。</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">将路径元素重新连接在一起。</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes，Atze Dijkstra，Johan Jeuring和Andres Loeh。&lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell的通用派生机制&lt;/a&gt;。第三届ACM Haskell关于Haskell的座谈会论文集（Haskell'2010），第37-48页，ACM，2010年。</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes，Atze Dijkstra，Johan Jeuring和Andres Loeh。&lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell的通用派生机制&lt;/a&gt;。第三届ACM Haskell关于Haskell的座谈会论文集（Haskell'2010），第37-48页，ACM，2010年。</target>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">朱尔斯&amp;middot;树篱。&amp;ldquo;用于回溯搜索的Monad变压器&amp;rdquo;。在&lt;em&gt;MSFP 2014论文集中&lt;/em&gt;。&lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 一样，但不要在每个元素后添加斜杠。</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 一样，但不要在每个元素后添加斜杠。</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">就像编译 &lt;code&gt;A.hs&lt;/code&gt; 会生成一个接口文件 &lt;code&gt;A.hi&lt;/code&gt; 和一个目标文件 &lt;code&gt;A.o&lt;/code&gt; ，编译 &lt;code&gt;A.hs-boot&lt;/code&gt; 也会生成一个接口文件 &lt;code&gt;A.hi-boot&lt;/code&gt; 和一个伪目标文件 &lt;code&gt;A.o-boot&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">就像Template Haskell（&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;）一样，如果将引号放在第二个字符是引号的数据构造函数之前，GHC也会感到困惑。在这种情况下，只需在促销报价和数据构造函数之间放置一个空格：</target>
        </trans-unit>
        <trans-unit id="2870800735c79017eac1d692e6e01d1292a30d03" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;template_haskell#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">就像Template Haskell（&lt;a href=&quot;template_haskell#th-syntax&quot;&gt;Syntax&lt;/a&gt;）一样，如果将引号放在第二个字符是引号的数据构造函数之前，GHC也会感到困惑。在这种情况下，只需在促销报价和数据构造函数之间放置一个空格：</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">就像类型推断一样，递归类型的种类推断只能使用&lt;em&gt;单态&lt;/em&gt;递归。考虑以下（人为）示例：</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">就像您不会使用do-notation 定义 &lt;code&gt;Monad&lt;/code&gt; 实例一样，您也不应该使用do-notation 定义 &lt;code&gt;Functor&lt;/code&gt; 或 &lt;code&gt;Applicative&lt;/code&gt; 实例（使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; 时）。用 &lt;code&gt;Monad&lt;/code&gt; 定义这些实例的正确方法是直接使用 &lt;code&gt;Monad&lt;/code&gt; 操作，例如</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">就像值级绑定上的签名一样,模式同义词签名可以应用于多个模式。例如:</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="translated">与其他类型的插件一样，您可以编写 &lt;code&gt;DynFlags&lt;/code&gt; 插件，这些插件可以使用并利用一些选项，然后可以使用 &lt;code&gt;-fplugin-opt&lt;/code&gt; 标志指定这些选项。在上面的 &lt;code&gt;DynFlagsPlugin&lt;/code&gt; 代码中，上述选项将在 &lt;code&gt;hooksP&lt;/code&gt; 的 &lt;code&gt;opts&lt;/code&gt; 参数中可用。</target>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">就像unsafePerformIO一样，但我们对其进行内联。巨大的性能提升，因为它使很多东西可以进一步内联。&lt;em&gt;很不安全&lt;/em&gt;。特别是，您不应在 &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 块内进行任何内存分配。在Hugs上，这只是 &lt;code&gt;unsafePerformIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">就像unsafePerformIO一样，但我们对其进行内联。巨大的性能提升，因为它使很多东西可以进一步内联。&lt;em&gt;很不安全&lt;/em&gt;。特别是，您不应在 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 块内进行任何内存分配。在Hugs上，这只是 &lt;code&gt;unsafePerformIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">只是x =&amp;gt;使用给定的模式创建文件，Nothing =&amp;gt;文件必须存在。</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">通过&lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt;进行从 &lt;code&gt;.hs&lt;/code&gt; 到 &lt;code&gt;.o&lt;/code&gt; 的编译时，请保留中间的 &lt;code&gt;.hc&lt;/code&gt; 文件（注意： &lt;code&gt;.hc&lt;/code&gt; 文件仅由&lt;a href=&quot;codegens#unreg&quot;&gt;未注册的&lt;/a&gt;编译器生成）。</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.hi&lt;/code&gt; 文件。这是默认值。如果您对 &lt;code&gt;.hi&lt;/code&gt; 文件不感兴趣，则可以使用 &lt;code&gt;-no-keep-hi-files&lt;/code&gt; files。</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">通过&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt;进行 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 编译时，请保留中间的 &lt;code&gt;.ll&lt;/code&gt; 文件（注意：使用本机代码生成器时不会生成 &lt;code&gt;.ll&lt;/code&gt; 文件，您可能需要使用&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;来强制生成它们）。</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.o&lt;/code&gt; 文件。这是默认值。如果您对 &lt;code&gt;.o&lt;/code&gt; 文件不感兴趣，则可以使用 &lt;code&gt;-no-keep-o-files&lt;/code&gt; files。</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.s&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">仅保留其中至少一个类是&lt;strong&gt;交互式类&lt;/strong&gt;（在下面定义）的组。</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">将 &lt;code&gt;CPP&lt;/code&gt; 预处理程序阶段的输出保留为 &lt;code&gt;.hscpp&lt;/code&gt; 文件。甲 &lt;code&gt;.hscpp&lt;/code&gt; 文件只被创建，如果一个模块被编译和使用C预处理器。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">关键参数被评估为WHNF。</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">种填充或填充要做。</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">善意的表示</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="translated">种类变量也可以在&lt;em&gt;可见&lt;/em&gt;位置量化。请考虑以下两个示例：</target>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">种平等不能延后,如。</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">克莱斯利箭的一个单体。</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">已知的局限性。</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">向左箭头</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">向左箭头-尾巴。</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">左侧双箭头-尾巴。</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM代码生成器中&lt;/a&gt;的LLVM代码</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">LLVM代码生成器</target>
        </trans-unit>
        <trans-unit id="3c49671b7e2363cd100d9148316191ae6da5ed49" translate="yes" xml:space="preserve">
          <source>LOCALESIGNATURE</source>
          <target state="translated">LOCALESIGNATURE</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">给解码器贴标签。如果解码器失败,标签将被附加在错误信息字符串的新行上。</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">树木的标签</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">语言扩展查询</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">语言扩展</target>
        </trans-unit>
        <trans-unit id="b475046df5e047a5d324d26e9300cc370c2f256f" translate="yes" xml:space="preserve">
          <source>Language extensions can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;pragmas#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">也可以使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译指示来启用语言扩展，因此可以使用 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; （请参阅&lt;a href=&quot;pragmas#language-pragma&quot;&gt;LANGUAGE编译指示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b09f9847980af7e4a3a6760441d9ffe569eb0c00" translate="yes" xml:space="preserve">
          <source>Language extensions can be controlled (i.e. allowed or not) in two ways:</source>
          <target state="translated">语言扩展可以通过两种方式进行控制(即允许或不允许)。</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">GHC已知的语言扩展</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">语言选项可以通过两种方式进行控制。</target>
        </trans-unit>
        <trans-unit id="1d88995321d1e03fc9c056aa2f0848cb14f687c1" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;exts/control#options-language&quot;&gt;Controlling extensions&lt;/a&gt;.</source>
          <target state="translated">可以通过命令行选项 &lt;code&gt;-Xblah&lt;/code&gt; 或文件本身中的 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; 编译指示来启用语言选项。请参阅&lt;a href=&quot;exts/control#options-language&quot;&gt;控制扩展&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">可以通过命令行选项 &lt;code&gt;-Xblah&lt;/code&gt; 或文件本身中的 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; 编译指示来启用语言选项。请参阅&lt;a href=&quot;glasgow_exts#options-language&quot;&gt;语言选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Cabal识别的语言选项也可以使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译指示来启用，因此可以使用 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; （请参阅&lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE编译指示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="5f9b3e6bbd10362e192076519937e6af00547ec4" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.CodeDo</source>
          <target state="translated">Language.Haskell.TH.CodeDo</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal公开了一些额外的功能,这些功能在GHC与Template Haskell的集成中被内部使用。这不是公共 API 的一部分,因此,这个模块在不同版本之间没有 API 保证。</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">大对象没有从 &lt;code&gt;-A&lt;/code&gt; 标志设置的正常分配区域中分配，这就是为什么对它们有单独的限制的原因。大对象往往比小物件非常罕见，所以大多数程序打 &lt;code&gt;-A&lt;/code&gt; 的前限制 &lt;code&gt;-AL&lt;/code&gt; 限制。但是， &lt;code&gt;-A&lt;/code&gt; 限制是每个功能的限制，而 &lt;code&gt;-AL&lt;/code&gt; 限制是全局的限制，因此 &lt;code&gt;-N&lt;/code&gt; 越大，我们越有可能首先达到 &lt;code&gt;-AL&lt;/code&gt; 限制。为了解决这个问题，当使用大的 &lt;code&gt;-N&lt;/code&gt; 时，可能有必要使用更大的 &lt;code&gt;-AL&lt;/code&gt; 限制。</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">最后是声明的正常类型变量。</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">最后，所有这些仅适用于应用库存推导的 &lt;code&gt;Read&lt;/code&gt; ， &lt;code&gt;Show&lt;/code&gt; ， &lt;code&gt;Typeable&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 以外的类（Haskell报告的4.3.3节）。（对于标准类 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; ，使用库存方法还是此处描述的方法都不重要。）</target>
        </trans-unit>
        <trans-unit id="f0fc455f2e488c46f4258275b73483dfdda67dc4" translate="yes" xml:space="preserve">
          <source>Laws</source>
          <target state="translated">Laws</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">然后将布局字段进行重叠,使最终的布局尽可能的紧凑。例如,假设我们有未装箱的和。</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">多向if的布局与其他布局上下文的工作方式相同,只是多向if中守卫之间的分号是可选的。因此,没有必要将所有的守卫排在同一列;这与守卫在函数定义和案例表达式中的工作方式是一致的。</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">懒惰地将所有在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 上的用户输入作为单个字符串读取。</target>
        </trans-unit>
        <trans-unit id="9c161543e3be3df002213096ec26355269feb4c2" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">懒惰地将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 输入上的所有用户输入作为单个字符串读取。</target>
        </trans-unit>
        <trans-unit id="e038a37a55536e01a6e93e7ead75ab34c8cde87f" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">懒惰地将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 输入上的所有用户输入作为单个字符串读取。</target>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">懒洋洋地阅读 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的其余内容。该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将关闭读取完成后，或在错误。</target>
        </trans-unit>
        <trans-unit id="4161b76a8d82e2a67a0cc9182fd41736687ceb1c" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">懒洋洋地阅读 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的其余内容。该 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将关闭读取完成后，或在错误。</target>
        </trans-unit>
        <trans-unit id="bf9b4f02596e6fd7b5e52ce1559424597d35ee1c" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">懒洋洋地阅读 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的其余内容。该 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将关闭读取完成后，或在错误。</target>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">懒惰地将一个值序列化到一个文件。</target>
        </trans-unit>
        <trans-unit id="2e58d7db217f7ed5e5b534420eebdd649aef1451" translate="yes" xml:space="preserve">
          <source>Laziness in the second argument</source>
          <target state="translated">第二个论点中的懒惰</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 用作生成的惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的尾部</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">如果遇到错误，则惰性I / O会引发异常，这与Haskell 98规范相反，后者要求丢弃错误（请参见Haskell 98报告的21.2.2节）。抛出的异常是通常的IO异常，如果在IO monad中执行失败的IO操作将抛出该异常，并且可以被 &lt;code&gt;System.IO.Error.catch&lt;/code&gt; 或 &lt;code&gt;Control.Exception.catch&lt;/code&gt; 捕获。</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">懒惰的RWS单体。</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">懒惰的读者-作者-状态单体</target>
        </trans-unit>
        <trans-unit id="d5489376c9d88deacb286105f787e1b38b636614" translate="yes" xml:space="preserve">
          <source>Lazy corecursive folds</source>
          <target state="translated">懒惰的卷积式折叠</target>
        </trans-unit>
        <trans-unit id="cfe6c9b5652571971dc8bf8ed33e2fb436e96b8f" translate="yes" xml:space="preserve">
          <source>Lazy corecursive folds of unbounded structures are fine:</source>
          <target state="translated">慵懒的非约束性结构的核心卷积折叠就可以了。</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">懒状态单体,通过计算传递一个可更新的状态。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">懒态单体。</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">懒人作家单子。</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="0a2f5e69772acd39bb519e219d7512fd338af3bf" translate="yes" xml:space="preserve">
          <source>Left and right folds</source>
          <target state="translated">左右两边折叠</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">在一个结构上的左联一元二折。</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">左身份</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">左侧收缩(或紧缩</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">一个结构的左联折叠,但严格应用运算符。</target>
        </trans-unit>
        <trans-unit id="9ad7cc2dc31661b7a9b7f1187d9b82b29af93328" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure, lazy in the accumulator. This is rarely what you want, but can work well for structures with efficient right-to-left sequencing and an operator that is lazy in its left argument.</source>
          <target state="translated">一个结构的左联折叠,在累加器中是懒惰的。这很少是你想要的,但对于具有高效的从右到左排序的结构和一个在左参数中懒惰的操作符来说,可以很好地工作。</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">结构的左联折叠。</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">构造函数应用的左关联折叠操作。</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">从左到右构成</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">从左到右组成的克莱斯利箭头。</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">遗留问题</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">一个SIMD向量类型的长度</target>
        </trans-unit>
        <trans-unit id="47460bf7f1b7a814e03f3e50d8835668cf96f2db" translate="yes" xml:space="preserve">
          <source>Length:</source>
          <target state="translated">Length:</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">Lennart Kolmodin</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">Lennart Kolmodin Ross Paterson</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">让我们在&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;的CSV表呈现示例中说明这些改进。它的&amp;ldquo;热代码&amp;rdquo;是表单元格的呈现，我们仅使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API中的函数来实现其实现。</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">我们先来看一个例子。</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">让我们考虑一个简单的例子，</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">让我们创建一个Hello World程序，然后编译并运行它。首先，创建一个包含Haskell代码的文件 &lt;code&gt;hello.hs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">首先让我们看一下执行如何在该程序中流动。首先，告诉GHC我们需要调试信息，</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">让我们从一个示例GHCi会话开始。您可以使用 &lt;code&gt;ghci&lt;/code&gt; 命令启动GHCi ：</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">让我们从上面举个例子，并从一个独立的C程序中调用它。这是C代码：</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">让我们使用quicksort作为运行示例。这是代码：</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">让我们来解码一下这里的二进制数据表示。在这个例子中,数值是以小恩迪安为单位的。</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">首先定义一个解码许多 &lt;code&gt;Trade&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">漂亮打印输出的细节水平。0级是最少的细节。</target>
        </trans-unit>
        <trans-unit id="46ea3fc173ca6f3f7f2ab9f2d659dfe92c450434" translate="yes" xml:space="preserve">
          <source>Levity-polymorphic since &lt;em&gt;template-haskell-2.16.0.0&lt;/em&gt;.</source>
          <target state="translated">自&lt;em&gt;模板-haskell-2.16.0.0&lt;/em&gt;起的多态性。</target>
        </trans-unit>
        <trans-unit id="52dcee87fcfc322421d1cb812971dd1afed2aeaf" translate="yes" xml:space="preserve">
          <source>Levity-polymorphic since &lt;em&gt;template-haskell-2.17.0.0&lt;/em&gt;. type TExpQ :: TYPE r -&amp;gt; Kind.Type</source>
          <target state="translated">自&lt;em&gt;模板-haskell-2.17.0.0&lt;/em&gt;起的多态性。键入TExpQ :: TYPE r-&amp;gt; Kind.Type</target>
        </trans-unit>
        <trans-unit id="25799598a4e8c42a83738d367f796323e13b7b18" translate="yes" xml:space="preserve">
          <source>Lexeme</source>
          <target state="translated">Lexeme</target>
        </trans-unit>
        <trans-unit id="46ace3bdab1ce2e35c935ef17a0a57edf4886910" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;angles p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in angle brackets ('&amp;lt;' and '&amp;gt;'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">语义解析器 &lt;code&gt;angles p&lt;/code&gt; 解析 &lt;code&gt;p&lt;/code&gt; 尖括号（&amp;ldquo;&amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;），返回的值 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cc7d61ad991ca5dc420dbacf991b3321c23b4f3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;braces p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in braces ('{' and '}'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">语义解析器 &lt;code&gt;braces p&lt;/code&gt; 解析 &lt;code&gt;p&lt;/code&gt; 括在括号（&amp;ldquo;{&amp;rdquo;和&amp;ldquo;}&amp;rdquo;），返回的值 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b05508eef449259c3da847ba5b8908b337a57ef" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;brackets p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in brackets ('[' and ']'), returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">语义解析器 &lt;code&gt;brackets p&lt;/code&gt; 解析 &lt;code&gt;p&lt;/code&gt; 括在括号（&amp;ldquo;[&amp;rdquo;和&amp;ldquo;]&amp;rdquo;），返回的值 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6f01f6fd61a8c0bb200b1113e901859689cb574" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;colon&lt;/code&gt; parses the character ':' and skips any trailing white space. Returns the string &quot;:&quot;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;colon&lt;/code&gt; 解析字符&amp;ldquo;：&amp;rdquo;，并跳过任何结尾的空格。返回字符串&amp;ldquo;：&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="906be22b3485d6af088c4586447a23867836a78c" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;comma&lt;/code&gt; parses the character ',' and skips any trailing white space. Returns the string &quot;,&quot;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;comma&lt;/code&gt; 解析字符'，'并跳过任何结尾的空格。返回字符串&amp;ldquo;，&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8fa5d226b4524a8f2606ab3fb7b4e7c3152035a2" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;commaSep p&lt;/code&gt; 解析&lt;em&gt;零个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="8f0383ea5ef26d7b618c08586a182319e06433ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;commaSep p&lt;/code&gt; 解析&lt;em&gt;零个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="3b0f682fe5ecece9ab074d848ae3efde0075785f" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;commaSep1 p&lt;/code&gt; 解析&lt;em&gt;一个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="1527e1889e4d9db5a2a2a401431c80198a7ad8ed" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;commaSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;commaSep1 p&lt;/code&gt; 解析&lt;em&gt;一个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:comma&quot;&gt;comma&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="a06e52077d648a539ce51fcce5464792168d2116" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;dot&lt;/code&gt; parses the character '.' and skips any trailing white space. Returns the string &quot;.&quot;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;dot&lt;/code&gt; 解析字符&amp;ldquo;。&amp;rdquo;。并跳过任何尾随空白。返回字符串&amp;ldquo;。&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5c625c13a8a270d65b20ce25a79ef5d1e88e0c01" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;parens p&lt;/code&gt; parses &lt;code&gt;p&lt;/code&gt; enclosed in parenthesis, returning the value of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">语义解析器 &lt;code&gt;parens p&lt;/code&gt; 解析 &lt;code&gt;p&lt;/code&gt; 括在括号，则返回的值 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09775ca66fe1940d621ab83bb334774f062130fc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;semiSep p&lt;/code&gt; 解析&lt;em&gt;零个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 的出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="1fde367cf1acc73ec6e48dd7f44d104f7a0066d3" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep p&lt;/code&gt; parses &lt;em&gt;zero&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;semiSep p&lt;/code&gt; 解析&lt;em&gt;零个&lt;/em&gt;或多个由 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; 分隔的 &lt;code&gt;p&lt;/code&gt; 的出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="a56558ecec4b9b3865d84f3538f50974882790bc" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;semiSep1 p&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; 分隔的&lt;em&gt;一个&lt;/em&gt;或多个 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="f226487b67eb839b478eae118624bbb75f343207" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;semiSep1 p&lt;/code&gt; parses &lt;em&gt;one&lt;/em&gt; or more occurrences of &lt;code&gt;p&lt;/code&gt; separated by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt;. Returns a list of values returned by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;semiSep1 p&lt;/code&gt; 解析由 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:semi&quot;&gt;semi&lt;/a&gt;&lt;/code&gt; 分隔的&lt;em&gt;一个&lt;/em&gt;或多个 &lt;code&gt;p&lt;/code&gt; 出现。返回 &lt;code&gt;p&lt;/code&gt; 返回的值的列表。</target>
        </trans-unit>
        <trans-unit id="71ba5db9cf8b9d035392754516d0f0d298c6b31e" translate="yes" xml:space="preserve">
          <source>Lexeme parser &lt;code&gt;symbol s&lt;/code&gt; parses &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; and skips trailing white space.</source>
          <target state="translated">Lexeme解析器 &lt;code&gt;symbol s&lt;/code&gt; 解析 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:string&quot;&gt;string&lt;/a&gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 并跳过结尾的空格。</target>
        </trans-unit>
        <trans-unit id="1cae647ca5dc3e8507fd8b9a75e7e569807d779e" translate="yes" xml:space="preserve">
          <source>Lexeme parser |semi| parses the character ';' and skips any trailing white space. Returns the string &quot;;&quot;.</source>
          <target state="translated">词法解析器|semi|解析字符';'并跳过任何尾部的空白。返回字符串&quot;;&quot;。</target>
        </trans-unit>
        <trans-unit id="1a85bb6bdbe773df37163bd57f9f3cbce90e0583" translate="yes" xml:space="preserve">
          <source>Lexical type variables may be alpha-renamed freely, without changing the program.</source>
          <target state="translated">词法类型变量可以自由地重新命名,而不需要改变程序。</target>
        </trans-unit>
        <trans-unit id="dfa4917a631d5ad9efc7afed87e7e85e133625b5" translate="yes" xml:space="preserve">
          <source>LexicalNegation</source>
          <target state="translated">LexicalNegation</target>
        </trans-unit>
        <trans-unit id="acfd3fae981ce83b9a78f156f575113d42a472b8" translate="yes" xml:space="preserve">
          <source>LiberalTypeSynonyms</source>
          <target state="translated">LiberalTypeSynonyms</target>
        </trans-unit>
        <trans-unit id="57b431fa7c23fe6a92d842e080f85a382840075b" translate="yes" xml:space="preserve">
          <source>Libraries can specify this by using &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SPEC&quot;&gt;SPEC&lt;/a&gt;&lt;/code&gt; data type to inform which loops should be aggressively specialized.</source>
          <target state="translated">库可以通过使用 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:SPEC&quot;&gt;SPEC&lt;/a&gt;&lt;/code&gt; 数据类型来指定此值，以告知应该积极地进行专门处理的循环。</target>
        </trans-unit>
        <trans-unit id="150017bb5be516efb13183274c04717c3913f12c" translate="yes" xml:space="preserve">
          <source>Library functions</source>
          <target state="translated">图书馆职能</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8f40b70f72540e03b88378ef3507f6d84f38b8e2" translate="yes" xml:space="preserve">
          <source>Licensed under a BSD-style license (see top of the page).</source>
          <target state="translated">采用BSD风格的许可证(见页面顶部)。</target>
        </trans-unit>
        <trans-unit id="7c040e16c5971eb5c4f65496f4403ed7de94405d" translate="yes" xml:space="preserve">
          <source>Licensed under the Glasgow Haskell Compiler License.</source>
          <target state="translated">根据 Glasgow Haskell 编译器许可证授权。</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="efd0976a0ad531b6453a3782b50f0f3ff5363b1e" translate="yes" xml:space="preserve">
          <source>Lift</source>
          <target state="translated">Lift</target>
        </trans-unit>
        <trans-unit id="69bd6ed6019d0841a40b7376c8be9d0e00a15a4a" translate="yes" xml:space="preserve">
          <source>Lift &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">通过类型构造函数提升 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="28a4c297cb17de5189cf531fb8cff2247893efd7" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 提升到 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b11a06f969ecc3525b7fd7eb5bd850c961745651" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 提升到 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77ad9a4be8766f89114fe4a089c39d2885ba04cb" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="57350b28e0ae1579635d1c5f5bfee71f12dc8af6" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; 对新monad 的callCC操作。</target>
        </trans-unit>
        <trans-unit id="e69559f09d367723fe7abf1f50e359886a0e8931" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;catchE&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">将 &lt;code&gt;catchE&lt;/code&gt; 操作取消到新的monad。</target>
        </trans-unit>
        <trans-unit id="9c3605ce5319733a98246b58994a1c7a3b22a3dc" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;listen&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">取消对新monad 的 &lt;code&gt;listen&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="898de1bff1c29cda9790c0fed24117c87b00c641" translate="yes" xml:space="preserve">
          <source>Lift a &lt;code&gt;pass&lt;/code&gt; operation to the new monad.</source>
          <target state="translated">取消对新monad 的 &lt;code&gt;pass&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="0d0feda6a4614b667af6e9eb00a72f0992d75a5c" translate="yes" xml:space="preserve">
          <source>Lift a IO operation</source>
          <target state="translated">提升IO操作</target>
        </trans-unit>
        <trans-unit id="b9039d9d95aa49349189305fdf5c0f23de8d10bb" translate="yes" xml:space="preserve">
          <source>Lift a binary function to actions.</source>
          <target state="translated">将二元函数提升到动作。</target>
        </trans-unit>
        <trans-unit id="4fdb7ea3c747b4ff83d8fd93dbad25981db51967" translate="yes" xml:space="preserve">
          <source>Lift a computation from the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 提升计算。</target>
        </trans-unit>
        <trans-unit id="0e31379847177eab30d30f0126819d393b4805f7" translate="yes" xml:space="preserve">
          <source>Lift a computation from the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. This allows us to run IO computations in any monadic stack, so long as it supports these kinds of operations (i.e. &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; is the base monad for the stack).</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad提升计算。这使我们能够在任何monadic堆栈中运行IO计算，只要它支持这些类型的操作即可（即 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 是堆栈的基本monad）。</target>
        </trans-unit>
        <trans-unit id="6fb4cfd1308d8bc1fc2b8075cc399da8778ef019" translate="yes" xml:space="preserve">
          <source>Lift a computation from the argument monad to the constructed monad.</source>
          <target state="translated">将计算从参数单体提升到构造单体。</target>
        </trans-unit>
        <trans-unit id="755e2bbeb43333564e4df3721333f2c5cb05f108" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">将功能提升为动作。该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="65540f13b21961e922b1b042f1d167b1c9a2abf6" translate="yes" xml:space="preserve">
          <source>Lift a function to actions. This function may be used as a value for &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">将功能提升为动作。该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="e3306c8d28d88915bd946a2603ec45578ecd138e" translate="yes" xml:space="preserve">
          <source>Lift a function to an arrow.</source>
          <target state="translated">将一个功能提升到一个箭头。</target>
        </trans-unit>
        <trans-unit id="70e5d47cad9c90bc5aea988bdcc449bc319bf871" translate="yes" xml:space="preserve">
          <source>Lift a monadic action producing code into the typed &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; representation</source>
          <target state="translated">将产生代码的单子动作提升为键入的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; 表示形式</target>
        </trans-unit>
        <trans-unit id="072c31ba78fc0ac74605cd75f183f4375e32d5b8" translate="yes" xml:space="preserve">
          <source>Lift a monadic action producing code into the typed &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; representation</source>
          <target state="translated">将产生代码的单子动作提升为键入的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt; 表示形式</target>
        </trans-unit>
        <trans-unit id="34e1005428b4115e3bdc892cb79d78caeaad7d73" translate="yes" xml:space="preserve">
          <source>Lift a precedence-insensitive &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将不区分优先级的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 提升为 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readprec#t:ReadPrec&quot;&gt;ReadPrec&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a927363c52ab42f8173b13c6038ee007ad8a17e" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid。对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9bff245d149ddf1ae6d16d98ebd9221f1ea4340f" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="29850a41c75e24ec5f1d7822fdd746419e6175d1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1f4ae6d40699215f86ae7acc6dbd638b4d640c8" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid。对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="50ae922d71481e0c500a4d32043520930c6c6f12" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ef6d5d2890f728fc0dec424db983bea6034793d1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid。对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d9bf2088ff3118acf5a0706a43b2ca5d9acc93eb" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="f3a10c09a2df5ee40736eca77b005327c3f502e1" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid。对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5e1fcf4cd57048cb7f11dc48a4d6b768b70babd3" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="55317bb47900a6c531bb57912283090eb69391dc" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid。对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3c1bc5d6a5612d9590c702c04f8fbd95d193c275" translate="yes" xml:space="preserve">
          <source>Lift a semigroup into &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; forming a &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid&lt;/a&gt;: &quot;Any semigroup &lt;code&gt;S&lt;/code&gt; may be turned into a monoid simply by adjoining an element &lt;code&gt;e&lt;/code&gt; not in &lt;code&gt;S&lt;/code&gt; and defining &lt;code&gt;e*e = e&lt;/code&gt; and &lt;code&gt;e*s = s = s*e&lt;/code&gt; for all &lt;code&gt;s &amp;isin; S&lt;/code&gt;.&quot;</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Monoid&quot;&gt;http://en.wikipedia.org/wiki/Monoid将&lt;/a&gt;一个半群提升为 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 形成一个 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ：&amp;ldquo;任何半群 &lt;code&gt;S&lt;/code&gt; 都可以简单地通过连接一个不在 &lt;code&gt;S&lt;/code&gt; 中的元素 &lt;code&gt;e&lt;/code&gt; 并定义 &lt;code&gt;e*e = e&lt;/code&gt; 来变成一个monoid对于所有 &lt;code&gt;s &amp;isin; S&lt;/code&gt; ， &lt;code&gt;e*s = s = s*e&lt;/code&gt; 。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b18efdb14898a61cd6bf3e53b88908b07c899338" translate="yes" xml:space="preserve">
          <source>Lift a ternary function to actions.</source>
          <target state="translated">将三元函数提升到动作。</target>
        </trans-unit>
        <trans-unit id="1c6cfea669eba5bd426957f891847f721512f382" translate="yes" xml:space="preserve">
          <source>Lift a unary operation to the new monad.</source>
          <target state="translated">举一反三,对新的单体进行操作。</target>
        </trans-unit>
        <trans-unit id="46b3af654500c45d1bbe42552320fbf9acf7d7ab" translate="yes" xml:space="preserve">
          <source>Lift a value.</source>
          <target state="translated">提升一个数值。</target>
        </trans-unit>
        <trans-unit id="1a088c3e62edefbbd612558fe95e26c16929b0cf" translate="yes" xml:space="preserve">
          <source>Lift an IO operation</source>
          <target state="translated">提升IO操作</target>
        </trans-unit>
        <trans-unit id="f3531bf1113fe8b33ad38c7a7731990c8b025668" translate="yes" xml:space="preserve">
          <source>Lift an equality test through the type constructor.</source>
          <target state="translated">通过类型构造函数提起平等测试。</target>
        </trans-unit>
        <trans-unit id="d59a4331fe2b228402b5f804879977d4d2bdbdf8" translate="yes" xml:space="preserve">
          <source>Lift equality tests through the type constructor.</source>
          <target state="translated">通过类型构造函数解除平等测试。</target>
        </trans-unit>
        <trans-unit id="ba141aacd2971ab64cd183f644499403aa27baf6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准 &lt;code&gt;(&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;)&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="2a5c11e919022ea17cf3e50538bb0b39ab267ca8" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="a22f0b12039df26e38242ef4e1b27fd9a2aca7c5" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="cef4fc8589a89ebe3dab70e8896098b35542b102" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准的 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="81beb3415733b0127f91ccfbc68d75371f1bc17c" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="faeb2e4ce6194f3ee4155e1efd45893a2e939961" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准的 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="053aeb1412e2444b0b1a20409a35603dc721e057" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准的 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="408cf02de66cc6b705154fd2c661de60e644f5b6" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; functions through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准的 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3004afec47fb6a84cae4d9e49047dab3af9ecdbb" translate="yes" xml:space="preserve">
          <source>Lift the standard &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; function through the type constructor.</source>
          <target state="translated">通过类型构造函数提升标准的 &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f4fbea4d9b31cd33d7694749c6476d3a1af9a3ab" translate="yes" xml:space="preserve">
          <source>Lifted product of functors.</source>
          <target state="translated">掀起的漏斗积。</target>
        </trans-unit>
        <trans-unit id="3b10925916ee44f531f851144318a3b5ce0f20aa" translate="yes" xml:space="preserve">
          <source>Lifted sum of functors.</source>
          <target state="translated">掀起的漏斗之和。</target>
        </trans-unit>
        <trans-unit id="babef654d32e20b79299fbdb4e3acce1da353228" translate="yes" xml:space="preserve">
          <source>Lifted, heterogeneous equality. By lifted, we mean that it can be bogus (deferred type error). By heterogeneous, the two types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; might have different kinds. Because &lt;code&gt;~~&lt;/code&gt; can appear unexpectedly in error messages to users who do not care about the difference between heterogeneous equality &lt;code&gt;~~&lt;/code&gt; and homogeneous equality &lt;code&gt;~&lt;/code&gt;, this is printed as &lt;code&gt;~&lt;/code&gt; unless &lt;code&gt;-fprint-equality-relations&lt;/code&gt; is set.</source>
          <target state="translated">解除的，异质的平等。所谓提升，是指它可能是虚假的（延迟类型错误）。由于种类不同， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 这两种类型可能具有不同的种类。因为 &lt;code&gt;~~&lt;/code&gt; 可能会在错误消息中意外出现给不关心异构等式 &lt;code&gt;~~&lt;/code&gt; 和同类等式 &lt;code&gt;~&lt;/code&gt; 之间差异的用户，所以除非设置了 &lt;code&gt;-fprint-equality-relations&lt;/code&gt; ,否则它将被打印为 &lt;code&gt;~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4bfbdd16cc189cc5129a0d8ec953d2317a224b0" translate="yes" xml:space="preserve">
          <source>LiftedRep</source>
          <target state="translated">LiftedRep</target>
        </trans-unit>
        <trans-unit id="12c2f75c3b26c4edac3b33e5c51db3b8e36394c9" translate="yes" xml:space="preserve">
          <source>Lifting an applicative</source>
          <target state="translated">提升适用性</target>
        </trans-unit>
        <trans-unit id="e2c3b2b741daea57fdd436a0412a6ba2f18b6f68" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类提升为二进制类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="44895603faea79f05cd37173f6a4597b6953146e" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类提升为一元类型构造函数。</target>
        </trans-unit>
        <trans-unit id="e0a82371cc12bbf7738745a43b619731d3611950" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类提升为二进制类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="7d9b6f54af0f5e9694ecfd7ee7add7a2cc652087" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类提升为一元类型构造函数。</target>
        </trans-unit>
        <trans-unit id="ae55fc1bef97cadc36b9661bf1e25f7f4c7e352d" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类提升为二进制类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="86c660f1a1c56586cead2935de6c64b3ef5324c5" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类提升为一元类型构造函数。</target>
        </trans-unit>
        <trans-unit id="b2e9206d787342e53328d0f894bfa7fc5940af4a" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to binary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类提升为二进制类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="d56ab180af5b8c6b67cd1de105953549f78976c7" translate="yes" xml:space="preserve">
          <source>Lifting of the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class to unary type constructors.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类提升为一元类型构造函数。</target>
        </trans-unit>
        <trans-unit id="ef79daca18c86fc7acb004897eb034a72769183c" translate="yes" xml:space="preserve">
          <source>Lifting other operations</source>
          <target state="translated">吊装其他业务</target>
        </trans-unit>
        <trans-unit id="70b315b20d2f0763f381b07677fe5fcdd427769f" translate="yes" xml:space="preserve">
          <source>Liftings of Prelude classes</source>
          <target state="translated">序曲班的升降</target>
        </trans-unit>
        <trans-unit id="bbd32f90f691094d13a835f9d8bc070165c84480" translate="yes" xml:space="preserve">
          <source>Liftings of the &lt;code&gt;NFData&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;NFData&lt;/code&gt; 类的提升</target>
        </trans-unit>
        <trans-unit id="cf36ebf7919530abaa3b7a585d3a7f483fb9666d" translate="yes" xml:space="preserve">
          <source>Liftings of the Prelude classes &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; to unary and binary type constructors.</source>
          <target state="translated">将Prelude类 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 提升为一元和二进制类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="b9662e4165cf70bc0656fd852ce8badb4bccd421" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="e98068ced479359302008df12305e0fa6226acf9" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="533e09a9bf33161ccd152904f791f9b0ccd0dfa2" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="3f90827cfa26ca646d28cee985138fed19cc82be" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="f5521b87bdd2b2ba0107fa6810e0f9218d24ee9b" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="7d1efb767ef813dfdeb09404aab44cab82ce1aa2" translate="yes" xml:space="preserve">
          <source>Lifts an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; into any &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; e&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt; e&lt;/code&gt; 到任何MonadError e中。</target>
        </trans-unit>
        <trans-unit id="4ea5fc5a99bc5f43e32f54299e4add38a5941b11" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, but options set with &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; affect only expressions and commands typed at the prompt, and not modules loaded with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; (in contrast, options set with &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; apply everywhere). See &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;一样，但用&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;设置的选项仅影响在提示符下键入的表达式和命令，而不影响用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 加载的&lt;/a&gt;模块（相反，用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置的&lt;/a&gt;选项适用于所有地方）。请参阅&lt;a href=&quot;#ghci-interactive-options&quot;&gt;仅设置用于交互式评估的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3eb1542266aa6e78b551f4a66f99dca63eb84c5" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; ，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="3ee688d5e3686106a78a8c11143028e7c7c2d867" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 类似，但是以二进制模式打开文件。有关更多评论，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171756990cca268601ff47e149f013f10d1f0b1d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; ，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="3e5d1ae0b75edd09252cda3ae684b700669426cc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 类似，但是以二进制模式打开文件。有关更多评论，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1abb83e3fff00970acacf5a85cdb8ae50239c4a9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; ，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="e3c101ba4a684aa998861e15a7cff4ed12d0d488" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 类似，但是以二进制模式打开文件。有关更多评论，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e95f6be3cd220d7c265e9ff2d6eb81b829a783d7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 相似，但是让您指定线程应在哪种功能上运行。与 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程不同， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 创建的线程将在整个生命周期内保持相同的功能（ &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程可以根据调度策略在功能之间迁移）。当您事先知道如何最好地分配线程时， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 对于覆盖调度策略很有用。</target>
        </trans-unit>
        <trans-unit id="315f04774b37e903ccef1fd017cf5e6c8fb19cad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 一样，但是子线程传递了一个函数，该函数可用于取消屏蔽异步异常。此功能通常按以下方式使用</target>
        </trans-unit>
        <trans-unit id="26af205331dd385348a903a75489cae5ac1bc8a2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, this sparks off a new thread to run the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation passed as the first argument, and returns the &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; of the newly created thread.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 一样，这会触发一个新线程来运行作为第一个参数传递的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算，并返回新创建的线程的 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e51a2d5c390f6fe2c3f06d7a141e356abf36b260" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is a bound thread, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 一样，但是子线程是一个绑定线程，就像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="ee5a0feb98209de5e446543c7ee38359b8a7b02e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 一样，但是子线程固定到给定的CPU，就像 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="894deb520e4932d4ccd6a7678d392f4657ad389a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; 相似，但是第二个参数中的 &lt;code&gt;IO&lt;/code&gt; 操作是在屏蔽了异步异常的情况下执行的。</target>
        </trans-unit>
        <trans-unit id="b23d745348276319c0475e801e641228506e2414" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 类似，但是第二个参数中的 &lt;code&gt;IO&lt;/code&gt; 操作是在屏蔽了异步异常的情况下执行的。</target>
        </trans-unit>
        <trans-unit id="cbaf69411b6e48d7f755fce6152d35bbf2f5117d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, but the &lt;code&gt;IO&lt;/code&gt; action in the second argument is executed with asynchronous exceptions masked.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; 一样，但是第二个参数中的 &lt;code&gt;IO&lt;/code&gt; 操作是在屏蔽了异步异常的情况下执行的。</target>
        </trans-unit>
        <trans-unit id="ddf1b2d2d7438a64e06e7288f0b784895fdb2d25" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; but the function is a simple state transition that can return a side value which is passed on as the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:modifyTVar-39-&quot;&gt;modifyTVar'&lt;/a&gt;&lt;/code&gt; 一样，但该函数是一个简单的状态转换，可以返回作为 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 结果传递的边值。</target>
        </trans-unit>
        <trans-unit id="c85aa7d7cdb5b9edc279fc62b53487dd9aa084bc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the in-between computation.</source>
          <target state="translated">类似于方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，但仅在中间计算引起异常时才执行最终操作。</target>
        </trans-unit>
        <trans-unit id="428edc72ad0acbe121d8494d1d65e4193ca597f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 一样，但仅在计算引发异常时才执行最终动作。</target>
        </trans-unit>
        <trans-unit id="58d823ae8a2d7d414c0d42e7b802e79575732ed8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，但不会将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="6caf66653eb22b299f52b1089ebb3605f273b200" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，但是被屏蔽的计算不可中断（请参见&lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;）。这应该与GREAT CARE一起使用，因为如果某个线程出于某种原因在 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 掩码中执行，那么该线程（如果是主线程，则可能是程序）将无响应且无法杀死。仅当您需要屏蔽可中断操作周围的异常时，才需要使用此功能，并且可以保证可中断操作只会在短时间内阻塞。</target>
        </trans-unit>
        <trans-unit id="c4d8e2c728be8dff68d64c2a9d4e55d7a3457b7d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 一样，但是不将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="d0c2cdb316924ad0cfcfbad4c5a54c0b89f7946f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;control-monad#v:foldM&quot;&gt;foldM&lt;/a&gt;&lt;/code&gt; 一样，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="b96efb08972b89ea81a161e65a91a252070d9475" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; ，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="b6ab6604b14c9e57db46ecf0ddcd0256f914b9e9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, but only performs the final action if an error is thrown by the in-between computation.</source>
          <target state="translated">类似于方 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，但仅在中间计算引发错误时才执行最终操作。</target>
        </trans-unit>
        <trans-unit id="b6a432005495b7136cfdf428a9a6ea3acfc5248a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，但不会将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="af33929c8b3cdd326c411d0878af278835603f2d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. WARNING: Only use if you need to mask exceptions around an interruptible operation AND you can guarantee the interruptible operation will only block for a short period of time. Otherwise you render the program/thread unresponsive and/or unkillable.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 一样，但是被屏蔽的计算是不可中断的（请参见&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 。警告：仅在需要屏蔽可中断操作周围的异常时使用，并且可以确保可中断操作只会在短时间内阻塞。否则，您将使程序/线程无响应和/或无法杀死。</target>
        </trans-unit>
        <trans-unit id="ed29ac9ba7c3e179a54bf2966ac9ac7af76e7d0a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;. WARNING: Only use if you need to mask exceptions around an interruptible operation AND you can guarantee the interruptible operation will only block for a short period of time. Otherwise you render the program/thread unresponsive and/or unkillable.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 一样，但是被屏蔽的计算是不可中断的（请参见&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 。警告：仅在需要屏蔽可中断操作周围的异常时使用，并且可以确保可中断操作只会在短时间内阻塞。否则，您将使程序/线程无响应和/或无法杀死。</target>
        </trans-unit>
        <trans-unit id="a5f3eb839ad43d64884f153d8e4355f1395cdc6c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 一样，但是不会将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="78cdc9f7942398d4390de39bd760476640cca3cf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相似，不同之处在于，如果没有足够的立即可用字节满足整个请求，则可以返回较短的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。仅当没有可用数据并且尚未达到EOF时， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 才会阻止。</target>
        </trans-unit>
        <trans-unit id="22204fd64f738ebaf8d59795481095728e60cafd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt;, except that a shorter &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be returned if there are not enough bytes immediately available to satisfy the whole request. &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; only blocks if there is no data available, and EOF has not yet been reached.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; 相似，不同之处在于，如果没有足够的立即可用字节满足整个请求，则可以返回较短的 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。仅当没有可用数据并且尚未达到EOF时， &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGetSome&quot;&gt;hGetSome&lt;/a&gt;&lt;/code&gt; 才会阻止。</target>
        </trans-unit>
        <trans-unit id="88bc8146cfaa55c674a416c3250cf7fde75cab90" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; but instead of giving the final size of the ByteString, it is just an upper bound. The inner action returns the actual size. Unlike &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; the ByteString is not reallocated if the final size is less than the estimated size.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:unsafeCreate&quot;&gt;unsafeCreate&lt;/a&gt;&lt;/code&gt; 一样，但是它没有给出ByteString的最终大小，只是一个上限。内部动作将返回实际大小。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#v:createAndTrim&quot;&gt;createAndTrim&lt;/a&gt;&lt;/code&gt; 不同，如果最终大小小于估计的大小，则不会重新分配ByteString。</target>
        </trans-unit>
        <trans-unit id="f5d3796594fc3ab685a758f79230f2378e0d143a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returning unit in an arbitrary &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context. Allows for convenient use in do-notation.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 但在任意 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 上下文中返回单位。便于在注释符号中使用。</target>
        </trans-unit>
        <trans-unit id="d14b22297f44f3b23085789ee54f433e3be99756" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; but returns the message instead of a third value.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 类似，但返回消息而不是第三个值。</target>
        </trans-unit>
        <trans-unit id="94f249d85e854bd365a2caf558548ba6a48c90f7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 类似，但在参数上使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 可以将其转换为 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bda17b6fe85f48913bc5a5c73b83bf25335feb15" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt;, but uses &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; on the argument to convert it to a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 类似，但在参数上使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 可以将其转换为 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d4f7e6d83c6d859a27421bd667669770d5a90e1" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; but returns the shown value instead of a third value.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 类似,但返回显示的值而不是第三个值。</target>
        </trans-unit>
        <trans-unit id="3388029e6ebab6adb5dbdc535cdaa4a63773ee6d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 一样，但为终结器传递了附加的环境参数。</target>
        </trans-unit>
        <trans-unit id="6f7201461e77cbbffbf975483dea651ac9f115ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 类似,但允许将终结器传递给附加的环境参数，该参数将传递给终结器。传递给终结器的环境由 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 的第二个参数固定</target>
        </trans-unit>
        <trans-unit id="61b50bda211ddddaf8be8d611e3ac6aceb8f889d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 一样，但为终结器传递了附加的环境参数。</target>
        </trans-unit>
        <trans-unit id="7debe615da856622a94fda2ea5817fa207e70f78" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 类似,但允许将终结器传递给附加的环境参数，该参数将传递给终结器。传递给终结器的环境由 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 的第二个参数固定</target>
        </trans-unit>
        <trans-unit id="64ed7e2ac88ad404c757ebe2bf247c490e1bb7f8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ,但是内存中填充了零值字节。</target>
        </trans-unit>
        <trans-unit id="86170fb3c040fb17cc898e1ff2e2691ab6d6babd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:allocaArray&quot;&gt;allocaArray&lt;/a&gt;&lt;/code&gt; ，但添加一个额外的位置来容纳特殊的终止元素。</target>
        </trans-unit>
        <trans-unit id="ac1ab9de75683278e54e5c08a09c39dc2659dca6" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:callocArray0&quot;&gt;callocArray0&lt;/a&gt;&lt;/code&gt; ，但是分配的内存中填充了零值字节。</target>
        </trans-unit>
        <trans-unit id="31e8f4f3a29d9ebfdb6b5dd33afab7987daa7fac" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but add an extra position to hold a special termination element.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但增加一个额外的位置来容纳特殊的终止元素。</target>
        </trans-unit>
        <trans-unit id="e8798d35982e07ff23b6d4dd4f9bdb7568df53ad" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but allocated memory is filled with bytes of value zero.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但是分配的内存中填充了零值字节。</target>
        </trans-unit>
        <trans-unit id="56fea7f011d519c7d258e88b7f3d4ae54477fc85" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 相似，但是终止符指示数组的结束位置</target>
        </trans-unit>
        <trans-unit id="5f5dc7b1ce9daa64f13a0b057b2f35119ac5cd95" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt;, but the action gets the number of values as an additional parameter</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArray&quot;&gt;withArray&lt;/a&gt;&lt;/code&gt; 一样，但是该操作将值的数量作为附加参数获取</target>
        </trans-unit>
        <trans-unit id="2e4b7f2fe78306ea129c2aaf255ab760c2af8b59" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt;, but a terminator indicates where the array ends</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:withArrayLen&quot;&gt;withArrayLen&lt;/a&gt;&lt;/code&gt; 相似，但终止符指示数组的结束位置</target>
        </trans-unit>
        <trans-unit id="789fc518616c7bbb0baf7f9f6873e5ac8d47ec18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIf&quot;&gt;throwIf&lt;/a&gt;&lt;/code&gt; 一样，但是丢弃结果</target>
        </trans-unit>
        <trans-unit id="c8a36a8d0834f745b3ab8c875279421ca4121094" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt;, but discarding the result</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-error#v:throwIfNeg&quot;&gt;throwIfNeg&lt;/a&gt;&lt;/code&gt; ，但丢弃结果</target>
        </trans-unit>
        <trans-unit id="6a1b2b22a37fbf26bc19da6800d4f4f4c18e9196" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; ，但不检查值是否在范围内。</target>
        </trans-unit>
        <trans-unit id="fd6ed34fe3d856c29ed47ef21309ed222b27e308" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 相似，但是让您指定线程应在哪种功能上运行。与 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程不同， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 创建的线程将在整个生命周期内保持相同的功能（ &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程可以根据调度策略在功能之间迁移）。当您事先知道如何最好地分配线程时， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 对于覆盖调度策略很有用。</target>
        </trans-unit>
        <trans-unit id="8a1ab1b4c3fc6205f7cbc119a5029f50c82ecfa2" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 一样，但是子线程传递了一个函数，该函数可用于取消屏蔽异步异常。此功能通常按以下方式使用</target>
        </trans-unit>
        <trans-unit id="36c33ff708aca6f019cd5e4f36eb986bb33a1c42" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 一样，但是子线程固定到给定的CPU，就像 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="c7e718907739536fc11ccba60be322ece4a576f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but lets you specify on which capability the thread should run. Unlike a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread, a thread created by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; will stay on the same capability for its entire lifetime (&lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads can migrate between capabilities according to the scheduling policy). &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is useful for overriding the scheduling policy when you know in advance how best to distribute the threads.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 相似，但是让您指定线程应在哪种功能上运行。与 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程不同， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 创建的线程将在整个生命周期内保持相同的功能（ &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程可以根据调度策略在功能之间迁移）。当您事先知道如何最好地分配线程时， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 对于覆盖调度策略很有用。</target>
        </trans-unit>
        <trans-unit id="06b626d6d4d9cc23806065fb84e761850f571140" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, but the child thread is passed a function that can be used to unmask asynchronous exceptions. This function is typically used in the following way</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 一样，但是子线程传递了一个函数，该函数可用于取消屏蔽异步异常。此功能通常按以下方式使用</target>
        </trans-unit>
        <trans-unit id="2074e4e1e1d435d659723420ae5b7066c75304a9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;, but the child thread is pinned to the given CPU, as with &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 一样，但是子线程固定到给定的CPU，就像 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="03378dafea3e612ebd75747dbec79dd54212c74e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; but the finalizer is passed an additional environment parameter.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 一样，但为终结器传递了附加的环境参数。</target>
        </trans-unit>
        <trans-unit id="7f3f4ecabff6e19ca899a6be2fc7069356485a28" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; but allows the finalizer to be passed an additional environment parameter to be passed to the finalizer. The environment passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 类似,但允许将终结器传递给附加的环境参数，该参数将传递给终结器。传递给终结器的环境由 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizerEnv&quot;&gt;addForeignPtrFinalizerEnv&lt;/a&gt;&lt;/code&gt; 的第二个参数固定</target>
        </trans-unit>
        <trans-unit id="7ce27041c32b2c7b9dd00240cd18dbacb3f46271" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, there is a class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; that defines a representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; and conversion functions &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt;, only that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; ranges over types of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. (More generally, it can range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;, if the &lt;code&gt;PolyKinds&lt;/code&gt; extension is enabled. More on this later.) The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class is also derivable.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; ，还有一类 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 限定表示 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 和转换函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from1&quot;&gt;from1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:to1&quot;&gt;to1&lt;/a&gt;&lt;/code&gt; ，只有 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 范围超过类型种 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 。（更一般地，它的范围可以在类型种 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; ，对于任何一种 &lt;code&gt;k&lt;/code&gt; ，如果 &lt;code&gt;PolyKinds&lt;/code&gt; 。分机启用更多稍后）的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 类也可衍生。</target>
        </trans-unit>
        <trans-unit id="c6bccda987e33fe0bbf298a851536cd1b5e84ab8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，但不会将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="aad2536126d6403f4616d23d084d88d2eb347131" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, but the masked computation is not interruptible (see &lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;). THIS SHOULD BE USED WITH GREAT CARE, because if a thread executing in &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; blocks for any reason, then the thread (and possibly the program, if this is the main thread) will be unresponsive and unkillable. This function should only be necessary if you need to mask exceptions around an interruptible operation, and you can guarantee that the interruptible operation will only block for a short period of time.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，但是被屏蔽的计算是不可中断的（请参见&lt;a href=&quot;control-exception#interruptible&quot;&gt;Control.Exception&lt;/a&gt;）。这应该与GREAT CARE一起使用，因为如果某个线程出于某种原因在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 掩码中执行，则该线程（可能是程序，如果这是主线程）将无响应且无法杀死。仅当您需要屏蔽可中断操作周围的异常时，才需要使用此功能，并且可以保证可中断操作只会在短时间内阻塞。</target>
        </trans-unit>
        <trans-unit id="8ad819e37fccd377f4f7ea98ffe39aaa59462a5e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, but does not pass a &lt;code&gt;restore&lt;/code&gt; action to the argument.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 一样，但是不将 &lt;code&gt;restore&lt;/code&gt; 操作传递给参数。</target>
        </trans-unit>
        <trans-unit id="8f34379fe53a8f49eef2d4d51e196bbfce89ed5a" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 类似，但是以二进制模式打开文件。在Windows上，以文本模式（默认）读取文件会将CRLF转换为LF，而写入会将LF转换为CRLF。这通常是文本文件所需要的。对于二进制文件，这是不可取的。同样，在Microsoft操作系统下，文本模式也照常将control-Z视为EOF。二进制模式关闭行尾和文件尾字符的所有特殊处理。（另请参见 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c6e447be1c8c5966385a7af2bdc9dacccc9d0191" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but opens the file in ordinary blocking mode. This can be useful for opening a FIFO for writing: if we open in non-blocking mode then the open will fail if there are no readers, whereas a blocking open will block until a reader appear.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 类似，但以普通阻止模式打开文件。这对于打开用于写入的FIFO很有用：如果我们以非阻塞模式打开，那么如果没有读取器，则打开将失败，而阻塞打开将阻塞，直到出现读取器为止。</target>
        </trans-unit>
        <trans-unit id="d11ed8ec1f7d4a4f76c34befc3bc8a8f2cef6d9c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-ix#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, but without checking that the value is in range.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;ghc-ix#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; ，但不检查值是否在范围内。</target>
        </trans-unit>
        <trans-unit id="11412198fb2aebb6ae9a4f43a11db80ce5c58256" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; (expand escape characters using Haskell escape conventions), but * break the string into multiple lines * wrap the entire thing in double quotes Example: &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showLitString&quot;&gt;showLitString&lt;/a&gt;&lt;/code&gt; （使用Haskell转义符扩展转义符），但是*将字符串分成多行*将整个内容用双引号引起来示例： &lt;code&gt;showMultiLineString &quot;hellongoodbyenblah&quot;&lt;/code&gt; 返回 &lt;code&gt;[&quot;&quot;hello\n\&quot;, &quot;\goodbyen\&quot;, &quot;\blah&quot;&quot;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c39ac872c5a458945a6a2759691e5bcbdb98387" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but in the event of an exception that causes an exit, we don't shut down the system cleanly, we just exit. This is useful in some cases, because the safe exit version will give other threads a chance to clean up first, which might shut down the system in a different way. For example, try</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 一样，但是如果发生异常导致退出，我们不会干净地关闭系统，而只是退出。在某些情况下这很有用，因为安全退出版本将使其他线程有机会先清理，这可能会以其他方式关闭系统。例如，尝试</target>
        </trans-unit>
        <trans-unit id="92a361d777b7468b2f4fc3ce94a02dd7971e288e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, but only performs the final action if there was an exception raised by the computation.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 一样，但仅在计算引发异常时才执行最终动作。</target>
        </trans-unit>
        <trans-unit id="d3dcb0071e2c488b5032fe8ef982a6ce42d875b4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;, but can also read arguments supplied via response files.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 类似，但也可以读取通过响应文件提供的参数。</target>
        </trans-unit>
        <trans-unit id="524c7a43bda4a60c5d96c8d591c7b926a8919edd" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;, but allows blank environment values and mimics the function signature of &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;unix&lt;/code&gt; package.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;system-environment#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; ，但允许空值的环境和模仿的函数签名 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;unix&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="b797f1a70d1f88521b8770e48825b66c385a7740" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt;, but allows for the removal of blank environment variables. May throw an exception if the underlying platform doesn't support unsetting of environment variables.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;system-environment#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; ，但允许删除空白环境变量。如果基础平台不支持取消环境变量的设置，则可能引发异常。</target>
        </trans-unit>
        <trans-unit id="8431a8f9693c397e4ecffa5b03a89b83f5c963c3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryTempFile&quot;&gt;openBinaryTempFile&lt;/a&gt;&lt;/code&gt; ，但使用默认文件权限</target>
        </trans-unit>
        <trans-unit id="ddc8a70da72ad8f7b98007cd07b86322fc708d18" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt;, but open the file in binary mode. On Windows, reading a file in text mode (which is the default) will translate CRLF to LF, and writing will translate LF to CRLF. This is usually what you want with text files. With binary files this is undesirable; also, as usual under Microsoft operating systems, text mode treats control-Z as EOF. Binary mode turns off all special treatment of end-of-line and end-of-file characters. (See also &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; 类似，但是以二进制模式打开文件。在Windows上，以文本模式（默认）读取文件会将CRLF转换为LF，而写入会将LF转换为CRLF。这通常是文本文件所需要的。对于二进制文件，这是不可取的。同样，在Microsoft操作系统下，文本模式也照常将control-Z视为EOF。二进制模式关闭行尾和文件尾字符的所有特殊处理。（另请参见 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="445dbb3aac3b63578f83ae7ca3264f9470654614" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but opens the file in binary mode. See &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; for more comments.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; ，但是以二进制模式打开文件。有关更多评论，请参见 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42d2371aba08fe3ad0e461bdd5e9243b5d4ff47c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt;, but uses the default file permissions</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:openTempFile&quot;&gt;openTempFile&lt;/a&gt;&lt;/code&gt; 类似，但使用默认文件权限</target>
        </trans-unit>
        <trans-unit id="68e487cc9bcc812ffdd024d2959aeef2edcaff91" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 类似,但是时间戳可以具有亚秒级的分辨率。</target>
        </trans-unit>
        <trans-unit id="5fd41ba6952859aa302482f390cdfdfc026468ce" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 类似,但不遵循符号链接。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="bf41494a113002bf4517831272153ccf7cd29c3d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="0b8c47891569804ad6ed4ae6fd8eda019375adc3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; but timestamps can have sub-second resolution.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimes&quot;&gt;setFileTimes&lt;/a&gt;&lt;/code&gt; 类似,但是时间戳可以具有亚秒级的分辨率。</target>
        </trans-unit>
        <trans-unit id="33961ae29501aef7bf09af455c8576676e24ac35" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setFileTimesHiRes&quot;&gt;setFileTimesHiRes&lt;/a&gt;&lt;/code&gt; 类似,但不遵循符号链接。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="5bbeb7f8e03e4906f3490fc206720d0eab71a223" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; but does not follow symbolic links. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:touchFile&quot;&gt;touchFile&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="662c747da0f04cde3ce2ca5a423c4b7f959d2f5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainl&quot;&gt;chainl&lt;/a&gt;&lt;/code&gt; ，但是解析 &lt;code&gt;p&lt;/code&gt; 的一个或多个出现。</target>
        </trans-unit>
        <trans-unit id="f8ce7731553d62994a654a2d708daf3c75a28d74" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt;, but parses one or more occurrences of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">类似于 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:chainr&quot;&gt;chainr&lt;/a&gt;&lt;/code&gt; ，但是解析 &lt;code&gt;p&lt;/code&gt; 的一个或多个出现。</target>
        </trans-unit>
        <trans-unit id="6fee7ff8239ed3fa9381ad7aca490952c09c187d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; 一样，但丢弃结果。</target>
        </trans-unit>
        <trans-unit id="b3dabdc0b676ddd52428d8521d1cc42a6a7a8ded" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt;, but discards the result.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:many1&quot;&gt;many1&lt;/a&gt;&lt;/code&gt; 一样，但是丢弃结果。</target>
        </trans-unit>
        <trans-unit id="a81f5f54f0cb0d0d364aaedc68e2c63bc094834c" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;INLINE&lt;/code&gt;, the &lt;code&gt;INLINABLE&lt;/code&gt; pragma retains a copy of the original RHS for inlining purposes, and persists it in the interface file, regardless of the size of the RHS.</source>
          <target state="translated">像 &lt;code&gt;INLINE&lt;/code&gt; 一样， &lt;code&gt;INLINABLE&lt;/code&gt; 杂注会保留原始RHS的副本以进行内联，并将其保留在接口文件中，而不管RHS的大小如何。</target>
        </trans-unit>
        <trans-unit id="be5585db37b6a8bd5e1a92603fdbe92c2af65ed4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;compactAdd#&lt;/code&gt;, but retains sharing and cycles during compaction.</source>
          <target state="translated">类似于 &lt;code&gt;compactAdd#&lt;/code&gt; ，但是在压缩期间保留共享和循环。</target>
        </trans-unit>
        <trans-unit id="211af64297aca58574fb18700a2e7f33892effcf" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;createUpToN&lt;/code&gt;, but also returns an additional value created by the action.</source>
          <target state="translated">类似于 &lt;code&gt;createUpToN&lt;/code&gt; ，还返回由操作创建的附加值。</target>
        </trans-unit>
        <trans-unit id="ee95b6c97dc7c4bdba6a1af63ea6a5ab1b1b563e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; bindings, name shadowing is not allowed within an &lt;code&gt;mdo&lt;/code&gt;-expression or a &lt;code&gt;rec&lt;/code&gt;-block; that is, all the names bound in a single &lt;code&gt;rec&lt;/code&gt; must be distinct. (GHC will complain if this is not the case.)</source>
          <target state="translated">就像 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;where&lt;/code&gt; 的绑定，名字阴影不是一个内不允许 &lt;code&gt;mdo&lt;/code&gt; -expression或 &lt;code&gt;rec&lt;/code&gt; -块; 也就是说，单个 &lt;code&gt;rec&lt;/code&gt; 绑定的所有名称都必须是唯一的。（如果不是这种情况，GHC将进行投诉。）</target>
        </trans-unit>
        <trans-unit id="a0a24c56e1b9f366848073186782d64a2635b134" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;seq&lt;/code&gt;, the argument of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; can have an unboxed type.</source>
          <target state="translated">像 &lt;code&gt;seq&lt;/code&gt; 一样， &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 的参数可以具有未装箱的类型。</target>
        </trans-unit>
        <trans-unit id="e6cafc4e6a3f71e112837260dfb933a8b2509697" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;setFileTimesHiRes&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">与 &lt;code&gt;setFileTimesHiRes&lt;/code&gt; 类似,但是使用文件描述符而不是路径。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="e4c941a2f6f4373225d42fc487a0f7d303ff143f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;touchFile&lt;/code&gt; but uses a file descriptor instead of a path. This operation is not supported on all platforms. On these platforms, this function will raise an exception.</source>
          <target state="translated">与 &lt;code&gt;touchFile&lt;/code&gt; 类似,但使用文件描述符而不是路径。并非在所有平台上都支持此操作。在这些平台上，此功能将引发异常。</target>
        </trans-unit>
        <trans-unit id="99cd3e5d292b4b23332a6b2a47c1eadf4be20341" translate="yes" xml:space="preserve">
          <source>Like all other GHCi commands, the output is always displayed in the current GHCi scope (&lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;).</source>
          <target state="translated">像所有其他GHCi命令一样，输出始终显示在当前GHCi范围内（&lt;a href=&quot;#ghci-scope&quot;&gt;提示符处真正在范围内是什么？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ef089d2aac5aa17ae2f559d2e25f348c4bd6fbfe" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">像许多其他Haskell数据结构一样， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是惰性的。这意味着，如果在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中放置昂贵的未评估的thunk ，它将由使用它的线程而不是产生它的线程来评估。确保 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 值放入适当的标准格式的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中，或使用strict-concurrency软件包提供的严格MVar。</target>
        </trans-unit>
        <trans-unit id="bc84715575b0fa376556544c5d2ef3d4d3ec50fb" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">像许多其他Haskell数据结构一样， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是惰性的。这意味着，如果在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中放置昂贵的未经评估的thunk ，它将由使用它的线程而不是产生它的线程来评估。确保 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 值放入适当的标准格式的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中，或使用strict-concurrency软件包提供的严格MVar。</target>
        </trans-unit>
        <trans-unit id="9ac2766b2f81ed2520ff46eac0020d43ebcf3f72" translate="yes" xml:space="preserve">
          <source>Like many other Haskell data structures, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s are lazy. This means that if you place an expensive unevaluated thunk inside an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; values to be placed in an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package.</source>
          <target state="translated">像许多其他Haskell数据结构一样， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是惰性的。这意味着，如果在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中放置昂贵的未评估的thunk ，它将由使用它的线程而不是产生它的线程来评估。确保 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 值放入适当的标准格式的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 中，或使用strict-concurrency软件包提供的严格MVar。</target>
        </trans-unit>
        <trans-unit id="37c17ec186b7de612cb654acafdf92b9e7cdfb9b" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">像其他编译指示一样，将始终检查&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;编译指示是否存在作用域错误，并进行类型检查。类型检查意味着对规则的LHS和RHS进行类型检查，并且必须具有相同的类型。但是，仅当&lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt;标志处于&lt;em&gt;启用状态&lt;/em&gt;时，才&lt;em&gt;启用&lt;/em&gt;规则（请参见&lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3447df87a2c63f15a9f31c14cbaf487254b0da44" translate="yes" xml:space="preserve">
          <source>Like other pragmas, &lt;code&gt;RULE&lt;/code&gt; pragmas are always checked for scope errors, and are typechecked. Typechecking means that the LHS and RHS of a rule are typechecked, and must have the same type. However, rules are only &lt;em&gt;enabled&lt;/em&gt; if the &lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt;&lt;code&gt;-fenable-rewrite-rules&lt;/code&gt;&lt;/a&gt; flag is on (see &lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;).</source>
          <target state="translated">像其他编译指示一样，将始终检查 &lt;code&gt;RULE&lt;/code&gt; 编译指示是否存在范围错误，并进行类型检查。类型检查意味着对规则的LHS和RHS进行类型检查，并且必须具有相同的类型。但是，仅在&lt;a href=&quot;#ghc-flag--fenable-rewrite-rules&quot;&gt; &lt;code&gt;-fenable-rewrite-rules&lt;/code&gt; &lt;/a&gt;标志处于&lt;em&gt;启用状态&lt;/em&gt;时才&lt;em&gt;启用&lt;/em&gt;规则（请参见&lt;a href=&quot;#rule-semantics&quot;&gt;Semantics&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8cd118e46b9ceb5fcb2a8499ea3916b27ce3f424" translate="yes" xml:space="preserve">
          <source>Like the function &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, but appends a stack trace to the error message if one is available.</source>
          <target state="translated">类似于函数 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ，但是将堆栈跟踪附加到错误消息（如果有）。</target>
        </trans-unit>
        <trans-unit id="2b393f82e4729c2fe510cc4df3e3b9d2a29de00f" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, it is possible to explicitly bind type and kind variables in default declarations with a &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">与&lt;a href=&quot;#assoc-inst&quot;&gt;关联实例&lt;/a&gt;一样，可以通过使用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;语言扩展将默认声明中的类型和种类变量显式绑定到 &lt;code&gt;forall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="890d847e558aebfae92e81761cfeaf99e3ee4aed" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, it is possible to explicitly bind type and kind variables in default declarations with a &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">与&lt;a href=&quot;#assoc-inst&quot;&gt;关联实例&lt;/a&gt;一样，可以通过使用&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;语言扩展将默认声明中的类型和种类变量显式绑定到 &lt;code&gt;forall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe3d21a89ef91e153f239215fab5185af22cd639" translate="yes" xml:space="preserve">
          <source>Likewise, the &lt;code&gt;&lt;a href=&quot;control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; operator in some &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functors, and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; in some monads are conditionally lazy and can &lt;em&gt;short-circuit&lt;/em&gt; a chain of computations. The below folds will terminate as early as possible, but even infinite loops can be productive here, when evaluated solely for their stream of IO side-effects. See &lt;a href=&quot;data-traversable#validation&quot;&gt;Data.Traversable&lt;/a&gt; for some additional discussion.</source>
          <target state="translated">同样，某些 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 函子中的 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 运算符和某些单子中的 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 是有条件的惰性对象，可以&lt;em&gt;缩短&lt;/em&gt;计算链。下面的折叠将尽早终止，但仅根据其IO副作用流进行评估时，即使无限循环也可以在此处产生效果。有关其他讨论，请参见&lt;a href=&quot;data-traversable#validation&quot;&gt;Data.Traversable&lt;/a&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24d948e4bdbe5b8224bbc0dfbab1923fab00b98e" translate="yes" xml:space="preserve">
          <source>Limit</source>
          <target state="translated">Limit</target>
        </trans-unit>
        <trans-unit id="70044be8751bf68d4de8b7945e5586e80acb7cb2" translate="yes" xml:space="preserve">
          <source>Limit the number of lines stored in the history.</source>
          <target state="translated">限制历史记录中存储的行数。</target>
        </trans-unit>
        <trans-unit id="ea9676003762818513c636984faeaa0ae356839a" translate="yes" xml:space="preserve">
          <source>Line</source>
          <target state="translated">Line</target>
        </trans-unit>
        <trans-unit id="16fd51c8ab5fd356a1d23d48f4531237b879e504" translate="yes" xml:space="preserve">
          <source>Line and character position</source>
          <target state="translated">行和字符位置</target>
        </trans-unit>
        <trans-unit id="702b953a8e73a9c6b4402eb231caf05c182af7f6" translate="yes" xml:space="preserve">
          <source>Line length.</source>
          <target state="translated">线长。</target>
        </trans-unit>
        <trans-unit id="054f11de365cf7821b8d7f5863692c6cc9051ab6" translate="yes" xml:space="preserve">
          <source>Line number information necessary to map instruction addresses to line numbers in the source program.</source>
          <target state="translated">将指令地址映射到源程序中的行号所需的行号信息。</target>
        </trans-unit>
        <trans-unit id="8087784b605286ef9ef2960647bad3300431de2b" translate="yes" xml:space="preserve">
          <source>LineBuffering</source>
          <target state="translated">LineBuffering</target>
        </trans-unit>
        <trans-unit id="281752024edc1ab9c1f92c79633d55bc44eacd94" translate="yes" xml:space="preserve">
          <source>LineSeparator</source>
          <target state="translated">LineSeparator</target>
        </trans-unit>
        <trans-unit id="37ab103648f9cbe2c3ec3bdbc19ef7d8e446b187" translate="yes" xml:space="preserve">
          <source>Linear and multiplicity-polymorphic arrows are &lt;em&gt;always declared&lt;/em&gt;, never inferred. That is, if you don&amp;rsquo;t give an appropriate type signature to a function, it will be inferred as being a regular function of type &lt;code&gt;a -&amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">线性和多重多态箭头&lt;em&gt;始终被声明&lt;/em&gt;，从不推断。也就是说，如果您没有给函数提供适当的类型签名，则将其推断为a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 类型的常规函数。</target>
        </trans-unit>
        <trans-unit id="6426e1d3a720f52e0ea553a3684fcfe15d605bda" translate="yes" xml:space="preserve">
          <source>Linear types are still considered experimental and come with several limitations. If you have read the full design in the proposal (see &lt;a href=&quot;#linear-types-references&quot;&gt;Design and further reading&lt;/a&gt; below), here is a run down of the missing pieces.</source>
          <target state="translated">线性类型仍被认为是实验性的，并具有一些局限性。如果您已经阅读了提案中的完整设计（请参见下面的&amp;ldquo;&lt;a href=&quot;#linear-types-references&quot;&gt;设计&amp;rdquo;和&amp;ldquo;进一步阅读&amp;rdquo;&lt;/a&gt;），则这里列出了缺少的部分。</target>
        </trans-unit>
        <trans-unit id="d34b558f3fd7232f2c7a2fa63c6617836c82a559" translate="yes" xml:space="preserve">
          <source>LinearTypes</source>
          <target state="translated">LinearTypes</target>
        </trans-unit>
        <trans-unit id="e3b93cdf9997876ced65e2c007d6364b7d627da6" translate="yes" xml:space="preserve">
          <source>LinesAffected</source>
          <target state="translated">LinesAffected</target>
        </trans-unit>
        <trans-unit id="eb1cda622d5b91f2847faea4f7c037e360353e7a" translate="yes" xml:space="preserve">
          <source>Link all passed files into a static library suitable for linking. To control the name, use the &lt;code&gt;-o ⟨file⟩&lt;/code&gt; option as usual. The default name is &lt;code&gt;liba.a&lt;/code&gt;.</source>
          <target state="translated">将所有传递的文件链接到适合链接的静态库中。要控制名称，请照常使用 &lt;code&gt;-o ⟨file⟩&lt;/code&gt; 选项。默认名称为 &lt;code&gt;liba.a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f4a6bdd90ed3ff452ae2e2964b9b2c357b03f32" translate="yes" xml:space="preserve">
          <source>Link in library ⟨lib⟩</source>
          <target state="translated">图书馆中的链接 ⟨lib⟩。</target>
        </trans-unit>
        <trans-unit id="d9cd1bd51d029ba12d6908919f6358ef8b55fb4f" translate="yes" xml:space="preserve">
          <source>Link in the ⟨lib⟩ library. On Unix systems, this will be in a file called &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; or &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; which resides somewhere on the library directories path.</source>
          <target state="translated">链接到&amp;ldquo; lib&amp;rdquo;库。在Unix系统上，该文件位于名为 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.a&lt;/code&gt; 或 &lt;code&gt;lib&lt;em&gt;lib&lt;/em&gt;.so&lt;/code&gt; 的文件中，该文件位于库目录路径中的某个位置。</target>
        </trans-unit>
        <trans-unit id="fcaae5f3f12bcb52dc5f90152a65e0bdbec2c943" translate="yes" xml:space="preserve">
          <source>Link the program with a debugging version of the runtime system. The debugging runtime turns on numerous assertions and sanity checks, and provides extra options for producing debugging output at runtime (run the program with &lt;code&gt;+RTS -?&lt;/code&gt; to see a list).</source>
          <target state="translated">将程序链接到运行时系统的调试版本。调试运行时会打开许多​​断言和健全性检查，并提供其他选项以在运行时生成调试输出（使用 &lt;code&gt;+RTS -?&lt;/code&gt; 运行程序以查看列表）。</target>
        </trans-unit>
        <trans-unit id="aa02a71e52144b5208df7f7113d1f3bb6b6ff3a1" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;eventlog&amp;rdquo; version of the runtime system. A program linked in this way can generate a runtime trace of events (such as thread start/stop) to a binary file &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt;, which can then be interpreted later by various tools. See &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;Tracing&lt;/a&gt; for more information.</source>
          <target state="translated">将程序与运行系统的&amp;ldquo; eventlog&amp;rdquo;版本链接。以这种方式链接的程序可以生成事件的运行时跟踪（例如线程启动/停止）到二进制文件 &lt;code&gt;&lt;em&gt;program&lt;/em&gt;.eventlog&lt;/code&gt; ，然后可以通过各种工具对其进行解释。有关更多信息，请参见&lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;跟踪&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74630b9250c4419175d9406e09096a825645aee9" translate="yes" xml:space="preserve">
          <source>Link the program with the &amp;ldquo;threaded&amp;rdquo; version of the runtime system. The threaded runtime system is so-called because it manages multiple OS threads, as opposed to the default runtime system which is purely single-threaded.</source>
          <target state="translated">将程序与运行系统的&amp;ldquo;线程&amp;rdquo;版本链接。所谓的线程化运行时系统，是因为它管理多个OS线程，而不是默认的纯单线程运行时系统。</target>
        </trans-unit>
        <trans-unit id="e83840f20750c680ebae2cc09ff4df519b21aac5" translate="yes" xml:space="preserve">
          <source>Link the runtime when generating a shared or static library</source>
          <target state="translated">生成共享或静态库时,链接运行时。</target>
        </trans-unit>
        <trans-unit id="a0ad1ef7b6972d54e70158733112a5d174213f28" translate="yes" xml:space="preserve">
          <source>LinkCount</source>
          <target state="translated">LinkCount</target>
        </trans-unit>
        <trans-unit id="05669bed092bbe0873ad6674e013a8667f68fe04" translate="yes" xml:space="preserve">
          <source>LinkLimit</source>
          <target state="translated">LinkLimit</target>
        </trans-unit>
        <trans-unit id="9fa999dc4d8eab9b8471e5d9aa06c5de2dbcdca7" translate="yes" xml:space="preserve">
          <source>Linking type and value level</source>
          <target state="translated">连接类型和价值水平</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="2be1eb803afe605ac5bf0ed36710e67b7cf3ad56" translate="yes" xml:space="preserve">
          <source>List all enabled language extensions.</source>
          <target state="translated">列出所有启用的语言扩展。</target>
        </trans-unit>
        <trans-unit id="4ada7d3f43f0d02ac75493517b3e3afc1c377d07" translate="yes" xml:space="preserve">
          <source>List all of the files or folders beginning with this path.</source>
          <target state="translated">列出所有以该路径开头的文件或文件夹。</target>
        </trans-unit>
        <trans-unit id="d5c60e0858274aa75bbb19a9a06cc630a1d46b1c" translate="yes" xml:space="preserve">
          <source>List all types collected for expressions and (local) bindings currently loaded (while &lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt;&lt;code&gt;:set +c&lt;/code&gt;&lt;/a&gt; was active) with their respective source-code span, e.g.</source>
          <target state="translated">列出所有为当前加载的表达式和（本地）绑定（在&lt;a href=&quot;#ghci-cmd-:set%20+c&quot;&gt; &lt;code&gt;:set +c&lt;/code&gt; &lt;/a&gt;处于活动状态）而收集的表达式类型，以及它们各自的源代码范围，例如</target>
        </trans-unit>
        <trans-unit id="ba8a89a77fc9557b8e8c8d251c8ead9fbdaeb7a1" translate="yes" xml:space="preserve">
          <source>List comprehensions</source>
          <target state="translated">列表理解</target>
        </trans-unit>
        <trans-unit id="3f051a8062e5fac28d61cc364f9f1acc708cd461" translate="yes" xml:space="preserve">
          <source>List index (subscript) operator, starting from 0. It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt;, which takes an index of any integral type.</source>
          <target state="translated">列表索引（下标）运算符，从0开始。它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 的实例，它采用任何整数类型的索引。</target>
        </trans-unit>
        <trans-unit id="754adb8bd3be1191610eae9f21f2c4cd71a1162d" translate="yes" xml:space="preserve">
          <source>List notation, such as &lt;code&gt;[x,y]&lt;/code&gt; or &lt;code&gt;[m..n]&lt;/code&gt; can also be treated via rebindable syntax if you use &lt;code&gt;-XOverloadedLists&lt;/code&gt;; see &lt;a href=&quot;#overloaded-lists&quot;&gt;Overloaded lists&lt;/a&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;-XOverloadedLists&lt;/code&gt; ，还可以通过可重新绑定的语法来处理列表符号，例如 &lt;code&gt;[x,y]&lt;/code&gt; 或 &lt;code&gt;[m..n]&lt;/code&gt; ；请参阅&lt;a href=&quot;#overloaded-lists&quot;&gt;重载列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f89f6b34299ebe78927d05ee13933db3f881f13b" translate="yes" xml:space="preserve">
          <source>List notation, such as &lt;code&gt;[x,y]&lt;/code&gt; or &lt;code&gt;[m..n]&lt;/code&gt; can also be treated via rebindable syntax if you use &lt;code&gt;-XOverloadedLists&lt;/code&gt;; see &lt;a href=&quot;overloaded_lists#overloaded-lists&quot;&gt;Overloaded lists&lt;/a&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;-XOverloadedLists&lt;/code&gt; ，还可以通过可重新绑定的语法来处理列表符号，例如 &lt;code&gt;[x,y]&lt;/code&gt; 或 &lt;code&gt;[m..n]&lt;/code&gt; ；请参阅&lt;a href=&quot;overloaded_lists#overloaded-lists&quot;&gt;重载列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="920d73e463b5cf5eed14ea6d6e2da4031afeaa2c" translate="yes" xml:space="preserve">
          <source>List of associations</source>
          <target state="translated">协会名单</target>
        </trans-unit>
        <trans-unit id="6b46c2d4b10caadfeb5b6a9c62ffb97de0f2b1d4" translate="yes" xml:space="preserve">
          <source>List of elements of a structure, from left to right.</source>
          <target state="translated">一个结构的元素列表,从左到右。</target>
        </trans-unit>
        <trans-unit id="33a6deba502bb1454d149d3118ad9c84618f053e" translate="yes" xml:space="preserve">
          <source>List of elements of a structure, from left to right. If the entire list is intended to be reduced via a fold, just fold the structure directly bypassing the list.</source>
          <target state="translated">一个结构的元素列表,从左到右。如果打算通过折叠来减少整个列表,则直接绕过列表折叠结构。</target>
        </trans-unit>
        <trans-unit id="2d083b1175ab43fb5ee46569148ded37582637a2" translate="yes" xml:space="preserve">
          <source>List of lazy functions</source>
          <target state="translated">懒惰函数列表</target>
        </trans-unit>
        <trans-unit id="72682d906b86160d1433288b665aba1ecaebee43" translate="yes" xml:space="preserve">
          <source>List of short-circuit functions</source>
          <target state="translated">短路功能列表</target>
        </trans-unit>
        <trans-unit id="09c9b0a56436b310fefac1b1b89437d88df5a11b" translate="yes" xml:space="preserve">
          <source>List of strict functions</source>
          <target state="translated">严格函数列表</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">列表操作</target>
        </trans-unit>
        <trans-unit id="5f897200e3f1c653befd6edfbddc4172f95a6a57" translate="yes" xml:space="preserve">
          <source>List patterns are also overloaded. When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, these definitions are desugared as follows</source>
          <target state="translated">列表模式也超载。当 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展开启时，这些定义脱如下</target>
        </trans-unit>
        <trans-unit id="76603bea3fde9f607769b026d910df0dfc04acfc" translate="yes" xml:space="preserve">
          <source>List the active breakpoints.</source>
          <target state="translated">列出活动的断点。</target>
        </trans-unit>
        <trans-unit id="bb72cfc84c631772e908d5b0c3a4205d0c9649a0" translate="yes" xml:space="preserve">
          <source>List the active evaluations that are stopped at breakpoints.</source>
          <target state="translated">列出在断点处停止的活动评价。</target>
        </trans-unit>
        <trans-unit id="d92d0a195ad4655dbddbf91fc436d0a6b999cd58" translate="yes" xml:space="preserve">
          <source>List the frames of a stack trace.</source>
          <target state="translated">列出堆栈跟踪的帧。</target>
        </trans-unit>
        <trans-unit id="b46a3709f9c0d5af2b972568db4b210d8669456f" translate="yes" xml:space="preserve">
          <source>List transformations</source>
          <target state="translated">列表转换</target>
        </trans-unit>
        <trans-unit id="105d6ef74784f6217af666c539a87096be10b1b3" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">清单版本的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8e9efe55b79317a3e563e7e8e801673f73f1521" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 的列表版本</target>
        </trans-unit>
        <trans-unit id="db73b7893f3af8f6c05605cf9251be842b275f8d" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-pprlib#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的列表版本</target>
        </trans-unit>
        <trans-unit id="482dfe339c4f0977581fe5ee524fa53adc1e28ed" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="cfafdd602fb158738556497c46c51d6d60df9768" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="20bd5a0e4fabf718ca894fcb17f676efec0307ae" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="6ceba6d840aab502457ce42ae3fbfeab1ecc2414" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="66e7277f4ef344564d58e60d6ea51d7adf033fef" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="b3158aef4933628130f67b89a618bc8b174d8978" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="745ee4c2660329c820454e1ba2a47f402e1ce21f" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="5594bce20a5038736c0afcf0c55e2622caf81f60" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="7d0b7f90f7aacdb031c45cf80cdd404adafbe362" translate="yes" xml:space="preserve">
          <source>List version of &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">列出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="33a93596bb8da89147bd59e3fe1b97c2d66a5038" translate="yes" xml:space="preserve">
          <source>ListT</source>
          <target state="translated">ListT</target>
        </trans-unit>
        <trans-unit id="c518fb067439705f3ff5fa5b4a62b9be3afa31ae" translate="yes" xml:space="preserve">
          <source>Listen</source>
          <target state="translated">Listen</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="781623c2be49bc87bb9e5a34fe84e216baf4b8b9" translate="yes" xml:space="preserve">
          <source>Lists the source code around the definition of ⟨identifier⟩ or the current breakpoint if not given. This requires that the identifier be defined in an interpreted module. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">列出了围绕⟨identifier⟩定义的源代码,如果没有给定,则列出当前断点。这需要在解释模块中定义标识符。如果你的输出设备支持,那么GHCi会用粗体高亮显示活动的子表达式。</target>
        </trans-unit>
        <trans-unit id="808589d62b1e1bf49e41bd4b6a92d4dc1a0d0f3a" translate="yes" xml:space="preserve">
          <source>Lists the source code around the given line number of ⟨module⟩. This requires that the module be interpreted. If your output device supports it, then GHCi will highlight the active subexpression in bold.</source>
          <target state="translated">列出给定行数的⟨module⟩周围的源代码。这需要对模块进行解释。如果你的输出设备支持它,那么GHCi会用粗体突出显示活动的子表达式。</target>
        </trans-unit>
        <trans-unit id="d4a7facfa8bfb2e9078fe2cd6adc3a55c36788e6" translate="yes" xml:space="preserve">
          <source>Lists, but with an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor based on zipping.</source>
          <target state="translated">列表，但具有基于压缩的 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 函子。</target>
        </trans-unit>
        <trans-unit id="7c730a293f109c2c9fe03256794b5a680b2406f1" translate="yes" xml:space="preserve">
          <source>Lit</source>
          <target state="translated">Lit</target>
        </trans-unit>
        <trans-unit id="1d45d75d6a3cc51b4987b3781a45f5c1345a4a98" translate="yes" xml:space="preserve">
          <source>LitSort</source>
          <target state="translated">LitSort</target>
        </trans-unit>
        <trans-unit id="3c7167176c55c32edbdb72649b122c134066cd84" translate="yes" xml:space="preserve">
          <source>Little-endian</source>
          <target state="translated">Little-endian</target>
        </trans-unit>
        <trans-unit id="0877eccb7ffb8474ab69b0fcf579d9b84daccdd0" translate="yes" xml:space="preserve">
          <source>Little-endian decoding</source>
          <target state="translated">小英译码</target>
        </trans-unit>
        <trans-unit id="c7273f034919f3ef6168c89cba26b3bce836ba9e" translate="yes" xml:space="preserve">
          <source>Little-endian primitives</source>
          <target state="translated">小二烯基元</target>
        </trans-unit>
        <trans-unit id="1c321830ed633cc94628e1e65216ff4ba6a6ed76" translate="yes" xml:space="preserve">
          <source>Little-endian writes</source>
          <target state="translated">Little-endian写道</target>
        </trans-unit>
        <trans-unit id="6fc67654e4796ae3f37595e79dd2e45c3625e5e5" translate="yes" xml:space="preserve">
          <source>LittleEndian</source>
          <target state="translated">LittleEndian</target>
        </trans-unit>
        <trans-unit id="2e67c31b2f3fdce36aeeb1f20caff4b304f70567" translate="yes" xml:space="preserve">
          <source>Ll: Letter, Lowercase</source>
          <target state="translated">Ll:字母,小写</target>
        </trans-unit>
        <trans-unit id="58382029ac6f1e5383d7bade61f6a456488c6bbd" translate="yes" xml:space="preserve">
          <source>Llike &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; but memory is filled with bytes of value zero.</source>
          <target state="translated">与mallocBytes &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; 但内存中填充的值为零。</target>
        </trans-unit>
        <trans-unit id="4288785885201e9bb76e1d0199483effb5fe9f71" translate="yes" xml:space="preserve">
          <source>Lm: Letter, Modifier</source>
          <target state="translated">Lm:信件,修饰语</target>
        </trans-unit>
        <trans-unit id="2fdaaab4868bf18d8a809e1f5f7e47a37f964d96" translate="yes" xml:space="preserve">
          <source>Lo: Letter, Other</source>
          <target state="translated">Lo:信件,其他</target>
        </trans-unit>
        <trans-unit id="8accbc10b359e949cb147175bb580bf3e07dc786" translate="yes" xml:space="preserve">
          <source>Load a plugin exported by a given module</source>
          <target state="translated">加载一个由指定模块导出的插件</target>
        </trans-unit>
        <trans-unit id="51fa1bf18d44ef1d1248c602fa8dd72c62735eea" translate="yes" xml:space="preserve">
          <source>Load the plugin in the given module. The module must be a member of a package registered in GHC&amp;rsquo;s package database.</source>
          <target state="translated">将插件加载到给定的模块中。该模块必须是在GHC的软件包数据库中注册的软件包的成员。</target>
        </trans-unit>
        <trans-unit id="19f77727de15c8eb41a9504fa18fee15c5c48b61" translate="yes" xml:space="preserve">
          <source>Load-balancing shares out the work of GC between the available cores. This is a good idea when the heap is large and we need to parallelise the GC work, however it is also pessimal for the short young-generation collections in a parallel program, because it can harm locality by moving data from the cache of the CPU where is it being used to the cache of another CPU. Hence the default is to do load-balancing only in the old-generation. In fact, for a parallel program it is sometimes beneficial to disable load-balancing entirely with &lt;code&gt;-qb&lt;/code&gt;.</source>
          <target state="translated">负载平衡在可用内核之间共享GC的工作。当堆很大并且我们需要并行化GC工作时，这是一个好主意，但是对于并行程序中的年轻一代短集合来说，这也是一个小技巧，因为它可能会通过从CPU缓存中移出数据来损害局部性。它在哪里用于另一个CPU的缓存。因此，默认设置是仅在旧版本中进行负载平衡。实际上，对于并行程序，有时完全使用 &lt;code&gt;-qb&lt;/code&gt; 禁用负载平衡有时是有益的。</target>
        </trans-unit>
        <trans-unit id="5baeca2bd84e4324195dfc5aa4a5d2fe832d33c9" translate="yes" xml:space="preserve">
          <source>Loading a multi-module program is just as straightforward; just give the name of the &amp;ldquo;topmost&amp;rdquo; module to the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command (hint: &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; can be abbreviated to &lt;code&gt;:l&lt;/code&gt;). The topmost module will normally be &lt;code&gt;Main&lt;/code&gt;, but it doesn&amp;rsquo;t have to be. GHCi will discover which modules are required, directly or indirectly, by the topmost module, and load them all in dependency order.</source>
          <target state="translated">加载多模块程序同样简单。只需在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令中指定&amp;ldquo;最顶层&amp;rdquo;模块的名称即可（提示&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;可以缩写为 &lt;code&gt;:l&lt;/code&gt; ）。最顶层的模块通常是 &lt;code&gt;Main&lt;/code&gt; ，但不是必须的。GHCi将发现最顶层的模块直接或间接需要哪些模块，并以依赖顺序将其全部加载。</target>
        </trans-unit>
        <trans-unit id="3ca542db8dd842ccea2e2f49600e491d4a676f0a" translate="yes" xml:space="preserve">
          <source>Loc</source>
          <target state="translated">Loc</target>
        </trans-unit>
        <trans-unit id="94637a234d4833c0a67b7a4f6b5d70bd1cdd5712" translate="yes" xml:space="preserve">
          <source>Local Time</source>
          <target state="translated">当地时间</target>
        </trans-unit>
        <trans-unit id="ab3cb665e2195c48dc51ad950c912c0fa2cb8e4a" translate="yes" xml:space="preserve">
          <source>Local allocation</source>
          <target state="translated">当地分配</target>
        </trans-unit>
        <trans-unit id="0478f8de1f3f270ad9e2bf09aa44262b4422de07" translate="yes" xml:space="preserve">
          <source>Local name bound outside of the TH AST</source>
          <target state="translated">绑定在TH AST之外的本地名称</target>
        </trans-unit>
        <trans-unit id="93c22935b426d63080a636bc51d84b1a5c5cca31" translate="yes" xml:space="preserve">
          <source>Local, exclusive, left-biased choice: If left parser locally produces any result at all, then right parser is not used.</source>
          <target state="translated">本地的、排他的、左偏的选择:如果左解析器在本地产生任何结果,那么就不使用右解析器。</target>
        </trans-unit>
        <trans-unit id="478df254596a4a4a51b18fe7c43423e110e9c8b9" translate="yes" xml:space="preserve">
          <source>LocalMode</source>
          <target state="translated">LocalMode</target>
        </trans-unit>
        <trans-unit id="9cb40f7cd87e6348d6d2464d28eeaa1636f17835" translate="yes" xml:space="preserve">
          <source>LocalTime</source>
          <target state="translated">LocalTime</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="c72c9f7a9c187a5da0f209dc188fa32ae35d17f4" translate="yes" xml:space="preserve">
          <source>Locale representing American usage.</source>
          <target state="translated">代表美国用法的地域。</target>
        </trans-unit>
        <trans-unit id="b7a9db328cdf327a87303972030f518b2e1143a4" translate="yes" xml:space="preserve">
          <source>Locale support</source>
          <target state="translated">当地支持</target>
        </trans-unit>
        <trans-unit id="6f1b4ce09e502ee2cc257e3b65eb100b21e07dcd" translate="yes" xml:space="preserve">
          <source>LocaleTestFlags</source>
          <target state="translated">LocaleTestFlags</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="04685f4c01bb7310cd3e866073d0858b658078ed" translate="yes" xml:space="preserve">
          <source>Location information about an address from a backtrace.</source>
          <target state="translated">从回溯中获取地址的位置信息。</target>
        </trans-unit>
        <trans-unit id="5131787646387f0d5f88f17ccb4880dde6ba21d3" translate="yes" xml:space="preserve">
          <source>Lock the semaphore, blocking until it becomes available. Since this is done through a system call, this will block the *entire runtime*, not just the current thread. If this is not the behaviour you want, use semThreadWait instead.</source>
          <target state="translated">锁定旗语,阻塞直到它变得可用。因为这是通过系统调用完成的,所以会阻塞整个运行时*,而不仅仅是当前线程。如果这不是你想要的行为,可以使用semThreadWait代替。</target>
        </trans-unit>
        <trans-unit id="79ad9e43cfdad7f13ded5dc73bb870eee73c9832" translate="yes" xml:space="preserve">
          <source>LockMode</source>
          <target state="translated">LockMode</target>
        </trans-unit>
        <trans-unit id="031e1faa819e43723677621db8e08752f93d196c" translate="yes" xml:space="preserve">
          <source>LockRequest</source>
          <target state="translated">LockRequest</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="f768a9742ff93e60b7bb02545b5b0dd507f52d9d" translate="yes" xml:space="preserve">
          <source>Locking mode</source>
          <target state="translated">锁定模式</target>
        </trans-unit>
        <trans-unit id="3c518a9153977589254df029f9697c14bdd187b6" translate="yes" xml:space="preserve">
          <source>Locks a given range in a file handle, To lock an entire file use 0xFFFFFFFFFFFFFFFF for size and 0 for offset.</source>
          <target state="translated">锁定文件句柄中给定的范围,要锁定整个文件,大小用0xFFFFFFFFFFFF,偏移量用0。</target>
        </trans-unit>
        <trans-unit id="db36a6985ae81e7f06f9b77a678b760e42fb6c81" translate="yes" xml:space="preserve">
          <source>Log base 2 (round down) of natural numbers. &lt;code&gt;Log 0&lt;/code&gt; is undefined (i.e., it cannot be reduced).</source>
          <target state="translated">对数以2为底（向下取整）的自然数。 &lt;code&gt;Log 0&lt;/code&gt; 未定义（即，无法减少）。</target>
        </trans-unit>
        <trans-unit id="705364a478cdab0540a4c25854746a42ccf2183f" translate="yes" xml:space="preserve">
          <source>Log events as text to standard output, instead of to the &lt;code&gt;.eventlog&lt;/code&gt; file. The ⟨flags⟩ are the same as for &lt;code&gt;-l&lt;/code&gt;, with the additional option &lt;code&gt;t&lt;/code&gt; which indicates that the each event printed should be preceded by a timestamp value (in the binary &lt;code&gt;.eventlog&lt;/code&gt; file, all events are automatically associated with a timestamp).</source>
          <target state="translated">将事件作为文本记录到标准输出中，而不是记录到 &lt;code&gt;.eventlog&lt;/code&gt; 文件中。⟨flags与 &lt;code&gt;-l&lt;/code&gt; 相同，带有附加选项 &lt;code&gt;t&lt;/code&gt; ，它指示每个打印的事件应带有时间戳记值（在二进制 &lt;code&gt;.eventlog&lt;/code&gt; 文件中，所有事件都将自动与时间戳记关联）。</target>
        </trans-unit>
        <trans-unit id="8c0b83ca797348a57e601331a800396f17173e34" translate="yes" xml:space="preserve">
          <source>Log events in binary format. Without any ⟨flags⟩ specified, this logs a default set of events, suitable for use with tools like ThreadScope.</source>
          <target state="translated">以二进制格式记录事件。在没有指定任何⟨flags⟩的情况下,会记录一组默认的事件,适合与ThreadScope等工具一起使用。</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="f61cb07b41e23ab1a79f15c05c0f8ba5b477ab22" translate="yes" xml:space="preserve">
          <source>Logarithmic-time access to any element with &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">对数时间访问带有 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-33--63-&quot;&gt;!?&lt;/a&gt;&lt;/code&gt; 的任何元素 ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:insertAt&quot;&gt;insertAt&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:deleteAt&quot;&gt;deleteAt&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:adjust-39-&quot;&gt;adjust'&lt;/a&gt;&lt;/code&gt; ，和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:update&quot;&gt;update&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4382c3d779a065ce766f6771a0eda14473b0c8a" translate="yes" xml:space="preserve">
          <source>Logarithmic-time concatenation with &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; &amp;lt;的对数时间级联</target>
        </trans-unit>
        <trans-unit id="c70a3bed95e2afdacbd2edd9f3abf4bff06b5635" translate="yes" xml:space="preserve">
          <source>Logarithmic-time splitting with &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">对数时间的分裂与 &lt;code&gt;&lt;a href=&quot;data-sequence#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cebebf8637724ae58cb90aacf5d8022fb2074f2" translate="yes" xml:space="preserve">
          <source>Look at the Core syntax!</source>
          <target state="translated">看看核心语法吧!</target>
        </trans-unit>
        <trans-unit id="4f44d0f99b2e9f9e75bd7d13f005f42ba7ac90d3" translate="yes" xml:space="preserve">
          <source>Look at the first three elements of a sequence</source>
          <target state="translated">看一个序列的前三个元素</target>
        </trans-unit>
        <trans-unit id="036e3fb15ef00e480fa4d3acf7a733a4ca5f5561" translate="yes" xml:space="preserve">
          <source>Look for the exact match on the name in the built-in command list.</source>
          <target state="translated">在内置的命令列表中寻找与名称完全匹配的内容。</target>
        </trans-unit>
        <trans-unit id="1c5a3aaf89cbcab1e2d9dd0a759cbcb475301525" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">在接口文件中寻找您的功能，然后在编译指示中寻找第三个字段；它应该说 &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; 。字符串表示函数参数的严格性：有关严格性表示法的说明，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/Demand&quot;&gt;GHC注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a08e53663e845cc46457faaa8a00f1851876f2c" translate="yes" xml:space="preserve">
          <source>Look for your function in the interface file, then for the third field in the pragma; it should say &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt;. The ⟨string⟩ gives the strictness of the function&amp;rsquo;s arguments: see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;the GHC Commentary&lt;/a&gt; for a description of the strictness notation.</source>
          <target state="translated">在接口文件中查找您的功能，然后在编译指示中查找第三个字段；它应该说 &lt;code&gt;Strictness: ⟨string⟩&lt;/code&gt; 。字符串表示函数参数的严格性：有关严格性表示法的说明，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/demand&quot;&gt;GHC注释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="646113c2b824e740bba103f465367c553a9eb4ec" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database, and fail if it's not defined.</source>
          <target state="translated">在terminfo数据库中查找一个布尔能力,如果没有定义,则失败。</target>
        </trans-unit>
        <trans-unit id="c4c0a18679ef62e4477ab6e7f74f367ea337ce4c" translate="yes" xml:space="preserve">
          <source>Look up a boolean capability in the terminfo database.</source>
          <target state="translated">在terminfo数据库中查找一个布尔能力。</target>
        </trans-unit>
        <trans-unit id="7a72d8f66e8e9faaac46b9deb897bfc7808a27e2" translate="yes" xml:space="preserve">
          <source>Look up a constructor by its representation</source>
          <target state="translated">通过构造函数的表示形式来查找</target>
        </trans-unit>
        <trans-unit id="c01e8f2c42ad48d0b20e9f727f7dd206fb60685a" translate="yes" xml:space="preserve">
          <source>Look up a numeric capability in the terminfo database.</source>
          <target state="translated">在terminfo数据库中查找一个数字能力。</target>
        </trans-unit>
        <trans-unit id="586b4cdd798272f8e1ea61b1bc18f4217842421c" translate="yes" xml:space="preserve">
          <source>Look up a string capability in the terminfo database. NOTE: This function is deprecated; use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">在terminfo数据库中查找字符串功能。注意：不建议使用此功能；使用 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="a9c5ab2d2d0139456f33ef943c0b402c0ecc56ca" translate="yes" xml:space="preserve">
          <source>Look up an output capability in the terminfo database.</source>
          <target state="translated">在terminfo数据库中查找一个输出能力。</target>
        </trans-unit>
        <trans-unit id="9021c22f55a1940644c0487372237fc2b4baba0e" translate="yes" xml:space="preserve">
          <source>Look up an output capability which takes a fixed number of parameters (for example, &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt;).</source>
          <target state="translated">查找采用固定数量参数的输出功能（例如， &lt;code&gt;Int -&amp;gt; Int -&amp;gt; TermOutput&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f90efbcd7f1eeff6426b782004bd5ca5f919386e" translate="yes" xml:space="preserve">
          <source>Look up the control sequence for a given function sequence. For example, &lt;code&gt;functionKey 12&lt;/code&gt; retrieves the &lt;code&gt;kf12&lt;/code&gt; capability.</source>
          <target state="translated">查找给定功能序列的控制序列。例如， &lt;code&gt;functionKey 12&lt;/code&gt; 检索 &lt;code&gt;kf12&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="fee394d0e5a9ad0f8eab2e63dc20d9771d2d9b1c" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (type namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">在当前接头范围的（类型名称空间）中查找给定名称。有关更多详细信息，请参见&lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1a8bb741760af7e3cd92aaa2b183fc9d4090ffa" translate="yes" xml:space="preserve">
          <source>Look up the given name in the (value namespace of the) current splice's scope. See &lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt; for more details.</source>
          <target state="translated">在当前接头的作用域（的值命名空间）中查找给定名称。有关更多详细信息，请参见&lt;a href=&quot;language-haskell-th-syntax#namelookup&quot;&gt;Language.Haskell.TH.Syntax&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c27f2b60d886938ddc087b401729fa285ab4f28" translate="yes" xml:space="preserve">
          <source>Look up the named Unicode encoding. May fail with</source>
          <target state="translated">查找命名的Unicode编码。可能会失败</target>
        </trans-unit>
        <trans-unit id="ba28f2554c741d83cd517f5e544d7d36306b57bc" translate="yes" xml:space="preserve">
          <source>Look-ahead: returns the part of the input that is left, without consuming it.</source>
          <target state="translated">瞻前顾后:返回输入的剩余部分,不消耗。</target>
        </trans-unit>
        <trans-unit id="5eb4c34799d13148c8206bca4c92597220f71e0b" translate="yes" xml:space="preserve">
          <source>Looks up a &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; by its &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">查找一个 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 其 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="b233a4c41641797d29c66ebedda9a193a0f05643" translate="yes" xml:space="preserve">
          <source>Lookup a constructor via a string</source>
          <target state="translated">通过字符串查找构造函数</target>
        </trans-unit>
        <trans-unit id="9b088da5659869d545bfc9a0cf4258116c580743" translate="yes" xml:space="preserve">
          <source>LossOfPrecision</source>
          <target state="translated">LossOfPrecision</target>
        </trans-unit>
        <trans-unit id="853c95f571d7fa18c42a8e831393f2dd7e6ab65b" translate="yes" xml:space="preserve">
          <source>Low level CString conversions</source>
          <target state="translated">低级CString转换</target>
        </trans-unit>
        <trans-unit id="9a62bf48cdec4e2fa80fc92d8d939e62810d8f8d" translate="yes" xml:space="preserve">
          <source>Low level conversions</source>
          <target state="translated">低级别的转换</target>
        </trans-unit>
        <trans-unit id="e5145ff9d1cf255f56081e2cfd62251c784c3336" translate="yes" xml:space="preserve">
          <source>Low level execution</source>
          <target state="translated">低级别执行</target>
        </trans-unit>
        <trans-unit id="163304e093070531fe3b7fc36d57bfbdbc31b649" translate="yes" xml:space="preserve">
          <source>Low level imperative construction</source>
          <target state="translated">低水平的必要建设</target>
        </trans-unit>
        <trans-unit id="50d7d6709a31a0dba951b8a2031b80d349c3b9d0" translate="yes" xml:space="preserve">
          <source>Low level interaction with CStrings</source>
          <target state="translated">与CStrings的低水平互动</target>
        </trans-unit>
        <trans-unit id="6177301b8c0f30b2a86ceb3d0093fdce68f18734" translate="yes" xml:space="preserve">
          <source>Low level operations</source>
          <target state="translated">低级业务</target>
        </trans-unit>
        <trans-unit id="972a48160fb1f24ef39460baab7e378aa636e944" translate="yes" xml:space="preserve">
          <source>Low word of signed integer multiply.</source>
          <target state="translated">符号整数乘法的低字。</target>
        </trans-unit>
        <trans-unit id="0cabfc67ff1de7a21583a2681ad3451d8a86cf31" translate="yes" xml:space="preserve">
          <source>Low-level action that performs the real close.</source>
          <target state="translated">低级动作,执行真正的关闭。</target>
        </trans-unit>
        <trans-unit id="0b24e544fe7febd646c007e1db09a744758b8a8c" translate="yes" xml:space="preserve">
          <source>Low-level capabilities</source>
          <target state="translated">低级能力</target>
        </trans-unit>
        <trans-unit id="f7ce8d6baf61dc38e2ccf714c9bc7f73b9b6975e" translate="yes" xml:space="preserve">
          <source>Low-level creation of the ParsecT type. You really shouldn't have to do this.</source>
          <target state="translated">低级创建ParsecT类型。你真的不应该这样做。</target>
        </trans-unit>
        <trans-unit id="9ee648a6dd68992ea5cde1cd8d86b7c63d4484d6" translate="yes" xml:space="preserve">
          <source>Low-level manipulation</source>
          <target state="translated">低层次的操纵</target>
        </trans-unit>
        <trans-unit id="9a08a2849208613a25ed31a1dac45b5fb6adb67f" translate="yes" xml:space="preserve">
          <source>Low-level operations</source>
          <target state="translated">低级业务</target>
        </trans-unit>
        <trans-unit id="13fab495e207628ea2444c309679bf776f4535b0" translate="yes" xml:space="preserve">
          <source>Low-level support for text I/O.</source>
          <target state="translated">对文本I/O的低级支持。</target>
        </trans-unit>
        <trans-unit id="f00047587dbdef15842bce850c4a2657569cb360" translate="yes" xml:space="preserve">
          <source>Low-level unpacking of the ParsecT type. To run your parser, please look to runPT, runP, runParserT, runParser and other such functions.</source>
          <target state="translated">ParsecT类型的低级解包。要运行你的解析器,请看runPT、runP、runParserT、runParser等这类函数。</target>
        </trans-unit>
        <trans-unit id="bf0c3ee8ad72ff8c9d2eb19ea3532abdb2e4b477" translate="yes" xml:space="preserve">
          <source>Lowercase pattern syntax functions</source>
          <target state="translated">小写模式语法功能</target>
        </trans-unit>
        <trans-unit id="a6b810d16a3b6d530ef202b4a2d4f83a9f2052b1" translate="yes" xml:space="preserve">
          <source>LowercaseLetter</source>
          <target state="translated">LowercaseLetter</target>
        </trans-unit>
        <trans-unit id="3f339b0acbc3595803d9353e1c9001e104dfb4d7" translate="yes" xml:space="preserve">
          <source>Lt: Letter, Titlecase</source>
          <target state="translated">中尉 信,标题案</target>
        </trans-unit>
        <trans-unit id="fae8b46afcb632cf202e5b21df13474f2135a227" translate="yes" xml:space="preserve">
          <source>Lu: Letter, Uppercase</source>
          <target state="translated">陆:字母,大写</target>
        </trans-unit>
        <trans-unit id="76ecaf2a4852a8a6204487921c653426552025b4" translate="yes" xml:space="preserve">
          <source>Luckily, we know of a function that takes an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; and returns an &lt;code&gt;(m a)&lt;/code&gt;: &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt;, enabling us to run the program and see the expected results:</source>
          <target state="translated">幸运的是，我们知道一个函数需要一个 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 并返回一个 &lt;code&gt;(m a)&lt;/code&gt; ： &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; ，使我们能够运行程序并查看预期结果：</target>
        </trans-unit>
        <trans-unit id="f6d00f67258bac7b9cebb726f8da4dc1bfbef425" translate="yes" xml:space="preserve">
          <source>M1</source>
          <target state="translated">M1</target>
        </trans-unit>
        <trans-unit id="b215a5a119a163d59cea8f190c2384c43d8ef927" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL LEFT WHITE SQUARE BRACKET</source>
          <target state="translated">数学左白方格篮子</target>
        </trans-unit>
        <trans-unit id="3040721941e3243f84460b3f75c97496f9d468d1" translate="yes" xml:space="preserve">
          <source>MATHEMATICAL RIGHT WHITE SQUARE BRACKET</source>
          <target state="translated">数学右方白色方块篮子</target>
        </trans-unit>
        <trans-unit id="b4d743ca88772a1217c91cba52116bdb88ef5d73" translate="yes" xml:space="preserve">
          <source>MArray</source>
          <target state="translated">MArray</target>
        </trans-unit>
        <trans-unit id="4b3e60b5afe51211e63fc50f1522b81c9ed52c4b" translate="yes" xml:space="preserve">
          <source>MBlock size</source>
          <target state="translated">MBlock大小</target>
        </trans-unit>
        <trans-unit id="66d7b21255c88198fbbcee4794e30cfb5de722f2" translate="yes" xml:space="preserve">
          <source>MOUSEINPUT</source>
          <target state="translated">MOUSEINPUT</target>
        </trans-unit>
        <trans-unit id="2dafde4ace7cf035bd8fac9346bb5f75c97c5928" translate="yes" xml:space="preserve">
          <source>MVar</source>
          <target state="translated">MVar</target>
        </trans-unit>
        <trans-unit id="fb09978b40c384ebd545f0a9a7fcdec83351ee76" translate="yes" xml:space="preserve">
          <source>MVar#</source>
          <target state="translated">MVar#</target>
        </trans-unit>
        <trans-unit id="46d2f54777058d8f461ec0e1349a0d4dfc5ea0e9" translate="yes" xml:space="preserve">
          <source>MVars</source>
          <target state="translated">MVars</target>
        </trans-unit>
        <trans-unit id="ff6912e2f0ea1f0a272acab877e81da5e3f73b0e" translate="yes" xml:space="preserve">
          <source>Magenta</source>
          <target state="translated">Magenta</target>
        </trans-unit>
        <trans-unit id="6c6f4a44e9e83aafaa5023b2c1c354521ec83aa4" translate="yes" xml:space="preserve">
          <source>MagicHash</source>
          <target state="translated">MagicHash</target>
        </trans-unit>
        <trans-unit id="597dbcc3afd445131f986826cdf6caa30f1f99dd" translate="yes" xml:space="preserve">
          <source>Maintainer</source>
          <target state="translated">Maintainer</target>
        </trans-unit>
        <trans-unit id="9ed930864a951ac93cbc26664a2297c407da9c9e" translate="yes" xml:space="preserve">
          <source>Maintaining variable bindings, or other shared environment.</source>
          <target state="translated">维护变量绑定,或其他共享环境。</target>
        </trans-unit>
        <trans-unit id="a8a516b79965afb8ee743e8779110117c528ae43" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, stop GHC eta-expanding through a case expression, which is good for performance, but bad if you are using &lt;code&gt;seq&lt;/code&gt; on partial applications.</source>
          <target state="translated">使GHC对其底部的处理更加精确（但另请参阅&lt;a href=&quot;#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; &lt;/a&gt;）。特别是，通过case表达式停止GHC eta扩展，这对性能有好处，但如果在部分应用程序上使用 &lt;code&gt;seq&lt;/code&gt; 则不好。</target>
        </trans-unit>
        <trans-unit id="d7420d41204c439a4f517471040fab645169f4e5" translate="yes" xml:space="preserve">
          <source>Make GHC be more precise about its treatment of bottom (but see also &lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt;&lt;code&gt;-fno-state-hack&lt;/code&gt;&lt;/a&gt;). In particular, GHC will not eta-expand through a case expression.</source>
          <target state="translated">使GHC对其底部的处理更加精确（但另请参阅&lt;a href=&quot;using-optimisation#ghc-flag--fno-state-hack&quot;&gt; &lt;code&gt;-fno-state-hack&lt;/code&gt; &lt;/a&gt;）。特别是，GHC不会通过case表达式进行eta扩展。</target>
        </trans-unit>
        <trans-unit id="2fdef1410de7bb1f110ecf15d30ac3c953aad457" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">使字符串成为具有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 令牌类型的 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="2d2d3352f83dfd1c05932c3401d3d788e9213d3c" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">使字符串成为具有 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 令牌类型的 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="d1084fe0dfb8f51c0fc8e30373108ff6994595e4" translate="yes" xml:space="preserve">
          <source>Make Strings an instance of &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; token type.</source>
          <target state="translated">使字符串成为具有 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 令牌类型的 &lt;code&gt;&lt;a href=&quot;text-parsec#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="c8574286f1db7f5674cdca2f0f347f3d37fbe842" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 的第二个参数作为终结器，在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 被垃圾回收时运行，从而使它指向TMVar的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="3c9caff43c15f5f5ce07d7d17ceba770b1aed418" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">制作指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针，使用第二个参数作为终结器在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 被垃圾收集时运行</target>
        </trans-unit>
        <trans-unit id="59b220e362957ec29f398b074092e745f5e98507" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">使用第二个参数作为终结器，在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 被垃圾回收时运行，从而使它指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="43736e995d33c8137a44869b4d0d5452ba4e560a" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">制作指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针，使用第二个参数作为终结器，在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 被垃圾收集时运行</target>
        </trans-unit>
        <trans-unit id="172869b1cbc85f865a41d6b19398e157d00b6ffc" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is garbage-collected.</source>
          <target state="translated">使用第二个参数作为终结器，在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 被垃圾回收时运行，从而使它指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针。</target>
        </trans-unit>
        <trans-unit id="1a8478949c5b16ca6a4c0c847407471a72f503c5" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">制作指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针，使用第二个参数作为终结器，在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 被垃圾收集时运行</target>
        </trans-unit>
        <trans-unit id="bb1e49e8f1341ae8024c59aa4dfd0a0ff98889ea" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; from an existing file descriptor. Fails if the FD refers to a directory. If the FD refers to a file, &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; locks the file according to the Haskell 2010 single writer/multiple reader locking semantics (this is why we need the &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; argument too).</source>
          <target state="translated">根据现有文件描述符进行 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#t:FD&quot;&gt;FD&lt;/a&gt;&lt;/code&gt; 。如果FD引用目录失败。如果FD引用文件，则 &lt;code&gt;&lt;a href=&quot;ghc-io-fd#v:mkFD&quot;&gt;mkFD&lt;/a&gt;&lt;/code&gt; 会根据Haskell 2010单编写器/多读取器锁定语义来锁定文件（这就是为什么我们需要 &lt;code&gt;&lt;a href=&quot;system-io#t:IOMode&quot;&gt;IOMode&lt;/a&gt;&lt;/code&gt; 参数的）。</target>
        </trans-unit>
        <trans-unit id="c7f75d66c23f2c823051ed78b549c0dc321c99c1" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">制作指向 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 指针，使用第二个参数作为终结器在以下情况下运行 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 被垃圾收集</target>
        </trans-unit>
        <trans-unit id="90c73ab748e0e00da22596dbc5fd000f5f781ad2" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; pointer to an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, using the second argument as a finalizer to run when &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; is garbage-collected</source>
          <target state="translated">使用第二个参数作为要在以下情况下运行的终结器，使指向 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的指针变 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 被垃圾收集</target>
        </trans-unit>
        <trans-unit id="68976173fa646f3a0550c955065f1d56dd3d0c9c" translate="yes" xml:space="preserve">
          <source>Make a StablePtr that can be passed to the C function &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. The RTS wants a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt;, but a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; can only refer to lifted types, so we have to cheat by coercing.</source>
          <target state="translated">制作一个可以传递给C函数 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 的StablePtr。RTS希望对基础 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MVar-35-&quot;&gt;MVar#&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; ，但是 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:StablePtr-35-&quot;&gt;StablePtr#&lt;/a&gt;&lt;/code&gt; 只能引用提升类型，因此我们必须通过强制作弊。</target>
        </trans-unit>
        <trans-unit id="340793623e1a085d7b8da534d1c4b5daea514359" translate="yes" xml:space="preserve">
          <source>Make a mutable array immutable, without copying.</source>
          <target state="translated">使一个可变数组不可变,不需要复制。</target>
        </trans-unit>
        <trans-unit id="c7e012d6c09327d0dafcfeae27a661402dd25db0" translate="yes" xml:space="preserve">
          <source>Make a mutable array of arrays immutable, without copying.</source>
          <target state="translated">使一个可变的数组成为不可变的数组,不需要复制。</target>
        </trans-unit>
        <trans-unit id="698be6d083fa7f3ca40015a52bb017297e592080" translate="yes" xml:space="preserve">
          <source>Make a mutable byte array immutable, without copying.</source>
          <target state="translated">使一个可变的字节数组成为不可变的,不需要复制。</target>
        </trans-unit>
        <trans-unit id="46fdb0fb8e4b555aaff57055206c3612f29ab2c3" translate="yes" xml:space="preserve">
          <source>Make a path absolute, normalize the path, and remove as many indirections from it as possible. Any trailing path separators are discarded via &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt;. Additionally, on Windows the letter case of the path is canonicalized.</source>
          <target state="translated">将路径设为绝对，规范化路径，并从其中删除尽可能多的间接访问。任何尾随路径分隔符都通过 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:dropTrailingPathSeparator&quot;&gt;dropTrailingPathSeparator&lt;/a&gt;&lt;/code&gt; 丢弃。此外，在Windows上，路径的字母大小写被规范化。</target>
        </trans-unit>
        <trans-unit id="186ec7bfc50eae0a8d365be8aba8bea7326758f0" translate="yes" xml:space="preserve">
          <source>Make a reference to a local value that we can send remotely. This reference will keep the value that it refers to alive until &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">引用我们可以远程发送的本地值。在调用 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#v:freeRemoteRef&quot;&gt;freeRemoteRef&lt;/a&gt;&lt;/code&gt; 之前，此引用将保留它引用的值。</target>
        </trans-unit>
        <trans-unit id="3c87f88ba73344e1ab783a73a9a5979fecf885d2" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">制作一个唯一的目录。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是创建的目录的路径，该目录用6个随机字符填充。该参数是要创建的临时目录的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="8d3ca167e4c389a68d7893e4900b4c3fb3ba06a9" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">制作一个唯一的目录。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是创建的目录的路径，该目录用6个随机字符填充。该参数是要创建的临时目录的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="c74d346c4da5940c1912b0eac5540bbe7a580ada" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">制作一个唯一的目录。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是创建的目录的路径，该目录用6个随机字符填充。该参数是要创建的临时目录的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="81daa0d04fc3934a4c048011fb03208252f865cf" translate="yes" xml:space="preserve">
          <source>Make a unique directory. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the path of the created directory, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary directory to be created.</source>
          <target state="translated">制作一个唯一的目录。返回的 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 是创建的目录的路径，该目录用6个随机字符填充。该参数是要创建的临时目录的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="6a7af8c778c02a1f594bc3983b00324c16ab69b7" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">制作一个唯一的文件名并打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的路径（可能是相对路径），并用6个随机字符填充。该参数是要创建的临时文件的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="330d0dcda662cdafbb50eaf0cfa0b95ff8c0f42d" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">制作一个唯一的文件名并打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的路径（可能是相对路径），并用6个随机字符填充。该参数是要创建的临时文件的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="510be01a4433f345cddd74c7e143b3b18d7042bb" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">制作一个唯一的文件名并打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的路径（可能是相对路径），并用6个随机字符填充。该参数是要创建的临时文件的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="55c11d94c0f07317aebbc90457dbda2e57127b10" translate="yes" xml:space="preserve">
          <source>Make a unique filename and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which is padded with 6 random characters. The argument is the desired prefix of the filepath of the temporary file to be created.</source>
          <target state="translated">制作一个唯一的文件名并打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的路径（可能是相对路径），并用6个随机字符填充。该参数是要创建的临时文件的文件路径的所需前缀。</target>
        </trans-unit>
        <trans-unit id="f72f7ad8e05097abb6ee289f5eba19d0e1965f5c" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">制作一个具有给定前缀和后缀的唯一文件名，然后将其打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的路径（可能是相对路径），该路径在前缀和后缀之间包含6个随机字符。第一个参数是要创建的临时文件的文件路径的所需前缀。第二个参数是要创建的临时文件的后缀。</target>
        </trans-unit>
        <trans-unit id="95866426633d8275aa8fda94a7e85fdc02e90eb7" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">制作一个具有给定前缀和后缀的唯一文件名，然后将其打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的（可能是相对的）路径，该路径在前缀和后缀之间包含6个随机字符。第一个参数是要创建的临时文件的文件路径的所需前缀。第二个参数是要创建的临时文件的后缀。</target>
        </trans-unit>
        <trans-unit id="1c2d72bf515d3058a7049dde45a964b650627ffb" translate="yes" xml:space="preserve">
          <source>Make a unique filename with a given prefix and suffix and open it for reading/writing. The returned &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; is the (possibly relative) path of the created file, which contains 6 random characters in between the prefix and suffix. The first argument is the desired prefix of the filepath of the temporary file to be created. The second argument is the suffix of the temporary file to be created.</source>
          <target state="translated">制作一个具有给定前缀和后缀的唯一文件名，然后将其打开以进行读取/写入。返回的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 是所创建文件的（可能是相对的）路径，该路径在前缀和后缀之间包含6个随机字符。第一个参数是要创建的临时文件的文件路径的所需前缀。第二个参数是要创建的临时文件的后缀。</target>
        </trans-unit>
        <trans-unit id="3855d0f70cdfe996ae50f55037d364c1d1456c5b" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="393f21690a4ea611c6c45f302e4ee432d74df383" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍然允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以用作 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标。，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="82f94594233f4381e0de2f863949173a4888fe87" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="6c15a521855fa1db7d583391896bbe67487efc38" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="0efc78aad57ab0b135f7ad0c2ee2f1ea5372a73a" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍然允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以用作 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标。，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="2d033fcc13dd280fccc1b69e179fcb458f3b3db2" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="86ec4e16e20a04abfbb1ac99cdbce02e8ced1057" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="a77491851c6d1ffca83dc5af796a06989b259ab9" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍然允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以用作 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标。，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="d654a324a0882e03ad1f59875092013e6ecc780a" translate="yes" xml:space="preserve">
          <source>Make a weak pointer to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;. It can be important to do this if you want to hold a reference to a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; while still allowing the thread to receive the &lt;code&gt;BlockedIndefinitely&lt;/code&gt; family of exceptions (e.g. &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;). Holding a normal &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; reference will prevent the delivery of &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions because the reference could be used as the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; at any time, which would unblock the thread.</source>
          <target state="translated">使一个弱指针指向 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 。如果要保留对 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 的引用，同时仍允许线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常家族（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ），则这样做很重要。持有普通的 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 引用将阻止传递 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常，因为该引用可以随时用作 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的目标，这将取消阻塞线程。</target>
        </trans-unit>
        <trans-unit id="9f678ce0a5f94456a91a790fc3be2c2ec6925020" translate="yes" xml:space="preserve">
          <source>Make an immutable array mutable, without copying.</source>
          <target state="translated">使一个不可变的数组可以突变,无需复制。</target>
        </trans-unit>
        <trans-unit id="df39c3ecba9f1a1d5927f8873184709183484ed4" translate="yes" xml:space="preserve">
          <source>Make bindings in the current module strict by default.</source>
          <target state="translated">使当前模块中的绑定默认为严格。</target>
        </trans-unit>
        <trans-unit id="b462570effd4237ee90c797f361ccb9ef392f0ca" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;</source>
          <target state="translated">使依赖项声明带有后缀 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 的文件依赖于带有后缀的接口文件 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="1b9d645523fe749f3d314ba22eb6324344c7aca9" translate="yes" xml:space="preserve">
          <source>Make dependencies that declare that files with suffix &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; depend on interface files with suffix &lt;code&gt;.⟨suf⟩hi&lt;/code&gt;, or (for &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports) on &lt;code&gt;.hi-boot&lt;/code&gt;. Multiple &lt;code&gt;-dep-suffix&lt;/code&gt; flags are permitted. For example, &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; will make dependencies for &lt;code&gt;.hs&lt;/code&gt; on &lt;code&gt;.hi&lt;/code&gt;, &lt;code&gt;.a_hs&lt;/code&gt; on &lt;code&gt;.a_hi&lt;/code&gt;, and &lt;code&gt;.b_hs&lt;/code&gt; on &lt;code&gt;.b_hi&lt;/code&gt;. Note that you must provide at least one suffix; if you do not want a suffix then pass &lt;code&gt;-dep-suffix ''&lt;/code&gt;.</source>
          <target state="translated">制作的依赖关系声明以后缀的文件 &lt;code&gt;.⟨suf⟩⟨osuf⟩&lt;/code&gt; 取决于接口文件后缀 &lt;code&gt;.⟨suf⟩hi&lt;/code&gt; ，或（对于 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 进口）上 &lt;code&gt;.hi-boot&lt;/code&gt; 。允许使用多个 &lt;code&gt;-dep-suffix&lt;/code&gt; 标志。例如， &lt;code&gt;-dep-suffix a_ -dep-suffix b_&lt;/code&gt; 将使 &lt;code&gt;.hs&lt;/code&gt; 对 &lt;code&gt;.hi&lt;/code&gt; ， &lt;code&gt;.a_hs&lt;/code&gt; 对 &lt;code&gt;.a_hi&lt;/code&gt; 和 &lt;code&gt;.b_hs&lt;/code&gt; 对 &lt;code&gt;.b_hi&lt;/code&gt; s具有依赖性。请注意，您必须至少提供一个后缀。如果您不想要后缀，请传递 &lt;code&gt;-dep-suffix ''&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f58245b56849264d71b5f006aa40914e92e5165" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict</source>
          <target state="translated">让字典变得严格</target>
        </trans-unit>
        <trans-unit id="f7e4637506fdb1c126cf33d58aefa19e41c7d250" translate="yes" xml:space="preserve">
          <source>Make dictionaries strict.</source>
          <target state="translated">让字典严格起来。</target>
        </trans-unit>
        <trans-unit id="5455661e420f1ccaf72cf9dabbbfecf771d7db4a" translate="yes" xml:space="preserve">
          <source>Make dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">让字典价值的表达方式在优化器看来很便宜。</target>
        </trans-unit>
        <trans-unit id="6f85a3e8f6df876856512758475047874462d99e" translate="yes" xml:space="preserve">
          <source>Make fields of data types defined in the current module strict by default.</source>
          <target state="translated">使当前模块中定义的数据类型的字段默认为严格。</target>
        </trans-unit>
        <trans-unit id="af0e48df1414b6d5a7855574141f6461c5ce4805" translate="yes" xml:space="preserve">
          <source>Make suggestions for mis-spelled names.</source>
          <target state="translated">对拼写错误的名字提出建议。</target>
        </trans-unit>
        <trans-unit id="88ce76b97dc5f41df8b9eb8175635106d378b209" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">确保关闭了let-floating（ &lt;code&gt;-fno-full-laziness&lt;/code&gt; ），或者确保对 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的调用不能在lambda之外浮动。例如，如果您说： &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; ，则可能只获得对 &lt;code&gt;f&lt;/code&gt; 的所有调用之间共享的一个参考单元。最好是 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 因为现在它无法在lambda之外浮动。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
