<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="translated">如果您不关心leap秒，可以使用 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;NominalDiffTime&lt;/code&gt; 进行时钟计算，这样就可以了。</target>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">如果你不关心排序，考虑使用 &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; 从&lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;无序的容器&lt;/a&gt;包装来代替。</target>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">如果你不关心排序，可以考虑使用 &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; 从&lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;无序的容器&lt;/a&gt;包装来代替。</target>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">如果不使用 &lt;code&gt;-threaded&lt;/code&gt; 选项，则运行时不会使用多个OS线程。外部调用将阻塞所有其他正在运行的Haskell线程，直到调用返回。该&lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt;库仍然无法复用，所以可以有多个线程执行I / O，而这是内部运行时处理使用 &lt;code&gt;select&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">如果无法测试该标志并使用它（尽管未定义），则 &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">如果无法测试该标志并使用它（尽管未定义），则 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">如果无法测试该标志并使用它（尽管未定义），则 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">如果您强烈认为上述限制中的任何一项过于繁重，&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;请向GHC小组大喊一声&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57825a77683045fd11cf61c7e2280d83f489c5c5" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="translated">如果你觉得你的代码需要修改这些设置,请查阅源代码的默认值和文档。但我强烈建议不要这样做。</target>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="translated">如果你发现明显的性能回归,可以追溯到明显的糟糕的代码布局,请开一个票。</target>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="translated">如果您忘记了 &lt;code&gt;-watch&lt;/code&gt; 标志，您仍然可以从&amp;ldquo;状态&amp;rdquo;菜单中选择&amp;ldquo;监视文件&amp;rdquo;。现在，每次您生成新的配置文件 &lt;code&gt;FOO.ps&lt;/code&gt; 时，视图都会自动更新。</target>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="translated">如果您启用了&lt;a href=&quot;#unboxed-tuples&quot;&gt;拆箱元组&lt;/a&gt;，则元组部分也将可用。</target>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="translated">如果对编码格式有特定要求，则可以直接使用编码和解码原语，请参阅模块&lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt;和&lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="translated">如果您必须使用绝对路径（请注意makefile层次结构中无害的 &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; 或配置脚本），Cygwin提供了一种名为 &lt;code&gt;cygpath&lt;/code&gt; 的工具，该工具可以将Cygwin的Unix样式的路径转换为其实际的Windows样式的路径。许多Cygwin工具实际上接受绝对的Windows风格的路径（不过请记住，您需要转义 &lt;code&gt;\\&lt;/code&gt; 或将 &lt;code&gt;\\&lt;/code&gt; 转换为 &lt;code&gt;/&lt;/code&gt; ），因此，只要在各处使用这些路径就可以了。如果您需要使用根据Unix样式路径进行某种路径处理的工具（一个有趣的示例正在尝试将解释为 &lt;code&gt;:&lt;/code&gt; 作为路径列表中的分隔符），您仍然可以尝试使用 &lt;code&gt;cygpath&lt;/code&gt; 转换路径 在将它们传递给GHC和朋友之前。</target>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="translated">如果由于 &lt;code&gt;/tmp&lt;/code&gt; 空间不足（或安装认为应该&lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;临时文件的位置）而遇到麻烦，则可以使用-tmpdir⟨dir⟩选项来指定备用目录。例如， &lt;code&gt;-tmpdir .&lt;/code&gt; 表示将临时文件放在当前工作目录中。</target>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="translated">如果你事先知道你将处理具有特定编码(如UTF-8)的数据,而且你的应用程序对性能高度敏感,你可能会发现使用字节串来执行I/O,并自己进行编码和解码比使用本模块中的函数要快。</target>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">如果您在本地定义一个指定 &lt;code&gt;type Elem = Char&lt;/code&gt; 的签名，则现在可以使用继承的签名中的 &lt;code&gt;head&lt;/code&gt; ，就好像它返回了 &lt;code&gt;Char&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="translated">如果您对源代码进行了一些更改，并希望GHCi重新编译程序，请提供&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;命令。该程序将根据需要进行重新编译，如果它们的外部依存关系没有改变，则GHCi会尽力避免实际重新编译模块。这与我们避免在批处理编译设置中重新编译模块所使用的机制相同（请参阅&lt;a href=&quot;separate_compilation#recomp&quot;&gt;重新编译检查器&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="translated">如果你必须在旧版本的GHC上使用非UTF-8编码,你将不得不自己执行转码,例如,如下所示。</target>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">如果您需要反复用子字符串来断开字符串（例如，您想在子字符串的每个实例上断开），请改用 &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; ，因为它具有较低的启动开销。</target>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">如果您需要反复用子字符串来断开字符串（例如，您想在子字符串的每个实例上断开），请改用 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; ，因为它具有较低的启动开销。</target>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="translated">如果需要在异常处理程序中再次取消屏蔽异步异常，则也可以在其中使用 &lt;code&gt;restore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="translated">如果您需要编写自己的生成器原语，那么请注意，您正在编写&lt;em&gt;所有安全带都关闭的&lt;/em&gt;代码；即，*这是可能使您的应用程序容易受到缓冲区溢出攻击的代码！* &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt;模块为您提供了用于彻底测试编码的实用程序。</target>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="translated">如果将接口文件重定向到GHC无法找到的位置，那么重新编译检查器可能会感到困惑（至少，您不会避免任何重新编译）。如果可能的 &lt;code&gt;-hidir&lt;/code&gt; ，我们建议使用-hidir和 &lt;code&gt;-hisuf&lt;/code&gt; 选项的组合。</target>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="translated">如果在Cygwin或MSYS Shell中运行GHCi，则Control-C行为将受到不利影响。在这些环境之一中，应使用 &lt;code&gt;ghcii.sh&lt;/code&gt; 脚本启动GHCi，否则当您按Control-C时，将返回到Shell提示符，但GHCi进程仍将运行。但是，即使使用 &lt;code&gt;ghcii.sh&lt;/code&gt; 脚本，如果您按Control-C，则GHCi进程将立即终止，而不是让您中断GHCi内部正在运行的程序。此问题是由于Cygwin和MSYS Shell环境不会将Control-C事件传递给非Cygwin子进程这一事实引起的，因为要这样做，必须有Windows控制台。</target>
        </trans-unit>
        <trans-unit id="baf4b7d8b90c0aee801d209afdb87b81f931a2c9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">如果在链接时适当地设置了 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 标志（请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;），则可以在运行程序时在命令行上提供RTS选项。</target>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="translated">如果指定可选的&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;，GHC还将通过扩展类型同义词和评估类型功能应用程序来对类型进行标准化，并显示标准化结果。</target>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="translated">如果从命令行启动GHCi，则GHCi的当前目录与从其启动的Shell的当前目录相同。如果从Windows中的&amp;ldquo;开始&amp;rdquo;菜单启动GHCi，则当前目录可能类似于 &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="translated">如果在咨询了本节之后仍然有问题，则可能是发现了&lt;em&gt;错误-&lt;/em&gt;请报告！有关如何&lt;a href=&quot;intro#bug-reporting&quot;&gt;报告错误&lt;/a&gt;的详细信息以及我们希望了解的有关您的错误的列表，请参见GHC中的报告错误。如有疑问，请发送报告-我们喜欢愤怒用户的邮件：-！</target>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="translated">如果提供 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; ，则应确保：</target>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="translated">如果您提供 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; ，请确保：</target>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="translated">如果你同时提供这两样东西,你也应该确保。</target>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">如果您将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值视为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值的数组（不是），则会冒编写效率低下的代码的风险。</target>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="translated">如果你认为GHC可以产生一个更好的错误信息,请将其作为一个bug报告。</target>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="translated">如果打开 &lt;code&gt;+t&lt;/code&gt; 选项，GHCi将显示由语句限制的每个变量的类型。例如：</target>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="translated">如果使用 &lt;code&gt;ghc --make&lt;/code&gt; 而不使用 &lt;code&gt;-o&lt;/code&gt; ，则GHC将为可执行文件选择名称，它将基于包含模块 &lt;code&gt;Main&lt;/code&gt; 的文件的名称。请注意，使用GHC时，不必将 &lt;code&gt;Main&lt;/code&gt; 模块放入 &lt;code&gt;Main.hs&lt;/code&gt; 文件中。因此两者</target>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">如果使用&lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt;标志，GHC会警告您任何多态的本地绑定。作为警告的一部分，GHC还报告推断的类型。该选项默认情况下处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;-T&lt;/code&gt; 标志，则应使用&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;访问统计信息。</target>
        </trans-unit>
        <trans-unit id="b229e3d5ff9a118b7d23643c61f72dbd7947f474" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="translated">如果您使用 &lt;code&gt;-s&lt;/code&gt; 标志，则在程序完成时，您将看到类似这样的信息（具体细节将取决于您所拥有的RTS类型，例如，仅当您的RTS被编译用于性能分析时，您才会看到性能数据） ：</target>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="translated">如果使用 &lt;code&gt;-t&lt;/code&gt; 标志，则在程序完成时，您将看到类似以下内容：</target>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">如果使用标志&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt;，则GHC将在创建孤立模块时警告您。像任何警告一样，您可以使用&lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt;关闭警告，并且&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;将在发出警告时使编译失败。</target>
        </trans-unit>
        <trans-unit id="5c0d6aaecc809c7a412ba9777573bc108e4291b9" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="translated">如果你想要一个真正适用于重载类方法的rule,唯一的方法是这样的。</target>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="translated">如果要强制性多态性，主要的解决方法是使用新类型包装器。该 &lt;code&gt;id runST&lt;/code&gt; 例如可以使用此解决办法是这样写：</target>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="translated">如果你想要行缓冲的行为,就像在GHC中一样,你可以这样启动你的程序。</target>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="translated">如果要使用后一种类型，则可以显式编写 &lt;code&gt;forall&lt;/code&gt; 。实际上，强烈建议对2级类型的用户这样做。</target>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="translated">如果要让程序在退出之前等待子线程完成，则需要自己进行编程。一种简单的机制是让每个子线程在完成时都写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; ，并让主线程在退出所有 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 之前等待：</target>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="translated">如果你想把一些数据也从C回调传回Haskell,最好的办法是先在Haskell中分配一些内存来接收数据,然后把地址传给C,就像上面的例子一样。</target>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要通过Windows创建硬链接，请改用 &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果要通过Windows创建符号链接，请改用 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果要在引发异常的情况下进行一些清理，请使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; ，方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="translated">如果你想手动完成这些步骤,或者正在编写自己的构建系统,那么必须遵循一定的惯例。构建一个输出 Haskell 代码的共享库,以便被其他 Haskell 代码使用,这比输出 C API 并将被 C 代码使用的库要复杂一些。如果你弄错了,你通常会以链接器错误告终。</target>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="translated">如果你想给成本中心起一个与函数名称不同的名字,你可以给注解传递一个字符串。</target>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="translated">如果你想在你的标准 Haskell 代码中使用断言,你可以定义一个类似下面的函数。</target>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">如果要在程序中提及任何原始数据类型或操作，则必须首先导入 &lt;code&gt;GHC.Prim&lt;/code&gt; 以将它们纳入范围。其中许多名称以 &lt;code&gt;#&lt;/code&gt; 结尾，要提及此类名称，您需要使用&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展名。</target>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="translated">如果要退出所有预处理，只需在路径中明确使用命名空间即可。由于此更改，如果您需要打开原始设备（例如COM端口），则需要显式使用设备名称空间。（例如 &lt;code&gt;\\.\COM1&lt;/code&gt; ）。通常，GHC和Haskell程序不再支持旧格式的打开设备。</target>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="translated">如果要从签名 &lt;code&gt;module SigName&lt;/code&gt; 导出实体，则还必须包括模块SigName导出，以便导出签名中定义的所有实体。例如，以下模块从 &lt;code&gt;Prelude&lt;/code&gt; 导出 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">如果要在以后使用它，请确保在最后一次使用指针之后 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; ，这样就不会太早释放该数组。</target>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">如果要在以后使用它，请确保在最后一次使用指针之后 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; ，这样就不会太早释放该数组。</target>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="translated">如果你想自己写好消费者或生产者,可以看看上述函数的前言定义,看看如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">如果您希望GHC检查每个导出的顶层函数/值是否具有类型签名，而不检查未导出的值，请使用&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt;选项。此选项优先于&lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt;。作为警告的一部分，GHC还报告推断的类型。该选项默认情况下处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="translated">如果您希望GHC检查每个模式同义词是否都具有类型签名，请使用&lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt; &lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt; &lt;/a&gt;选项。如果将此选项与&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt;结合使用，则仅导出的模式同义词必须具有类型签名。GHC还报告推断的类型。该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">如果您希望GHC检查每个顶级函数/值是否具有类型签名，请使用&lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt;选项。作为警告的一部分，GHC还报告推断的类型。该选项默认情况下处于关闭状态。</target>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">如果您真的很偏执，&lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt; &lt;code&gt;-dcore-lint&lt;/code&gt; &lt;/a&gt;选项是一个不错的选择。它打开了GHC中的重量级通道内完整性检查。（它检查GHC的健全性，而不是您的健全性。）</target>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="translated">如果您使用的是 &lt;code&gt;Complex&lt;/code&gt; ，则一定要使用 &lt;code&gt;Complex Double&lt;/code&gt; 而不是 &lt;code&gt;Complex Float&lt;/code&gt; （前者是专门化的，而后者则不是）。</target>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="translated">如果使用Cabal，则软件包的公开状态或隐藏状态无关紧要：可用的软件包由 &lt;code&gt;.cabal&lt;/code&gt; 规范中列出的依赖项确定。软件包的公开/隐藏状态仅在直接使用 &lt;code&gt;ghc&lt;/code&gt; 或 &lt;code&gt;ghci&lt;/code&gt; 时才相关。</target>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果您希望能够将环境变量设置为空白字符串，请使用 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="translated">如果您使用的是 &lt;code&gt;GHC.Generics&lt;/code&gt; ，则应考虑使用&lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt;软件包，其中包含许多有用的泛型函数。</target>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">如果您的 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 也是 &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; ，那么一个流行的定义是</target>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">如果您的 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 也是 &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; ，那么一个流行的定义是</target>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="translated">如果你的数据类型有单场一个构造函数，使用 &lt;code&gt;newtype&lt;/code&gt; 声明，而不是 &lt;code&gt;data&lt;/code&gt; 声明。该 &lt;code&gt;newtype&lt;/code&gt; 在大多数情况下被优化掉。</target>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="translated">如果程序包含多个模块，则只需告诉GHC包含 &lt;code&gt;Main&lt;/code&gt; 模块的源文件的名称，GHC就会检查 &lt;code&gt;import&lt;/code&gt; 声明以查找组成程序的其他模块并找到其源文件。这意味着，除 &lt;code&gt;Main&lt;/code&gt; 模块外，每个源文件都应以其包含的模块名称命名（用目录分隔符替换点）。例如，模块 &lt;code&gt;Data.Person&lt;/code&gt; 将位于Unix / Linux / Mac上的 &lt;code&gt;Data/Person.hs&lt;/code&gt; 文件中，或者位于Windows上的 &lt;code&gt;Data\Person.hs&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="translated">如果您的程序中没有外部调用，也没有对已知的不安全函数的调用（例如 &lt;code&gt;unsafePerformIO&lt;/code&gt; ），则崩溃在GHC系统中始终是一个BUG，除了一种情况：如果您的程序由多个模块组成，则每个模块模块必须在其依赖的任何模块之后进行编译（除非您使用 &lt;code&gt;.hi-boot&lt;/code&gt; 文件，在这种情况下，这些文件对于模块源&lt;em&gt;必须&lt;/em&gt;正确）。</target>
        </trans-unit>
        <trans-unit id="6d6ef9a1cfc5c74eeeabcdcb897c3ce978bdc728" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; or &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">如果程序的GC统计信息（ &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS选项）表明它正在执行大量垃圾收集（例如，超过20％的执行时间），则可能需要更多内存-使用 &lt;code&gt;-H⟨size⟩&lt;/code&gt; 或 &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS选项（请参阅&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;）。根据经验，尝试将 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 设置为您愿意让进程使用的内存量，或者尝试传递 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 不带任何参数的方式让GHC根据内存量来计算值实时数据。</target>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="translated">如果你的共享库导出了一个 Haskell API,那么你就不能直接把它链接到另一个 Haskell 程序中并使用那个 Haskell API。你会得到链接器错误。相反,你必须按照上面一节中的描述将其制作成一个包。</target>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">如果省略了⟨n⟩,则假设为2级。</target>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="translated">如果&amp;ldquo;提示 &lt;code&gt;&quot;&lt;/code&gt; 以&amp;ldquo;&amp;rdquo;开头，则将其解析为Haskell字符串；否则将其视为文字字符串。</target>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="translated">如果省略了&amp;ldquo; size&amp;rdquo;，那么垃圾收集器将使用前一个GC的堆大小作为&amp;ldquo; size&amp;rdquo;。这样的效果是允许使用更大的 &lt;code&gt;-A&lt;/code&gt; 值，但不会增加程序的整体内存要求。当默认的 &lt;code&gt;-A&lt;/code&gt; 小值不是最佳值时，它可能会很有用，因为它可能在创建大量长期数据的程序中使用。</target>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="translated">如果作为 &lt;code&gt;Set a&lt;/code&gt; a之类的类型构造函数的库作者要阻止模块的用户编写 &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt; ，则需要将 &lt;code&gt;Set&lt;/code&gt; 的type参数的角色设置为 &lt;code&gt;nominal&lt;/code&gt; ，通过写</target>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="translated">但是，如果在编译包含（D）的模块时启用扩展名&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;，则GHC将改为选择（C），而不会抱怨后续实例化的问题。</target>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">如果在任何维度上下限都大于上限，则该数组是合法的，但为空。索引空数组总是会产生数组边界错误，但是 &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 仍然会产生构造数组的边界。</target>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">如果在任何维度上下限都大于上限，则该数组是合法的，但为空。索引空数组总是会产生数组边界错误，但是 &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 仍然会产生构造数组的边界。</target>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">如果在任何维度上下限都大于上限，则该数组是合法的，但为空。索引空数组总是会产生数组边界错误，但是 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; 仍然会产生构造数组的边界。</target>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">如果改为使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; ，则会在每次比较时对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 进行评估，从而得出 \（O（n \ log n）\）而不是\（O（n）\）。</target>
        </trans-unit>
        <trans-unit id="2bb6b96d1379082a5862430606e077e4951c8b2d" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">相反，如果使用了 &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; ，则会在每次比较时对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 进行评估，从而得出\（O（n \ log n）\）而不是\（O（n）\）。</target>
        </trans-unit>
        <trans-unit id="a830bfeca5ac45c0e56970fbc2cc9313f12b8526" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">如果改为使用 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; ，则将在每次比较时对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 进行评估，从而得出 \（O（n \ log n）\）而不是\（O（n）\）。</target>
        </trans-unit>
        <trans-unit id="b49b973971f72b90b88232bbeeb66a8215462172" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">相反，如果使用了 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; ，则会在每次比较时对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 进行评估，从而得出\（O（n \ log n）\）而不是\（O（n）\）。</target>
        </trans-unit>
        <trans-unit id="98de0ed556230c1fbd1808a2934adcaaa69ac02e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="translated">忽略一个无效的输入,在输出中不做任何替换。</target>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">忽略源中的断言。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="translated">忽略代码布局的cfg权重。</target>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="translated">忽略标记。</target>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="translated">忽略软件包⟨pkg⟩。</target>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="translated">忽略界面文件中的编译指示。仅由&lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="cf4ec85769b7a4182ac16f4a75bfe188c6947b6d" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;code&gt;-O0&lt;/code&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">忽略已安装软件包上的暴露标志，默认情况下将其全部隐藏。如果使用此标志，则需要使用&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;选项显式公开所需的任何软件包（包括 &lt;code&gt;base&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">忽略已安装软件包上的trust标志，默认情况下不信任它们。如果使用此标志和Safe Haskell，则需要使用 &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; 选项显式信任您需要信任的所有软件包（包括 &lt;code&gt;base&lt;/code&gt; ）。此选项不会更改软件包的公开/隐藏状态，因此它并不等同于将 &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; 系统上的所有软件包。（请参阅&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="translated">使用类似的技术也可以忽略指定迭代次数的断点。</target>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="translated">不可更改的数组类型。</target>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="translated">具有重载接口的不可变数组。有关可用于此接口的 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 类型，请参见此模块和&lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt;模块导出的数组类型。其他软件包，例如diffarray，也使用此接口提供数组。</target>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="translated">不可变的非严格(盒式)数组。</target>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="translated">不可变的非严格数组</target>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="translated">实施内部</target>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="translated">撇开实现细节不谈,堆栈中的函数名应该能给你足够的线索来追踪这个bug。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">实施说明</target>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="translated">字符谓词(isLower、isUpper等)和转换(toUpper、toLower)的实现。如果Unix系统中的libunicode可用,则使用它来实现。</target>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="translated">实施应至少在Haskell进程本地执行，对文件的多读取器单写入器锁定。也就是说，&lt;em&gt;在同一文件上可能有许多用于管理输入的句柄，或者在文件上只有一个用于管理输出的句柄&lt;/em&gt;。如果任何打开或半关闭句柄正在管理文件以进行输出，则无法为该文件分配新的句柄。如果任何打开或半关闭句柄正在管理文件输入，则只有在新句柄不管理输出时才可以分配新句柄。两个文件是否相同取决于实现，但是例如，如果两个文件具有相同的绝对路径名并且都没有重命名，则它们通常应该相同。</target>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 实现。</target>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="translated">使用/ Breadth-First Numbering改编的算法来实现，该算法是ICFP'00 /的&lt;em&gt;Chris Okasaki的&amp;ldquo;&lt;/em&gt;算法设计小练习中的教训&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="translated">隐式呼叫堆栈</target>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="translated">隐式参数绑定声明。只能用于完全由隐式绑定构成的let和where子句。</target>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="translated">如果存在显式类型签名，则隐式参数（请参阅&lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;隐式参数&lt;/a&gt;）仅在断点范围内可用。</target>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">隐式参数的实现如&lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]中&lt;/a&gt;所述，并使用选项&lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; &lt;/a&gt;启用。（以下大多数（但仍不完整）文档归功于Jeff Lewis。）</target>
        </trans-unit>
        <trans-unit id="f3e48b33a4890da92cd70584a377ecd462ba1a72" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="translated">隐式参数约束不会引起歧义。例如,请考虑:</target>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="218aafacdf8f46f838b7332039de5c3dbbc7cc14" translate="yes" xml:space="preserve">
          <source>Implied by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91e7074a90e49338f31c7b8d7563d1849b2d089" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">由&lt;a href=&quot;#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; 表示&lt;/a&gt;，否则为off。</target>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;隐含表示。另请参见&lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;隐含表示。另请参见&lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wtyped-holes&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="translated">暗示:</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="translated">通过 &lt;code&gt;hs-boot&lt;/code&gt; 文件导入模块以中断模块循环。</target>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">导入语句和作用域规则与Haskell中完全一样。要提到一个非Prelude类型或类,你必须导入它。</target>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="translated">导入模式。</target>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="translated">进口/出口功能</target>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要说明： &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的行为与论文&amp;ldquo; Haskell中的异步异常&amp;rdquo;（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）中描述的行为不同。在本文中， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 是非阻塞的；但是库实现采用了更为同步的设计，在该设计中， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 直到目标线程接收到异常后才返回。权衡取舍在本文的第9节中讨论。像任何阻塞操作一样， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 因此是可中断的（请参见本文的5.3节）。但是，与其他可中断操作不同， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt;始终&lt;/em&gt;是可中断的，即使它实际上并未阻塞。</target>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要说明： &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的行为与论文&amp;ldquo; Haskell中的异步异常&amp;rdquo;（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）中描述的行为不同。在本文中， &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 是非阻塞的；但是库实现采用了更为同步的设计，在该设计中， &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 直到目标线程接收到异常后才返回。权衡取舍在本文的第9节中讨论。像任何阻塞操作一样， &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 因此是可中断的（请参见本文的5.3节）。但是，与其他可中断操作不同， &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt;始终&lt;/em&gt;是可中断的，即使它实际上并未阻塞。</target>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要说明： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的行为与论文&amp;ldquo; Haskell中的异步异常&amp;rdquo;（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）中描述的行为不同。在本文中， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 是非阻塞的；但是库实现采用了更为同步的设计，在该设计中， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 直到目标线程接收到异常后才返回。权衡取舍在本文的第9节中讨论。像任何阻塞操作一样， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 因此是可中断的（请参见本文的5.3节）。但是，与其他可中断操作不同， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt;始终&lt;/em&gt;是可中断的，即使它实际上并未阻塞。</target>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">重要说明： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 的行为与论文&amp;ldquo; Haskell中的异步异常&amp;rdquo;（&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;）中描述的行为不同。在本文中， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 是非阻塞的；但是库实现采用了更为同步的设计，在该设计中， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 直到目标线程接收到异常后才返回。权衡取舍在本文的第9节中讨论。像任何阻塞操作一样， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 因此是可中断的（请参见本文的5.3节）。但是，与其他可中断操作不同， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt;始终&lt;/em&gt;是可中断的，即使它实际上并未阻塞。</target>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="translated">重要的是，GHC &lt;strong&gt;永远不会&lt;/strong&gt;推断 &lt;code&gt;HasCallStack&lt;/code&gt; 约束，您必须明确地请求它。</target>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="translated">可以使用语法 &lt;code&gt;:module -M&lt;/code&gt; 从上下文中&lt;em&gt;删除&lt;/em&gt;导入。的 &lt;code&gt;import&lt;/code&gt; 语法是累积（如一个Haskell模块中），所以这是从范围中减去的唯一途径。</target>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="translated">在(不太可能的)坏的情况下,这个算法的复杂度会向O(n*m)退化。</target>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="translated">在(不太可能)坏的情况下,这个函数的时间复杂度会向O(n*m)退化。</target>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="translated">在&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式和&lt;a href=&quot;using#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt;模式下（请参阅&lt;a href=&quot;using#modes&quot;&gt;操作模式&lt;/a&gt;），编译器通常确定当前Haskell模块需要哪些软件包，并仅链接这些软件包。但是，在批处理模式下，依赖项信息不可用，并且在链接时必须提供显式的 &lt;code&gt;-package&lt;/code&gt; 选项。您可能需要使用 &lt;code&gt;-package&lt;/code&gt; 来强制链接一个包，这是该包不包含任何Haskell模块时（例如，它可能仅包含C库）。在这种情况下，GHC将永远不会发现对它的依赖关系，因此必须明确提及。</target>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="translated">在 &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt; ，LHS不是应用程序；在 &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt; ，LHS的头部具有模式变量。在 &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt; ，LHS由应用于参数的&lt;em&gt;构造函数&lt;/em&gt;（而不是&lt;em&gt;变量）组成&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt; ，种类变量 &lt;code&gt;a&lt;/code&gt; 由LHS类型模式 &lt;code&gt;x&lt;/code&gt; 的种类签名隐式绑定。</target>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;...rhs...&lt;/code&gt; 中，实际上对于任何 &lt;code&gt;a&lt;/code&gt; 都有一个 &lt;code&gt;Eq (f a)&lt;/code&gt; 的本地实例。但是在 &lt;code&gt;f&lt;/code&gt; 的调用站点，编译器本身会产生证据传递给 &lt;code&gt;f&lt;/code&gt; 。例如，如果我们调用 &lt;code&gt;f Nothing&lt;/code&gt; ，则 &lt;code&gt;f&lt;/code&gt; 是 &lt;code&gt;Maybe&lt;/code&gt; ，并且编译器必须证明（在调用站点）所有 &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; 等式=&amp;gt;等式（也许a）成立。通过诉诸 &lt;code&gt;Eq (Maybe a)&lt;/code&gt; 的现有实例声明，它可以轻松地做到这一点。</target>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="translated">在表单的 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例中</target>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 中，参数 &lt;code&gt;p&lt;/code&gt; 是第一次使用，而 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 仅将 &lt;code&gt;f&lt;/code&gt; 的应用包装到 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; 中，父类或类型的名称</target>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 中，类型构造函数的稀疏性</target>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 中，类型构造函数是否被取消？</target>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 中，与特定数据构造函数关联的数字。 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 是单索引的，并且绝对不能超过其对应的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 的值。例如：</target>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; ，总数 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 秒。例如， &lt;code&gt;(#|#)&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 为2。</target>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; 中，父类或类型的名称</target>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 中，类型构造函数的稀疏性</target>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 中，类型构造函数是否被取消？</target>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; 中，与特定数据构造函数关联的数字。 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 是单索引的，并且绝对不能超过其对应的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 的值。例如：</target>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; ，总数 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; 秒。例如， &lt;code&gt;(#|#)&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; 为2。</target>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="translated">在 &lt;code&gt;MetaCons n f s&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; 是构造函数的名称， &lt;code&gt;f&lt;/code&gt; 是其固定性， &lt;code&gt;s&lt;/code&gt; 是 &lt;code&gt;'True&lt;/code&gt; 如果构造函数包含记录选择器，则为true。</target>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MetaData n m p nt&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; 是数据类型的名称， &lt;code&gt;m&lt;/code&gt; 是在其中定义数据类型的模块， &lt;code&gt;p&lt;/code&gt; 是在其中定义数据类型的包，并且 &lt;code&gt;nt&lt;/code&gt; 是 &lt;code&gt;'True&lt;/code&gt; ,如果数据类型是 &lt;code&gt;newtype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="translated">在 &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt; ，如果该字段使用记录语法，则 &lt;code&gt;mn&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 记录名称。否则， &lt;code&gt;mn&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;su&lt;/code&gt; 和 &lt;code&gt;ss&lt;/code&gt; 是该字段的解包性和严格性注释，而 &lt;code&gt;ds&lt;/code&gt; 是GHC推断该字段的严格性。</target>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MkBar&lt;/code&gt; 中， &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 将量化 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MkBar&lt;/code&gt; 中， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 将量化 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MkFoo&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 将量化 &lt;code&gt;b&lt;/code&gt; ，而不是 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MkFoo&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 将量化 &lt;code&gt;b&lt;/code&gt; ，而不是 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">在 &lt;code&gt;Monad&lt;/code&gt; 实例中，声明警告以下条件是否成立：</target>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">在 &lt;code&gt;Monoid&lt;/code&gt; 实例中，声明满足以下任一条件时发出警告：</target>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="translated">在 &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;f2&lt;/code&gt; 中，类型变量 &lt;code&gt;b&lt;/code&gt; 不会被最外面的 &lt;code&gt;forall&lt;/code&gt; 量化，因此它不在函数主体的范围内。既不是 &lt;code&gt;b&lt;/code&gt; 的范围在体内 &lt;code&gt;f3&lt;/code&gt; ，作为 &lt;code&gt;forall&lt;/code&gt; 的是藏在下面 &lt;code&gt;Foo&lt;/code&gt; 类型同义词。</target>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">在 &lt;code&gt;g&lt;/code&gt; 的定义中，我们将实例化为 &lt;code&gt;(C alpha)&lt;/code&gt; 并尝试从 &lt;code&gt;(C a)&lt;/code&gt; 推导 &lt;code&gt;(C alpha)&lt;/code&gt; 并失败。</target>
        </trans-unit>
        <trans-unit id="3a689d248410c565d4fb51360a8de99b622f55fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="translated">在 &lt;code&gt;kindOf&lt;/code&gt; 中， &lt;code&gt;k&lt;/code&gt; 变量同时用于种类位置和类型位置。目前， &lt;code&gt;kindOf&lt;/code&gt; 也正被接受。</target>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; 查看 &lt;code&gt;map&lt;/code&gt; 的规则，以了解如何编写规则以进行融合，并且即使没有发生融合也能提供高效的程序。 &lt;code&gt;GHC/List.hs&lt;/code&gt; 中有更多规则。</target>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="translated">在&lt;em&gt;批处理模式下&lt;/em&gt;，GHC将编译命令行上给定的一个或多个源文件。</target>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="translated">在GHC 6.12.3和更早版本中，默认设置是处理所有RTS选项。但是，由于RTS选项可用于在运行程序的安全上下文下将日志记录数据写入任意文件，因此存在潜在的安全问题。因此，GHC 7.0.1和更高版本默认为 &lt;code&gt;-rtsopts=some&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="translated">在GHC 8.4和更高版本中， &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 已对Maybe的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 实例进行了更正，以提升 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例而不是 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 实例。因此，此类型不再有用。将在GHC 8.8中将其标记为已弃用，并在GHC 8.10中将其删除。</target>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="translated">在GHC中， &lt;code&gt;Int&lt;/code&gt; 类型遵循主机体系结构上地址的大小；换句话说，它在32位计算机上保留32位，在64位计算机上保留64位。</target>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="translated">在GHC版本6.12中，Linux（在x86和x86-64体系结构上）支持构建共享库。GHC 7.0版增加了对Windows（请参阅&lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;构建和使用Win32 DLL&lt;/a&gt;），FreeBSD和OpenBSD（x86和x86-64），Solaris（x86）和Mac OS X（x86和PowerPC）的支持。</target>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="translated">在GHC中， &lt;code&gt;alloca&lt;/code&gt; 是使用 &lt;code&gt;MutableByteArray#&lt;/code&gt; 实现的，因此分配和释放都非常快：比C的 &lt;code&gt;malloc/free&lt;/code&gt; 快得多，但不及C中的堆栈分配快。请尽可能使用 &lt;code&gt;alloca&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="translated">在GHC中， &lt;code&gt;mallocForeignPtr&lt;/code&gt; 也使用 &lt;code&gt;MutableByteArray#&lt;/code&gt; 实现。虽然内存指向由 &lt;code&gt;ForeignPtr&lt;/code&gt; ，有没有涉及实际的终结（除非你自己增加一个 &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; ），并重新分配使用GC完成的，因此 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 通常是很便宜的。</target>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="translated">在GHC中,固定性声明可以伴随着本地绑定。</target>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="translated">在GHC中,stdout句柄默认是行缓冲的。然而,在GHCi中,我们关闭了stdout的缓冲,因为这通常是你在解释器中想要的:输出会在生成时出现。</target>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="translated">在GHC中,这是1(一个标签只是一个字符)。</target>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="translated">在GHC中， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程是轻量级线程，并且完全由GHC运行时管理。通常，Haskell线程的效率要比操作系统线程高一个数量级或两个数量级（就时间和空间而言）。</target>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="translated">在Haskell 2010中，某些类型的表达式可以不带括号而用作运算符的参数，而不能用作函数的参数。它们包括 &lt;code&gt;do&lt;/code&gt; ，lambda， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;case&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 表达式。一些GHC扩展也定义了这种类型的语言构造： &lt;code&gt;mdo&lt;/code&gt; （&lt;a href=&quot;#recursive-do-notation&quot;&gt;递归&lt;/a&gt;do- 表示法）， &lt;code&gt;\case&lt;/code&gt; （&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;）和 &lt;code&gt;proc&lt;/code&gt; （&lt;a href=&quot;#arrow-notation&quot;&gt;箭头表示法&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="translated">在 Haskell 2010 中,这是一个不透明的类型。</target>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="translated">在Haskell 98模式下以及默认情况下（但在Haskell 2010模式下则不是），GHC在 &lt;code&gt;do&lt;/code&gt; 表达式中使用时对布局规则的要求略低一些。具体而言，放宽了&amp;ldquo;嵌套上下文必须比包围上下文缩进更远的缩进&amp;rdquo;的限制，以允许嵌套上下文与包围上下文处于同一级别（如果包围上下文是 &lt;code&gt;do&lt;/code&gt; 表达式）。</target>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="translated">在Haskell 98中，类声明（引入超类）的上下文必须很简单。也就是说，每个谓词必须包含一个应用于类型变量的类。扩展&lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#flexible-contexts&quot;&gt;类型签名的上下文&lt;/a&gt;）取消了此限制，因此在类声明中对上下文的唯一限制是类层次结构必须是非循环的。因此，这些类声明是可以的：</target>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="translated">在Haskell 98中，实例声明的头部必须采用 &lt;code&gt;C (T a1 ... an)&lt;/code&gt; ，其中 &lt;code&gt;C&lt;/code&gt; 是类， &lt;code&gt;T&lt;/code&gt; 是数据类型构造函数，而 &lt;code&gt;a1 ... an&lt;/code&gt; 是不同的类型变量。在多参数类型类的情况下，此规则适用于实例头的每个参数（可以说，只要其中一个具有这种形式，而其他形式是类型变量，就可以了，但是这就是目前的规则）。</target>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="translated">在Haskell 98中，实例声明的上下文中的类约束必须采用 &lt;code&gt;C a&lt;/code&gt; 的形式，其中 &lt;code&gt;a&lt;/code&gt; 是出现在头部的类型变量。</target>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="translated">在Haskell 98中， &lt;code&gt;App&lt;/code&gt; 的推断类型是 &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 。但这过于具体，因为适用于 &lt;code&gt;App&lt;/code&gt; 的另一种Haskell 98类型是 &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt; ，其中分配给 &lt;code&gt;a&lt;/code&gt; 的 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 是Type-&amp;gt; Type。实际上，如果没有种类签名（&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;），则必须使用伪构造函数来获取Haskell编译器来推断第二种种类。利用种类多态性（&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;），GHC推断种类 &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt; Type&lt;/code&gt; 为 &lt;code&gt;App&lt;/code&gt; ，这是它的最一般的种类。</target>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="translated">在Haskell 98中，唯一可派生的类是 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Enum&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; ， &lt;code&gt;Bounded&lt;/code&gt; ， &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; 。&lt;a href=&quot;#deriving-extra&quot;&gt;各种语言扩展&lt;/a&gt;扩展了此列表。</target>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="translated">在Haskell 98中,我们可以通过以下方式定义一个解析单子</target>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="translated">在Haskell中， &lt;code&gt;let&lt;/code&gt; 表达式后跟 &lt;code&gt;in&lt;/code&gt; 。但是，在GHCi中，由于也可以在 &lt;code&gt;IO&lt;/code&gt; monad中解释表达式，因此如上例所示，可以用空行来表示没有附带 &lt;code&gt;in&lt;/code&gt; 语句的 &lt;code&gt;let&lt;/code&gt; 绑定。</target>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">在Haskell中，换行符始终由字符 &lt;code&gt;'\n'&lt;/code&gt; 。但是，在文件和外部字符流中，换行符可能由另一个字符序列（例如 &lt;code&gt;'\r\n'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="translated">在Haskell中，程序员编写的类型签名通过其自由类型变量进行隐式量化（Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;4.1.2节&lt;/a&gt;）。词法范围的类型变量会按以下方式影响此隐式量化规则：作用域内的任何类型变量都&lt;em&gt;不会被&lt;/em&gt;普遍地量化。例如，如果类型变量 &lt;code&gt;a&lt;/code&gt; 在范围内，则</target>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="translated">在Haskell中，浮点运算具有纯类型，并且未指定评估顺序。因此严格来说，由于 &lt;code&gt;fenv.h&lt;/code&gt; 函数使您可以更改浮点运算的结果或观察浮点运算的效果，因此使用 &lt;code&gt;fenv.h&lt;/code&gt; 会使程序中任何位置的浮点运算的行为均未定义。</target>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="translated">在Haskell中，您不能在实例声明中编写类型签名，但有时这样做很方便，而语言扩展&lt;a href=&quot;#extension-InstanceSigs&quot;&gt; &lt;code&gt;InstanceSigs&lt;/code&gt; &lt;/a&gt;允许您这样做。例如：</target>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="translated">在&lt;em&gt;封闭型族中，&lt;/em&gt;所有方程都是有序的，并且在一个地方。方程也是成对检查的，但这一次必须将一个方程与所有前面的方程配对。当然，单方程封闭型族是单射的（除非上面的（1），（2）或（3）成立）。</target>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="translated">在&lt;em&gt;源程序中，&lt;/em&gt;这将声明TA不具有构造函数（GHC扩展：请参阅&lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;不带构造函数的数据类型&lt;/a&gt;），但是在Hi-boot文件中，这意味着&amp;ldquo;我不知道或不在乎构造函数是什么&amp;rdquo;。这是数据类型声明的最常见形式，因为它很容易正确。您&lt;em&gt;也&lt;/em&gt;可以写出构造函数，但如果这样做，则必须按照其实际定义精确地写出来。</target>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="translated">在GADT样式的数据类型声明中，没有明显的方法来指定数据构造函数应为infix，如果派生针对该类型的 &lt;code&gt;Show&lt;/code&gt; ，这将有所不同。 （声明为infix的数据构造函数在派生的 &lt;code&gt;show&lt;/code&gt; 中显示为infix 。）因此，GHC进行了以下设计：在GADT样式的数据类型声明中声明的数据构造函数由 &lt;code&gt;Show&lt;/code&gt; if显示为infix （a）它是运算符， ）它有两个参数，（c）它有一个程序员提供的固定性声明。例如</target>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="translated">在类声明中，必须从每种方法类型的自由变量中获取所有类类型变量（在&lt;a href=&quot;#flexible-contexts&quot;&gt;类型签名的上下文中&lt;/a&gt;提到的意义上）。例如：</target>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="translated">在并发程序中，根据底层处理器体系结构的内存模型， &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 操作可能对另一个线程而言是乱序的。例如，在x86上，负载可以移至存储区之前，因此在以下示例中：</target>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="translated">在少数情况下,即使是平等约束也不能推迟。特别是:</target>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="translated">在形式上,懒得检查不变性。</target>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="translated">在将来的GHC版本中， &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;kindOf&lt;/code&gt; 都将根据&amp;ldquo;全部或全部&amp;rdquo;规则被拒绝。该警告属于&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组，允许在实际的重大更改发生之前检测到此警告。</target>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在多线程程序中，当前工作目录是进程所有线程之间共享的全局状态。因此，从多个线程执行文件系统操作时，强烈建议使用绝对路径而不是相对路径（请参阅： &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="translated">在模式背景下</target>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="translated">在模式语境中,有现场双关语</target>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="translated">在具有记录语法的模式上下文中</target>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="translated">在模式类型签名中（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法作用域类型变量&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="translated">在一次记录更新中</target>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="translated">在诸如 &lt;code&gt;e { x = 1 }&lt;/code&gt; 的记录更新中，如果作用域中有多个 &lt;code&gt;x&lt;/code&gt; 字段，则上下文的类型必须确定要使用的记录数据类型，或者必须提供类型注释。请考虑以下定义：</target>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="translated">以类似的方式， &lt;code&gt;g&lt;/code&gt; 的早期定义现在将被标记为类型错误。</target>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="translated">在单一模式中,视图模式表达式左边的模式所绑定的变量都在范围内。例如:</target>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="translated">在一个独立的GHC程序中,只有主线程需要终止才能使进程终止,因此,所有其他分叉线程只会与主线程同时终止(这种行为的术语是 &quot;守护线程&quot;)。因此,所有其他的分叉线程将仅仅与主线程同时终止(这种行为的术语是 &quot;守护线程&quot;)。</target>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">在严格的monad中，您知道何时执行每个动作，但是monad的返回值或monad的其他组件（例如状态）不一定严格。但是，您可以使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 创建要在要评估的组件中严格执行的操作。</target>
        </trans-unit>
        <trans-unit id="7880166b35b3a24c62f866c80bb1e9fca6aab314" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43015c398315c351d899f4cc070e29bfc23b64c4" translate="yes" xml:space="preserve">
          <source>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="translated">另外， &lt;code&gt;#{stuff}&lt;/code&gt; 与 &lt;code&gt;#stuff&lt;/code&gt; 等效，只是它是自定界的，因此不需要放在行尾或某些方括号中。</target>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="translated">除Core插件外，GHC还对typechecker插件提供了实验性支持，该插件允许修改约束求解器的行为。例如，它们使编译器与SMT求解器接口成为可能，以便支持比GHC内置的理论更丰富的类型级算术表达式理论（请参阅&lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;使用类型级自然函数进行计算&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除了在结构上等效外，这两个实例还具有行为相同的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 实例。此类型将在GHC 8.8中标记为已弃用，并在GHC 8.10中删除。建议用户使用&lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt;的变体并将其包装在 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="translated">除了核心和类型检查器插件外,你还可以安装能够访问源代码的不同表示的插件。这些插件的主要目的是为了更容易实现开发工具。</target>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="translated">除了创建DLL， &lt;code&gt;-shared&lt;/code&gt; 选项还创建一个导入库。导入库名称是从DLL的名称派生的，如下所示：</target>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="translated">除了 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作引发的异常外，异常可能由纯代码（不精确的异常）或外部事件（异步异常）引发，但只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中捕获。有关更多详细信息，请参见：</target>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="translated">除了对程序的时间和分配行为进行分析外,你还可以生成一个内存使用情况的图表。这对于检测空间泄漏的原因是很有用的,当你的程序在运行时占用了更多的内存时。由于垃圾收集器的大量活动,空间泄漏会导致执行速度变慢,甚至可能导致程序完全耗尽内存。</target>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="translated">除了通过 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作刚刚写入缓冲区中的数据之外，它还为您提供了一个预先存在的数据块 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。它还为您提供以下 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作。使用缓冲区中的空闲空间与上一个运行操作所剩余的缓冲区一样多来运行此后续操作是安全的。</target>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="translated">除了DWARF规范指定的通常的DIE外,GHC还使用标签和属性空间的供应商可扩展性区域产生了其他各种DIE。</target>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="translated">另外，您可以使用&lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; RTS选项来获得以下附加信息：</target>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">另外，在 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; 模式下，如果进程以ExitFailure（-SIGINT）终止，则 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 将引发 &lt;code&gt;UserInterrupt&lt;/code&gt; 异常。通常，您将不希望捕获此异常，而是让其传播，从而有规律地进行正常关闭。需要注意的一个细节是， &lt;code&gt;UserInterrupt&lt;/code&gt; 异常是在调用 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 的线程中&lt;em&gt;同步&lt;/em&gt;引发的，而通常 &lt;code&gt;SIGINT&lt;/code&gt; 会导致将该异常&lt;em&gt;异步&lt;/em&gt;引发到主线程。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="translated">此外,所要的数据类型可以作为选择器的参数的类型签名。</target>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="translated">此外,可以将配置文件限制在满足特定标准的堆数据上--例如,您可能希望按类型显示配置文件,但只显示某个模块产生的数据,或者按保留器显示某类数据的配置文件。限制条件指定如下。</target>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="translated">此外,还有一些字段具有特殊的语法(如包名、版本、依赖关系)。</target>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="translated">此外，使用&lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt;可以在导入或导出列表中的数据构造函数的名称前面加上关键字 &lt;code&gt;pattern&lt;/code&gt; ，以允许在没有其父类型构造函数的情况下导入或导出数据构造函数（请参见&lt;a href=&quot;#patsyn-impexp&quot;&gt;模式同义词的导入和导出&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="translated">在所有情况下（除了箭头符号之外），静态语义都应该是已删除修饰符的形式，即使有些意外。例如，文字 &lt;code&gt;368&lt;/code&gt; 的静态语义恰好是 &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; 的静态语义；它的罚款 &lt;code&gt;fromInteger&lt;/code&gt; 有任何的类型：</target>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="translated">在所有其他情况下,不允许使用类型通配符,命名的通配符被视为普通类型变量。例如</target>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="translated">在类的 &lt;code&gt;instance&lt;/code&gt; 声明中，如果未为关联的类型提供显式 &lt;code&gt;type instance&lt;/code&gt; 声明，则将使用默认声明，就像使用默认类方法一样。</target>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="translated">在进口或出口清单中,如</target>
        </trans-unit>
        <trans-unit id="cc915ffb21811be1dad23381dc586229e4878e9d" translate="yes" xml:space="preserve">
          <source>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class&amp;rsquo;s type variable binders. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="translated">在base中,我们不能使用wordToNatural#,因为内置的规则会将其中一些转化为Natural字面。使用这个函数来代替。</target>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">在批处理编译模式下，也可以使用目标文件名覆盖目标文件的名称。 &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-o ⟨file⟩&lt;/code&gt; &lt;/a&gt;选项的名称，并且可以使用&lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-ohi ⟨file⟩&lt;/code&gt; &lt;/a&gt;选项直接指定接口文件的名称。</target>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="translated">以二进制格式保存到文件中，以便以后通过各种工具进行分析。这样的工具之一就是&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;，它可以解释事件日志以生成程序的可视并行执行配置文件。</target>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="translated">以二进制格式对自定义的事件日志写入器。这样可以在程序运行时对事件进行实时分析。</target>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="translated">在绑定位置,我们有类似的解析规则。请看下面的例子</target>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">在这两种情况下，在开始评估 &lt;code&gt;body&lt;/code&gt; 之前都要对 &lt;code&gt;e&lt;/code&gt; 进行评估。</target>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="translated">在这两种情况下， &lt;code&gt;r1&lt;/code&gt; 和 &lt;code&gt;r2&lt;/code&gt; 在整个 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;rec&lt;/code&gt; 块以及其后的语句中均可用。区别在于 &lt;code&gt;let&lt;/code&gt; 是非单声道的，而 &lt;code&gt;rec&lt;/code&gt; 是单声道的。（在Haskell中， &lt;code&gt;let&lt;/code&gt; 实际上就是 &lt;code&gt;letrec&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="translated">如果您尝试派生某个新类型的类，则可以使用&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;也启用了，则&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;优先。</target>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="translated">如果有几个 &lt;code&gt;needle&lt;/code&gt; 重叠的情况，则仅第一个会被替换：</target>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="translated">配合 &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; 使用&lt;/a&gt;，GHC支持更高级别的种类。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="ecd1bab6934e5b406a45cc9d86aaae1eda35aa2c" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">与&lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt;结合使用扩展，空数据声明也可以派生标准类型类的&lt;a href=&quot;#empty-data-deriving&quot;&gt;实例&lt;/a&gt;（请参见派生实例获取空数据类型）。</target>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">相反，对于 &lt;code&gt;g&lt;/code&gt; ，没有可靠的方法可以做到这一点。我们将不知道在 &lt;code&gt;g&lt;/code&gt; 的类型的约束中将首先列出 &lt;code&gt;Eq a&lt;/code&gt; 还是 &lt;code&gt;Eq b&lt;/code&gt; 。为了使GHC发行版之间的可见类型应用程序健壮，我们因此禁止将其与 &lt;code&gt;g&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="22f781a5702b84d96719b279819ee7bee564bebe" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="translated">在转储中,压制一切可压制的东西(除了单体)。</target>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="translated">在每种情况下，在 &lt;code&gt;deriving&lt;/code&gt; 子句中提到适当的类之前，必须先在其范围内。</target>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="translated">在早期版本的GHC中，可以省略 &lt;code&gt;forall&lt;/code&gt; 在构造函数的类型，如果有一个明确的背景下。例如：</target>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="translated">无论哪种情况，C都是有关程序包信任的唯一权限。由客户决定哪个&lt;a href=&quot;#safe-package-trust&quot;&gt;他们信任软件包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="translated">在错误消息中，表达式被打印到某个&amp;ldquo;深度&amp;rdquo;，超出该深度的子表达式将被省略号代替。该标志设置深度。默认值为5。</target>
        </trans-unit>
        <trans-unit id="4aea9c2bc91c202848f5c9b6db19bf9964c3bd1d" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="translated">实际上，出于技术原因，如果没有&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt;无效（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;问题＃5252&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="translated">事实上,如果命令行上有任何Haskell源文件而没有指定其他模式,GHC就会自动进入make模式,所以在这种情况下,我们可以直接输入</target>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">实际上，GHCi提供了一种在遇到断点时运行命令的方法，因此我们可以使其自动执行&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="translated">在 &lt;code&gt;showHelp&lt;/code&gt; 函数中，GHC没有看到重叠的实例，因此使用 &lt;code&gt;MyShow [a]&lt;/code&gt; 实例时不会产生任何抱怨。在调用 &lt;code&gt;myshow&lt;/code&gt; 在 &lt;code&gt;main&lt;/code&gt; ，GHC解析 &lt;code&gt;MyShow [T]&lt;/code&gt; 使用在模块重叠实例声明约束 &lt;code&gt;Main&lt;/code&gt; 。结果，程序打印</target>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">通常，如果 &lt;code&gt;p&lt;/code&gt; 不绑定任何变量，则惰性模式绑定 &lt;code&gt;p = e&lt;/code&gt; 是无操作的。允许使用单独的通配符模式的动机是，它们与 &lt;code&gt;_v = rhs3&lt;/code&gt; 并没有太大差异，后者不会引起警告。并且它们对于添加类型约束非常有用，例如 &lt;code&gt;_ = x::Int&lt;/code&gt; 。碰撞模式（请参见&lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang pattern和Strict Haskell&lt;/a&gt;）&lt;em&gt;不是&lt;/em&gt;禁忌，因为它会强制求值，并且可以作为 &lt;code&gt;seq&lt;/code&gt; 的替代方法&lt;em&gt;&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="translated">一般来说,弱指针是对一个对象的引用,它不会被垃圾收集器跟踪,也就是说,一个对象的弱指针的存在对该对象的寿命没有影响。弱指针可以通过去引用来了解它所引用的对象是否还活着,如果还活着,则返回对象本身。</target>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="translated">通常，存在三种模式同义词。单向，双向和显式双向。到目前为止给出的示例是双向模式同义词的示例。双向同义词的行为与普通数据构造函数相同。我们可以在模式上下文中使用它来解构值，在表达式上下文中使用它来构建值。例如，我们可以使用模式同义词 &lt;code&gt;Arrow&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; 构造值 &lt;code&gt;intEndo&lt;/code&gt; 先前定义。</target>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="translated">通常， &lt;code&gt;ghc -M Foo&lt;/code&gt; 执行以下操作。对于集合 &lt;code&gt;Foo&lt;/code&gt; 中的每个模块 &lt;code&gt;M&lt;/code&gt; 及其所有导入（以传递方式），它将添加到Makefile中：</target>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="translated">一般来说,GHC只有在有一些理由(无论多么轻微)认为这样做是有用的时候才会内联函数。</target>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="translated">一般来说,GHC只会在一个单态类型(没有foralls的类型)上实例化一个多态函数。例如:</target>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">通常，在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令之后，将自动导入添加到最近加载的&amp;ldquo;目标&amp;rdquo;模块的作用域中，如果可能的话，将以 &lt;code&gt;*&lt;/code&gt; 形式添加。例如，如果你说 &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; 和 &lt;code&gt;bar.hs&lt;/code&gt; 包含模块 &lt;code&gt;Bar&lt;/code&gt; ，那么范围将被设置为 &lt;code&gt;*Bar&lt;/code&gt; ，如果 &lt;code&gt;Bar&lt;/code&gt; 解释，或者 &lt;code&gt;Bar&lt;/code&gt; 编译它将被设置为 &lt;code&gt;Prelude Bar&lt;/code&gt; （GHCI 如果不存在并且没有任何 &lt;code&gt;*&lt;/code&gt; -form模块，则会自动添加 &lt;code&gt;Prelude&lt;/code&gt; 。这些自动添加的导入可以通过&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;看到：</target>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="translated">通常，如&lt;a href=&quot;#instance-resolution&quot;&gt;实例解析中所述&lt;/a&gt;，&lt;em&gt;GHC要求明确使用哪个实例声明来解析类型-类约束&lt;/em&gt;。 GHC还提供了一种方法，可以通过允许多个实例进行匹配来放宽实例分辨率，&lt;em&gt;前提是存在最具体的&lt;/em&gt;实例&lt;em&gt;&lt;/em&gt;。此外，可以通过允许一个以上的实例匹配，而不管是否存在最具体的实例来进一步放宽。本节提供了详细信息。</target>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="translated">通常，如果GHC在牛津括号内看到一个表达式（例如 &lt;code&gt;[| foo bar |]&lt;/code&gt; ，那么GHC会在括号内查找每个名称。如果名称是全局名称（例如 &lt;code&gt;foo&lt;/code&gt; 来自导入或顶级）声明），则直接在报价单中使用完全限定名称。如果名称是本地名称（例如，假设 &lt;code&gt;bar&lt;/code&gt; 在函数定义 &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt; 本地绑定），则GHC 在其上使用 &lt;code&gt;lift&lt;/code&gt; （因此，GHC假装 &lt;code&gt;[| foo bar |]&lt;/code&gt; 实际上包含 &lt;code&gt;[| foo $(lift bar) |]&lt;/code&gt; ）。处理报价时，实际上会评估未在接头位置范围内的本地名称。</target>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="translated">通常，不建议在单独的对象上使用终结器，而终结器之间应具有排序约束。为了稳健地表达顺序，需要在终结器之间使用 &lt;code&gt;MVar&lt;/code&gt; 进行显式同步，但是即使那样，运行时有时也会在单个线程中顺序运行多个终结器（出于性能原因），因此终结器之间的同步可能会导致人为的死锁。另一种选择是使用显式引用计数。</target>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="translated">通常， &lt;code&gt;pluginRecompile&lt;/code&gt; 字段具有以下类型：</target>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="translated">通常， &lt;code&gt;do&lt;/code&gt; 语句何时产生 &lt;code&gt;Monad&lt;/code&gt; 约束的规则如下。如果do-expression具有以下形式：</target>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="translated">通常，这些选项作用于 &lt;code&gt;.tix&lt;/code&gt; 检测到的二进制文件生成后会文件。</target>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">通常，对于任意秩类型的类型推断是不确定的。GHC使用Odersky和Laufer提出的算法（&amp;ldquo;将类型注释工作&amp;rdquo;，POPL'96），通过需要程序员的一些帮助来确定算法。我们还没有关于&amp;ldquo;一些帮助&amp;rdquo;的正式规范，但是规则是这样的：</target>
        </trans-unit>
        <trans-unit id="31dba12d8f480c4aabbd58985394adff8da0a17b" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;rsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="translated">通常，您只能在 &lt;code&gt;case&lt;/code&gt; 表达式或函数定义的模式中对已存在量化的构造函数进行模式匹配。这种限制的原因实际上是一种实现。没有存在性会使图片复杂化，类型检查绑定组已经是一场噩梦。同样，在模块顶层的存在模式绑定是没有意义的，因为尚不清楚如何防止存在量化的类型&amp;ldquo;转义&amp;rdquo;。因此，目前有一个简单的限制。我们将看到它是多么烦人。</target>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="translated">在高性能的Haskell代码中(例如数字代码),从内部循环中消除thunks是一个巨大的胜利。GHC支持三个扩展,允许程序员指定使用严格(按值调用)评估,而不是懒惰(按需求调用)评估。</target>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="translated">在默认模式下，GHC不接受数据类型上下文，因为已决定将其从语言标准的下一版本中删除。可以通过 &lt;code&gt;DatatypeContexts&lt;/code&gt; 扩展来控制此行为。请参阅&lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;数据类型上下文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="translated">在其默认模式下,GHC使一些程序的定义比它们应该的略多。例如,考虑一下</target>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="translated">与类方法先列出其类变量的方式一致,关联类型也将类变量列在其他变量之前。这意味着从类中推断出的变量在类中指定的变量之前,而类中指定的变量在其他隐式约束的变量之前。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">在许多情况下， &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 操作可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; 代替，这可以促进函数应用。</target>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">在许多情况下， &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; 操作可以使用 &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; 代替，这可以促进函数应用。</target>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="translated">在更复杂的例子中,你可能希望定义一个完整的例外层次结构。</target>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">在大多数情况下， &lt;code&gt;toLazyByteString&lt;/code&gt; 使用的参数可提供良好的性能。 &lt;code&gt;toLazyByteString&lt;/code&gt; 的一个性能不佳的情况是正在执行short（&amp;lt;128字节） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。在这种情况下，第一个4kb缓冲区的分配开销和修整成本将主导执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的成本。您可以使用避免出现此问题</target>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">在大多数情况下， &lt;code&gt;toLazyByteString&lt;/code&gt; 使用的参数可提供良好的性能。 &lt;code&gt;toLazyByteString&lt;/code&gt; 的一个性能不佳的情况是正在执行short（&amp;lt;128字节） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。在这种情况下，第一个4kb缓冲区的分配开销和修整成本将主导执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的成本。您可以使用避免出现此问题</target>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="translated">在大多数情况下，必须提供一个显式上下文（在示例中，上下文为 &lt;code&gt;(Eq a)&lt;/code&gt; ），就像在普通实例声明中一样。（相反，在附加到数据类型声明的 &lt;code&gt;deriving&lt;/code&gt; 子句中，将推断上下文。）</target>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="translated">在大多数情况下，每个 &lt;code&gt;deriving&lt;/code&gt; 语句都以明确的方式生成类型类实例。但是，在&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;情况下，同时启用&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;和DeriveAnyClass扩展会使派生变得模棱两可。考虑下面的例子</target>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="translated">在诸如 &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;where&lt;/code&gt; 或顶层这样的相互递归绑定中，一个声明中的视图模式可能不会提及其他声明所绑定的变量。也就是说，每个声明必须是独立的。例如，不允许以下程序：</target>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="translated">为了完全灵活地使用种类，必须使用种类系统来区分装箱的，提升的类型（正常的日常类型，如 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;[Bool]&lt;/code&gt; ）和未装箱的原始类型（未装箱的&lt;a href=&quot;#primitives&quot;&gt;类型和原始操作）&lt;/a&gt;）就像 &lt;code&gt;Int#&lt;/code&gt; 一样。因此，我们具有所谓的高度多态性。</target>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="translated">为了避免与内置约束解决方案冲突，禁止使用以下用户定义的 &lt;code&gt;HasField&lt;/code&gt; 实例（除了通常的规则，例如，禁止在实例头中出现类型族的规则）：</target>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="translated">为了能够做到这一点,我们需要知道这些类型的实际定义。</target>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="translated">为了保证在存在类型族时可以进行类型推断，我们需要对类型实例声明的形成施加一些其他限制（参见&amp;ldquo; &lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;使用开放类型函数进行类型检查&lt;/a&gt; &amp;rdquo;的定义5（松弛条件）） 。实例声明具有一般形式</target>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="translated">为了使图更具可读性， &lt;code&gt;hp2ps&lt;/code&gt; 对每个标识符的阴影带进行排序。默认排序顺序是将面积最大的波段堆叠在较小的波段之上。该 &lt;code&gt;-d&lt;/code&gt; 选项使粗糙带（那些代表值的系列最大的标准差）对那些平滑的顶部堆叠。</target>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="translated">为了使用多个CPU，您的程序必须与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项&lt;a href=&quot;phases#options-linker&quot;&gt;链接&lt;/a&gt;（请参阅影响链接的选项）。此外，以下编译器选项会影响并行性：</target>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="translated">为了停止在每个命令上绑定的值 &lt;code&gt;it&lt;/code&gt; 可以设置标志&lt;a href=&quot;#ghc-flag--fno-it&quot;&gt; &lt;code&gt;-fno-it&lt;/code&gt; &lt;/a&gt;。由于GHCi如何处理阴影声明， &lt;code&gt;it&lt;/code&gt; 变量可能是空间泄漏的根源（请参阅&lt;a href=&quot;#ghci-decls&quot;&gt;Type，class和其他声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="translated">为了告诉GHC C类型，Haskell类型与CAPI一起使用时对应，可以在类型定义上使用 &lt;code&gt;CTYPE&lt;/code&gt; 编译指示。定义类型的标头也可以选择指定。语法如下：</target>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">为了在多线程设置中使用FFI，必须使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项（请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="translated">依次， &lt;code&gt;ghc&lt;/code&gt; 将在以下位置查找软件包环境：</target>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="translated">在普通的Haskell中， &lt;code&gt;f&lt;/code&gt; 在其自变量中是惰性的，因此在 &lt;code&gt;x&lt;/code&gt; 中是惰性的；和 &lt;code&gt;g&lt;/code&gt; 是在它的参数严格，因此也严格在 &lt;code&gt;x&lt;/code&gt; 。使用 &lt;code&gt;Strict&lt;/code&gt; 时，两者都会变得严格，因为 &lt;code&gt;f&lt;/code&gt; 的参数会隐式爆炸。</target>
        </trans-unit>
        <trans-unit id="f0c005424bafd0442e357105c93d1f9cfe1f688c" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s argument gets an implicit bang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405421d283da798715928c97732511b19ea5e87" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="translated">但在其他方面,独立派生与普通派生服从相同的规则。</target>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;check b = unless b retry&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="translated">在我们的情况下，模块 &lt;code&gt;TCB_Runner&lt;/code&gt; 可以正常编译而无需导入模块 &lt;code&gt;Dangerous&lt;/code&gt; 。因此，在决定使用哪个实例调用 &lt;code&gt;op&lt;/code&gt; 时，如果我们确定模块Dangerous中的实例 &lt;code&gt;TC [Int]&lt;/code&gt; 是最特定的，则这是不安全的。这样可以防止我们不信任的第三方（在Safe Haskell中使用 &lt;code&gt;-XSafe&lt;/code&gt; 编译）编写的代码更改我们现有代码的行为。</target>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="translated">在并行GC中,所有线程复制的平衡数据量。</target>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="translated">在并行GC中,任何一个线程复制的最大数据量。已废弃。</target>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="translated">特别是GHC产生了以下DWARF部分:</target>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="translated">特别是Haskell共享库&lt;em&gt;必须&lt;/em&gt;打包成包。您不能自由分配哪个模块进入哪个共享库。 Haskell共享库必须与程序包边界匹配。这样做的原因是，GHC处理到符号的引用&lt;em&gt;内&lt;/em&gt;从以符号的引用同一共享库（或主可执行二进制）不同&lt;em&gt;之间&lt;/em&gt;不同的共享库。 GHC需要为每个导入的模块知道该模块是本地驻留在同一共享库中还是在单独的共享库中。它使用包的方法。使用&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; 时&lt;/a&gt;，假定来自单独程序包的模块来自单独的共享库，而来自相同程序包（或默认的&amp;ldquo;主&amp;rdquo;程序包）的模块被假定位于相同的共享库（或主可执行二进制文件）内。</target>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="translated">特别是，其 &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="translated">特别是，在内联之后，这将直接将 &lt;code&gt;f&lt;/code&gt; 暴露给循环体，从而在递归情况下进行了专门化。</target>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="translated">特别是，构造函数&lt;em&gt;不是&lt;/em&gt;保留者。</target>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="translated">特别是，如果实例声明与该实例声明的&lt;em&gt;开头&lt;/em&gt;提到的任何类型或类的定义位于同一模块（&amp;ldquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;rdquo; 之后的部分；请参见&lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;实例上下文的宽松规则&lt;/a&gt;），则GHC必须仍要访问该接口文件。例：</target>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="translated">特别是，在 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;newtype&lt;/code&gt; 声明的构造函数的参数可以是多态类型的任何等级的; 请参阅示例中的&lt;a href=&quot;#univ&quot;&gt;示例&lt;/a&gt;。注意，声明的类型始终是单态的。这很重要，因为默认情况下，GHC不会将类型变量实例&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;化为多&lt;/a&gt;态类型（Impredicative polymorphism）。</target>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="translated">特别地，该模块中的&amp;ldquo;大&amp;rdquo;的功能（ &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; ）是一个简单的组合物 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 后跟一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 与异常安全。这些仅具有原子性保证，如果所有其他线程执行 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 一个前 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 为好; 否则，它们可能会阻塞。</target>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="translated">具体来说,本模块中的函数遵循以下规律。</target>
        </trans-unit>
        <trans-unit id="9d41d9ff0d0d0895ae2e1959850587fbcb656b74" translate="yes" xml:space="preserve">
          <source>In particular, the occurrence &lt;code&gt;VarE nm1&lt;/code&gt; refers to the binding &lt;code&gt;VarP nm1&lt;/code&gt;, and is not captured by the binding &lt;code&gt;VarP nm2&lt;/code&gt;.</source>
          <target state="translated">特别地，出现 &lt;code&gt;VarE nm1&lt;/code&gt; 是指结合的 &lt;code&gt;VarP nm1&lt;/code&gt; ，而不是被结合的 &lt;code&gt;VarP nm2&lt;/code&gt; 捕获。</target>
        </trans-unit>
        <trans-unit id="7e3faed30034bb62c86f00fd56d131c7714b3f69" translate="yes" xml:space="preserve">
          <source>In practice, the FFI should not be used for a task as simple as reading bytes from a &lt;code&gt;MutableByteArray#&lt;/code&gt;. Users should prefer &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d02df75e8eea52729bdf6cd2eb9e25ca0f13738" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b2886cb4e0d3786c17223969b938c2fef5e88" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue #13730&lt;/a&gt;).</source>
          <target state="translated">在以前的版本中，GHC将利用本章提供的自由，通过在字节码解释器中执行 &lt;code&gt;safe&lt;/code&gt; 外部调用来代替 &lt;code&gt;unsafe&lt;/code&gt; 调用。这意味着某些在编译时有效的软件包在GHCi下会失败（例如&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue＃13730&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3ff8d012302e9131b060a6becba0fe4885a49e66" translate="yes" xml:space="preserve">
          <source>In principle you can use &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; without &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; so that the code is suitable to include into a shared library and we do not do that at the moment.</source>
          <target state="translated">原则上，你可以使用&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;没有&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;链接步骤。这意味着将运行时系统和所有基本库静态链接到新的共享库中。这将构成一个非常大但独立的共享库。但是，在大多数平台上，这要求所有静态库都已使用&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; 生成,&lt;/a&gt;因此该代码适合包含在共享库中，我们目前不这样做。</target>
        </trans-unit>
        <trans-unit id="fd263cf5ce99e2b91836dc4e35a2d6bb18f488af" translate="yes" xml:space="preserve">
          <source>In principle, with a suitable class declaration with a functional dependency, it&amp;rsquo;s possible that this type is not ambiguous; but GHC nevertheless rejects it. The type variables mentioned in the context of the data type declaration must be among the type parameters of the data type.</source>
          <target state="translated">原则上，如果使用具有函数依赖项的合适的类声明，则此类型可能不是模棱两可的。但GHC还是拒绝了。在数据类型声明的上下文中提到的类型变量必须在数据类型的类型参数中。</target>
        </trans-unit>
        <trans-unit id="18e2f91b13004cb3ee73758eb6c0f3436fbf8f70" translate="yes" xml:space="preserve">
          <source>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</source>
          <target state="translated">在记录构造和记录模式匹配中,即使范围内有两个不同的数据类型,但有一个共同的字段名,也完全可以毫不含糊地引用哪个字段。例如:</target>
        </trans-unit>
        <trans-unit id="026f7b4f745c03773b13fa4d11e7929e66eb04db" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">简而言之，该库中的所有&amp;ldquo;捕获&amp;rdquo;机制将无法捕获&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;模块中的函数引发的异常，反之亦然。</target>
        </trans-unit>
        <trans-unit id="c7c0b572397dc91bfdb2bb7d885052532168e385" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934808fb13fd2c8c5cce75253dd4e268d2a4d578" translate="yes" xml:space="preserve">
          <source>In short, if you compile a module and its interface changes, then all the modules that import that interface &lt;em&gt;must&lt;/em&gt; be re-compiled.</source>
          <target state="translated">简而言之，如果您编译模块并且其接口发生更改，则&lt;em&gt;必须&lt;/em&gt;重新编译所有导入该接口的模块。</target>
        </trans-unit>
        <trans-unit id="f81140bb54ceba3a8d0fad4549fca0af74b151f4" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;#9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c8b3bf997296fa73e6193137e7fe4e16c83b1a" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Issue #9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">简而言之，如果您希望模式同义词具有类似GADT的行为，那么（与 &lt;code&gt;S1&lt;/code&gt; 之类的具体数据构造函数不同），您必须使用显式提供的相等性来编写其类型。对于像 &lt;code&gt;S1&lt;/code&gt; 这样的具体数据构造函数，您可以将其类型签名写为 &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; 或 &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; ；两者是等效的。模式同义词不是这样：这两种形式是不同的，以区分上述两种情况。（有关此选择的讨论，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;问题＃9953&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c2cfc1f8c0043394ab94a925d7089c33080293c8" translate="yes" xml:space="preserve">
          <source>In short, quantifed constraints do not introduce incoherence.</source>
          <target state="translated">总之,量化约束不会引入不一致。</target>
        </trans-unit>
        <trans-unit id="eedb3f453802c917804d8787ef3886b3897a16d7" translate="yes" xml:space="preserve">
          <source>In short: GHC does &lt;em&gt;not&lt;/em&gt; propagate kind information from the members of a class instance declaration into the instance declaration head.</source>
          <target state="translated">简而言之：GHC并&lt;em&gt;不会&lt;/em&gt;传播从一个类实例声明的成员样的信息为实例声明头。</target>
        </trans-unit>
        <trans-unit id="65fcdd4e01ef4cdb5c7448159811829c535afe34" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">在某些情况下， &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 可以撤消 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似的操作：</target>
        </trans-unit>
        <trans-unit id="b6129fb34e144fcdfe206a301e6dfcb025a1c2ff" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">在某些情况下， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 可以撤消 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似的操作：</target>
        </trans-unit>
        <trans-unit id="7dca494ed5d22b408ce97c79a38cce42379ecc3f" translate="yes" xml:space="preserve">
          <source>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</source>
          <target state="translated">在一些单体中,使用应用性操作符比单体bind更有效。例如,它可以实现更多的并行性。</target>
        </trans-unit>
        <trans-unit id="7dc076e52a11bd5ce04c056123ea9f1e10b44f69" translate="yes" xml:space="preserve">
          <source>In summary, Safe Haskell consists of the following three language flags:</source>
          <target state="translated">总的来说,Safe Haskell由以下三个语言标志组成。</target>
        </trans-unit>
        <trans-unit id="c0610e4e2f239ff00ac0559246fa585a0148acde" translate="yes" xml:space="preserve">
          <source>In summary, given an &lt;code&gt;mdo&lt;/code&gt; expression, GHC first performs segmentation, introducing &lt;code&gt;rec&lt;/code&gt; blocks to wrap over minimal recursive groups. Then, each resulting &lt;code&gt;rec&lt;/code&gt; is desugared, using a call to &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; as described in the previous section. The original &lt;code&gt;mdo&lt;/code&gt;-expression typechecks exactly when the desugared version would do so.</source>
          <target state="translated">总而言之，给定一个 &lt;code&gt;mdo&lt;/code&gt; 表达式，GHC首先执行分段，引入 &lt;code&gt;rec&lt;/code&gt; 块以包装最少的递归组。然后，使用上一节中所述的对 &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; 的调用对每个生成的 &lt;code&gt;rec&lt;/code&gt; 进行减重。原始的 &lt;code&gt;mdo&lt;/code&gt; -expression类型精确地检查已删除版本的时间。</target>
        </trans-unit>
        <trans-unit id="a10dd2ac36a1ae45ee7e6746793e9b0203b43531" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;encodeByteStringWithF&lt;/code&gt;) they will very likely never be.</source>
          <target state="translated">就表达性而言，功能 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; 足以从 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 构造 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。之所以提供此功能的融合变体，是因为它们允许更有效的实现。我们的编译器还不够聪明。以及某些采用的优化方法（请参见 &lt;code&gt;encodeByteStringWithF&lt;/code&gt; ），它们很可能永远不会实现。</target>
        </trans-unit>
        <trans-unit id="16093d6461ecbdcf12ae1c671e142ce8282ad0b5" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (aka bound) threads are much more expensive than &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (aka unbound) threads, because a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread is tied to a particular OS thread, whereas a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread can be run by any OS thread. Context-switching between a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread and a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread is many times more expensive than between two &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads.</source>
          <target state="translated">就性能而言，因为 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 线程绑定到特定的OS线程，而 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程可以由任何OS线程运行，所以 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; （又称绑定）线程比 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; （又称无绑定）线程昂贵得多。在 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 线程和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程之间进行上下文切换比在两个 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 线程之间进行上下文切换要贵很多倍。</target>
        </trans-unit>
        <trans-unit id="bce56fe3f42df3f84c1b74ed1a9d8786ce76ea2b" translate="yes" xml:space="preserve">
          <source>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as &amp;ldquo;moving&amp;rdquo; the floating point by one bit left (negative) or right (positive). Here are some examples:</source>
          <target state="translated">就基础位编码而言，每个十六进制数字对应于4位，您可能会认为该指数将浮点&amp;ldquo;左移&amp;rdquo;（负）或右移（正）一位。这里有些例子：</target>
        </trans-unit>
        <trans-unit id="4c29bd546b673357d6a340429155e16543ce1ef1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例中， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 应该等效于使用常量应用函子（ &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ）进行遍历。</target>
        </trans-unit>
        <trans-unit id="26bd18f823787461b100c3022f6a3b7c840dc2a6" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例中， &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 应该等效于使用标识应用函子（ &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ）进行遍历。</target>
        </trans-unit>
        <trans-unit id="96a50628ee823a13660f1210d45eabd5be493de8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例中， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 应该等效于使用常量应用函子（ &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ）进行遍历。</target>
        </trans-unit>
        <trans-unit id="2b0439badce801cd06d5468b87c04f9c720d7a99" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例中， &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 应该等效于使用标识应用函子（ &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ）进行遍历。</target>
        </trans-unit>
        <trans-unit id="ca7aaa131ade1d4a8a95415db546c6e55e36ffda" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ModIface&lt;/code&gt; datatype you can find lots of useful information, including the exported definitions and type class instances.</source>
          <target state="translated">在 &lt;code&gt;ModIface&lt;/code&gt; 数据类型中，您可以找到许多有用的信息，包括导出的定义和类型类实例。</target>
        </trans-unit>
        <trans-unit id="c9e4b692ce0d40c03d30c364c1d3096a5795a987" translate="yes" xml:space="preserve">
          <source>In the above desugarings, the functions &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt; are all methods of the &lt;code&gt;IsList&lt;/code&gt; class, which is itself exported from the &lt;code&gt;GHC.Exts&lt;/code&gt; module. The type class is defined as follows:</source>
          <target state="translated">在上述说明中，函数 &lt;code&gt;toList&lt;/code&gt; ， &lt;code&gt;fromList&lt;/code&gt; 和 &lt;code&gt;fromListN&lt;/code&gt; 都是 &lt;code&gt;IsList&lt;/code&gt; 类的所有方法，该类本身是从 &lt;code&gt;GHC.Exts&lt;/code&gt; 导出的。模块。类型类的定义如下：</target>
        </trans-unit>
        <trans-unit id="4825ce73481d56bef5ff3baeddca3bd6b9d29055" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt; 调用中，如果 &lt;code&gt;digs&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该值以完全精度显示；如果 &lt;code&gt;digs&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; ，则显示小数点后最多 &lt;code&gt;d&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="a51c3b2c73eac013b9c52be99faf3b0167ac1d7a" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt; 调用中，如果 &lt;code&gt;digs&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该值以完全精度显示；如果 &lt;code&gt;digs&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; ，则显示小数点后最多 &lt;code&gt;d&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="20f3428ed1923f90f0f3d4207a60933c2d70d92e" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt; 调用中，如果 &lt;code&gt;digs&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该值以完全精度显示；如果 &lt;code&gt;digs&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; ，则显示小数点后最多 &lt;code&gt;d&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="faf271f3b7e45777b426c7cffb5c33694e0dd460" translate="yes" xml:space="preserve">
          <source>In the caret diagnostics, there is currently no inheritance at all between &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">在插入符号诊断中， &lt;code&gt;margin&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; ， &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;fatal&lt;/code&gt; 之间目前根本没有继承。。</target>
        </trans-unit>
        <trans-unit id="df6b03ed8eec1645f1ec33aca8ebc6b982b543ce" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, we append the encodings of the two subcomponents:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; ：，我们附加两个子组件的编码：</target>
        </trans-unit>
        <trans-unit id="a978f8a308124dfc5a94e8b84169bed1e73065cf" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, we produce &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; depending on whether the constructor of the value provided is located on the left or on the right:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 我们根据提供的值的构造函数是位于左侧还是右侧来生成False或 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce418c4b3f9c3b015c79b89b8c9bc6967c098d2d" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">在列表中的情况下， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ，当施加到二进制运算符，起始数值（典型地操作员的左标识），和一个列表，降低了使用该二进制运算符的列表中，从左至右依次为：</target>
        </trans-unit>
        <trans-unit id="402a6cba8bb6099d8590be06c5b33a8b61bcddf5" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">在列表的情况下，文件 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，一个起始值（通常是该运算符的右标识）和一个列表，然后使用二进制运算符将列表从右向左缩小：</target>
        </trans-unit>
        <trans-unit id="685a71a3a3feec5434325876c2b1603c04dc1092" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">在列表中的情况下， &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ，当施加到二进制运算符，起始数值（典型地操作员的左标识），和一个列表，降低了使用该二进制运算符的列表中，从左至右依次为：</target>
        </trans-unit>
        <trans-unit id="736cf45d430966ca499dea036acc85e2fd726f3c" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">对于列表，将 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，一个起始值（通常是该运算符的右标识）和一个列表，然后使用二进制运算符将列表从右向左缩小：</target>
        </trans-unit>
        <trans-unit id="d2c4ff0ca5914473682d3bb850acf33cf8e28c10" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">在列表中的情况下， &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ，当施加到二进制运算符，起始数值（典型地操作员的左标识），和一个列表，降低了使用该二进制运算符的列表中，从左至右依次为：</target>
        </trans-unit>
        <trans-unit id="814e67cd70bc9b16fbc05fe331eda86206bb01d8" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">对于列表，将 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 应用于二进制运算符，一个起始值（通常是该运算符的右标识）和一个列表，然后使用二进制运算符将列表从右向左缩小：</target>
        </trans-unit>
        <trans-unit id="9d49a0dc9233f8cd0bbb34abc56b57be8989f4d7" translate="yes" xml:space="preserve">
          <source>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type &lt;code&gt;n&lt;/code&gt; (provided it has an &lt;code&gt;fmap&lt;/code&gt;, as well as the comprehension being over an arbitrary monad.</source>
          <target state="translated">对于转换理解，请注意，这些组是在某个任意类型 &lt;code&gt;n&lt;/code&gt; 上参数化的（假设它具有 &lt;code&gt;fmap&lt;/code&gt; ，并且对任意monad的理解也应如此）。</target>
        </trans-unit>
        <trans-unit id="3a3ec5fd8ab5dd582ca482ba430b56b04ee9d354" translate="yes" xml:space="preserve">
          <source>In the case where a module is compiled without one of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag, then M is marked as safe. Otherwise, it is marked as unsafe.</source>
          <target state="translated">如果在编译模块时未使用&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;，&amp;ldquo; &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;之一，则GHC将尝试弄清楚自己是否可以认为该模块是安全的。此安全性推论永远不会将模块标记为可信赖，仅将其标记为不安全或安全。 GHC使用一种简单的方法来确定模块M的情况：如果M将在&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志下正确编译，则M被标记为安全。否则，它被标记为不安全。</target>
        </trans-unit>
        <trans-unit id="bef7088bfdbcf4a4161af79eaa7b29eb8e585121" translate="yes" xml:space="preserve">
          <source>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</source>
          <target state="translated">在模式类型签名中的所有类型变量都已经在范围内的情况下(即由包围上下文约束),事情很简单:签名只是以明显的方式约束模式的类型。</target>
        </trans-unit>
        <trans-unit id="dd7dd4c533ac4dfdb79170f8873e9bdd1a07434d" translate="yes" xml:space="preserve">
          <source>In the class declaration, nothing constrains the kind of the type &lt;code&gt;a&lt;/code&gt;, so it becomes a poly-kinded type variable &lt;code&gt;(a :: k)&lt;/code&gt;. Yet, in the instance declaration, the right-hand side of the associated type instance &lt;code&gt;b -&amp;gt; b&lt;/code&gt; says that &lt;code&gt;b&lt;/code&gt; must be of kind &lt;code&gt;Type&lt;/code&gt;. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind &lt;code&gt;Type&lt;/code&gt;, as opposed to types of any kind. However, GHC does &lt;em&gt;not&lt;/em&gt; do this.</source>
          <target state="translated">在类声明中，没有什么约束类型 &lt;code&gt;a&lt;/code&gt; 的类型，因此它成为多类型类型变量 &lt;code&gt;(a :: k)&lt;/code&gt; 。但是，在实例声明中，关联类型实例 &lt;code&gt;b -&amp;gt; b&lt;/code&gt; 的右侧表示 &lt;code&gt;b&lt;/code&gt; 必须是 &lt;code&gt;Type&lt;/code&gt; 类型。从理论上讲，GHC可以将该信息传播回实例头，并使该实例声明仅适用于 &lt;code&gt;Type&lt;/code&gt; 类型的类型，而不是任何类型的类型。但是，GHC并&lt;em&gt;没有&lt;/em&gt;做到这一点。</target>
        </trans-unit>
        <trans-unit id="1ea0fe630422f6fbaa324604dd0d23443b8c3800" translate="yes" xml:space="preserve">
          <source>In the common case where &lt;code&gt;CProv&lt;/code&gt; is empty, (i.e., &lt;code&gt;()&lt;/code&gt;), it can be omitted altogether in the above pattern type signature for &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;CProv&lt;/code&gt; 为空的常见情况下（即 &lt;code&gt;()&lt;/code&gt; ），可以在上述 &lt;code&gt;P&lt;/code&gt; 的模式类型签名中将其完全省略。</target>
        </trans-unit>
        <trans-unit id="738595723a083effce19571c75a1705b54ce2cd0" translate="yes" xml:space="preserve">
          <source>In the current GHC implementation, the call stack is only available if the program was compiled with &lt;code&gt;-prof&lt;/code&gt;; otherwise &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; behaves exactly like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;. Entries in the call stack correspond to &lt;code&gt;SCC&lt;/code&gt; annotations, so it is a good idea to use &lt;code&gt;-fprof-auto&lt;/code&gt; or &lt;code&gt;-fprof-auto-calls&lt;/code&gt; to add SCC annotations automatically.</source>
          <target state="translated">在当前的GHC实现中，仅当使用 &lt;code&gt;-prof&lt;/code&gt; 编译程序时，调用堆栈才可用。否则 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; 的行为与 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 完全相同。调用堆栈中的条目对应于 &lt;code&gt;SCC&lt;/code&gt; 注释，因此，最好使用 &lt;code&gt;-fprof-auto&lt;/code&gt; 或 &lt;code&gt;-fprof-auto-calls&lt;/code&gt; 自动添加SCC注释。</target>
        </trans-unit>
        <trans-unit id="acbdce2c4062331f2c3f39e4ae942c4efb63986d" translate="yes" xml:space="preserve">
          <source>In the definition for &lt;code&gt;F&lt;/code&gt;, the two equations are incompatible &amp;ndash; their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type &lt;code&gt;F a&lt;/code&gt; does not simplify; only a type such as &lt;code&gt;F Double&lt;/code&gt; will simplify to &lt;code&gt;Char&lt;/code&gt;. In &lt;code&gt;G&lt;/code&gt;, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, &lt;code&gt;G a&lt;/code&gt; will simplify to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;F&lt;/code&gt; 的定义中，两个方程式不兼容-它们的模式不分开，但它们的右侧不一致。因此，在GHC选择第二个方程之前，必须确保第一个方程永远不会适用。因此，类型 &lt;code&gt;F a&lt;/code&gt; 不会简化。只有 &lt;code&gt;F Double&lt;/code&gt; 这样的类型会简化为 &lt;code&gt;Char&lt;/code&gt; 。另一方面，在 &lt;code&gt;G&lt;/code&gt; 中，两个方程是兼容的。因此，GHC在查看第二个方程时可以忽略第一个方程。因此， &lt;code&gt;G a&lt;/code&gt; 将简化为 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="846c20df94f9314fa1fe586ab3d9172b13b606cb" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type withing generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="translated">在定义 &lt;code&gt;gmapQ&lt;/code&gt; &lt;em&gt;X&lt;/em&gt;组合程序，我们使用幻影类型构造为 &lt;code&gt;c&lt;/code&gt; 的类型 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 因为查询的结果类型不涉及（多态）类型的长期争论。在 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; 的定义中，我们简单地使用普通常量类型构造函数，因为 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 仍然是左关联的，因此它很适合在左子项上折叠左关联的二进制运算。在gmapQr的定义中，需要付出额外的努力。我们使用高阶累积技巧在左关联构造函数应用程序与右关联二进制操作之间进行中介（例如 &lt;code&gt;(:)&lt;/code&gt; ）。当查询打算计算类型 &lt;code&gt;r&lt;/code&gt; 的值时，具有通用折叠的结果类型为 &lt;code&gt;r -&amp;gt; r&lt;/code&gt; 。因此，折叠的结果是一个函数，我们最终将正确的单位传递给该函数。</target>
        </trans-unit>
        <trans-unit id="172ded5aaf2bf60400ff8b3fbe797e04c36dee1c" translate="yes" xml:space="preserve">
          <source>In the degenerate case where all the alternatives have zero width, such as the &lt;code&gt;Bool&lt;/code&gt;-like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt;, the unboxed sum layout only has an &lt;code&gt;Int32&lt;/code&gt; tag field (i.e., the whole thing is represented by an integer).</source>
          <target state="translated">在退化的情况下，所有替代项的宽度均为零，例如类似 &lt;code&gt;Bool&lt;/code&gt; 的 &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt; ，未装箱的总和布局仅具有 &lt;code&gt;Int32&lt;/code&gt; 标签字段（即，表示了整个内容）整数）。</target>
        </trans-unit>
        <trans-unit id="eae7ddef52aa6d501f88a9704bbcc99c4b28932e" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在文档中，\（n \）是列表中元素的数量，而\（d \）是列表中不同元素的数量。\（W \）是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数。</target>
        </trans-unit>
        <trans-unit id="f0778e8d7eb2efc83b2b32dc144b880b32c199c0" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8410efb81dbdeacb0d6540b0e647a317447ad44" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">如果您想将ghc编译的代码包含在另一个（非Haskell）程序中，RTS将在链接时不提供其 &lt;code&gt;main()&lt;/code&gt; 的定义。要在链接时向编译器发出信号，请使用 &lt;code&gt;-no-hs-main&lt;/code&gt; 。另请参阅&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d261a91a10cc118ec325a4c82debf0de9dec298f" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;Danger&lt;/code&gt; can import module &lt;code&gt;RIO&lt;/code&gt; because &lt;code&gt;RIO&lt;/code&gt; is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;Danger&lt;/code&gt; can make use of the &lt;code&gt;rioReadFile&lt;/code&gt; and &lt;code&gt;rioWriteFile&lt;/code&gt; functions to access permitted file names. The main application then imports both &lt;code&gt;RIO&lt;/code&gt; and &lt;code&gt;Danger&lt;/code&gt;. To run the plugin, it calls &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. The application is safe in the knowledge that the only &lt;code&gt;IO&lt;/code&gt; to ensue will be to files whose paths were approved by the &lt;code&gt;pathOK&lt;/code&gt; test.</source>
          <target state="translated">在该示例中， &lt;code&gt;Danger&lt;/code&gt; 可以导入模块 &lt;code&gt;RIO&lt;/code&gt; ,因为 &lt;code&gt;RIO&lt;/code&gt; 是使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的。因此， &lt;code&gt;Danger&lt;/code&gt; 可以使用 &lt;code&gt;rioReadFile&lt;/code&gt; 和 &lt;code&gt;rioWriteFile&lt;/code&gt; 函数来访问允许的文件名。然后，主应用程序同时导入 &lt;code&gt;RIO&lt;/code&gt; 和 &lt;code&gt;Danger&lt;/code&gt; 。要运行该插件，它将在 &lt;code&gt;IO&lt;/code&gt; monad中调用 &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; 。该应用程序是安全的，因为唯一要 &lt;code&gt;pathOK&lt;/code&gt; &lt;code&gt;IO&lt;/code&gt; 将是其路径被pathOK测试批准的文件。</target>
        </trans-unit>
        <trans-unit id="04e6cf746c3b3e5d963876bd4cd89448b3120476" translate="yes" xml:space="preserve">
          <source>In the examples above, all promoted constructors are prefixed with a single quote mark &lt;code&gt;'&lt;/code&gt;. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</source>
          <target state="translated">在上面的示例中，所有提升的构造函数都以单引号 &lt;code&gt;'&lt;/code&gt; 开头。该标记告诉GHC在数据构造器名称空间中查找名称，而不是类型（构造器）名称空间。考虑</target>
        </trans-unit>
        <trans-unit id="40ee1ceda8e59fc5b01c325869581e1e58fcdd95" translate="yes" xml:space="preserve">
          <source>In the first application of &lt;code&gt;f&lt;/code&gt;, we had to do some more type reconstruction in order to recover the result type of &lt;code&gt;f&lt;/code&gt;. But after that, we are free to use &lt;code&gt;f&lt;/code&gt; normally.</source>
          <target state="translated">在 &lt;code&gt;f&lt;/code&gt; 的第一个应用程序中，我们必须进行一些其他类型的重构才能恢复 &lt;code&gt;f&lt;/code&gt; 的结果类型。但是之后，我们可以自由地正常使用 &lt;code&gt;f&lt;/code&gt; 了。</target>
        </trans-unit>
        <trans-unit id="149193862750cd07d67aa98378a43e7fa5bcd8bc" translate="yes" xml:space="preserve">
          <source>In the first example above, &lt;code&gt;_x&lt;/code&gt; is generalised over (and is effectively replaced by a fresh type variable &lt;code&gt;a&lt;/code&gt;). In the second example, &lt;code&gt;_x&lt;/code&gt; is unified with the &lt;code&gt;Bool&lt;/code&gt; type, and as &lt;code&gt;Bool&lt;/code&gt; implements the &lt;code&gt;Show&lt;/code&gt; type class, the constraint &lt;code&gt;Show Bool&lt;/code&gt; can be simplified away.</source>
          <target state="translated">在上面的第一个示例中，对 &lt;code&gt;_x&lt;/code&gt; 进行了概括（并有效地由新鲜类型变量 &lt;code&gt;a&lt;/code&gt; 代替）。在第二个示例中， &lt;code&gt;_x&lt;/code&gt; 与 &lt;code&gt;Bool&lt;/code&gt; 类型统一，并且当 &lt;code&gt;Bool&lt;/code&gt; 实现 &lt;code&gt;Show&lt;/code&gt; 类型类时，可以简化约束 &lt;code&gt;Show Bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c6ea9d39cdb3d6f149abc95c32c55d1e377bfe4" translate="yes" xml:space="preserve">
          <source>In the first example, the kind variable &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;invisible&lt;/em&gt; argument to &lt;code&gt;ProxyKInvis&lt;/code&gt;. In other words, a user does not need to instantiate &lt;code&gt;k&lt;/code&gt; explicitly, as kind inference automatically determines what &lt;code&gt;k&lt;/code&gt; should be. For instance, in &lt;code&gt;ProxyKInvis True&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; is inferred to be &lt;code&gt;Bool&lt;/code&gt;. This is reflected in the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e49151ec338f81e6976a10a88331d5852242bf" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;Haskell file&amp;rdquo; is the main output (usually a &lt;code&gt;.hs&lt;/code&gt; file), &amp;ldquo;compiled Haskell file&amp;rdquo; is the Haskell file after &lt;code&gt;ghc&lt;/code&gt; has compiled it to C (i.e. a &lt;code&gt;.hc&lt;/code&gt; file), &amp;ldquo;C program&amp;rdquo; is the program that outputs the Haskell file, &amp;ldquo;C file&amp;rdquo; is the optionally generated C file, and &amp;ldquo;C header&amp;rdquo; is its header file.</source>
          <target state="translated">在下面的代码中，&amp;ldquo; Haskell文件&amp;rdquo;是主要输出（通常是 &lt;code&gt;.hs&lt;/code&gt; 文件），&amp;ldquo; compiled Haskell文件&amp;rdquo;是 &lt;code&gt;ghc&lt;/code&gt; 将其编译为C 之后的Haskell文件（即 &lt;code&gt;.hc&lt;/code&gt; 文件），&amp;ldquo; C程序&amp;rdquo;是输出Haskell文件的程序，&amp;ldquo; C文件&amp;rdquo;是可选生成的C文件，&amp;ldquo; C头文件&amp;rdquo;是其头文件。</target>
        </trans-unit>
        <trans-unit id="dc1456dc1bb5376e50df9356963ec4ad4e2b367b" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;h&lt;/code&gt; we use the record selectors &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; to extract the polymorphic bind and return functions from the &lt;code&gt;MonadT&lt;/code&gt; data structure, rather than using pattern matching.</source>
          <target state="translated">在函数 &lt;code&gt;h&lt;/code&gt; 中,我们使用记录选择器 &lt;code&gt;return&lt;/code&gt; 和 &lt;code&gt;bind&lt;/code&gt; 从 &lt;code&gt;MonadT&lt;/code&gt; 数据结构中提取多态绑定和return函数，而不是使用模式匹配。</target>
        </trans-unit>
        <trans-unit id="3c2ee3eafdcad4b683c78d591fee52c85b813144" translate="yes" xml:space="preserve">
          <source>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</source>
          <target state="translated">将来,GHC可能会使用manifest文件做更多的事情,比如提供依赖的DLL的位置。</target>
        </trans-unit>
        <trans-unit id="8c26d49122d64dd0270b09c279fadaf85a7e889c" translate="yes" xml:space="preserve">
          <source>In the last line, we use the promoted constructor &lt;code&gt;'MkCompose&lt;/code&gt;, which has kind</source>
          <target state="translated">在最后一行，我们使用升级的构造函数 &lt;code&gt;'MkCompose&lt;/code&gt; ，它具有</target>
        </trans-unit>
        <trans-unit id="6ea81a9e9ab238a60258241f86c06e46f72fec13" translate="yes" xml:space="preserve">
          <source>In the last section we saw that besides a name, a &lt;code&gt;CoreDoPluginPass&lt;/code&gt; takes a pass of type &lt;code&gt;PluginPass&lt;/code&gt;. A &lt;code&gt;PluginPass&lt;/code&gt; is a synonym for &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;. &lt;code&gt;ModGuts&lt;/code&gt; is a type that represents the one module being compiled by GHC at any given time.</source>
          <target state="translated">在上一节中，我们看到除了名称之外， &lt;code&gt;CoreDoPluginPass&lt;/code&gt; 还带有PluginPass类型的 &lt;code&gt;PluginPass&lt;/code&gt; 。甲 &lt;code&gt;PluginPass&lt;/code&gt; 为同义词 &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; 。 &lt;code&gt;ModGuts&lt;/code&gt; 是一种类型，代表GHC在任何给定时间正在编译的一个模块。</target>
        </trans-unit>
        <trans-unit id="e7151264545101799acf59e7b7e571c55db95bd2" translate="yes" xml:space="preserve">
          <source>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint &lt;code&gt;C t&lt;/code&gt;</source>
          <target state="translated">根据重叠决策，在尝试解决类约束 &lt;code&gt;C t&lt;/code&gt; 时，实例查找的工作方式如下</target>
        </trans-unit>
        <trans-unit id="53eb63bc56e230d6466f7d38014cd8cc4cf52862" translate="yes" xml:space="preserve">
          <source>In the messages from the compiler, we see that there is no line for &lt;code&gt;D&lt;/code&gt;. This is because it isn&amp;rsquo;t necessary to compile &lt;code&gt;D&lt;/code&gt;, because the source and everything it depends on is unchanged since the last compilation.</source>
          <target state="translated">在来自编译器的消息中，我们看到 &lt;code&gt;D&lt;/code&gt; 没有一行。这是因为不必编译 &lt;code&gt;D&lt;/code&gt; ，因为自上次编译以来，源及其依赖的所有内容都没有改变。</target>
        </trans-unit>
        <trans-unit id="ddeb2139081c601845dbe769a075fe10d73419d8" translate="yes" xml:space="preserve">
          <source>In the olden days, GHC compared the newly-generated &lt;code&gt;.hi&lt;/code&gt; file with the previous version; if they were identical, it left the old one alone and didn&amp;rsquo;t change its modification date. In consequence, importers of a module with an unchanged output &lt;code&gt;.hi&lt;/code&gt; file were not recompiled.</source>
          <target state="translated">在过去，GHC将新生成的 &lt;code&gt;.hi&lt;/code&gt; 文件与以前的版本进行比较；如果它们是相同的，则它会保留旧版本，并且不会更改其修改日期。结果，没有重新编译输出 &lt;code&gt;.hi&lt;/code&gt; 文件不变的模块的导入器。</target>
        </trans-unit>
        <trans-unit id="374581211f11803a65e2cf204f4183e85b4fceb6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">在上面的输出中，观察到 &lt;code&gt;T&lt;/code&gt; 具有两个类型变量（ &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; ）和两个类型变量（ &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ）。请注意， &lt;code&gt;k&lt;/code&gt; 是一个&lt;em&gt;推断&lt;/em&gt;变量，而 &lt;code&gt;l&lt;/code&gt; 是一个&lt;em&gt;指定&lt;/em&gt;变量（请参阅&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;推断的vs.指定的类型变量&lt;/a&gt;），因此，它们以略有不同的语法在 &lt;code&gt;T @{k} @l a b&lt;/code&gt; 类型中显示。 &lt;code&gt;l&lt;/code&gt; 的应用程序（带有 &lt;code&gt;@l&lt;/code&gt; ）是可见类型应用程序的标准语法（请参见&lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;）。应用 &lt;code&gt;k&lt;/code&gt; （用 &lt;code&gt;@{k}&lt;/code&gt; ），但是对推断的类型变量的可见类型应用使用一种假设的语法。该语法当前未公开给程序员，但在启用&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;时仍会显示。</target>
        </trans-unit>
        <trans-unit id="0a5a27aca496c351b26fd16433d9f2aacedebfda" translate="yes" xml:space="preserve">
          <source>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</source>
          <target state="translated">在本文和以前的实施例中,堆栈上的值是以单个参数的形式搭配在环境的右边,但现在环境和堆栈是单独的参数。</target>
        </trans-unit>
        <trans-unit id="e4a4ad8ff9e2ea2640cf5cde3b222326c4f733bc" translate="yes" xml:space="preserve">
          <source>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</source>
          <target state="translated">在前面的例子中,我们使用条件表达式来构造一个箭头的输入。有时,我们希望有条件地执行不同的命令,如在</target>
        </trans-unit>
        <trans-unit id="53458cc6655e7a520b6f10bf393f2ad481ee4cd4" translate="yes" xml:space="preserve">
          <source>In the second declaration, GHC cannot immediately tell that &lt;code&gt;k&lt;/code&gt; should be a dependent variable, and so the declaration is rejected.</source>
          <target state="translated">在第二个声明中，GHC无法立即告诉 &lt;code&gt;k&lt;/code&gt; 应该是因变量，因此该声明被拒绝。</target>
        </trans-unit>
        <trans-unit id="e04af78973d3e47e134276ff85a7f3c652f7d13c" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;visible&lt;/em&gt; argument to &lt;code&gt;ProxyKVis&lt;/code&gt;. That is to say, &lt;code&gt;k&lt;/code&gt; is an argument that users must provide explicitly when applying &lt;code&gt;ProxyKVis&lt;/code&gt;. For example, &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; is a well formed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55addee8e051e63bec155782732ce1d09c9a2858" translate="yes" xml:space="preserve">
          <source>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</source>
          <target state="translated">在上一节的简单案例中,我们可以说指定的变量是按照从左到右的顺序出现的。然而,并不是所有的情况都这么简单。下面是更细微的情况下的规则。</target>
        </trans-unit>
        <trans-unit id="97b005cab59c28efe19b8404620d4586fb6285f7" translate="yes" xml:space="preserve">
          <source>In the threaded and SMP versions of the RTS (see &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), a major GC is automatically performed if the runtime has been idle (no Haskell computation has been running) for a period of time. The amount of idle time which must pass before a GC is performed is set by the &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; option. Specifying &lt;code&gt;-I0&lt;/code&gt; disables the idle GC.</source>
          <target state="translated">在RTS的线程版本和SMP版本中（请参见&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;），如果运行时间处于空闲状态（没有运行Haskell计算）一段时间，则会自动执行主要GC。通过 &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; 选项设置执行GC前必须经过的空闲时间。指定 &lt;code&gt;-I0&lt;/code&gt; 将禁用空闲GC。</target>
        </trans-unit>
        <trans-unit id="1694137a8ab9fbad9a236c803a20b15d21740e1f" translate="yes" xml:space="preserve">
          <source>In the unification check in the final bullet, GHC also uses the &amp;ldquo;in-scope given constraints&amp;rdquo;. Consider for example</source>
          <target state="translated">在最终项目符号的统一检查中，GHC还使用&amp;ldquo;范围内给定约束&amp;rdquo;。考虑一下</target>
        </trans-unit>
        <trans-unit id="588a44eae37ca5b1dac65821d0d9f7a7a8542d81" translate="yes" xml:space="preserve">
          <source>In the unlikely case that modifier characters of some kind are desirable for a user-provided type, a &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; can be provided to process these characters. The resulting modifiers will appear in the &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; for use by the type-specific formatter.</source>
          <target state="translated">如果不太可能出现某种修饰符对于用户提供的类型是理想的，则可以提供 &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; 来处理这些字符。结果修饰符将出现在 &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; 中,以供特定于类型的格式化程序使用。</target>
        </trans-unit>
        <trans-unit id="2ad711240568f9303ca209fe831d40e7c3af2733" translate="yes" xml:space="preserve">
          <source>In theory, this mechanism allows arbitrary data to be roundtripped via a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with no loss of data. In practice, there are two limitations to be aware of:</source>
          <target state="translated">从理论上讲，此机制允许通过 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 来回传送任意数据，而不会丢失数据。实际上，要注意两个限制：</target>
        </trans-unit>
        <trans-unit id="23cb01df08dfcb7824b863fc014f5bf29ea5fc79" translate="yes" xml:space="preserve">
          <source>In this case the derived instance declaration is of the form</source>
          <target state="translated">在这种情况下,派生实例声明的形式为</target>
        </trans-unit>
        <trans-unit id="71a288fd8d8656887893d68ab53108d408b426c0" translate="yes" xml:space="preserve">
          <source>In this case the kind parameter &lt;code&gt;k&lt;/code&gt; is actually an implicit parameter of the type family.</source>
          <target state="translated">在这种情况下，种类参数 &lt;code&gt;k&lt;/code&gt; 实际上是类型族的隐式参数。</target>
        </trans-unit>
        <trans-unit id="1458f3d45d7cf8add3f964f47bf5c04fad0f65f0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn&amp;rsquo;t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Head&lt;/code&gt; ⟨x⟩不能在表达式中，只有模式使用，因为它不会指定在右侧的⟨xs⟩的值。但是，我们可以通过分别指定如何构造和解构类型来定义显式双向模式同义词。这样做的语法如下：</target>
        </trans-unit>
        <trans-unit id="a0936edcab6b0c6b0eac6247ce8f47c52daa2c9a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;g&lt;/code&gt; is desugared to</source>
          <target state="translated">在这种情况下， &lt;code&gt;g&lt;/code&gt; 被减为</target>
        </trans-unit>
        <trans-unit id="46b676aa5c3c6fb868cf3f9cd7c077e91b44b610" translate="yes" xml:space="preserve">
          <source>In this case, the child thread will receive a &lt;code&gt;NonTermination&lt;/code&gt; exception instead of waiting for the value of &lt;code&gt;r&lt;/code&gt; to be computed.</source>
          <target state="translated">在这种情况下，子线程将收到 &lt;code&gt;NonTermination&lt;/code&gt; 异常，而不是等待 &lt;code&gt;r&lt;/code&gt; 的值被计算。</target>
        </trans-unit>
        <trans-unit id="2cd24087d75374f112a445bc71400a6456c492b4" translate="yes" xml:space="preserve">
          <source>In this case, we could not simply bind &lt;code&gt;k&lt;/code&gt; on the left-hand side, as &lt;code&gt;k&lt;/code&gt; would become a &lt;em&gt;visible&lt;/em&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cc674153a787afcfa95c57ed93cc3673880fbe" translate="yes" xml:space="preserve">
          <source>In this case, we were able to do this with &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;, but operations with more complex types require special lifting functions, which are provided by monad transformers for which they can be implemented. If you use the monad classes of the &lt;code&gt;mtl&lt;/code&gt; package or similar, this lifting is handled automatically by the instances of the classes, and you need only use the generalized methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，我们可以使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 来做到这一点，但是类型更复杂的操作需要特殊的提升功能，这些功能由monad变压器提供，可以实现这些功能。如果您使用 &lt;code&gt;mtl&lt;/code&gt; 包的monad类或类似的类，则这种提升将由这些类的实例自动处理，并且您只需要使用广义方法 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="7bb4a09f269488c7395d0751f14e5beb2db506fc" translate="yes" xml:space="preserve">
          <source>In this chapter you&amp;rsquo;ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It&amp;rsquo;s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</source>
          <target state="translated">在本章中，您将找到有关GHC命令行语法的完整参考，包括所有400多个标志。这是一个庞大而复杂的系统，并且有很多细节，因此很难弄清楚如何入门。考虑到这一点，在以下各节深入介绍完整语法之前，本介绍性部分将简要介绍GHC用于编译Haskell程序的基本用法。</target>
        </trans-unit>
        <trans-unit id="a4cb88a5dbcf9e66af97ada60f7fc8018cc84f7c" translate="yes" xml:space="preserve">
          <source>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such &lt;code&gt;-fspec-constr&lt;/code&gt; will transform the above code to:</source>
          <target state="translated">在此代码中，一旦我们通过了对空列表的初始检查，便知道在递归情况下，此模式匹配是多余的。这样， &lt;code&gt;-fspec-constr&lt;/code&gt; 会将上面的代码转换为：</target>
        </trans-unit>
        <trans-unit id="b4c5c94cfab7bea6a279520afd17cf54b4f5145f" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;Reader&lt;/code&gt; monad provides access to variable bindings. Bindings are a &lt;code&gt;Map&lt;/code&gt; of integer variables. The variable &lt;code&gt;count&lt;/code&gt; contains number of variables in the bindings. You can see how to run a Reader monad and retrieve data from it with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt;, how to access the Reader data with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;Reader&lt;/code&gt; monad提供对变量绑定的访问。绑定是整数变量的 &lt;code&gt;Map&lt;/code&gt; 。变量 &lt;code&gt;count&lt;/code&gt; 包含绑定中变量的数量。你可以看到如何运行一个读者的单子，并从它检索数据 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt; ，如何访问读取器数据与 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b2208e92b48546b397d55cc261960cb8033549a" translate="yes" xml:space="preserve">
          <source>In this example we use the operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;, which are defined only for monads that are applications of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. Alternatively one could use monad classes from the &lt;code&gt;mtl&lt;/code&gt; package or similar, which contain methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; with types generalized over all suitable monads.</source>
          <target state="translated">在这个例子中，我们使用的操作 &lt;code&gt;get&lt;/code&gt; 并 &lt;code&gt;put&lt;/code&gt; 从&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;，这只是对于那些应用单子定义 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 。或者，可以使用来自 &lt;code&gt;mtl&lt;/code&gt; 包或类似包的monad类，其中包含对所有合适的monad进行通用化的 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="22ae5ddc301afbf76db451d6ae86206a63cdb84b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt; depends on &lt;code&gt;a&lt;/code&gt;. Even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ac2fd6e175d918e681db807d09bc0d9cfd7a0f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;op&lt;/code&gt; is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of &lt;code&gt;op&lt;/code&gt;-used-at-type-Bool to a specialised function, say &lt;code&gt;opBool&lt;/code&gt;, where</source>
          <target state="translated">在此示例中， &lt;code&gt;op&lt;/code&gt; 不是普通的顶级函数；这是一个类方法。GHC快速将 &lt;code&gt;op&lt;/code&gt; - &lt;code&gt;opBool&lt;/code&gt; -at-type-Bool的任何出现重写为专用功能，例如opBool，其中</target>
        </trans-unit>
        <trans-unit id="a54c35f64a11f9102b446b75a06ab15997039209" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144a6001279409b5fe23e336fea6b41236a7436a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside...</source>
          <target state="translated">在这个例子中，一个 &lt;code&gt;reify&lt;/code&gt; 内...</target>
        </trans-unit>
        <trans-unit id="d1ca7b6071a21a43da3a7e5ebc0b51fe9aa62cd1" translate="yes" xml:space="preserve">
          <source>In this example, all of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are considered kind variables and will always be placed before &lt;code&gt;b&lt;/code&gt;, a lowly type variable. (Note that &lt;code&gt;a&lt;/code&gt; is used in &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind.) Yet, even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">在此示例中，所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 都被视为种类变量，并将始终放置在 &lt;code&gt;b&lt;/code&gt; （低类型变量）之前。（请注意， &lt;code&gt;a&lt;/code&gt; 用于 &lt;code&gt;b&lt;/code&gt; 的那种。）然而，即使 &lt;code&gt;a&lt;/code&gt; 前词汇出现 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 首先量化，因为 &lt;code&gt;a&lt;/code&gt; 依赖于 &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 。还要注意， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 不会相对于彼此重新排序，即使这样做不会违反依赖条件。</target>
        </trans-unit>
        <trans-unit id="ea70ba4f788151f3c14bd89916938adefd9dddbc" translate="yes" xml:space="preserve">
          <source>In this example, the declaration has only one variant. In general, it can be any number.</source>
          <target state="translated">在这个例子中,声明只有一个变量。一般来说,它可以是任何数字。</target>
        </trans-unit>
        <trans-unit id="c73dc37636c8cb640cf041df73293ff0e50794dc" translate="yes" xml:space="preserve">
          <source>In this example, the list &lt;code&gt;output&lt;/code&gt; would take on the value:</source>
          <target state="translated">在此示例中，列表 &lt;code&gt;output&lt;/code&gt; 将采用以下值：</target>
        </trans-unit>
        <trans-unit id="0477cc1de77b96d2dcbf9d8cc1e8fbeac11cb261" translate="yes" xml:space="preserve">
          <source>In this example, we inspect all available details of the compiled source code. We don&amp;rsquo;t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</source>
          <target state="translated">在此示例中，我们检查了已编译源代码的所有可用细节。我们不更改任何表示形式，而是将详细信息写到标准输出中。解析，重命名和类型检查的语法树的漂亮打印表示形式以及评估的接头和准引号将出现在输出中。还将显示已加载的接口的名称。</target>
        </trans-unit>
        <trans-unit id="ce7a808f73475173c84b4a7d49aa6676ec3a0955" translate="yes" xml:space="preserve">
          <source>In this example, you cannot say &lt;code&gt;... deriving( Show )&lt;/code&gt; on the data type declaration for &lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt; is a GADT, but you &lt;em&gt;can&lt;/em&gt; generate the instance declaration using stand-alone deriving.</source>
          <target state="translated">在此示例中，您不能在 &lt;code&gt;T&lt;/code&gt; 的数据类型声明上说 &lt;code&gt;... deriving( Show )&lt;/code&gt; ，因为 &lt;code&gt;T&lt;/code&gt; 是GADT，但是您&lt;em&gt;可以&lt;/em&gt;使用独立派生生成实例声明。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="af62a3290de70aad01a1a52e1391134fd1bf6e1e" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;.</source>
          <target state="translated">在这种模式下，GHC将自动构建一个多模块的Haskell程序，从而自行确定依赖关系。如果您有一个简单的Haskell程序，则与使用&lt;strong&gt;make&lt;/strong&gt;相比，这可能会更容易，更快捷。&lt;a href=&quot;#make-mode&quot;&gt;使用ghc &amp;ndash;make中&lt;/a&gt;描述了Make模式。</target>
        </trans-unit>
        <trans-unit id="05b4a3b6689dfdb162bbf16479c4e6487fd716f8" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b5fc6a536a1554868646b6ca60e10360d30c4b" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just &lt;code&gt;Main&lt;/code&gt;). For example, if your &lt;code&gt;Main&lt;/code&gt; module is in a file called &lt;code&gt;Main.hs&lt;/code&gt;, you could compile and link the program like this:</source>
          <target state="translated">在这种模式下，GHC将遵循一个或多个根模块（通常只是 &lt;code&gt;Main&lt;/code&gt; ）的依赖关系来构建多模块Haskell程序。例如，如果您的 &lt;code&gt;Main&lt;/code&gt; 模块位于名为 &lt;code&gt;Main.hs&lt;/code&gt; 的文件中，则可以像下面这样编译和链接程序：</target>
        </trans-unit>
        <trans-unit id="28db988427b635ef091ce5edd09284a3efe60154" translate="yes" xml:space="preserve">
          <source>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</source>
          <target state="translated">在这个符号中,浮点数字是用十六进制数字来写的,所以数字的解释是用16进制,而不是通常的10。这意味着小数点左边的数字对应16的正数,而右边的数字对应负数。</target>
        </trans-unit>
        <trans-unit id="1625565ac67aff08f4fe4a675ec370d8a1444409" translate="yes" xml:space="preserve">
          <source>In this redefinition, we give an explicit kind for &lt;code&gt;(:~~:)&lt;/code&gt;, deferring the choice of &lt;code&gt;k2&lt;/code&gt; until after the first argument (&lt;code&gt;a&lt;/code&gt;) has been given. With this declaration for &lt;code&gt;(:~~:)&lt;/code&gt;, the instance for &lt;code&gt;HTestEquality&lt;/code&gt; is accepted.</source>
          <target state="translated">在此重新定义中，我们为 &lt;code&gt;(:~~:)&lt;/code&gt; 提供一个明确的种类，将 &lt;code&gt;k2&lt;/code&gt; 的选择推迟到给出第一个参数（ &lt;code&gt;a&lt;/code&gt; ）之后。有了 &lt;code&gt;(:~~:)&lt;/code&gt; 声明， &lt;code&gt;HTestEquality&lt;/code&gt; 可以接受HTestEquality的实例。</target>
        </trans-unit>
        <trans-unit id="241d07916ab9a1a491c806d2158cdc7962a6343f" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is lazy, so that for example the following produces a usable result:</source>
          <target state="translated">在这个版本中,计算的顺序是懒惰的,因此,例如下面会产生一个可用的结果。</target>
        </trans-unit>
        <trans-unit id="c84b399cd2cbed2ef45d9909f32f6700a23e3816" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">在此版本中，计算的顺序是严格的（但是状态中的计算并不严格，除非您使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 等强制执行）。有关具有相同接口的惰性版本，请参见&lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="733a7b8597e3bea6d79329500059b7357f9f04c9" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a029dcaf77ff2149eaa82e23825caa41a60b1" translate="yes" xml:space="preserve">
          <source>In type errors, also print type-synonym-expanded types.</source>
          <target state="translated">在类型错误中,也要打印类型同义词扩展类型。</target>
        </trans-unit>
        <trans-unit id="9cdca6bb9120edae790472f128bdcd1be571c545" translate="yes" xml:space="preserve">
          <source>In types, an operator symbol like &lt;code&gt;(+)&lt;/code&gt; is normally treated as a type &lt;em&gt;variable&lt;/em&gt;, just like &lt;code&gt;a&lt;/code&gt;. Thus in Haskell 98 you can say</source>
          <target state="translated">在类型，如操作者的符号 &lt;code&gt;(+)&lt;/code&gt; 通常视为型&lt;em&gt;变量&lt;/em&gt;，就像 &lt;code&gt;a&lt;/code&gt; 。因此，在Haskell 98中，您可以说</target>
        </trans-unit>
        <trans-unit id="65afe3f89d89dfa50d619b7bc79e59801641ec08" translate="yes" xml:space="preserve">
          <source>In typical use cases it can be imported alongside &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;, e.g.</source>
          <target state="translated">在典型的用例中，它可以与&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;一起导入，例如</target>
        </trans-unit>
        <trans-unit id="d1e5195c56fb5f6cf6fae4475985c40c8b88fe88" translate="yes" xml:space="preserve">
          <source>In your program, you import a module &lt;code&gt;Foo&lt;/code&gt; by saying &lt;code&gt;import Foo&lt;/code&gt;. In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, GHC will look for a source file for &lt;code&gt;Foo&lt;/code&gt; and arrange to compile it first. Without &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, GHC will look for the interface file for &lt;code&gt;Foo&lt;/code&gt;, which should have been created by an earlier compilation of &lt;code&gt;Foo&lt;/code&gt;. GHC uses the same strategy in each of these cases for finding the appropriate file.</source>
          <target state="translated">在你的程序中，导入了一个模块 &lt;code&gt;Foo&lt;/code&gt; 说 &lt;code&gt;import Foo&lt;/code&gt; 。在&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式或GHCi中，GHC将查找 &lt;code&gt;Foo&lt;/code&gt; 的源文件并安排首先对其进行编译。如果没有&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;，GHC将为 &lt;code&gt;Foo&lt;/code&gt; 寻找接口文件，该文件应该是由 &lt;code&gt;Foo&lt;/code&gt; 的早期编译创建的。在每种情况下，GHC都使用相同的策略来查找适当的文件。</target>
        </trans-unit>
        <trans-unit id="e6fb0b72e73092b08131513da6dffeda9e5d2c1b" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current output history on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">将 &lt;code&gt;callCC&lt;/code&gt; 操作原位提升到新monad。此版本在输入延续时使用当前输出历史记录。它不满足均匀性属性（请参见&lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ed82252f8ef32e515385822c367b97c16dae701f" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation.</source>
          <target state="translated">将 &lt;code&gt;callCC&lt;/code&gt; 操作原位提升到新monad。此版本在输入延续时使用当前状态。</target>
        </trans-unit>
        <trans-unit id="6a76bfe845d96c79100211ad66d5be912f9bcb9e" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">将 &lt;code&gt;callCC&lt;/code&gt; 操作原位提升到新monad。此版本在输入延续时使用当前状态。它不满足均匀性属性（请参见&lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0bc346f91d9ddc5a0ccbe414514a097c0e2ae594" translate="yes" xml:space="preserve">
          <source>InappropriateType</source>
          <target state="translated">InappropriateType</target>
        </trans-unit>
        <trans-unit id="491a2c5d60825a9925b3d9a2ec49e95b47e7f9c8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples or sums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5a86ec622c5d2ce4a51514213ff5193a71f6e8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples.</source>
          <target state="translated">顺便说一句，&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;与GHCi不兼容，这是因为字节码编译器无法处理未装箱的元组。</target>
        </trans-unit>
        <trans-unit id="04035088cec19a7e2a3af045cabd4c24b2d47171" translate="yes" xml:space="preserve">
          <source>Include preprocessor dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7ecb7c530843411667d62a790e5a78d07bb31e" translate="yes" xml:space="preserve">
          <source>Include the memory occupied by threads in a heap profile. Each thread takes up a small area for its thread state in addition to the space allocated for its stack (stacks normally start small and then grow as necessary).</source>
          <target state="translated">在堆配置文件中包含线程占用的内存。每个线程除了为其堆分配的空间外,还为其线程状态占用一小块区域(堆通常开始时很小,然后根据需要增长)。</target>
        </trans-unit>
        <trans-unit id="bf6b5e91451bcaf207fe546e25dfb945b2ef9008" translate="yes" xml:space="preserve">
          <source>Incoherent</source>
          <target state="translated">Incoherent</target>
        </trans-unit>
        <trans-unit id="b38b4aae2bf24bfd05e072f52c00b63da2993ab0" translate="yes" xml:space="preserve">
          <source>IncoherentInstances</source>
          <target state="translated">IncoherentInstances</target>
        </trans-unit>
        <trans-unit id="c456a08558be1da87f0db1872fa8594cdebf4bc0" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835b6be9a8a369d9816b32613c73aac90a0d27dc" translate="yes" xml:space="preserve">
          <source>Increases the precedence context by one.</source>
          <target state="translated">将优先级上下文增加一个。</target>
        </trans-unit>
        <trans-unit id="9fce6bc4b7e5c5a1ab1bd960ce68b81905da42d1" translate="yes" xml:space="preserve">
          <source>Increasing the allocation area size may or may not give better performance (a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion).</source>
          <target state="translated">增加分配区域的大小可能会或不会带来更好的性能(更大的分配区域意味着更糟糕的缓存行为,但更少的垃圾收集和更少的推广)。</target>
        </trans-unit>
        <trans-unit id="90bbbaecf2c42b5555ebc1a33319be6fd0d0626c" translate="yes" xml:space="preserve">
          <source>Increasing this figure is more likely to result in longer compile times than faster code. The &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is more useful.</source>
          <target state="translated">与更快的代码相比，增加这个数字更有可能导致更长的编译时间。所述&lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt;是更加有用。</target>
        </trans-unit>
        <trans-unit id="4f85c1ee822e61bcfb4fe66d19d113d5f463b45b" translate="yes" xml:space="preserve">
          <source>Incremental array updates</source>
          <target state="translated">阵列增量更新</target>
        </trans-unit>
        <trans-unit id="df1b72108d080551ba84e7f0b92fa55056537617" translate="yes" xml:space="preserve">
          <source>Increments the column number of a source position.</source>
          <target state="translated">增加一个源位置的列号。</target>
        </trans-unit>
        <trans-unit id="e41e0acce642a9a1ccc70291606c4bb9e436f67f" translate="yes" xml:space="preserve">
          <source>Increments the line number of a source position.</source>
          <target state="translated">增加源位置的行数。</target>
        </trans-unit>
        <trans-unit id="3b6b076780f1d62948deeee6a296d893d53b3592" translate="yes" xml:space="preserve">
          <source>Indeed, the bindings can even be recursive.</source>
          <target state="translated">事实上,这些绑定甚至可以是递归的。</target>
        </trans-unit>
        <trans-unit id="96dc8cbd171c88cf2266f42fcde1d0fd90902e1c" translate="yes" xml:space="preserve">
          <source>Indeed, we can even set breakpoints,</source>
          <target state="translated">事实上,我们甚至可以设置断点。</target>
        </trans-unit>
        <trans-unit id="ec8be4828bc680f1764ecad7e8b3a8f6a6c5c173" translate="yes" xml:space="preserve">
          <source>Indexed</source>
          <target state="translated">Indexed</target>
        </trans-unit>
        <trans-unit id="06793fabc8f42b418a1cb6b931583c1a10698618" translate="yes" xml:space="preserve">
          <source>Indexed data families are introduced by a signature, such as</source>
          <target state="translated">索引数据族由一个签名引入,如</target>
        </trans-unit>
        <trans-unit id="35f58c1b9b260f98cfc78bcd3803628ca7e2f859" translate="yes" xml:space="preserve">
          <source>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</source>
          <target state="translated">索引类型族有三种味道:数据族、开放类型同义词族和封闭类型同义词族。它们分别是代数数据类型和类型同义词的索引族变体。数据族的实例可以是数据类型和新类型。</target>
        </trans-unit>
        <trans-unit id="d12b44f71b7203449d4ead8607709958c3027d75" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">索引类型族构成了扩展，以促进类型级别的编程。类型族是关联数据类型的概括&lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt;和关联的类型同义词&lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt;类型族本身在Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]中&lt;/a&gt;进行了描述。类型族实质上提供类型索引的数据类型和类型上的命名函数，这对于泛型编程和高度参数化的库接口以及具有增强的静态信息的接口（如从属类型）很有用。它们也可以被视为功能依赖的替代方案，但是比功能依赖的关系风格提供了更多的类型级编程功能。</target>
        </trans-unit>
        <trans-unit id="c623b2752a83108ab46f6eab2be4ef5e8f114c82" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7316d5d3f19bb830a24f91422d22cdab9dd77e21" translate="yes" xml:space="preserve">
          <source>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</source>
          <target state="translated">索引类型族,或简称类型族,是表示类型集的类型构造器。集合成员是通过向类型族构造函数提供类型参数来表示的,这些参数被称为类型索引。范式参数化类型构造器和族构造器之间的区别很像参数化多态函数和类型类的(特设多态)方法之间的区别。参数化多态函数在所有类型实例上的行为都是一样的,而类方法可以根据类的类型参数来改变其行为。同样,凡型构造器意味着对所有类型实例都有相同的数据表示,但族构造器对不同的类型指数可以有不同的表示类型。</target>
        </trans-unit>
        <trans-unit id="b949d0cdd6e23a0ad23263d4ec380e2896eb8d8b" translate="yes" xml:space="preserve">
          <source>IndexedQueue</source>
          <target state="translated">IndexedQueue</target>
        </trans-unit>
        <trans-unit id="8fa14decb45552b922c2f1e05a96dc53620208d3" translate="yes" xml:space="preserve">
          <source>IndexedTaggedQueue</source>
          <target state="translated">IndexedTaggedQueue</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="e8487b7ebf53e6a4c89fb11a42e40edb17475681" translate="yes" xml:space="preserve">
          <source>Indexing ByteStrings</source>
          <target state="translated">索引字节串</target>
        </trans-unit>
        <trans-unit id="a877b32121d14e603604359d2ca06dd6d1231f86" translate="yes" xml:space="preserve">
          <source>Indexing lists</source>
          <target state="translated">编制索引清单</target>
        </trans-unit>
        <trans-unit id="10dea83b6d35fb66236376830ee8aaca1d2aa47d" translate="yes" xml:space="preserve">
          <source>Indexing streams</source>
          <target state="translated">索引流</target>
        </trans-unit>
        <trans-unit id="9d4cf9835a874b031aa2556ce944d3dfd7d3212c" translate="yes" xml:space="preserve">
          <source>Indexing with predicates</source>
          <target state="translated">用谓词做索引</target>
        </trans-unit>
        <trans-unit id="7bb8fb7fdc165fa4b18dff47b53df0d3155ddd63" translate="yes" xml:space="preserve">
          <source>Indicates a mode in which a file should be locked.</source>
          <target state="translated">表示文件应被锁定的模式。</target>
        </trans-unit>
        <trans-unit id="3355b10b90f7375e78f86318065481808ee2eee6" translate="yes" xml:space="preserve">
          <source>Indicates an &quot;alternate format&quot;. See &lt;code&gt;printf(3)&lt;/code&gt; for the details, which vary by argument spec.</source>
          <target state="translated">指示&amp;ldquo;替代格式&amp;rdquo;。有关详细信息，请参见 &lt;code&gt;printf(3)&lt;/code&gt; ，具体取决于参数规范。</target>
        </trans-unit>
        <trans-unit id="ee701376e3689ff56e8540e626710f8190183f54" translate="yes" xml:space="preserve">
          <source>Indicates that this RunTH is finished, and the next message will be the result of RunTH (a QResult).</source>
          <target state="translated">表示本次RunTH结束,下一条消息将是RunTH的结果(QResult)。</target>
        </trans-unit>
        <trans-unit id="ffebd8440073e88e499e1336894f2e16eae1751e" translate="yes" xml:space="preserve">
          <source>Indirections include the two special directories &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;, as well as any symbolic links (and junction points on Windows). The input path need not point to an existing file or directory. Canonicalization is performed on the longest prefix of the path that points to an existing file or directory. The remaining portion of the path that does not point to an existing file or directory will still be normalized, but case canonicalization and indirection removal are skipped as they are impossible to do on a nonexistent path.</source>
          <target state="translated">间接访问包括两个特殊目录 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 以及任何符号链接（和Windows上的连接点）。输入路径不必指向现有文件或目录。规范化是在指向现有文件或目录的路径的最长前缀上执行的。未指向现有文件或目录的路径的其余部分仍将被规范化，但由于无法在不存在的路径上执行，无法进行大小写规范化和间接删除。</target>
        </trans-unit>
        <trans-unit id="66db8a5a7f44af7446c06e6455194d161c7318dd" translate="yes" xml:space="preserve">
          <source>Individual fields of constructors: &lt;code&gt;K1&lt;/code&gt;</source>
          <target state="translated">构造函数的各个字段： &lt;code&gt;K1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="004823746d749da477fecffe53c215cee2dcb8f7" translate="yes" xml:space="preserve">
          <source>Infer less polymorphic types for local bindings by default.</source>
          <target state="translated">默认为本地绑定推导出较少的多态类型。</target>
        </trans-unit>
        <trans-unit id="a49aa56d23bf8a67723b80736f57bcc1ae0f7ed4" translate="yes" xml:space="preserve">
          <source>InferR</source>
          <target state="translated">InferR</target>
        </trans-unit>
        <trans-unit id="b62fa7fe203f750a1b3935b720b00e4d542210bf" translate="yes" xml:space="preserve">
          <source>Inferring equality from other types</source>
          <target state="translated">从其他类型推断平等</target>
        </trans-unit>
        <trans-unit id="3744a97e602ea3666eb2a1e01050a64e4445a1a1" translate="yes" xml:space="preserve">
          <source>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary type expression, including a partial application of a type constructor, such as &lt;code&gt;Either Int&lt;/code&gt;. In fact, &lt;a href=&quot;#ghci-cmd-:kind&quot;&gt;&lt;code&gt;:kind&lt;/code&gt;&lt;/a&gt; even allows you to write a partial application of a type synonym (usually disallowed), so that this works:</source>
          <target state="translated">推断并打印&amp;ldquo;类型&amp;rdquo;的类型。后者可以是任意类型表达式，包括类型构造函数（例如 &lt;code&gt;Either Int&lt;/code&gt; )的部分应用程序。实际上，&lt;a href=&quot;#ghci-cmd-:kind&quot;&gt; &lt;code&gt;:kind&lt;/code&gt; &lt;/a&gt;甚至允许您编写类型同义词的部分应用程序（通常是不允许的），这样可以工作：</target>
        </trans-unit>
        <trans-unit id="3177c8b6010228311525b74fd82e8bb7622e8e6c" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, but without fiddling with type variables or class constraints. This is useful when you are using &lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; and care about the distinction between specified type variables (available for type application) and inferred type variables (not available). This mode sometimes prints constraints (such as &lt;code&gt;Show Int&lt;/code&gt;) that could readily be solved, but solving these constraints may affect the type variables, so GHC refrains.</source>
          <target state="translated">推断并打印&amp;ldquo;表达式&amp;rdquo;的类型，但不必摆弄类型变量或类约束。当您使用&lt;a href=&quot;glasgow_exts#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;并注意指定的类型变量（适用于类型应用程序）和推断的类型变量（不可用）之间的区别时，这很有用。此模式有时会打印出可以轻松解决的约束（例如 &lt;code&gt;Show Int&lt;/code&gt; ），但是解决这些约束可能会影响类型变量，因此GHC会拒绝使用。</target>
        </trans-unit>
        <trans-unit id="8a06b410b4c6d06c8f15b06ce8d7dbe7ce974ec5" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, defaulting type variables if possible. In this mode, if the inferred type is constrained by any interactive class (&lt;code&gt;Num&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, or &lt;code&gt;Traversable&lt;/code&gt;), the constrained type variable(s) are defaulted according to the rules described under &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt;. This mode is quite useful when the inferred type is quite general (such as for &lt;code&gt;foldr&lt;/code&gt;) and it may be helpful to see a more concrete instantiation.</source>
          <target state="translated">推断并打印&amp;ldquo;表达式&amp;rdquo;的类型，并在可能的情况下默认使用类型变量。在此模式下，如果推断的类型受任何交互式类（ &lt;code&gt;Num&lt;/code&gt; ， &lt;code&gt;Show&lt;/code&gt; ， &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Foldable&lt;/code&gt; 或 &lt;code&gt;Traversable&lt;/code&gt; ）的约束，则约束类型变量将根据&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;下描述的规则默认设置。当推断的类型非常通用时（例如 &lt;code&gt;foldr&lt;/code&gt; ），此模式非常有用，并且可能有助于查看更具体的实例。</target>
        </trans-unit>
        <trans-unit id="9b49ea1e8603da8d3ed4f7b29043ab1b859d18a2" translate="yes" xml:space="preserve">
          <source>Infers and prints the type of ⟨expression⟩, including explicit forall quantifiers for polymorphic types. The type reported is the type that would be inferred for a variable assigned to the expression, but without the monomorphism restriction applied.</source>
          <target state="translated">推断并打印⟨expression⟩的类型,包括多态类型的显式forall量化器。所报告的类型是为赋值给表达式的变量所推断的类型,但没有应用单态限制。</target>
        </trans-unit>
        <trans-unit id="89ab60251bc6707c53f48175ddc8665e44956e1a" translate="yes" xml:space="preserve">
          <source>Infinite ByteStrings</source>
          <target state="translated">无限字节字符串</target>
        </trans-unit>
        <trans-unit id="f1a0caa9cda260897b3d3a8a3366456b3f12604b" translate="yes" xml:space="preserve">
          <source>Infinite lists</source>
          <target state="translated">无限清单</target>
        </trans-unit>
        <trans-unit id="fe77bd8489f76d5d9e8b67c97bcc2fb77aac9380" translate="yes" xml:space="preserve">
          <source>Infix</source>
          <target state="translated">Infix</target>
        </trans-unit>
        <trans-unit id="dc17702bd4456d8936d032b3557ed49fb5376c40" translate="yes" xml:space="preserve">
          <source>InfixL</source>
          <target state="translated">InfixL</target>
        </trans-unit>
        <trans-unit id="20413b58a0ca7cb9b7575983b614a1c19ab4ff77" translate="yes" xml:space="preserve">
          <source>InfixN</source>
          <target state="translated">InfixN</target>
        </trans-unit>
        <trans-unit id="028e6ce7a43f27e4616aed257c32e084ad147516" translate="yes" xml:space="preserve">
          <source>InfixR</source>
          <target state="translated">InfixR</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="83ca07e3694e10dbb5ccf3a65b2e15a2aa71adaa" translate="yes" xml:space="preserve">
          <source>InfoQ</source>
          <target state="translated">InfoQ</target>
        </trans-unit>
        <trans-unit id="ce6a0a5b544415ee768925ccfd3225f374bbf9b6" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;Strict&lt;/code&gt; language extension switches functions, data types, and bindings to be strict by default, allowing optional laziness by adding &lt;code&gt;~&lt;/code&gt; in front of a variable. This essentially reverses the present situation where laziness is default and strictness can be optionally had by adding &lt;code&gt;!&lt;/code&gt; in front of a variable.</source>
          <target state="translated">非正式地， &lt;code&gt;Strict&lt;/code&gt; 语言扩展默认情况下将函数，数据类型和绑定设置为严格，通过在变量前面添加 &lt;code&gt;~&lt;/code&gt; 来允许可选的惰性。这从本质上扭转了默认情况，即懒惰是默认设置，可以通过添加 &lt;code&gt;!&lt;/code&gt; 在变量前面。</target>
        </trans-unit>
        <trans-unit id="b7a8fe8965d2d84c47cc81ac096afe56b49210c8" translate="yes" xml:space="preserve">
          <source>Informally the &lt;code&gt;StrictData&lt;/code&gt; language extension switches data type declarations to be strict by default allowing fields to be lazy by adding a &lt;code&gt;~&lt;/code&gt; in front of the field.</source>
          <target state="translated">非正式地，默认情况下， &lt;code&gt;StrictData&lt;/code&gt; 语言扩展将数据类型声明更改为严格，允许在字段前面添加 &lt;code&gt;~&lt;/code&gt; 以使字段变得懒惰。</target>
        </trans-unit>
        <trans-unit id="c1d79469162855a43f3eaf9e3321d8cf50684dcb" translate="yes" xml:space="preserve">
          <source>Informally, if we have a closed expression</source>
          <target state="translated">非正式地,如果我们有一个封闭的表达式</target>
        </trans-unit>
        <trans-unit id="bc65f2d3fbd1ee9f583dec831481e53abb70fa26" translate="yes" xml:space="preserve">
          <source>Information Preservation</source>
          <target state="translated">信息保存</target>
        </trans-unit>
        <trans-unit id="ccf896e081192f981240670d0e7869acc682d16d" translate="yes" xml:space="preserve">
          <source>Information about a received signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">有关接收到的信号的信息（源自 &lt;code&gt;siginfo_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e730d579902dace90d61c30931b7c39b9b5c188a" translate="yes" xml:space="preserve">
          <source>Information about the characteristics of the host system lucky enough to run your program.</source>
          <target state="translated">关于有幸运行你的程序的主机系统的特性信息。</target>
        </trans-unit>
        <trans-unit id="97818649517ae55c8ef983801726362db33a72b7" translate="yes" xml:space="preserve">
          <source>Information about your computer.</source>
          <target state="translated">关于你的电脑的信息。</target>
        </trans-unit>
        <trans-unit id="7590d8f956e48cf87c1411168c5822d362a8880b" translate="yes" xml:space="preserve">
          <source>Information specific to a particular type of signal (derived from &lt;code&gt;siginfo_t&lt;/code&gt;).</source>
          <target state="translated">特定于特定信号类型的信息（源自 &lt;code&gt;siginfo_t&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="18f99833bb423f35b13b6374e87a08306b82f669" translate="yes" xml:space="preserve">
          <source>Inherit</source>
          <target state="translated">Inherit</target>
        </trans-unit>
        <trans-unit id="10a7ab6418304c704b776a62f13dc7b3f3d8190a" translate="yes" xml:space="preserve">
          <source>Inherit Handle from parent</source>
          <target state="translated">继承父级的手柄</target>
        </trans-unit>
        <trans-unit id="131da1e4b635c2e4aa073e59724b377201ce6033" translate="yes" xml:space="preserve">
          <source>InitialQuote</source>
          <target state="translated">InitialQuote</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="468840c91f4e11363baba6fad080b835e2d90e74" translate="yes" xml:space="preserve">
          <source>Initialize a session of line-oriented user interaction.</source>
          <target state="translated">初始化一个面向行的用户交互会话。</target>
        </trans-unit>
        <trans-unit id="79a1bd4a448da27813a2c98ec5cbdca961401161" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library to the given terminal entry.</source>
          <target state="translated">将terminfo库初始化到给定的终端条目。</target>
        </trans-unit>
        <trans-unit id="f311d39fb45ca161e338979b5589e040c6185db3" translate="yes" xml:space="preserve">
          <source>Initialize the terminfo library, using the &lt;code&gt;TERM&lt;/code&gt; environmental variable. If &lt;code&gt;TERM&lt;/code&gt; is not set, we use the generic, minimal entry &lt;code&gt;dumb&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;TERM&lt;/code&gt; 环境变量初始化terminfo库。如果未设置 &lt;code&gt;TERM&lt;/code&gt; ，则使用通用的最小条目 &lt;code&gt;dumb&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="939c8fcbb3a241e55009e926ba9e9f9f130c11fc" translate="yes" xml:space="preserve">
          <source>Initializes your &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This is optional.</source>
          <target state="translated">初始化您的&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;。这是可选的。</target>
        </trans-unit>
        <trans-unit id="c79f3175dc50a18ee0d2393eff10c5aa2297aaaf" translate="yes" xml:space="preserve">
          <source>Inject a value into the monadic type.</source>
          <target state="translated">在单项型中注入一个值。</target>
        </trans-unit>
        <trans-unit id="7de60f53f52e7d4a1d23489236b528a745ebb923" translate="yes" xml:space="preserve">
          <source>Injective type families are enabled with &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; language extension. This extension implies &lt;code&gt;-XTypeFamilies&lt;/code&gt;.</source>
          <target state="translated">内射类型族通过 &lt;code&gt;-XTypeFamilyDependencies&lt;/code&gt; 语言扩展启用。此扩展暗含 &lt;code&gt;-XTypeFamilies&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3800191eed005fd216c850a6af16770c6198afc5" translate="yes" xml:space="preserve">
          <source>Injectivity annotation</source>
          <target state="translated">注射性注释</target>
        </trans-unit>
        <trans-unit id="20740ccc0ccfa9620154536bb90e4481418a8cde" translate="yes" xml:space="preserve">
          <source>Injectivity annotation is added after type family head and consists of two parts:</source>
          <target state="translated">注射性注解添加在类型族头后,由两部分组成。</target>
        </trans-unit>
        <trans-unit id="5ce4a424681e8e8d4af68879e4d178e19578aaeb" translate="yes" xml:space="preserve">
          <source>InjectivityAnn</source>
          <target state="translated">InjectivityAnn</target>
        </trans-unit>
        <trans-unit id="70da87d6559d7f1134da3bb10fd8c978c0bbd8a1" translate="yes" xml:space="preserve">
          <source>Inlinable</source>
          <target state="translated">Inlinable</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="2cf1a81193ffc568b768198d38637e294820f553" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memcpy&lt;/code&gt; calls if they would generate no more than ⟨n⟩ pseudo-instructions.</source>
          <target state="translated">内联 &lt;code&gt;memcpy&lt;/code&gt; 调用，如果它们生成的伪指令不超过n个。</target>
        </trans-unit>
        <trans-unit id="5455a4bec4fb43a62132e2ac05940c352abd92c6" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;memset&lt;/code&gt; calls if they would generate no more than n pseudo instructions.</source>
          <target state="translated">内联 &lt;code&gt;memset&lt;/code&gt; 调用，如果它们生成的伪指令不超过n个。</target>
        </trans-unit>
        <trans-unit id="f455d62d020e6eddcc787a8c9c55ba1f78236d68" translate="yes" xml:space="preserve">
          <source>Input / Output</source>
          <target state="translated">输入/输出</target>
        </trans-unit>
        <trans-unit id="d395c711b92fc61b74f8c3ff68d9004aa7cb8404" translate="yes" xml:space="preserve">
          <source>Input functions</source>
          <target state="translated">输入功能</target>
        </trans-unit>
        <trans-unit id="5d1b609b532bb8aa117614c8340893874e0d56cc" translate="yes" xml:space="preserve">
          <source>Input string.</source>
          <target state="translated">输入字符串。</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">输入文本。</target>
        </trans-unit>
        <trans-unit id="59f2d1955d5cf0a2b8bee3b6d9a4ed1809c129a3" translate="yes" xml:space="preserve">
          <source>InputLineLimit</source>
          <target state="translated">InputLineLimit</target>
        </trans-unit>
        <trans-unit id="a1aa2989284777e5694122e01199982258b92b20" translate="yes" xml:space="preserve">
          <source>InputQueue</source>
          <target state="translated">InputQueue</target>
        </trans-unit>
        <trans-unit id="642ac7e20b3f8a8dd831942dd30d6fb267ed8a73" translate="yes" xml:space="preserve">
          <source>InputQueueLimit</source>
          <target state="translated">InputQueueLimit</target>
        </trans-unit>
        <trans-unit id="6b355e50341a905ef45c8beb3f4a624b29b98e2e" translate="yes" xml:space="preserve">
          <source>InputState</source>
          <target state="translated">InputState</target>
        </trans-unit>
        <trans-unit id="49141e9c95b68ea8d21c96c95e556fd4e3c8b9a0" translate="yes" xml:space="preserve">
          <source>InputT</source>
          <target state="translated">InputT</target>
        </trans-unit>
        <trans-unit id="e75f30b22d5bec33bb907d8901f7fb77cde5c043" translate="yes" xml:space="preserve">
          <source>InputUnderflow</source>
          <target state="translated">InputUnderflow</target>
        </trans-unit>
        <trans-unit id="d42b1cf617b7ff4fdd4f096b44e1d83b5423c29e" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;error&lt;/code&gt; expressions after bottoming expressions; useful when debugging the compiler.</source>
          <target state="translated">在底部表达式之后插入 &lt;code&gt;error&lt;/code&gt; 表达式；在调试编译器时很有用。</target>
        </trans-unit>
        <trans-unit id="76aa707dc17cbfd229d5de411f19e42614784006" translate="yes" xml:space="preserve">
          <source>Insert a scalar at the given position in a vector.</source>
          <target state="translated">在向量的指定位置插入一个标量。</target>
        </trans-unit>
        <trans-unit id="6ffaeff164e1d6773f39ae8fe9bbe6e6ef734c6a" translate="yes" xml:space="preserve">
          <source>Insertion</source>
          <target state="translated">Insertion</target>
        </trans-unit>
        <trans-unit id="0fb526c25f533482f1770bd05055cb689b6470bc" translate="yes" xml:space="preserve">
          <source>Insertion/removal</source>
          <target state="translated">Insertion/removal</target>
        </trans-unit>
        <trans-unit id="33b33d75acd9bccbdc63b02e3a1b9e48f6928c65" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt;, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de0c91236421ce4d302848e923cf815031f7fda" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;RULE&lt;/code&gt; &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;&amp;rdquo; is treated as a keyword, regardless of any other flag settings. Furthermore, inside a RULE, the language extension &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt; is automatically enabled; see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;RULE&lt;/code&gt; 内部，&amp;ldquo; &lt;code&gt;forall&lt;/code&gt; &amp;rdquo;被视为关键字，而与其他任何标志设置无关。此外，在规则内部，语言扩展名&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;被自动启用。请参见&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法范围类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8052685f0cc727e7c2ebcd111bc548b4add6a4b8" translate="yes" xml:space="preserve">
          <source>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</source>
          <target state="translated">在一个拼接内部,你只能调用导入模块中定义的函数,而不能调用同一模块中其他地方定义的函数。请注意,除了在顶层(在任何其他声明之外),任何地方都不允许声明拼接。</target>
        </trans-unit>
        <trans-unit id="545835b49fc011bc077a5db3657fd4e34d03642a" translate="yes" xml:space="preserve">
          <source>Inspecting</source>
          <target state="translated">Inspecting</target>
        </trans-unit>
        <trans-unit id="2409022af23815ff0491ac232cbdc6c5b9d6cd9e" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">受论文《&lt;em&gt;具有重载和高阶多态性的函数编程》的&lt;/em&gt;启发，马克&amp;middot;P&amp;middot;琼斯（Mark P Jones）（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;），高级函数编程学院，1995年。</target>
        </trans-unit>
        <trans-unit id="70c309e18c61bc57ee637952f14b1c7107d7947a" translate="yes" xml:space="preserve">
          <source>Inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">受论文《&lt;em&gt;具有重载和高阶多态性的功能编程》的&lt;/em&gt;启发，马克&amp;middot;P&amp;middot;琼斯（Mark P Jones）（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&quot;&gt;http://web.cecs.pdx.edu/~mpj/pubs/springschool.html&lt;/a&gt;），《功能编程高级学院》，1995年。</target>
        </trans-unit>
        <trans-unit id="c0aacbdde24ca156566b7d32f70c5cccf57ab9e3" translate="yes" xml:space="preserve">
          <source>Install standard signal handlers for catching ^C, which just throw an exception in the target thread. The current target thread is the thread at the head of the list in the MVar passed to installSignalHandlers.</source>
          <target state="translated">安装用于捕获^C的标准信号处理程序,它只是在目标线程中抛出一个异常。当前的目标线程是传递给installSignalHandlers的MVar中列表头部的线程。</target>
        </trans-unit>
        <trans-unit id="4a69978d36d4f8c81b1e10d8995051dff3da9a47" translate="yes" xml:space="preserve">
          <source>Installer detection can be also turned off globally for the system using the security control panel, but GHC by default generates binaries that don&amp;rsquo;t depend on the user having disabled installer detection.</source>
          <target state="translated">也可以使用安全控制面板为系统全局关闭安装程序检测，但是默认情况下，GHC生成的二进制文件不依赖于已禁用安装程序检测的用户。</target>
        </trans-unit>
        <trans-unit id="7cc8d33f2d97d8e835a27045d7ac58f353fddcec" translate="yes" xml:space="preserve">
          <source>Instance declarations are only merged if their heads are exactly the same, so it is possible to get into a situation where GHC thinks that instances in a signature are overlapping, even if they are implemented in a non-overlapping way. If this is giving you problems give us a shout.</source>
          <target state="translated">实例声明只有在它们的头部完全相同的情况下才会被合并,所以有可能出现这样的情况:GHC认为一个签名中的实例是重叠的,即使它们是以非重叠的方式实现的。如果这给你带来了问题,请给我们打个招呼。</target>
        </trans-unit>
        <trans-unit id="44d84e2252fdea394c95b5f2a46555b5e11e4e23" translate="yes" xml:space="preserve">
          <source>Instance declarations of data and newtype families are very similar to standard data and newtype declarations. The only two differences are that the keyword &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed in type parameters, and type synonyms are allowed as long as they are fully applied and expand to a type that is itself admissible - exactly as this is required for occurrences of type synonyms in class instance parameters. For example, the &lt;code&gt;Either&lt;/code&gt; instance for &lt;code&gt;GMap&lt;/code&gt; is</source>
          <target state="translated">数据和新类型族的实例声明与标准数据和新类型声明非常相似。仅有的两个区别是关键字 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 后跟 &lt;code&gt;instance&lt;/code&gt; ，并且某些或所有类型参数可以是非变量类型，但可能不包含所有类型或类型同义词族。但是，通常在类型参数中允许使用数据族，并且只要它们被完全应用并扩展为本身允许的类型，就允许类型同义词，这与在类实例参数中出现类型同义词所必需的完全相同。例如， &lt;code&gt;GMap&lt;/code&gt; 的 &lt;code&gt;Either&lt;/code&gt; 实例是</target>
        </trans-unit>
        <trans-unit id="83bfa7778c9507fc8976cd01f0cb81fffebfd1e7" translate="yes" xml:space="preserve">
          <source>Instance declarations of type families are very similar to standard type synonym declarations. The only two differences are that the keyword &lt;code&gt;type&lt;/code&gt; is followed by &lt;code&gt;instance&lt;/code&gt; and that some or all of the type arguments can be non-variable types, but may not contain forall types or type synonym families. However, data families are generally allowed, and type synonyms are allowed as long as they are fully applied and expand to a type that is admissible - these are the exact same requirements as for data instances. For example, the &lt;code&gt;[e]&lt;/code&gt; instance for &lt;code&gt;Elem&lt;/code&gt; is</source>
          <target state="translated">类型族的实例声明与标准类型同义词声明非常相似。仅有的两个区别是关键字 &lt;code&gt;type&lt;/code&gt; 后面是 &lt;code&gt;instance&lt;/code&gt; ，并且某些或所有类型参数可以是非变量类型，但可能不包含所有类型或类型同义词族。但是，通常允许使用数据族，并且只要类型同义词完全应用并扩展为可允许的类型，就允许类型同义词-这些要求与数据实例完全相同。例如， &lt;code&gt;Elem&lt;/code&gt; 的 &lt;code&gt;[e]&lt;/code&gt; 实例是</target>
        </trans-unit>
        <trans-unit id="aa54ccd8a5b1e6248e90321db5cede28dbc27c83" translate="yes" xml:space="preserve">
          <source>Instance details</source>
          <target state="translated">实例详情</target>
        </trans-unit>
        <trans-unit id="7e9c3e59e4902eb11a9bc6ca6aecc9cd55844913" translate="yes" xml:space="preserve">
          <source>Instance lookup</source>
          <target state="translated">实例查询</target>
        </trans-unit>
        <trans-unit id="4d286d9c6958cb859af4d3cc5f70112b22b5d71b" translate="yes" xml:space="preserve">
          <source>InstanceDec</source>
          <target state="translated">InstanceDec</target>
        </trans-unit>
        <trans-unit id="fd5054f4d8b7d330705d793f60720bb1539b82c2" translate="yes" xml:space="preserve">
          <source>InstanceSigs</source>
          <target state="translated">InstanceSigs</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="87602c33058f0ebd121afb309504a6eb0e28e43e" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">实例类似于 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，例如给定数据类型</target>
        </trans-unit>
        <trans-unit id="2b4574eaaa234d54582199f6b7f5240c28a0c1c8" translate="yes" xml:space="preserve">
          <source>Instances are similar to &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, e.g. given a data type</source>
          <target state="translated">实例类似于 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，例如给定数据类型</target>
        </trans-unit>
        <trans-unit id="e4b471ed6e4af73beb38b8a58ed041752edf7705" translate="yes" xml:space="preserve">
          <source>Instances details</source>
          <target state="translated">实例详情</target>
        </trans-unit>
        <trans-unit id="d8a851e89f00abbc9380f8fe634c1825d148cc64" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="f456cfda455d78aa8a5bb61b135052b5780b6a6d" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="af23596067e4762785ef1756f8ec64eb7e700ca3" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="d95157f0e1123c9e701efbf70b7e19778274e572" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="c793ddfb9db8e74c5e0c06e1d28e546ad4cb0556" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">可以为组成类型在 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 中的任何用户定义数据类型派生 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例。数据声明中构造函数的声明顺序确定派生 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例中的顺序。的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 数据类型允许单个比较，以确定两个对象的精确顺序。</target>
        </trans-unit>
        <trans-unit id="2b35050349db25cdc61794ff971eb58445ded210" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="54c208a5a34a501f171c263767afb89fcd30fabe" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">可以为任何枚举类型（其构造函数没有字段的类型）派生 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 的实例。假定将 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt; 从fromEnum左右编号。有关更多详细信息，请参见&lt;em&gt;Haskell报告的&lt;/em&gt;第10章。</target>
        </trans-unit>
        <trans-unit id="993368854467462dff364596a665427fa9e766be" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; may be derived for any enumeration type (types whose constructors have no fields). The nullary constructors are assumed to be numbered left-to-right by &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;n-1&lt;/code&gt;. See Chapter 10 of the &lt;em&gt;Haskell Report&lt;/em&gt; for more details.</source>
          <target state="translated">可以为任何枚举类型（其构造函数没有字段的类型）派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 的实例。假定将 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt; 从fromEnum左右编号。有关更多详细信息，请参见&lt;em&gt;Haskell报告的&lt;/em&gt;第10章。</target>
        </trans-unit>
        <trans-unit id="6abd05054200d033151c38fc2023bfb19af24a4f" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; should satisfy the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="81df02f73af490aca4a8ceac4875eec434e49205" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; should satisfy the following law: &lt;code&gt;fail s&lt;/code&gt; should be a left zero for &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律： &lt;code&gt;fail s&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 对于&amp;gt;&amp;gt; =，应为左零。</target>
        </trans-unit>
        <trans-unit id="8400c20b4cb48bf7adc682e14acc2013d85e7139" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; can be derived for any user-defined datatype whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. The declared order of the constructors in the data declaration determines the ordering in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instances. The &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; datatype allows a single comparison to determine the precise ordering of two objects.</source>
          <target state="translated">可以为组成类型在 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 中的任何用户定义数据类型派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例。数据声明中构造函数的声明顺序确定派生 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例中的顺序。的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ordering&quot;&gt;Ordering&lt;/a&gt;&lt;/code&gt; 数据类型允许单个比较，以确定两个对象的精确顺序。</target>
        </trans-unit>
        <trans-unit id="8498083049962c5ddf48a88c7ef6ff394e9c7be7" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Monoid&lt;/code&gt; should also be instances of &lt;code&gt;Semigroup&lt;/code&gt;</source>
          <target state="translated">实例 &lt;code&gt;Monoid&lt;/code&gt; 也应该是实例 &lt;code&gt;Semigroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42499a12ab52b772685bdffe6cd77d34696c747" translate="yes" xml:space="preserve">
          <source>Instances of Binary should satisfy the following property:</source>
          <target state="translated">Binary的实例应满足以下属性。</target>
        </trans-unit>
        <trans-unit id="679c72c6bd3806fccb37008ccaad716ad6e46022" translate="yes" xml:space="preserve">
          <source>Instances of these classes can be derived by GHC with the &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt; extension, and are necessary to be able to define generic instances automatically.</source>
          <target state="translated">这些类的实例可以由GHC带有&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;扩展名派生，并且对于能够自动定义通用实例是必需的。</target>
        </trans-unit>
        <trans-unit id="89fe09bb4f8ebf1e47ee60af8037d77fb33c5ffb" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; is a transformer of monads:</source>
          <target state="translated">实例应满足以下法律，该法律规定 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 是monad的转换器：</target>
        </trans-unit>
        <trans-unit id="1abade2b53df1a1ba01e60f984a3a5290e836572" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following laws:</source>
          <target state="translated">实例应满足以下规律:</target>
        </trans-unit>
        <trans-unit id="9d7bb7203c91aa0d38c7b980a4ce66dfed489cf2" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the following:</source>
          <target state="translated">实例应满足以下条件:</target>
        </trans-unit>
        <trans-unit id="e86269f38cc2b59aa37a9312708da931d8afbda8" translate="yes" xml:space="preserve">
          <source>Instances should satisfy the laws:</source>
          <target state="translated">实例应满足规律。</target>
        </trans-unit>
        <trans-unit id="b012f0abcde18071b0722ff582581b311bd03281" translate="yes" xml:space="preserve">
          <source>Instead of a single form of arrow application (arrow tail) with two translations, the implementation provides two forms &lt;code&gt;-&amp;lt;&lt;/code&gt; (first-order) and &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; (higher-order).</source>
          <target state="translated">该实现提供了两种形式 &lt;code&gt;-&amp;lt;&lt;/code&gt; （一阶）和 &lt;code&gt;-&amp;lt;&amp;lt;&lt;/code&gt; （高阶），而不是带有两种翻译的单一形式的箭头应用程序（箭头尾）。</target>
        </trans-unit>
        <trans-unit id="886e0a6b103c70f084410d0784c49a059007efdd" translate="yes" xml:space="preserve">
          <source>Instead of creating an executable, GHC produces a shared object with this linker flag. Depending on the operating system target, this might be an ELF DSO, a Windows DLL, or a Mac OS dylib. GHC hides the operating system details beneath this uniform flag.</source>
          <target state="translated">GHC不是创建一个可执行文件,而是产生一个带有这个链接器标志的共享对象。根据操作系统的目标,这可能是一个ELF DSO,一个Windows DLL,或者一个Mac OS dylib。GHC将操作系统的细节隐藏在这个统一标志之下。</target>
        </trans-unit>
        <trans-unit id="4bea18059726367b2d2fc3a93789ffe96f83da94" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；当在 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数然后引用 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="43d6bd77abb0145c25600eed500e3ab34605d53a" translate="yes" xml:space="preserve">
          <source>Instead of making a recursive call, we introduce a dummy parameter &lt;code&gt;rec&lt;/code&gt;; when used within &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;, this parameter then refers to &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; argument, hence the recursion is reintroduced.</source>
          <target state="translated">我们没有进行递归调用，而是引入了虚拟参数 &lt;code&gt;rec&lt;/code&gt; ；当在 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 中使用时，此参数然后引用 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 参数，因此重新引入了递归。</target>
        </trans-unit>
        <trans-unit id="e766beefc2f70f81de8c559b30c93536dd165acf" translate="yes" xml:space="preserve">
          <source>Instead of reusing &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;, a separate data family &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; is used to mark occurrences of common unlifted types:</source>
          <target state="translated">代替重新使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; ，使用单独的数据族 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt;&lt;/code&gt; 来标记常见的未提升类型的出现：</target>
        </trans-unit>
        <trans-unit id="28acba53025bd15fee205581c34d0d6b581a22f3" translate="yes" xml:space="preserve">
          <source>Instead, use a &lt;code&gt;case&lt;/code&gt; expression:</source>
          <target state="translated">而是使用 &lt;code&gt;case&lt;/code&gt; 表达式：</target>
        </trans-unit>
        <trans-unit id="904bf5c0f9e80212c91a23a693a49eb67e501513" translate="yes" xml:space="preserve">
          <source>Instead, we can use the &lt;a href=&quot;#ghci-cmd-:main&quot;&gt;&lt;code&gt;:main&lt;/code&gt;&lt;/a&gt; command. This runs whatever &lt;code&gt;main&lt;/code&gt; is in scope, with any arguments being treated the same as command-line arguments, e.g.:</source>
          <target state="translated">相反，我们可以使用&lt;a href=&quot;#ghci-cmd-:main&quot;&gt; &lt;code&gt;:main&lt;/code&gt; &lt;/a&gt;命令。这可以运行范围内的任何 &lt;code&gt;main&lt;/code&gt; ，并且将任何参数与命令行参数一样对待，例如：</target>
        </trans-unit>
        <trans-unit id="ed612bf7d1e1bf9249388e996ba2c817a283fe3f" translate="yes" xml:space="preserve">
          <source>Instead, we provide a function &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt;, which would be used thus:</source>
          <target state="translated">相反，我们提供了一个 &lt;code&gt;&lt;a href=&quot;control-exception#v:catches&quot;&gt;catches&lt;/a&gt;&lt;/code&gt; 函数，可以这样使用：</target>
        </trans-unit>
        <trans-unit id="af0a510e3a346d26bd86b56dc0c175daeafd39a0" translate="yes" xml:space="preserve">
          <source>Instead, you should only catch exactly the exceptions that you really want. In this case, this would likely be more specific than even &quot;any IO exception&quot;; a permissions error would likely also want to be handled differently. Instead, you would probably want something like:</source>
          <target state="translated">相反,你应该只捕捉你真正想要的异常。在这种情况下,这可能会比 &quot;任何IO异常 &quot;更具体;一个权限错误可能也希望以不同的方式处理。相反,你可能会想要这样的东西。</target>
        </trans-unit>
        <trans-unit id="ad2288edd1fb8d5afcaabf253b85250d058d0294" translate="yes" xml:space="preserve">
          <source>Instead, you would have to write &lt;code&gt;foo&lt;/code&gt; as a class operation, thus:</source>
          <target state="translated">相反，您必须将 &lt;code&gt;foo&lt;/code&gt; 作为类操作编写，因此：</target>
        </trans-unit>
        <trans-unit id="dbd230bbda194ea68580a1f846c3ea6c3d1dcbb0" translate="yes" xml:space="preserve">
          <source>Instruct &lt;a href=&quot;ghci#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to use &lt;code&gt;Show&lt;/code&gt; instances where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b938452c4d4e801965219c0e20127da862913e" translate="yes" xml:space="preserve">
          <source>Instruct the linker to produce a position-independent executable.</source>
          <target state="translated">指示链接器生成一个与位置无关的可执行文件。</target>
        </trans-unit>
        <trans-unit id="395f6e3c69e858b418512c3a6a34e4c05014b51b" translate="yes" xml:space="preserve">
          <source>Instructs GHC to consider a value to be especially cheap to inline.</source>
          <target state="translated">指示GHC考虑一个值特别便宜的内联。</target>
        </trans-unit>
        <trans-unit id="bccb53bdffc16a668b6a787212ca241e78854706" translate="yes" xml:space="preserve">
          <source>Instructs GHC to use the platform&amp;rsquo;s native vector registers to pass vector arguments during function calls. As with all vector support, this requires &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示GHC使用平台的本机矢量寄存器在函数调用期间传递矢量参数。与所有向量支持一样，这需要&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fc26ab3c56e988207cb5b87c0a8f1b8c3e39ed8" translate="yes" xml:space="preserve">
          <source>Instructs the GHC driver not to delete any of its temporary files, which it normally keeps in &lt;code&gt;/tmp&lt;/code&gt; (or possibly elsewhere; see &lt;a href=&quot;#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;). Running GHC with &lt;code&gt;-v&lt;/code&gt; will show you what temporary files were generated along the way.</source>
          <target state="translated">指示GHC驱动程序不要删除其通常保存在 &lt;code&gt;/tmp&lt;/code&gt; 中的任何临时文件（或可能保存在其他地方；请参阅&lt;a href=&quot;#temp-files&quot;&gt;重定向临时文件&lt;/a&gt;）。使用 &lt;code&gt;-v&lt;/code&gt; 运行GHC 将向您显示在此过程中生成了哪些临时文件。</target>
        </trans-unit>
        <trans-unit id="eeeb93766512243c6a86ffca2e17fc90c9bf7fbd" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;#11487&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2154c477da950e933ffd834aafe87aa85025a4f4" translate="yes" xml:space="preserve">
          <source>Instructs the LLVM code generator to fill dead STG registers with garbage instead of &lt;code&gt;undef&lt;/code&gt; in calls. This makes it easier to catch subtle code generator and runtime system bugs (e.g. see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue #11487&lt;/a&gt;).</source>
          <target state="translated">指示LLVM代码生成器用垃圾填充无效的STG寄存器，而不是在调用中使用 &lt;code&gt;undef&lt;/code&gt; 。这使得捕获细微的代码生成器和运行时系统错误更加容易（例如，参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11487&quot;&gt;Issue＃11487&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bfa150c9679995565d99e25e8bfa01f17da6a7ba" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to inline a value.</source>
          <target state="translated">指示编译器不要内联一个值。</target>
        </trans-unit>
        <trans-unit id="675da7443910dccefb93ff214351f3b254eb9326" translate="yes" xml:space="preserve">
          <source>Instructs the compiler not to unpack a constructor field.</source>
          <target state="translated">指示编译器不要解包一个构造函数字段。</target>
        </trans-unit>
        <trans-unit id="91e67ac1bd85402d088ab03ef989ae5c792d157d" translate="yes" xml:space="preserve">
          <source>Instructs the compiler to unpack the contents of a constructor field into the constructor itself.</source>
          <target state="translated">指示编译器将构造函数字段的内容解包到构造函数本身。</target>
        </trans-unit>
        <trans-unit id="365865761dffc2759227bec5082fd7cd2a7643d4" translate="yes" xml:space="preserve">
          <source>Instructs the simplifier to emit &lt;code&gt;error&lt;/code&gt; expressions in the continuation of empty case analyses (which should bottom and consequently not return). This is helpful when debugging demand analysis bugs which can sometimes manifest as segmentation faults.</source>
          <target state="translated">指示简化程序在继续进行空的案例分析时发出 &lt;code&gt;error&lt;/code&gt; 表达式（应该从底部开始，因此不返回）。当调试有时可能表现为分段错误的需求分析错误时，这很有用。</target>
        </trans-unit>
        <trans-unit id="40743f84300c6c1b0918774a56963484d75164e4" translate="yes" xml:space="preserve">
          <source>Insufficient resources are available to perform the operation.</source>
          <target state="translated">没有足够的资源来执行这项行动。</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="b0b14c298354a19d3dea6a61e98e487fa2e51bfb" translate="yes" xml:space="preserve">
          <source>Int results</source>
          <target state="translated">Int结果</target>
        </trans-unit>
        <trans-unit id="474e49b09d35d1abae6313b6259476068b2d3bdb" translate="yes" xml:space="preserve">
          <source>Int#</source>
          <target state="translated">Int#</target>
        </trans-unit>
        <trans-unit id="7982e8c08d84551a97dde8c3cc98e03fc2d6082c" translate="yes" xml:space="preserve">
          <source>Int16</source>
          <target state="translated">Int16</target>
        </trans-unit>
        <trans-unit id="89aeb74564c1a3c6fca4d47bfe34fd7d47efe931" translate="yes" xml:space="preserve">
          <source>Int16#</source>
          <target state="translated">Int16#</target>
        </trans-unit>
        <trans-unit id="ea2b1a89854df33ae5484ba3a6d447aba6945b77" translate="yes" xml:space="preserve">
          <source>Int16ElemRep</source>
          <target state="translated">Int16ElemRep</target>
        </trans-unit>
        <trans-unit id="169183d72c87a00c62c1bb70bbe1dfca6290ac59" translate="yes" xml:space="preserve">
          <source>Int16Rep</source>
          <target state="translated">Int16Rep</target>
        </trans-unit>
        <trans-unit id="e2fdc71a811dda1a2d0bb96b4d4e22861e2e4166" translate="yes" xml:space="preserve">
          <source>Int16X16#</source>
          <target state="translated">Int16X16#</target>
        </trans-unit>
        <trans-unit id="89b499eed6d98b58571c4a678cbf7b8a491c01ed" translate="yes" xml:space="preserve">
          <source>Int16X32#</source>
          <target state="translated">Int16X32#</target>
        </trans-unit>
        <trans-unit id="126ed280a67ec0e5c6c0869188f83c20171f65d3" translate="yes" xml:space="preserve">
          <source>Int16X8#</source>
          <target state="translated">Int16X8#</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="6f45983428b6cb7b5a6012b9615122a8dcae1e85" translate="yes" xml:space="preserve">
          <source>Int32#</source>
          <target state="translated">Int32#</target>
        </trans-unit>
        <trans-unit id="03ba764facc01a43ae3957c999e280d34c99b823" translate="yes" xml:space="preserve">
          <source>Int32ElemRep</source>
          <target state="translated">Int32ElemRep</target>
        </trans-unit>
        <trans-unit id="1dfbf78305bea63530a44158509f80087a73c868" translate="yes" xml:space="preserve">
          <source>Int32X16#</source>
          <target state="translated">Int32X16#</target>
        </trans-unit>
        <trans-unit id="6e53f2f4f4529ad29ba52b5509f536c32a89ecff" translate="yes" xml:space="preserve">
          <source>Int32X4#</source>
          <target state="translated">Int32X4#</target>
        </trans-unit>
        <trans-unit id="882e5d71bbe1adc471c1dd253deaed0ba0cf0f2c" translate="yes" xml:space="preserve">
          <source>Int32X8#</source>
          <target state="translated">Int32X8#</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="2e9b900740b9471923d1ee1ad9a28f09fca651d7" translate="yes" xml:space="preserve">
          <source>Int64#</source>
          <target state="translated">Int64#</target>
        </trans-unit>
        <trans-unit id="280ff825353cf945ad0e0cb68c2f00e2c3be2f18" translate="yes" xml:space="preserve">
          <source>Int64ElemRep</source>
          <target state="translated">Int64ElemRep</target>
        </trans-unit>
        <trans-unit id="35a21477cc0dcffc75ded41cca3b2d1f63f3bc54" translate="yes" xml:space="preserve">
          <source>Int64Rep</source>
          <target state="translated">Int64Rep</target>
        </trans-unit>
        <trans-unit id="7dc1816fbc9a76921593b78d139c0aefaa5ed5d4" translate="yes" xml:space="preserve">
          <source>Int64X2#</source>
          <target state="translated">Int64X2#</target>
        </trans-unit>
        <trans-unit id="b5d12f27a2badb0da71c1c025c40a353791c7df3" translate="yes" xml:space="preserve">
          <source>Int64X4#</source>
          <target state="translated">Int64X4#</target>
        </trans-unit>
        <trans-unit id="0126c222589438679d7129f37eaa49a40ef647ad" translate="yes" xml:space="preserve">
          <source>Int64X8#</source>
          <target state="translated">Int64X8#</target>
        </trans-unit>
        <trans-unit id="a96d87d7c8b3dcfbd0b1d669a1f16d6b32c2a364" translate="yes" xml:space="preserve">
          <source>Int8</source>
          <target state="translated">Int8</target>
        </trans-unit>
        <trans-unit id="f23dd6eb83dd2c6d4c26d67bd205664514ef3334" translate="yes" xml:space="preserve">
          <source>Int8#</source>
          <target state="translated">Int8#</target>
        </trans-unit>
        <trans-unit id="6432a5292cbe710c394997d2e832158d7d933219" translate="yes" xml:space="preserve">
          <source>Int8ElemRep</source>
          <target state="translated">Int8ElemRep</target>
        </trans-unit>
        <trans-unit id="eeefd58bf82829401c0268ef8251bdf8b3f24966" translate="yes" xml:space="preserve">
          <source>Int8Rep</source>
          <target state="translated">Int8Rep</target>
        </trans-unit>
        <trans-unit id="bca4f782d0f853ef5278cf2783e82bd4ca0e6793" translate="yes" xml:space="preserve">
          <source>Int8X16#</source>
          <target state="translated">Int8X16#</target>
        </trans-unit>
        <trans-unit id="273d50cf360a4f6d087c88837ee0b4808a7557d2" translate="yes" xml:space="preserve">
          <source>Int8X32#</source>
          <target state="translated">Int8X32#</target>
        </trans-unit>
        <trans-unit id="5ec83732ef2a77c6bd76ba72fb9dccf0fdb8ff21" translate="yes" xml:space="preserve">
          <source>Int8X64#</source>
          <target state="translated">Int8X64#</target>
        </trans-unit>
        <trans-unit id="e09cb14a20b097264eac071df65d1afd98163fbc" translate="yes" xml:space="preserve">
          <source>IntMap</source>
          <target state="translated">IntMap</target>
        </trans-unit>
        <trans-unit id="e63b5240ec2d5f7585915f4d28ddb5efc058620c" translate="yes" xml:space="preserve">
          <source>IntPtr</source>
          <target state="translated">IntPtr</target>
        </trans-unit>
        <trans-unit id="2901d3f7a1db5d58eeaffb4b887831e2d949eb75" translate="yes" xml:space="preserve">
          <source>IntRep</source>
          <target state="translated">IntRep</target>
        </trans-unit>
        <trans-unit id="9e69d47445a71be667d23e5d0ef7d5321b56a177" translate="yes" xml:space="preserve">
          <source>IntSet</source>
          <target state="translated">IntSet</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="320552ac98d7f56a8b5c90eb071442ff5ade6253" translate="yes" xml:space="preserve">
          <source>Integer results</source>
          <target state="translated">整数结果</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="c4c03c5bf82bd9916b53979e703ce58d3667b527" translate="yes" xml:space="preserve">
          <source>Integral numbers, supporting integer division.</source>
          <target state="translated">整数,支持整数除法。</target>
        </trans-unit>
        <trans-unit id="234d47467506fc9f47ee7950fcdb7bb2ae54365b" translate="yes" xml:space="preserve">
          <source>Integral types</source>
          <target state="translated">整体类型</target>
        </trans-unit>
        <trans-unit id="df30aeff3c9f2ae9693e9f1c28c3699de6eac4ed" translate="yes" xml:space="preserve">
          <source>Integral types with lossless conversion to and from pointers</source>
          <target state="translated">积分类型与指针之间的无损转换。</target>
        </trans-unit>
        <trans-unit id="e27829052d0d9df18b05cefeb88ad5a94afbc61c" translate="yes" xml:space="preserve">
          <source>Intended for use with pinned arrays; otherwise very unsafe!</source>
          <target state="translated">适用于带钉的阵列,否则非常不安全!</target>
        </trans-unit>
        <trans-unit id="007b2ebed9a4c28b982956fb6038e4230fef94c2" translate="yes" xml:space="preserve">
          <source>Interactive mode - normally used by just running &lt;code&gt;ghci&lt;/code&gt;; see &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt; for details.</source>
          <target state="translated">交互模式-通常在运行 &lt;code&gt;ghci&lt;/code&gt; 时使用 ; 有关详细信息，请参见&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1a5c0c3d73751b79478f13c6aba7659e97bd850" translate="yes" xml:space="preserve">
          <source>Interactive mode, which is also available as &lt;strong&gt;ghci&lt;/strong&gt;. Interactive mode is described in more detail in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;.</source>
          <target state="translated">交互模式，也可以作为&lt;strong&gt;ghci使用&lt;/strong&gt;。&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCi&lt;/a&gt;中更详细地描述了交互模式。</target>
        </trans-unit>
        <trans-unit id="200ddf5e689f542251354b2292ff7f306c830bcd" translate="yes" xml:space="preserve">
          <source>Interactive sessions</source>
          <target state="translated">互动会议</target>
        </trans-unit>
        <trans-unit id="9b175511971a5226d37c0acfed7f54181e087e72" translate="yes" xml:space="preserve">
          <source>Interchange</source>
          <target state="translated">Interchange</target>
        </trans-unit>
        <trans-unit id="0889e1352d0093dd2c1bd60ccefdbe1787dedf12" translate="yes" xml:space="preserve">
          <source>Intermediate C file produced by the Haskell compiler.</source>
          <target state="translated">由Haskell编译器产生的中间C文件。</target>
        </trans-unit>
        <trans-unit id="0e87fa48ab9403bcfb3ef1be0554d0a70b493987" translate="yes" xml:space="preserve">
          <source>Intermediate result in a processing pipeline.</source>
          <target state="translated">加工管道中的中间结果。</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="82a32977b22d691e4bebb6181d666886678637a3" translate="yes" xml:space="preserve">
          <source>Internal encoding of argv</source>
          <target state="translated">argv的内部编码</target>
        </trans-unit>
        <trans-unit id="25a43e5e4971ff9be08a18b36db8ee9809321bf3" translate="yes" xml:space="preserve">
          <source>Internal function used by the RTS to run sparks.</source>
          <target state="translated">RTS用于运行火花的内部功能。</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">内部职能</target>
        </trans-unit>
        <trans-unit id="f9ce090f6b4e6812a2a33054e170fe0befa25fea" translate="yes" xml:space="preserve">
          <source>Internal implementation</source>
          <target state="translated">内部执行</target>
        </trans-unit>
        <trans-unit id="335c261c9e3240dffccc5e11b7feb9b035c0ffee" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version.</source>
          <target state="translated">内部模块总是会随着版本的变化而变化。</target>
        </trans-unit>
        <trans-unit id="4cd52ec76491f663a1c43928caec2f316b4ca018" translate="yes" xml:space="preserve">
          <source>Internal modules are always subject to change from version to version. The contents of this module are also platform-dependent, hence what is shown in the Hackage documentation may differ from what is actually available on your system.</source>
          <target state="translated">内部模块总是会随着版本的变化而变化。这个模块的内容也是依赖于平台的,因此在Hackage文档中显示的内容可能会与您系统中实际可用的内容有所不同。</target>
        </trans-unit>
        <trans-unit id="0fcdcb0ba8bba814068eb6100072ef47243548c0" translate="yes" xml:space="preserve">
          <source>Internal representation of ShortByteString</source>
          <target state="translated">ShortByteString的内部表示</target>
        </trans-unit>
        <trans-unit id="6f8442c92f2a07632791660fdbe8ed261d183750" translate="yes" xml:space="preserve">
          <source>Internal stuff: support for ByteString FilePaths</source>
          <target state="translated">内部资料:支持ByteString FilePaths。</target>
        </trans-unit>
        <trans-unit id="c06d3b6c05aaeb5431e0abe73a9ea613ced45014" translate="yes" xml:space="preserve">
          <source>Internal to GHC is yet a third equality relation &lt;code&gt;(~#)&lt;/code&gt;. It is heterogeneous (like &lt;code&gt;~~&lt;/code&gt;) and is used only internally. It may appear in error messages and other output only when &lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">GHC的内部仍然是第三个相等关系 &lt;code&gt;(~#)&lt;/code&gt; 。它是异构的（如 &lt;code&gt;~~&lt;/code&gt; ），仅在内部使用。仅当启用&lt;a href=&quot;using#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;时，它才可能出现在错误消息和其他输出中。</target>
        </trans-unit>
        <trans-unit id="2bd330af85b0e5f22d5c9a7160723d4849210dfe" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are buffer-filling functions. They are executed by a &lt;em&gt;driver&lt;/em&gt; that provides them with an actual buffer to fill. Once called with a buffer, a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; fills it and returns a signal to the driver telling it that it is either done, has filled the current buffer, or wants to directly insert a reference to a chunk of memory. In the last two cases, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; also returns a continutation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; that the driver can call to fill the next buffer. Here, we provide the two drivers that satisfy almost all use cases. See &lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;, for information about fine-tuning them.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 是缓冲区填充功能。它们由&lt;em&gt;驱动程序&lt;/em&gt;执行，该&lt;em&gt;驱动程序&lt;/em&gt;为它们提供了要填充的实际缓冲区。一旦使用缓冲区调用， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 就会对其进行填充，并向驱动程序返回信号，告知其已完成，已经填充了当前缓冲区或想要直接插入对内存块的引用。在最后两种情况下， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 还返回一个延续性 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，驱动程序可以调用它来填充下一个缓冲区。在这里，我们提供了满足几乎所有用例的两个驱动程序。有关微调它们的信息，请参见&lt;a href=&quot;data-bytestring-builder-extra&quot;&gt;Data.ByteString.Builder.Extra&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d88cff51e0a932119461c68d8546032600672fb6" translate="yes" xml:space="preserve">
          <source>Internally, a builder constructs a lazy &lt;code&gt;Text&lt;/code&gt; by filling arrays piece by piece. As each buffer is filled, it is 'popped' off, to become a new chunk of the resulting lazy &lt;code&gt;Text&lt;/code&gt;. All this is hidden from the user of the &lt;code&gt;Builder&lt;/code&gt;.</source>
          <target state="translated">在内部，构建器通过逐个填充数组来构造惰性 &lt;code&gt;Text&lt;/code&gt; 。随着每个缓冲区的填充，它会被&amp;ldquo;弹出&amp;rdquo;，成为生成的惰性 &lt;code&gt;Text&lt;/code&gt; 的新块。这一切对 &lt;code&gt;Builder&lt;/code&gt; 的用户都是隐藏的。</target>
        </trans-unit>
        <trans-unit id="12bba6c28355d7983d21c1e6090494085220dbb9" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is represented as an array of &lt;code&gt;Word16&lt;/code&gt; UTF-16 code units. The offset and length fields in the constructor are in these units, &lt;em&gt;not&lt;/em&gt; units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在内部， &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型表示为 &lt;code&gt;Word16&lt;/code&gt; UTF-16代码单元的数组。构造函数中的offset和length字段使用这些单位，&lt;em&gt;而不是&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 的单位。</target>
        </trans-unit>
        <trans-unit id="c0b999b33863c1153156a264b1868a08a53695d3" translate="yes" xml:space="preserve">
          <source>Internally, this function reads a chunk at a time from the lower-level buffering abstraction, and concatenates the chunks into a single string once the entire file has been read.</source>
          <target state="translated">在内部,这个函数每次从低级缓冲抽象中读取一个分块,并在整个文件被读取后将这些分块连成一个字符串。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="a897c5f4e03ea395f7767d7d272cb62520bcf994" translate="yes" xml:space="preserve">
          <source>Internals of the &lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc#v:ExecutionStack&quot;&gt;ExecutionStack&lt;/a&gt;&lt;/code&gt; 模块的内部</target>
        </trans-unit>
        <trans-unit id="8603050a19ff41766967b86a389c3d31e6830c45" translate="yes" xml:space="preserve">
          <source>Interoperability with native code</source>
          <target state="translated">与本地代码的互操作性</target>
        </trans-unit>
        <trans-unit id="c0f7a30128320b71a384a07bf1ad2a57bf643c91" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 解释为1位位域</target>
        </trans-unit>
        <trans-unit id="2344763cc3af5c5ff8f14dc7427762225e47cc74" translate="yes" xml:space="preserve">
          <source>Interpret &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; as 1-bit bit-field</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; 解释为1位位域</target>
        </trans-unit>
        <trans-unit id="8180b611e957caccb58a76268ebb6645c0d090ca" translate="yes" xml:space="preserve">
          <source>Interpreter monad</source>
          <target state="translated">解释者单体</target>
        </trans-unit>
        <trans-unit id="bc1f6afb0744a5bbe6fbb6b0551f3c09aa2d8e3d" translate="yes" xml:space="preserve">
          <source>Interpreting flags as concrete values</source>
          <target state="translated">将标志解释为具体的值</target>
        </trans-unit>
        <trans-unit id="b3238b1b65299f84d2a4787b06c096df0bde1630" translate="yes" xml:space="preserve">
          <source>Interpreting flags as transformations of an options record</source>
          <target state="translated">将标志解释为选项记录的转换。</target>
        </trans-unit>
        <trans-unit id="5ca1eff01a671dfb25491109dc859fa21b0790a2" translate="yes" xml:space="preserve">
          <source>Interprocess communication</source>
          <target state="translated">进程间通信</target>
        </trans-unit>
        <trans-unit id="d5db45498426a18d87491bdc35ea0b2b61778847" translate="yes" xml:space="preserve">
          <source>Interrupt</source>
          <target state="translated">Interrupt</target>
        </trans-unit>
        <trans-unit id="fd306da47657f9f268642aa78227bfb906aca053" translate="yes" xml:space="preserve">
          <source>InterruptOnBreak</source>
          <target state="translated">InterruptOnBreak</target>
        </trans-unit>
        <trans-unit id="50be3afcff74fd9eea61c4dfdd7da275a216bfb6" translate="yes" xml:space="preserve">
          <source>Interrupted</source>
          <target state="translated">Interrupted</target>
        </trans-unit>
        <trans-unit id="36df567b3b522f136606322b1937e0e7e48c4f5c" translate="yes" xml:space="preserve">
          <source>Interruptible</source>
          <target state="translated">Interruptible</target>
        </trans-unit>
        <trans-unit id="d8390d6de28cf8b96b830c119a47584ce55061df" translate="yes" xml:space="preserve">
          <source>Interruptible operations</source>
          <target state="translated">可中断的业务</target>
        </trans-unit>
        <trans-unit id="68c9e301e1801956050651ad57b360275600a452" translate="yes" xml:space="preserve">
          <source>InterruptibleFFI</source>
          <target state="translated">InterruptibleFFI</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="8ee8437c2a66962c8f0907ee26289d77e36aba20" translate="yes" xml:space="preserve">
          <source>Introducing and eliminating &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">引进和消除 &lt;code&gt;ByteString&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="f2ed6db5ae3728afff2fec4a361e39f9464f0d95" translate="yes" xml:space="preserve">
          <source>Introducing quantified constraints offers two main benefits:</source>
          <target state="translated">引入量化的约束条件主要有两个好处。</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9b6edb900949eb2a114c5641991b055536e376d" translate="yes" xml:space="preserve">
          <source>Intruct LLVM to fill dead STG registers with garbage</source>
          <target state="translated">引入LLVM,用垃圾填满死的STG寄存器。</target>
        </trans-unit>
        <trans-unit id="f13f1e646d5fc57caced649f7e0af90a6d1873ef" translate="yes" xml:space="preserve">
          <source>Intuitively it is a bifunctor where both the first and second arguments are covariant.</source>
          <target state="translated">直观地讲,它是一个双叉子,第一个和第二个参数都是共变的。</target>
        </trans-unit>
        <trans-unit id="f11b308cf805ee45457dc6ec7628b5e4afe5bda0" translate="yes" xml:space="preserve">
          <source>Intuitively, a covariant type is &lt;em&gt;produced&lt;/em&gt;, and a contravariant type is &lt;em&gt;consumed&lt;/em&gt;. Most types in Haskell are covariant, but the function type is special in that the lefthand side of a function arrow reverses variance. If a function type &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a covariant position (e.g., &lt;code&gt;CovFun1&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in a contravariant position and &lt;code&gt;b&lt;/code&gt; is in a covariant position. Similarly, if &lt;code&gt;a -&amp;gt; b&lt;/code&gt; appears in a contravariant position (e.g., &lt;code&gt;CovFun2&lt;/code&gt; above), then &lt;code&gt;a&lt;/code&gt; is in &lt;code&gt;a&lt;/code&gt; covariant position and &lt;code&gt;b&lt;/code&gt; is in a contravariant position.</source>
          <target state="translated">直观地，&lt;em&gt;产生&lt;/em&gt;了协变类型，而&lt;em&gt;消耗&lt;/em&gt;了协变类型。 Haskell中的大多数类型都是协变的，但是函数类型的特殊之处在于，函数箭头的左侧反转了方差。如果函数类型 &lt;code&gt;CovFun1&lt;/code&gt; &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 出现在协变位置（例如，上面的CovFun1），则 &lt;code&gt;a&lt;/code&gt; 处于协变位置， &lt;code&gt;b&lt;/code&gt; 处于协变位置。类似地，如果 &lt;code&gt;CovFun2&lt;/code&gt; &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 出现在 &lt;code&gt;a&lt;/code&gt; 协变位置（例如，上面的CovFun2），则 &lt;code&gt;a&lt;/code&gt; 处于一个协变位置，而 &lt;code&gt;b&lt;/code&gt; 处于一个协变位置。</target>
        </trans-unit>
        <trans-unit id="721bd28235527f71feda3a70976332e724e9adeb" translate="yes" xml:space="preserve">
          <source>InvalidArgument</source>
          <target state="translated">InvalidArgument</target>
        </trans-unit>
        <trans-unit id="c34e89295bf2cea238c801b77ea83ba0fd5c3764" translate="yes" xml:space="preserve">
          <source>InvalidSequence</source>
          <target state="translated">InvalidSequence</target>
        </trans-unit>
        <trans-unit id="6e547a33d95e99ec46c6344b0c23479734bb0e2a" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">不变式：使用 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 时，如果值不适用于 &lt;code&gt;&lt;a href=&quot;../integer-gmp-1.0.2.0/ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf37e1cc70f0e61b9e34e40498126af8ea1a4ccd" translate="yes" xml:space="preserve">
          <source>Invariant: &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; are used iff value doesn't fit in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">不变式：使用 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jn-35-&quot;&gt;Jn#&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:Jp-35-&quot;&gt;Jp#&lt;/a&gt;&lt;/code&gt; 时，如果值不适用于 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:S-35-&quot;&gt;S#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bfccb2baadf6166a2829f9676f95fd9d7a60ac3" translate="yes" xml:space="preserve">
          <source>Invariants that all functions must maintain:</source>
          <target state="translated">所有函数都必须保持的不变量。</target>
        </trans-unit>
        <trans-unit id="11b6b45efb71efd3b50f12592ee43024fb8e5262" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Tricky Nom Age&lt;/code&gt; representationally equal to &lt;code&gt;Tricky Nom Int&lt;/code&gt;? No! The former stores a &lt;code&gt;Char&lt;/code&gt; and the latter stores a &lt;code&gt;Bool&lt;/code&gt;. The solution to this is to require all parameters to type variables to have role nominal. Thus, GHC would infer role representational for &lt;code&gt;a&lt;/code&gt; but role nominal for &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">是 &lt;code&gt;Tricky Nom Age&lt;/code&gt; 表象等于 &lt;code&gt;Tricky Nom Int&lt;/code&gt; ？没有！前者存储 &lt;code&gt;Char&lt;/code&gt; ，后者存储 &lt;code&gt;Bool&lt;/code&gt; 。解决方案是要求所有参数键入变量以具有名义角色。因此，GHC会推断 &lt;code&gt;a&lt;/code&gt; 代表角色但 &lt;code&gt;b&lt;/code&gt; 象征角色。</target>
        </trans-unit>
        <trans-unit id="a766705ed66afa23d41d644b867c8c1d8246d785" translate="yes" xml:space="preserve">
          <source>Is a FilePath valid, i.e. could you create a file like it? This function checks for invalid names, and invalid characters, but does not check if length limits are exceeded, as these are typically filesystem dependent.</source>
          <target state="translated">一个FilePath是否有效,也就是说,你可以创建一个类似的文件吗?这个函数检查无效名称和无效字符,但不检查是否超过长度限制,因为这些通常取决于文件系统。</target>
        </trans-unit>
        <trans-unit id="2d4afcc43e797a70db779c9a0014ea77683183f9" translate="yes" xml:space="preserve">
          <source>Is a path relative, or is it fixed to the root?</source>
          <target state="translated">路径是相对的,还是固定在根上?</target>
        </trans-unit>
        <trans-unit id="43af79dad26580cb65546e44c841b83ea361dfc6" translate="yes" xml:space="preserve">
          <source>Is an element a drive</source>
          <target state="translated">元素是一种驱动力吗?</target>
        </trans-unit>
        <trans-unit id="ad55afc8d42967efa9b30f062839411d7d64cecd" translate="yes" xml:space="preserve">
          <source>Is an item either a directory or the last character a path separator?</source>
          <target state="translated">一个项目是目录还是最后一个字符是路径分隔符?</target>
        </trans-unit>
        <trans-unit id="dea849a91828d7c22d9e225f465ea37622f0abe6" translate="yes" xml:space="preserve">
          <source>Is event tracing enabled?</source>
          <target state="translated">是否启用了事件追踪?</target>
        </trans-unit>
        <trans-unit id="4a3d4ce5bba4710d2b59407e172ef6004d960b58" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3d87698463b1e6a36b367f2bd25afa09087482c6" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3bfeac45184637e42717c5ef3d8450bbfdd4d45a" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="translated">通过错误信息的类型和monad类型的构造函数进行参数化。通常将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 用作错误monad的monad类型构造函数，其中错误描述采用字符串形式。在那种情况下以及许多其他常见情况下，生成的monad已被定义为 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。您也可以定义自己的错误类型和/或使用以外的单子类型构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt; 。在这些情况下，您将必须显式定义 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 类的实例。 （如果您使用的是过时的&lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt;或&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;，您可能还必须定义一个 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="371baf4cf811b522632264fa7d84bdafaf787645" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1fd83de1504db40a2c6a9fab6c7f5a6ffe0a914" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9ee65f747219137fd7d52ad82e317c19d9c76e" translate="yes" xml:space="preserve">
          <source>Is parameterized over the type of error information and the monad type constructor. It is common to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; as the monad type constructor for an error monad in which error descriptions take the form of strings. In that case and many other common cases the resulting monad is already defined as an instance of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. You can also define your own error type and/or use a monad type constructor other than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; String&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-either#t:Either&quot;&gt;Either&lt;/a&gt; IOError&lt;/code&gt;. In these cases you will have to explicitly define instances of the &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; class. (If you are using the deprecated &lt;a href=&quot;control-monad-error&quot;&gt;Control.Monad.Error&lt;/a&gt; or &lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-error&quot;&gt;Control.Monad.Trans.Error&lt;/a&gt;, you may also have to define an &lt;code&gt;&lt;a href=&quot;control-monad-error-class#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; instance.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa333bbf2afea384536b00960809179ff42dd9d" translate="yes" xml:space="preserve">
          <source>Is the character a file separator?</source>
          <target state="translated">这个字符是文件分隔符吗?</target>
        </trans-unit>
        <trans-unit id="5f43305893105d5144cecca878b219714e75b65a" translate="yes" xml:space="preserve">
          <source>Is the character an extension character?</source>
          <target state="translated">这个角色是扩展角色吗?</target>
        </trans-unit>
        <trans-unit id="badcfb21de3bbbdff6edcea7831f4297f75e8e47" translate="yes" xml:space="preserve">
          <source>Is the handle connected to a terminal?</source>
          <target state="translated">手柄是否连接到终端?</target>
        </trans-unit>
        <trans-unit id="db53055cb5536987019e96f49887b6f3ccf9ab28" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 返回的实例列表是非空的吗？</target>
        </trans-unit>
        <trans-unit id="0276f66684c522748357fa6f520335cef096d53c" translate="yes" xml:space="preserve">
          <source>Is the list of instances returned by &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; nonempty?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; 返回的实例列表是非空的吗？</target>
        </trans-unit>
        <trans-unit id="ff726b2a6e4e23e49531e7725f31b4ca2f33315a" translate="yes" xml:space="preserve">
          <source>Is this a definition of the infix function &amp;ldquo;&lt;code&gt;(!)&lt;/code&gt;&amp;rdquo;, or of the &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; with a bang pattern? GHC resolves this ambiguity in favour of the latter. If you want to define &lt;code&gt;(!)&lt;/code&gt; with bang-patterns enabled, you have to do so using prefix notation:</source>
          <target state="translated">这是中缀函数&amp;ldquo; &lt;code&gt;(!)&lt;/code&gt; &amp;rdquo;还是带爆炸模式的&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;的定义？GHC解决了这种歧义，支持后者。如果要在启用爆炸模式的情况下定义 &lt;code&gt;(!)&lt;/code&gt; ，则必须使用前缀表示法：</target>
        </trans-unit>
        <trans-unit id="727d9897dcf734181d527a496f77a4e981c855b3" translate="yes" xml:space="preserve">
          <source>Is this an orphan module? Apparently not, because &lt;code&gt;T&lt;/code&gt; is declared in the same module. But suppose class &lt;code&gt;E&lt;/code&gt; had a functional dependency:</source>
          <target state="translated">这是孤立模块吗？显然不是，因为 &lt;code&gt;T&lt;/code&gt; 是在同一模块中声明的。但是，假设类 &lt;code&gt;E&lt;/code&gt; 具有功能依赖性：</target>
        </trans-unit>
        <trans-unit id="015d37bd7153776002ea5dd2e0e58e04be60d1e9" translate="yes" xml:space="preserve">
          <source>Is this program linked against the GHC RTS? (always &amp;ldquo;YES&amp;rdquo;).</source>
          <target state="translated">该计划是否与GHC RTS相关联？（始终为&amp;ldquo;是&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="4ab93a61d74047e9e250aa0b4d353a580e7f3de6" translate="yes" xml:space="preserve">
          <source>Is this time zone just persisting for the summer?</source>
          <target state="translated">这个时区就这样坚持到了夏天吗?</target>
        </trans-unit>
        <trans-unit id="5bdaa14aeb3a57c8d59aa15adeeaf4ca36f447a6" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Gregorian calendar?</source>
          <target state="translated">按照无序的格里高利历,今年是闰年吗?</target>
        </trans-unit>
        <trans-unit id="722098dfb78f933cddee4ba4c9a0bba9c43dafcf" translate="yes" xml:space="preserve">
          <source>Is this year a leap year according to the proleptic Julian calendar?</source>
          <target state="translated">按照无序的朱利安历,今年是闰年吗?</target>
        </trans-unit>
        <trans-unit id="ad4ea982b3c058e21b49b8f110e994dd2768d032" translate="yes" xml:space="preserve">
          <source>Is transformed to,</source>
          <target state="translated">是转化为。</target>
        </trans-unit>
        <trans-unit id="ad0876366a1c77a7a9a0da1b2963828591f6ce29" translate="yes" xml:space="preserve">
          <source>Is used within a monadic computation to begin exception processing.</source>
          <target state="translated">在单项计算中用于开始异常处理。</target>
        </trans-unit>
        <trans-unit id="5534ee618fbad70f11c2e1cb6e9405c6eaa359eb" translate="yes" xml:space="preserve">
          <source>IsChar</source>
          <target state="translated">IsChar</target>
        </trans-unit>
        <trans-unit id="1aa675efc7a7eeb0b92b8ba7fa53d00d3161a009" translate="yes" xml:space="preserve">
          <source>IsList</source>
          <target state="translated">IsList</target>
        </trans-unit>
        <trans-unit id="98e4309bebb71a041dd60cba19bc3de15703f3bf" translate="yes" xml:space="preserve">
          <source>IsStatic</source>
          <target state="translated">IsStatic</target>
        </trans-unit>
        <trans-unit id="d9570a11de28b7264d6886af3296a0aa64b763e0" translate="yes" xml:space="preserve">
          <source>IsString</source>
          <target state="translated">IsString</target>
        </trans-unit>
        <trans-unit id="3676b65080f47af23667593fa2dbe56b53899761" translate="yes" xml:space="preserve">
          <source>Isolate a decoder to operate with a fixed number of bytes, and fail if fewer bytes were consumed, or more bytes were attempted to be consumed. If the given decoder fails, &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; will also fail. Offset from &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; will be relative to the start of &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt;, not the absolute of the input.</source>
          <target state="translated">隔离解码器以固定的字节数进行操作，如果消耗较少的字节或尝试消耗更多的字节，则会失败。如果给定的解码器失败， &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 也会失败。与 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:bytesRead&quot;&gt;bytesRead&lt;/a&gt;&lt;/code&gt; 的偏移量将相对于 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:isolate&quot;&gt;isolate&lt;/a&gt;&lt;/code&gt; 的开始，而不是输入的绝对值。</target>
        </trans-unit>
        <trans-unit id="a4ce542505148e05bcc65af7af6636a88b0f16dd" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is marked as -XTrustworthy but it could instead be marked as -XSafe , a more informative bound. Can be used to detect once a Safe Haskell bound can be improved as dependencies are updated.</source>
          <target state="translated">如果被编译的模块被标记为-XTrustworthy,但它可能被标记为-XSafe,一个更有信息量的绑定,则发出警告。可以用来检测一旦安全的 Haskell 绑定是否可以随着依赖关系的更新而改进。</target>
        </trans-unit>
        <trans-unit id="06aa14b53286f8584e57c40fad1e3a81a67ba0f1" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">如果正在编译的模块被认为是安全的,则发出警告。当使用安全推理时,应该用来检查模块的安全类型。</target>
        </trans-unit>
        <trans-unit id="b6ed530fa6a142afa10ab96b574f393e658ba7bb" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be safe. Should be used to check the safety type of modules when using safe inference. If the module is explicitly marked as safe then no warning will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60682df2a77a2bc855bbc66ec9bbdabac2ee26b2" translate="yes" xml:space="preserve">
          <source>Issue a warning if the module being compiled is regarded to be unsafe. Should be used to check the safety type of modules when using safe inference.</source>
          <target state="translated">如果正在编译的模块被认为是不安全的,则发出警告。当使用安全推理时,应该用来检查模块的安全类型。</target>
        </trans-unit>
        <trans-unit id="7bf53c375a4a624f22b2da10f2c07ed17f8bb47d" translate="yes" xml:space="preserve">
          <source>It appears in the right hand side of a binding that binds at least one used variable that is used</source>
          <target state="translated">它出现在绑定至少一个使用过的变量的右手边,该变量被用于</target>
        </trans-unit>
        <trans-unit id="223c43fdc56fe609487e6e247ea7cd3e66ebb0fa" translate="yes" xml:space="preserve">
          <source>It can also be placed on the right-hand side of a type-level function to provide an error for an invalid case,</source>
          <target state="translated">它也可以放在类型级函数的右侧,为无效的情况提供一个错误。</target>
        </trans-unit>
        <trans-unit id="2ac87d14aeacaa952c867a2404b8511d2d18797a" translate="yes" xml:space="preserve">
          <source>It can also help in a third way: when used with &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;), a strict field can be unpacked or unboxed in the constructor, and one or more levels of indirection may be removed. Unpacking only happens for single-constructor datatypes (&lt;code&gt;Int&lt;/code&gt; is a good candidate, for example).</source>
          <target state="translated">它还可以通过第三种方式提供帮助：与&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 一起使用&lt;/a&gt;（请参阅&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;）时，可以在构造函数中将严格的字段拆包或拆箱，并且可能会进行一个或多个间接级别被删除。仅对单构造函数数据类型进行解压缩（例如， &lt;code&gt;Int&lt;/code&gt; 是一个不错的选择）。</target>
        </trans-unit>
        <trans-unit id="294eac74bb8a1b732eb019ba498538e7dd7de972" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;#13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b37878c8cab374119d560c1fadebca482f149" translate="yes" xml:space="preserve">
          <source>It can be implemented in any way, with any set of superclasses and methods; however, modules depending on an abstract class are not permitted to define instances (as of GHC 8.2, this restriction is not checked, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;Issue #13086&lt;/a&gt;.) These declarations can be implemented by type synonyms of kind &lt;code&gt;Constraint&lt;/code&gt;; this can be useful if you want to parametrize over a constraint in functions. For example, with the &lt;code&gt;ConstraintKinds&lt;/code&gt; extension, this type synonym is a valid implementation of the signature above:</source>
          <target state="translated">它可以用任何方式，任何超类和方法来实现。但是，不允许依赖抽象类的模块定义实例（从GHC 8.2开始，不检查此限制，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13086&quot;&gt;问题＃13086&lt;/a&gt;。）这些声明可以由 &lt;code&gt;Constraint&lt;/code&gt; 类型的同义词实现。如果要对函数约束进行参数化，这将很有用。例如，使用 &lt;code&gt;ConstraintKinds&lt;/code&gt; 扩展，此类型同义词是上述签名的有效实现：</target>
        </trans-unit>
        <trans-unit id="7dc3d61a5c9f85d876d3d8830ea9d78107b392ca" translate="yes" xml:space="preserve">
          <source>It can be used as a base monad to which a series of monad transformers may be applied to construct a composite monad. Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;State s&lt;/code&gt; is an abbreviation for &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它可以用作基础monad，可以将一系列monad变压器应用于该monad以构造复合monad。大多数monad转换器模块包括将转换器应用于 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的特殊情况。例如， &lt;code&gt;State s&lt;/code&gt; 是 &lt;code&gt;StateT s &lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的缩写。</target>
        </trans-unit>
        <trans-unit id="b9852af2f468eb5552aeda23d235265408470558" translate="yes" xml:space="preserve">
          <source>It can be used with functions parameterized by functor or monad classes.</source>
          <target state="translated">它可以与由漏子或单子类参数化的函数一起使用。</target>
        </trans-unit>
        <trans-unit id="9d9e1dcae3fe4aa8145c9784bf5a266157b5617e" translate="yes" xml:space="preserve">
          <source>It can sometime be the case that the name and type of a valid hole fit is not enough to realize what the fit stands for. This flag adds the documentation of the fit to the message, if the documentation is available (and the module from which the function comes was compiled with the &lt;code&gt;-haddock&lt;/code&gt; flag).</source>
          <target state="translated">有时，有效孔配合的名称和类型可能不足以实现该配合的含义。如果提供了适合的文档，则此标志会将其添加到消息中（并且使用 &lt;code&gt;-haddock&lt;/code&gt; 标志编译了函数所在的模块）。</target>
        </trans-unit>
        <trans-unit id="131c8043e25d68f30a2ae760ed59ea45ec37b93c" translate="yes" xml:space="preserve">
          <source>It does seem odd that the existentially-bound type variable &lt;em&gt;must not&lt;/em&gt; be already in scope. Contrast that usually name-bindings merely shadow (make a &amp;lsquo;hole&amp;rsquo;) in a same-named outer variable&amp;rsquo;s scope. But we must have &lt;em&gt;some&lt;/em&gt; way to bring such type variables into scope, else we could not name existentially-bound type variables in subsequent type signatures.</source>
          <target state="translated">确实存在绑定类型变量&lt;em&gt;一定不在&lt;/em&gt;范围内似乎很奇怪。相比之下，通常名称绑定仅在同名外部变量的范围内产生阴影（&amp;ldquo;打洞&amp;rdquo;）。但是我们必须有&lt;em&gt;某种&lt;/em&gt;方法将这些类型变量带入范围，否则我们将无法在后续的类型签名中命名存在绑定的类型变量。</target>
        </trans-unit>
        <trans-unit id="054d4cae547999a330f8c63a5c615eee34554065" translate="yes" xml:space="preserve">
          <source>It enables the &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; to be used, which allows threads to run in parallelism on a multi-processor or multi-core machine. See &lt;a href=&quot;#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">它启用了&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;，从而允许线程在多处理器或多核计算机上并行运行。请参阅&lt;a href=&quot;#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f4b4b81f61547fa1245445f1f306f991f4d6a69" translate="yes" xml:space="preserve">
          <source>It enables the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option to be used, which allows threads to run in parallel on a multiprocessor or multicore machine. See &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">它启用了 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS选项，该选项允许线程在多处理器或多核计算机上并行运行。请参阅&lt;a href=&quot;using-concurrent#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb0ce11093eeb1e05f584fe528a07b4ef4451608" translate="yes" xml:space="preserve">
          <source>It ensures that the result of each application of force to weak head normal form before proceeding.</source>
          <target state="translated">它保证了每次施力的结果都是以弱头正常的形式进行的。</target>
        </trans-unit>
        <trans-unit id="46308fd5d44db11f7f98b515fc84088603b61098" translate="yes" xml:space="preserve">
          <source>It has a lower memory overhead than a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and and does not contribute to heap fragmentation. It can be converted to or from a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; (at the cost of copying the string data). It supports very few other operations.</source>
          <target state="translated">它具有比 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 更低的内存开销，并且不会导致堆碎片。可以将其转换为 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 或从ByteString转换（以复制字符串数据为代价）。它支持很少的其他操作。</target>
        </trans-unit>
        <trans-unit id="5740ea7db69553e93f1f0294393cd715c08f5eba" translate="yes" xml:space="preserve">
          <source>It has been copied into a compact region. The documentation for &lt;code&gt;ghc-compact&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt; describes this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a707e49b0a7765ed34649085bd077081e96884" translate="yes" xml:space="preserve">
          <source>It ignores leap-seconds, so it's not necessarily a fixed amount of clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime = 01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.</source>
          <target state="translated">它忽略了闰秒,所以它不一定是一个固定的时钟时间量。例如,23:00 UTC+2小时的NominalDiffTime=01:00 UTC (+1天),不管是否有闰秒的间隔。</target>
        </trans-unit>
        <trans-unit id="df69e6b9bd468ac0cfd863a00e4fc497cbf20b12" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;Your Responsibility&lt;/em&gt; to make sure that &lt;code&gt;intLookup&lt;/code&gt; really behaves as a specialised version of &lt;code&gt;genericLookup&lt;/code&gt;!!!</source>
          <target state="translated">这是&lt;em&gt;你的责任&lt;/em&gt;，以确保 &lt;code&gt;intLookup&lt;/code&gt; 真正表现为一个专业版本 &lt;code&gt;genericLookup&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="03f782cb2cf883c8957d19560fdc08a6367864fa" translate="yes" xml:space="preserve">
          <source>It is a member of the &lt;em&gt;root set&lt;/em&gt;.</source>
          <target state="translated">它是&lt;em&gt;根集&lt;/em&gt;的成员。</target>
        </trans-unit>
        <trans-unit id="069be4f33a15425dcbdb6739fc39df2c50d79737" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. It is about 40% faster than &lt;em&gt;groupBy (==)&lt;/em&gt;</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。比&lt;em&gt;groupBy（==）&lt;/em&gt;快40％&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="239e0df1f67690a4356b9b61134d42a036c1b5b3" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="bd809bd965bb0b89781400d6bdebc57c3ad18a2c" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="fa42b4f7bbfb75dac932dd4da50a6822c257bf8f" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="f8fd3a20ff645eb541fd385527d7dc74a8034274" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="cb8c3ea4f4fa2bd6894db3bc15c4f14fe3736921" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。如果在第一个列表和第二个列表中均找到该元素，则将使用第一个列表中的元素。</target>
        </trans-unit>
        <trans-unit id="8ca3310f8d4a5261d5f6d4a55bd30a7adbbbfad1" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="c645a3e28d8356b799e0c5997e6e6fa8ae48c19e" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteBy&quot;&gt;deleteBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="cbc3e58e1417baac797e30cd4b1fce7f11aee8c6" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="eab5f4c0e60e1bf6ad7feb752ee004afd76acf82" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。</target>
        </trans-unit>
        <trans-unit id="9f4770e82cc2d4aa8245aef5038e07d136f80baa" translate="yes" xml:space="preserve">
          <source>It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own equality test. If the element is found in both the first and the second list, the element from the first list will be used.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的相等性测试。如果在第一个列表和第二个列表中均找到该元素，则将使用第一个列表中的元素。</target>
        </trans-unit>
        <trans-unit id="b1552e1c07901d09d36b63e9e1d341f53802ec30" translate="yes" xml:space="preserve">
          <source>It is a weak pointer object whose key is reachable.</source>
          <target state="translated">它是一个弱指针对象,其密钥是可以到达的。</target>
        </trans-unit>
        <trans-unit id="0cca6e72767e4d015953dd197d29471c4aebb413" translate="yes" xml:space="preserve">
          <source>It is also possible for library writers to instruct GHC to perform call-pattern specialisation extremely aggressively. This is necessary for some highly optimized libraries, where we may want to specialize regardless of the number of specialisations, or the size of the code. As an example, consider a simplified use-case from the &lt;code&gt;vector&lt;/code&gt; library:</source>
          <target state="translated">库作者也可以指示GHC非常积极地执行呼叫模式专业化。对于某些高度优化的库而言，这是必需的，我们可能希望对其进行专化，而不考虑专长的数量或代码的大小。例如，考虑 &lt;code&gt;vector&lt;/code&gt; 库中的简化用例：</target>
        </trans-unit>
        <trans-unit id="4757c18b6a5b619791dbad2b33b1d97df1650f39" translate="yes" xml:space="preserve">
          <source>It is also possible to break down the heap in one or more of these states by a different criteria, by restricting a profile by biography. For example, to show the portion of the heap in the drag or void state by producer:</source>
          <target state="translated">也可以通过不同的标准来分解堆在这些状态中的一个或多个状态,通过传记来限制配置文件。例如,按生产者来显示堆中处于拖动或无效状态的部分。</target>
        </trans-unit>
        <trans-unit id="22401f25d2546092811a16d0a0193b09e8047866" translate="yes" xml:space="preserve">
          <source>It is also possible to convert a run-time integer or string value to the corresponding type-level literal. Of course, the resulting type literal will be unknown at compile-time, so it is hidden in an existential type. The conversion may be performed using &lt;code&gt;someNatVal&lt;/code&gt; for integers and &lt;code&gt;someSymbolVal&lt;/code&gt; for strings:</source>
          <target state="translated">也可以将运行时整数或字符串值转换为相应的类型级别文字。当然，结果类型文字在编译时将是未知的，因此将其隐藏在存在类型中。可以通过将 &lt;code&gt;someNatVal&lt;/code&gt; 用于整数，将 &lt;code&gt;someSymbolVal&lt;/code&gt; 用于字符串来执行转换：</target>
        </trans-unit>
        <trans-unit id="c3907b0597bf6218c2db4b87b9bbdc3553feab8b" translate="yes" xml:space="preserve">
          <source>It is also possible to define pattern synonyms which behave just like record constructors. The syntax for doing this is as follows:</source>
          <target state="translated">也可以定义模式同义词,它的行为就像记录构造函数一样。这样做的语法如下。</target>
        </trans-unit>
        <trans-unit id="8a1490fcee5f36e805c28234c40d20c616d4e3dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use the special token &lt;code&gt;..&lt;/code&gt; in an export list to mean all currently bundled constructors. For example, we could write:</source>
          <target state="translated">也可以在导出列表中使用特殊标记 &lt;code&gt;..&lt;/code&gt; 来表示当前捆绑的所有构造函数。例如，我们可以这样写：</target>
        </trans-unit>
        <trans-unit id="de2873d8935eeb0018b07c42899bc06b831c7270" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;ghc-base#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c12a49d05c28a1a98429762042c0b4412957c895" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9f8f6803d1f1e2615e394efe93e5fe24a089463" translate="yes" xml:space="preserve">
          <source>It is also useful in higher-order situations, such as &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt;.</source>
          <target state="translated">它在高阶情况下也很有用，例如 &lt;code&gt;&lt;a href=&quot;prelude#v:map&quot;&gt;map&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; 0) xs&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;) fs xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="088801e51db959873ed393905491b4b94a913978" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;qualified&lt;/code&gt; appears in both pre and postpositive positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c19c4298b2ba4d7e7e82d4c54f964b68bea6b25f" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="8d61ccfca667f2076e6f4edcc5438cf1d81d7dfc" translate="yes" xml:space="preserve">
          <source>It is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">它是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="4520db00eca14b103654198af329d717c9454f03" translate="yes" xml:space="preserve">
          <source>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC&amp;rsquo;s implementation). So, GHC takes the easy way out and requires a little help from the user.</source>
          <target state="translated">可以想象将来会放宽此限制，但是（在撰写本文时）尚不清楚围绕此场景的困难是否是理论上的（推断这种依赖性将意味着我们的类型系统没有主体类型）或仅是实际的（鉴于GHC的实现，很难推断出这种依赖性）。因此，GHC可以轻松解决问题，并且需要用户的一点帮助。</target>
        </trans-unit>
        <trans-unit id="132f9840bd91416c5132ad1603ef8603660ce360" translate="yes" xml:space="preserve">
          <source>It is currently implemented as &lt;code&gt;Array ix (TVar e)&lt;/code&gt;, but it may be replaced by a more efficient implementation in the future (the interface will remain the same, however).</source>
          <target state="translated">它当前以 &lt;code&gt;Array ix (TVar e)&lt;/code&gt; ，但是将来可能会被更有效的实现方式替代（但是接口将保持不变）。</target>
        </trans-unit>
        <trans-unit id="abf70f5f9fd5128dce09b9caedea975ee8e442ea" translate="yes" xml:space="preserve">
          <source>It is directly pointed to by a reachable object, other than a weak pointer object.</source>
          <target state="translated">它是由一个可到达的对象直接指向的,而不是一个弱指针对象。</target>
        </trans-unit>
        <trans-unit id="261c2e926d54062731e9f0110ad18886ba23e42b" translate="yes" xml:space="preserve">
          <source>It is enabled with the extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt;, or the &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; pragma. (The same extension enables both &lt;code&gt;mdo&lt;/code&gt;-notation, and the use of &lt;code&gt;rec&lt;/code&gt; blocks inside &lt;code&gt;do&lt;/code&gt; expressions.)</source>
          <target state="translated">它通过扩展名&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;LANGUAGE RecursiveDo&lt;/code&gt; 编译指示启用。（相同的扩展名启用了 &lt;code&gt;mdo&lt;/code&gt; -notation和 &lt;code&gt;do&lt;/code&gt; 内部的 &lt;code&gt;rec&lt;/code&gt; 块的使用。表达式。）</target>
        </trans-unit>
        <trans-unit id="8bea23b077b757046e91df01a7b24e7e8a098f4b" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;data-list#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;data-list#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="ab7ccf86caf74eb72038f169e079e1f3cf957dea" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;ghc-list#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-list#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;ghc-list#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;ghc-list#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="dd5e739fd9707031c252768bfd31d106af48cdf7" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="012b2268f894fbcad616c233a5e6e2ed1c0e90d2" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; when &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;_|_&lt;/code&gt; (&lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt;). &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; is an instance of the more general &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt;, in which &lt;code&gt;n&lt;/code&gt; may be of any integral type.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 不是 &lt;code&gt;_|_&lt;/code&gt; （ &lt;code&gt;splitAt _|_ xs = _|_&lt;/code&gt; ）时 &lt;code&gt;(&lt;a href=&quot;prelude#v:take&quot;&gt;take&lt;/a&gt; n xs, &lt;a href=&quot;prelude#v:drop&quot;&gt;drop&lt;/a&gt; n xs)&lt;/code&gt; 它等效于（&lt;a href=&quot;prelude#v:take&quot;&gt;取&lt;/a&gt; n xs，&lt;a href=&quot;prelude#v:drop&quot;&gt;降低&lt;/a&gt; n xs）。 &lt;code&gt;&lt;a href=&quot;prelude#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; 是更通用的 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;n&lt;/code&gt; 可以是任何整数类型。</target>
        </trans-unit>
        <trans-unit id="9043eb63209967eef7cab64b2197f94ad029bacc" translate="yes" xml:space="preserve">
          <source>It is essential that this operator be polymorphic in &lt;code&gt;e&lt;/code&gt; (representing the environment input to the command and thence to its subcommands) and satisfy the corresponding naturality property</source>
          <target state="translated">该运算符必须在 &lt;code&gt;e&lt;/code&gt; 中是多态的（表示输入到命令的环境以及从其到子命令的环境）并满足相应的自然属性</target>
        </trans-unit>
        <trans-unit id="51c5c05402feec4369eaf30cf0ebc2b274ccd329" translate="yes" xml:space="preserve">
          <source>It is expected that this operation will be replaced in a future revision of Haskell.</source>
          <target state="translated">预计这一操作将在未来的Haskell修订版中被取代。</target>
        </trans-unit>
        <trans-unit id="6893a464868ba3a09460037bfdb1c410934d2838" translate="yes" xml:space="preserve">
          <source>It is exported, or</source>
          <target state="translated">它是出口的,或</target>
        </trans-unit>
        <trans-unit id="6817f51eb52aa0729cda4c69d73c2002e9dd073d" translate="yes" xml:space="preserve">
          <source>It is fine for there to be a &lt;em&gt;potential&lt;/em&gt; of overlap (by including both declarations (A) and (B), say); an error is only reported if a particular constraint matches more than one.</source>
          <target state="translated">&lt;em&gt;可能&lt;/em&gt;存在重叠的&lt;em&gt;可能&lt;/em&gt;（例如，同时声明（A）和（B））；仅当特定约束匹配多个时，才报告错误。</target>
        </trans-unit>
        <trans-unit id="b7b71de1d9414a5e4eec5ca37b04a89216d93297" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;-O*&lt;/code&gt; flags are roughly equivalent to combinations of &lt;code&gt;-f*&lt;/code&gt; flags. For this reason, the effect of the &lt;code&gt;-O*&lt;/code&gt; and &lt;code&gt;-f*&lt;/code&gt; flags is dependent upon the order in which they occur on the command line.</source>
          <target state="translated">重要的是要注意 &lt;code&gt;-O*&lt;/code&gt; 标志大致等同于 &lt;code&gt;-f*&lt;/code&gt; 标志的组合。因此， &lt;code&gt;-O*&lt;/code&gt; 和 &lt;code&gt;-f*&lt;/code&gt; 标志的效果取决于它们在命令行上出现的顺序。</target>
        </trans-unit>
        <trans-unit id="51fa236e42b180f8cc9073b0f8f9aa89b051ee47" translate="yes" xml:space="preserve">
          <source>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a3f52225442e2fb709c4dba2b7ecf38df183fa" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="c74a81a688854157f5042c8facebe05cd92fb4c3" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="9df03deec4ca738a7771974c1c29751abc74608f" translate="yes" xml:space="preserve">
          <source>It is less well known that &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is not type safe. For example:</source>
          <target state="translated">不太了解 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 不是类型安全的。例如：</target>
        </trans-unit>
        <trans-unit id="f4ac0712f3f7039b35bf7281360a3c3a76733fb1" translate="yes" xml:space="preserve">
          <source>It is necessary to iterate the case, rather than using an equational function definition. And the situation is even worse when the matching against &lt;code&gt;t&lt;/code&gt; is buried deep inside another pattern.</source>
          <target state="translated">有必要进行迭代，而不是使用方程式函数定义。当与 &lt;code&gt;t&lt;/code&gt; 匹配时情况甚至更糟被埋在另一个模式的深处。</target>
        </trans-unit>
        <trans-unit id="e8c666bcec97da91a1f2bdb19c53fb008bad01e9" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">它没有比使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 更快</target>
        </trans-unit>
        <trans-unit id="7993dac004679b298df229876946bdc7ec3a34f8" translate="yes" xml:space="preserve">
          <source>It is no faster than using &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它没有比使用 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 更快。</target>
        </trans-unit>
        <trans-unit id="8c92a675066e21869f55b433afde1a20b5c0c7ab" translate="yes" xml:space="preserve">
          <source>It is not always required to provide instances for all the generic representation types, but omitting instances restricts the set of datatypes the functions will work for:</source>
          <target state="translated">并不总是需要为所有的通用表示类型提供实例,但省略实例会限制函数工作的数据类型集。</target>
        </trans-unit>
        <trans-unit id="b38df5c45ca172adcd27d8afb5aa470712828fe4" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a finalizer will eventually run, and no attempt is made to run outstanding finalizers when the program exits. Therefore finalizers should not be relied on to clean up resources - other methods (eg. exception handlers) should be employed, possibly in addition to finalizers.</source>
          <target state="translated">不能保证最终的定标器最终会运行,而且当程序退出时,不会尝试运行未完成的定标器。因此,不应该依靠最终处理程序来清理资源--除了最终处理程序之外,还应该采用其他方法(例如异常处理程序)。</target>
        </trans-unit>
        <trans-unit id="4bbc26cf551bb9424447020a8aa82fbb576e6ad5" translate="yes" xml:space="preserve">
          <source>It is not recommended to move all the contents of your Makefiles into your source files, but in some circumstances, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is the Right Thing. (If you use &lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt;&lt;code&gt;-keep-hc-file&lt;/code&gt;&lt;/a&gt; and have &lt;code&gt;OPTION&lt;/code&gt; flags in your module, the &lt;code&gt;OPTIONS_GHC&lt;/code&gt; will get put into the generated &lt;code&gt;.hc&lt;/code&gt; file).</source>
          <target state="translated">不建议将Makefile的所有内容都移到源文件中，但是在某些情况下， &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译指示是正确的选择。（如果使用&lt;a href=&quot;separate_compilation#ghc-flag--keep-hc-file&quot;&gt; &lt;code&gt;-keep-hc-file&lt;/code&gt; &lt;/a&gt;并在模块中具有 &lt;code&gt;OPTION&lt;/code&gt; 标志，则 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 将放入生成的 &lt;code&gt;.hc&lt;/code&gt; 文件中）。</target>
        </trans-unit>
        <trans-unit id="1ff8d11ee1db2c3d0f7f66202dd22454f1e83d2b" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;
&lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">这是很方便的同时使用这些功能 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;data-function#v:on&quot;&gt;`on`&lt;/a&gt; &lt;a href=&quot;prelude#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f82e0aec46550ca7cd3c7a17a29d279383519fb8" translate="yes" xml:space="preserve">
          <source>It is often convenient to use these functions together with &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt;, for instance &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;
 `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">这是很方便的同时使用这些功能 &lt;code&gt;&lt;a href=&quot;data-function#v:on&quot;&gt;on&lt;/a&gt;&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt; `on` &lt;a href=&quot;data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de502421480842aa548e8ea6ed82138595929709" translate="yes" xml:space="preserve">
          <source>It is often useful to change the interactive options, without having that option apply to loaded modules too. For example</source>
          <target state="translated">通常情况下,改变交互式选项是很有用的,而不需要将该选项也应用到已加载的模块中。例如</target>
        </trans-unit>
        <trans-unit id="eb7c1cce1ac012520a592bb5beee1e418b094930" translate="yes" xml:space="preserve">
          <source>It is perfectly fine to declare new instances of &lt;code&gt;IsList&lt;/code&gt;, so that list notation becomes useful for completely new data types. Here are several example instances:</source>
          <target state="translated">声明 &lt;code&gt;IsList&lt;/code&gt; 的新实例非常好，这样列表符号对于全新的数据类型很有用。这是几个示例实例：</target>
        </trans-unit>
        <trans-unit id="be592f31214a85aaa56dc9374e547bf23d2889f8" translate="yes" xml:space="preserve">
          <source>It is permitted to declare an ordinary algebraic data type using GADT-style syntax. What makes a GADT into a GADT is not the syntax, but rather the presence of data constructors whose result type is not just &lt;code&gt;T a b&lt;/code&gt;.</source>
          <target state="translated">允许使用GADT样式的语法声明普通的代数数据类型。使GADT成为GADT的原因不是语法，而是其结果类型不只是 &lt;code&gt;T a b&lt;/code&gt; 的数据构造函数的存在。</target>
        </trans-unit>
        <trans-unit id="5bbad91689683e0416e9939388b48991ae76e32a" translate="yes" xml:space="preserve">
          <source>It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</source>
          <target state="translated">拼接有可能扩展到一个表达式,该表达式包含的名称在拼接处不在范围内。作为一个例子,考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="bd581700f02bf98080ced3eb7d39eabe45397ae7" translate="yes" xml:space="preserve">
          <source>It is possible for the class defining the associated type to specify a default for associated type instances. So for example, this is OK:</source>
          <target state="translated">定义关联类型的类可以为关联类型实例指定一个默认值。所以,例如,这是确定的。</target>
        </trans-unit>
        <trans-unit id="d7b7fcebbf4b65341979036fb2aefa0d104f093c" translate="yes" xml:space="preserve">
          <source>It is possible that by using packages you might end up with a program that contains two modules with the same name: perhaps you used a package &lt;code&gt;P&lt;/code&gt; that has a &lt;em&gt;hidden&lt;/em&gt; module &lt;code&gt;M&lt;/code&gt;, and there is also a module &lt;code&gt;M&lt;/code&gt; in your program. Or perhaps the dependencies of packages that you used contain some overlapping modules. Perhaps the program even contains multiple versions of a certain package, due to dependencies from other packages.</source>
          <target state="translated">通过使用软件包，您可能最终得到一个包含两个具有相同名称的模块的程序：也许您使用了具有&lt;em&gt;隐藏&lt;/em&gt;模块 &lt;code&gt;M&lt;/code&gt; 的软件包 &lt;code&gt;P&lt;/code&gt; ，并且程序中也存在模块 &lt;code&gt;M&lt;/code&gt; 。或者您使用的软件包的依赖项包含一些重叠的模块。由于其他软件包的依赖性，该程序甚至可能包含某个软件包的多个版本。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e864f624e39a6372353b24e0e6a96c7344cbf60c" translate="yes" xml:space="preserve">
          <source>It is possible to ask the RTS to give some information about itself. To do this, use the &lt;a href=&quot;#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; flag, e.g.</source>
          <target state="translated">可以要求RTS提供一些有关其自身的信息。为此，请使用&lt;a href=&quot;#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;标志，例如</target>
        </trans-unit>
        <trans-unit id="1a5239595846ebef3ee721fce01d7bb0a22f2eef" translate="yes" xml:space="preserve">
          <source>It is possible to catch all exceptions, by using the type &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;control-exception#t:SomeException&quot;&gt;SomeException&lt;/a&gt;&lt;/code&gt; 类型，可以捕获所有异常：</target>
        </trans-unit>
        <trans-unit id="8190060f870795d42df681cc02e5db01b634f194" translate="yes" xml:space="preserve">
          <source>It is possible to chain &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; blocks with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">可以用 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 链接 &lt;code&gt;&lt;a href=&quot;control-monad-cont#t:Cont&quot;&gt;Cont&lt;/a&gt;&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="eb0b7b074cc3fe7c2ea69389e576baaaad67d773" translate="yes" xml:space="preserve">
          <source>It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</source>
          <target state="translated">在类型或类声明中引入的类型变量之间有可能得到复杂的依赖关系。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="e9a188cc02db22c8ef5ca5e67b12a46a7c5847e2" translate="yes" xml:space="preserve">
          <source>It is possible to glean a little information about how well &lt;code&gt;par&lt;/code&gt; is working from the runtime statistics; see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;.</source>
          <target state="translated">可以从运行时统计信息中收集一些有关 &lt;code&gt;par&lt;/code&gt; 工作情况的信息。请参阅&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7f5b4a244218bab17d22682a2382ef6e25e7da7" translate="yes" xml:space="preserve">
          <source>It is possible to load shared libraries generated by GHC in other programs not written in Haskell, so they are suitable for using as plugins. Of course to construct a plugin you will have to use the FFI to export C functions and follow the rules about initialising the RTS. See &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;. In particular you will probably want to export a C function from your shared library to initialise the plugin before any Haskell functions are called.</source>
          <target state="translated">可以在其他不是用Haskell编写的程序中加载GHC生成的共享库，因此它们适合用作插件。当然，要构建插件，您将必须使用FFI导出C函数并遵循有关初始化RTS的规则。请参阅&lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;制作可从外部代码调用的Haskell库&lt;/a&gt;。特别是，您可能需要从共享库中导出C函数，以在调用任何Haskell函数之前初始化插件。</target>
        </trans-unit>
        <trans-unit id="98b901240fe3edf96da3bc8e1456eab7dfeb139d" translate="yes" xml:space="preserve">
          <source>It is possible to see the actual translation by using &lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt;&lt;code&gt;-ddump-ds&lt;/code&gt;&lt;/a&gt;, but be warned, the output is quite verbose.</source>
          <target state="translated">通过使用&lt;a href=&quot;debugging#ghc-flag--ddump-ds&quot;&gt; &lt;code&gt;-ddump-ds&lt;/code&gt; &lt;/a&gt;可以看到实际的翻译，但请注意，输出非常冗长。</target>
        </trans-unit>
        <trans-unit id="97c0a8caadf3b66e62c0079cf1c23a1634b80cf9" translate="yes" xml:space="preserve">
          <source>It is possible to use the debugger to examine function values. When we are at a breakpoint and a function is in scope, the debugger cannot show you the source code for it; however, it is possible to get some information by applying it to some arguments and observing the result.</source>
          <target state="translated">可以使用调试器来检查函数值。当我们处于断点处,一个函数处于范围内时,调试器不能向你展示它的源代码;但是,通过将它应用于一些参数并观察结果,可以得到一些信息。</target>
        </trans-unit>
        <trans-unit id="3cffc26f001e98a5eb62d64eab151b2a804d4ff6" translate="yes" xml:space="preserve">
          <source>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</source>
          <target state="translated">可以写一个数据类型,它在语法上有一个CUSK(根据上面的规则),但实际上需要一些推理。作为一个非常简单的例子,考虑一下</target>
        </trans-unit>
        <trans-unit id="e70bf594eb18f38591c15ebb15e4986a31f41ffd" translate="yes" xml:space="preserve">
          <source>It is reasonably straightforward to set up a &lt;code&gt;Makefile&lt;/code&gt; to use with GHC, assuming you name your source files the same as your modules. Thus:</source>
          <target state="translated">假设您将源文件命名为与模块相同，则设置 &lt;code&gt;Makefile&lt;/code&gt; 与GHC一起使用非常简单。从而：</target>
        </trans-unit>
        <trans-unit id="9b1330a63d6eae27b2d3c5c63940929507d87108" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="translated">建议将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 设置为二进制和 &lt;code&gt;BlockBuffering&lt;/code&gt; 模式。请参见 &lt;code&gt;hSetBinaryMode&lt;/code&gt; 和 &lt;code&gt;hSetBuffering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fec177bf1098e5f20ba1d64f4c20e2f4b753abf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is set to binary and &lt;code&gt;BlockBuffering&lt;/code&gt; mode. See &lt;code&gt;hSetBinaryMode&lt;/code&gt; and &lt;code&gt;hSetBuffering&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7149585b59024bf632f3eb0345377f4daf71cd2" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">强制使用 &lt;code&gt;C&lt;/code&gt; 的每种方法都是安全的。也就是说，缺少的最后一个参数 &lt;code&gt;C&lt;/code&gt; 不是以任何名义角色使用 &lt;code&gt;C&lt;/code&gt; 的方法。（请参阅&lt;a href=&quot;#roles&quot;&gt;角色&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="56ac92f5a75c017852235f851030bbab0ac262ac" translate="yes" xml:space="preserve">
          <source>It is safe to coerce each of the methods of &lt;code&gt;C&lt;/code&gt;. That is, the missing last argument to &lt;code&gt;C&lt;/code&gt; is not used at a nominal role in any of the &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s methods. (See &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6dfdd6aaac4046a07ffe9ab81b043a38fb69661" translate="yes" xml:space="preserve">
          <source>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</source>
          <target state="translated">在对外调用过程中临时修改浮点单位状态是安全的,因为对外调用永远不会被GHC抢先。</target>
        </trans-unit>
        <trans-unit id="96385c6227a3ac0109a62a1c3c011cd583d5d18e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; but slower. Its advantage is that it's compatible with C.</source>
          <target state="translated">它类似于 &lt;code&gt;&lt;a href=&quot;data-array-io#v:IOUArray&quot;&gt;IOUArray&lt;/a&gt;&lt;/code&gt; ,但速度较慢。它的优点是与C兼容。</target>
        </trans-unit>
        <trans-unit id="5091abc2477144e1329f7f3c467074952c1a5362" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to enable additional language extensions when deriving instances via &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. For instance, consider a simple class and instance using &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; syntax:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;派生实例时，有时必须启用其他语言扩展。例如，考虑使用&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;语法的简单类和实例：</target>
        </trans-unit>
        <trans-unit id="5897d1d4639badd735a78c211392c1d9c37495e6" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">有时使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 构造参数名称很有用以确保我们从正确的名称空间进行验证。例如，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="000457152f4555357926c0b8afb516222a4f1c89" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to construct the argument name using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; to ensure that we are reifying from the right namespace. For instance, in this context:</source>
          <target state="translated">有时使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupTypeName&quot;&gt;lookupTypeName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:lookupValueName&quot;&gt;lookupValueName&lt;/a&gt;&lt;/code&gt; 构造自变量名称很有用，以确保我们从正确的名称空间进行验证。例如，在这种情况下：</target>
        </trans-unit>
        <trans-unit id="c301fee90cdf2b960b35ddd17fe3eb6c2529a715" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to use the safer, monadic API of &lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;, if possible, rather than the explicit state management functions of this module.</source>
          <target state="translated">如果可能的话，强烈建议使用&lt;a href=&quot;system-console-haskeline&quot;&gt;System.Console.Haskeline&lt;/a&gt;的更安全的monadic API ，而不要使用此模块的显式状态管理功能。</target>
        </trans-unit>
        <trans-unit id="cc6c22c421bb7df31e233c1d7015be119c4e51ad" translate="yes" xml:space="preserve">
          <source>It is suitable for use as an internal representation for code that needs to keep many short strings in memory, but it &lt;em&gt;should not&lt;/em&gt; be used as an interchange type. That is, it should not generally be used in public APIs. The &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; type is usually more suitable for use in interfaces; it is more flexible and it supports a wide range of operations.</source>
          <target state="translated">它适合用作需要在内存中保留许多短字符串的代码的内部表示形式，但&lt;em&gt;不应&lt;/em&gt;用作交换类型。也就是说，一般不应在公共API中使用它。的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 类型通常更适合于使用的接口; 它更加灵活，并且支持多种操作。</target>
        </trans-unit>
        <trans-unit id="c44526ff00c2ea8f2f54194c36d403aa696761a1" translate="yes" xml:space="preserve">
          <source>It is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">它适用于纯代码。在IO上下文中，使用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc72eb1fbfce672989fe724db9126c46b5b0adc1" translate="yes" xml:space="preserve">
          <source>It is the value or finalizer of a weak pointer object whose key is reachable.</source>
          <target state="translated">它是一个弱指针对象的值或定标,其键是可以到达的。</target>
        </trans-unit>
        <trans-unit id="746eec2fe2a404a8fabc9e6abdf7648c07f8bc2b" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">哪个线程接收此异常是不确定的。GHC当前将其扔给接收 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 的同一线程，但是将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="d492c88d310512060b035b6ec8aa0a90e3614dfd" translate="yes" xml:space="preserve">
          <source>It is undefined which thread receives this exception. GHC currently throws this to the same thread that receives &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt;, but this may change in the future.</source>
          <target state="translated">哪个线程接收此异常是不确定的。GHC当前将其扔给接收 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 的同一线程，但是将来可能会改变。</target>
        </trans-unit>
        <trans-unit id="f6bfd659d3eb587c25350fe75cdd1cec239a674b" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="translated">与GH的其他非 &lt;code&gt;INLINE&lt;/code&gt; 函数一样，如果最终调用 &lt;code&gt;f&lt;/code&gt; 的非内联版本，则GHC可以优化INLINE函数 &lt;code&gt;f&lt;/code&gt; 的定义非常有用。但是我们不想内联 &lt;code&gt;f&lt;/code&gt; 的&lt;em&gt;优化&lt;/em&gt;版本； &lt;code&gt;INLINE&lt;/code&gt; 编译指示的主要原因是要在 &lt;code&gt;f&lt;/code&gt; 的RHS中公开具有重写规则的函数，并且如果这些函数没有被优化，那就不好了。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="257ce5275a4cb48ad40d9428d4ab5e66cc348fde" translate="yes" xml:space="preserve">
          <source>It is useful for GHC to optimise the definition of an INLINE function &lt;code&gt;f&lt;/code&gt; just like any other non-&lt;code&gt;INLINE&lt;/code&gt; function, in case the non-inlined version of &lt;code&gt;f&lt;/code&gt; is ultimately called. But we don&amp;rsquo;t want to inline the &lt;em&gt;optimised&lt;/em&gt; version of &lt;code&gt;f&lt;/code&gt;; a major reason for &lt;code&gt;INLINE&lt;/code&gt; pragmas is to expose functions in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s RHS that have rewrite rules, and it&amp;rsquo;s no good if those functions have been optimised away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf84a0b4bca232dcfe172af6a8fe10d863549539" translate="yes" xml:space="preserve">
          <source>It is useful to think of &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; not as a way to completely prevent asynchronous exceptions, but as a way to switch from asynchronous mode to polling mode. The main difficulty with asynchronous exceptions is that they normally can occur anywhere, but within a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; an asynchronous exception is only raised by operations that are interruptible (or call other interruptible operations). In many cases these operations may themselves raise exceptions, such as I/O errors, so the caller will usually be prepared to handle exceptions arising from the operation anyway. To perform an explicit poll for asynchronous exceptions inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 视为不是完全防止异步异常的方法，而是将其从异步模式切换为轮询模式的方法很有用。异步异常的主要困难是它们通常可以在任何地方发生，但是在 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ，异步异常仅由可中断的操作（或调用其他可中断的操作）引发。在许多情况下，这些操作本身可能会引发异常，例如I / O错误，因此调用者通常会准备好处理由于该操作引起的异常。要对 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 中的异步异常执行显式轮询，请使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:allowInterrupt&quot;&gt;allowInterrupt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="def905b28141bd2cd23fb72f07484744ecd15628" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; required to give the data families themselves return kinds involving &lt;code&gt;TYPE&lt;/code&gt;, such as the &lt;code&gt;FooKey&lt;/code&gt; and &lt;code&gt;BarType&lt;/code&gt; examples above. The extension is only required for &lt;code&gt;newtype instance&lt;/code&gt; declarations, such as &lt;code&gt;FooKeyBoolC&lt;/code&gt; and &lt;code&gt;BarTypeWorkRepC&lt;/code&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c498521723f8812e03fd4118ff670333ce430a6f" translate="yes" xml:space="preserve">
          <source>It is worth noting with shared objects, when each package is built as a single shared object file, since a reference to a shared object costs an extra indirection, intra-package references are cheaper than inter-package references. Of course, this applies to the &lt;code&gt;main&lt;/code&gt; package as well.</source>
          <target state="translated">对于共享对象，值得注意的是，当每个包都构建为单个共享对象文件时，由于对共享对象的引用需要额外的间接调用，因此包内引用比包间引用便宜。当然，这也适用于 &lt;code&gt;main&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="92ef842f60f53412417acbb9c342eaa7f4e2205c" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What&amp;rsquo;s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;, &lt;code&gt;hs_exit()&lt;/code&gt; is normally called before unloading the DLL). So &lt;code&gt;hs_exit()&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; wait until all outstanding foreign calls return before it can return itself.</source>
          <target state="translated">并非总是可能会强行终止Haskell线程：例如，该线程当前可能正在执行外部调用，而我们无法强制外部调用完成。此外，运行时必须假定在最坏的情况下Haskell代码和运行时将要从内存中删除（例如，如果这是&lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Windows DLL&lt;/a&gt;，则通常在卸载DLL之前会调用 &lt;code&gt;hs_exit()&lt;/code&gt; ）。因此 &lt;code&gt;hs_exit()&lt;/code&gt; &lt;em&gt;必须&lt;/em&gt;等待所有未完成的外部调用返回，然后才能返回自身。</target>
        </trans-unit>
        <trans-unit id="3e1f8368ea03e61951e96f7203ef6dd1ba202cc6" translate="yes" xml:space="preserve">
          <source>It may also output a C file which contains additional C functions to be linked into the program, together with a C header that gets included into the C code to which the Haskell module will be compiled (when compiled via C) and into the C file. These two files are created when the &lt;code&gt;#def&lt;/code&gt; construct is used (see below).</source>
          <target state="translated">它还可能会输出一个C文件，其中包含要链接到程序中的其他C函数，以及一个C头文件，该文件头包含在Haskell模块将被编译到的C代码中（通过C编译时）和C文件中。 。这两个文件是在使用 &lt;code&gt;#def&lt;/code&gt; 构造时创建的（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="d09779bd37727473434368e2def3ed2ba44679a3" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;#3605&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8136f6e215348988c49d3102c5c3052b920fc9de" translate="yes" xml:space="preserve">
          <source>It may appear tempting to use &lt;code&gt;DllMain&lt;/code&gt; to call &lt;code&gt;hs_init&lt;/code&gt;/&lt;code&gt;hs_exit&lt;/code&gt;, but this won&amp;rsquo;t work (particularly if you compile with &lt;code&gt;-threaded&lt;/code&gt;). There are severe restrictions on which actions can be performed during &lt;code&gt;DllMain&lt;/code&gt;, and &lt;code&gt;hs_init&lt;/code&gt; violates these restrictions, which can lead to your DLL freezing during startup (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;Issue #3605&lt;/a&gt;).</source>
          <target state="translated">它可能会出现诱人使用 &lt;code&gt;DllMain&lt;/code&gt; 调用 &lt;code&gt;hs_init&lt;/code&gt; / &lt;code&gt;hs_exit&lt;/code&gt; ，但这是不行的（特别是如果你有编译 &lt;code&gt;-threaded&lt;/code&gt; ）。在 &lt;code&gt;DllMain&lt;/code&gt; 期间可以执行哪些操作有严格的限制，并且 &lt;code&gt;hs_init&lt;/code&gt; 违反了这些限制，这可能导致您的DLL在启动过程中冻结（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/3605&quot;&gt;问题＃3605&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="863ecc94447ccc2697e7cef0c45280ea8b50466a" translate="yes" xml:space="preserve">
          <source>It may be useful to note that supposing</source>
          <target state="translated">可能需要指出的是,假设</target>
        </trans-unit>
        <trans-unit id="32c8a688305684e8a6eed99f28e0bf7debe34172" translate="yes" xml:space="preserve">
          <source>It might seem that &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; do similar things: you can use both to bring a module into scope. However, there is a very important difference. GHCi is concerned with two sets of modules:</source>
          <target state="translated">似乎&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;import&lt;/code&gt; 和&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 会&lt;/a&gt;做类似的事情：您可以同时使用两者将模块引入作用域。但是，有一个非常重要的区别。GHCi与两套模块有关：</target>
        </trans-unit>
        <trans-unit id="8e2a509fc1a6cc8bacc29eac66f8d2b04611ec55" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;lsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="translated">必须是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 具有相同的种类。还要注意， &lt;code&gt;b&lt;/code&gt; 以 &lt;code&gt;c&lt;/code&gt; 的类型隐式声明。因此，根据我们的一般原则， &lt;code&gt;b&lt;/code&gt; 必须&lt;em&gt;在&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。但是， &lt;code&gt;b&lt;/code&gt; &lt;em&gt;取决于&lt;/em&gt; &lt;code&gt;k&lt;/code&gt; 。因此，我们以适当的错误消息拒绝 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d71a3e4924a3c6c7be2ff4e99d0b3ace79cfc698" translate="yes" xml:space="preserve">
          <source>It must be that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same kind. Note also that &lt;code&gt;b&lt;/code&gt; is implicitly declared in &lt;code&gt;c&lt;/code&gt;&amp;rsquo;s kind. Thus, according to our general principle, &lt;code&gt;b&lt;/code&gt; must come &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. However, &lt;code&gt;b&lt;/code&gt;&lt;em&gt;depends on&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;. We thus reject &lt;code&gt;T2&lt;/code&gt; with a suitable error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6086959b33661c7e9581d7038f036b9687ffb684" translate="yes" xml:space="preserve">
          <source>It returns the number of bytes actually read. This may be zero if EOF was reached before any data was read (or if &lt;code&gt;count&lt;/code&gt; is zero).</source>
          <target state="translated">它返回实际读取的字节数。如果在读取任何数据之前已达到EOF（或 &lt;code&gt;count&lt;/code&gt; 为零），则该值为零。</target>
        </trans-unit>
        <trans-unit id="ad092a31e7b069ad5452e1dfd822db5e1ae8fc9d" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211c65f9fdb230b192954d5e3e492b544e937b6c" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5294a2ca52cc071e8a324a9f8f6ff0a8cae15e2b" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2289a3219a1ed755ecc57cda3383343eb8709ef1" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b435c38ec10dc76b668c9ec854526a598ebffc36" translate="yes" xml:space="preserve">
          <source>It serves to keep the internal states of different invocations of &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; separate from each other and from invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它有助于保持不同调用的内部状态 &lt;code&gt;&lt;a href=&quot;ghc-st#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 彼此分开并从调用 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:stToIO&quot;&gt;stToIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29550fa0ca4c9e4aac212d854a9fc9caacdfa683" translate="yes" xml:space="preserve">
          <source>It turns out that such recursive bindings do indeed make sense for a variety of monads, but not all. In particular, recursion in this sense requires a fixed-point operator for the underlying monad, captured by the &lt;code&gt;mfix&lt;/code&gt; method of the &lt;code&gt;MonadFix&lt;/code&gt; class, defined in &lt;code&gt;Control.Monad.Fix&lt;/code&gt; as follows:</source>
          <target state="translated">事实证明，这样的递归绑定确实适用于各种monad，但不是全部。特别是，从这种意义上讲，递归需要底层 &lt;code&gt;mfix&lt;/code&gt; 的定点运算符，该常量由 &lt;code&gt;MonadFix&lt;/code&gt; 类的mfix方法捕获，该类在 &lt;code&gt;Control.Monad.Fix&lt;/code&gt; 中定义如下：</target>
        </trans-unit>
        <trans-unit id="dc2967b7223e4a80cc2b7ede4a86ad6f728237bf" translate="yes" xml:space="preserve">
          <source>It was allocated by &lt;code&gt;newPinnedByteArray#&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5052bd2b0b2688526179e347a8f93097a86fbaf" translate="yes" xml:space="preserve">
          <source>It will create &lt;code&gt;.ghci-history&lt;/code&gt; in current folder where GHCi is launched.</source>
          <target state="translated">它将在启动GHCi的当前文件夹中创建 &lt;code&gt;.ghci-history&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e89d7af8e2aa6670470982a682725f5658cf083d" translate="yes" xml:space="preserve">
          <source>It will then pass the individual entries and pairs of entries to &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, or &lt;code&gt;f&lt;/code&gt; as appropriate:</source>
          <target state="translated">然后，它将适当地将各个条目和成对的条目传递给 &lt;code&gt;g1&lt;/code&gt; ， &lt;code&gt;g2&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1540cae372d4d44e85661059bc790134f5ab7b8e" translate="yes" xml:space="preserve">
          <source>It would be better for GHCi to record what the default settings in each module are, and use those of the &amp;lsquo;current&amp;rsquo; module (whatever that is).</source>
          <target state="translated">对于GHCi，最好记录每个模块中的默认设置，并使用&amp;ldquo;当前&amp;rdquo;模块（无论是哪个）的默认设置。</target>
        </trans-unit>
        <trans-unit id="7f8111ac56899714c85e5abca35105627760e1bf" translate="yes" xml:space="preserve">
          <source>It would be quite sensible to &lt;em&gt;compile&lt;/em&gt; on a fast machine using remotely-mounted disks; then &lt;em&gt;link&lt;/em&gt; on a slow machine that had your disks directly mounted.</source>
          <target state="translated">使用远程安装的磁盘在快速的计算机上进行&lt;em&gt;编译&lt;/em&gt;是非常明智的。然后&lt;em&gt;链接&lt;/em&gt;到直接安装了磁盘的慢速计算机上。</target>
        </trans-unit>
        <trans-unit id="763a82435cb1c586af5397dec827eab8a6fea09e" translate="yes" xml:space="preserve">
          <source>It would be undesirable if &lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; were to apply to loaded modules too: that might cause a compilation error, but more commonly it will cause extra recompilation, because GHC will think that it needs to recompile the module because the flags have changed.</source>
          <target state="translated">如果&lt;a href=&quot;glasgow_exts#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;也要应用于加载的模块，那将是不希望的：这可能会导致编译错误，但更常见的是，它将导致额外的重新编译，因为GHC认为由于标志已更改，因此需要重新编译模块。</target>
        </trans-unit>
        <trans-unit id="738c3efaf58c34fc713cd68ed8f30d5430283ea5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s all the better if a function is strict in a single-constructor type (a type with only one data-constructor; for example, tuples are single-constructor types).</source>
          <target state="translated">如果函数严格限制为单构造函数类型（一种只有一个数据构造函数的类型；例如，元组是单构造函数类型），那就更好了。</target>
        </trans-unit>
        <trans-unit id="7aca502a5780a7008e4ab06793361208292555d4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to have mutually recursive bindings, using the new &lt;code&gt;rec&lt;/code&gt; keyword, as in the following example:</source>
          <target state="translated">可以使用新的 &lt;code&gt;rec&lt;/code&gt; 关键字进行相互递归绑定，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="923f83a378500c5bf707083388bd8a5d2d3dc878" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ok to say &lt;code&gt;a==b&lt;/code&gt; or &lt;code&gt;p==q&lt;/code&gt;, but &lt;code&gt;a==q&lt;/code&gt; is wrong because it equates the two distinct types arising from the two &lt;code&gt;Baz1&lt;/code&gt; constructors.</source>
          <target state="translated">可以肯定地说 &lt;code&gt;a==b&lt;/code&gt; 或 &lt;code&gt;p==q&lt;/code&gt; ，但是 &lt;code&gt;a==q&lt;/code&gt; 是错误的，因为它等同于两个 &lt;code&gt;Baz1&lt;/code&gt; 构造函数产生的两种不同类型。</target>
        </trans-unit>
        <trans-unit id="f7c6fdc0025c696839bbcb4d3a4afbd97412dcd6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s ugly and slow.</source>
          <target state="translated">丑陋而缓慢。</target>
        </trans-unit>
        <trans-unit id="514128120e37ddc76a0f201865baee5082dd51ad" translate="yes" xml:space="preserve">
          <source>It's recommended to avoid calling &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; for small integers as this function would currently convert those to big integers in msbf to call &lt;code&gt;mpz_export()&lt;/code&gt;.</source>
          <target state="translated">建议避免为小整数调用 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; ，因为此函数当前会将它们转换为msbf中的大整数，以调用 &lt;code&gt;mpz_export()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cee3c6301483587eda64e5ab687af2ed85576f1" translate="yes" xml:space="preserve">
          <source>It's worth noting that the size of the result may be smaller if, for some &lt;code&gt;(x,y)&lt;/code&gt;, &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt;</source>
          <target state="translated">值得注意的是，如果对于某些 &lt;code&gt;(x,y)&lt;/code&gt; ， &lt;code&gt;x /= y &amp;amp;&amp;amp; f x == f y&lt;/code&gt; ，结果的大小可能会更小</target>
        </trans-unit>
        <trans-unit id="ee6ff3dfa9bf63053b4c7f482ac4fa5228abd4d4" translate="yes" xml:space="preserve">
          <source>Item (IsList)</source>
          <target state="translated">项目(IsList)</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="912a927d3c272044f83f97a4a9348c2b0b737b5e" translate="yes" xml:space="preserve">
          <source>Iterative construction</source>
          <target state="translated">迭代结构</target>
        </trans-unit>
        <trans-unit id="15efe73a427c5593245c3e378d2d1f213eb9ce90" translate="yes" xml:space="preserve">
          <source>Ix</source>
          <target state="translated">Ix</target>
        </trans-unit>
        <trans-unit id="c00d287ecb04edccb5fea26b5b72064393528f73" translate="yes" xml:space="preserve">
          <source>J. Nievergelt and E.M. Reingold, &quot;&lt;em&gt;Binary search trees of bounded balance&lt;/em&gt;&quot;, SIAM journal of computing 2(1), March 1973.</source>
          <target state="translated">J. Nievergelt和EM Reingold，&amp;ldquo; &lt;em&gt;有限平衡的二叉搜索树&lt;/em&gt; &amp;rdquo;，SIAM计算杂志2（1），1973年3月。</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="13f21e57d0b030c88aa84181b98abab96e4c801a" translate="yes" xml:space="preserve">
          <source>JavaScriptFFI</source>
          <target state="translated">JavaScriptFFI</target>
        </trans-unit>
        <trans-unit id="35f6feec54354858f697f87aaa0e0984f56e1720" translate="yes" xml:space="preserve">
          <source>Johan Tibell &amp;lt;johan.tibell@gmail.com&amp;gt;</source>
          <target state="translated">约翰&amp;middot;蒂贝尔（Johan Tibell）&amp;lt;johan.tibell@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="136e9e756d575af36e49778c9cc45e9f8a0f90f2" translate="yes" xml:space="preserve">
          <source>Join a drive and the rest of the path.</source>
          <target state="translated">加入一个驱动器和其余的路径。</target>
        </trans-unit>
        <trans-unit id="81e4e655a28bbcb077ce4558a222bf0f0a8cba3c" translate="yes" xml:space="preserve">
          <source>Join path elements back together.</source>
          <target state="translated">将路径元素重新连接在一起。</target>
        </trans-unit>
        <trans-unit id="382ff1702ad460b913c77bbc040227d10fae8bb9" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;lsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="translated">Jose Pedro Magalhaes，Atze Dijkstra，Johan Jeuring和Andres Loeh。&lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;Haskell的通用派生机制&lt;/a&gt;。第三届ACM Haskell关于Haskell的座谈会论文集（Haskell'2010），第37-48页，ACM，2010年。</target>
        </trans-unit>
        <trans-unit id="8cce6d3a7b7f612b30abbeb5c7bc5be263acd7cb" translate="yes" xml:space="preserve">
          <source>Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh. &lt;a href=&quot;http://dreixel.net/research/pdf/gdmh.pdf&quot;&gt;A generic deriving mechanism for Haskell&lt;/a&gt;. Proceedings of the third ACM Haskell symposium on Haskell (Haskell&amp;rsquo;2010), pp. 37-48, ACM, 2010.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9361b1c736dd39f64c18be1fbaf85ce313be120e" translate="yes" xml:space="preserve">
          <source>Jules Hedges. &quot;Monad transformers for backtracking search&quot;. In &lt;em&gt;Proceedings of MSFP 2014&lt;/em&gt;. &lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</source>
          <target state="translated">朱尔斯&amp;middot;树篱。&amp;ldquo;用于回溯搜索的Monad变压器&amp;rdquo;。在&lt;em&gt;MSFP 2014论文集中&lt;/em&gt;。&lt;a href=&quot;https://arxiv.org/abs/1406.2058&quot;&gt;https://arxiv.org/abs/1406.2058&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e1532d85b8e7a783cd0eeb4f032f73947230558" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 一样，但不要在每个元素后添加斜杠。</target>
        </trans-unit>
        <trans-unit id="e1b8cd9be8a4a56d3e279168c48e322c5a8f7d5f" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt;, but don't add the trailing slashes to each element.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:splitPath&quot;&gt;splitPath&lt;/a&gt;&lt;/code&gt; 一样，但不要在每个元素后添加斜杠。</target>
        </trans-unit>
        <trans-unit id="bf4d570e4ce8e1639edd6b13c9e338ab1cfd25c6" translate="yes" xml:space="preserve">
          <source>Just as compiling &lt;code&gt;A.hs&lt;/code&gt; produces an interface file &lt;code&gt;A.hi&lt;/code&gt;, and an object file &lt;code&gt;A.o&lt;/code&gt;, so compiling &lt;code&gt;A.hs-boot&lt;/code&gt; produces an interface file &lt;code&gt;A.hi-boot&lt;/code&gt;, and a pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt;:</source>
          <target state="translated">就像编译 &lt;code&gt;A.hs&lt;/code&gt; 会生成一个接口文件 &lt;code&gt;A.hi&lt;/code&gt; 和一个目标文件 &lt;code&gt;A.o&lt;/code&gt; ，编译 &lt;code&gt;A.hs-boot&lt;/code&gt; 也会生成一个接口文件 &lt;code&gt;A.hi-boot&lt;/code&gt; 和一个伪目标文件 &lt;code&gt;A.o-boot&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a7ab736e2bc63d2763e588e9ee6e30408ceb5d71" translate="yes" xml:space="preserve">
          <source>Just as in the case of Template Haskell (&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</source>
          <target state="translated">就像Template Haskell（&lt;a href=&quot;#th-syntax&quot;&gt;Syntax&lt;/a&gt;）一样，如果将引号放在第二个字符是引号的数据构造函数之前，GHC也会感到困惑。在这种情况下，只需在促销报价和数据构造函数之间放置一个空格：</target>
        </trans-unit>
        <trans-unit id="5b2209ab2f057867c4513a2da5e88701a39853ef" translate="yes" xml:space="preserve">
          <source>Just as in type inference, kind inference for recursive types can only use &lt;em&gt;monomorphic&lt;/em&gt; recursion. Consider this (contrived) example:</source>
          <target state="translated">就像类型推断一样，递归类型的种类推断只能使用&lt;em&gt;单态&lt;/em&gt;递归。考虑以下（人为）示例：</target>
        </trans-unit>
        <trans-unit id="960a74070ce7ace8facd72bd4167a0b45f8388db" translate="yes" xml:space="preserve">
          <source>Just as you wouldn&amp;rsquo;t define a &lt;code&gt;Monad&lt;/code&gt; instance using the do-notation, you shouldn&amp;rsquo;t define &lt;code&gt;Functor&lt;/code&gt; or &lt;code&gt;Applicative&lt;/code&gt; instance using do-notation (when using &lt;code&gt;ApplicativeDo&lt;/code&gt;) either. The correct way to define these instances in terms of &lt;code&gt;Monad&lt;/code&gt; is to use the &lt;code&gt;Monad&lt;/code&gt; operations directly, e.g.</source>
          <target state="translated">就像您不会使用do-notation 定义 &lt;code&gt;Monad&lt;/code&gt; 实例一样，您也不应该使用do-notation 定义 &lt;code&gt;Functor&lt;/code&gt; 或 &lt;code&gt;Applicative&lt;/code&gt; 实例（使用 &lt;code&gt;ApplicativeDo&lt;/code&gt; 时）。用 &lt;code&gt;Monad&lt;/code&gt; 定义这些实例的正确方法是直接使用 &lt;code&gt;Monad&lt;/code&gt; 操作，例如</target>
        </trans-unit>
        <trans-unit id="4b041bcf3276487951d5811d4b81addad99a067a" translate="yes" xml:space="preserve">
          <source>Just like signatures on value-level bindings, pattern synonym signatures can apply to more than one pattern. For instance,</source>
          <target state="translated">就像值级绑定上的签名一样,模式同义词签名可以应用于多个模式。例如:</target>
        </trans-unit>
        <trans-unit id="7774d2f3942adcf9419122bc33bb2393a5f13dbf" translate="yes" xml:space="preserve">
          <source>Just like the other types of plugins, you can write &lt;code&gt;DynFlags&lt;/code&gt; plugins that can take and make use of some options that you can then specify using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flag. In the &lt;code&gt;DynFlagsPlugin&lt;/code&gt; code from above, the said options would be available in the &lt;code&gt;opts&lt;/code&gt; argument of &lt;code&gt;hooksP&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985acf2ff25e349dcabef121160378e3f752037f" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">就像unsafePerformIO一样，但我们对其进行内联。巨大的性能提升，因为它使很多东西可以进一步内联。&lt;em&gt;很不安全&lt;/em&gt;。特别是，您不应在 &lt;code&gt;&lt;a href=&quot;data-text-internal-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 块内进行任何内存分配。在Hugs上，这只是 &lt;code&gt;unsafePerformIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fe74271062cab89acca9c50f817b98e381da7a1" translate="yes" xml:space="preserve">
          <source>Just like unsafePerformIO, but we inline it. Big performance gains as it exposes lots of things to further inlining. &lt;em&gt;Very unsafe&lt;/em&gt;. In particular, you should do no memory allocation inside an &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; block. On Hugs this is just &lt;code&gt;unsafePerformIO&lt;/code&gt;.</source>
          <target state="translated">就像unsafePerformIO一样，但我们对其进行内联。巨大的性能提升，因为它使很多东西可以进一步内联。&lt;em&gt;很不安全&lt;/em&gt;。特别是，您不应在 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:inlinePerformIO&quot;&gt;inlinePerformIO&lt;/a&gt;&lt;/code&gt; 块内进行任何内存分配。在Hugs上，这只是 &lt;code&gt;unsafePerformIO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6159003781d783ae2d3e51421957681ceabbb1" translate="yes" xml:space="preserve">
          <source>Just x =&amp;gt; creates the file with the given modes, Nothing =&amp;gt; the file must exist.</source>
          <target state="translated">只是x =&amp;gt;使用给定的模式创建文件，Nothing =&amp;gt;文件必须存在。</target>
        </trans-unit>
        <trans-unit id="7d2a7bff0abb0d0de4946434ea191a1498465dec" translate="yes" xml:space="preserve">
          <source>Justification</source>
          <target state="translated">Justification</target>
        </trans-unit>
        <trans-unit id="f0cab9d2f956f8044d800c15b8fc3a101bddd6b9" translate="yes" xml:space="preserve">
          <source>K1</source>
          <target state="translated">K1</target>
        </trans-unit>
        <trans-unit id="8db55d0eb9679e9399434774b00bd1464da87b23" translate="yes" xml:space="preserve">
          <source>KProxy</source>
          <target state="translated">KProxy</target>
        </trans-unit>
        <trans-unit id="39150f84927b15fbfb438bdbe30c28313b7dab8c" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hc&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt; (Note: &lt;code&gt;.hc&lt;/code&gt; files are only generated by &lt;a href=&quot;codegens#unreg&quot;&gt;unregisterised&lt;/a&gt; compilers).</source>
          <target state="translated">通过&lt;a href=&quot;codegens#c-code-gen&quot;&gt;C&lt;/a&gt;进行从 &lt;code&gt;.hs&lt;/code&gt; 到 &lt;code&gt;.o&lt;/code&gt; 的编译时，请保留中间的 &lt;code&gt;.hc&lt;/code&gt; 文件（注意： &lt;code&gt;.hc&lt;/code&gt; 文件仅由&lt;a href=&quot;codegens#unreg&quot;&gt;未注册的&lt;/a&gt;编译器生成）。</target>
        </trans-unit>
        <trans-unit id="0e96ed700c728faa5ce093e2ef58af4b206c758f" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.hi&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-hi-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.hi&lt;/code&gt; 文件。这是默认值。如果您对 &lt;code&gt;.hi&lt;/code&gt; 文件不感兴趣，则可以使用 &lt;code&gt;-no-keep-hi-files&lt;/code&gt; files。</target>
        </trans-unit>
        <trans-unit id="65a6fabb3b1fdedf128544cf6e03be19810249f5" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.ll&lt;/code&gt; files when doing &lt;code&gt;.hs&lt;/code&gt;-to-&lt;code&gt;.o&lt;/code&gt; compilations via &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt; (Note: &lt;code&gt;.ll&lt;/code&gt; files aren&amp;rsquo;t generated when using the native code generator, you may need to use &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; to force them to be produced).</source>
          <target state="translated">通过&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM&lt;/a&gt;进行 &lt;code&gt;.hs&lt;/code&gt; -to- &lt;code&gt;.o&lt;/code&gt; 编译时，请保留中间的 &lt;code&gt;.ll&lt;/code&gt; 文件（注意：使用本机代码生成器时不会生成 &lt;code&gt;.ll&lt;/code&gt; 文件，您可能需要使用&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;来强制生成它们）。</target>
        </trans-unit>
        <trans-unit id="bb4eaab08ea50b174cad4a0dcbfee09ebe256732" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.o&lt;/code&gt; files. This is the default. You may use &lt;code&gt;-no-keep-o-files&lt;/code&gt; if you are not interested in the &lt;code&gt;.o&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.o&lt;/code&gt; 文件。这是默认值。如果您对 &lt;code&gt;.o&lt;/code&gt; 文件不感兴趣，则可以使用 &lt;code&gt;-no-keep-o-files&lt;/code&gt; files。</target>
        </trans-unit>
        <trans-unit id="8891247972e540d00a82a48db690001e72e39435" translate="yes" xml:space="preserve">
          <source>Keep intermediate &lt;code&gt;.s&lt;/code&gt; files.</source>
          <target state="translated">保留中间的 &lt;code&gt;.s&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="618d7b66d0a5da454a76c61a106bbc8b386980c1" translate="yes" xml:space="preserve">
          <source>Keep only the groups in which at least one of the classes is an &lt;strong&gt;interactive class&lt;/strong&gt; (defined below).</source>
          <target state="translated">仅保留其中至少一个类是&lt;strong&gt;交互式类&lt;/strong&gt;（在下面定义）的组。</target>
        </trans-unit>
        <trans-unit id="db48f9adf54739f6c307652ccc128abe44ee55b6" translate="yes" xml:space="preserve">
          <source>Keep the output of the &lt;code&gt;CPP&lt;/code&gt; pre-processor phase as &lt;code&gt;.hscpp&lt;/code&gt; files. A &lt;code&gt;.hscpp&lt;/code&gt; file is only created, if a module gets compiled and uses the C pre-processor.</source>
          <target state="translated">将 &lt;code&gt;CPP&lt;/code&gt; 预处理程序阶段的输出保留为 &lt;code&gt;.hscpp&lt;/code&gt; 文件。甲 &lt;code&gt;.hscpp&lt;/code&gt; 文件只被创建，如果一个模块被编译和使用C预处理器。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="45185a850411c05190d8644455ed7e28be79f32f" translate="yes" xml:space="preserve">
          <source>Key arguments are evaluated to WHNF</source>
          <target state="translated">关键参数被评估为WHNF。</target>
        </trans-unit>
        <trans-unit id="108b398a8a710d3b21b74c853623729fec5c66a8" translate="yes" xml:space="preserve">
          <source>KeyboardInterrupts</source>
          <target state="translated">KeyboardInterrupts</target>
        </trans-unit>
        <trans-unit id="7b932e7704c56ac279074adf9cbeed98bb90a289" translate="yes" xml:space="preserve">
          <source>Kill</source>
          <target state="translated">Kill</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="f6f11ccdb22e9dbd420ca8b73fb865e1a73beb02" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;data-type-equality#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="e9add9e559da1de515054945468cae650868cb37" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;data-typeable#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="2b9fefce453a09c064d0416bf50a8fdee9b8f03a" translate="yes" xml:space="preserve">
          <source>Kind heterogeneous propositional equality. Like &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;a :~~: b&lt;/code&gt; is inhabited by a terminating value if and only if &lt;code&gt;a&lt;/code&gt; is the same type as &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">类异质命题相等。像 &lt;code&gt;&lt;a href=&quot;type-reflection#t::-126-:&quot;&gt;:~:&lt;/a&gt;&lt;/code&gt; 一样，当且仅当 &lt;code&gt;a&lt;/code&gt; 与 &lt;code&gt;b&lt;/code&gt; 的类型相同时， &lt;code&gt;a :~~: b&lt;/code&gt; 才会有一个终止值。</target>
        </trans-unit>
        <trans-unit id="1e2202b3014628a192e63059a442e7689aab808a" translate="yes" xml:space="preserve">
          <source>Kind of filling or padding to be done.</source>
          <target state="translated">种填充或填充要做。</target>
        </trans-unit>
        <trans-unit id="15d871de56a82992077494c7e2360de27a218760" translate="yes" xml:space="preserve">
          <source>Kind representations</source>
          <target state="translated">善意的表示</target>
        </trans-unit>
        <trans-unit id="cc4cf8a32a2bc0862e7d482199843cd1ee70873c" translate="yes" xml:space="preserve">
          <source>Kind variables can also be quantified in &lt;em&gt;visible&lt;/em&gt; positions. Consider the following two examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a4407d441254c502eba426c88d24ec2721a6ab" translate="yes" xml:space="preserve">
          <source>Kind-equalities cannot be deferred, e.g.</source>
          <target state="translated">种平等不能延后,如。</target>
        </trans-unit>
        <trans-unit id="db7f1b7b324213bc7b9a60bf048eeec0dafa8a82" translate="yes" xml:space="preserve">
          <source>KindQ</source>
          <target state="translated">KindQ</target>
        </trans-unit>
        <trans-unit id="a0e1adf2caacb11f0a7f30552166686185a261b9" translate="yes" xml:space="preserve">
          <source>KindRep</source>
          <target state="translated">KindRep</target>
        </trans-unit>
        <trans-unit id="c53c4c21817ef2a1d4f60e2cceae1eb6be52eda4" translate="yes" xml:space="preserve">
          <source>KindSignatures</source>
          <target state="translated">KindSignatures</target>
        </trans-unit>
        <trans-unit id="1f207bb143ebf53a96f07da496ea625fd1ed3952" translate="yes" xml:space="preserve">
          <source>Kinds</source>
          <target state="translated">Kinds</target>
        </trans-unit>
        <trans-unit id="a4c865932a7f3d9b055f979bca5ede567a926edc" translate="yes" xml:space="preserve">
          <source>Kleisli</source>
          <target state="translated">Kleisli</target>
        </trans-unit>
        <trans-unit id="e841df54a07c5f2cc9b5f9af566dd4e754d4d096" translate="yes" xml:space="preserve">
          <source>Kleisli arrows of a monad.</source>
          <target state="translated">克莱斯利箭的一个单体。</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">已知的局限性。</target>
        </trans-unit>
        <trans-unit id="5d7d25439595bfc8d329c71ca182a7c6823088b5" translate="yes" xml:space="preserve">
          <source>KnownNat</source>
          <target state="translated">KnownNat</target>
        </trans-unit>
        <trans-unit id="c37bbcaa811caf4684344786df42286e08100459" translate="yes" xml:space="preserve">
          <source>KnownSymbol</source>
          <target state="translated">KnownSymbol</target>
        </trans-unit>
        <trans-unit id="1bafcba98aca5f350dc05c967f514185665ef856" translate="yes" xml:space="preserve">
          <source>LANGID</source>
          <target state="translated">LANGID</target>
        </trans-unit>
        <trans-unit id="84f34581093e5397ee10c973d3f1265b05c1f6db" translate="yes" xml:space="preserve">
          <source>LARGE_INTEGER</source>
          <target state="translated">LARGE_INTEGER</target>
        </trans-unit>
        <trans-unit id="bf87bea3a535f56ac91a5de66d6b55f69d98184f" translate="yes" xml:space="preserve">
          <source>LCID</source>
          <target state="translated">LCID</target>
        </trans-unit>
        <trans-unit id="0beee13d31c1e3c6098692c8568c5506cfa9174d" translate="yes" xml:space="preserve">
          <source>LCMapFlags</source>
          <target state="translated">LCMapFlags</target>
        </trans-unit>
        <trans-unit id="336b811f9fed9547f7ebf0e4f1880cbb455180ca" translate="yes" xml:space="preserve">
          <source>LCTYPE</source>
          <target state="translated">LCTYPE</target>
        </trans-unit>
        <trans-unit id="52c2e43c2456d90f37c50642076b0af5566ae13a" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW</source>
          <target state="translated">向左箭头</target>
        </trans-unit>
        <trans-unit id="cecc3c11891d7815b56633d3559be2f6608334e9" translate="yes" xml:space="preserve">
          <source>LEFTWARDS ARROW-TAIL</source>
          <target state="translated">向左箭头-尾巴。</target>
        </trans-unit>
        <trans-unit id="16577c79334aa225051280c5bb84f84cce0e4ae6" translate="yes" xml:space="preserve">
          <source>LEFTWARDS DOUBLE ARROW-TAIL</source>
          <target state="translated">左侧双箭头-尾巴。</target>
        </trans-unit>
        <trans-unit id="91a07087a57580c557f3a426586f0c2f60ef2af4" translate="yes" xml:space="preserve">
          <source>LF</source>
          <target state="translated">LF</target>
        </trans-unit>
        <trans-unit id="7526c6cf5f75ab344e0a9b50d84724f46ba01601" translate="yes" xml:space="preserve">
          <source>LHANDLE</source>
          <target state="translated">LHANDLE</target>
        </trans-unit>
        <trans-unit id="a85510722a0e3f63597435d302fceae090486b57" translate="yes" xml:space="preserve">
          <source>LLVM code from the &lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM code generator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codegens#llvm-code-gen&quot;&gt;LLVM代码生成器中&lt;/a&gt;的LLVM代码</target>
        </trans-unit>
        <trans-unit id="e71dc1792dc3123b5a369dd038b6e7cc64277908" translate="yes" xml:space="preserve">
          <source>LLVM code generator</source>
          <target state="translated">LLVM代码生成器</target>
        </trans-unit>
        <trans-unit id="a4ab30ac59152c7cdac425098a0e91bddb57dee0" translate="yes" xml:space="preserve">
          <source>LONG</source>
          <target state="translated">LONG</target>
        </trans-unit>
        <trans-unit id="ec5d37add4b689af044ac3c5bffa9caeddd4928a" translate="yes" xml:space="preserve">
          <source>LONG32</source>
          <target state="translated">LONG32</target>
        </trans-unit>
        <trans-unit id="4d839d00f90159ea1c7a2cce620daacfba69bfe0" translate="yes" xml:space="preserve">
          <source>LONG64</source>
          <target state="translated">LONG64</target>
        </trans-unit>
        <trans-unit id="30573aefe36d3bba7516573e936a54b9886f4531" translate="yes" xml:space="preserve">
          <source>LONG_PTR</source>
          <target state="translated">LONG_PTR</target>
        </trans-unit>
        <trans-unit id="6799d635b5e2816633a1eee1011aa42c6900072f" translate="yes" xml:space="preserve">
          <source>LPARAM</source>
          <target state="translated">LPARAM</target>
        </trans-unit>
        <trans-unit id="e191267d6636b8d8dd17922a36f5d83423ca186f" translate="yes" xml:space="preserve">
          <source>LPBOOL</source>
          <target state="translated">LPBOOL</target>
        </trans-unit>
        <trans-unit id="b0179249b725b53a04310f204589b18a9f487e9a" translate="yes" xml:space="preserve">
          <source>LPBYTE</source>
          <target state="translated">LPBYTE</target>
        </trans-unit>
        <trans-unit id="1aa1c9f4c10c1f10229a085be9fe5e8d772815c4" translate="yes" xml:space="preserve">
          <source>LPCSTR</source>
          <target state="translated">LPCSTR</target>
        </trans-unit>
        <trans-unit id="e741ece1418d5a115d62b99230ca71d3efe4070d" translate="yes" xml:space="preserve">
          <source>LPCTSTR</source>
          <target state="translated">LPCTSTR</target>
        </trans-unit>
        <trans-unit id="172c9c6bdd05170cc78b4016e92a18b0ce371012" translate="yes" xml:space="preserve">
          <source>LPCTSTR_</source>
          <target state="translated">LPCTSTR_</target>
        </trans-unit>
        <trans-unit id="77d43834b2e69f339ace63bdd9b49fba118491ec" translate="yes" xml:space="preserve">
          <source>LPCWSTR</source>
          <target state="translated">LPCWSTR</target>
        </trans-unit>
        <trans-unit id="eacdfe1b863de52295f8ed9111840c8b69de1d8a" translate="yes" xml:space="preserve">
          <source>LPDWORD</source>
          <target state="translated">LPDWORD</target>
        </trans-unit>
        <trans-unit id="f5d63f9a27fa44191677aa464c55c7503eba938c" translate="yes" xml:space="preserve">
          <source>LPINPUT</source>
          <target state="translated">LPINPUT</target>
        </trans-unit>
        <trans-unit id="d255c79116e40dec5d46ebe0b88ddcd312799e9a" translate="yes" xml:space="preserve">
          <source>LPMSG</source>
          <target state="translated">LPMSG</target>
        </trans-unit>
        <trans-unit id="4ade22c4abe03e351c322f7d46f37b350a895c69" translate="yes" xml:space="preserve">
          <source>LPOSVERSIONINFOEX</source>
          <target state="translated">LPOSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="59d6e50d1a4f36a9203f0cbba59c865419b38b5b" translate="yes" xml:space="preserve">
          <source>LPOVERLAPPED</source>
          <target state="translated">LPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="be649aa6e2e33d351a5bab4d706cca9fa800ea52" translate="yes" xml:space="preserve">
          <source>LPPAINTSTRUCT</source>
          <target state="translated">LPPAINTSTRUCT</target>
        </trans-unit>
        <trans-unit id="67257cfd99d80a2df705d6b562a4f33f6da4eef6" translate="yes" xml:space="preserve">
          <source>LPSECURITY_ATTRIBUTES</source>
          <target state="translated">LPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="89625841cf8382a8b7cbfb91a1aa9825d588e589" translate="yes" xml:space="preserve">
          <source>LPSTR</source>
          <target state="translated">LPSTR</target>
        </trans-unit>
        <trans-unit id="4bf9ddc5d3aca695589c5b07f3bbfd2293289ee7" translate="yes" xml:space="preserve">
          <source>LPTSTR</source>
          <target state="translated">LPTSTR</target>
        </trans-unit>
        <trans-unit id="f34c393d2b1c91567364523f1ab42c92643afd25" translate="yes" xml:space="preserve">
          <source>LPVOID</source>
          <target state="translated">LPVOID</target>
        </trans-unit>
        <trans-unit id="df97686e2eaf116cd4616939d89f5db838713001" translate="yes" xml:space="preserve">
          <source>LPWSTR</source>
          <target state="translated">LPWSTR</target>
        </trans-unit>
        <trans-unit id="c9907d8861344b17d44c4f103abf75a9157959d9" translate="yes" xml:space="preserve">
          <source>LRESULT</source>
          <target state="translated">LRESULT</target>
        </trans-unit>
        <trans-unit id="6c62fb7313eb9d28efbca3e61ff13801b5b45a0a" translate="yes" xml:space="preserve">
          <source>LT</source>
          <target state="translated">LT</target>
        </trans-unit>
        <trans-unit id="e069a75ab11debd5703606dcab59ec2fb4d96109" translate="yes" xml:space="preserve">
          <source>Label a decoder. If the decoder fails, the label will be appended on a new line to the error message string.</source>
          <target state="translated">给解码器贴标签。如果解码器失败,标签将被附加在错误信息字符串的新行上。</target>
        </trans-unit>
        <trans-unit id="600b10a6ff2b2b4798fef332e1c46bd3ff40864f" translate="yes" xml:space="preserve">
          <source>Labelling trees</source>
          <target state="translated">树木的标签</target>
        </trans-unit>
        <trans-unit id="bd0e2f60f3cab26b9d1a005d3e6df03ee775b43b" translate="yes" xml:space="preserve">
          <source>LambdaCase</source>
          <target state="translated">LambdaCase</target>
        </trans-unit>
        <trans-unit id="f8ba7082b851540c52b04047ac4c6d27074d828b" translate="yes" xml:space="preserve">
          <source>LangAsm</source>
          <target state="translated">LangAsm</target>
        </trans-unit>
        <trans-unit id="e29d0e2e40cfc7d4080b46c4ed09bd1426b13ae6" translate="yes" xml:space="preserve">
          <source>LangC</source>
          <target state="translated">LangC</target>
        </trans-unit>
        <trans-unit id="6f9fe5d064c62dd571d1cd25ae70836c15d42666" translate="yes" xml:space="preserve">
          <source>LangCxx</source>
          <target state="translated">LangCxx</target>
        </trans-unit>
        <trans-unit id="b36e168343c5d8ff6e8b16848d95a785e3e4e206" translate="yes" xml:space="preserve">
          <source>LangObjc</source>
          <target state="translated">LangObjc</target>
        </trans-unit>
        <trans-unit id="8f6e55899c5e99e242135ff6cf8c727ef909dd4c" translate="yes" xml:space="preserve">
          <source>LangObjcxx</source>
          <target state="translated">LangObjcxx</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="e3818c797711a3ca9b496a8bf021d70184059791" translate="yes" xml:space="preserve">
          <source>Language extension lookup</source>
          <target state="translated">语言扩展查询</target>
        </trans-unit>
        <trans-unit id="819f46032d151fbc83b888fce06e8becbc1ba90d" translate="yes" xml:space="preserve">
          <source>Language extensions</source>
          <target state="translated">语言扩展</target>
        </trans-unit>
        <trans-unit id="05b5ef0d2efbebac38a6a109039519a6c3f95008" translate="yes" xml:space="preserve">
          <source>Language extensions known to GHC</source>
          <target state="translated">GHC已知的语言扩展</target>
        </trans-unit>
        <trans-unit id="b132eded8d0dc30dbe1263774537feb48884f8fb" translate="yes" xml:space="preserve">
          <source>Language options can be controlled in two ways:</source>
          <target state="translated">语言选项可以通过两种方式进行控制。</target>
        </trans-unit>
        <trans-unit id="6bd1a5ed914255da4f2e3d146728cb1407c73dac" translate="yes" xml:space="preserve">
          <source>Language options can be enabled either by a command-line option &lt;code&gt;-Xblah&lt;/code&gt;, or by a &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; pragma in the file itself. See &lt;a href=&quot;glasgow_exts#options-language&quot;&gt;Language options&lt;/a&gt;.</source>
          <target state="translated">可以通过命令行选项 &lt;code&gt;-Xblah&lt;/code&gt; 或文件本身中的 &lt;code&gt;{-# LANGUAGE blah #-}&lt;/code&gt; 编译指示来启用语言选项。请参阅&lt;a href=&quot;glasgow_exts#options-language&quot;&gt;语言选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb129676df1e2ca9487a872968ddcafe0d9dd6a9" translate="yes" xml:space="preserve">
          <source>Language options recognised by Cabal can also be enabled using the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma, thus &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; (see &lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE pragma&lt;/a&gt;).</source>
          <target state="translated">Cabal识别的语言选项也可以使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译指示来启用，因此可以使用 &lt;code&gt;{-# LANGUAGE TemplateHaskell #-}&lt;/code&gt; （请参阅&lt;a href=&quot;#language-pragma&quot;&gt;LANGUAGE编译指示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4303cd5d535fbb5d0b9f4d30dd7adce7e5ce6778" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH</source>
          <target state="translated">Language.Haskell.TH</target>
        </trans-unit>
        <trans-unit id="de2ab3d572f18c64ff1f3f745dbafb85fc36b86d" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.LanguageExtensions</source>
          <target state="translated">Language.Haskell.TH.LanguageExtensions</target>
        </trans-unit>
        <trans-unit id="a536fc0da9feb311a1888ebea07a6df0b1199739" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal</target>
        </trans-unit>
        <trans-unit id="625f2edd5986bf5aa6e47f4476741a674b3ee730" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Lib.Internal exposes some additional functionality that is used internally in GHC's integration with Template Haskell. This is not a part of the public API, and as such, there are no API guarantees for this module from version to version.</source>
          <target state="translated">Language.Haskell.TH.Lib.Internal公开了一些额外的功能,这些功能在GHC与Template Haskell的集成中被内部使用。这不是公共 API 的一部分,因此,这个模块在不同版本之间没有 API 保证。</target>
        </trans-unit>
        <trans-unit id="1c03c9aef7745ac205e3905894725dfd28c07640" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Ppr</source>
          <target state="translated">Language.Haskell.TH.Ppr</target>
        </trans-unit>
        <trans-unit id="d5b1913241bcbf67ca726f074016aeb992ec6064" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.PprLib</source>
          <target state="translated">Language.Haskell.TH.PprLib</target>
        </trans-unit>
        <trans-unit id="beacda45774b21626492b1c3c45cdfb6c502fea0" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Quote</source>
          <target state="translated">Language.Haskell.TH.Quote</target>
        </trans-unit>
        <trans-unit id="2af0f0aebf13fc8e5f915b22fc1832e251d01c0b" translate="yes" xml:space="preserve">
          <source>Language.Haskell.TH.Syntax</source>
          <target state="translated">Language.Haskell.TH.Syntax</target>
        </trans-unit>
        <trans-unit id="2c4c7d3c26eea5a437b10f135bd656f51fe7182c" translate="yes" xml:space="preserve">
          <source>LanguageDef</source>
          <target state="translated">LanguageDef</target>
        </trans-unit>
        <trans-unit id="8d5e1a74eb773e87b48d793c077afcf2cd4b9d8a" translate="yes" xml:space="preserve">
          <source>Large objects are not allocated from the normal allocation area set by the &lt;code&gt;-A&lt;/code&gt; flag, which is why there is a separate limit for these. Large objects tend to be much rarer than small objects, so most programs hit the &lt;code&gt;-A&lt;/code&gt; limit before the &lt;code&gt;-AL&lt;/code&gt; limit. However, the &lt;code&gt;-A&lt;/code&gt; limit is per-capability, whereas the &lt;code&gt;-AL&lt;/code&gt; limit is global, so as &lt;code&gt;-N&lt;/code&gt; gets larger it becomes more likely that we hit the &lt;code&gt;-AL&lt;/code&gt; limit first. To counteract this, it might be necessary to use a larger &lt;code&gt;-AL&lt;/code&gt; limit when using a large &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">大对象没有从 &lt;code&gt;-A&lt;/code&gt; 标志设置的正常分配区域中分配，这就是为什么对它们有单独的限制的原因。大对象往往比小物件非常罕见，所以大多数程序打 &lt;code&gt;-A&lt;/code&gt; 的前限制 &lt;code&gt;-AL&lt;/code&gt; 限制。但是， &lt;code&gt;-A&lt;/code&gt; 限制是每个功能的限制，而 &lt;code&gt;-AL&lt;/code&gt; 限制是全局的限制，因此 &lt;code&gt;-N&lt;/code&gt; 越大，我们越有可能首先达到 &lt;code&gt;-AL&lt;/code&gt; 限制。为了解决这个问题，当使用大的 &lt;code&gt;-N&lt;/code&gt; 时，可能有必要使用更大的 &lt;code&gt;-AL&lt;/code&gt; 限制。</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="036fd8195c1bacf1837b14eef6243e90d12eeff8" translate="yes" xml:space="preserve">
          <source>Lastly come the normal type variables of a declaration.</source>
          <target state="translated">最后是声明的正常类型变量。</target>
        </trans-unit>
        <trans-unit id="96565d42beb23b9f18b0c44cb990adddfa8c6c5e" translate="yes" xml:space="preserve">
          <source>Lastly, all of this applies only for classes other than &lt;code&gt;Read&lt;/code&gt;, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Typeable&lt;/code&gt;, and &lt;code&gt;Data&lt;/code&gt;, for which the stock derivation applies (section 4.3.3. of the Haskell Report). (For the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, and &lt;code&gt;Bounded&lt;/code&gt; it is immaterial whether the stock method is used or the one described here.)</source>
          <target state="translated">最后，所有这些仅适用于应用库存推导的 &lt;code&gt;Read&lt;/code&gt; ， &lt;code&gt;Show&lt;/code&gt; ， &lt;code&gt;Typeable&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 以外的类（Haskell报告的4.3.3节）。（对于标准类 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; ，使用库存方法还是此处描述的方法都不重要。）</target>
        </trans-unit>
        <trans-unit id="7a81fbeb8d54ada80dba09a4fc21a3129bfb1430" translate="yes" xml:space="preserve">
          <source>Laws:</source>
          <target state="translated">Laws:</target>
        </trans-unit>
        <trans-unit id="0f509e179cc1a0fe8f803e98982287db8fe059d4" translate="yes" xml:space="preserve">
          <source>Layout fields are then overlapped so that the final layout will be as compact as possible. For example, suppose we have the unboxed sum:</source>
          <target state="translated">然后将布局字段进行重叠,使最终的布局尽可能的紧凑。例如,假设我们有未装箱的和。</target>
        </trans-unit>
        <trans-unit id="cb90f09d6abe9a4f5536f00172206430dfc1fd65" translate="yes" xml:space="preserve">
          <source>Layout with multi-way if works in the same way as other layout contexts, except that the semi-colons between guards in a multi-way if are optional. So it is not necessary to line up all the guards at the same column; this is consistent with the way guards work in function definitions and case expressions.</source>
          <target state="translated">多向if的布局与其他布局上下文的工作方式相同,只是多向if中守卫之间的分号是可选的。因此,没有必要将所有的守卫排在同一列;这与守卫在函数定义和案例表达式中的工作方式是一致的。</target>
        </trans-unit>
        <trans-unit id="cb0824cf9ff62297df30a510f886637077aac5e0" translate="yes" xml:space="preserve">
          <source>Lazily read all user input on &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; as a single string.</source>
          <target state="translated">懒惰地将所有在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 上的用户输入作为单个字符串读取。</target>
        </trans-unit>
        <trans-unit id="740345f4fc26eb7795ac98f172dc650babd2bee4" translate="yes" xml:space="preserve">
          <source>Lazily read the remaining contents of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be closed after the read completes, or on error.</source>
          <target state="translated">懒洋洋地阅读 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的其余内容。该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将关闭读取完成后，或在错误。</target>
        </trans-unit>
        <trans-unit id="9133c4ce416a587d4206249b3ec0be18933d85ff" translate="yes" xml:space="preserve">
          <source>Lazily serialise a value to a file.</source>
          <target state="translated">懒惰地将一个值序列化到一个文件。</target>
        </trans-unit>
        <trans-unit id="8e4c4b8d6f447284862f49f3045c8dc03eb992a3" translate="yes" xml:space="preserve">
          <source>Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to use as the tail of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 用作生成的惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的尾部</target>
        </trans-unit>
        <trans-unit id="2200f814b893336b40ddd029ac88811c89cd6469" translate="yes" xml:space="preserve">
          <source>Lazy I/O throws an exception if an error is encountered, in contrast to the Haskell 98 spec which requires that errors are discarded (see Section 21.2.2 of the Haskell 98 report). The exception thrown is the usual IO exception that would be thrown if the failing IO operation was performed in the IO monad, and can be caught by &lt;code&gt;System.IO.Error.catch&lt;/code&gt; or &lt;code&gt;Control.Exception.catch&lt;/code&gt;.</source>
          <target state="translated">如果遇到错误，则惰性I / O会引发异常，这与Haskell 98规范相反，后者要求丢弃错误（请参见Haskell 98报告的21.2.2节）。抛出的异常是通常的IO异常，如果在IO monad中执行失败的IO操作将抛出该异常，并且可以被 &lt;code&gt;System.IO.Error.catch&lt;/code&gt; 或 &lt;code&gt;Control.Exception.catch&lt;/code&gt; 捕获。</target>
        </trans-unit>
        <trans-unit id="0dc8a7617416cac1adb37dc18ef37fe1492d919f" translate="yes" xml:space="preserve">
          <source>Lazy RWS monad.</source>
          <target state="translated">懒惰的RWS单体。</target>
        </trans-unit>
        <trans-unit id="4e7f54740d38945be5cd4b244d5c2c47d033b6be" translate="yes" xml:space="preserve">
          <source>Lazy Reader-writer-state monads</source>
          <target state="translated">懒惰的读者-作者-状态单体</target>
        </trans-unit>
        <trans-unit id="eb43f112ea276b50bd6b9f699aa36231d04bac2f" translate="yes" xml:space="preserve">
          <source>Lazy state monads, passing an updatable state through a computation. See below for examples.</source>
          <target state="translated">懒状态单体,通过计算传递一个可更新的状态。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="556c668dfd9b10659aee0887aa651ecc4197ef61" translate="yes" xml:space="preserve">
          <source>Lazy state monads.</source>
          <target state="translated">懒态单体。</target>
        </trans-unit>
        <trans-unit id="d6e57ca0c7140fb8eaf2002ba63c8930d28ffe8d" translate="yes" xml:space="preserve">
          <source>Lazy writer monads.</source>
          <target state="translated">懒人作家单子。</target>
        </trans-unit>
        <trans-unit id="0f8c868597dc0fe23d3aa967985ce4e3dd234ee3" translate="yes" xml:space="preserve">
          <source>LeapSecondMap</source>
          <target state="translated">LeapSecondMap</target>
        </trans-unit>
        <trans-unit id="6d9694ab87c1509816fc3f073364a45eed8143dd" translate="yes" xml:space="preserve">
          <source>Left associative monadic bifold over a structure.</source>
          <target state="translated">在一个结构上的左联一元二折。</target>
        </trans-unit>
        <trans-unit id="9113429feae9435bc9a22b91fdadcab770bb70b5" translate="yes" xml:space="preserve">
          <source>Left identity</source>
          <target state="translated">左身份</target>
        </trans-unit>
        <trans-unit id="888262dff4e29ba66957e08ae5e7c00c8ddb1ac9" translate="yes" xml:space="preserve">
          <source>Left shrinking (or Tightening)</source>
          <target state="translated">左侧收缩(或紧缩</target>
        </trans-unit>
        <trans-unit id="43b09cf749eb5491b74e53f1bc09fa04659674f0" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure but with strict application of the operator.</source>
          <target state="translated">一个结构的左联折叠,但严格应用运算符。</target>
        </trans-unit>
        <trans-unit id="2e864825085ba6b285b3deb3c0b79e4d521a8979" translate="yes" xml:space="preserve">
          <source>Left-associative fold of a structure.</source>
          <target state="translated">结构的左联折叠。</target>
        </trans-unit>
        <trans-unit id="3c1c012fb20a62b44c7c2d747a91757337b12110" translate="yes" xml:space="preserve">
          <source>Left-associative fold operation for constructor applications.</source>
          <target state="translated">构造函数应用的左关联折叠操作。</target>
        </trans-unit>
        <trans-unit id="771b2d8147f59a5691eb79cad7d5c64627dab857" translate="yes" xml:space="preserve">
          <source>Left-to-right composition</source>
          <target state="translated">从左到右构成</target>
        </trans-unit>
        <trans-unit id="c2371e24467463447fab51b81ef30f6f1fa7acf3" translate="yes" xml:space="preserve">
          <source>Left-to-right composition of Kleisli arrows.</source>
          <target state="translated">从左到右组成的克莱斯利箭头。</target>
        </trans-unit>
        <trans-unit id="b396eca23f1092998983c79f8de12421ce4d07d7" translate="yes" xml:space="preserve">
          <source>LeftAdjust</source>
          <target state="translated">LeftAdjust</target>
        </trans-unit>
        <trans-unit id="6f12db94ca14c410ee6aea9aaf9f37f142111790" translate="yes" xml:space="preserve">
          <source>LeftAssociative</source>
          <target state="translated">LeftAssociative</target>
        </trans-unit>
        <trans-unit id="0b5d32fdd51149a3a9a8927f5a4932ddaa322146" translate="yes" xml:space="preserve">
          <source>LeftMode</source>
          <target state="translated">LeftMode</target>
        </trans-unit>
        <trans-unit id="17af1ff09188bf46cc1670386af27eac4b42d3c1" translate="yes" xml:space="preserve">
          <source>Legacy folds</source>
          <target state="translated">遗留问题</target>
        </trans-unit>
        <trans-unit id="3bade34ecbc5d996b2f301ebd4ba689e81c7c9ea" translate="yes" xml:space="preserve">
          <source>Length</source>
          <target state="translated">Length</target>
        </trans-unit>
        <trans-unit id="b35cc825e3ceae3035f623e062f495f46e1b0bf1" translate="yes" xml:space="preserve">
          <source>Length of a SIMD vector type</source>
          <target state="translated">一个SIMD向量类型的长度</target>
        </trans-unit>
        <trans-unit id="1da751ae056c25dec1bf146025343c7d7baa5ec4" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin</source>
          <target state="translated">Lennart Kolmodin</target>
        </trans-unit>
        <trans-unit id="4c902ed308255eedb5791755b57d87de654a6e37" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</source>
          <target state="translated">Lennart Kolmodin &amp;lt;kolmodin@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c65eb9120ed9793a089cab8d78b2b3e2762a66f1" translate="yes" xml:space="preserve">
          <source>Lennart Kolmodin Ross Paterson</source>
          <target state="translated">Lennart Kolmodin Ross Paterson</target>
        </trans-unit>
        <trans-unit id="785175efbad60848e99dc0e384b6197a7399034b" translate="yes" xml:space="preserve">
          <source>Let us illustrate these improvements on the CSV-table rendering example from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;. Its &quot;hot code&quot; is the rendering of a table's cells, which we implement as follows using only the functions from the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">让我们在&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;的CSV表呈现示例中说明这些改进。它的&amp;ldquo;热代码&amp;rdquo;是表单元格的呈现，我们仅使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; API中的函数来实现其实现。</target>
        </trans-unit>
        <trans-unit id="8f4eb684c9a2dfb229ddec06c0f99f449d161a5a" translate="yes" xml:space="preserve">
          <source>Let us look at an example first:</source>
          <target state="translated">我们先来看一个例子。</target>
        </trans-unit>
        <trans-unit id="a5c3e5bbf9a5e76197700fa3298be080332fba3f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a simple example,</source>
          <target state="translated">让我们考虑一个简单的例子，</target>
        </trans-unit>
        <trans-unit id="a592951b101ac13a4cc74ab595c10c997b2adfa4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Hello World program, and compile and run it. First, create a file &lt;code&gt;hello.hs&lt;/code&gt; containing the Haskell code:</source>
          <target state="translated">让我们创建一个Hello World程序，然后编译并运行它。首先，创建一个包含Haskell代码的文件 &lt;code&gt;hello.hs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dd8ebc96ea1bed3112a906d9d91800a76be4b101" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first see how execution flows through this program. We start by telling GHC that we want debug information,</source>
          <target state="translated">首先让我们看一下执行如何在该程序中流动。首先，告诉GHC我们需要调试信息，</target>
        </trans-unit>
        <trans-unit id="bf4f9d515969a695864d800b64fe827628e6fe9a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with an example GHCi session. You can fire up GHCi with the command &lt;code&gt;ghci&lt;/code&gt;:</source>
          <target state="translated">让我们从一个示例GHCi会话开始。您可以使用 &lt;code&gt;ghci&lt;/code&gt; 命令启动GHCi ：</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="594c7197a66aa41cb3dd72c23871e7b9c600e29e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the example from above, and invoke it from a standalone C program. Here&amp;rsquo;s the C code:</source>
          <target state="translated">让我们从上面举个例子，并从一个独立的C程序中调用它。这是C代码：</target>
        </trans-unit>
        <trans-unit id="c8a1d1f3d4842f4a6ca73f207182495c844d5cac" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use quicksort as a running example. Here&amp;rsquo;s the code:</source>
          <target state="translated">让我们使用quicksort作为运行示例。这是代码：</target>
        </trans-unit>
        <trans-unit id="acb86e263cb9634893bee6f20e365bbfa9867198" translate="yes" xml:space="preserve">
          <source>Let's decode binary data representing illustrated here. In this example the values are in little endian.</source>
          <target state="translated">让我们来解码一下这里的二进制数据表示。在这个例子中,数值是以小恩迪安为单位的。</target>
        </trans-unit>
        <trans-unit id="789a59a775f3c2900a64ef818bc09e8989fd5353" translate="yes" xml:space="preserve">
          <source>Let's first define a function that decodes many &lt;code&gt;Trade&lt;/code&gt;s.</source>
          <target state="translated">首先定义一个解码许多 &lt;code&gt;Trade&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="9e7e5ce190e9c80ce4a8c228bca3542e7865655a" translate="yes" xml:space="preserve">
          <source>LetterNumber</source>
          <target state="translated">LetterNumber</target>
        </trans-unit>
        <trans-unit id="87f5f38833b121fccd9e5087f3c99d3bb46af917" translate="yes" xml:space="preserve">
          <source>Level of detail in the pretty printed output. Level 0 is the least detail.</source>
          <target state="translated">漂亮打印输出的细节水平。0级是最少的细节。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
