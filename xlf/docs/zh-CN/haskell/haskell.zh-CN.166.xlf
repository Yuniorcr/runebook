<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">过时的语言选项 &lt;code&gt;PolymorphicComponents&lt;/code&gt; 和&lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; &lt;/a&gt;是同义词&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;。他们过去通常指定GHC不再做出的更好区分。（他们确实应该引发弃用警告，但并非如此，纯粹是为了避免需要库作者更改其旧标志规范。）</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">老，阴影，版本的 &lt;code&gt;T&lt;/code&gt; 显示为 &lt;code&gt;main::Interactive.T&lt;/code&gt; 以试图从所述新区分它由GHCI &lt;code&gt;T&lt;/code&gt; ，其被显示为简单地 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">此规则的一个例外是&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，因为通过&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;派生实例只是生成了一个空的实例声明，不需要使用任何构造函数。有关更多详细信息，请参见&lt;a href=&quot;#derive-any-class&quot;&gt;派生任何类&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="5e0a9633714321260550a5d2fcda2a976b8c7ecf" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">此规则的一个例外是&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，因为通过&lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;派生实例只是生成了一个空实例声明，不需要使用任何构造函数。有关更多详细信息，请参见&lt;a href=&quot;#derive-any-class&quot;&gt;派生任何类&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">传递给 &lt;code&gt;unsafeLocalState&lt;/code&gt; 的 IO操作中唯一允许的IO操作是（a）本地分配（ &lt;code&gt;alloca&lt;/code&gt; ， &lt;code&gt;allocaBytes&lt;/code&gt; 和派生操作，例如 &lt;code&gt;withArray&lt;/code&gt; 和 &lt;code&gt;withCString&lt;/code&gt; ），以及（b）指针上的指针操作（ &lt;code&gt;Foreign.Storable&lt;/code&gt; 和 &lt;code&gt;Foreign.Ptr&lt;/code&gt; ） （c）外部函数，其唯一可观察到的作用是读取和/或写入本地分配的内存。传递不遵守这些规则的IO操作会导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">两组之间的唯一区别是，在第二组中， &lt;code&gt;len_acc&lt;/code&gt; 具有类型签名。在前一种情况下， &lt;code&gt;len_acc1&lt;/code&gt; 在其右侧是单态的，因此隐式参数 &lt;code&gt;?acc&lt;/code&gt; 不会传递给递归调用。在后一种情况下，因为 &lt;code&gt;len_acc2&lt;/code&gt; 具有类型签名，所以将对&lt;em&gt;多态&lt;/em&gt;版本进行递归调用，该&lt;em&gt;多态&lt;/em&gt;版本将 &lt;code&gt;?acc&lt;/code&gt; 作为隐式参数。因此，我们在GHCi中得到以下结果：</target>
        </trans-unit>
        <trans-unit id="9990b4df29d87745ac325e522dbe79968c7bc35e" translate="yes" xml:space="preserve">
          <source>The only effect which is intentionally not incorporated in the &lt;code&gt;release&lt;/code&gt; action is the effect of throwing an error. In that case, the error must be re-thrown. One subtlety which is easy to miss is that in the case in which &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; both throw an error, the error from &lt;code&gt;release&lt;/code&gt; should take priority. Here is an implementation for &lt;code&gt;ExceptT&lt;/code&gt; which demonstrates how to do this.</source>
          <target state="translated">故意不包含在 &lt;code&gt;release&lt;/code&gt; 动作中的唯一效果是引发错误的效果。在这种情况下，必须重新抛出该错误。一个微妙这是很容易错过的是，在这种情况下 &lt;code&gt;use&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 都抛出一个错误，从错误 &lt;code&gt;release&lt;/code&gt; 应优先。这是 &lt;code&gt;ExceptT&lt;/code&gt; 的实现，演示了如何执行此操作。</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">这种签字的唯一允许的执行方式是一个模块,该模块重新输出的是同一个实体。</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">应该显式调用 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 解析器的唯一点是主解析器的开始，以便跳过任何前导空白。</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">应该显式调用 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 解析器的唯一点是主解析器的开始，以便跳过任何前导空白。</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">唯一的预定义实例是明显的一个什么都不做的实例。</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">唯一的预定义实例是显而易见的,让字符串照常工作。</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">唯一的问题是,当一个模块包含一个实例声明,而GHC没有其他理由访问该模块时。例子:</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">现在剩下要做的就是定义一个&amp;ldquo;前端&amp;rdquo;类，该类向用户公开：</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unused&lt;/code&gt; 构造函数的唯一用途是为类型变量 &lt;code&gt;cxt&lt;/code&gt; 强制使用正确的类型。</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">程序运行的操作系统。</target>
        </trans-unit>
        <trans-unit id="baf98890264db12c13a0ed323b113f943e70d115" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running. Common values include:</source>
          <target state="translated">程序运行的操作系统。常见的值包括:</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且是目录或目录的符号链接，则 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 操作将返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8332f5125e87dd009d7bdddc38f1192739ced75f" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且是目录或指向目录的符号链接，则 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 操作将返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4854d75c06e684b051f9e4890dec7d55c0adcabb" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且是目录或指向目录的符号链接，则 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 操作将返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且不是目录，则操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a53f211f831c07b35860c179c1095eecd331bca" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在且不是目录，则操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="907aadbc191368f77ac2409d9668430f37f02e38" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在且不是目录，则操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但具有与 &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">该操作可能会失败,因为:</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">对字符串的操作也是类似的。</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">运算符部分被当作未定义函数的函数应用,而lambda形式是在WHNF中包含未定义函数的应用。</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">该优化同样适用于绑定字典的GADT。如果我们静态地知道我们需要哪个类字典,那么我们将直接解决它,而不是间接地使用运行时传入的字典。</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">仅当GHC在未注册模式下构建时，选项&lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt;才可用。有关更多详细信息，请参见&lt;a href=&quot;codegens#unreg&quot;&gt;未注册的编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt;仅运行编译器的预处理过程，并将结果转储到文件中。</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;警告有关在运行时模式匹配可能失败的地方。下面的函数 &lt;code&gt;g&lt;/code&gt; 在应用于非空列表时将失败，因此当启用&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;时，编译器将发出有关此警告。</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;警告有关通过缺少构造函数访问的记录字段可能失败的记录。下面的函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;Bar&lt;/code&gt; 时将失败，因此启用&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;时，编译器将在其定义时发出警告。</target>
        </trans-unit>
        <trans-unit id="b08d390b9c785654fe869c3d6ad222e20f07d378" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt;&lt;code&gt;-Wunused-packages&lt;/code&gt;&lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;, but were not loaded during compication. Usually it means that you have an unused dependency.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt; &lt;code&gt;-Wunused-packages&lt;/code&gt; &lt;/a&gt;警告有关软件包的信息，这些软件包是在命令行上通过 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 或 &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; ，但在复杂过程中未加载。通常，这意味着您有未使用的依赖项。</target>
        </trans-unit>
        <trans-unit id="61a620c8d9cc429955a946259cb514c924df7f85" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt;&lt;code&gt;-Wunused-packages&lt;/code&gt;&lt;/a&gt; warns about packages, specified on command line via &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; or &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt;, but were not loaded during compilation. Usually it means that you have an unused dependency.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wunused-packages&quot;&gt; &lt;code&gt;-Wunused-packages&lt;/code&gt; 会&lt;/a&gt;警告有关软件包的信息，这些软件包是通过 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;code&gt;-package-id ⟨unit-id⟩&lt;/code&gt; pkg⟩或-package-id⟨unit-id⟩在命令行上指定的，但在编译过程中未加载。通常，这意味着您有未使用的依赖项。</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">选项&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;使每个thunk在评估开始后就被黑洞化。默认值为&amp;ldquo;懒惰黑洞&amp;rdquo;，其中，仅当线程由于某种原因暂停时，才将thunk标记为正在评估中。懒惰黑洞通常效率更高（提高1-2％左右），因为大多数暴徒不需要黑洞。但是，急切的漏洞可以避免在并行程序中进行更多的重复计算，这对于并行性通常很重要。</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">启用选项 &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; ，以便将特殊的默认规则应用于在提示符下键入的表达式（请参见&lt;a href=&quot;#extended-default-rules&quot;&gt;GHCi中的Type defaulting&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">选项说明（请参阅 &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">订单要求（请参阅 &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d8167b403a42cc1edb9a2a682b7a5b48280ccc43" translate="yes" xml:space="preserve">
          <source>The origin of the combinatorial product when &lt;strong&gt;&lt;code&gt;F&lt;/code&gt;&lt;/strong&gt; is &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; should now be apparent, the &lt;em&gt;non-deterministic&lt;/em&gt; definition of &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; for &lt;code&gt;List&lt;/code&gt; makes multiple independent choices for each element of the structure.</source>
          <target state="translated">所述组合产品的产地时&lt;strong&gt; &lt;code&gt;F&lt;/code&gt; &lt;/strong&gt;是&lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt;现在应当清楚，所述&lt;em&gt;非确定性&lt;/em&gt;的定义 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 为 &lt;code&gt;List&lt;/code&gt; 使得对于该结构的每个元素的多个独立选择。</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">原始讨论存储在这里：&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;我们可以获取Data.Text.Text的Data实例吗？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">原始程序完全是错误的。这是另一种错误</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的原始数据构造函数集</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">另外一个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，具有适合使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; 进行提升的类型：</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">其他的组合器都有合理的默认定义,为了提高效率,可以重写。</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">其他方法的默认定义如下,可以用相应的专门实现来覆盖。</target>
        </trans-unit>
        <trans-unit id="7bb7ece3e405ff935e86728e725cfcb4a44b98bc" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">可能需要角色注释的其他地方是在 &lt;code&gt;hs-boot&lt;/code&gt; 文件中（&lt;a href=&quot;../separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块&lt;/a&gt;），其中可以省略定义的右侧。通常，在 &lt;code&gt;hs-boot&lt;/code&gt; 文件中声明的类型/类必须与 &lt;code&gt;hs&lt;/code&gt; 文件中的定义（包括角色）相匹配。数据类型的默认角色是 &lt;code&gt;hs-boot&lt;/code&gt; 文件中的代表性角色，与常用情况相对应。</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">可能需要角色注释的其他地方是在 &lt;code&gt;hs-boot&lt;/code&gt; 文件（&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块&lt;/a&gt;）中，在这里可以省略定义的右侧。像往常一样，在 &lt;code&gt;hs-boot&lt;/code&gt; 文件中声明的类型/类必须与 &lt;code&gt;hs&lt;/code&gt; 文件中的定义匹配，包括角色。数据类型的默认角色是 &lt;code&gt;hs-boot&lt;/code&gt; 文件中的代表性角色，与常见用例相对应。</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是对 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 的特殊情况的优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是特殊情况下 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是对 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 的特殊情况的优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是特殊情况下 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">&lt;code&gt;ghc-pkg recache&lt;/code&gt; 有用的另一时间是手动注册软件包：可以通过简单地将适当的文件放在软件包数据库目录中并调用 &lt;code&gt;ghc-pkg recache&lt;/code&gt; 来更新软件包来注册软件包。对于自动包装系统，这种注册包装的方法可能更方便。</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">类型的外类型构造函数</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">除非使用 &lt;code&gt;~&lt;/code&gt; 禁用，否则所有模式匹配项中最外面的模式都会隐式爆炸。这适用于case表达式，lambda中的模式，do-notation，列表理解等。例如</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是该行左半部分的未使用部分，取反了。</target>
        </trans-unit>
        <trans-unit id="64559f0045cf50a2584ac0f3b554b1497f350498" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">输出的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是该行左半部分的未使用部分，取反了。</target>
        </trans-unit>
        <trans-unit id="e8d7a4ea6191b58bf6e33cabb3a1257778b2a45b" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">输出的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是该行左半部分的未使用部分，取反了。</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">输出中包含了程序中每一个异常的报告(程序在执行过程中可能会引发和捕获多个异常),其中每个报告的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="2c2e5b9a77507c6a8b08d76dc41ae952b97f0397" translate="yes" xml:space="preserve">
          <source>The output is a listing of all matching instances, simplified and instantiated as much as possible.</source>
          <target state="translated">输出的是所有匹配实例的列表,尽量简化和实例化。</target>
        </trans-unit>
        <trans-unit id="e1647f08fd0d03cfed6027ec69a028632d0edcfe" translate="yes" xml:space="preserve">
          <source>The output is as follows:</source>
          <target state="translated">输出结果如下:</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的关联缓冲区对输出进行缓冲。如果此缓冲区太小而无法执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 动作的一个步骤，则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="5fe80f6940b0232944b7b1dd6f17ef4e130eec5a" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的关联缓冲区对输出进行缓冲。如果此缓冲区太小而无法执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 动作的一个步骤，则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="3218872b6fb2290ae09475079bde573ea5753f84" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的关联缓冲区对输出进行缓冲。如果此缓冲区太小而无法执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 动作的一个步骤，则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">输出放置在&amp;ldquo;文件&amp;rdquo;中。如果省略⟨file⟩，那么输出将发送到 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt;的输出从包含三个以空格分隔的字段的标题行开始：</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">&lt;code&gt;+RTS -s&lt;/code&gt; 的输出告诉您在程序运行期间创建和执行了多少&amp;ldquo;火花&amp;rdquo;（请参阅&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;），这将使您了解 &lt;code&gt;par&lt;/code&gt; 批注的工作状况。</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">这个程序的输出。</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">重载的不可变数组接口</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">类型被声明的模块的包名。</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">软件包规格必须是尚未安装的软件包。</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; 返回的对应该与 &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">论文《&lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;量化类约束》&lt;/a&gt;（由Bottu，Karachalias，Schrijvers，Oliveira，Wadler，Haskell Symposium 2017撰写）详细介绍了此功能，并附有示例，因此是该提案的主要参考资料。</target>
        </trans-unit>
        <trans-unit id="9a39d25846fddc558c23b85ab30760213efefaf3" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this feature.</source>
          <target state="translated">论文《&lt;a href=&quot;https://homepages.inf.ed.ac.uk/wadler/papers/quantcc/quantcc.pdf&quot;&gt;量化类约束》&lt;/a&gt;（由Bottu，Karachalias，Schrijvers，Oliveira，Wadler，Haskell Symposium 2017撰写）详细介绍了此功能，并附有示例，因此是该功能的主要参考资料。</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">可参数化的异常单子。</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">可参数化的monad，可以通过将任意monad与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad组合而成。</target>
        </trans-unit>
        <trans-unit id="6b9fb54cd437f1b7ff93722b920d2899ccc3176a" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">可参数化的monad，可以通过将任意monad与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad组合而成。</target>
        </trans-unit>
        <trans-unit id="b0d4cf46f2063df438af6121c5250c1c1eb7b7e2" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">可参数化的monad，可以通过将任意monad与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad组合而成。</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">可参数化的阅读器单体。</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">括号是必须的。</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; 行为与解析器 &lt;code&gt;p&lt;/code&gt; 相同，但是只要解析器 &lt;code&gt;p&lt;/code&gt; 在&lt;em&gt;不消耗任何输入的情况下&lt;/em&gt;发生故障，它就会将预期错误消息替换为预期错误消息 &lt;code&gt;msg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">解析器 &lt;code&gt;permute perm&lt;/code&gt; 解析由 &lt;code&gt;perm&lt;/code&gt; 描述的解析器的排列。例如，假设我们要分析的置换：一个可选的串 &lt;code&gt;a&lt;/code&gt; 的，字符 &lt;code&gt;b&lt;/code&gt; 和可选 &lt;code&gt;c&lt;/code&gt; 。这可以通过以下方式描述：</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">对于提供的函数 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 的任何字符，解析器 &lt;code&gt;satisfy f&lt;/code&gt; 成功。返回实际解析的字符。</target>
        </trans-unit>
        <trans-unit id="3da61c1f215262075e23c68ae9974f2a60c3aee3" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">对于提供的函数 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 的任何字符，解析器 &lt;code&gt;satisfy f&lt;/code&gt; 成功。返回实际解析的字符。</target>
        </trans-unit>
        <trans-unit id="1e182b9ed56cfea719bfb7f4e40d9f6a35233ac2" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">对于提供的函数 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 的任何字符，解析器 &lt;code&gt;satisfy f&lt;/code&gt; 成功。返回实际解析的字符。</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的令牌 &lt;code&gt;t&lt;/code&gt; 。 &lt;code&gt;t&lt;/code&gt; 的源位置应由 &lt;code&gt;posFromTok t&lt;/code&gt; 返回，并且可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。</target>
        </trans-unit>
        <trans-unit id="c8d4044987606d17ffa84d47bfdcb30cc0f2b4ab" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的令牌 &lt;code&gt;t&lt;/code&gt; 。 &lt;code&gt;t&lt;/code&gt; 的源位置应由 &lt;code&gt;posFromTok t&lt;/code&gt; 返回，并且可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。</target>
        </trans-unit>
        <trans-unit id="d0c3af649fb859adf4b4cd09d1710a5b4d71f62f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的令牌 &lt;code&gt;t&lt;/code&gt; 。 &lt;code&gt;t&lt;/code&gt; 的源位置应由 &lt;code&gt;posFromTok t&lt;/code&gt; 返回，并且可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的标记 &lt;code&gt;t&lt;/code&gt; 。可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。所述的位置&lt;em&gt;下&lt;/em&gt;时，令牌应该返回 &lt;code&gt;nextPos&lt;/code&gt; 调用与所述电流源位置 &lt;code&gt;pos&lt;/code&gt; ，当前令牌 &lt;code&gt;t&lt;/code&gt; 和令牌的其余 &lt;code&gt;toks&lt;/code&gt; ， &lt;code&gt;nextPos pos t toks&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21e2fe8d4e41cdd8a83bf46968df27727c4731ed" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的标记 &lt;code&gt;t&lt;/code&gt; 。可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。所述的位置&lt;em&gt;下&lt;/em&gt;时，令牌应该返回 &lt;code&gt;nextPos&lt;/code&gt; 调用与所述电流源位置 &lt;code&gt;pos&lt;/code&gt; ，当前令牌 &lt;code&gt;t&lt;/code&gt; 和令牌的其余 &lt;code&gt;toks&lt;/code&gt; ， &lt;code&gt;nextPos pos t toks&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27e6679a2040a4cc14d5ec3614b408bb7ee98b37" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的标记 &lt;code&gt;t&lt;/code&gt; 。可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。所述的位置&lt;em&gt;下&lt;/em&gt;时，令牌应该返回 &lt;code&gt;nextPos&lt;/code&gt; 调用与所述电流源位置 &lt;code&gt;pos&lt;/code&gt; ，当前令牌 &lt;code&gt;t&lt;/code&gt; 和令牌的其余 &lt;code&gt;toks&lt;/code&gt; ， &lt;code&gt;nextPos pos t toks&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">解析器 &lt;code&gt;try p&lt;/code&gt; 的行为与解析器 &lt;code&gt;p&lt;/code&gt; 相似，除了它假装在发生错误时没有消耗任何输入。</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">解析器 &lt;code&gt;unexpected msg&lt;/code&gt; 总是失败，并意外的错误消息 &lt;code&gt;msg&lt;/code&gt; 而不消耗任何输入。</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">该解析器称为&lt;em&gt;预测性&lt;/em&gt;解析器，因为 &lt;code&gt;q&lt;/code&gt; 仅在解析器 &lt;code&gt;p&lt;/code&gt; 不使用任何输入（即，前瞻为1）时才尝试使用q。这种非回溯行为既可以实现解析器组合器的有效实现，又可以生成良好的错误消息。</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="e7ee59d681c70376770b1fac8def196e60a6b828" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="fd849bb3016a66d8c098cc0703e43bfaab55d628" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="b3eada09e683e23c6ff49ebfe7467394ea90bede" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="e5fe22074b95aef0b21f9a5dd43e52a6c7896746" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="54e8eb477e245f7f3705845f40a88a71eb316dcf" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="f4f7143d745a0515f027af6396b04eb6900940b4" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;rdquo; 之前的部分是&lt;em&gt;上下文&lt;/em&gt;，而&amp;ldquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;rdquo; 之后的部分是实例声明的&lt;em&gt;头部&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">最后一个缓冲区的部分填充和结果。</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">该组的密码(gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; 返回的路径对应于传递相同字符串（作为 &lt;code&gt;RawCommand&lt;/code&gt; ，不是 &lt;code&gt;ShellCommand&lt;/code&gt; ）时由 &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 执行的程序，但前提是该 &lt;code&gt;name&lt;/code&gt; 不是具有多个段的相对路径。</target>
        </trans-unit>
        <trans-unit id="b2d3f49ac1a8f81e24f3b676bdd92147b2b52971" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; 返回的路径对应于传递相同字符串（作为 &lt;code&gt;RawCommand&lt;/code&gt; ，不是 &lt;code&gt;ShellCommand&lt;/code&gt; ）时由 &lt;code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 执行的程序，但前提是该 &lt;code&gt;name&lt;/code&gt; 不是具有多个段的相对路径。</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">你要制作的目录的路径</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">模式</target>
        </trans-unit>
        <trans-unit id="315acf3488874c225ec06af4616c6846812ce4e8" translate="yes" xml:space="preserve">
          <source>The pattern match checker works by assigning symbolic values to each pattern. We call each such assignment a &amp;lsquo;model&amp;rsquo;. Now, each pattern match clause leads to potentially multiple splits of that model, encoding different ways for the pattern match to fail. For example, when matching &lt;code&gt;x&lt;/code&gt; against &lt;code&gt;Just 4&lt;/code&gt;, we split each incoming matching model into two uncovered sub-models: One where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt; and one where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just y&lt;/code&gt; but &lt;code&gt;y&lt;/code&gt; is not &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">模式匹配检查器通过为每个模式分配符号值来工作。我们将每个这样的作业称为&amp;ldquo;模型&amp;rdquo;。现在，每个模式匹配子句都可能导致该模型的多个拆分，从而编码模式匹配失败的不同方式。例如，当将 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;Just 4&lt;/code&gt; 进行匹配时，我们将每个传入的匹配模型分为两个未覆盖的子模型：一个 &lt;code&gt;x&lt;/code&gt; 表示 &lt;code&gt;Nothing&lt;/code&gt; ，而 &lt;code&gt;x&lt;/code&gt; 表示 &lt;code&gt;Just y&lt;/code&gt; 而 &lt;code&gt;y&lt;/code&gt; 不 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8b96580328f0d50dd0ffa37b821ba6ac58cd252" translate="yes" xml:space="preserve">
          <source>The pattern synonym return type (&lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe Bool) -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">模式同义词返回类型（ &lt;code&gt;&amp;lt;...&amp;gt; G a (Maybe Bool) -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">模式语法反映的是术语语法。</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">模式类型签名使类型变量在等式的右侧可用。</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">RTS从操作系统分配的峰值内存。</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">这个调用及其所有子调用占程序总内存分配的百分比(不包括剖析开销)。</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">本次调用占程序总内存分配的百分比(不包括剖析开销)。</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">程序总运行时间中花在调用树这一点上的百分比。</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">程序总运行时间在调用树的这一点以下的百分比。</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">复数的相位，范围为 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; 。如果大小为零，则相位也是如此。</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">流程标识符的平台特定类型。</target>
        </trans-unit>
        <trans-unit id="8463d6555430125aabc768a8bec2859b4a17a9f0" translate="yes" xml:space="preserve">
          <source>The plugin is then defined as by providing a value for the &lt;code&gt;holeFitPlugin&lt;/code&gt; field, a function that takes the &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags and returns a &lt;code&gt;HoleFitPluginR&lt;/code&gt;. This function can be used to pass the &lt;code&gt;CommandLineOption&lt;/code&gt; strings along to the candidate and fit plugins respectively.</source>
          <target state="translated">然后，通过为 &lt;code&gt;holeFitPlugin&lt;/code&gt; 字段提供值来定义该插件，该函数采用使用&lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt;标志传递给编译器的 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串，并返回 &lt;code&gt;HoleFitPluginR&lt;/code&gt; 。此函数可用于将 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串分别传递给候选插件和fit插件。</target>
        </trans-unit>
        <trans-unit id="af51c643d01a6af33fb762fecbe75a84665e395b" translate="yes" xml:space="preserve">
          <source>The pointer refers to a byte array. Finalization is not supported. This optimizes &lt;code&gt;MallocPtr&lt;/code&gt; by avoiding the allocation of a &lt;code&gt;MutVar#&lt;/code&gt; when it is known that no one will add finalizers to the &lt;code&gt;ForeignPtr&lt;/code&gt;. Functions that add finalizers to a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; throw exceptions when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is backed by &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt;. The invariants that apply to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:MallocPtr&quot;&gt;MallocPtr&lt;/a&gt;&lt;/code&gt; apply to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; as well.</source>
          <target state="translated">指针指向一个字节数组。不支持完成。这将优化 &lt;code&gt;MallocPtr&lt;/code&gt; 避免的分配 &lt;code&gt;MutVar#&lt;/code&gt; 当知道没有人会终结添加到 &lt;code&gt;ForeignPtr&lt;/code&gt; 。该终结添加到功能 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 时抛出异常 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由支持 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 。适用于不变量 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:MallocPtr&quot;&gt;MallocPtr&lt;/a&gt;&lt;/code&gt; 适用于 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 为好。</target>
        </trans-unit>
        <trans-unit id="d0849b46a7478d7ad384336c0deed069c4c2b29c" translate="yes" xml:space="preserve">
          <source>The pointer refers to a byte array. The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; field means that the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; is reachable (by GC) whenever the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is reachable. When the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; becomes unreachable, the runtime's normal GC recovers the memory backing it. Here, the finalizer function intended to be used to &lt;code&gt;free()&lt;/code&gt; any ancilliary *unmanaged* memory pointed to by the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt;. See the &lt;code&gt;zlib&lt;/code&gt; library for an example of this use.</source>
          <target state="translated">指针指向一个字节数组。所述 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 字段的装置，该 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 是可到达的（通过GC）每当 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 可达。当 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不可访问时，运行时的常规GC将恢复支持它的内存。在这里，finalizer函数旨在用于 &lt;code&gt;free()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutableByteArray-35-&quot;&gt;MutableByteArray#&lt;/a&gt;&lt;/code&gt; 指向的任何*非托管*辅助内存。有关此用法的示例，请参见 &lt;code&gt;zlib&lt;/code&gt; 库。</target>
        </trans-unit>
        <trans-unit id="a263d8d41bb6edc433ea0e9142fdac0bd9776a58" translate="yes" xml:space="preserve">
          <source>The pointer refers to unmanaged memory that should not be freed when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; becomes unreachable. Functions that add finalizers to a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; throw exceptions when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is backed by &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt;Most commonly, this is used with &lt;code&gt;Addr#&lt;/code&gt; literals. See Note [Why FinalPtr].</source>
          <target state="translated">指针指向非托管内存，当 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不可访问时，不应释放该内存。该终结添加到功能 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 时抛出异常 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 由支持 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; 最常见的，这是用来与 &lt;code&gt;Addr#&lt;/code&gt; 文字。请参阅注释[Why FinalPtr]。</target>
        </trans-unit>
        <trans-unit id="8213f977e2ad8f2bba6a392999e51bc11f3a6125" translate="yes" xml:space="preserve">
          <source>The pointer refers to unmanaged memory that was allocated by a foreign function (typically using &lt;code&gt;malloc&lt;/code&gt;). The finalizer frequently calls the C function &lt;code&gt;free&lt;/code&gt; or some variant of it.</source>
          <target state="translated">指针指向由外部函数分配的非托管内存（通常使用 &lt;code&gt;malloc&lt;/code&gt; ）。终结器经常 &lt;code&gt;free&lt;/code&gt; 调用C函数或它的某些变体。</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">数组内容的指针由 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="cc771d773e26b800fb99dc3f19db0ff5b4824d1c" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指向数组内容的指针是通过 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得的。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="e1e8e44c1e9b1f75abd43ddc712a72d215368641" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指向数组内容的指针是通过 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得的。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">数组内容的指针由 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="fc94f03827f8d452b7fbe2b08e32fe79424476a7" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指向数组内容的指针是通过 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得的。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="4910952a92b169df78d7802200e6c4c8bfc1b643" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指向数组内容的指针是通过 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得的。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">这种类型的多态性使得它可以在多种环境下使用。例如,它可以作为一个约束条件,例如,为一个不存在的实例提供更好的错误信息。</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">子范围内的下标位置。</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">这种差异的实际含义是，由于&lt;em&gt;异常&lt;/em&gt;语义的&lt;em&gt;不精确性&lt;/em&gt;，</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">编译指示必须出现在实例声明的 &lt;code&gt;where&lt;/code&gt; 部分内。</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">语法 &lt;code&gt;OVERLAPPING&lt;/code&gt; ， &lt;code&gt;OVERLAPPABLE&lt;/code&gt; ， &lt;code&gt;OVERLAPS&lt;/code&gt; ， &lt;code&gt;INCOHERENT&lt;/code&gt; 用于指定各个实例的重叠行为，如&amp;ldquo; &lt;a href=&quot;#instance-overlap&quot;&gt;重叠实例&amp;rdquo;一&lt;/a&gt;节中所述。编译指示立即写在 &lt;code&gt;instance&lt;/code&gt; 关键字之后，如下所示：</target>
        </trans-unit>
        <trans-unit id="fac2032d2c008fd2be3f90420e30882ad7ba2306" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;instances#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">语法 &lt;code&gt;OVERLAPPING&lt;/code&gt; ， &lt;code&gt;OVERLAPPABLE&lt;/code&gt; ， &lt;code&gt;OVERLAPS&lt;/code&gt; ， &lt;code&gt;INCOHERENT&lt;/code&gt; 用于指定各个实例的重叠行为，如&amp;ldquo;&lt;a href=&quot;instances#instance-overlap&quot;&gt;重叠实例&amp;rdquo;一&lt;/a&gt;节中所述。编译指示立即写在 &lt;code&gt;instance&lt;/code&gt; 关键字之后，如下所示：</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">预处理器是在Haskell编译器正确处理Haskell输入之前运行的,但在识字标记被剥离之后,而且(可能)C预处理器已经清洗了Haskell输入。</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">精确的配色方案由环境变量 &lt;code&gt;GHC_COLORS&lt;/code&gt; （或 &lt;code&gt;GHC_COLOURS&lt;/code&gt; ）控制。可以将其设置为以冒号分隔的 &lt;code&gt;key=value&lt;/code&gt; 对列表。这些是默认设置：</target>
        </trans-unit>
        <trans-unit id="96eb7064b5867fe92b5d5dd35489d4118c6f5245" translate="yes" xml:space="preserve">
          <source>The precise type of a quotation depends on the types of the nested splices inside it:</source>
          <target state="translated">报价的准确类型取决于其内部嵌套拼接的类型。</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">Integral类型的精度是通过零点填充来实现的,如果一个Integral字段同时给出精度和零点填充,那么零点填充将被忽略。如果一个积分字段同时给出了精度和零位数,则忽略零位数。</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">谓词被假定为定义一个等价物。</target>
        </trans-unit>
        <trans-unit id="b97869b6de983c9edee7999d2e2b2ebaa0a6f660" translate="yes" xml:space="preserve">
          <source>The prefix &lt;code&gt;-&lt;/code&gt; binds tighter than any infix operator. &lt;code&gt;-a % b&lt;/code&gt; is parsed as &lt;code&gt;(-a) % b&lt;/code&gt; regardless of the fixity of &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">前缀 &lt;code&gt;-&lt;/code&gt; 绑定比任何infix运算符都紧密。 &lt;code&gt;-a % b&lt;/code&gt; 被解析为 &lt;code&gt;(-a) % b&lt;/code&gt; 不管固定性 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">前缀` &lt;code&gt;generic&lt;/code&gt; '表示重载函数，是&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;函数的广义版本。</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">预处理器无法处理其他 Haskell 扩展。这些必须放在单独的模块中。</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">管理共享库的主要难点是安排好程序在运行时能找到所需的库。不同的平台,特别是三大系统之间的工作细节有所不同。Unix ELF平台,Windows和Mac OS X。</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">但是，异步异常的主要来源是 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">原始解析器组合器。</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">primops广泛使用未&lt;a href=&quot;#glasgow-unboxed&quot;&gt;装箱的类型&lt;/a&gt;和未&lt;a href=&quot;#unboxed-tuples&quot;&gt;装箱的元组&lt;/a&gt;，我们在这里简要地进行总结。</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">这里的问题在于，此实例将允许 &lt;code&gt;[a]&lt;/code&gt; 的一个特定选择与 &lt;code&gt;b&lt;/code&gt; 的一个以上选择相关联，这与 &lt;code&gt;D&lt;/code&gt; 的定义中指定的依赖性相矛盾。更一般而言，这意味着在任何形式的情况下：</target>
        </trans-unit>
        <trans-unit id="781f3f1a3ff39d864639b6823399b6750b7c27dc" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking &lt;em&gt;system&lt;/em&gt; calls which works for most system calls on both Unix and Windows.</source>
          <target state="translated">问题在于，通常不可能安全地打断外线电话。但是，GHC确实提供了一种中断阻塞&lt;em&gt;系统&lt;/em&gt;调用的方法，该方法适用于Unix和Windows上的大多数系统调用。</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">问题在于，通常不可能安全地打断外线电话。但是，GHC确实提供了一种中断阻塞系统调用的方法，该方法适用于Unix和Windows上的大多数系统调用。当 &lt;code&gt;InterruptibleFFI&lt;/code&gt; 启用扩展，外国通话可以与注释 &lt;code&gt;interruptible&lt;/code&gt; ，而不是 &lt;code&gt;safe&lt;/code&gt; 或 &lt;code&gt;unsafe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; 创建广播频道的问题在于，如果仅将其写入而从不读取，则项目将堆积在内存中。通过使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; 创建广播频道，可以在客户看到项目后对其进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">检查模块是否受信任的过程取决于&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志是否存在。两种情况下的检查都类似，带有&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志，使对可信赖模块的额外要求被视为可信赖。</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">进程的权限不足,无法执行操作。</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">当绑定是多态的时，该过程会稍微复杂一些。我们通过一个例子来展示这个过程。为了简单起见，我们将使用众所周知的 &lt;code&gt;map&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">过程信号掩码</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">配置文件数据本身由 &lt;code&gt;profile&lt;/code&gt; 字段描述，该字段包含具有以下属性的树状对象（在此我们将其称为&amp;ldquo;成本中心堆栈&amp;rdquo;），</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">简介树本身</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">程序&lt;strong&gt;hp2ps&lt;/strong&gt;程序将 &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; 运行时选项生成的 &lt;code&gt;.hp&lt;/code&gt; 文件转换为堆配置文件的PostScript图形。按照惯例，被处理的文件&lt;strong&gt;hp2ps&lt;/strong&gt;有 &lt;code&gt;.hp&lt;/code&gt; 扩展。PostScript输出被写入 &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; @ .ps。如果 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 完全省略，则程序将充当过滤器。&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e8eeb216422d9b04565bfefa5f60f99f84c18a4" translate="yes" xml:space="preserve">
          <source>The program below, when compiled with optimisation:</source>
          <target state="translated">下面的程序,经过优化编译后。</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">程序文本本身，C堆栈，任何非堆数据（例如，由外部库分配的数据和由RTS分配的数据）以及 &lt;code&gt;mmap()&lt;/code&gt; 的内存都不会计入堆配置文件中。</target>
        </trans-unit>
        <trans-unit id="477940d98b5481ae904ea922ab7dabd1f651a748" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;rsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">程序文本本身，C堆栈，任何非堆数据（例如，由外部库分配的数据和由RTS分配的数据）以及 &lt;code&gt;mmap()&lt;/code&gt; 的内存都不会计入堆配置文件中。</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">程序的堆已达到极限,程序应采取措施减少其拥有的实时数据量。注意事项</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">程序员可以指定重写规则作为源程序的一部分(在pragma中)。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="770523c810bf8b94673e415429173c9454a13f38" translate="yes" xml:space="preserve">
          <source>The projection function for a record with a single linear field should be multiplicity-polymorphic; currently it&amp;rsquo;s unrestricted.</source>
          <target state="translated">具有单个线性场的记录的投影函数应该是多重多态的；目前没有限制。</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">伪目标文件 &lt;code&gt;A.o-boot&lt;/code&gt; 是空的（请不要链接它！），但是在使用Makefile时，它非常有用，它可以记录 &lt;code&gt;A.hi-boot&lt;/code&gt; 的最新更新时间（请参阅&lt;a href=&quot;#using-make&quot;&gt;使用make&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">模板Haskell的公众形象</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 的目的是为可以通过缓冲区读取和写入数据的I / O设备提供一个通用接口。实现 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 的设备包括普通文件，内存映射文件和字节串。实现 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的基础设备必须提供 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">已安装程序包ID的目的是检测由重新安装程序包引起的问题，而无需重新编译依赖于该程序包的程序包。重新编译依赖项是必要的，因为即使两个软件包都是使用相同的编译器从相同的源代码构建的，新编译的软件包可能具有与先前版本不同的ABI（应用程序二进制接口）。使用已安装的程序包ID，重新编译的程序包将具有与先前版本不同的已安装程序包ID，因此现在将孤立依赖于先前版本的程序包-不满足其依赖关系之一。 &lt;code&gt;ghc-pkg list&lt;/code&gt; 中显示了以此方式破坏的软件包输出为红色（如果可能）或用大括号包围。在以下示例中，我们重新编译并重新安装了 &lt;code&gt;filepath&lt;/code&gt; 软件包，这导致包括 &lt;code&gt;Cabal&lt;/code&gt; 在内的各种依赖关系中断：</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">使用构建器原语的目的是提高 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的性能。这些改进源于使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行的两个最常见的步骤更加高效。我们依次解释这两个步骤。</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名中的量化是显式的。例如：</target>
        </trans-unit>
        <trans-unit id="5b448f586c824562f03a97bce628eeed77c6e2ff" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名中的量化是明确的。例如：</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">引用的⟨string⟩可以是任意的,可以包含换行。</target>
        </trans-unit>
        <trans-unit id="0fea1585aed3010cb59ede80216e1092bd438ce4" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;#5348&lt;/a&gt; for details.</source>
          <target state="translated">引号⟨string⟩在两个字符序列 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 的第一次出现时结束。绝对不会执行转义。如果要在字符串中嵌入该字符序列，则必须发明自己的转义符（例如，使用字符串 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; ），并使引用程序函数将 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 解释为 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 。一种实现此方法的方法是在报价程序中添加预处理通道，以执行转义转换。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;＃5348中&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">带引号的&amp;ldquo;字符串&amp;rdquo;在两个字符序列 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 首次出现时结束。绝对不会执行转义。如果要在字符串中嵌入该字符序列，则必须发明自己的转义符（例如，使用字符串 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; ），并使引用程序函数将 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 解释为 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 。一种实现此方法的方法是在报价程序中添加预处理通道，以执行转义转换。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;问题＃5348中&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;论文&lt;/a&gt; &amp;ldquo;不应该被概括&amp;rdquo;和&amp;ldquo;采用局部假设的模块化类型推论&amp;rdquo;以及相关&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;博客文章中&lt;/a&gt;给出了这种更为保守的策略的原理。</target>
        </trans-unit>
        <trans-unit id="46c2ed2757c23fae8b2fbe6c5c9ab4a0e016d4ba" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;论文&lt;/a&gt;&amp;ldquo;不应该被概括&amp;rdquo;和&amp;ldquo;采用局部假设的模块化类型推论&amp;rdquo;以及相关&lt;a href=&quot;https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html&quot;&gt;博客文章中&lt;/a&gt;给出了采用这种更为保守的策略的理由。</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">归因于此成本中心的时间&amp;ldquo;滴答声&amp;rdquo;的原始数量；由此，我们得到上面提到的 &lt;code&gt;%time&lt;/code&gt; 数字。</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">读者单体变换器,它为给定的单体添加一个只读环境。</target>
        </trans-unit>
        <trans-unit id="46f9f597df38a353cb188142732c1daaa5e1b6f6" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behavior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 在回溯输出中未显示此符号名称的原因是其对调试信息的解释是不忠实的，它假定C中保留了一个不变式，但Haskell程序中并未保留该不变式。不幸的是，有必要手动解决此问题，直到此行为在上游得到修复。</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 在回溯输出中未显示此符号名称的原因是其对调试信息的解释是不忠实的，它假定C中保留了不变式，但Haskell程序中并未保留。不幸的是，必须手动解决此问题，直到此行为被固定在上游。</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">后一种限制的原因是没有办法检查实例匹配。考虑到</target>
        </trans-unit>
        <trans-unit id="727c709b27773183b391bcb744b381b376f0efb1" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">出现此异常的原因是，可能没有其他方法可以绑定 &lt;code&gt;k&lt;/code&gt; 。例如，假设我们希望 &lt;code&gt;S&lt;/code&gt; 具有&lt;em&gt;不可见&lt;/em&gt;参数 &lt;code&gt;k&lt;/code&gt; 的以下种类：</target>
        </trans-unit>
        <trans-unit id="76babb94bd7796eeda34a4c806d3669a17f9540b" translate="yes" xml:space="preserve">
          <source>The reason for this exception is that there may be no other way to bind &lt;code&gt;k&lt;/code&gt;. For example, suppose we wanted &lt;code&gt;S&lt;/code&gt; to have the the following kind with an &lt;em&gt;invisible&lt;/em&gt; parameter &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">出现此异常的原因是，可能没有其他方法可以绑定 &lt;code&gt;k&lt;/code&gt; 。例如，假设我们希望 &lt;code&gt;S&lt;/code&gt; 具有&lt;em&gt;不可见&lt;/em&gt;参数 &lt;code&gt;k&lt;/code&gt; 的以下种类：</target>
        </trans-unit>
        <trans-unit id="10fffb75c7f29def089f47d64a7d059f29394ea6" translate="yes" xml:space="preserve">
          <source>The reason for this is, essentially, that none of these define a new construct. This means that no new type is being defined where specificity could play a role.</source>
          <target state="translated">这样做的原因基本上是,这些都没有定义一个新的结构。这意味着,没有定义任何新的类型,而特殊性可能在其中发挥作用。</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">对 &lt;code&gt;mergeQs&lt;/code&gt; 的调用之所以懒惰是因为它将在队列中的最后一个元素的底部，从而阻止我们评估完全排序的序列。</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">存在两种检查信任方式的原因是&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;支持的额外要求导致Safe Haskell的设计具有侵入性。启用该标志时使用Safe Haskell的软件包可能会编译，也可能不会编译，具体取决于用户计算机上受信任软件包的状态。这既脆弱，又会导致每个人的编译失败，即使他们没有尝试使用Safe Haskell提供的任何保证也是如此。默认情况下禁用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;并将其转换为标志，可使Safe Haskell成为选择加入扩展而不是始终启用功能。</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">可重新绑定的运算符必须具有上表中给出的&amp;ldquo;期望类型&amp;rdquo;。这些类型令人惊讶地通用。例如，您可以将绑定运算符与类型</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装惰性ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">推荐的分块大小。目前设置为4k,减去内存管理开销。</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">记录字段 &lt;code&gt;f&lt;/code&gt; 以某种方式在范围内（合格或不合格）。</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的递归使用迫使第二个参数具有 &lt;code&gt;Type&lt;/code&gt; 类型。但是，就像类型推断一样，您可以通过为 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;提供完整的用户提供的种类签名&lt;/em&gt;（或CUSK）来实现多态递归。当所有参数类型和结果类型都已知时，无需进行推断就可以提出CUSK。例如：</target>
        </trans-unit>
        <trans-unit id="dedba55228cde4bbd5f3a4194d8b8dabbf8ef98a" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;standalone kind signature&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的递归使用强制第二个参数具有类型 &lt;code&gt;Type&lt;/code&gt; 。但是，就像类型推断一样，您可以通过为 &lt;code&gt;T&lt;/code&gt; 提供&lt;em&gt;独立的种类签名&lt;/em&gt;来实现多态递归：</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">这些引用必须在调用者进程中创建。</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 表示相关的&lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;查找优先操作&lt;/a&gt;，如下所示</target>
        </trans-unit>
        <trans-unit id="c82e04509f3c4e35fd2f1a07c859be169e0cebec" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;https://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 来表示相关的&lt;a href=&quot;https://en.wikipedia.org/wiki/Find_first_set&quot;&gt;查找优先设置操作&lt;/a&gt;，如下所示</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">渲染模式。</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">表示 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 稍有不同。让我们再次以 &lt;code&gt;Tree&lt;/code&gt; 为例：</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typ的表示方式是举行抽象的,允许实现者使用花哨的表示方式(例如,用哈希凝聚来管理共享)。如果没有视图模式,使用这个签名有点不方便。</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">外部文件或流中换行的表示。</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由GHC产生的表示形式，用于表示 &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 的种类。</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">表示重用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; （从而 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ），以及 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。（这种可重用性是我们为kind- &lt;code&gt;*&lt;/code&gt; -types 携带伪类型参数的原因，但是已经包含足够多的不同名称，而无需重复其中的每个。）</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">该模块使用的表示方法适合于高性能的使用和大量数据的流式传输。它提供了一种操作大量文本的方法,而不要求将全部内容储存在内存中。</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">类型的表示 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; ，函数 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; 其中使用由衍生实例 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 来构造 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="ba5b30cdfd9e86a561074290ccced5278a8f534c" translate="yes" xml:space="preserve">
          <source>The required constraints (&lt;code&gt;&amp;lt;...&amp;gt; Read a =&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">所需的约束（ &lt;code&gt;&amp;lt;...&amp;gt; Read a =&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">默认情况下，重新计划计时器以20毫秒的粒度运行，但是可以使用 &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS选项更改此计时器。重新安排&amp;ldquo;滴答&amp;rdquo;之后，正在运行的线程将尽快被抢占。</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">的分辨率 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;getCurrentTime&lt;/code&gt; ， &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">本节其余部分将进一步详细介绍GADT风格的数据类型声明。</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分概述了支持GADT的GHC扩展。扩展程序通过&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;启用。该&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;扩展还设置&lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb9e53f318cf247bf10897cae419b667774eabb1" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;let_generalisation#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分概述了支持GADT的GHC扩展。扩展程序通过&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;启用。该&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;扩展还设置&lt;a href=&quot;gadt_syntax#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;let_generalisation#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">对功能依赖项的限制（&lt;a href=&quot;#functional-dependencies&quot;&gt;功能依赖项&lt;/a&gt;）特别麻烦。引人注意的是在上下文中引入类型变量，这些变量不会出现在头部，这是常规规则所排除的。例如：</target>
        </trans-unit>
        <trans-unit id="756e15be4e4083197aaf2790548e77863f7b570b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;functional_dependencies#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">对功能依赖项的限制（&lt;a href=&quot;functional_dependencies#functional-dependencies&quot;&gt;功能依赖项&lt;/a&gt;）特别麻烦。引人注意的是在上下文中引入类型变量，这些变量不会出现在头部，这是常规规则所排除的。例如：</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f01982d31d372848e4d6802c210759a3354a8278" translate="yes" xml:space="preserve">
          <source>The result is always &lt;code&gt;&amp;gt;= 1&lt;/code&gt; since even zero is encoded with 1 limb.</source>
          <target state="translated">结果总是 &lt;code&gt;&amp;gt;= 1&lt;/code&gt; 因为即使零也被1个分支编码。</target>
        </trans-unit>
        <trans-unit id="234012fc40c4bea56f2e4f13bf5a1c3732914d46" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;defer_type_errors#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">结果是，孔或变量的行为将类似于 &lt;code&gt;undefined&lt;/code&gt; ，但具有额外的好处，即它在编译时显示警告，并且在运行时求值时也会显示相同的消息。此行为遵循&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;选项的行为，该选项表示&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。请参见将&lt;a href=&quot;defer_type_errors#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">结果是，孔或变量的行为将类似于 &lt;code&gt;undefined&lt;/code&gt; ，但具有额外的好处，即它在编译时显示警告，并且在运行时求值时也会显示相同的消息。此行为遵循&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;选项的行为，该选项表示&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。请参见将&lt;a href=&quot;#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">结果类型注释是可选的，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; （如参数类型）。可以使用种类注释中的参数声明多种类类型族：</target>
        </trans-unit>
        <trans-unit id="80a8283d81339db6232148408a4fcc0523f7e378" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; is all-or-nothing, either containers of exactly the same shape as the input or a failure (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, empty list, etc.). The &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; function does not perform selective filtering as with e.g. &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 的结果是全有或全无，要么容器的形状与输入的形状完全相同，要么失败（ &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ，empty list等）。的 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequence&quot;&gt;sequence&lt;/a&gt;&lt;/code&gt; 函数不执行选择性滤波与例如 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2eca7030285d2fa9dfbb2ca4fe65ae3271250e69" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is all-or-nothing, either containers of exactly the same shape as the input or a failure (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, empty list, etc.). The &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; function does not perform selective filtering as with e.g. &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 的结果是全部或全部，要么是与输入形状完全相同的容器，要么是失败（ &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ，空列表等）。所述 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 功能不执行选择性滤波与例如 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">运行CPS计算的结果，并将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 作为最后的延续。</target>
        </trans-unit>
        <trans-unit id="6cddc91b7454e61583af3768c2c69961c994bfc1" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">运行CPS计算的结果，并将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 作为最后的延续。</target>
        </trans-unit>
        <trans-unit id="f61cf4af4831c00ee95b4b539424083349107c0f" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">运行CPS计算的结果，并将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 作为最后的延续。</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">以身份作为最后的延续,运行CPS计算的结果。</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能比输入字符串长，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，亚美尼亚语的小连字&amp;ldquo; ﬓ&amp;rdquo;（现在为U + FB13）被折叠为序列&amp;ldquo;մ&amp;rdquo;（男人，U + 0574），后跟&amp;ldquo;ն&amp;rdquo;（现在为U + 0576），而希腊文将&amp;ldquo; &amp;micro;&amp;rdquo;（微符号，U + 00B5）而不是其自身折叠为&amp;ldquo;&amp;mu;&amp;rdquo;（小写字母mu，U + 03BC）。</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文小舌音符 &quot;U+FB02 &quot;被转换为拉丁文大写字母F(U+0046)和拉丁文小字母l(U+006C)的序列。</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,&quot;İ&quot; (拉丁文大写字母I,上面有点,U+0130)映射到序列 &quot;i&quot;(拉丁文小写字母i,U+0069),后面是&quot;̇&quot; (以上结合点,U+0307)。</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如，德语&amp;ldquo;&amp;szlig;&amp;rdquo;（埃塞特，U + 00DF）映射到两个字母的序列&amp;ldquo; SS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,德文eszett (U+00DF)映射到两个字母序列SS。</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文大写字母I和上面的点(U+0130)映射到序列拉丁文小写字母i(U+0069),然后是上面的组合点(U+0307)。</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">结果类型是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">结果类型不是 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">结果类型也必须是明确的。通常这一点可以推断出来,但是当一个组中的所有模式同义词在构造函数中都是多态的时候,用户必须提供一个类型签名。</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">每个数据构造函数的结果类型必须从定义的类型构造函数开始。如果所有构造函数的结果类型均为 &lt;code&gt;T a1 ... an&lt;/code&gt; ，其中 &lt;code&gt;a1 ... an&lt;/code&gt; 是不同的类型变量，则数据类型为&lt;em&gt;普通&lt;/em&gt;；否则为&lt;em&gt;通用&lt;/em&gt;数据类型（&lt;a href=&quot;#gadt&quot;&gt;通用代数数据类型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4a3b3a8adec46b33328872fb3047f33759478c0b" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;gadt#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">每个数据构造函数的结果类型必须以定义的类型构造函数开始。如果所有构造函数的结果类型均为 &lt;code&gt;T a1 ... an&lt;/code&gt; ，其中 &lt;code&gt;a1 ... an&lt;/code&gt; 是不同的类型变量，则数据类型为&lt;em&gt;普通&lt;/em&gt;；否则为&lt;em&gt;通用&lt;/em&gt;数据类型（&lt;a href=&quot;gadt#gadt&quot;&gt;通用代数数据类型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">结果将是一组（可能是）递归绑定，仅绑定左侧的简单变量。（可以像在Haskell报告中那样向前迈进一步，并使用 &lt;code&gt;fix&lt;/code&gt; 来使递归绑定成为非递归绑定，但是我们在Core中不这样做，并且它只会混淆问题，因此我们在这里不这样做。）</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">直到 &lt;code&gt;compactFixupPointers#&lt;/code&gt; ，GC才知道结果块，并且必须格外小心，以免地址逃脱或内存泄漏。</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="29be3c2210c3b04c22ea1f09a769d96cd67a12c6" translate="yes" xml:space="preserve">
          <source>The return type of the data constructor (&lt;code&gt;&amp;lt;...&amp;gt; T a b -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt;). By virtue of this being a Haskell98-style declaration, the order of type variables in the return type will always coincide with the order in which they are quantified.</source>
          <target state="translated">数据构造函数的返回类型（ &lt;code&gt;&amp;lt;...&amp;gt; T a b -&amp;gt; &amp;lt;...&amp;gt;&lt;/code&gt; ）。由于这是一个Haskell98样式的声明，因此返回类型中类型变量的顺序将始终与量化它们的顺序一致。</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">返回值为 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; （应为 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; ，但是Haskell的类型系统使此操作变得很困难）。</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">仅当编译器发现 &lt;code&gt;Control.Exception.assert&lt;/code&gt; 应用程序时，才由重写器执行重写，因此，您仍然可以根据需要定义和使用自己的 &lt;code&gt;assert&lt;/code&gt; 版本。如果不是，请导入 &lt;code&gt;Control.Exception&lt;/code&gt; 以在代码中使用 &lt;code&gt;assert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">记录更新的规则是这样的。</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">规则是这样的:</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">导出列表规则（Haskell报告&lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;第5.2节&lt;/a&gt;）需要针对类型族进行调整：</target>
        </trans-unit>
        <trans-unit id="798cfdb395c403ae103a26777b2df7c204f7f552" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;https://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) need adjustment for type families:</source>
          <target state="translated">导出列表的规则（Haskell报告&lt;a href=&quot;https://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;第5.2节&lt;/a&gt;）需要针对类型族进行调整：</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">词法范围的类型变量的规则（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法范围的类型变量&lt;/a&gt;）适用于模式同义词签名。如这些规则所指定的，只有模式显式同义词的定义中来自显式的，在语法上可见的 &lt;code&gt;forall&lt;/code&gt; （通用）范围内的类型变量；被内在的一切所束缚的存在不存在。例如</target>
        </trans-unit>
        <trans-unit id="aac6743a839a2635c600ff4724f24ebab991dfb5" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">词法范围的类型变量的规则（请参阅&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;词法范围的类型变量&lt;/a&gt;）适用于模式同义词签名。如这些规则所指定的，只有模式显式同义词定义中来自显式的，在语法上可见的 &lt;code&gt;forall&lt;/code&gt; （通用性）作用域中的类型变量；存在的事物不受内在的一切约束。例如</target>
        </trans-unit>
        <trans-unit id="b99c4ffb314648f355d9f28d0c2cc30bab28737d" translate="yes" xml:space="preserve">
          <source>The rules for solving &lt;code&gt;Typeable&lt;/code&gt; constraints are as follows:</source>
          <target state="translated">解决可 &lt;code&gt;Typeable&lt;/code&gt; 约束的规则如下：</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">解决 &quot;类型化 &quot;约束的规则如下。</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="20727f6b2cc15acd07a14915b1949b34a30873b7" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;exts/ffi#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">运行时管理一组虚拟处理器，我们称其为&lt;em&gt;功能&lt;/em&gt;，其数量由 &lt;code&gt;-N&lt;/code&gt; 选项确定。每个功能可以一次运行一个Haskell线程，因此功能的数量等于可以物理并行运行的Haskell线程的数量。功能由一个或多个OS线程激活；运行时为每种功能管理一个OS线程池，因此，如果Haskell线程进行外部调用（请参阅&lt;a href=&quot;exts/ffi#ffi-threads&quot;&gt;多线程和FFI&lt;/a&gt;），则另一个OS线程可以接管该功能。</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">运行时管理一组虚拟处理器，我们称其为&lt;em&gt;功能&lt;/em&gt;，其数量由 &lt;code&gt;-N&lt;/code&gt; 选项确定。每个功能可以一次运行一个Haskell线程，因此功能的数量等于可以物理并行运行的Haskell线程的数量。功能由一个或多个OS线程激活；运行时会为每种功能管理一个OS线程池，因此，如果Haskell线程进行外部调用（请参阅&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;多线程和FFI&lt;/a&gt;），则另一个OS线程可以接管该功能。</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">运行时将使用任何可用的工作程序OS线程运行Haskell线程。如果您需要控制使用哪个特定的OS线程来运行给定的Haskell线程，也许是因为您需要调用使用OS-thread-local状态的外部库，那么就需要绑定线程（请参见&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">与 &lt;code&gt;-v2&lt;/code&gt; 相同，除了另外还会打印每个编译阶段的完整命令行（如果适用）。</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">与 &lt;code&gt;-v3&lt;/code&gt; 相同，除了在每个编译阶段之后还会打印中间程序表示形式（不包括预处理和C /汇编文件）。</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 相同，但用于非IO计算。当它们用于导出具有非IO类型的Haskell函数时，用于包装 &lt;code&gt;foreign export&lt;/code&gt; 和 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">与 &lt;code&gt;register&lt;/code&gt; 相同，除了如果已安装相同名称的软件包，将其替换为新的软件包。</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">和普通的Haskell对一样,但却是</target>
        </trans-unit>
        <trans-unit id="72a1fc3ae8641ac86c68b367076d1f341252f25f" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于&amp;ldquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;rdquo;错误，其行为相同，默认情况下会终止编译。您可以使用&lt;a href=&quot;../using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志来推迟此类错误。该标志将超出范围的变量产生的错误推迟到运行时，并将它们转换为编译时警告。反过来，这些警告可以完全由&lt;a href=&quot;../using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;抑制。</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于&amp;ldquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;rdquo;错误，其行为相同，默认情况下会终止编译。您可以使用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志来推迟此类错误。该标志将超出范围的变量产生的错误推迟到运行时，并将它们转换为编译时警告。反过来，这些警告可以完全由&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;抑制。</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">即使我们从源代码编译模块，也需要相同的标志，因为GHC仍认为它处于批处理模式：</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">相同的函子，但具有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和可 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例，这些实例以相反的顺序处理元素。</target>
        </trans-unit>
        <trans-unit id="da41682db6dc3bc462b3f80ca76ddaa5753e53c9" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">相同的函子，但具有 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和可 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例，这些实例以相反的顺序处理元素。</target>
        </trans-unit>
        <trans-unit id="42d91297b7e2709522fcdafa0ad0f96001825d2c" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">相同的函子，但具有 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和可 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例，这些实例以相反的顺序处理元素。</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">相同的函子，但具有以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="0aaeaba67e253d52c7d36c2433b481fa76e2e2f2" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">相同的函子，但具有以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="0be87e89bbaedfbad2722adb37e85a35d656f391" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">相同的函子，但具有以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">同样的信息在此汇总。</target>
        </trans-unit>
        <trans-unit id="c9836bb2774b4fe28e93611c450bce02c5621a1e" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">相同的相位编号控件可用于&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="11ccaaa6255f0ab48c624aeaae5190abd7b58ce2" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt;&lt;code&gt;RULE&lt;/code&gt;&lt;/a&gt;s (&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">相同的相位编号控件可用于&lt;a href=&quot;rewrite_rules#pragma-RULES&quot;&gt; &lt;code&gt;RULE&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">相同的相位编号控件可用于 &lt;code&gt;RULE&lt;/code&gt; （&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">相同的精细依赖关系分析还允许相互递归函数的类型签名具有不同的上下文，这在Haskell 98中是非法的（第4.5.2节，最后一句话）。GHC仅坚持要求&lt;em&gt;精制&lt;/em&gt;组的类型签名具有相同的类型签名；实际上，这意味着仅由相同模式绑定绑定的变量必须具有相同的上下文。例如，这很好：</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">相同的限制适用于 &lt;code&gt;deriving&lt;/code&gt; 子句生成的实例。因此，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">这里的场景与&lt;a href=&quot;#using-own-main&quot;&gt;使用您自己的main（）中&lt;/a&gt;的场景非常相似，除了目标不是链接完整的程序，而是从Haskell代码中创建一个库，该库可以按照与部署C库相同的方式进行部署码。</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">默认情况下，搜索路径包含一个目录：&amp;ldquo;&amp;rdquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;（即当前目录）。以下选项可用于添加或更改搜索路径的内容：</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">查找源文件的搜索路径是通过GHCi命令行上的&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项指定的，如下所示：</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">第二个参数通常是应用程序的名称。因为它将被整合到路径中,所以它必须由有效的路径字符组成。注意:如果第二个参数是绝对路径,它将只返回第二个参数。</target>
        </trans-unit>
        <trans-unit id="465ae4467d1e0d963f25eb41be201215387efce5" translate="yes" xml:space="preserve">
          <source>The second argument of both is an initial accumulator value &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;b&lt;/code&gt;. This is the result of the fold when the structure is empty. When the structure is non-empty, this is the accumulator value merged with the first element in left-associative folds, or with the last element in right-associative folds.</source>
          <target state="translated">两者的第二个参数是类型 &lt;code&gt;b&lt;/code&gt; 的初始累加器值 &lt;code&gt;z&lt;/code&gt; 。这是结构为空时折叠的结果。当结构为非空时，这是累加器值与左关联折叠中的第一个元素合并，或与右关联折叠中的最后一个元素合并。</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">第二个子句比较有趣。它说,如果右手边在重叠区域内重合,则允许两个重叠的类型族实例。一些例子在这里有帮助。</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个构造函数由两个字段组成。每个字段都是 &lt;code&gt;Tree a&lt;/code&gt; 类型的递归字段，表示为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; 。使用二进制类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 组合各个字段的表示形式。</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行的第二个最常见的步骤是使用有界图元填充缓冲区，其工作方式如下。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 检查是否有留下来执行有限的原始足够的空间。如果存在，那么 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 将执行有界原语并使用更新的缓冲区调用下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 器会向其驱动程序发出信号，告知它需要新的缓冲区。该缓冲区必须至少与图元的边界一样大。我们可以使用有界原语通过融合连续 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的无缓冲区检查来减少无缓冲区检查的次数s。通过确保首先检查是否还有足够的空间，然后再决定如何编码给定值，我们还可以使用有界原语来简化表示缓冲区已满的信号的控制流程。</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">其中第二种情况,即一个类型与类型参数不等,但确实包含类型参数,这可能是令人惊讶的棘手问题。例如,下面的例子可以编译。</target>
        </trans-unit>
        <trans-unit id="099d78988af4538ef3d0e0fda8df1e66f037475f" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;../ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">第二个选项是添加标志&lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;../ghci#external-interpreter&quot;&gt;在单独的进程&lt;/a&gt;中运行解释器），该标志在单独的进程中运行解释器，在该进程中，它可以直接加载和运行配置文件的代码。无需两次编译代码，只需添加&lt;a href=&quot;../ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;即可。（此选项在GHC 8.0.x中是实验性的，但在将来的版本中可能会成为默认选项）。</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">第二个选项是添加标志&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程&lt;/a&gt;中运行解释器），该标志在单独的进程中运行解释器，在该进程中，它可以直接加载和运行配置文件的代码。无需两次编译代码，只需添加&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;即可。（此选项在GHC 8.0.x中是实验性的，但在将来的版本中可能会成为默认选项）。</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">文件的第二部分是按成本中心划分的程序中最昂贵的功能。在这种情况下，程序中只有一个重要功能，即 &lt;code&gt;fib&lt;/code&gt; ，它负责程序的时间和分配成本的100％。</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">本手册中有关种类多态性的部分介绍了如何对类型和类声明中&lt;a href=&quot;#inferring-variable-order&quot;&gt;的变量&lt;/a&gt;进行排序（推断类型/类声明中的变量顺序）。</target>
        </trans-unit>
        <trans-unit id="88af4d73b1b9951184f204460f7dd5ff35f03022" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;poly_kinds#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">本手册中有关种类多态性的部分介绍了如何对类型和类声明中&lt;a href=&quot;poly_kinds#inferring-variable-order&quot;&gt;的变量&lt;/a&gt;进行排序（推断类型/类声明中的变量顺序）。</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">适用于环境的选择器功能。</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">选择器的严格性注释(如有)。</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">选择器的解包性注释(如果有的话</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">这种情况下的语义是,所需实体的集合只由其导出项来定义;如果导出项列表中没有提到某个实体,它就不是必需的。这个特性背后的动机是允许库作者提供一个总括签名,其中包含了别人可能想要使用的每个函数的类型,而客户则将导出的函数缩减到他们实际需要的函数。例如,假设你继承了一个字符串的签名,你可以写一个这种形式的本地签名,只列出你需要的实体。</target>
        </trans-unit>
        <trans-unit id="692c1727fec760be3045c78464d8f7cd5b5023ee" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;do&lt;/code&gt; notation statements with &lt;code&gt;-XQualifiedDo&lt;/code&gt; is as follows:</source>
          <target state="translated">使用 &lt;code&gt;-XQualifiedDo&lt;/code&gt; 的 &lt;code&gt;do&lt;/code&gt; 表示法语句的语义如下：</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; 的语义非常简单。只要GHC找到一个 &lt;code&gt;rec&lt;/code&gt; 组，它将计算其绑定变量集，并将对 &lt;code&gt;MonadFix&lt;/code&gt; 类的基础 &lt;code&gt;mfix&lt;/code&gt; 值递归运算符mfix进行适当的调用。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell模式匹配的语义在Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2节中&lt;/a&gt;进行了描述。在此描述中添加一个额外的项目10，说：</target>
        </trans-unit>
        <trans-unit id="e60ab62bfd1aaf8462ce242eca667d79c6a73ddd" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell模式匹配的语义在Haskell报告的&lt;a href=&quot;https://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2节中&lt;/a&gt;进行了描述。在此描述中添加一个额外的项目10，说：</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">模式 &lt;code&gt;(&lt;/code&gt; ⟨exp⟨- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 的语义如下：</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">服务器端模板 Haskell 状态。这是由StartTH消息创建的。每个GHC类型检查的模块都会创建一个新的状态。</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">静态指针表中用于定位静态指针的键集不能保证在不同的程序二进制中保持稳定。或者换句话说,只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">已知的编码集取决于系统,但至少包括:</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">提示符下当前&lt;em&gt;作用域内&lt;/em&gt;的模块集。如上所述，此集合由 &lt;code&gt;import&lt;/code&gt; 和&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;修改，并且也会在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;之后自动修改。范围内的模块集可以用&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前正在&lt;em&gt;加载&lt;/em&gt;的模块集。该集合由&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 修改&lt;/a&gt;，并可以与&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;一起显示。</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">签名给出的是函数绑定或裸变量绑定的类型,而不是模式绑定。例如:</target>
        </trans-unit>
        <trans-unit id="a04023d825a1ad52cd3401b482121c628912e060" translate="yes" xml:space="preserve">
          <source>The simplest (degenerate case) of these is &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;, which determines whether a structure is empty or not. This only needs to look at the first element, and only to the extent of whether it exists or not, and not its value. In this case termination is guaranteed, and infinite input structures are fine. Its default definition is of course in terms of the lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">其中最简单的（简并的情况）为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; ，它确定结构是否为空。这只需要查看第一个元素，就其是否存在而言，而不是其价值。在这种情况下，可以保证端接，并且无限的输入结构也可以。它的默认定义当然是基于惰性文件 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 解码器的最简单的接口。如果解码器遇到错误，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或输入用完，它将调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e8c225c01f9faa3800585856cd9e7639c83f852" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 解码器的最简单的接口。如果解码器遇到错误，调用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或输入用完，它将调用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55de2210f5c6297aafeb6304d32b194dcb4402c4" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 解码器的最简单的接口。如果解码器遇到错误，调用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或输入用完，它将调用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="15de436f5ad58966f3fd02d798c87b26a0a4d2de" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。未检测到违反此条件的情况，如果超出了大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="4392c709b8ab747754f57b03eb8f62ce294291b7" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。未检测到违反此条件的情况，如果超出了大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，并且如果超出大小限制，则序列的行为不确定。这是不太可能在大多数应用中发生，但可能需要一些护理使用时 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ，特别是重复且特别是与组合 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9c06af16b62ace31432f475d864e0e1ea766afc" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，并且如果超出大小限制，则序列的行为不确定。这是不太可能在大多数应用中发生，但可能需要一些护理使用时 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ，特别是重复且特别是与组合 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8952fffc2c0bb8a184fb20f942742b2fb8968330" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，并且如果超出大小限制，则序列的行为不确定。这是不太可能在大多数应用中发生，但可能需要一些护理使用时 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ，特别是重复且特别是与组合 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。两个原始键中较大者的值用作 &lt;code&gt;c&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将保留原始键最大的值。</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 生成的字节序列的大小。</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">集合的大小不能超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">一个边界对所定义的子范围的大小。</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已调整大小的整数数据类型 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">您可以使用的大锤是 &lt;code&gt;INLINE&lt;/code&gt; 编译指示，因此使用：</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">解决办法是自己定义实例专用函数,用pragma防止过早内联,并给它一个rule。</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">该程序的源文件并不需要全部都在同一目录中。在&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项可以用来将目录添加到搜索路径（见&lt;a href=&quot;separate_compilation#search-path&quot;&gt;的搜索路径&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">来源地</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准数据声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准类型声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">专门的软件包名称 &lt;code&gt;this&lt;/code&gt; 可以用来指代当前包在建。</target>
        </trans-unit>
        <trans-unit id="2e75e752908ac1f2d1d245f44b5bc23796ac7067" translate="yes" xml:space="preserve">
          <source>The specialisation of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; to the case when &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; is a monad is called &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt;. The two are otherwise generally identical:</source>
          <target state="translated">对于&lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt;是单子的情况， &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 的特殊化称为 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 。否则，两者通常是相同的：&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">该规范以格式字符结束。</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">指定的文件包含在C程序，已编译的Haskell文件和C标头中。 &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; 是自动包含的。</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; ， &lt;code&gt;NominalDiffTime&lt;/code&gt; ， &lt;code&gt;CalendarDiffDays&lt;/code&gt; 和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 的说明符在语义上与其他类型分开。负时差的说明 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 通常为负（认为rem而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="509d7b73e79bd7157914844fa1c9246fd5e8d212" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; ， &lt;code&gt;NominalDiffTime&lt;/code&gt; ， &lt;code&gt;CalendarDiffDays&lt;/code&gt; 和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 的说明符在语义上与其他类型分开。负时差的说明 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 通常为负（认为rem而不是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="632d00023758f8684f4fce4f4f22a0178b84409a" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; ， &lt;code&gt;NominalDiffTime&lt;/code&gt; ， &lt;code&gt;CalendarDiffDays&lt;/code&gt; 和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 的说明符在语义上与其他类型分开。负时差的说明 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 通常为负（认为rem而不是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">接头 &lt;code&gt;$(blah1)&lt;/code&gt; 无法引用函数 &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; 是后面的声明组的一部分，因此是不可见的，类似地， &lt;code&gt;$(blah1)&lt;/code&gt; 也看不到 &lt;code&gt;h&lt;/code&gt; 的定义（因为它与 &lt;code&gt;$(blah1)&lt;/code&gt; 是同一声明组的一部分）（blah1）。但是，拼接 &lt;code&gt;$(blah1)&lt;/code&gt; 可以看到 &lt;code&gt;f&lt;/code&gt; 的定义（因为它在紧接的声明组中）。</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">拼接 &lt;code&gt;$(blah2)&lt;/code&gt; 会看到作为拼接相同的定义 &lt;code&gt;$(th2 ...)&lt;/code&gt; （但&lt;em&gt;没有&lt;/em&gt;任何绑定它创建）。</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; 将看到 &lt;code&gt;f&lt;/code&gt; 的定义-接头是顶级的，因此可见在先前声明组中的所有定义（即，模块中的所有定义，包括但不包括：接头本身）。</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;不能&lt;/em&gt;引用 &lt;code&gt;D&lt;/code&gt; -它在同一声明组中。</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">拼接 &lt;code&gt;$(th2 ...)&lt;/code&gt; 会看到的定义 &lt;code&gt;f&lt;/code&gt; ，通过创建的所有绑定 &lt;code&gt;$(th1 ...)&lt;/code&gt; ，定义 &lt;code&gt;h&lt;/code&gt; 和创建的所有绑定 &lt;code&gt;[qq|blah|]&lt;/code&gt; 他们都在前面声明组）。</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">拼接运行</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">默认情况下，堆栈配置文件中不计算堆栈。请参阅RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">堆栈跟踪通常可能以诸如 &lt;code&gt;GHC.List.CAF&lt;/code&gt; 之类的无信息的内容开始；这是GHC的优化程序的一种人工产物，它可以将异常提升到顶级，在顶级系统中，性能分析系统会将异常分配给成本中心&amp;ldquo; CAF&amp;rdquo;。但是， &lt;code&gt;+RTS -xc&lt;/code&gt; 不仅打印当前堆栈，它看起来更深，并在评估CAF时报告堆栈，并且它可能会报告其他堆栈，直到找到非CAF堆栈为止。在上面的示例中，下一个堆栈（在 &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 符之后）包含许多有关程序在评估 &lt;code&gt;head []&lt;/code&gt; 时正在执行的操作的信息。</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">堆栈溢出的消息。</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">独立语法针对新类型的泛化与普通 &lt;code&gt;deriving&lt;/code&gt; 子句的泛化完全相同（&lt;a href=&quot;#newtype-deriving&quot;&gt;针对新类型的广义派生实例&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="d40910594259296d4a228872f612655d7bafcd0a" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">独立语法针对新类型的泛化与泛化普通 &lt;code&gt;deriving&lt;/code&gt; 子句的方式完全相同（&lt;a href=&quot;newtype_deriving#newtype-deriving&quot;&gt;针对新类型的广义派生实例&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="6e89f770c17d80516fb68856c8f92154e2b891fa" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;../separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">独立派生声明不必与数据类型声明位于同一模块中。（但是要注意孤立实例的危险（&lt;a href=&quot;../separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">独立的派生声明不必与数据类型声明位于同一模块中。（但是要注意孤立实例的危险（&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="704c3d94002789a8f5e8c50c778edbf18c8986c7" translate="yes" xml:space="preserve">
          <source>The standalone kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">独立种类签名为 &lt;code&gt;T&lt;/code&gt; 指定了多态种类，并且该签名用于所有对 &lt;code&gt;T&lt;/code&gt; 的调用，包括递归调用。特别地， &lt;code&gt;T&lt;/code&gt; 的递归使用是 &lt;code&gt;Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db11743c6607fc01898eb1dded2916b4eb86f339" translate="yes" xml:space="preserve">
          <source>The standard C wndproc for every window class registered by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:registerClass&quot;&gt;registerClass&lt;/a&gt;&lt;/code&gt; is a C function pointer provided with this library. It in turn delegates to a Haskell function pointer stored in &lt;code&gt;gWLP_USERDATA&lt;/code&gt;. This action creates that function pointer. All Haskell function pointers must be freed in order to allow the objects they close over to be garbage collected. Consequently, if you are replacing a window closure previously set via this method or indirectly with &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindow&quot;&gt;createWindow&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; you must free it. This action returns a function pointer to the old window closure for you to free. The current window closure is freed automatically by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; when it receives &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于通过注册每个窗口类标准C的WndProc &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:registerClass&quot;&gt;registerClass&lt;/a&gt;&lt;/code&gt; 是提供与此库C函数指针。依次委托给存储在 &lt;code&gt;gWLP_USERDATA&lt;/code&gt; 中的Haskell函数指针。此操作将创建该函数指针。必须释放所有Haskell函数指针，以允许对其关闭的对象进行垃圾回收。因此，如果要替换以前通过此方法设置的窗口关闭，或用 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindow&quot;&gt;createWindow&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; 间接地关闭它，则必须释放它。此操作将返回指向旧窗口关闭功能的函数指针，以供您释放。 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; 在收到 &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; 时会自动释放当前的窗口关闭。</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">标准的C99 &lt;code&gt;fenv.h&lt;/code&gt; 标头提供了用于检查和修改浮点单元的状态的操作。特别是，可以更改浮点运算所使用的舍入模式，并且可以测试异常标志。</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">标准的CPUTime库。</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">标准的IO库。</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS X上的标准假设是，动态库将在构建时用&amp;ldquo;安装名称&amp;rdquo;标记，这是库文件的完整最终安装路径。随后链接到该库的任何库或可执行文件（即使尚未安装）也将选择该路径作为其运行时搜索位置。直接使用ghc进行编译时，默认情况下会将安装名称设置为生成位置。您可以使用 &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; 选项（将 &lt;code&gt;-install_name&lt;/code&gt; 传递给Apple链接程序）覆盖此选项。 Cabal为您做到这一点。它将自动将动态库的安装名称设置为最终安装位置的绝对路径。</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">因此，扩展了标准默认规则：当所有未解决的约束都涉及标准类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 时，将应用默认值；至少一个是数字类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">标准函数 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; 锁定稳定指针表，释放给定的稳定指针，然后再次解锁稳定指针表。一次释放许多稳定的指针时，通常一次锁定和解锁表会更有效。</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">编码和解码文本的标准功能很严格，也就是说，它们对无效输入会抛出异常。这通常对现实世界的输入没有帮助，因此存在替代功能，这些功能接受用于处理无效输入的自定义处理程序。这些 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; 处理程序是常规的Haskell函数。您可以使用此模块中预先提供的功能之一，也可以编写自己的自定义处理程序。</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">与 &lt;code&gt;callCC&lt;/code&gt; 一起使用的标准习惯用法是提供lambda表达式来命名延续。然后，即使在嵌套计算中有很多层，在其范围内的任何地方调用命名的连续都将退出计算。</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">标准库不直接支持此设备类型，但是用户实现应期望以任意顺序在目录中提供文件名列表，并以 &lt;code&gt;'\0'&lt;/code&gt; 字符分隔，但不包括 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 名称。另请参见 &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; 。目录（除零位以外）不支持搜寻操作。</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">系统加载程序的标准库搜索路径，在某些系统上，可以通过设置 &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量来覆盖该路径。</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">执行栈的状态</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">语句 &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; 表示&amp;ldquo; 在 &lt;code&gt;IO&lt;/code&gt; monad中执行 &lt;code&gt;return 42&lt;/code&gt; ，并将结果绑定到 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。然后，我们可以在以后的语句中使用 &lt;code&gt;x&lt;/code&gt; ，例如像上面一样打印它。</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">该语句不是绑定，或者它是仅绑定一个变量的单子绑定（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">存储值并不代表大的虚拟数据结构,可以懒得计算。</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">从抛出异常到处理异常的过程中,通过绕过约束函数,将能抛出异常的计算组合起来的策略。</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="9cc9078a7f0ba79c4a62093f3f0a698571e804e5" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;` is the least likely to be useful, structures that support efficient sequencing &lt;em&gt;only&lt;/em&gt; right-to-left are not at all common.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 最没有用处，&lt;em&gt;仅&lt;/em&gt;支持从右到左高效排序的结构根本不常见。</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型要求整个字符串一次放入内存。惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型能够使用较小的内存占用量流传输比内存大的字符串。在许多情况下，分块流传输的开销使惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型比其严格对应类型慢，但并非总是如此。有时，一个功能在一个模块中的时间复杂度可能会因另一个模块的内部结构不同而有所不同。</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">严格性分析器指出何时可以&amp;ldquo;严格地&amp;rdquo;对待函数中的参数和变量（即始终在函数中对它们进行评估）。这使GHC可以进行某些优化，例如取消装箱，否则将不适用，因为当应用于延迟参数时，它们会更改程序的语义。</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的严格程度。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">在编译过程中，GHC推断字段的严格性。尽管 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 有九种不同的组合，但是GHC决定的严格性最终将是惰性，严格或未打包的一种。GHC决定的内容受用户在源代码中编写的内容以及GHC标志的影响。例如，请考虑以下数据类型：</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">编译器对选择器推断的严格程度。</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">该模块中的字符串功能是对应于用户输入的字符序列,如方向键和功能键。</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">软件包名称后括号中的字符串是已安装的软件包ID：通常以软件包名称和版本开头，并以从已编译的软件包派生的哈希字符串结尾。软件包之间的依赖关系以已安装的软件包ID表示，而不仅仅是软件包和版本。例如，看一下 &lt;code&gt;haskell98&lt;/code&gt; 软件包的依赖关系：</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">有向图的强连接分量,反向拓扑排序。</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">有向图的强连接组件，按逆向拓扑排序。该函数与 &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; 相同，只是保留了有关每个节点的所有信息。当您希望申请该接口用于 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 来（一些）的结果 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; ，所以你不想失去相关性信息。</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">图的强连接分量,按反向拓扑顺序。</target>
        </trans-unit>
        <trans-unit id="83452083a9ce72a229493bf8b77c24809f89e2bb" translate="yes" xml:space="preserve">
          <source>The structure definition actually admits trees that are unbounded on either or both sides. The only fold that can plausibly terminate for a tree unbounded on both left and right is &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt;, when defined as shown below. The default definition in terms of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; diverges if the tree is unbounded on the left. Here we define a variant that avoids travelling down the tree to find the left-most element and just examines the root node.</source>
          <target state="translated">结构定义实际上允许两侧或两侧无界的树。如下所示定义时，唯一可能对左右两侧无界的树终止的折叠为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:null&quot;&gt;null&lt;/a&gt;&lt;/code&gt; 。如果树在左侧是无界的，则根据文件 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 定义的默认定义会有所不同。在这里，我们定义了一个变体，该变体避免沿树向下移动以找到最左侧的元素，而仅检查根节点。</target>
        </trans-unit>
        <trans-unit id="3e101feb4c7c413d89ff2a9de0dbd05a34c46cb1" translate="yes" xml:space="preserve">
          <source>The subset of type variables quantified by the GADT constructor that are mentioned in the return type. Note that the order of these variables follows the same principles as in &lt;a href=&quot;type_applications#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;. If the constructor explicitly quantifies its type variables at the beginning of the type, then the field selector type will quantify them in the same order (modulo any variables that are dropped due to not being mentioned in the return type). If the constructor implicitly quantifies its type variables, then the field selector type will quantify them in the left-to-right order that they appear in the field itself.</source>
          <target state="translated">返回类型中提到的由GADT构造函数量化的类型变量的子集。请注意，这些变量的顺序遵循与&lt;a href=&quot;type_applications#scopedsort&quot;&gt;指定变量&lt;/a&gt;的顺序相同的原则。如果构造函数在类型的开头显式量化其类型变量，则字段选择器类型将以相同顺序对其进行量化（对由于未在返回类型中提及而丢弃的所有变量进行模运算）。如果构造函数隐式地量化其类型变量，则字段选择器类型将按照它们在字段本身中出现的从左到右的顺序对其进行量化。</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">在 &lt;code&gt;n+k&lt;/code&gt; 模式中，减法运算和大于等于检验使用范围内的 &lt;code&gt;(-)&lt;/code&gt; 和 &lt;code&gt;(&amp;gt;=)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">由于输入不足而无法解码的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 后缀。</target>
        </trans-unit>
        <trans-unit id="8b56d651e782e4c6fee2c1292b2f284d6d8eec70" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">由于输入不足而无法解码的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 后缀。</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">概括 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; 的动作集合的总和。</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">超类实例应满足以下要求。</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">下面列出了GHC定义的符号。要检查哪些符号是由你本地安装的GHC定义的,下面的技巧很有用。</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">以下小节将详细说明模式同义词的语法和语义。也有在其它更多细节&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;纸&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">最小完整定义的语法是:</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">提示 &lt;code&gt;*module&lt;/code&gt; 中的语法表明，是&amp;ldquo; 模块&amp;rdquo;的完整顶级范围才有助于在提示中键入的表达式的范围。如果没有 &lt;code&gt;*&lt;/code&gt; ，则仅显示模块的导出。</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">语法是</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">除了（a）关键字 &lt;code&gt;deriving&lt;/code&gt; 和（b）缺少 &lt;code&gt;where&lt;/code&gt; 部分之外，该语法与普通实例声明的语法相同。</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">语法与 &lt;code&gt;case&lt;/code&gt; 表达式相同，除了替代方法的主体是命令而不是表达式。转换类似于 &lt;code&gt;if&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">表达式的成本中心注释的语法是</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCi提示符下接受的语句的语法与Haskell &lt;code&gt;do&lt;/code&gt; 表达式中的语句的语法完全相同。但是，这里没有monad重载：在提示符下键入的语句必须在 &lt;code&gt;IO&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">值的语法取决于字段。各种字段类型有:</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">下表总结了每一种模式同义词的使用范围。</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">模板文件(见下文)。</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">子计算终止时（正常或通过异常）释放临时存储，因此在该函数返回后，&lt;em&gt;不得&lt;/em&gt;使用指向临时存储的指针。</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">&amp;ldquo;未注册&amp;rdquo;一词的真正含义是&amp;ldquo;通过香草C编译&amp;rdquo;，从而禁用了GHC通常用来使程序运行更快的某些特定于平台的技巧。当编译未注册的内容时，GHC会简单地生成一个通过gcc编译的C文件。</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">术语级别的语法相似。前导和前杠（ &lt;code&gt;|&lt;/code&gt; ）指示它是哪个替代项。这是上面显示的两种类型的术语：</target>
        </trans-unit>
        <trans-unit id="c93728cc66c8f173dab941c09797eacc6f5110f5" translate="yes" xml:space="preserve">
          <source>The third and final argument is a &lt;code&gt;Foldable&lt;/code&gt; structure containing elements &lt;code&gt;(a, b, c, &amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">第三个也是最后一个参数是包含元素 &lt;code&gt;(a, b, c, &amp;hellip;)&lt;/code&gt; 的 &lt;code&gt;Foldable&lt;/code&gt; 结构。</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">该文件的第三部分也是最后一部分提供了按成本中心堆栈划分的配置文件细分。这大致是程序的调用树配置文件。在上面的示例中，很明显，对 &lt;code&gt;fib&lt;/code&gt; 的昂贵调用来自 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">第三例声明不服从覆盖条件;事实上(有点奇怪)定义。</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">对于每种新类型 &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; ，都存在第三种实例，它有两个变体，即</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">第三种通配符是&lt;em&gt;Extra-constraints通配符&lt;/em&gt;。额外约束通配符的存在指示在类型检查期间可以推断任意数量的额外约束，并将其添加到类型签名中。在下面的示例中，额外约束通配符用于推断三个额外约束。</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">该线程在 &lt;code&gt;MVar&lt;/code&gt; 上被阻止，但是没有其他对 &lt;code&gt;MVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">该线程正在等待重试STM事务，但是没有其他涉及任何 &lt;code&gt;TVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">使用 &lt;code&gt;pthread_kill()&lt;/code&gt; 向发出外部调用的线程发送 &lt;code&gt;SIGPIPE&lt;/code&gt; 信号。这通常足以导致阻塞的系统调用返回 &lt;code&gt;EINTR&lt;/code&gt; （默认情况下，GHC为 &lt;code&gt;SIGPIPE&lt;/code&gt; 安装一个空信号处理程序，以覆盖默认行为，即立即终止进程）。</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">线程运行系统具有以下优点。</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">程序给定部分所花费的时间和分配以两种方式显示：&amp;ldquo;个人&amp;rdquo;，即由该成本中心堆栈所覆盖的代码所产生的成本；以及&amp;ldquo;继承&amp;rdquo;，其包括所有成本所引起的成本该节点的子代。</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">气象局本身所耗费的时间</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">在同步化过程中,GC之前所经过的时间。</target>
        </trans-unit>
        <trans-unit id="4b330c6f47b52569d23f62fae825fc0e09a81ec0" translate="yes" xml:space="preserve">
          <source>The time elapsed during the post-mark pause phase of the concurrent nonmoving GC.</source>
          <target state="translated">同时不动的GC的标记后暂停阶段所经过的时间。</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">时间地点。</target>
        </trans-unit>
        <trans-unit id="1637c3729549ceeb82c37601b6dec6b827e71006" translate="yes" xml:space="preserve">
          <source>The time profiling mode enabled by &lt;a href=&quot;profiling#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; also emits sample events to the eventlog. At the start of profiling the tick interval is emitted to the eventlog and then on each tick the current cost centre stack is emitted. Together these enable a user to construct an approximate track of the executation of their program.</source>
          <target state="translated">&lt;a href=&quot;profiling#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt;启用的时间概要分析模式还将样本事件发送到事件日志。在配置开始时，滴答间隔被发送到事件日志，然后在每个滴答中发出当前的成本中心堆栈。这些共同使用户能够构建其程序执行的大致轨迹。</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">时间值，如果无法使用给定格式解析输入，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="806aa42ce85483bc45bf5f50020217f50c8cf737" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">时间值，如果无法使用给定格式解析输入，则为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eab7f7de4b2ca2df8fd007dac9308197876dafad" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">时间值，如果无法使用给定格式解析输入，则为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">时间值。</target>
        </trans-unit>
        <trans-unit id="431cd0d00a93588e67b435b97058b6600e1ca6b4" translate="yes" xml:space="preserve">
          <source>The top of an instance declaration only permits very specific forms of types. To make more precise what forms of types are or are not permitted, we provide a BNF-style grammar for the tops of instance declarations below:</source>
          <target state="translated">实例声明的顶部只允许非常特殊的类型形式。为了更精确地说明哪些类型形式是允许的,哪些是不允许的,我们在下面为实例声明的顶部提供了一个BNF风格的语法。</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">程序在整个运行过程中分配的总字节数。</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">进行垃圾收集的总次数。</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">程序执行的总时间（以秒为单位）。</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">译文经过精心设计,使bang模式对递归和多态绑定以及直接的非递归绑定都有意义。</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">这种形式的翻译使用 &lt;code&gt;loop&lt;/code&gt; 组合器，因此有关的箭头必须属于 &lt;code&gt;ArrowLoop&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">三元单体变换器,它将一个单体映射到一个等价单体上。</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">孤儿的麻烦在于，GHC必须主动读取所有孤儿模块的接口文件，以防万一它们的实例或规则起作用，而无论模块接口是否可以使用。有关详细信息，请参见&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">两者的处理方式相同，只是后者可能会将类型变量带入范围（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexical作用域类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1156ff53b3f2cd0af552bcc10ee29d6be241cefb" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">两者的处理方式相同，只是后者可能会将类型变量带入范围（请参阅&lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexical作用域类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">这两个构造函数具有您期望的类型：</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">两个函数 &lt;code&gt;comp1&lt;/code&gt; 和 &lt;code&gt;comp2&lt;/code&gt; 具有相同的语义，但是 &lt;code&gt;comp1&lt;/code&gt; 在应用于&lt;em&gt;两个&lt;/em&gt;参数时将被内联，而 &lt;code&gt;comp2&lt;/code&gt; 需要&lt;em&gt;三个&lt;/em&gt;。如果您说这可能会有很大的不同</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">两组选项的初始化如下。首先，&lt;a href=&quot;#ghci-dot-files&quot;&gt;如.ghci和.haskeline文件中&lt;/a&gt;所述初始化两组选项。然后，对交互选项进行如下修改：</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;命令分别检查两组选项，不带参数。例如，在干净的GHCi会话中，我们可能会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 类型在角色表示中具有其参数，这通常是最常见的情况。 &lt;code&gt;Simple Age&lt;/code&gt; 与 &lt;code&gt;Simple Int&lt;/code&gt; 具有相同的表示形式。类型 &lt;code&gt;Complex&lt;/code&gt; ，而另一方面，有其在标称的作用参数，因为 &lt;code&gt;Complex Age&lt;/code&gt; 和 &lt;code&gt;Complex Int&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样的。最后，尽管 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Bool&lt;/code&gt; 无关，但 &lt;code&gt;Phant Age&lt;/code&gt; 和 &lt;code&gt;Phant Bool&lt;/code&gt; 具有相同的表示形式。</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">类型 &lt;code&gt;StreamPermParser s st a&lt;/code&gt; 表示一个置换分析器，当由 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 函数转换时，它将分析具有用户状态 &lt;code&gt;st&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 流，并在成功时返回a类型 &lt;code&gt;a&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="6120b118bdba0e4c010f34fbf9eb9b4980f33ce0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="ccdd21e1ff03d8afd75bec7ff6200ae1990727b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">类型 &lt;code&gt;t&lt;/code&gt; 是任意类型。</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">类型检查器有时会在错误消息中显示类型环境的片段，但是最多显示此标志设置的最大数量。使用 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 将其关闭可提供无限数量。从语法上讲，顶级绑定通常也被排除（因为它们可能很多），但是 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 也包括它们。</target>
        </trans-unit>
        <trans-unit id="b4f3436c445b81b9b8c7c9be8963efa0b16fdd8a" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; includes them too.</source>
          <target state="translated">类型检查器有时会在错误消息中显示类型环境的片段，但是最多显示此标志设置的最大数量。使用 &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 将其关闭可提供无限数量。从语法上讲，顶级绑定通常也被排除（因为它们可能很多），但是 &lt;code&gt;-fno-max-relevant-binds&lt;/code&gt; 也包括它们。</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; 是可以安全地将任何提升类型强制转换为反向的类型。更具体地说，对于提升类型 &lt;code&gt;t&lt;/code&gt; 和值 &lt;code&gt;x :: t&lt;/code&gt; ， &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; 等效于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">类型构造函数 &lt;code&gt;Proxy#&lt;/code&gt; 用于见证某些类型变量。当您要传递代理值以进行诸如对类型应用程序建模之类的操作时，可以使用它。一个 &lt;code&gt;Proxy#&lt;/code&gt; 不仅拆箱，它也有一个多态样了，有没有运行时表示，是完全免费的。</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 都是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">类型函数 &lt;code&gt;Item&lt;/code&gt; 返回结构 &lt;code&gt;l&lt;/code&gt; 的项目类型。</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">在一个类型 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示可以是任何类型，它是比原来的功能的类型少的多态性。具体来说，如果原始函数为 &lt;code&gt;f&lt;/code&gt; ,则说明语用</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">当然,该类型也可以包含一个类上下文。</target>
        </trans-unit>
        <trans-unit id="0da5e4c5461995d9d1a9807b0c5f1ea4b4a2d0bb" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; can also be modified, as seen here for a graded monad:</source>
          <target state="translated">也可以修改 &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; 的类型，如以下针对分级monad所示：</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的类型令人头疼，但是在操作上它是列表折叠的简单概括。</target>
        </trans-unit>
        <trans-unit id="2884ac6a531d323777978ba398fbe58aa7e3a183" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; 的类型在Haskell 98中是非法的，因为它包含约束 &lt;code&gt;Eq a&lt;/code&gt; ，该约束仅约束类类型变量（在这种情况下为 &lt;code&gt;a&lt;/code&gt; ）。更准确地说，如果以下情况被拒绝，则拒绝类方法签名中的约束：</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; 的类型在Haskell 98中是非法的，因为它包含约束 &lt;code&gt;Eq a&lt;/code&gt; ，该约束仅约束类类型变量（在这种情况下为 &lt;code&gt;a&lt;/code&gt; ）。这种情况 &lt;code&gt;a&lt;/code&gt; ）。更准确地说，如果以下情况被拒绝，则拒绝类方法签名中的约束：</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">任何一种 &lt;code&gt;case&lt;/code&gt; 提到的任何自由变量的类型都必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">不可变的非严格（装箱）数组的类型，其索引在 &lt;code&gt;i&lt;/code&gt; 中，元素在 &lt;code&gt;e&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">非空流的类型</target>
        </trans-unit>
        <trans-unit id="e4eb98f38164f85b0e9e25152a191c387afddc54" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can change the type of the default method by requiring a different context using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt;, you can specify a default method that uses that generic implementation. But your default implementation can only be used if the constraints are satisfied, therefore you need to change the type of the default method</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 方法的类型为 &lt;code&gt;[a]&lt;/code&gt; ，这也是默认方法的类型。您可以通过使用扩展名&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;要求不同的上下文来更改默认方法的类型。例如，如果你在一个类写一个通用实现枚举的 &lt;code&gt;GEnum&lt;/code&gt; 与方法 &lt;code&gt;genum&lt;/code&gt; ，你可以指定一个默认的方法使用该通用实现。但是您的默认实现只能在满足约束条件的情况下使用，因此您需要更改默认方法的类型</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 方法的类型为 &lt;code&gt;[a]&lt;/code&gt; ，这也是默认方法的类型。您可以取消此限制，并使用扩展名&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;为默认方法提供其他类型。例如，如果你在一个类写一个通用实现枚举的 &lt;code&gt;GEnum&lt;/code&gt; 与方法 &lt;code&gt;genum&lt;/code&gt; 来讲 &lt;code&gt;GHC.Generics&lt;/code&gt; ，你可以指定一个默认的方法，它使用通用的实现：</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">正如 &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; 所示，参数的类型通常可以比所需的类型更一般。（ &lt;code&gt;reverse&lt;/code&gt; 不需要 &lt;code&gt;Ord&lt;/code&gt; 约束。）</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">整个 &lt;code&gt;case&lt;/code&gt; 表达式的类型必须是固定的。</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">被更新的表达式的类型不会被推断出来,也不会进行约束解,所以以下内容会被视为模棱两可而被拒绝。</target>
        </trans-unit>
        <trans-unit id="8edd129d0ca324d51366c3bf0ae7aef1ee10d380" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt;).</source>
          <target state="translated">字段的类型（ &lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, Bool)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="905d4fae66a0da2db8e9ac3bf1ac52a2cf5ff066" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, x)&lt;/code&gt;).</source>
          <target state="translated">字段的类型（ &lt;code&gt;&amp;lt;...&amp;gt; -&amp;gt; forall e. Either e (a, x)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f8af0edfcb4865af68ec3f581c18da4cc40a7334" translate="yes" xml:space="preserve">
          <source>The type of the field (&lt;code&gt;&amp;lt;...&amp;gt; forall e. Either e a&lt;/code&gt;).</source>
          <target state="translated">字段的类型（ &lt;code&gt;&amp;lt;...&amp;gt; forall e. Either e a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">对象的类型必须是 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 的实例，以确保只能将单态类型的对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 。要将多态对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; ，请为其提供单态类型签名。例如：</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">该类型保存词法分析器是工作记录的 &lt;code&gt;s&lt;/code&gt; 与国家流 &lt;code&gt;u&lt;/code&gt; 在单子 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">审稿人的类型必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">类型参数 &lt;code&gt;c_m&lt;/code&gt; 在 &lt;code&gt;T1&lt;/code&gt; 到 &lt;code&gt;Tk&lt;/code&gt; 的每个类型变量中出现一次。想象一个没有这种情况的课堂。例如：</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数应该是 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">当然,类型参数必须都是类型变量,其中一些(但不一定全部)可以是类参数。每个类参数在每个关联类型中最多只能使用一次,但有些可以省略,它们的顺序也可以不在类头中。因此,下面这个人为的例子是可以接受的。</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 被列表的无限嵌套替换，则这对中的类型模式相等。对于类型健全性，必须拒绝此类实例。</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名使类型变量 &lt;code&gt;a&lt;/code&gt; 进入范围，这是因为显式的 &lt;code&gt;forall&lt;/code&gt; （&lt;a href=&quot;#decl-type-sigs&quot;&gt;声明类型签名&lt;/a&gt;）。由结合的类型变量 &lt;code&gt;forall&lt;/code&gt; 的范围在所附的值声明的整个定义。在此示例中，类型变量 &lt;code&gt;a&lt;/code&gt; 覆盖 &lt;code&gt;f&lt;/code&gt; 的整个定义，包括 &lt;code&gt;ys&lt;/code&gt; 的类型签名。在Haskell 98中，不可能为 &lt;code&gt;ys&lt;/code&gt; 声明一个类型。作用域类型变量的主要好处是可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">类型类的默认方法的类型签名必须与相应的主方法的类型签名采用相同的形式。否则，类型检查器将拒绝该类的定义。&amp;ldquo;采用相同的形式&amp;rdquo;是指默认类型签名应仅在其上下文中与主要类型签名不同。因此，如果您有一个方法 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">实例声明中的类型签名必须比类声明中的类型签名更多态(或相同),用实例类型实例化。例如,这样就可以了。</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">类型签名可能有量化的类型变量,但没有出现在结果类型中。</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; 的类型签名会通知用户其正确性取决于未经证实的猜想。如果使用该功能，则用户必须通过以下方式确认依赖关系：</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">每个构造函数的类型签名都是独立的，并且像往常一样隐式地进行通用量化。特别是，&amp;ldquo; &lt;code&gt;data T a where&lt;/code&gt; &amp;rdquo;标头中的类型变量没有作用域，并且不同的构造函数可能具有不同的通用量化类型变量：</target>
        </trans-unit>
        <trans-unit id="600179f267be505bf0dea2d828c9b5066c60f915" translate="yes" xml:space="preserve">
          <source>The type signatures for &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; all begin with an outermost &lt;code&gt;forall&lt;/code&gt;, so every type variable in these signatures must be explicitly bound by a &lt;code&gt;forall&lt;/code&gt;. Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, since they explicitly quantify &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. On the other hand, &lt;code&gt;h&lt;/code&gt; does not explicitly quantify &lt;code&gt;b&lt;/code&gt;, so GHC will reject its type signature for being improperly scoped.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;h&lt;/code&gt; 的类型签名均以最外层的 &lt;code&gt;forall&lt;/code&gt; 开头，因此这些签名中的每个类型变量都必须由 &lt;code&gt;forall&lt;/code&gt; 显式绑定。无论 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 服从 &lt;code&gt;forall&lt;/code&gt; -或全无的规则，因为他们明确地量化 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。另一方面， &lt;code&gt;h&lt;/code&gt; 并未明确量化 &lt;code&gt;b&lt;/code&gt; ，因此GHC将因其作用域不正确而拒绝其类型签名。</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">用于尺寸和sizeBounds的类型。</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">类型变量 &lt;code&gt;a&lt;/code&gt; 没有其他限制</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">此处使用的类型变量 &lt;code&gt;e&lt;/code&gt; 表示元素类型，而 &lt;code&gt;ce&lt;/code&gt; 是容器本身的类型。在此框架内，我们可能想为列表或特征函数（两者都可用于表示任何相等类型的集合），位集（可用于表示字符的集合）或哈希定义此类的实例。表（可用于表示其元素具有哈希功能的任何集合）。省略标准实施细节，这将导致以下声明：</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">类型变量由单一的，语法上可见，最外面的量化 &lt;code&gt;forall&lt;/code&gt; 的类型签名的。例如，GHC将拒绝以下所有示例：</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">类型变量（如果给定的话）可能是显式的，所以我们也可以这样写 &lt;code&gt;Foo&lt;/code&gt; 的头文件：</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">类型变量 &lt;code&gt;vk+1...vn&lt;/code&gt; 不在类型 &lt;code&gt;t&lt;/code&gt; ， &lt;code&gt;s1..sk&lt;/code&gt; 或 &lt;code&gt;t1..tj&lt;/code&gt; 中出现。</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;instance&lt;/code&gt; 声明的头部中的类型变量作用于 &lt;code&gt;where&lt;/code&gt; 部分中定义的方法。您甚至不需要显式的 &lt;code&gt;forall&lt;/code&gt; （尽管在 &lt;code&gt;instance&lt;/code&gt; 声明中允许显式的 &lt;code&gt;forall&lt;/code&gt; ；请参阅&lt;a href=&quot;#explicit-foralls&quot;&gt;显式通用量化（forall）&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="4527110e436f59f5f03d4993fa8ef3b4a17f7938" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">通过使用&lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;语言扩展，可以使用显式 &lt;code&gt;forall&lt;/code&gt; 量化外部声明类型中的类型变量，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="1f03bbab3fd03c0f04b9e0c0fedb642fb00b2844" translate="yes" xml:space="preserve">
          <source>The type variables in the type of a foreign declaration may be quantified with an explicit &lt;code&gt;forall&lt;/code&gt; by using the &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; language extension, as in the following example:</source>
          <target state="translated">通过使用&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;语言扩展，可以使用显式 &lt;code&gt;forall&lt;/code&gt; 量化外部声明类型中的类型变量，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">通常，类型族方程右侧的类型变量必须由左侧明确绑定。对于&lt;em&gt;种类&lt;/em&gt;变量，此限制放宽了，但是，因为允许右侧提到隐式绑定的种类变量。例如，这些是合法的：</target>
        </trans-unit>
        <trans-unit id="cf551ca6fe716e0e3656d418ee13c9c2e0107f55" translate="yes" xml:space="preserve">
          <source>The type variables quantified by the data type head (&lt;code&gt;forall a b. &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">由数据类型头（总的 &lt;code&gt;forall a b. &amp;lt;...&amp;gt;&lt;/code&gt; ）量化的类型变量。</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">类型变量： &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型级别等效于 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">类型安全浇注操作</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，类 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 以及在Word32和Float以及Word64和Double之间进行转换。</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; 再次是类型级别的代理，仅用于创建 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的多个变体。</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ，以及类 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">单纯的类型是不会执行这些法律的,所以你要自己去查。</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">细孔配合中其他孔的类型显示在输出中，例如 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; 是孔 &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; 的细化。如果关闭此标志，则输出将仅显示 &lt;code&gt;foldl1 _&lt;/code&gt; ，可以将其直接替换为孔，而无需 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d81a104972bf197c2bbed8aa492a5ea327869a2" translate="yes" xml:space="preserve">
          <source>The types of the operations picked for desugaring must produce an expression which is accepted by the typechecker. But other than that, there are no specific requirements on the types.</source>
          <target state="translated">选取的去ugaring操作的类型必须产生一个能被tyechecker接受的表达式。但除此之外,对类型没有具体要求。</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">未装箱元组的典型用法是简单地返回多个值，并将这些多个结果与 &lt;code&gt;case&lt;/code&gt; 表达式绑定在一起，因此：</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">地图列表的结合,并进行组合操作。</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d32217b38bffdaa9ca587e9d6a40f750e6e5bfb9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79dd47dfab111b7b4fefeb6ad5d0a0d8f7cfd08d" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b99c2dfae5341557cba637c4f3ef989142689dd9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="907c04acd0a9bc47be90c69632d4ff6df0869303" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">地图列表的结合。</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="06da55697aaeea01f68121fc5dda49aec58e2fa9" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="61303d04994d9cc4ddac01a7c1400e746e7c55a8" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5359b26f8252c95c2fa3287a62d5ed9a07ab46e7" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4ab744c66494b3202c4bf443d168cb8c1c43690a" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">一组列表的结合。</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">可折叠结构中集合的并集：（ &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">该组的唯一数字ID(gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">将单元类型 &lt;code&gt;()&lt;/code&gt; 和列表类型 &lt;code&gt;[]&lt;/code&gt; 添加到标准类型列表的开头，这些类型在进行类型默认设置时会尝试使用。</target>
        </trans-unit>
        <trans-unit id="bd2f4c60db39330dbc4e1160f8c12c21318aa37a" translate="yes" xml:space="preserve">
          <source>The universal type variables (&lt;code&gt;forall a. &amp;lt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">通用类型变量（全部 &lt;code&gt;forall a. &amp;lt;...&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的解包性。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="f73f2fa8215550228fa8f2f4b091ed3e8ae1ac99" translate="yes" xml:space="preserve">
          <source>The unqualified &lt;code&gt;do&lt;/code&gt; syntax is convenient for writing monadic code, but it only works for data types that provide an instance of the &lt;code&gt;Monad&lt;/code&gt; type class. There are other types which are &amp;ldquo;monad-like&amp;rdquo; but can&amp;rsquo;t provide an instance of &lt;code&gt;Monad&lt;/code&gt; (e.g. indexed monads, graded monads or relative monads), yet they could still use the &lt;code&gt;do&lt;/code&gt; syntax if it weren&amp;rsquo;t hardwired to the methods of the &lt;code&gt;Monad&lt;/code&gt; type class. &lt;code&gt;-XQualifiedDo&lt;/code&gt; comes to make the do syntax customizable in this respect. It allows you to mix and match &lt;code&gt;do&lt;/code&gt; blocks of different types with suitable operations to use on each case:</source>
          <target state="translated">不限定条件的 &lt;code&gt;do&lt;/code&gt; 语法对于编写monadic代码很方便，但是它仅适用于提供 &lt;code&gt;Monad&lt;/code&gt; 类型类实例的数据类型。还有其他一些类型类似于&amp;ldquo; monad&amp;rdquo;，但不能提供 &lt;code&gt;Monad&lt;/code&gt; 的实例（例如，索引的monad，分级的monad或相对monad），但是如果未将其硬连接到方法的话，它们仍然可以使用 &lt;code&gt;do&lt;/code&gt; 语法。在 &lt;code&gt;Monad&lt;/code&gt; 类型的类。 &lt;code&gt;-XQualifiedDo&lt;/code&gt; 在这方面使do语法可自定义。它允许您混合使用不同类型的 &lt;code&gt;do&lt;/code&gt; 块和匹配的块，并在每种情况下使用合适的操作：</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">这样的结果是，如果您的Haskell线程在外部调用中被阻塞，则 &lt;code&gt;hs_exit()&lt;/code&gt; 可能会挂起（或可能忙于等待），直到调用返回。因此，最好在调用 &lt;code&gt;hs_exit()&lt;/code&gt; 时确保系统中没有此类线程。这包括执行I / O的任何线程，因为可以使用阻止外部调用来实现I / O（或可以不取决于I / O的类型和平台）。</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译 &lt;code&gt;Danger&lt;/code&gt; 限制了可用于&lt;a href=&quot;#safe-language&quot;&gt;安全子集&lt;/a&gt;的Haskell功能。这包括禁止使用 &lt;code&gt;unsafePerformIO&lt;/code&gt; ，模板Haskell，纯FFI函数，规则和限制重叠实例的操作。该&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志也限制了模块可以通过进口 &lt;code&gt;Danger&lt;/code&gt; ，只有那些被认为是可信的。受信任的模块是使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的模块，其中GHC提供了机械确保代码安全的保证。或那些使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的模块，其中模块作者声称该模块是安全的。</target>
        </trans-unit>
        <trans-unit id="7f1408b97746788b10921b1206ca1a3f3ea7a9dc" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示居住类型的类型取决于&lt;a href=&quot;exts/poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;扩展名，该扩展名在将来的版本中将默认关闭，然后可能会删除。&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30中&lt;/a&gt;对此原因和弃用时间表进行了说明。</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示居住类型的类型取决于&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;扩展名，该扩展名在将来的版本中将默认关闭，然后可能会删除。&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30中&lt;/a&gt;对此原因和弃用时间表进行了说明。</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">在 &lt;code&gt;?y&lt;/code&gt; 的绑定中使用 &lt;code&gt;?x&lt;/code&gt; 不会&amp;ldquo;看到&amp;rdquo; &lt;code&gt;?x&lt;/code&gt; 的绑定，因此 &lt;code&gt;f&lt;/code&gt; 的类型为</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">稍微修改一下这个例子,就能更好地证明成本中心堆栈的作用。</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">用户可以选择声明所需的&lt;a href=&quot;#deriving-stragies&quot;&gt;派生策略&lt;/a&gt;，特别是如果编译器&lt;a href=&quot;#default-deriving-strategy&quot;&gt;默认&lt;/a&gt;选择了错误的派生策略。</target>
        </trans-unit>
        <trans-unit id="98af7b33a0bad99da65cf462d2b46e6910ecbeb3" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;deriving_strategies#deriving-strategies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;deriving_strategies#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">用户可以选择声明所需的&lt;a href=&quot;deriving_strategies#deriving-strategies&quot;&gt;派生策略&lt;/a&gt;，尤其是在编译器&lt;a href=&quot;deriving_strategies#default-deriving-strategy&quot;&gt;默认&lt;/a&gt;选择错误的派生策略的情况下。</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">用户数据库</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">通常的输出流是 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 。对于Windows GUI应用程序（没有stderr），输出将定向到Windows调试控制台。这些函数的某些实现可能会修饰输出的字符串，以指示您正在跟踪。</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">数组中给定索引的值。</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">主要版本 &lt;code&gt;x.y.z&lt;/code&gt; 的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值（请参阅&lt;a href=&quot;phases#c-pre-processor&quot;&gt;影响C预处理程序的选项&lt;/a&gt;）是整数⟨xyy⟩（如果⟨y⟩是一位数字，则添加前导零，例如在版本6.8.2中）我们将拥有 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">快照版本的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值为整数⟨xyy⟩。但是，您永远不应编写任何测试该值的条件代码：由于接口每天都在变化，并且我们在 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值中没有更细的粒度，因此您仅应使用可测试该条件的谓词进行条件编译是否 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 等于，晚于或早于给定的主要版本。</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">的值 &lt;code&gt;seq a b&lt;/code&gt; 是底部，如果 &lt;code&gt;a&lt;/code&gt; 是底部，否则等于 &lt;code&gt;b&lt;/code&gt; 。换句话说，它将第一个参数 &lt;code&gt;a&lt;/code&gt; 评估为弱头范式（WHNF）。通常引入 &lt;code&gt;seq&lt;/code&gt; 来避免不必要的懒惰，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">在编译/链接时，GHC标志 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">变量的类型不是多态的，不是 &lt;code&gt;()&lt;/code&gt; ，并且是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">左手边定义中的变量被右手边的模式所约束。对于双向模式同义词,右侧的所有变量也必须出现在左侧;另外,不允许使用通配符模式和视图模式。对于单向和明确的双向模式同义词,对右侧模式没有限制。</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">运行时的变体（&amp;ldquo;方式&amp;rdquo;）。最常见的值是 &lt;code&gt;rts_v&lt;/code&gt; （香草）， &lt;code&gt;rts_thr&lt;/code&gt; （螺纹运行时，即，链接使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项）和 &lt;code&gt;rts_p&lt;/code&gt; （仿形运行时，即，链接使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项）。其他变体包括 &lt;code&gt;debug&lt;/code&gt; （使用&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;链接）和 &lt;code&gt;dyn&lt;/code&gt; （RTS是动态链接的，即共享库，而不是静态链接到可执行文件本身）。这些可以组合，例如，您可能具有 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">不同的通信进程需要在用于引用静态指针表中的值的键上达成一致,否则查找将失败。只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">您可以通过使用 &lt;code&gt;--version&lt;/code&gt; 标志调用 &lt;code&gt;ghc&lt;/code&gt; 来找到GHC副本的版本号（请参见&lt;a href=&quot;using#options-help&quot;&gt;Verbosity选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 与该程序被编译或正在解释。</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">编译此程序时使用的GHC版本。</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">强连接组件列表的顶点。</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">强连接分量的顶点。</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">类参数在相关族实例右侧的可见性&lt;em&gt;仅&lt;/em&gt;取决于族的参数。例如，考虑简单的类声明</target>
        </trans-unit>
        <trans-unit id="b254ff12dcb3719a93c7a27f7a665b84f55b2e3b" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;../using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;../using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;../using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt;，默认情况下处于关闭状态，但包含在&lt;a href=&quot;../using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 中&lt;/a&gt;，如果您隐藏了导入的模块不导出的内容，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt;，默认情况下处于关闭状态，但包含在&lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 中&lt;/a&gt;，如果您隐藏了导入的模块不导出的内容，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="5369ef220638dc82aaace3093ac85be8f6ea055a" translate="yes" xml:space="preserve">
          <source>The warning &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; (off by default) reports on any occurrences of imports annotated &lt;code&gt;qualified&lt;/code&gt; using prepositive syntax.</source>
          <target state="translated">警告 &lt;code&gt;-Wprepositive-qualified-syntax&lt;/code&gt; （默认情况下为关闭）会报告任何使用前置式语法注释为 &lt;code&gt;qualified&lt;/code&gt; 的导入事件。</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">对于以下划线开头的名字,警告会被抑制。例如</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">如果字段名以下划线开头,则该警告将被抑制。</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示重复的 &lt;code&gt;Eq a&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：： &lt;code&gt;f&lt;/code&gt; 的定义未使用它。）</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：它被 &lt;code&gt;Ord a&lt;/code&gt; 包含为约束。</target>
        </trans-unit>
        <trans-unit id="6b81d66b467d23d7422d611d2f4898b0e6c539b7" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">获得可预测行为的方法是在 &lt;code&gt;f&lt;/code&gt; 上使用&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示或 &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; 编译指示，以确保只有在其&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;有机会触发之前，它才可以内联。警告标志&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全性检查&lt;/a&gt;）对这种情况发出警告。</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">获得可预测行为的方法是在 &lt;code&gt;f&lt;/code&gt; 上使用&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示或INLINE [⟨phase⟩]编译指示，以确保在规则有机会触发之前不会内联。警告标志&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全性检查&lt;/a&gt;）对这种情况发出警告。</target>
        </trans-unit>
        <trans-unit id="14561f92a4c46bb2dbd93c4a1a57a24a8562eada" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;pragmas#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; have had a chance to fire. The warning flag &lt;a href=&quot;../using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;../using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">获得可预测行为的方法是在 &lt;code&gt;f&lt;/code&gt; 上使用&lt;a href=&quot;pragmas#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示或 &lt;code&gt;INLINE[⟨phase⟩]&lt;/code&gt; 编译指示，以确保只有在其&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;有机会触发之前，它才可以内联。警告标志&lt;a href=&quot;../using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;../using-warnings#options-sanity&quot;&gt;警告和健全性检查&lt;/a&gt;）对这种情况发出警告。</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">识别这种情况的方法是将&lt;em&gt;角色&lt;/em&gt;分配给数据类型，类和类型同义词的类型变量。</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">该库中的弱指针支持另一种方法，称为&lt;em&gt;finalization&lt;/em&gt;。当弱指针所指的密钥死亡时，存储管理器安排运行程序员指定的终结器。例如，在备忘录表的情况下，终结器可以从备忘录表中删除键/值对。</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">解决方法是分裂的.o文件，使你的包成两个或两个以上的.o的，沿该怎么行 &lt;code&gt;base&lt;/code&gt; 包做的。</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">工作车间</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">包装器和通用默认值</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">拉链： &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">&amp;ldquo; quoter&amp;rdquo;不能为&amp;ldquo; &lt;code&gt;e&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;t&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;d&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;p&lt;/code&gt; &amp;rdquo;，因为它们与Template Haskell引用重叠。</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩必须是导入的报价器名称,可以是有条件的,也可以是无条件的,不能是任意表达式。</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">然后 &lt;code&gt;Foo_stub.h&lt;/code&gt; 将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">然后， &lt;code&gt;Parser&lt;/code&gt; 是 &lt;code&gt;MonadPlus&lt;/code&gt; 的一个实例：单子排序实现解析器的串联，而 &lt;code&gt;mplus&lt;/code&gt; 提供选择。要使用解析器，我们需要一个基元来在输入字符串上运行构造的解析器：</target>
        </trans-unit>
        <trans-unit id="d51c7bd79ff661be693430fb4fca8b3531c214f1" translate="yes" xml:space="preserve">
          <source>Then GHC will interpret the return type of &lt;code&gt;MkB&lt;/code&gt; to be &lt;code&gt;C&lt;/code&gt;, and since GHC requires that the return type must be headed by &lt;code&gt;B&lt;/code&gt;, this will be rejected. On the other hand, it is acceptable to use type synonyms within the argument and result types themselves, so the following is permitted:</source>
          <target state="translated">然后，GHC会将 &lt;code&gt;MkB&lt;/code&gt; 的返回类型解释为 &lt;code&gt;C&lt;/code&gt; ，并且由于GHC要求返回类型必须以 &lt;code&gt;B&lt;/code&gt; 开头，因此将拒绝该返回类型。另一方面，可以在参数和结果类型本身中使用类型同义词，因此允许以下操作：</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">然后， &lt;code&gt;bar&lt;/code&gt; 的默认方法必须采用以下形式：</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">然后，尽管可以使用 &lt;code&gt;stdout2&lt;/code&gt; 写入标准输出，但 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">然后,涂抹式脱胶将使其变成。</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">然后是用户编写的变量，以类型变量的类型隐式地带入范围。</target>
        </trans-unit>
        <trans-unit id="e8b3132a6bec98840d3e0c94bc381c1588c40340" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">然后，使用&lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;再次对其进行编译，并另外使用 &lt;code&gt;-osuf p_o&lt;/code&gt; 来以不同的方式命名目标文件（您可以在此处选择不是普通目标后缀的任何后缀）。执行拼接表达式时，GHC将自动加载第一步中构建的目标文件。如果在使用&lt;a href=&quot;../profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;进行构建时省略了 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 标志，并且使用了模板Haskell，则GHC将发出错误消息。</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">然后使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;再次对其进行编译，并另外使用 &lt;code&gt;-osuf p_o&lt;/code&gt; 来对目标文件进行不同的命名（您可以在此处选择不是正常对象后缀的任何后缀）。执行拼接表达式时，GHC将自动加载第一步中构建的目标文件。如果在使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;进行构建时省略了 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 标志，并且使用了模板Haskell，则GHC将发出错误消息。</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">然后，在一些进口模块 &lt;code&gt;M&lt;/code&gt; ，约束 &lt;code&gt;(E a Int)&lt;/code&gt; 设置应为&amp;ldquo;提高&amp;rdquo; &lt;code&gt;a = T&lt;/code&gt; ，&lt;em&gt;尽管没有明确提及&lt;/em&gt;的 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">这样就可以派生 &lt;code&gt;HigherEq Option&lt;/code&gt; 实例。请注意，唯一的区别是现在 &lt;code&gt;(==#)&lt;/code&gt; 的非默认类型签名引入了一个 &lt;code&gt;Eq a&lt;/code&gt; 约束。来自非默认类型签名的约束永远不会出现在派生实例上下文本身中，但是它们可以用于履行默认类型签名所要求的义务。在上面的示例中，默认类型签名需要一个 &lt;code&gt;Eq a&lt;/code&gt; 实例，并且非默认签名能够满足该请求，因此派生的实例很简单：</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">那么它就会以错误的方式失败,大意是:。</target>
        </trans-unit>
        <trans-unit id="30b5d092dccca3ffe5f1a437962d4345013785c1" translate="yes" xml:space="preserve">
          <source>Then the application &lt;code&gt;f3 g3a&lt;/code&gt; is well-typed, because &lt;code&gt;g3a&lt;/code&gt; has a type that matches the type expected by &lt;code&gt;f3&lt;/code&gt;. But &lt;code&gt;f3 g3b&lt;/code&gt; is not well typed, because the foralls are in different places. Nor is &lt;code&gt;f3 g3c&lt;/code&gt;, where the foralls are in the same place but the variables are in a different order. Similarly &lt;code&gt;f4 g4&lt;/code&gt; is not well typed, because the constraints appear in a different order.</source>
          <target state="translated">然后，应用程序 &lt;code&gt;f3 g3a&lt;/code&gt; 具有良好的类型，因为 &lt;code&gt;g3a&lt;/code&gt; 的类型与 &lt;code&gt;f3&lt;/code&gt; 期望的类型匹配。但是 &lt;code&gt;f3 g3b&lt;/code&gt; 的类型不正确，因为所有人都在不同的地方。 &lt;code&gt;f3 g3c&lt;/code&gt; 也不是，所有的变量都位于同一位置，但变量的顺序不同。类似地，由于约束以不同的顺序出现，因此 &lt;code&gt;f4 g4&lt;/code&gt; 的类型也不正确。</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">然后派生的 &lt;code&gt;Foo&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">那么派生实例声明的形式是</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">然后，解析器将跟踪它执行了多少个 &lt;code&gt;tick&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">然后程序的其余部分将使用构建的标志列表来决定它的行为。</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">然后，使用 &lt;code&gt;args.txt&lt;/code&gt; 调用 &lt;code&gt;foo&lt;/code&gt; 的结果是：</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">然后我们可以这样运行程序。</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 原语之上实现自己的 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">有&lt;em&gt;许多&lt;/em&gt;影响GHC产生代码质量的选项。大多数人只有一个总体目标，例如&amp;ldquo;快速编译&amp;rdquo;或&amp;ldquo;使我的程序像润滑的闪电般运行&amp;rdquo;。下列优化（或缺乏优化）&amp;ldquo;包装&amp;rdquo;就足够了。</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有一些警告可能会在将来被删除：此选项当前未在Windows上实现（它是无操作），并且外部解释器不支持GHCi调试器，因此断点和单步执行不&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;不起作用。</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">有几个标志用于控制输入孔的上下文信息显示量。</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">还有其他一些与分析相关的编译选项。&lt;em&gt;除了&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt;之外，还要&lt;/em&gt;使用它们。这些不必一定要在程序中的所有模块上一致使用。</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="0ace737ea1ad0292af239ecd28b2b2f2f35d3aad" translate="yes" xml:space="preserve">
          <source>There are a number of restrictions around these &lt;em&gt;return kinds&lt;/em&gt;. The text below considers &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; and data families (enabled by &lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;). The discussion also assumes familiarity with &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;levity polymorphism&lt;/a&gt;.</source>
          <target state="translated">这些&lt;em&gt;退货种类&lt;/em&gt;有很多限制。下面的文本考虑了&lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;和数据族（由&lt;a href=&quot;type_families#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;启用）。讨论还假定您熟悉&lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;levity多态性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">还有 &lt;code&gt;case&lt;/code&gt; 命令，例如</target>
        </trans-unit>
        <trans-unit id="dd8eb62640463e13034ae0606f48f2c5c055b371" translate="yes" xml:space="preserve">
          <source>There are also hybrid cases, where the method and/or operator are not well suited to the task at hand, resulting in a fold that fails to yield incremental results until the entire input is processed, or fails to strictly evaluate results as it goes, deferring all the work to the evaluation of a large final thunk. Such cases should be avoided, either by selecting a more appropriate &lt;code&gt;Foldable&lt;/code&gt; method, or by tailoring the operator to the chosen method.</source>
          <target state="translated">在某些混合情况下，方法和/或操作员不太适合手头的任务，这导致折叠无法产生增量结果，直到处理完所有输入，或者无法严格评估结果，将所有工作推迟到评估大型最终thunk上。应避免这种情况，方法是选择一种更合适的 &lt;code&gt;Foldable&lt;/code&gt; 方法，或者使操作员适应所选的方法。</target>
        </trans-unit>
        <trans-unit id="1279203c2e0d157a8d9dad524a1fc81607cfc8e4" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt;&lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">当前有两种方法可以对有效的孔配合进行排序。可以使用&lt;a href=&quot;#ghc-flag--fno-sort-valid-hole-fits&quot;&gt; &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; &lt;/a&gt;切换排序</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">当前有两种方法可以对有效的孔配合进行排序。可以使用 &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 切换排序</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">编译为目标代码有一些缺点：例如，您不能在目标代码模块中设置断点。在GHCi中仅可见目标代码模块的导出，而不是解释模块中的所有顶级绑定。</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">有五种新的理解限定词形式， &lt;code&gt;then&lt;/code&gt; 由（existing）关键字引入：</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">有四种方法可以设置RTS选项。</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">有许多数据类型-通用函数并不区分作为参数的位置和作为递归调用的位置,也有许多数据类型-通用函数根本不关心数据类型和构造函数的名称。还有很多数据类型-泛型函数根本不关心数据类型和构造函数的名称。为了使通用函数在这种情况下要考虑的情况数量降到最低,结果发现上面介绍的很多类型构造函数实际上是同义词,把它们定义为一个较小的构造函数集的变体。</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">有许多不同种类的配置文件可以生成,由不同的 RTS 选项选择。我们将在本章的其余部分描述各种不同类型的配置文件。有些配置文件需要在程序运行后使用额外的工具进行进一步的处理。</target>
        </trans-unit>
        <trans-unit id="780abf829b6da95d281c25275aa198c1ad98ac87" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">没有此类的预定义实例。默认情况下，它不在范围内，但是可以通过导入&lt;a href=&quot;../../libraries/base-4.15.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels使其&lt;/a&gt;进入范围。不像 &lt;code&gt;IsString&lt;/code&gt; ，没有特殊的默认规则 &lt;code&gt;IsLabel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">没有此类的预定义实例。默认情况下，它不在范围内，但是可以通过导入&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels使其&lt;/a&gt;进入范围。不像 &lt;code&gt;IsString&lt;/code&gt; ，没有特殊的默认规则 &lt;code&gt;IsLabel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70d1d2c96409db371b4aa9bd1644711aa1fc1d7d" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">没有此类的预定义实例。默认情况下，它不在范围内，但是可以通过导入&lt;a href=&quot;../libraries/base-4.14.1.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels使其&lt;/a&gt;进入范围。不像 &lt;code&gt;IsString&lt;/code&gt; ，没有特殊的默认规则 &lt;code&gt;IsLabel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">没有可运行的线程，因此程序处于死锁状态。该 &lt;code&gt;Deadlock&lt;/code&gt; 例外仅在主线程提高。</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;没有语法变化。它在源代码级别显示的唯一方式是您可以拥有一个不需要 &lt;code&gt;Monad&lt;/code&gt; 约束的 &lt;code&gt;do&lt;/code&gt; 表达式。例如，在GHCi中：</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">没有要传递的 &lt;code&gt;V1 p&lt;/code&gt; 类型的值（未定义的除外），因此实际上是不可能的。有人会问为什么在这种情况下为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 定义一个实例为什么很有用？好的，可以将空类型用作非空类型的参数，并且您可能仍希望对结果类型进行编码。作为一个有些人为的示例，请考虑 &lt;code&gt;[Empty]&lt;/code&gt; ，它不是空类型，而仅包含空列表。该 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 实例，确保我们能够呼吁这些类型的通用功能。</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">在某些情况下，您确实确实需要捕获任何异常。但是，在大多数情况下，这只是为了使您可以进行一些清理。您实际上对异常本身不感兴趣。例如，如果您打开一个文件然后要再次关闭它，则处理文件是正常执行还是引发异常。但是，在这些情况下，您可以使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 之类的函数，它们实际上不会向您传递异常，而只是在适当的位置调用清除函数。</target>
        </trans-unit>
        <trans-unit id="68320e8b907613c7782553698755865907bc858f" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt;&lt;/a&gt; flags.</source>
          <target state="translated">您可以使用几种不同的访问点来定义用于访问表示形式的插件。所有这些字段都接收使用&lt;a href=&quot;#ghc-flag--fplugin-opt=%E2%9F%A8module%E2%9F%A9:%E2%9F%A8args%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin-opt=⟨module⟩:⟨args⟩&lt;/code&gt; &lt;/a&gt;标志传递给编译器的 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串列表。</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">您可以使用几种不同的访问点来定义用于访问表示形式的插件。所有这些字段都接收使用 &lt;code&gt;-fplugin-opt&lt;/code&gt; 标志传递给编译器的 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串列表。</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">有几种不同类型的堆配置文件可以生成。所有不同的剖面图类型都会产生一个实时堆与时间的对比图,但它们在如何将实时堆分解成带状方面有所不同。下面的RTS选项可以选择使用哪种分解方式。</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获和检查异常有几种功能。所有这些都只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 内部使用。</target>
        </trans-unit>
        <trans-unit id="0e8b486f6025f68e63b8a2e69c38027f05b9be43" translate="yes" xml:space="preserve">
          <source>There are several legitimate ways to use &lt;code&gt;&lt;a href=&quot;unsafe-coerce#v:unsafeCoerce&quot;&gt;unsafeCoerce&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">有几种使用 &lt;code&gt;&lt;a href=&quot;unsafe-coerce#v:unsafeCoerce&quot;&gt;unsafeCoerce&lt;/a&gt;&lt;/code&gt; 的合法方法：</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">有几个选项可让您精确控制垃圾回收。希望您在正常操作中不需要任何这些，但是为了达到最佳性能，可以进行一些调整。</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 还提供其他一些与Haskell和GHC相关的邮件列表。有关完整列表，&lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;请访问http://www.haskell.org/mailman/listinfo/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a880f0505216caaeec447cd58fe796163581619e" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;https://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 还提供其他一些与Haskell和GHC相关的邮件列表。有关完整列表，&lt;a href=&quot;https://www.haskell.org/mailman/listinfo/&quot;&gt;请访问http://www.haskell.org/mailman/listinfo/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">对于存在量化的构造体的使用方式有几个限制。</target>
        </trans-unit>
        <trans-unit id="93f0614d42022b318b6c7e89cd2bff7336dde820" translate="yes" xml:space="preserve">
          <source>There are some limitations when using this. File and process IO will be executed on the target. As such packages like &lt;code&gt;git-embed&lt;/code&gt;, &lt;code&gt;file-embed&lt;/code&gt; and others might not behave as expected if the target and host do not share the same filesystem.</source>
          <target state="translated">使用此功能时有一些限制。文件和进程IO将在目标上执行。因为像 &lt;code&gt;git-embed&lt;/code&gt; ， &lt;code&gt;file-embed&lt;/code&gt; 之类的软件包和其他软件包，如果目标和主机未共享同一文件系统，则可能无法按预期运行。</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">关于哪些数据类型可以派生 &lt;code&gt;Foldable&lt;/code&gt; 实例还有一些其他区别：</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">在某些其他情况下，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将无法编译：</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">对基元类型的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">对未装箱的元组的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">还有三个选项与堆剖析有关。</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">新增了三个关键字： &lt;code&gt;group&lt;/code&gt; ， &lt;code&gt;by&lt;/code&gt; 和 &lt;code&gt;using&lt;/code&gt; 。（ &lt;code&gt;sortWith&lt;/code&gt; 和 &lt;code&gt;groupWith&lt;/code&gt; 函数不是关键字；它们是 &lt;code&gt;GHC.Exts&lt;/code&gt; 导出的普通函数。）</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">有三种方法可以获得对当前调用栈的访问。</target>
        </trans-unit>
        <trans-unit id="18668df28a2960d99f735bbd24797ff6843bd893" translate="yes" xml:space="preserve">
          <source>There are two access points are bundled together for defining hole fit plugins, namely a candidate plugin and a fit plugin, for modifying the candidates to be checked and fits respectively.</source>
          <target state="translated">有两个接入点被捆绑在一起,用于定义孔洞拟合插件,即候选插件和拟合插件,分别用于修改待检查的候选和拟合。</target>
        </trans-unit>
        <trans-unit id="0e7482a52c288e2a6aa7c273bf0bcf1dbfeabe7e" translate="yes" xml:space="preserve">
          <source>There are two classes of event types:</source>
          <target state="translated">事件类型有两类。</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">特殊语法有两类。</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLL的使用有两种不同的方式。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">这一规则有两个例外。</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 还有两个其他重要属性：</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">这个解码器的执行方式有两种,分别是懒惰输入法和增量输入法。这里我们将使用懒惰输入法。</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">序列和列表之间有两大区别。</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">这个柜台有两件事可以做。</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">浏览命令有两种变体。</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">有两种方法可以使用这些实用工具。</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">有两种方法可以在多个处理器上运行程序：从程序中调用&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;或使用RTS&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="54084616a21d75658db0216e6ad990b71f0f3457" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">有两种方法可以在多个处理器上运行程序：从程序中调用&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;，或使用RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="092fc3bbaa6aff2c322b0758396d9aa0b8912b0f" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">有两种方法可以在多个处理器上运行程序：从程序中调用&lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;，或使用RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">可以有任意多的文件头实用名,而且可以在它们的前面或后面加上注释。</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">关联类型同义词最多只能有一个默认声明。</target>
        </trans-unit>
        <trans-unit id="322113e89338d2edb0df8de43c1eb5e1cfd90dc4" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;../bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">可以对 &lt;code&gt;hs_init()&lt;/code&gt; 进行多次调用，但每个调用都应与对hs_exit（）的一个（只有一个）调用 &lt;code&gt;hs_exit()&lt;/code&gt; 。最外面的 &lt;code&gt;hs_exit()&lt;/code&gt; 实际上会取消初始化系统。请注意，当前GHC的运行时在发生这种情况后无法可靠地重新初始化。参见&lt;a href=&quot;../bugs#infelicities-ffi&quot;&gt;外部功能接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">可以对 &lt;code&gt;hs_init()&lt;/code&gt; 进行多次调用，但每个调用都应与对hs_exit（）的一个（只有一个）调用 &lt;code&gt;hs_exit()&lt;/code&gt; 。最外面的 &lt;code&gt;hs_exit()&lt;/code&gt; 实际上会取消初始化系统。请注意，当前GHC的运行时在发生这种情况后无法可靠地重新初始化。参见&lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;外部功能接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">只能有一个&amp;ldquo;细分&amp;rdquo;选项（例如，上例中的&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;），但是可以应用的进一步限制的数量没有限制。所有的选项可以合并，但有一个例外：GHC目前不支持混合&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="94e3121ab462249427193d1d9fad3fc4ffc53a3c" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types&quot;&gt;wiki page dedicated to the linear types extension&lt;/a&gt;</source>
          <target state="translated">有一个&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types&quot;&gt;专门用于线性类型扩展&lt;/a&gt;的Wiki页面</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">有一个默认值 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 应该用于初始化 &lt;code&gt;RtsConfig&lt;/code&gt; 类型的变量。毫无疑问，将来会有更多字段添加到 &lt;code&gt;RtsConfig&lt;/code&gt; ，因此，为了使您的代码向前兼容，最好使用 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 进行初始化，然后修改所需的字段，如上面的代码示例中所示。</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;上有关于编译安全性和一些潜在解决方案的更详细的讨论。</target>
        </trans-unit>
        <trans-unit id="7ef9b54093e73b5247e6192453bb1d4451bfc02a" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/safe-haskell/safe-compilation&quot;&gt;GHC Wiki&lt;/a&gt;上有关于编译安全性和一些潜在解决方案的更详细的讨论。</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="566104a98981fe95741524bb050f2354c55f9f53" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="3600233714778db16c8732014dac5c73f6412ae4" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">死锁检测和终结器（由 &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 或&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak中&lt;/a&gt;的函数创建）之间存在微妙的交互：如果某个线程在等待终结器运行时被阻塞，则该线程将被视为死锁并发送异常。因此最好不要这样做，但是如果没有其他选择，则可以通过使 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 指向该线程来防止该线程被视为死锁。不要忘了释放 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 与后来的 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">这里有额外的符号(借用GNU图标v)来指定如何处理非法字符。</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">有大量的Haskell民间艺术 &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;智能构造&lt;/a&gt;函数，从本质上讲，这些函数将验证包装在构造函数周围，并避免公开其表示形式。缺点是基础构造函数不能用作匹配器。模式同义词可以用作真正的智能构造函数，用于验证和匹配。</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">剖析本身有一个开销,由剖析器从驻留数据中减去。当然,在没有profiling支持的情况下,这个开销会消失。空间开销目前是每个堆对象多出2个字,大概会造成30%的开销。</target>
        </trans-unit>
        <trans-unit id="bfeebc74cf73d84eb55c954269428d758e871dbb" translate="yes" xml:space="preserve">
          <source>There is currently no support for multiplicity annotations such as &lt;code&gt;x :: a %p&lt;/code&gt;, &lt;code&gt;\(x :: a %p) -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">目前尚数注释，如不支持 &lt;code&gt;x :: a %p&lt;/code&gt; ， &lt;code&gt;\(x :: a %p) -&amp;gt; ...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">当前不支持获取&amp;ldquo;堆栈跟踪&amp;rdquo;，但是跟踪和历史记录功能提供了有用的第二优功能，通常足以确定错误的上下文。例如，即使在编译后的代码中抛出异常，也可能自动中断该异常（请参阅&lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;调试异常&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">类型只有一个值 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; ，因此对它进行编码不需要任何知识，我们可以使用零位：</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有 &lt;code&gt;ZonedTime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例。如果要比较本地时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 。如果要比较绝对时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ed2f198aae585d94d8de2a49be348554775e93" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有 &lt;code&gt;ZonedTime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例。如果要比较本地时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 。如果要比较绝对时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f32d02061bc32b68cf56c079b75b5a16fbbf4b0" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有 &lt;code&gt;ZonedTime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例。如果要比较本地时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 。如果要比较绝对时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">没有 &lt;code&gt;deRefStableName&lt;/code&gt; 操作。您不能从一个稳定的名称返回到原始的Haskell对象。原因是对象的稳定名称的存在不能保证对象本身的存在。它仍然可以被垃圾收集。</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">与&lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;不同，没有 &lt;code&gt;freeStableName&lt;/code&gt; 操作。当不再需要稳定名称时，运行时系统将对其进行回收。</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; 或 &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 注释，因此标记为 &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">读取缓冲区没有相应的操作，因为在读取之前，客户端将始终调用 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">对新类型没有影响,只是对现有类型进行重命名。例如:</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">无法保证评估的顺序。该实现可以按任何顺序或并行评估结构的组件。要在评估征收的实际顺序，使用 &lt;code&gt;pseq&lt;/code&gt; 从&lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt;在 &lt;code&gt;parallel&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">无法保证延迟到期后将立即重新安排线程的运行时间，但是该线程将永远不会继续运行 &lt;em&gt;时间&lt;/em&gt;比指定的&lt;em&gt;早&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">无需列出所有源文件作为 &lt;code&gt;ghc -M&lt;/code&gt; 命令的参数。 &lt;code&gt;ghc&lt;/code&gt; 跟踪依赖项，就像 &lt;code&gt;ghc --make&lt;/code&gt; （GHC 6.4中的新功能）一样。</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有严格（ &lt;code&gt;!&lt;/code&gt; ）或惰性（ &lt;code&gt;~&lt;/code&gt; ）注释，因此将其标记为 &lt;code&gt;'NoSourceStrictness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b022fa6b4de80677bbfc2a36b1ae5a9a3723a85" translate="yes" xml:space="preserve">
          <source>There is no support for linear pattern synonyms.</source>
          <target state="translated">没有支持线性模式的同义词。</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">无法对 &lt;code&gt;Danger&lt;/code&gt; 可以导入的模块施加限制。这使 &lt;code&gt;Danger&lt;/code&gt; 的作者拥有很大的攻击面，基本上是系统上当前安装的任何软件包。如果这些软件包中的任何一个都有漏洞，则 &lt;code&gt;Danger&lt;/code&gt; 模块可以利用它。</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">除了初始数据外,没有办法提供更多的输入。要想以增量方式提供更多数据,请参见增量输入界面。</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">现在进出口清单中可能存在一些歧义；例如，如果您编写 &lt;code&gt;import M( (+) )&lt;/code&gt; ，是指&lt;em&gt;函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 还是&lt;em&gt;类型构造函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; ？默认值为前者，但是使用&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（由&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;隐含）GHC允许您通过在其前面加上关键字来指定后者 &lt;code&gt;type&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="447a4ae19a6034b9c2aff03899064c3f4858ff91" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;explicit_namespaces#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">现在，进出口清单中可能存在一些歧义；例如，如果您编写 &lt;code&gt;import M( (+) )&lt;/code&gt; ，是指&lt;em&gt;函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 还是&lt;em&gt;类型构造函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; ？默认值是前者，但是使用&lt;a href=&quot;explicit_namespaces#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（由&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;隐含），GHC允许您通过在其前面加上关键字 &lt;code&gt;type&lt;/code&gt; 来指定后者，因此：</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">有一个 &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 情况：reifyInstances''可键入的ty当前总是产生一个空列表（无论给出什么 &lt;code&gt;tys&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">此一般规则有一个例外：当使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;加载程序时，或在调用 &lt;code&gt;ghci&lt;/code&gt; 时指定程序时，可以提供文件名而不是模块名。该文件名（如果存在）将被加载，并且可能包含您喜欢的任何模块。如果您在同一目录中有多个 &lt;code&gt;Main&lt;/code&gt; 模块，而又不能全部调用它们 &lt;code&gt;Main.hs&lt;/code&gt; ,则这特别方便。</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">有一个特别棘手的案例,应该解释一下。</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">句法上的歧义有一个问题。请考虑:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="25f515351416a88c7165a7d23467301f2a1ae98e" translate="yes" xml:space="preserve">
          <source>There is room for extra information in the event type specification, which can be ignored by older tools.</source>
          <target state="translated">在事件类型规范中还有额外信息的空间,可以被旧工具忽略。</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCi加载前奏和标准库时，可能会停顿一会儿，然后显示提示。如横幅所示，您可以输入&lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;查看可用命令列表，以及每个命令的半行描述。我们将逐步解释所有这些命令，并且在&lt;a href=&quot;#ghci-commands&quot;&gt;GHCi命令中&lt;/a&gt;提供了所有命令的完整文档。</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">同一个键可能有多个弱指针。在这种情况下,每一个弱指针的定标器都会以某种任意的顺序运行,或者当键死亡时,可能会同时运行。如果程序员指定的定标器假定它拥有对一个对象的唯一引用(例如,它希望关闭的文件),那么程序员必须确保只有一个这样的定标器。</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">规则中可能有零个或多个&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;，并用分号分隔（可能由布局规则生成）。</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">令牌 &lt;code&gt;[quoter|&lt;/code&gt; 不能有空格。。</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如,我们可以定义这样的签名:</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如:</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">必须对类型族的方程进行一些限制,以免我们定义一个模糊的重写系统。所以,开放类型族的方程被限制为兼容。如果两个类型模式是兼容的</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">曾经有 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的另一种变体（即 &lt;code&gt;Par0&lt;/code&gt; ），但此后不推荐使用。</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;并发&lt;/em&gt;和&lt;em&gt;并行&lt;/em&gt;性之间有很好的区别：并行性就是使程序运行&lt;em&gt;得更快&lt;/em&gt;通过同时使用多个处理器来使。另一方面，并​​发是一种抽象手段：这是一种构造必须响应多个异步事件的程序的便捷方法。</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">有一个创建 &lt;code&gt;StablePtr&lt;/code&gt; 的特殊功能： &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; ，因为RTS需要一个到原始 &lt;code&gt;MVar#&lt;/code&gt; 对象的 &lt;code&gt;StablePtr&lt;/code&gt; ，而我们不能直接创建它。不要&lt;em&gt;不&lt;/em&gt;只是使用 &lt;code&gt;newStablePtr&lt;/code&gt; 的 &lt;code&gt;MVar&lt;/code&gt; &lt;em&gt;&lt;/em&gt;：你的程序会崩溃。</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">这里有一个例外：您可以使用Cygwin的外壳，如果 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量并&lt;em&gt;没有&lt;/em&gt;包含 &lt;code&gt;tty&lt;/code&gt; 。在这种模式下，Cygwin Shell的行为类似于Windows控制台Shell，并且控制台事件传播到子进程。注意，&lt;em&gt;在&lt;/em&gt;启动Cygwin shell &lt;em&gt;之前，&lt;/em&gt;必须先设置 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量。之后再更改它对外壳没有影响。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">使用外部库时，还需要牢记其他一点：如果该库包含 &lt;code&gt;main()&lt;/code&gt; 函数，则这将与GHC自己的 &lt;code&gt;main()&lt;/code&gt; 函数（例如 &lt;code&gt;libf2c&lt;/code&gt; 和 &lt;code&gt;libl&lt;/code&gt; 有自己 &lt;code&gt;main()&lt;/code&gt; 小号）。</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">有一个隐含的 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 系列函数之一的调用中，每个异常处理程序周围都有。这是因为这是您大多数时候想要的-它消除了启动异常处理程序时的常见竞争条件，因为如果一个人立即到达，则堆栈上可能没有异常处理程序来处理另一个异常。但是，如果异步异常在进入处理程序时被屏蔽，我们有时间在被中断之前安装新的异常处理程序。如果不是默认设置，则必须编写类似</target>
        </trans-unit>
        <trans-unit id="8e29544df8c9d4e04c3badac10c4c4870ef74b9a" translate="yes" xml:space="preserve">
          <source>There's even a generic way to handle empty values (&lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;, etc.):</source>
          <target state="translated">甚至还有一种处理空值的通用方法（ &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 等）：</target>
        </trans-unit>
        <trans-unit id="24a5307d79c12db0a4b7ba47ec7441e99dc9f60b" translate="yes" xml:space="preserve">
          <source>Therefore the type of an untyped quotation in GHC is `Quote m =&amp;gt; m Exp`</source>
          <target state="translated">因此，GHC中无类型引号的类型为&amp;ldquo; Quote m =&amp;gt; m Exp&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6b1f8f78c4b21b4ebde0207b0aeba4e07d56d547" translate="yes" xml:space="preserve">
          <source>Therefore, if we run GHC against the following code using the plugin from above:</source>
          <target state="translated">因此,如果我们用上面的插件对着下面的代码运行GHC。</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">这些 &lt;code&gt;Names&lt;/code&gt; 可用于构造Template Haskell表达式，模式，声明等。它们也可以作为 &lt;code&gt;reify&lt;/code&gt; 函数的参数提供。</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">这些RTS选项可用于（a）避免GHC错误，（b）看到&amp;ldquo;实际情况&amp;rdquo;，或（c）因为您喜欢它。不建议日常使用！</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">这些和许多其他示例在Honghong Xi和Tim Sheard的论文中给出。&lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;Wiki上&lt;/a&gt;有更长的介绍，以及Ralf Hinze的&amp;ldquo; &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;幻影类型&lt;/a&gt;的乐趣&amp;rdquo;。也有许多示例。请注意，论文使用的符号可能与GHC中实施的符号不同。</target>
        </trans-unit>
        <trans-unit id="04d9b83f5fd62464360061e6d169acf40021dc88" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;https://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">这些和许多其他示例在Honghong Xi和Tim Sheard的论文中给出。&lt;a href=&quot;https://www.haskell.org/haskellwiki/GADT&quot;&gt;Wiki上&lt;/a&gt;有更长的介绍，Ralf Hinze的&amp;ldquo;&lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;幻影类型&lt;/a&gt;的乐趣&amp;rdquo;也有许多示例。请注意，论文使用的符号可能与GHC中实施的符号不同。</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">这些可用作 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">这些可从&lt;em&gt;Trustworthy&lt;/em&gt;模块中获得&lt;a href=&quot;data-coerce&quot;&gt; Data.Coerce&lt;/a&gt;中获得</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">这些是 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;newtype&lt;/code&gt; 声明的示例，其数据构造函数具有多态参数类型：</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">这些是程序编译后要运行的平台。</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">这些是GHC本身编译的平台。同样,这通常与构建和目标平台相同。</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">这些是程序构建的平台。(也就是GHC本身的目标平台。)通常这和目标平台是一样的。(如果是交叉编译的话,有可能是不同的。)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">这些属性的所有属性都是关闭的。</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">这些对于调查错误或性能问题很有用。他们应该&lt;em&gt;不是&lt;/em&gt;在生产代码中使用。</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">这些功能直接对应于 &lt;code&gt;cub&lt;/code&gt; ， &lt;code&gt;cud&lt;/code&gt; ， &lt;code&gt;cub1&lt;/code&gt; ， &lt;code&gt;cud1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">这些字符是:任何空格、单引号、双引号和反斜杠字符。反斜杠字符总是转义(即,不加考虑地通过)后面的字符。字符也可以通过引号在块中进行转义(即在块的周围用匹配的单引号或双引号对其进行转义)。</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;不是&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;商标&amp;rdquo;，什么不是&amp;ldquo;商标&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;数字&amp;rdquo;，什么不是数字。</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;标点符号&amp;rdquo;和什么不是&amp;ldquo;标点符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;分隔符&amp;rdquo;，什么不是&amp;ldquo;分隔符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是和不是&amp;ldquo;符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="19c62646b51deb3633a6d39d0c6ae999d0c5d784" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;字母&amp;rdquo;，什么不是&amp;ldquo;字母&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7e8ba0bfda8d8d856d1195f3b3b7ce5c153b9ba0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;标记&amp;rdquo;，什么不是&amp;ldquo;标记&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d54be1da1d383c2b311f8f56c474dac56684b053" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;数字&amp;rdquo;，什么不是数字。</target>
        </trans-unit>
        <trans-unit id="438496159c2e65a90e159a06d8c49e17c47a3199" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;标点符号&amp;rdquo;和什么不是&amp;ldquo;标点符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2d4f46e5583cd4b0d09be2a2692dbfa6cb8a95d5" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;分隔符&amp;rdquo;，什么不是&amp;ldquo;分隔符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0044eb8f352d307e6606ff059288ad3a4e298068" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">这些类是在&lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;（Unicode标准的一部分）中定义的。同一文档定义了什么是&amp;ldquo;符号&amp;rdquo;，什么不是&amp;ldquo;符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">需要这些类来表达对便携式Haskell中的转换器参数的约束。因此，对于一个新的转换器 &lt;code&gt;T&lt;/code&gt; ，可能会编写如下实例</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">考虑到这些因素,我们对孤儿模块的定义如下:</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">这些通过参数化确保。</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">这些事件&lt;em&gt;始终&lt;/em&gt;是GHC系统中的错误，请报告。</target>
        </trans-unit>
        <trans-unit id="588a8548c6363993d22d2b7e86c47e328069a514" translate="yes" xml:space="preserve">
          <source>These events are typically produced during program startup and describe the environment which the program is being run in.</source>
          <target state="translated">这些事件通常在程序启动时产生,并描述了程序运行的环境。</target>
        </trans-unit>
        <trans-unit id="7e9e62a89c4ce54bd1d84649823a3e3080b1425a" translate="yes" xml:space="preserve">
          <source>These events mark various stages of the &lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;non-moving collection&lt;/code&gt;&lt;/a&gt; lifecycle. These are enabled with the &lt;code&gt;+RTS -lg&lt;/code&gt; event-set.</source>
          <target state="translated">这些事件标志着&lt;a href=&quot;runtime_control#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;non-moving collection&lt;/code&gt; &lt;/a&gt;生命周期的各个阶段。这些通过 &lt;code&gt;+RTS -lg&lt;/code&gt; 事件集启用。</target>
        </trans-unit>
        <trans-unit id="5bf8fa1560225f49387556fff72128a8cf04cff5" translate="yes" xml:space="preserve">
          <source>These examples can be made to typecheck by eta-expansion. For example &lt;code&gt;f3 (\x -&amp;gt; g3b x)&lt;/code&gt; is well typed, and similarly &lt;code&gt;f3 (\x -&amp;gt; g3c x)&lt;/code&gt; and &lt;code&gt;f4 (\x -&amp;gt; g4 x)&lt;/code&gt;.</source>
          <target state="translated">这些示例可以通过eta-expansion进行类型检查。例如， &lt;code&gt;f3 (\x -&amp;gt; g3b x)&lt;/code&gt; 的类型正确，并且类似地 &lt;code&gt;f3 (\x -&amp;gt; g3c x)&lt;/code&gt; 和 &lt;code&gt;f4 (\x -&amp;gt; g4 x)&lt;/code&gt; &amp;gt; g4x ）。</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">只要模块包含&amp;ldquo;孤立&amp;rdquo;实例声明或重写规则，这些标志就会发出警告。如果实例声明出现在模块中，而该实例或类都没有在同一模块中声明，则实例声明是孤立的。如果规则是另一个模块中声明的函数的规则，则它是孤立的。包含任何孤立对象的模块称为孤立模块。</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">这些标志从其他后端转储各种信息位。</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">这些标志从GHC的前端转储各种信息。这包括解析器和接口文件读取器。</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">这些标志从GHC的类型检查器和重命名器中转储各种信息。</target>
        </trans-unit>
        <trans-unit id="2dc9a8e0f094a600546405a33b0a5ef835899c04" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-- pipeline.</source>
          <target state="translated">这些标志转储了GHC的C--管线的各个阶段。</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">这些标志转储GHC的C-\-管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">这些标志转储了GHC核心到核心管道的各个阶段。这从解糖器开始，包括简化程序，工作者包装程序转换，规则引擎，专家，严格性/出现率分析器以及常见的子表达式消除过程。</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">这些标志转储GHC STG管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="50fcdcd1fe44bc0c3ab929a2c58bbb80cb13f620" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-- and produces native assembler.</source>
          <target state="translated">这些标志转储本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;管道的各个阶段，该管道以C--开头，并生成本机汇编程序。</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">这些标志转储本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;管道的各个阶段，该管道以C-\-开头并生成本机汇编程序。</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">这些标志打开和关闭各个优化。默认情况下，标记为on的标志由 &lt;code&gt;-O&lt;/code&gt; 启用，因此您不需要显式设置任何标志。可以通过说 &lt;code&gt;-fno-wombat&lt;/code&gt; &lt;code&gt;-fwombat&lt;/code&gt; 否定标志-fwombat。</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">提供这些用于标准类型的格式化程序是为了方便编写新的特定于类型的格式化程序：一种常见的模式是抛出 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; 来对新类型进行大多数格式处理。</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">这四个属性保证了在安全语言中,你可以相信类型,可以相信模块导出列表会得到尊重,可以相信成功编译的代码与正常情况下的代码具有相同的意义。</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">这些功能也由&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出。</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">这些函数与其对应的 &lt;code&gt;CAString&lt;/code&gt; 不同，它们将使用由当前语言环境确定的编码，而不是始终采用ASCII。</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">这些函数是重载的,因为它们需要返回不同的结果,这取决于它们被实例化的类型。</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">当移位量大于机器Int#的位数大小时,这些函数未被定义。</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">这些函数在内部用于引发各种错误,并被导出供新的特定类型格式化器使用。</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">这些函数可用于组合新代数类型的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例。例如，给定定义</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">这些函数没有绑定一个多态变量,所以被接受。它们的多态性允许用户使用这些函数来方便地剔除那些返回非盒式类型的函数。</target>
        </trans-unit>
        <trans-unit id="044a64ee1e082d15f5fc359f3ff870486d8b309f" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="translated">这些函数遵循&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception的&lt;/a&gt;函数，但它们基于 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; 类型类的方法。有关API的用法，请参见&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e87eeae99023d3ede05957d0fd11586bb75cb64" translate="yes" xml:space="preserve">
          <source>These functions follow those from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;, except that they are based on methods from the &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; typeclass. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; for API usage.</source>
          <target state="translated">这些函数遵循&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception的&lt;/a&gt;函数，但它们基于 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadCatch&quot;&gt;MonadCatch&lt;/a&gt;&lt;/code&gt; 类型类的方法。有关API的用法，请参见&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">通过允许任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作作为终结器，这些函数在可移植的&lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt;模块中通用了它们的名称。这些终结器必须在单独的线程中运行，请参见。&lt;em&gt;析构&lt;/em&gt;&lt;em&gt;函数&lt;/em&gt;，&lt;em&gt;终结器和同步&lt;/em&gt;，作者：Hans Boehm，&lt;em&gt;POPL&lt;/em&gt;，2003年。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">这些函数从序列的左端或右端进行顺序搜索,返回匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">这些功能早于 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; ，后者更加灵活。</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">这些实例是兼容的，因为它们的隐式种类参数有所不同。第一个使用 &lt;code&gt;Type&lt;/code&gt; ，第二个使用 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">这些宏从GHC 7.10.1开始可用。</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">提供这些宏是为了比 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 提供更细的粒度。通常，这不是必需的，因为期望大多数API在补丁程序版本之间保持稳定，但是偶尔需要内部API更改才能修复错误。此外，在补丁程序级别上进行条件编译对于解决较旧版本中的错误也很有用。</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">在预处理Haskell源和C源（包括从Haskell模块生成的C源（即 &lt;code&gt;.hs&lt;/code&gt; ， &lt;code&gt;.lhs&lt;/code&gt; ， &lt;code&gt;.c&lt;/code&gt; )时，会设置这些宏。和 &lt;code&gt;.hc&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">这些模块在导入时要有限定条件,以避免与Prelude函数的名称冲突,例如:。</target>
        </trans-unit>
        <trans-unit id="a3b4ffdd3087b092dcee0cb235ee95a5ddd25f36" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">这些操作分别返回 &lt;code&gt;0#&lt;/code&gt; 和 &lt;code&gt;1#&lt;/code&gt; ,而不是 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">这些操作分别返回 &lt;code&gt;0#&lt;/code&gt; 和 &lt;code&gt;1#&lt;/code&gt; ,而不是 &lt;code&gt;False&lt;/code&gt; 和 &lt;code&gt;True&lt;/code&gt; 。看到&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;&lt;/a&gt;更多详细信息， PrimBool Wiki页面。</target>
        </trans-unit>
        <trans-unit id="b7ccd9c5b4911eda91ad51529b53aa771bb31514" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">这些操作分别返回 &lt;code&gt;0#&lt;/code&gt; 和 &lt;code&gt;1#&lt;/code&gt; ,而不是 &lt;code&gt;False&lt;/code&gt; 和 &lt;code&gt;True&lt;/code&gt; 。有关更多详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/prim-bool&quot;&gt;PrimBool Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">这些选项在&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;中进行了详细描述。如果一个标志由 &lt;code&gt;-O&lt;/code&gt; 隐含，那么它也由 &lt;code&gt;-O2&lt;/code&gt; 隐含（除非标志说明另有明确说明）。如果仅 &lt;code&gt;-O0&lt;/code&gt; 隐含标志，则 &lt;code&gt;-O&lt;/code&gt; 和-O不隐含该标志。 &lt;code&gt;-O2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">这些选项在以下内容中有更详细的描述 &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;优化（代码改进）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">这些选项控制哪些警告被认为是致命的,并导致编译中止。</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">这些选项产生运行时系统统计信息，例如执行程序和在垃圾回收器中花费的时间，分配的内存量，堆的最大大小等。这三个变体提供不同的详细程度： &lt;code&gt;-T&lt;/code&gt; 收集数据但不产生输出 &lt;code&gt;-t&lt;/code&gt; 产生与GHC的 &lt;code&gt;-Rghc-timing&lt;/code&gt; 选项相同格式的单行输出， &lt;code&gt;-s&lt;/code&gt; 在结束时产生更详细的摘要程序和线程化的运行时将导致详细的摘要包括运行期间累积的各种内部计数；请注意，这些是未指定的，并且可能在发行版之间进行更改。 &lt;code&gt;-S&lt;/code&gt; 还会生成有关每个垃圾收集的信息。通过 &lt;code&gt;--internal-counters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c0ab9812442b7cb897140c469f1cac49b38dcf7" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 解压缩到另一个构造函数中后，这些开销都可以减少1个字（4或8个字节）。</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;ByteString&lt;/code&gt; 打包到另一个构造函数中后，这些开销都可以减少1个字（4或8个字节）。</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">这些论文和有关箭头的更多信息可以在&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="980eb694aecbc7d843eb7aedc5a7c4e4407cf823" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">这些论文和有关箭头的更多信息可以在&lt;a href=&quot;https://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些模式仅在GHC 8.0或更高版本中可用，而8.2版更适用于它们。当近期这些版本GHC的文字，图案可以代替使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">这些可能重叠，但是无论标志设置如何，GHC都不会抱怨实例声明本身。如果我们以后尝试解决约束 &lt;code&gt;(C Int Char)&lt;/code&gt; ,则只有第一个实例匹配，并且一切都很好。与 &lt;code&gt;(C Bool Bool)&lt;/code&gt; 相似。但是，如果我们尝试解决 &lt;code&gt;(C Int Bool)&lt;/code&gt; ，则两个实例都匹配，并且会报告错误。</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">这些实用名词控制着函数定义的内联。</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">这些限制很容易验证，并确保终止类型推断。但是，在存在所谓的&amp;ldquo;循环等式&amp;rdquo;（例如 &lt;code&gt;a ~ [F a]&lt;/code&gt; 的情况下，它们不足以保证类型推断的完整性，在这种情况下，类型变量的递归出现在族应用程序的下方，并且数据构造器应用程序-有关详细信息，请参见上述文章。</target>
        </trans-unit>
        <trans-unit id="9f701b27c6f77c55b38a0a5e6d91357571f66567" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;rsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">这些限制很容易验证，并确保终止类型推断。但是，在存在所谓的&amp;ldquo;循环等式&amp;rdquo;（例如 &lt;code&gt;a ~ [F a]&lt;/code&gt; 的情况下，它们不足以保证类型推断的完整性，在这种情况下，类型变量的递归出现在族应用程序的下方，并且数据构造器应用程序-有关详细信息，请参见上述文章。</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">这些限制确保实例解析终止：每个简化步骤至少使一个构造函数使问题变小。您可以在论文中&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;通过约束处理规则了解功能依赖性&lt;/a&gt;找到许多背景材料，以了解这些限制的原因。。</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">这些规则将记录通配符限制在用户可以编写扩展版本的情况下。例如</target>
        </trans-unit>
        <trans-unit id="3572299793ccce6d8d28737f8cbd5463ebd7fbd6" translate="yes" xml:space="preserve">
          <source>These two types of folds are typified by the left-associative strict &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` and the right-associative lazy &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这两种类型的褶皱都是由左结合严格的代表 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; '和右结合懒 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似。</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">这些类型对于实现处理可变数量的参数 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 是必需的。从模块中看不到它们的实现。如果您尝试将不是该适当类的实例的类型的参数传递给 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; ，则编译器会将其报告为缺少的 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例。 （所有 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例都是 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">为了访问Haskell中的C库接口，需要使用这些类型来精确表示C函数原型。 Haskell系统不需要完全像C那样表示这些类型，但是对于表示C类型 &lt;code&gt;t&lt;/code&gt; 的Haskell类型 &lt;code&gt;CT&lt;/code&gt; 提供了以下保证：</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 第 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，和是的情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 。这是否意味着 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; 的（分别 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; 的的）情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的行为（分别为 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ）一样糟糕。</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 基本外交类型的S，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 的种S &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;和&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">上述函数的这些变体用于不懂Unicode的C库。这些函数的使用应谨慎,因为可能会造成信息丢失。</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">以上函数的这些变体用于与C语言库有关的C库，这些C库使用C &lt;code&gt;wchar_t&lt;/code&gt; 类型以依赖于系统的方式对Unicode进行编码。支持的唯一编码是</target>
        </trans-unit>
        <trans-unit id="d4df89c18ae8de17d49ca0683c16ba6bdd50a129" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="translated">如果遇到输入结束，则它们将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。进一步来说：</target>
        </trans-unit>
        <trans-unit id="50f263b93d3c7ccbcb56063a272d2935f84a444b" translate="yes" xml:space="preserve">
          <source>They return &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if they encounter the end of input. More specifically:</source>
          <target state="translated">如果遇到输入结束，则它们将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。进一步来说：</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">他们告诉 &lt;code&gt;make&lt;/code&gt; ，如果有任何的 &lt;code&gt;Foo.o&lt;/code&gt; ， &lt;code&gt;Foo.hc&lt;/code&gt; 或 &lt;code&gt;Foo.s&lt;/code&gt; 有较早的修改日期比 &lt;code&gt;Baz.hi&lt;/code&gt; ，再出过期的文件必须予以更新。为了把它最新的， &lt;code&gt;make&lt;/code&gt; 寻找一个规则来做到这一点; 前面的后缀规则之一可以很好地完成这项工作。这些依赖可以由 &lt;code&gt;ghc&lt;/code&gt; 自动生成；请参阅&lt;a href=&quot;#makefile-dependencies&quot;&gt;依赖项生成&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">它们在Simon Peyton Jones，Andrew Gordon和Sigbjorn Finne 的论文&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&amp;ldquo; Concurrent Haskell&amp;rdquo;中&lt;/a&gt;进行了介绍，尽管此后其实现的某些细节已发生了变化（特别是用于错误的完整 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的外观，但现在仅是块状）。 ）</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">需要注意的事项:</target>
        </trans-unit>
        <trans-unit id="7491f2cc71840e16ed3ed05e5fb825c9e4a1db46" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">此&amp;ldquo;功能&amp;rdquo;与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 具有表面上的相似之处，但实际上它是混乱的恶毒代理。它揭开了现实（和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad）的接缝，使常规规则不再适用。它会让您认为这是合理的，但是当您不看时，它会刺伤您的背部，并为所有可变缓冲区起别名。许多经验丰富的Haskell程序员的尸体被撒在脚上。</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">这个&amp;ldquo;功能&amp;rdquo;与 &lt;code&gt;unsafePerformIO&lt;/code&gt; 有表面上的相似之处，但实际上它是混乱的恶毒代理。它揭开了现实的接缝（以及 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad），使常规规则不再适用。它使您认为它是合理的，但是当您不看它时，它会刺伤您的背部，并为所有可变缓冲区起别名。许多经验丰富的Haskell程序员的尸体散落在其脚下。</target>
        </trans-unit>
        <trans-unit id="4c6dd831f46ec853aa8fce97c6a2a27a512463cc" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">此&amp;ldquo;功能&amp;rdquo;与 &lt;code&gt;unsafePerformIO&lt;/code&gt; 具有表面上的相似之处，但实际上它是混乱的恶毒代理。它揭开了现实（和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad）的接缝，使常规规则不再适用。它会让您认为这是合理的，但是当您不看时，它会刺伤您的背部，并为所有可变缓冲区起别名。许多经验丰富的Haskell程序员的尸体被撒在脚上。</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">此&amp;ldquo;功能&amp;rdquo;可能违反直觉： &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; 将把中间C代码放入文件 &lt;code&gt;foo.o&lt;/code&gt; 中。，尽管名称！</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">这个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 在对字符串进行模式匹配时，使用相等谓词。</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="c332f21db0753a9ce2e0bf5358f7f0659bb25726" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="6f9b155da963f248e8bbd48cdc8d158a756b4231" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">可以将此 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 扩展为默认提供的格式类型以外的其他格式。这是通过实例化 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 并为该类型提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 来完成的。可以提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 来处理特定于类型的修饰符，但是默认实例通常是最佳选择。</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">这种缩写使顶层申报片更安静、更不吓人。</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">这个抽象的数据类型表示解析错误消息。有四种消息。</target>
        </trans-unit>
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">这将调整所有列号,从42开始。这个参数的存在只影响诊断的质量,并不改变代码本身的语法。</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">这允许通过指定另一种相等的运行时表示形式来 &lt;code&gt;deriving&lt;/code&gt; 类型的类实例（例如，在两者之间存在一个 &lt;code&gt;Coercible&lt;/code&gt; 实例：请参阅&lt;a href=&quot;#coercible&quot;&gt;Coercible约束&lt;/a&gt;），该已经是这个类的一个实例。</target>
        </trans-unit>
        <trans-unit id="b751018507dda770efb90b1f91e7734fdc436369" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;equality_constraints#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">这允许 &lt;code&gt;deriving&lt;/code&gt; （例如，存在一个通过指定另一类型等于运行时表示的一类类实例 &lt;code&gt;Coercible&lt;/code&gt; ：看到两者实例&lt;a href=&quot;equality_constraints#coercible&quot;&gt;的强制转换的约束&lt;/a&gt;），该已经是这个类的一个实例。</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">这允许具有指定字段的记录类型具有多态的定义。例如，以下内容适用于任何具有字段 &lt;code&gt;name :: String&lt;/code&gt; 记录类型：</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">这允许你写更短的签名。</target>
        </trans-unit>
        <trans-unit id="e8a1d903f792395fe48e068f8423dc24b82157d5" translate="yes" xml:space="preserve">
          <source>This also applies to GADT-style data instances:</source>
          <target state="translated">这也适用于GADT风格的数据实例。</target>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">这假定库 &lt;code&gt;libfoo.so&lt;/code&gt; 位于当前目录中，并且一旦部署了程序，便可以在与可执行文件 &lt;code&gt;main&lt;/code&gt; 所在的目录中找到该库。同样，可以使用相对于可执行文件的子目录，例如 &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61fe3a7a67ef0295ed3b813ce3259d063c2d2b72" translate="yes" xml:space="preserve">
          <source>This avoid generating Typeable-related bindings for modules and types. This is useful when debugging because it gives smaller modules and dumps, but the compiler will panic if you try to use Typeable instances of things that you built with this flag.</source>
          <target state="translated">这可以避免为模块和类型生成Typeable相关的绑定。这在调试时很有用,因为它提供了更小的模块和转储,但如果你试图使用你用这个标志构建的东西的Typeable实例,编译器会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="f6f906decfdad529805a16ffec27620b40f24764" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这在4.10.0.0中成为类型类方法。在此之前，它是根据 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 定义的函数。</target>
        </trans-unit>
        <trans-unit id="9638426e03b58cbb0b8529e91d4b2a020cb1636d" translate="yes" xml:space="preserve">
          <source>This became a typeclass method in 4.10.0.0. Prior to that, it was a function defined in terms of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这在4.10.0.0中成为类型类方法。在此之前，它是根据 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 定义的函数。</target>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">表现为 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; ，除了始终保证小数点（即使不需要）外。</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">这种行为不同于GHC内置的Ctrl-C处理方式,它可能在用户第二次按下Ctrl-C后立即终止程序。</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">这种行为对大多数应用来说应该是足够的。</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">这种行为取决于一个键的可到达性是什么意思。在非正式的情况下,如果某个东西可以通过根集的普通指针到达,但不能通过弱指针到达,那么它就是可到达的。我们将可到达性更精确地定义如下。</target>
        </trans-unit>
        <trans-unit id="016ad1599c06fe3db26044725923f3c8ab895470" translate="yes" xml:space="preserve">
          <source>This behaviour is considered an implementation detail and code relying on thread local state should instead use one of the interfaces provided in &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; to make this explicit.</source>
          <target state="translated">将此行为视为实现细节，并且依赖于线程本地状态的代码应改用&lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent中&lt;/a&gt;提供的接口之一来使之明确。</target>
        </trans-unit>
        <trans-unit id="6b2b05c125a4021b12f162035f98b456ef9c82e9" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt;&lt;code&gt;NondecreasingIndentation&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">此行为由&lt;a href=&quot;#extension-NondecreasingIndentation&quot;&gt; &lt;code&gt;NondecreasingIndentation&lt;/code&gt; &lt;/a&gt;扩展控制。</target>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">此行为由 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 扩展控制。</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">当设置了 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; = True选项时，此行为由 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; ）实现。特别是， &lt;code&gt;SIGINT&lt;/code&gt; 信号将被忽略，直到 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 返回（或 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 返回非Nothing结果）为止，因此对每个创建的进程使用 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 变得尤为重要。</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">在控制评估顺序时，此行为有时很有用。值得注意的是，在 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 的库定义中使用了 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">这些都可以用一个小脚本来封装。</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">这可以用以下方法编译和运行。</target>
        </trans-unit>
        <trans-unit id="f7e5132d5805fa0f4b66063054f14a1690215ca6" translate="yes" xml:space="preserve">
          <source>This can be exponential in the arity of the pattern and in the number of guards in some cases. The &lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt;&lt;/a&gt; limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</source>
          <target state="translated">在某些情况下，模式的多样性和警卫人数可能是指数级的。该&lt;a href=&quot;#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-fmax-pmcheck-models=⟨n⟩&lt;/code&gt; &lt;/a&gt;限制可以确保我们的模式的数量多项式规模，由于忘记从部分匹配成功获得提炼信息。对于上面的示例，如果限制为1，我们将继续使用原始的未精炼模型检查下一个子句。</target>
        </trans-unit>
        <trans-unit id="c46a06f859ec4216c3665e278e7c6dd66a8347dc" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly quantifying over &lt;code&gt;k&lt;/code&gt;:</source>
          <target state="translated">这可以通过显式量化 &lt;code&gt;k&lt;/code&gt; 来解决：</target>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">这对于调试特别有用：如果您的程序抱怨出现 &lt;code&gt;head []&lt;/code&gt; 错误，并且您不知道是哪段代码引起它， &lt;code&gt;-prof -fprof-auto&lt;/code&gt; 使用-prof -fprof-auto（请参阅&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;）进行编译并运行使用 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; 将在发生错误时准确地告诉您调用堆栈。</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">例如,这可以用来重新定位标准手柄。</target>
        </trans-unit>
        <trans-unit id="0931038d623b08783b09e8bd0091edc745c9aed9" translate="yes" xml:space="preserve">
          <source>This can be useful when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">当数值数据类型的正负范围不匹配时，这很有用。例如，在8位算术中，-128是可表示的，但+128不是可表示的。因此， &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 将引发意外的整数字面溢出消息。</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">当你知道被审查的表达式没有非底值时,这就很有用。例如</target>
        </trans-unit>
        <trans-unit id="eddd4c05222390632f36d3c6901904480d608851" translate="yes" xml:space="preserve">
          <source>This can be worked around by defining extra functions which are specified to be linear, such as:</source>
          <target state="translated">这可以通过定义额外的函数来解决,这些函数被指定为线性的,例如:</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">当数值数据类型的正负范围不匹配时，这可能会有所不同。例如，在8位算术中，-128是可表示的，但+128不是。因此 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 将引发意外的整数字面溢出消息。</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的背景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的前景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">如果你有一个包含Template Haskell代码的多模块程序,并且你需要编译它进行剖析,这就会造成困难,因为GHC不能加载剖析过的对象代码并在执行拼接时使用它。</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">此更改仅适用于主模块。无论 &lt;code&gt;-main-is&lt;/code&gt; 标志如何，其他模块仍将从默认的导出列表中导出 &lt;code&gt;main&lt;/code&gt; 。这允许将 &lt;code&gt;-main-is&lt;/code&gt; 与通过默认导出列表导出 &lt;code&gt;main&lt;/code&gt; 的现有模块一起使用，即使 &lt;code&gt;-main-is&lt;/code&gt; 指向不同的入口点（如本示例中所述）（与 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 编译）也是如此。</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">此类包含一些类型，您可以从&lt;em&gt;术语中&lt;/em&gt;包含的信息中学习两种类型的相等性。通常，只有单例类型可以居住在此类中。</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">这个类给出了与类型级自然相关的整数。每一个具体的文字都有这个类的实例:0,1,2,等等。</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">这个类给出了与类型级符号相关联的字符串。每一个具体的文字符号都有该类的实例。&quot;hello&quot;,等等。</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">这个类是作为缺乏FlexibleInstances的Haskell98兼容的变通方法而需要的。</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">此类在GHC和Hugs支持的递归 &lt;code&gt;do&lt;/code&gt; 表示法的翻译中使用。</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">该类仅具有一个实例，被用作一种变通方法，以解决 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 作为具体类型不允许作为typeclass实例的事实。导出 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">这个代码片段应该引起一个致命的错误,但它没有。</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="83010be07376269d9080bf541aef5e0b9bd24515" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（与其自己编写这段代码，不如使用抽象抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0459111867f0b4bf21ea31dbb72a95eb8474fa39" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（与其自己编写这段代码，不如使用抽象抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3494ba5905a6ab7393145cd907a3ba47ca64dbf3" translate="yes" xml:space="preserve">
          <source>This code is in the style of both transformers and mtl, and is compatible with them, though doesn't mimic the module structure or offer the complete range of features in those packages.</source>
          <target state="translated">这段代码采用了transformers和mtl的风格,并与它们兼容,不过并没有模仿这些包中的模块结构或提供完整的功能。</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该组合器实现选择。解析器 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 首先应用 &lt;code&gt;p&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;p&lt;/code&gt; 的值。如果 &lt;code&gt;p&lt;/code&gt; 失败&lt;em&gt;而不消耗任何输入&lt;/em&gt;，则尝试解析器 &lt;code&gt;q&lt;/code&gt; 。此组合子被定义等于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 所述的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类和（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05f82f2ce2fd9bc7ef8dc6adbbe8bab553e349cc" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该组合器实现选择。解析器 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 首先应用 &lt;code&gt;p&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;p&lt;/code&gt; 的值。如果 &lt;code&gt;p&lt;/code&gt; 失败&lt;em&gt;而不消耗任何输入&lt;/em&gt;，则尝试解析器 &lt;code&gt;q&lt;/code&gt; 。此组合子被定义等于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 所述的构件 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类和（ &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）的构件 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d271e551be54c1cdaf8d8475b3236094d494ecd" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该组合器实现选择。解析器 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 首先应用 &lt;code&gt;p&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;p&lt;/code&gt; 的值。如果 &lt;code&gt;p&lt;/code&gt; 失败&lt;em&gt;而不消耗任何输入&lt;/em&gt;，则尝试解析器 &lt;code&gt;q&lt;/code&gt; 。此组合子被定义等于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 所述的构件 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类和（ &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）的构件 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">即使通过管道而不是通过适当的终端进行交互，此命令也允许从GHCi请求命令完成，并且该命令旨在将GHCi的完成与文本编辑器和IDE集成在一起。</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">这条命令对于高亮显示和导航编辑器和IDE中标识符的所有用途非常有用。</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个goto-definition设施。</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个show-type-under-point设施。</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">由于以下 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 异常之一，此计算可能会失败：</target>
        </trans-unit>
        <trans-unit id="3a53acc002bbe269420ba165928d4d81ea8f10ab" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">由于以下 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 异常之一，此计算可能会失败：</target>
        </trans-unit>
        <trans-unit id="ed67e498f09c1f718f1eeef445a1a02f8f1c9aa1" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">由于以下 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 异常之一，此计算可能会失败：</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">这个计算可能会失败,因为:</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">这涉及到外部呼叫与 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 的交互。通常，当外部调用涉及 &lt;code&gt;throwTo&lt;/code&gt; 的目标时，在调用返回之前不会引发异常，与此同时，调用者也将被阻止。这可能会导致无响应，这在用户中断（例如Control-C）的情况下尤其不希望出现。当收到Control-C信号时（在Unix上为 &lt;code&gt;SIGINT&lt;/code&gt; ），默认行为是在主线程中引发 &lt;code&gt;UserInterrupt&lt;/code&gt; 异常；如果此时主线程在外部调用中被阻塞，则程序将不会响应用户中断。</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">这个条件不被类型检查。您必须确保所提供的值是自己有效的总订单。</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">这将转换一个字符串,但保留了不可换行的空格,并在输入列表中的每个字符串之间添加换行符。</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">这将转换一个字符串,但保留了不可断行的空格。</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">这对应于 &lt;code&gt;base&lt;/code&gt; 的&lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt;模块提供的 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="b849491aac2caa06d22e6da0aa56daf804da18ae" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">这对应于 &lt;code&gt;base&lt;/code&gt; 的&lt;a href=&quot;../base-4.14.1.0/numeric&quot;&gt;Numeric&lt;/a&gt;模块提供的 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="d376b70e2f4efe4cf1c1f4fa399b2057e2187eec" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.15.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">这对应于 &lt;code&gt;base&lt;/code&gt; 的&lt;a href=&quot;../base-4.15.0.0/numeric&quot;&gt;Numeric&lt;/a&gt;模块提供的 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">目前,这使</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">这种数据类型表示一个等价关系。</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">此数据类型指定可处理类型为 &lt;code&gt;a&lt;/code&gt; 的值的运算符。运算符可以是二进制中缀，也可以是一元前缀或后缀。二元运算符也具有关联性。</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">此数据类型指定运算符的关联性:左、右或无。</target>
        </trans-unit>
        <trans-unit id="831a0b5e449e944bcd13dda14651accbf5a15f97" translate="yes" xml:space="preserve">
          <source>This data type uses a Haskell98-style declaration. The only part of this data type that is not Haskell98 code is &lt;code&gt;unT&lt;/code&gt;, whose type uses higher-rank polymorphism (&lt;a href=&quot;rank_polymorphism#arbitrary-rank-polymorphism&quot;&gt;Arbitrary-rank polymorphism&lt;/a&gt;). To construct the type of the &lt;code&gt;unT&lt;/code&gt; field selector, we will assemble the following:</source>
          <target state="translated">此数据类型使用Haskell98样式的声明。该数据类型中唯一不是Haskell98代码的部分是 &lt;code&gt;unT&lt;/code&gt; ，其类型使用更高级别的多态性（&lt;a href=&quot;rank_polymorphism#arbitrary-rank-polymorphism&quot;&gt;任意级别的多态性&lt;/a&gt;）。为了构造 &lt;code&gt;unT&lt;/code&gt; 字段选择器的类型，我们将组装以下内容：</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">此数据类型见证了 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 向点 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 的提升。</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">数据类型 &lt;code&gt;G&lt;/code&gt; 的类型和类型均类似于GADT。假设您有 &lt;code&gt;g :: G a&lt;/code&gt; ，其中 &lt;code&gt;a :: k&lt;/code&gt; 。然后，模式匹配，以发现 &lt;code&gt;g&lt;/code&gt; 其实 &lt;code&gt;GMaybe&lt;/code&gt; 告诉你们的是 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 和 &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; 的定义要求&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;有效，但是 &lt;code&gt;G&lt;/code&gt; 上的模式匹配不需要扩展到&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;之外。这项工作实际上是常规GADT的直接扩展，并且是种类和类型相同的事实的结果。</target>
        </trans-unit>
        <trans-unit id="0ab78fb6ca9a0cac82260654f0f4cc814bc37c64" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;gadt#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">数据类型 &lt;code&gt;G&lt;/code&gt; 的类型和类型均类似于GADT。假设您有 &lt;code&gt;g :: G a&lt;/code&gt; ，其中 &lt;code&gt;a :: k&lt;/code&gt; 。然后，模式匹配，以发现 &lt;code&gt;g&lt;/code&gt; 其实 &lt;code&gt;GMaybe&lt;/code&gt; 告诉你们的是 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 和 &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; 的定义要求&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;有效，但是 &lt;code&gt;G&lt;/code&gt; 上的模式匹配不需要扩展到&lt;a href=&quot;gadt#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;之外。这项工作实际上是常规GADT的直接扩展，并且是种类和类型相同的事实的结果。</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">此数据类型作为用于缓冲器逐缓冲器执行的共同界面 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 。该接口的典型用户是 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 或iteratee风格的库，例如 &lt;code&gt;enumerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">这个解码器的缺点是,它需要在返回之前读取所有的输入。另一方面,它不会返回任何东西,直到它知道它可以在没有任何解码器错误的情况下进行解码。</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">该定义允许基于操作系统的条件编译，其中&amp;ldquo; os&amp;rdquo;是当前操作系统的名称（例如 &lt;code&gt;linux&lt;/code&gt; ，Windows的 &lt;code&gt;mingw32&lt;/code&gt; ， &lt;code&gt;solaris&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">此定义允许基于主机体系结构进行条件编译，其中&amp;ldquo; arch&amp;rdquo;是当前体系结构的名称（例如 &lt;code&gt;i386&lt;/code&gt; ， &lt;code&gt;x86_64&lt;/code&gt; ， &lt;code&gt;powerpc&lt;/code&gt; ， &lt;code&gt;sparc&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">这个定义使 &lt;code&gt;f1&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 中严格，而如果没有爆炸声，它将是懒惰的。爆炸模式当然可以嵌套：</target>
        </trans-unit>
        <trans-unit id="b91b94fef6db287d03fbeab2dc4d7e8eab765914" translate="yes" xml:space="preserve">
          <source>This definition works for any applicative functor in the co-domain of &lt;code&gt;f&lt;/code&gt;, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">该定义适用于 &lt;code&gt;f&lt;/code&gt; 的共域中的任何应用函子，因为 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的定律暗示了一种缔合形式。</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">这表示在其中派生上下文的派生 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 实例，其方式与普通 &lt;code&gt;deriving&lt;/code&gt; 子句相同。禁止在独立 &lt;code&gt;deriving&lt;/code&gt; 声明中使用通配符。</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">这种设计使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的实现可以完全访问 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad。因此，必须 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 小心，不要覆盖给定BufferRange之外的任何内容。此外，还必须格外小心，以确保 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 是参照透明的。请参阅 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 的注释并 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 函数以获取更多信息。请注意，使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 时&lt;em&gt;根本没有安全带&lt;/em&gt;：您正在编写代码，可能会在Haskell服务器上启用下一个缓冲区溢出攻击！</target>
        </trans-unit>
        <trans-unit id="9424f4d941d065861400a0aac7eda9e8e5e684ee" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">这种设计使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的实现可以完全访问 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad。因此，必须 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 小心，不要覆盖给定BufferRange之外的任何内容。此外，还必须格外注意，以确保 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 是参照透明的。请参阅 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 的注释并 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 函数以获取更多信息。请注意，使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 时&lt;em&gt;根本没有安全带&lt;/em&gt;：您正在编写代码，可能会在Haskell服务器上启用下一个缓冲区溢出攻击！</target>
        </trans-unit>
        <trans-unit id="ffd98d4a6017bba368758de2469c58f09f328ffb" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">这种设计使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的实现可以完全访问 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad。因此，必须 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 小心，不要覆盖给定BufferRange之外的任何内容。此外，还必须格外注意，以确保 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 是参照透明的。请参阅 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 的注释并 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 函数以获取更多信息。请注意，使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 时&lt;em&gt;根本没有安全带&lt;/em&gt;：您正在编写代码，可能会在Haskell服务器上启用下一个缓冲区溢出攻击！</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">由于&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 的&lt;/a&gt;工作方式，这种区别很重要。派生的 &lt;code&gt;Functor Right&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="35e478384f40b7a1e661dbe9f918af72fd276223" translate="yes" xml:space="preserve">
          <source>This distinction is only meaningful for monads which have multiple exit points, such as &lt;code&gt;Except&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt;. For monads that only have a single exit point, there is no difference between &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; has a more constrained type.</source>
          <target state="translated">这种区别仅对具有多个退出点的 &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-maybe#t:MaybeT&quot;&gt;MaybeT&lt;/a&gt;&lt;/code&gt; （例如 &lt;code&gt;Except&lt;/code&gt; 和MaybeT）有意义。对于仅具有单个出口点的monad， &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; 之间没有区别，除了 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:onError&quot;&gt;onError&lt;/a&gt;&lt;/code&gt; 具有更受约束的类型。</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">这不会嵌入任何运行时路径。它依赖于共享库在标准位置或 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量给定的目录中可用。</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">这不再起作用了。假设模块 &lt;code&gt;C&lt;/code&gt; 进口模块 &lt;code&gt;B&lt;/code&gt; ，和 &lt;code&gt;B&lt;/code&gt; 进口模块 &lt;code&gt;A&lt;/code&gt; 。因此，对模块 &lt;code&gt;A&lt;/code&gt; 的更改可能需要重新编译模块 &lt;code&gt;C&lt;/code&gt; ，因此，在 &lt;code&gt;A.hi&lt;/code&gt; 更改时，我们应检查是否应重新编译 &lt;code&gt;C&lt;/code&gt; 。但是， &lt;code&gt;C&lt;/code&gt; 的依存关系只会列出 &lt;code&gt;B.hi&lt;/code&gt; ，而不 &lt;code&gt;A.hi&lt;/code&gt; ，并且可以想到，对 &lt;code&gt;A&lt;/code&gt; 的某些更改（更改出现在 &lt;code&gt;B&lt;/code&gt; 导出的函数的内联中的函数的定义）可能不会更改 &lt;code&gt;B.hi&lt;/code&gt; 一个记号。所以现在</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">由于变量 &lt;code&gt;x&lt;/code&gt; 具有表示多态类型，因此消除了 &lt;code&gt;bad&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">这样就可以在代码生成器的汇编阶段实现快捷化。简单来说,捷径的意思是,如果一个指令块A只由一个无条件跳转组成,我们就用跳转到A的后继者来代替所有对A的跳转。</target>
        </trans-unit>
        <trans-unit id="f7bbbb3ab3d29cf5ffa8743547ffc2d2bd5ddb95" translate="yes" xml:space="preserve">
          <source>This enables static control flow prediction on the final Cmm code. If enabled GHC will apply certain heuristics to identify loops and hot code paths. This information is then used by the register allocation and code layout passes.</source>
          <target state="translated">这可以对最终的Cmm代码进行静态控制流预测。如果启用,GHC将应用某些启发式方法来识别循环和热代码路径。这些信息将被用于寄存器分配和代码布局通道。</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">这种编码在任何一个方向上都不会失败。但是,编码会丢弃信息,所以编码之后的解码不是身份。</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">该编码使用字节序列 &quot;xc0x80 &quot;表示NUL,字符串以NUL结尾。</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用双折前的每一步之前将其强制转换为弱头正常形态，避免了否则会发生的团块聚集。这通常是您要严格将有限结构简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="913f56eb4194e0ecead838a70ce1e6d3cf6501e8" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to Weak Head Normal Form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single strict result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可以确保折痕的每一步在应用之前都被强制设置为弱头正常形态，避免了否则会发生的松动现象。这通常是您要严格将有限结构简化为单个严格结果（例如 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; ）的方法。</target>
        </trans-unit>
        <trans-unit id="4223c1939c432f75f827180d4e7260a63349ec55" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to Weak Head Normal Form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single strict result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可以确保折痕的每一步在应用之前都被强制设置为弱头正常形态，避免了否则会发生的松动现象。这通常是您要严格将有限结构简化为单个严格结果（例如 &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; ）的方法。</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">这个错误信息。</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">这样可以确定模块是受信任的，但是保证由模块的作者提供。然后，该模块的客户端通过指定他们信任包含该模块的程序包来指定他们信任该模块的作者。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;并不将模块限制在安全语言范围内。但是，它确实限制了重叠实例的分辨率，只允许&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全重叠实例&lt;/a&gt;。它还允许使用安全导入关键字。</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">这个例子让我们了解了转义延续的工作原理,展示了它们的典型使用模式。</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">这个例子是一个缩减版的,在</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">如果直接使用 &lt;code&gt;Type&lt;/code&gt; 构造函数，则此示例等效于复杂得多的构造。</target>
        </trans-unit>
        <trans-unit id="352d62082975f9e8c31475e16d2847378caf0fdb" translate="yes" xml:space="preserve">
          <source>This example is rejected, as a visible argument should by definition be explicitly applied. Making them inferred (and thus not appliable) would be conflicting.</source>
          <target state="translated">这个例子是被拒绝的,因为根据定义,可见论点应该是明确适用的。使它们成为推论的(因此不能适用)将是矛盾的。</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">此示例仅需要 &lt;code&gt;Functor&lt;/code&gt; ，因为它被转换为 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 。一个更复杂的示例需要 &lt;code&gt;Applicative&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">本例使用 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 的Microsoft Word的功能，但提供 &lt;code&gt;HsStart&lt;/code&gt; 是第一个函数之前调用， &lt;code&gt;HsEnd&lt;/code&gt; 在最后，那么它会正常工作。</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此示例改编自原始的Concurrent Haskell论文。有关用于构建高级同步原语的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的更多示例，请参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">此异常不适用于语句，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">另一个调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 的线程会引发此异常，如果系统由于某种原因需要终止该线程，则会引发该异常。</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">当用户通过通常的机制(例如控制台中的Control-C)请求终止程序时,程序的主线程会默认引发这个异常。</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">此扩展允许程序员使用列表符号构造结构，例如： &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;IntMap&lt;/code&gt; ， &lt;code&gt;Vector&lt;/code&gt; ， &lt;code&gt;Text&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; 。下面的代码清单给出了一些示例：</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">此扩展名使我们可以编写形式为 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 约束。Eq b =&amp;gt; Eq（fb），这是解决因 &lt;code&gt;(==)&lt;/code&gt; 方法的第二次使用而引起的 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 约束所必需的。</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">此扩展还可以显式量化&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;，&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;，&lt;a href=&quot;#closed-type-families&quot;&gt;封闭类型系列&lt;/a&gt;，&lt;a href=&quot;#assoc-inst&quot;&gt;关联实例&lt;/a&gt;和&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则中&lt;/a&gt;的类型和种类变量。</target>
        </trans-unit>
        <trans-unit id="536f19bd6cf13372c7c568246c5a2d2331aa186e" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;type_families#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;type_families#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;type_families#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;type_families#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">此扩展还可以显式量化&lt;a href=&quot;type_families#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;，&lt;a href=&quot;type_families#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;，&lt;a href=&quot;type_families#closed-type-families&quot;&gt;封闭类型族&lt;/a&gt;，&lt;a href=&quot;type_families#assoc-inst&quot;&gt;关联实例&lt;/a&gt;和&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;重写规则中&lt;/a&gt;的类型和种类变量。</target>
        </trans-unit>
        <trans-unit id="0f49ba4e744c9be271237eb0c498b43e818d8451" translate="yes" xml:space="preserve">
          <source>This extension also relaxes some of the restrictions around data family instances. In particular, &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; permits a &lt;code&gt;newtype instance&lt;/code&gt; to be given a return kind of &lt;code&gt;TYPE r&lt;/code&gt;, not just &lt;code&gt;Type&lt;/code&gt;. For example, the following &lt;code&gt;newtype instance&lt;/code&gt; declarations would be permitted:</source>
          <target state="translated">此扩展还放宽了对数据族实例的一些限制。特别是，&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;允许给新 &lt;code&gt;TYPE r&lt;/code&gt; &lt;code&gt;newtype instance&lt;/code&gt; 赋予TYPE r的返回类型，而不仅仅是 &lt;code&gt;Type&lt;/code&gt; 。例如，将允许以下新类型 &lt;code&gt;newtype instance&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">该扩展可以在以下地方进行种类签名:</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">此扩展概括了&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;。要使用GND 派生 &lt;code&gt;Num Unicode&lt;/code&gt; （ &lt;code&gt;deriving newtype Num&lt;/code&gt; ），它必须重用 &lt;code&gt;Num Int&lt;/code&gt; 实例。使用 &lt;code&gt;DerivingVia&lt;/code&gt; ，我们可以显式指定表示类型 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bbc89d69b20fe11c6a3d394e6059acbe8810468" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">此扩展概括了&lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;。要使用GND派生 &lt;code&gt;Num Unicode&lt;/code&gt; （ &lt;code&gt;deriving newtype Num&lt;/code&gt; ），它必须重用 &lt;code&gt;Num Int&lt;/code&gt; 实例。使用 &lt;code&gt;DerivingVia&lt;/code&gt; ，我们可以显式指定表示类型 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c9ca40eca072f061d5d015785400da83bc7d6281" translate="yes" xml:space="preserve">
          <source>This extension has been originally conceived of in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/linear-haskell-practical-linearity-higher-order-polymorphic-language/&quot;&gt;Linear Haskell: practical linearity in a higher-order polymorphic language&lt;/a&gt; (POPL 2018)</source>
          <target state="translated">此扩展最初是在《&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/linear-haskell-practical-linearity-higher-order-polymorphic-language/&quot;&gt;线性Haskell：高阶多态语言中的实用线性》&lt;/a&gt;（POPL 2018）一书中构思的。</target>
        </trans-unit>
        <trans-unit id="6100b971f8f1c7a7cc634cc306d12a82af5c029a" translate="yes" xml:space="preserve">
          <source>This extension impacts the determination of whether or not a newtype has a Complete User-Specified Kind Signature (CUSK). The exact impact is specified &lt;a href=&quot;#complete-kind-signatures&quot;&gt;the section on CUSKs&lt;/a&gt;.</source>
          <target state="translated">此扩展会影响新类型是否具有完整的用户指定的种类签名（CUSK）的确定。确切的影响&lt;a href=&quot;#complete-kind-signatures&quot;&gt;在CUSK的这一部分中&lt;/a&gt;指定。</target>
        </trans-unit>
        <trans-unit id="18783492d32e3c1b270b1600db180644b1ca6936" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">自GHC 8.6.1起，在&lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/libraries/proposals/monad-fail&quot;&gt;MonadFail提案（MFP）&lt;/a&gt;下默认启用此扩展。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
