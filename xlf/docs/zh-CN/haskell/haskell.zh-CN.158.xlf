<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="d84ebfc6fbaa58496dbe73b158b5610e0f005524" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">确保关闭了let-floating（ &lt;code&gt;-fno-full-laziness&lt;/code&gt; ），或者确保对 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的调用不能在lambda之外浮动。例如，如果您说： &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; ，则可能只获得对 &lt;code&gt;f&lt;/code&gt; 的所有调用之间共享的一个参考单元。最好是 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 因为现在它无法在lambda之外浮动。</target>
        </trans-unit>
        <trans-unit id="156fd7ebd73ad9d7d9ba6f146870be0be3263cef" translate="yes" xml:space="preserve">
          <source>Make sure that the either you switch off let-floating (&lt;code&gt;-fno-full-laziness&lt;/code&gt;), or that the call to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; cannot float outside a lambda. For example, if you say: &lt;code&gt;
           f x = unsafePerformIO (newIORef [])
        &lt;/code&gt; you may get only one reference cell shared between all calls to &lt;code&gt;f&lt;/code&gt;. Better would be &lt;code&gt;
           f x = unsafePerformIO (newIORef [x])
        &lt;/code&gt; because now it can't float outside the lambda.</source>
          <target state="translated">确保关闭了let-floating（ &lt;code&gt;-fno-full-laziness&lt;/code&gt; ），或者确保对 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的调用不能在lambda之外浮动。例如，如果您说： &lt;code&gt; f x = unsafePerformIO (newIORef []) &lt;/code&gt; ，则可能只获得对 &lt;code&gt;f&lt;/code&gt; 的所有调用之间共享的一个参考单元。最好是 &lt;code&gt; f x = unsafePerformIO (newIORef [x]) &lt;/code&gt; 因为现在它无法在lambda之外浮动。</target>
        </trans-unit>
        <trans-unit id="4240c3ab8260bb583d13050ed2064bbaae7bc43b" translate="yes" xml:space="preserve">
          <source>Make the interface loader be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">使接口加载程序&lt;em&gt;真实&lt;/em&gt;谈论它的功能。</target>
        </trans-unit>
        <trans-unit id="4358699704291b8174b75e1e492414b400dba246" translate="yes" xml:space="preserve">
          <source>Make the pattern match exhaustiveness checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">使模式匹配详尽度检查器为&lt;em&gt;实&lt;/em&gt;于需要做什么。</target>
        </trans-unit>
        <trans-unit id="d42a1e2a4e6f039639430d0f8ec96b5efe794a51" translate="yes" xml:space="preserve">
          <source>Make the renamer be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">使重命名器成为&lt;em&gt;真实的&lt;/em&gt;起死回生。</target>
        </trans-unit>
        <trans-unit id="8cd12a9927ea510906e14322831e59cfe0a4baca" translate="yes" xml:space="preserve">
          <source>Make the type checker be &lt;em&gt;real&lt;/em&gt; chatty about what it is up to.</source>
          <target state="translated">使类型检查器为&lt;em&gt;真&lt;/em&gt;健谈的人。</target>
        </trans-unit>
        <trans-unit id="15d9abd622590033f2c411d33953dd776c5be50c" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为任意对象创建一个 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。作为第一个参数传递的对象不会由 &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="c12968a0552ecdcf1b9de9b4f5c5bede7e5bbb53" translate="yes" xml:space="preserve">
          <source>Makes a &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; for an arbitrary object. The object passed as the first argument is not evaluated by &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为任意对象创建一个 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。作为第一个参数传递的对象不会由 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="aa32c2b4fd707872dac37cc6dbc8a7e855f28d02" translate="yes" xml:space="preserve">
          <source>Makes a binary Handle. This is for historical reasons; it should probably be a text Handle with the default encoding and newline translation instead.</source>
          <target state="translated">制作一个二进制的Handle,由于历史原因,这可能应该是一个文本Handle,用默认的编码和换行来代替。这是出于历史原因,它可能应该是一个带有默认编码和换行翻译的文本句柄。</target>
        </trans-unit>
        <trans-unit id="d4e61217ddb45f4a69f77fed47cefb695ba63354" translate="yes" xml:space="preserve">
          <source>Makes a constructor for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 创建一个构造函数。</target>
        </trans-unit>
        <trans-unit id="675f8bacbe562ad639f450df630ba3e1d4142613" translate="yes" xml:space="preserve">
          <source>Makes a pointer to a field struct. It will have the type &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt;.</source>
          <target state="translated">指向字段结构的指针。它将具有类型 &lt;code&gt;Ptr a -&amp;gt; Ptr b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d722c20f3a7b347acb5b13726b5fa9b1a3a525" translate="yes" xml:space="preserve">
          <source>Makes a specific warning into a fatal error. The warning will be enabled if it hasn&amp;rsquo;t been enabled yet. Can be reversed with &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">将特定警告变为致命错误。如果尚未启用警告，则将启用它。可以使用 &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 反转。</target>
        </trans-unit>
        <trans-unit id="b11cc1ed06b4ae510e6c368934b3332b8443ad9c" translate="yes" xml:space="preserve">
          <source>Makes any warning into a fatal error. Useful so that you don&amp;rsquo;t miss warnings when doing batch compilation. To reverse &lt;code&gt;-Werror&lt;/code&gt; and stop treating any warnings as errors use &lt;code&gt;-Wwarn&lt;/code&gt;, or use &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; to stop treating specific warnings as errors.</source>
          <target state="translated">将任何警告变为致命错误。有用，这样您在进行批处理编译时就不会错过警告。要反转 &lt;code&gt;-Werror&lt;/code&gt; 并停止将任何警告视为错误，请使用 &lt;code&gt;-Wwarn&lt;/code&gt; ，或使用 &lt;code&gt;-Wwarn=&amp;lt;wflag&amp;gt;&lt;/code&gt; 停止将特定警告视为错误。</target>
        </trans-unit>
        <trans-unit id="bbf1ed151ae759b693edba02d868a0ae08a8295e" translate="yes" xml:space="preserve">
          <source>Makes the second handle a duplicate of the first handle. The second handle will be closed first, if it is not already.</source>
          <target state="translated">使第二个手柄成为第一个手柄的副本。如果第二个手柄还没有被关闭,那么它将首先被关闭。</target>
        </trans-unit>
        <trans-unit id="610ca9a4f461051b57571e94ee46024ad1945482" translate="yes" xml:space="preserve">
          <source>Making functors whose elements are notionally in the reverse order from the original functor.</source>
          <target state="translated">使其元素在概念上与原漏斗器的顺序相反的漏斗器。</target>
        </trans-unit>
        <trans-unit id="de10c11c39a04c2dd93935591757ad821f0de619" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 制作函子相反顺序执行操作实例来。</target>
        </trans-unit>
        <trans-unit id="289b3ce3f004eadb698cbe23952c8692f75647d6" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">使用以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例来构造函子。</target>
        </trans-unit>
        <trans-unit id="316f89b1fd653898886f6125de784c38a5ec08fb" translate="yes" xml:space="preserve">
          <source>Making functors with an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">使用以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例来构造函子。</target>
        </trans-unit>
        <trans-unit id="155fd1571bb064a261bef3cb9235ad72ee317621" translate="yes" xml:space="preserve">
          <source>Malloc some data and return a &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; to it</source>
          <target state="translated">Malloc一些数据并返回一个 &lt;code&gt;&lt;a href=&quot;ghci-remotetypes#t:RemotePtr&quot;&gt;RemotePtr&lt;/a&gt;&lt;/code&gt; 它</target>
        </trans-unit>
        <trans-unit id="357e8ecf448ec27f6c58902a75153131236e9618" translate="yes" xml:space="preserve">
          <source>Manage separate memory pools for each node.</source>
          <target state="translated">为每个节点管理单独的内存池。</target>
        </trans-unit>
        <trans-unit id="27a837f8eed8146ea6300d174b2ba753bef518d3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8d02698e3a7db40c93071ad0130d603170bdbf3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量在&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b134cb33755b44d8cb28b21abf1877659563685" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量在&lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f6f1aebfb4c2d76356eff64760ef8d083e1ea9b" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理&lt;em&gt;惰性&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量&lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0938573170c5ad64ab547628da8f4334a36723ce" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理&lt;em&gt;惰性&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量在&lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="847ea03503ee75bf6cb87556d6d49608481050a3" translate="yes" xml:space="preserve">
          <source>Manipulate &lt;em&gt;lazy&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; equivalents in &lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 操作处理&lt;em&gt;惰性&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。所有字符将被截断为8位。可以预期的是，这些功能将以相同的速度到其运行 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#v:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 当量在&lt;a href=&quot;data-bytestring-lazy&quot;&gt;Data.ByteString.Lazy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="21b2945c3b95e9ba030912e565f7997d2afceb6a" translate="yes" xml:space="preserve">
          <source>Many codecs are not stateful, and in these case the state can be represented as &lt;code&gt;()&lt;/code&gt;. Other codecs maintain a state. For example, UTF-16 recognises a BOM (byte-order-mark) character at the beginning of the input, and remembers thereafter whether to use big-endian or little-endian mode. In this case, the state of the codec would include two pieces of information: whether we are at the beginning of the stream (the BOM only occurs at the beginning), and if not, whether to use the big or little-endian encoding.</source>
          <target state="translated">许多编解码器不是有状态的，在这种情况下，状态可以表示为 &lt;code&gt;()&lt;/code&gt; 。其他编解码器保持状态。例如，UTF-16在输入的开头识别出BOM（字节顺序标记）字符，并在此后记住是使用大端模式还是小端模式。在这种情况下，编解码器的状态将包含两条信息：我们是否位于流的开头（BOM仅出现在流的开头），如果不是，则使用大端编码还是小端编码。</target>
        </trans-unit>
        <trans-unit id="24d0ab19e4e99147773dbcbe9263cdf0c945a575" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">此模块中的许多函数与&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;或&lt;a href=&quot;../base-4.13.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;中的函数具有相同的名称。在几乎所有情况下，这些功能的行为类似。例如， &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 以与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.13.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 完全相同的方式过滤序列。filter过滤列表。唯一的主要例外是 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 功能，该功能基于&lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap中&lt;/a&gt;该名称的功能，而不是&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude中的功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c62b5fa473677017f2721ca5795d98e992c22e65" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">该模块中的许多函数与&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;或&lt;a href=&quot;../base-4.14.1.0/data-list&quot;&gt;Data.List&lt;/a&gt;中的函数具有相同的名称。在几乎所有情况下，这些功能的行为类似。例如， &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 以与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.14.1.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 完全相同的方式过滤序列。filter过滤列表。唯一的主要例外是 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 函数，该函数基于&lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap中&lt;/a&gt;该名称的函数，而不是&lt;a href=&quot;../base-4.14.1.0/prelude&quot;&gt;Prelude中的&lt;/a&gt;那个函数。</target>
        </trans-unit>
        <trans-unit id="32ed30cfd1996dd6a729e9c45a8bc70a6cf0b6f3" translate="yes" xml:space="preserve">
          <source>Many functions in this module have the same names as functions in the &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; or in &lt;a href=&quot;../base-4.15.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;. In almost all cases, these functions behave analogously. For example, &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a sequence in exactly the same way that &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.15.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; filters a list. The only major exception is the &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; function, which is based on the function by that name in &lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap&lt;/a&gt; rather than the one in &lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">该模块中的许多函数与&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;或&lt;a href=&quot;../base-4.15.0.0/data-list&quot;&gt;Data.List&lt;/a&gt;中的函数具有相同的名称。在几乎所有情况下，这些功能的行为类似。例如， &lt;code&gt;&lt;a href=&quot;data-sequence#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 以与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;.&lt;a href=&quot;../base-4.15.0.0/prelude#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 完全相同的方式过滤序列。filter过滤列表。唯一的主要例外是 &lt;code&gt;&lt;a href=&quot;data-sequence#v:lookup&quot;&gt;lookup&lt;/a&gt;&lt;/code&gt; 函数，该函数基于&lt;a href=&quot;data-intmap&quot;&gt;Data.IntMap中&lt;/a&gt;该名称的函数，而不是&lt;a href=&quot;../base-4.15.0.0/prelude&quot;&gt;Prelude中的&lt;/a&gt;那个函数。</target>
        </trans-unit>
        <trans-unit id="e8f58e0bdebbef9653cf1bc7b5100f112ff0653f" translate="yes" xml:space="preserve">
          <source>Many instances of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; (e.g. the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; instance) are conditionally lazy, and use or don't use their second argument depending on the value of the first. These are used with the folds below, which terminate as early as possible, but otherwise generally keep going. Some instances (e.g. for List) are always strict, but the result is lazy in the tail of the output, so that &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; for a list of lists is in fact corecursive. These folds are defined in terms of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 的许多实例（例如 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 实例）在条件上是懒惰的，根据第一个参数的值使用或不使用第二个参数。这些与下面的折叠一起使用，这些折叠会尽早终止，但通常会继续进行。某些情况下（如表）总是严格，但结果是在输出的尾部懒惰，使 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; 对列表的列表实际上是corecursive。这些折叠是根据 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 定义的。</target>
        </trans-unit>
        <trans-unit id="a54ffbaf5c6091b870718ed3779391643593140a" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算的元素数可以线性化，最大为&lt;em&gt;W&lt;/em&gt; - &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数（32或64）。</target>
        </trans-unit>
        <trans-unit id="98a01da62d47f087f540e76f8d5b26b5e49b62ce" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算可以在最大为&lt;em&gt;W&lt;/em&gt;的元素数量（即 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数）（32或64）中变为线性。</target>
        </trans-unit>
        <trans-unit id="9acf6964d94c05eea3598cac6c4c82a9ac869d16" translate="yes" xml:space="preserve">
          <source>Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of &lt;em&gt;W&lt;/em&gt; -- the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">许多运算的最坏情况复杂度为O（min（n，W））。这意味着该运算可以在最大为&lt;em&gt;W&lt;/em&gt;的元素数量（即 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 中的位数）（32或64）中变为线性。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="9eaadd708e5d269baf72848cf514c6218e594037" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;'\r\n'&lt;/code&gt; into &lt;code&gt;'\n'&lt;/code&gt; on input, and &lt;code&gt;'\n'&lt;/code&gt; to the native newline representation on output. This mode can be used on any platform, and works with text files using any newline convention. The downside is that &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; might yield a different file.</source>
          <target state="translated">地图 &lt;code&gt;'\r\n'&lt;/code&gt; 到 &lt;code&gt;'\n'&lt;/code&gt; 上输入，和 &lt;code&gt;'\n'&lt;/code&gt; 到对输出的本机换行符表示。此模式可以在任何平台上使用，并且可以使用任何换行符约定与文本文件一起使用。缺点是 &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; 可能会产生不同的文件。</target>
        </trans-unit>
        <trans-unit id="2b7b80f10f3a81cda5d3d90fed79ebb948d0265b" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;'\r\n'&lt;/code&gt; into &lt;code&gt;'\n'&lt;/code&gt; on input, and &lt;code&gt;'\n'&lt;/code&gt; to the native newline represetnation on output. This mode can be used on any platform, and works with text files using any newline convention. The downside is that &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; might yield a different file.</source>
          <target state="translated">地图 &lt;code&gt;'\r\n'&lt;/code&gt; 到 &lt;code&gt;'\n'&lt;/code&gt; 输入，和 &lt;code&gt;'\n'&lt;/code&gt; 对输出的原始换行符represetnation。此模式可以在任何平台上使用，并且可以使用任何换行符约定与文本文件一起使用。缺点是 &lt;code&gt;readFile &amp;gt;&amp;gt;= writeFile&lt;/code&gt; 可能会产生不同的文件。</target>
        </trans-unit>
        <trans-unit id="6d55454f009aa8f95f75c772db0fb5ae0e9a9272" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">地图 &lt;code&gt;m1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d73f39524fe5ef1af56ec8e22806ecc515086be" translate="yes" xml:space="preserve">
          <source>Map &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">地图 &lt;code&gt;m2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9983700cca6f292aa903742f89b52d541c8d933e" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 映射到 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 安全值。</target>
        </trans-unit>
        <trans-unit id="18e38d5e5d89b044de0e37bb9b26db6369ce574d" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 映射到 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 安全值。</target>
        </trans-unit>
        <trans-unit id="e654d2c2aeead91ee951837f20bb89e6b191fd36" translate="yes" xml:space="preserve">
          <source>Map a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;-safe value.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 映射到 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 安全值。</target>
        </trans-unit>
        <trans-unit id="0766fa419be24fb2dc55e7497743d52826668e62" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上映射一个函数并连接结果</target>
        </trans-unit>
        <trans-unit id="15035b59f86fdfce06c5503b47c04b11e811e80d" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上映射一个函数并连接结果</target>
        </trans-unit>
        <trans-unit id="b46e7ebb5140a1447b3c89113a3d9ae22bb0b79b" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上映射一个函数并连接结果</target>
        </trans-unit>
        <trans-unit id="6903ae5c580a3f2ab80be5d8534af3c46567f965" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; and concatenate the results</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上映射一个函数并连接结果</target>
        </trans-unit>
        <trans-unit id="9f9558286be8174c824362eb946ace711872dbf8" translate="yes" xml:space="preserve">
          <source>Map a function over a &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; stream.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 流上映射一个函数。</target>
        </trans-unit>
        <trans-unit id="21fd99a4595253dffd079844b719d83735a7905f" translate="yes" xml:space="preserve">
          <source>Map a function over a list and concatenate the results.</source>
          <target state="translated">将一个函数映射到一个列表上,并将结果连接起来。</target>
        </trans-unit>
        <trans-unit id="9800e72be66dc6c45d2ad289e20ef1a9a51d98ad" translate="yes" xml:space="preserve">
          <source>Map a function over a stream that results in a stream and concatenate the results.</source>
          <target state="translated">在一个流上映射一个函数,结果是一个流,并将结果连接起来。</target>
        </trans-unit>
        <trans-unit id="ad689681c3a3649d48f9aaad672101632605a134" translate="yes" xml:space="preserve">
          <source>Map a function over all the elements of a container and concatenate the resulting lists.</source>
          <target state="translated">将一个函数映射到一个容器的所有元素上,并将产生的列表连接起来。</target>
        </trans-unit>
        <trans-unit id="552e1bebb738ef9f96de04d70a982bb350a641c3" translate="yes" xml:space="preserve">
          <source>Map a function returning a list over a list and concatenate the results. &lt;code&gt;&lt;a href=&quot;ghc-list#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; can be seen as the composition of &lt;code&gt;&lt;a href=&quot;ghc-list#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将返回列表的函数映射到列表上并连接结果。 &lt;code&gt;&lt;a href=&quot;ghc-list#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; 可以看作是 &lt;code&gt;&lt;a href=&quot;ghc-list#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的组成。</target>
        </trans-unit>
        <trans-unit id="06fff69e6935c5ce977d35f21f04166c5be20d3c" translate="yes" xml:space="preserve">
          <source>Map a function returning a list over a list and concatenate the results. &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; can be seen as the composition of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将返回列表的函数映射到列表上并连接结果。 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concatMap&quot;&gt;concatMap&lt;/a&gt;&lt;/code&gt; 可以看作是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的组成。</target>
        </trans-unit>
        <trans-unit id="1a8247db8adfeefa619b1655afff9beae6787d09" translate="yes" xml:space="preserve">
          <source>Map a user interaction by modifying the base monad computation.</source>
          <target state="translated">通过修改基础单体计算来映射用户交互。</target>
        </trans-unit>
        <trans-unit id="7edbce9966aa6d05b4981154c3d88123653a0c5d" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 计算之间的映射。</target>
        </trans-unit>
        <trans-unit id="712af23920428aa8ce829c6c9a926052d19c882a" translate="yes" xml:space="preserve">
          <source>Map between &lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; computations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-list#t:ListT&quot;&gt;ListT&lt;/a&gt;&lt;/code&gt; 计算之间的映射。</target>
        </trans-unit>
        <trans-unit id="45e2cd283ebb4c611280d82cee74660fbe85bf94" translate="yes" xml:space="preserve">
          <source>Map both the return value and final state of a computation using the given function.</source>
          <target state="translated">使用给定函数映射计算的返回值和最终状态。</target>
        </trans-unit>
        <trans-unit id="4273e77ff1728ba48d1f840696e743d1da1ee755" translate="yes" xml:space="preserve">
          <source>Map both the return value and output of a computation using the given function.</source>
          <target state="translated">使用给定函数映射计算的返回值和输出。</target>
        </trans-unit>
        <trans-unit id="803e1322fde156db8cc3128774fd2f8d4c99abec" translate="yes" xml:space="preserve">
          <source>Map capabilities to NUMA nodes. Capability C is mapped to NUMA node C mod N.</source>
          <target state="translated">将能力映射到NUMA节点。能力C被映射到NUMA节点C mod N。</target>
        </trans-unit>
        <trans-unit id="21de922b618d81f2e317aafc9cbebc99176766bc" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f _ y z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa119e405295642a5bcf3b77b05b9cefc544c124" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x _ z&lt;/code&gt; 映射到WhenMatched fx _ z上。</target>
        </trans-unit>
        <trans-unit id="7245e811517b83cae4b9adf19d8a5924072530a7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f _ x&lt;/code&gt; 映射WhenMissing f _ x。</target>
        </trans-unit>
        <trans-unit id="09e23d7bb6cd983f23a248d179ee216a8f59e394" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k _ y z&lt;/code&gt; 映射到WhenMatched fk _ yz。</target>
        </trans-unit>
        <trans-unit id="2569c1d7ccbe6013b4e6c78fb8e786a9a6095e76" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x _ z&lt;/code&gt; 映射到WhenMatched fkx _ z上。</target>
        </trans-unit>
        <trans-unit id="a14103f7c1f26a2fcbb71bbe285a99bdcde54ff7" translate="yes" xml:space="preserve">
          <source>Map contravariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k _ x&lt;/code&gt; 映射一个WhenMissing fk _ x。</target>
        </trans-unit>
        <trans-unit id="a8eb552837e87415b9d4df127dcd174fef924114" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f x y&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="46bcbb877a60019cf521e9ab67aa98b003657bfd" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f x&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="b9d6ab9d11a41a76d9162b3143fae97f6b16f455" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="3f706796547b811fccb9bd7e5484d305853862eb" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="80246f23eba01c63a2b57d2f1b0b002711c39d9f" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="a5cd585d64a0c1fc4c937dd0ee8ee4b052b09370" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="ce99df6d5a6c7da2f980fb998d55fe0e027d1fd2" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt; f k x y&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="2de75aa8ae3777dc3c106e78b70228d497cabfb4" translate="yes" xml:space="preserve">
          <source>Map covariantly over a &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k x&lt;/code&gt; 协变映射。</target>
        </trans-unit>
        <trans-unit id="1414775fb27f647a11edd9afbabc9f1f96d002c5" translate="yes" xml:space="preserve">
          <source>Map covariantly over the first argument.</source>
          <target state="translated">在第一个论点上共变映射。</target>
        </trans-unit>
        <trans-unit id="d189acaf26502066081e31e150c1693816dae853" translate="yes" xml:space="preserve">
          <source>Map covariantly over the second argument.</source>
          <target state="translated">在第二个论点上共变映射。</target>
        </trans-unit>
        <trans-unit id="66f098667a15e2db24bb8373340e33eb8b6f8853" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到单子动作，从左到右评估这些动作，并收集结果。有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;control-monad#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3b66d8ea2cb272c74911fcfbdc7cf4ca77953fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到单子动作，从左到右评估这些动作，并收集结果。有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-foldable#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9faa2d5ff3705c067b9b5226876c908059a5fa59" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到单子动作，从左到右评估这些动作，并收集结果。有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;prelude#v:mapM_&quot;&gt;mapM_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02dfb7e92c38e4214d51e2b9595047ff1b8f9b31" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to a monadic action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到单子动作，从左到右评估这些动作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapM&quot;&gt;mapM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbfeb99bf3039f3b9bd94716be1697f7c672a217" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作，从左到右评估这些操作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e288a8969f8edd9a984979987138d0017375a217" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作，从左到右评估这些操作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29efd3765dfabc72142232cb82d864034ee72729" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and collect the results. For a version that ignores the results see &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个动作，从左到右评估这些动作，并收集结果。有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-foldable#v:traverse_&quot;&gt;traverse_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d22dd22b104dd621f77d9d5650ccd532318e02da" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个动作，从左到右评估这些动作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43e6de6decbbed7c2a5b1c6751631f378ba334b2" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个动作，从左到右评估这些动作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4417d32b4f323c831d7b4ced61e67f600e01b3fb" translate="yes" xml:space="preserve">
          <source>Map each element of a structure to an action, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results see &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将结构的每个元素映射到一个动作，从左到右评估这些动作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c124d6dfa5bddefa553c4516b6211d2cf0661762" translate="yes" xml:space="preserve">
          <source>Map each element of a structure using one of two actions, evaluate these actions from left to right, and ignore the results. For a version that doesn't ignore the results, see &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用两个动作之一映射结构的每个元素，从左到右评估这些动作，并忽略结果。对于不忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="539eacbc27d41b07bf8575009d83f8bccfbf1214" translate="yes" xml:space="preserve">
          <source>Map each element of the structure into a monoid, and combine the results with &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt;. This fold is right-associative and lazy in the accumulator. For strict left-associative folds consider &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead.</source>
          <target state="translated">将结构的每个元素映射到一个monoid中，并将结果与 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 合并。该折叠在累加器中是右关联的并且是惰性的。对于严格的左关联折叠，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `。</target>
        </trans-unit>
        <trans-unit id="5fa8b74f971e12062a8ab201e009a282f51b7016" translate="yes" xml:space="preserve">
          <source>Map each element of the structure into a monoid, and combine the results with &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt;. This fold is right-associative and lazy in the accumulator. For strict left-associative folds consider &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead.</source>
          <target state="translated">将结构的每个元素映射到一个monoid中，并将结果与 &lt;code&gt;(&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 合并。该折叠在累加器中是右关联的并且是惰性的。对于严格的左关联折叠，请考虑使用 &lt;code&gt;&lt;a href=&quot;prelude#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `。</target>
        </trans-unit>
        <trans-unit id="33e14cd9471b9b06b4f5f3069e4de360f95948a3" translate="yes" xml:space="preserve">
          <source>Map each element of the structure to a monoid, and combine the results.</source>
          <target state="translated">将结构中的每个元素映射到一个单体上,并将结果合并。</target>
        </trans-unit>
        <trans-unit id="cb44df1644994b6e9bedbd4295f2ba757e01b134" translate="yes" xml:space="preserve">
          <source>Map leap-second values to the start of the following second. The resulting &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; will always be in the range 0 to 1E9-1.</source>
          <target state="translated">将leap秒值映射到下一秒的开始。所得的系统 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:systemNanoseconds&quot;&gt;systemNanoseconds&lt;/a&gt;&lt;/code&gt; 将始终在0到1E9-1的范围内。</target>
        </trans-unit>
        <trans-unit id="f67b9485e617340983ccecc0a0a8ab8a5398d3f1" translate="yes" xml:space="preserve">
          <source>Map over both arguments at the same time.</source>
          <target state="translated">同时将两个参数映射过来。</target>
        </trans-unit>
        <trans-unit id="820bfb2b876cadb7ba21577ea1191e745febb6e2" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">映射另一个映射中缺少键的条目，可以选择删除一些。这是最强大的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="042a8e608fdbf1be1815be0ba68d9d8129c0d45e" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">映射另一个映射中缺少键的条目，可以选择删除一些。这是最强大的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="7446b734119c67e4a15eea3901f43f333f1d45b7" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">映射另一个映射中缺少键的条目，可以选择删除一些。这是最强大的 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="f20f45f5901d5da69a8a8bd25afdefdf94fb0463" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map, optionally removing some. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">映射另一个映射中缺少键的条目，可以选择删除一些。这是最强大的 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt;&lt;/code&gt; 策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="27b9407877fd74e4c60e5bb3f11429e5468cc32d" translate="yes" xml:space="preserve">
          <source>Map over the entries whose keys are missing from the other map.</source>
          <target state="translated">在其他地图上缺少键的条目上进行映射。</target>
        </trans-unit>
        <trans-unit id="4972444ee92a42eeb10783a738cee55cc20ccb73" translate="yes" xml:space="preserve">
          <source>Map the inner computation using the given function.</source>
          <target state="translated">使用给定函数映射内部计算。</target>
        </trans-unit>
        <trans-unit id="f01bd56150a44e5c1e36c99b2ce32a4952f1afda" translate="yes" xml:space="preserve">
          <source>Map the return value, final state and output of a computation using the given function.</source>
          <target state="translated">使用给定函数映射计算的返回值、最终状态和输出。</target>
        </trans-unit>
        <trans-unit id="611b5e106ea059979f2f1779bbc5d5819342b37e" translate="yes" xml:space="preserve">
          <source>Map the unwrapped computation using the given function.</source>
          <target state="translated">使用给定的函数映射解包计算。</target>
        </trans-unit>
        <trans-unit id="9a3aa11de5ca9a6bdbea1dfb4fae341156bcff0a" translate="yes" xml:space="preserve">
          <source>Map type</source>
          <target state="translated">地图类型</target>
        </trans-unit>
        <trans-unit id="1810f098d7eac5bae7e2406903ecfc11787e8374" translate="yes" xml:space="preserve">
          <source>MapCRtoLF</source>
          <target state="translated">MapCRtoLF</target>
        </trans-unit>
        <trans-unit id="28b80a5d51a036d17e03dadde928449b953d85da" translate="yes" xml:space="preserve">
          <source>MapLFtoCR</source>
          <target state="translated">MapLFtoCR</target>
        </trans-unit>
        <trans-unit id="0f7287b611e3434635c4078dcc64979ba53c31bb" translate="yes" xml:space="preserve">
          <source>MapiFlag</source>
          <target state="translated">MapiFlag</target>
        </trans-unit>
        <trans-unit id="509e216767250bbf0cec7134cc87bd8db88ff863" translate="yes" xml:space="preserve">
          <source>MapiFreeBufferType</source>
          <target state="translated">MapiFreeBufferType</target>
        </trans-unit>
        <trans-unit id="f6693d804c9943e70a4a0323060d0df51aa65dfa" translate="yes" xml:space="preserve">
          <source>MapiFuncs</source>
          <target state="translated">MapiFuncs</target>
        </trans-unit>
        <trans-unit id="cd9c46f0be135a23d65b90dc10dbdb8e6bf7bb43" translate="yes" xml:space="preserve">
          <source>MapiLoaded</source>
          <target state="translated">MapiLoaded</target>
        </trans-unit>
        <trans-unit id="fa7f40372f1e4c545567caf67dc788efc58735dc" translate="yes" xml:space="preserve">
          <source>MapiLogoffType</source>
          <target state="translated">MapiLogoffType</target>
        </trans-unit>
        <trans-unit id="36cb3aec5c1c5fe73d8e8e0fc96d8a25e6742274" translate="yes" xml:space="preserve">
          <source>MapiLogonType</source>
          <target state="translated">MapiLogonType</target>
        </trans-unit>
        <trans-unit id="7a12682bc39d4a4b9b85256454d88deeb97151f5" translate="yes" xml:space="preserve">
          <source>MapiRecipDesc</source>
          <target state="translated">MapiRecipDesc</target>
        </trans-unit>
        <trans-unit id="dd6f6d1599d7119a2a1666a29fe8913e02817cc0" translate="yes" xml:space="preserve">
          <source>MapiResolveNameType</source>
          <target state="translated">MapiResolveNameType</target>
        </trans-unit>
        <trans-unit id="e806730edd68685562cf8c1233b6d49d37ab11ba" translate="yes" xml:space="preserve">
          <source>MapiSendMailType</source>
          <target state="translated">MapiSendMailType</target>
        </trans-unit>
        <trans-unit id="09e81b0440d9e7e7c46c283e70fc598be2643acd" translate="yes" xml:space="preserve">
          <source>Mapped object, from withMappedFile</source>
          <target state="translated">映射对象,来自withMappedFile</target>
        </trans-unit>
        <trans-unit id="782e4fafad5e3beb16ef35319d6126950de58292" translate="yes" xml:space="preserve">
          <source>MappedObject</source>
          <target state="translated">MappedObject</target>
        </trans-unit>
        <trans-unit id="6f8944015d37918b217a17f41aec65c11bca6197" translate="yes" xml:space="preserve">
          <source>Mapping of C types to corresponding Haskell types.</source>
          <target state="translated">C类型到对应的Haskell类型的映射。</target>
        </trans-unit>
        <trans-unit id="bfccc2a90a967ca2c9726fa59c31448b51ea07bc" translate="yes" xml:space="preserve">
          <source>Maps an old state to a new state inside a state monad. The old state is thrown away.</source>
          <target state="translated">在状态单体中把一个旧状态映射到一个新状态。旧的状态被丢弃。</target>
        </trans-unit>
        <trans-unit id="0a1978af85dd59fcc87cee4e7808720188940a44" translate="yes" xml:space="preserve">
          <source>Maps area into memory.</source>
          <target state="translated">将区域映射到内存中。</target>
        </trans-unit>
        <trans-unit id="12d3f218c041a3e94409cd521a65703707ec7d30" translate="yes" xml:space="preserve">
          <source>Maps file fully and returns ForeignPtr and length of the mapped area. The mapped file is opened read-only and shared reading.</source>
          <target state="translated">完全映射文件并返回ForeignPtr和映射区域的长度。映射的文件是只读和共享阅读打开的。</target>
        </trans-unit>
        <trans-unit id="3936cc3f677a76a2eedb9a68dae98afcd381cc69" translate="yes" xml:space="preserve">
          <source>Mark a module as unsafe so that it can&amp;rsquo;t be imported by code compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Also enable the Safe Import extension so that a module can require a dependency to be trusted.</source>
          <target state="translated">将模块标记为不安全，以便不能使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的代码导入该模块。还启用&amp;ldquo;安全导入&amp;rdquo;扩展，以便模块可以要求依赖关系是可信的。</target>
        </trans-unit>
        <trans-unit id="b2469915cb8350f4b45d32b9fb09eae8014a2fd7" translate="yes" xml:space="preserve">
          <source>MarkParityErrors</source>
          <target state="translated">MarkParityErrors</target>
        </trans-unit>
        <trans-unit id="cf1e479bca0990aa370eb4cace42655c1749155a" translate="yes" xml:space="preserve">
          <source>Markers let us do this: we can annotate the program to emit a marker at an appropriate point during execution and then see that in a profile.</source>
          <target state="translated">标记可以让我们做到这一点:我们可以对程序进行注释,使其在执行过程中的适当点发出一个标记,然后在配置文件中看到这个标记。</target>
        </trans-unit>
        <trans-unit id="cbfae789a5691468edf927d3fcc545f317911943" translate="yes" xml:space="preserve">
          <source>Marks a capability flushing its local update remembered set accumulator.</source>
          <target state="translated">标志着一个能力刷新了它的本地更新记忆集累加器。</target>
        </trans-unit>
        <trans-unit id="749ef48ee39365b34972946cb74471d0eed9c084" translate="yes" xml:space="preserve">
          <source>Marks if the datatype is actually a newtype</source>
          <target state="translated">标识数据类型是否为新类型。</target>
        </trans-unit>
        <trans-unit id="2e31ff5a5bf802580a8893f8699ba55f6d3ac5b7" translate="yes" xml:space="preserve">
          <source>Marks if this constructor is a record</source>
          <target state="translated">标记该构造函数是否为记录</target>
        </trans-unit>
        <trans-unit id="c3400456e0dc9b11aa991afcb8dd85aa615efa2c" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a heap profile sample.</source>
          <target state="translated">标志着一个堆配置文件样本的开始。</target>
        </trans-unit>
        <trans-unit id="dfdb9356e7d55128f5fe9e41f811cbba7086dbb4" translate="yes" xml:space="preserve">
          <source>Marks the beginning of a time profile.</source>
          <target state="translated">标志着一个时间轮廓的开始。</target>
        </trans-unit>
        <trans-unit id="11481cc8464a72c6d603970383a2b8035b849cba" translate="yes" xml:space="preserve">
          <source>Marks the beginning of marking by the concurrent collector.</source>
          <target state="translated">标志着同时采集器开始标记。</target>
        </trans-unit>
        <trans-unit id="c5867d7dd9a19fc447a637c38b43c98746f7ab60" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">标记并发垃圾收集器的标记后同步阶段的开始。</target>
        </trans-unit>
        <trans-unit id="7e14a218bcc85c7d4dcb33742d978559eff47dc5" translate="yes" xml:space="preserve">
          <source>Marks the beginning of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">标记并发垃圾收集器的清除阶段的开始。</target>
        </trans-unit>
        <trans-unit id="be5ce64099ae9eb2d5c99a4e160328562b3336ca" translate="yes" xml:space="preserve">
          <source>Marks the creation of a Haskell thread.</source>
          <target state="translated">标志着一个Haskell线程的创建。</target>
        </trans-unit>
        <trans-unit id="06e940d86df5e1c669573ec00f380d2004c19a2e" translate="yes" xml:space="preserve">
          <source>Marks the creation of a task.</source>
          <target state="translated">标志着一项任务的产生。</target>
        </trans-unit>
        <trans-unit id="e3821a3cd57a76c02636f3ef5d01798bb2876d2d" translate="yes" xml:space="preserve">
          <source>Marks the end of a heap profile sample.</source>
          <target state="translated">标志着一个堆配置文件样本的结束。</target>
        </trans-unit>
        <trans-unit id="1e59b472cf539a835c888dd89568d8c7535aa244" translate="yes" xml:space="preserve">
          <source>Marks the end of concurrent scavenging.</source>
          <target state="translated">标志着同时清扫工作的结束。</target>
        </trans-unit>
        <trans-unit id="57bb2a224b54670e5e30b20bb4395fd09c0df40e" translate="yes" xml:space="preserve">
          <source>Marks the end of marking by the concurrent collector.</source>
          <target state="translated">标志着同时采集器的标记结束。</target>
        </trans-unit>
        <trans-unit id="640deea39fa19db976a137734b54b69c77f77688" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s post-mark synchronization phase.</source>
          <target state="translated">标记并发垃圾收集器的标记后同步阶段的结束。</target>
        </trans-unit>
        <trans-unit id="ff67171565b14a0ac19b21e97b897585fbd8895f" translate="yes" xml:space="preserve">
          <source>Marks the end of the concurrent garbage collector&amp;rsquo;s sweep phase.</source>
          <target state="translated">标记并发垃圾收集器的清除阶段结束。</target>
        </trans-unit>
        <trans-unit id="769d2819dbb6bff931272f20731d9d45442d5b36" translate="yes" xml:space="preserve">
          <source>Marks the migration of a task to a new capability.</source>
          <target state="translated">标志着一项任务迁移到一个新的能力。</target>
        </trans-unit>
        <trans-unit id="2a1e650924ea24ab3b1b0f295ccf2fdea9b1307a" translate="yes" xml:space="preserve">
          <source>Marks the start of concurrent scavenging.</source>
          <target state="translated">标志着同时清扫的开始。</target>
        </trans-unit>
        <trans-unit id="7e626c3e7759a64e59e9a89ccd39a484ef5b02cf" translate="yes" xml:space="preserve">
          <source>Marshal a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; into a C string encoded as UTF-8 in temporary storage, with explicit length information. The encoded string may contain NUL bytes, and is not followed by a trailing NUL byte.</source>
          <target state="translated">在显式长度信息的临时存储中，将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 为编码为UTF-8的C字符串。编码的字符串可以包含NUL字节，并且后​​面不可以跟随NUL字节。</target>
        </trans-unit>
        <trans-unit id="e194c0bfa99200c6de46b0a0dae4f141264ffb6b" translate="yes" xml:space="preserve">
          <source>Marshal a C string with explicit length into a Haskell string.</source>
          <target state="translated">将一个具有显式长度的 C 字符串转换为一个 Haskell 字符串。</target>
        </trans-unit>
        <trans-unit id="50198af1318b58c7e70f40d2d8b8dc415ec720f2" translate="yes" xml:space="preserve">
          <source>Marshal a C wide string with explicit length into a Haskell string.</source>
          <target state="translated">将一个具有显式长度的 C 宽字符串转换为一个 Haskell 字符串。</target>
        </trans-unit>
        <trans-unit id="3c5b68516d82d4c37cb3d40678d4531758ba74e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) in temporary storage, with explicit length information.</source>
          <target state="translated">将一个 Haskell 字符串在临时存储中Marshal成一个 C 字符串(即字符数组),并提供明确的长度信息。</target>
        </trans-unit>
        <trans-unit id="062175c88aeda03668433b163d83cb6364af626e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C string (ie, character array) with explicit length information.</source>
          <target state="translated">将一个 Haskell 字符串转换为一个带有明确长度信息的 C 字符串(即字符数组)。</target>
        </trans-unit>
        <trans-unit id="912dd885ff9b0a2ea4a16995e74ae7cc0940d45e" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">将一个Haskell字符串在临时存储中Marshal成一个C宽字符串(即宽字符数组),并有明确的长度信息。</target>
        </trans-unit>
        <trans-unit id="f77c471f3c7f74d5609487ca9b39a6878b13f8dd" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a C wide string (ie, wide character array) with explicit length information.</source>
          <target state="translated">将一个 Haskell 字符串转换为一个具有显式长度信息的 C 宽字符串(即宽字符数组)。</target>
        </trans-unit>
        <trans-unit id="c98ce6c5f02b8c9585848448e89dbd65dcaf47e3" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string using temporary storage.</source>
          <target state="translated">使用临时存储将一个 Haskell 字符串转换为一个 NUL 结尾的 C 字符串。</target>
        </trans-unit>
        <trans-unit id="fdda91a4f111ed1a0fc6f2a8775b98e089fe921b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C string.</source>
          <target state="translated">将一个 Haskell 字符串转换为一个 NUL 结尾的 C 字符串。</target>
        </trans-unit>
        <trans-unit id="4a04b9cb2051b02b522faee9650a0d495e9ac7e2" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">使用临时存储将一个 Haskell 字符串转换为一个 NUL 结束的 C 宽字符串。</target>
        </trans-unit>
        <trans-unit id="4054981272596d06fac239f84b099d399356e48b" translate="yes" xml:space="preserve">
          <source>Marshal a Haskell string into a NUL terminated C wide string.</source>
          <target state="translated">将一个 Haskell 字符串转换为一个 NUL 结尾的 C 宽字符串。</target>
        </trans-unit>
        <trans-unit id="09d48aea89cc33b11ec8033bc15b6483354cf103" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C string into a Haskell string.</source>
          <target state="translated">将一个以 NUL 结尾的 C 字符串转换为一个 Haskell 字符串。</target>
        </trans-unit>
        <trans-unit id="4311d7c39509b4fe039bef36ba55dfd320cecd73" translate="yes" xml:space="preserve">
          <source>Marshal a NUL terminated C wide string into a Haskell string.</source>
          <target state="translated">将一个以 NUL 结尾的 C 宽字符串转换为一个 Haskell 字符串。</target>
        </trans-unit>
        <trans-unit id="4c47a3a8839a6fd68ae9716c3fa1ce5197fbd8d4" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a C wide string (i.e. wide character array) in temporary storage, with explicit length information.</source>
          <target state="translated">将一个虚拟的Haskell字符串在临时存储中Marshal成一个C宽字符串(即宽字符数组),并有明确的长度信息。</target>
        </trans-unit>
        <trans-unit id="6d86041ec3d2e84d33ddd1dd6cfc24550f14836a" translate="yes" xml:space="preserve">
          <source>Marshal a dummy Haskell string into a NUL terminated C wide string using temporary storage.</source>
          <target state="translated">使用临时存储将一个虚拟的Haskell字符串转换成一个NUL终止的C宽字符串。</target>
        </trans-unit>
        <trans-unit id="e0dade00c021cdaf9d0ee91f43d69115b6f80912" translate="yes" xml:space="preserve">
          <source>Marshal a list of Haskell strings into an array of NUL terminated C strings using temporary storage.</source>
          <target state="translated">使用临时存储将一个Haskell字符串列表Marshal到一个NUL终止的C字符串数组中。</target>
        </trans-unit>
        <trans-unit id="cc6b108a5f57dc6b9a05c1b127e58f7eca9629cd" translate="yes" xml:space="preserve">
          <source>Marshalling</source>
          <target state="translated">Marshalling</target>
        </trans-unit>
        <trans-unit id="f0ad063d68044737957ed0f797a2cae2aa208116" translate="yes" xml:space="preserve">
          <source>Marshalling arrays</source>
          <target state="translated">汇集数组</target>
        </trans-unit>
        <trans-unit id="36c846ee62dfe999f6767389bfae195bd57e0465" translate="yes" xml:space="preserve">
          <source>Marshalling lists of storable objects</source>
          <target state="translated">汇集可储存物品清单</target>
        </trans-unit>
        <trans-unit id="0dba1cb48010c84cd2d29279809f66a88be05516" translate="yes" xml:space="preserve">
          <source>Marshalling of Boolean values (non-zero corresponds to &lt;code&gt;True&lt;/code&gt;)</source>
          <target state="translated">布尔值的编组（非零对应于 &lt;code&gt;True&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ab71dfd4eb06d44348ff90d0b69db22a5328f47d" translate="yes" xml:space="preserve">
          <source>Marshalling of Maybe values</source>
          <target state="translated">可能值的汇总</target>
        </trans-unit>
        <trans-unit id="239b1e2996122625ab9c3b095db2c1aaf212e151" translate="yes" xml:space="preserve">
          <source>Marshalling support</source>
          <target state="translated">调集支助</target>
        </trans-unit>
        <trans-unit id="2768b4d93d7521d0bb9c22088cc6e109b9cb0751" translate="yes" xml:space="preserve">
          <source>Marshalling support. Unsafe API.</source>
          <target state="translated">支持Marshalling。不安全的API。</target>
        </trans-unit>
        <trans-unit id="2ac6f66636ae68e7acfa888a200b00a6c8d691d3" translate="yes" xml:space="preserve">
          <source>Marshalling support: routines allocating, storing, and retrieving Haskell lists that are represented as arrays in the foreign language</source>
          <target state="translated">Marshalling支持:分配、存储和检索Haskell列表的例程,这些列表在外语中表示为数组。</target>
        </trans-unit>
        <trans-unit id="2eec1eaadfce2f2343fb8a58e72120839ce594dd" translate="yes" xml:space="preserve">
          <source>Martin Escardo and Paulo Oliva. &quot;Selection functions, bar recursion and backward induction&quot;, &lt;em&gt;Mathematical Structures in Computer Science&lt;/em&gt; 20:2 (2010), pp. 127-168. &lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</source>
          <target state="translated">马丁&amp;middot;埃斯卡多（Martin Escardo）和保罗&amp;middot;奥利瓦（Paulo Oliva）。&amp;ldquo;选择函数，小节递归和后向归纳&amp;rdquo;，《&lt;em&gt;计算机科学中的数学结构&lt;/em&gt;》20：2（2010），第127-168页。&lt;a href=&quot;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&quot;&gt;https://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8aadf1657da58cb6e5ae063fb1322736bf6002e4" translate="yes" xml:space="preserve">
          <source>Mask</source>
          <target state="translated">Mask</target>
        </trans-unit>
        <trans-unit id="30b6cc635afcf7d59efbff7d871b3f85ca41ffeb" translate="yes" xml:space="preserve">
          <source>MaskedInterruptible</source>
          <target state="translated">MaskedInterruptible</target>
        </trans-unit>
        <trans-unit id="f8a86f7a0ad149ff28451b56d2a010763bd9ea96" translate="yes" xml:space="preserve">
          <source>MaskedUninterruptible</source>
          <target state="translated">MaskedUninterruptible</target>
        </trans-unit>
        <trans-unit id="55a3d416a9f5e2d65bbae417b235dd396b7e87d1" translate="yes" xml:space="preserve">
          <source>MaskingState</source>
          <target state="translated">MaskingState</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="d8e65ef19404e901265ea66bdd78cf07c84d55f3" translate="yes" xml:space="preserve">
          <source>Match &lt;code&gt;v1&lt;/code&gt; against &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt; against &lt;code&gt;p2&lt;/code&gt; and so on. If any of these matches fail or diverge, so does the whole match.</source>
          <target state="translated">将 &lt;code&gt;v1&lt;/code&gt; 与 &lt;code&gt;p1&lt;/code&gt; 匹配，将 &lt;code&gt;v2&lt;/code&gt; 与 &lt;code&gt;p2&lt;/code&gt; 匹配，依此类推。如果这些匹配中的任何一个失败或偏离，那么整个匹配也会失败。</target>
        </trans-unit>
        <trans-unit id="6ceb6ea323bd13a9e935c2eb466741cf2f979c72" translate="yes" xml:space="preserve">
          <source>Match and Clause</source>
          <target state="translated">匹配和条款</target>
        </trans-unit>
        <trans-unit id="dd7924a1ec8896d061a233f605e42f91781e1add" translate="yes" xml:space="preserve">
          <source>Match the value &lt;code&gt;v&lt;/code&gt; against &lt;code&gt;p&lt;/code&gt;. If this match fails or diverges, so does the whole (pattern synonym) match. Otherwise the match against &lt;code&gt;p&lt;/code&gt; must bind the variables &lt;code&gt;x1 ... xn&lt;/code&gt;; let them be bound to values &lt;code&gt;v1 ... vn&lt;/code&gt;.</source>
          <target state="translated">将值 &lt;code&gt;v&lt;/code&gt; 与 &lt;code&gt;p&lt;/code&gt; 匹配。如果此匹配失败或偏离，则整个（模式同义词）匹配也将匹配。否则，与 &lt;code&gt;p&lt;/code&gt; 的匹配必须绑定变量 &lt;code&gt;x1 ... xn&lt;/code&gt; ; 让它们绑定到值 &lt;code&gt;v1 ... vn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6763e6cca4e80df18fa4d5f912665ef97a375c19" translate="yes" xml:space="preserve">
          <source>MatchQ</source>
          <target state="translated">MatchQ</target>
        </trans-unit>
        <trans-unit id="4895b24f6bce36c2cd9b44590b52713fb09b4922" translate="yes" xml:space="preserve">
          <source>Matching an expression &lt;code&gt;e&lt;/code&gt; against a pattern &lt;code&gt;!p&lt;/code&gt; is done by first evaluating &lt;code&gt;e&lt;/code&gt; (to WHNF) and then matching the result against &lt;code&gt;p&lt;/code&gt;. Example:</source>
          <target state="translated">通过首先对 &lt;code&gt;e&lt;/code&gt; （对WHNF）求值，然后对 &lt;code&gt;p&lt;/code&gt; 进行结果匹配，可以将表达式 &lt;code&gt;e&lt;/code&gt; 与模式 &lt;code&gt;!p&lt;/code&gt; 进行匹配。例：</target>
        </trans-unit>
        <trans-unit id="70016ff14223778abe33ce54933e1dcebf537bde" translate="yes" xml:space="preserve">
          <source>Matching function for the token to parse.</source>
          <target state="translated">要解析的标记的匹配函数。</target>
        </trans-unit>
        <trans-unit id="469df59ba37712c09add7e5bdd4e7279148a045b" translate="yes" xml:space="preserve">
          <source>Matching is carried out on GHC&amp;rsquo;s intermediate language, which includes type abstractions and applications. So a rule only matches if the types match too. See &lt;a href=&quot;#rule-spec&quot;&gt;Specialisation&lt;/a&gt; below.</source>
          <target state="translated">匹配是在GHC的中间语言上进行的，该中间语言包括类型抽象和应用程序。因此，规则仅在类型也匹配时才匹配。请参阅下面的&lt;a href=&quot;#rule-spec&quot;&gt;专业化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78b96c127877ae96cfefda73d72a8baba84838aa" translate="yes" xml:space="preserve">
          <source>Matching on &lt;code&gt;App&lt;/code&gt; directly is both hard to read and error prone to write. And the situation is even worse when the matching is nested:</source>
          <target state="translated">直接在 &lt;code&gt;App&lt;/code&gt; 上进行匹配既难以阅读，也容易出错。当匹配嵌套时，情况甚至更糟：</target>
        </trans-unit>
        <trans-unit id="042bacca5d8f713d47eab01491aa815bdbd55203" translate="yes" xml:space="preserve">
          <source>Matching the pattern &lt;code&gt;!pat&lt;/code&gt; against a value &lt;code&gt;v&lt;/code&gt; behaves as follows:</source>
          <target state="translated">将模式 &lt;code&gt;!pat&lt;/code&gt; 与值 &lt;code&gt;v&lt;/code&gt; 匹配的行为如下：</target>
        </trans-unit>
        <trans-unit id="3d675806f239e11d4b41b67aa65a5606104824d2" translate="yes" xml:space="preserve">
          <source>Matching: To the equations in Section 3.17.3 of the &lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt;, add the following:</source>
          <target state="translated">匹配：在&lt;a href=&quot;http://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report的&lt;/a&gt; 3.17.3节中的等式中，添加以下内容：</target>
        </trans-unit>
        <trans-unit id="d87072f110a398a070f07e3107f06ad006b827b3" translate="yes" xml:space="preserve">
          <source>Matching: To the equations in Section 3.17.3 of the &lt;a href=&quot;https://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report&lt;/a&gt;, add the following:</source>
          <target state="translated">匹配：在&lt;a href=&quot;https://www.haskell.org/onlinereport/&quot;&gt;Haskell 98 Report的&lt;/a&gt;3.17.3节中的等式中，添加以下内容：</target>
        </trans-unit>
        <trans-unit id="e2376240265e2ddbf31297cb5bda027216f1ebd9" translate="yes" xml:space="preserve">
          <source>MathSymbol</source>
          <target state="translated">MathSymbol</target>
        </trans-unit>
        <trans-unit id="a95e85aed56318093b024674e217cae0bd30241d" translate="yes" xml:space="preserve">
          <source>Max</source>
          <target state="translated">Max</target>
        </trans-unit>
        <trans-unit id="c189943b0e68bf52ade04ebce38ce6c7c78d6eea" translate="yes" xml:space="preserve">
          <source>Maximum length of a line, in characters.</source>
          <target state="translated">一行的最大长度,以字符为单位。</target>
        </trans-unit>
        <trans-unit id="144a9206977b57448e4faf5e1062274633d6193e" translate="yes" xml:space="preserve">
          <source>Maximum live data (including large objects + compact regions) in the heap. Updated after a major GC.</source>
          <target state="translated">堆中最大的活数据(包括大对象+紧凑区域)。在一次大型GC后更新。</target>
        </trans-unit>
        <trans-unit id="159b778d9454be206f67d4893bca54a49e9b8c77" translate="yes" xml:space="preserve">
          <source>Maximum live data in compact regions</source>
          <target state="translated">紧凑区域的最大实时数据</target>
        </trans-unit>
        <trans-unit id="a16695344254fdba02129e66db3ad3e63cb1016e" translate="yes" xml:space="preserve">
          <source>Maximum live data in large objects</source>
          <target state="translated">大型物体的最大实时数据</target>
        </trans-unit>
        <trans-unit id="240702bae0f29e273fb09ffdba7773ca8777719c" translate="yes" xml:space="preserve">
          <source>Maximum memory in use by the RTS</source>
          <target state="translated">RTS使用的最大内存</target>
        </trans-unit>
        <trans-unit id="d8099e9d8479df145a140dbad71866cd985cafd7" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to read</source>
          <target state="translated">读取的最大字节数</target>
        </trans-unit>
        <trans-unit id="29145ea756091c42d8b8df72e4191a60b4a54c6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to write</source>
          <target state="translated">最大写入字节数</target>
        </trans-unit>
        <trans-unit id="9e69850923d54429a417c753e43ca53a7ffd31d5" translate="yes" xml:space="preserve">
          <source>Maximum number of unmatched patterns to be shown in warnings generated by &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt;生成的警告中显示的最大不匹配模式数。</target>
        </trans-unit>
        <trans-unit id="1f5b0947f46a97bb1ec7fe07a7eee8499d030c8e" translate="yes" xml:space="preserve">
          <source>Maximum of two size hints.</source>
          <target state="translated">最多两个尺寸提示。</target>
        </trans-unit>
        <trans-unit id="bdf18c00bb82701af0218115bcf257f5be6c13bb" translate="yes" xml:space="preserve">
          <source>Maximum slop</source>
          <target state="translated">最大坡度</target>
        </trans-unit>
        <trans-unit id="15683050ba4f95be274c22da707d4d37cc680acd" translate="yes" xml:space="preserve">
          <source>May be overlapped by more specific instances</source>
          <target state="translated">可能会被更多的具体实例所重叠。</target>
        </trans-unit>
        <trans-unit id="9d13a4f70e986c78366878d8a4b23da17275d3fb" translate="yes" xml:space="preserve">
          <source>May overlap a more general instance</source>
          <target state="translated">可能与一个更一般的例子重叠</target>
        </trans-unit>
        <trans-unit id="bc53972d25b2dda7267fd09725c8dd41aac97859" translate="yes" xml:space="preserve">
          <source>May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">如果这是一个无效的描述符,可能会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="56dd8d0bbe9dcb95403cd2c187064106af47af84" translate="yes" xml:space="preserve">
          <source>Maybe</source>
          <target state="translated">Maybe</target>
        </trans-unit>
        <trans-unit id="bef155b2a43310adf81b6d1bb8637732d86f34c0" translate="yes" xml:space="preserve">
          <source>Maybe include (or exclude) replacement locales?</source>
          <target state="translated">也许包括(或排除)替换地点?</target>
        </trans-unit>
        <trans-unit id="b92babb5409c0a6ec95584469ae7d91df0ca8969" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the leftmost non-Nothing value.</source>
          <target state="translated">也许monoid返回最左边的非Nothing值。</target>
        </trans-unit>
        <trans-unit id="018b50df30620e3a51db9ef52260cf832edd1f4d" translate="yes" xml:space="preserve">
          <source>Maybe monoid returning the rightmost non-Nothing value.</source>
          <target state="translated">也许monoid返回最右边的非Nothing值。</target>
        </trans-unit>
        <trans-unit id="fc0be6aa40a87f2c34d21604241fc126b3d008fc" translate="yes" xml:space="preserve">
          <source>Maybe type</source>
          <target state="translated">也许类型</target>
        </trans-unit>
        <trans-unit id="aa7807fd2f555e6dc07cae0194859e7c01ce8cb6" translate="yes" xml:space="preserve">
          <source>Maybe values</source>
          <target state="translated">也许价值</target>
        </trans-unit>
        <trans-unit id="e3265936ce333fe37c9404fe3bfe54fa2731aec4" translate="yes" xml:space="preserve">
          <source>MaybeT</source>
          <target state="translated">MaybeT</target>
        </trans-unit>
        <trans-unit id="3fbd96571113d60d1ec28c5fc4754c91f3088410" translate="yes" xml:space="preserve">
          <source>MbATOM</source>
          <target state="translated">MbATOM</target>
        </trans-unit>
        <trans-unit id="55d8534107e7b0b303e6aa4feb48079bd26d10e8" translate="yes" xml:space="preserve">
          <source>MbHANDLE</source>
          <target state="translated">MbHANDLE</target>
        </trans-unit>
        <trans-unit id="e5248b4829d90843e057bd4eca3e14ec6c01b898" translate="yes" xml:space="preserve">
          <source>MbHINSTANCE</source>
          <target state="translated">MbHINSTANCE</target>
        </trans-unit>
        <trans-unit id="863abdca342d4cbfd84104bbc0ff83f945b49e3b" translate="yes" xml:space="preserve">
          <source>MbHMODULE</source>
          <target state="translated">MbHMODULE</target>
        </trans-unit>
        <trans-unit id="3d9c03cdc0330cc84e5101070b081063867dbc28" translate="yes" xml:space="preserve">
          <source>MbINT</source>
          <target state="translated">MbINT</target>
        </trans-unit>
        <trans-unit id="ecea6b01153b85a30965344164775b06fbcb69a4" translate="yes" xml:space="preserve">
          <source>MbLPCSTR</source>
          <target state="translated">MbLPCSTR</target>
        </trans-unit>
        <trans-unit id="e5be102041dc49217c1540606dd21365b89afc4f" translate="yes" xml:space="preserve">
          <source>MbLPCTSTR</source>
          <target state="translated">MbLPCTSTR</target>
        </trans-unit>
        <trans-unit id="53d96f8a97cd2285858b07956c5ce9cae6040aba" translate="yes" xml:space="preserve">
          <source>MbLPOVERLAPPED</source>
          <target state="translated">MbLPOVERLAPPED</target>
        </trans-unit>
        <trans-unit id="1bab356846186170a8b4b1f5b81a7ad37bab46a7" translate="yes" xml:space="preserve">
          <source>MbLPSECURITY_ATTRIBUTES</source>
          <target state="translated">MbLPSECURITY_ATTRIBUTES</target>
        </trans-unit>
        <trans-unit id="48504feb90b785c6491d7d2c1926298c2bd30054" translate="yes" xml:space="preserve">
          <source>MbLPVOID</source>
          <target state="translated">MbLPVOID</target>
        </trans-unit>
        <trans-unit id="96d0adb31743d4f3821a0e34427fd9d3c6b05a6e" translate="yes" xml:space="preserve">
          <source>MbPos</source>
          <target state="translated">MbPos</target>
        </trans-unit>
        <trans-unit id="e4fd24ce7545ffe7c595a6b3e7a83dba23199af3" translate="yes" xml:space="preserve">
          <source>MbString</source>
          <target state="translated">MbString</target>
        </trans-unit>
        <trans-unit id="ce9329746fe501a099093f13e3edca7c47f40a51" translate="yes" xml:space="preserve">
          <source>Mc: Mark, Spacing Combining</source>
          <target state="translated">Mc:标记、间距组合</target>
        </trans-unit>
        <trans-unit id="e2c8f4a8900f070fa946c771890c8638e1827848" translate="yes" xml:space="preserve">
          <source>Me: Mark, Enclosing</source>
          <target state="translated">我:马克,封闭</target>
        </trans-unit>
        <trans-unit id="5613874632be97c00f6099463fe7f3e041473ea8" translate="yes" xml:space="preserve">
          <source>Meanings of specific keywords:</source>
          <target state="translated">特定关键词的含义。</target>
        </trans-unit>
        <trans-unit id="1aedf6c2f14dc3df6a343ae9b734d4a0213e9822" translate="yes" xml:space="preserve">
          <source>Means &amp;ldquo;turn off all optimisation&amp;rdquo;, reverting to the same settings as if no &lt;code&gt;-O&lt;/code&gt; options had been specified. Saying &lt;code&gt;-O0&lt;/code&gt; can be useful if e.g. &lt;code&gt;make&lt;/code&gt; has inserted a &lt;code&gt;-O&lt;/code&gt; on the command line already.</source>
          <target state="translated">表示&amp;ldquo;关闭所有优化&amp;rdquo;，恢复为与未指定 &lt;code&gt;-O&lt;/code&gt; 选项相同的设置。如果例如 &lt;code&gt;make&lt;/code&gt; 已经在命令行上插入了 &lt;code&gt;-O&lt;/code&gt; ，那么说 &lt;code&gt;-O0&lt;/code&gt; 会很有用。</target>
        </trans-unit>
        <trans-unit id="1b4aa9a4c3b5df0d65ca9349e71ddf30cd0d7394" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Apply every non-dangerous optimisation, even if it means significantly longer compile times.&amp;rdquo;</source>
          <target state="translated">意思是：&amp;ldquo;应用每一次非危险的优化，即使这意味着明显更长的编译时间。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c3bbe6c8c39ed5248e3ca18003eb3d6900b1a45b" translate="yes" xml:space="preserve">
          <source>Means: &amp;ldquo;Generate good-quality code without taking too long about it.&amp;rdquo; Thus, for example: &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</source>
          <target state="translated">意思是：&amp;ldquo;无需花费太多时间即可生成高质量的代码。&amp;rdquo; 因此，例如： &lt;code&gt;ghc -c -O Main.lhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe31d4f25bb8cbbdafdbd4fc62d7fc6cf17c7656" translate="yes" xml:space="preserve">
          <source>Mediate types and binary type constructors.</source>
          <target state="translated">调解类型和二进制类型构造函数。</target>
        </trans-unit>
        <trans-unit id="517ef4fa125305a5305a3a02844f3bb72b3175b5" translate="yes" xml:space="preserve">
          <source>Mediate types and unary type constructors.</source>
          <target state="translated">调解类型和单调类型构造器。</target>
        </trans-unit>
        <trans-unit id="e4fbd39576ea76f4b6886965b788cbf9b98faaa4" translate="yes" xml:space="preserve">
          <source>Memoisation happens because the built-in Haskell list &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; is represented as &lt;strong&gt;data&lt;/strong&gt;, either empty or a &lt;em&gt;cons-cell&lt;/em&gt; holding the first element and the tail of the list. The &lt;code&gt;Foldable&lt;/code&gt; class enables a variant representation of iterators as &lt;em&gt;functions&lt;/em&gt;, which take an operator and a starting accumulator and output a summary result.</source>
          <target state="translated">进行记忆化是因为内置的Haskell list &lt;strong&gt; &lt;code&gt;[]&lt;/code&gt; &lt;/strong&gt;被表示为&lt;strong&gt;data&lt;/strong&gt;，它为空或包含列表的第一个元素和结尾的&lt;em&gt;cons单元&lt;/em&gt;。所述 &lt;code&gt;Foldable&lt;/code&gt; 类使迭代器的一种变型表示为&lt;em&gt;函数&lt;/em&gt;，它取操作和起动累加器并输出汇总结果。</target>
        </trans-unit>
        <trans-unit id="a1bf368dfa41af6966ac27794caf5006abecc398" translate="yes" xml:space="preserve">
          <source>Memory Model</source>
          <target state="translated">记忆模型</target>
        </trans-unit>
        <trans-unit id="49364f57d947f17b4af9ef59269db84acaef977a" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">内存地址被表示为 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 类型的值，对于某些 &lt;code&gt;a&lt;/code&gt; 而言，它是 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的类型参数有助于在FFI代码中提供一些有价值的类型安全性（在没有显式强制转换的情况下，您不能混合使用不同类型的指针），同时可以帮助Haskell类型系统确定给定指针需要哪种编组方法。</target>
        </trans-unit>
        <trans-unit id="8ccc7c7227622171674639dfab2d7182af83111c" translate="yes" xml:space="preserve">
          <source>Memory addresses are represented as values of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt;, for some &lt;code&gt;a&lt;/code&gt; which is an instance of class &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;. The type argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; helps provide some valuable type safety in FFI code (you can't mix pointers of different types without an explicit cast), while helping the Haskell type system figure out which marshalling method is needed for a given pointer.</source>
          <target state="translated">内存地址被表示为 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 类型的值，对于某些 &lt;code&gt;a&lt;/code&gt; 而言，它是 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的类型参数有助于在FFI代码中提供一些有价值的类型安全性（在没有显式强制转换的情况下，您不能混合使用不同类型的指针），同时可以帮助Haskell类型系统确定给定指针需要哪种编组方法。</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">内存分配</target>
        </trans-unit>
        <trans-unit id="403b42e453dae36d100f182dddf88973e094f006" translate="yes" xml:space="preserve">
          <source>Memory containing the data to write</source>
          <target state="translated">含有要写入的数据的存储器</target>
        </trans-unit>
        <trans-unit id="94713b6ce43e5b0b6c83500725c2f66aaf33bf20" translate="yes" xml:space="preserve">
          <source>Memory in which to put the data</source>
          <target state="translated">放置数据的存储器</target>
        </trans-unit>
        <trans-unit id="6dc9de36a01521f350aa26cecadb8b40753a93e7" translate="yes" xml:space="preserve">
          <source>Memory occupied by threads and their stacks is labelled as &amp;ldquo;TSO&amp;rdquo; and &amp;ldquo;STACK&amp;rdquo; respectively when displaying the profile by closure description or type description.</source>
          <target state="translated">通过闭包描述或类型描述显示概要文件时，线程及其堆栈所占用的内存分别标记为&amp;ldquo; TSO&amp;rdquo;和&amp;ldquo; STACK&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4c76fe9817202da64040fc649066dabc0e7eed8e" translate="yes" xml:space="preserve">
          <source>Memory overhead</source>
          <target state="translated">内存开销</target>
        </trans-unit>
        <trans-unit id="76cf8b1754b778b2d89d0e21d90207ed29dcf08d" translate="yes" xml:space="preserve">
          <source>Memory-related system things.</source>
          <target state="translated">内存相关的系统事情。</target>
        </trans-unit>
        <trans-unit id="d10533e6a3289c9df349dcd02b8d8d7f9c80176b" translate="yes" xml:space="preserve">
          <source>Merge immediately-nested case expressions that scrutinise the same variable. For example,</source>
          <target state="translated">合并立即嵌套的案例表达式,这些案例表达式仔细检查同一个变量。例如:</target>
        </trans-unit>
        <trans-unit id="5d3ef442f47f2ad90bddd19466398680ce25d8b8" translate="yes" xml:space="preserve">
          <source>Merge two maps.</source>
          <target state="translated">合并两张地图。</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="19c032c62dd34ab443e91cd122c550a6e77893b2" translate="yes" xml:space="preserve">
          <source>Merging the contribution of the current element with an accumulator value from a partial result is performed by an &lt;em&gt;operator&lt;/em&gt; function, either explicitly provided by the caller as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, implicit as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, or partly implicit as in &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; (where each element is mapped into a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, and the monoid's &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; operator performs the merge).</source>
          <target state="translated">通过&lt;em&gt;运算符&lt;/em&gt;函数将当前元素的贡献与部分结果的累加器值合并在一起，该函数可以由调用者在 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 中显式提供，在隐式中以 &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 隐式提供，或在 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 中部分隐式（其中每个元素都映射到一个 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ，然后Monoid的 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 运算符执行合并）。</target>
        </trans-unit>
        <trans-unit id="68f4145fee7dde76afceb910165924ad14cf0d00" translate="yes" xml:space="preserve">
          <source>Message</source>
          <target state="translated">Message</target>
        </trans-unit>
        <trans-unit id="024d721d7acc6f792bdb94402861b9353228512e" translate="yes" xml:space="preserve">
          <source>Messages sent back to GHC from GHCi.TH, to implement the methods of &lt;code&gt;Quasi&lt;/code&gt;. For an overview of how TH works with Remote GHCi, see Note [Remote Template Haskell] in GHCi.TH.</source>
          <target state="translated">从GHCi.TH发送回GHC的消息，以实现 &lt;code&gt;Quasi&lt;/code&gt; 的方法。有关TH如何与Remote GHCi一起使用的概述，请参见GHCi.TH中的&amp;ldquo;注解[Remote Template Haskell]&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="b4c38ae701ee7b9a08939eed835436caf60c6814" translate="yes" xml:space="preserve">
          <source>Meta information: &lt;code&gt;M1&lt;/code&gt;</source>
          <target state="translated">元信息： &lt;code&gt;M1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbd5ac6aaff1e4e5e3680f3fcf71d0e95837cf76" translate="yes" xml:space="preserve">
          <source>Meta-information</source>
          <target state="translated">Meta-information</target>
        </trans-unit>
        <trans-unit id="1704ec077999acd78a98ea2ae7222e509894be96" translate="yes" xml:space="preserve">
          <source>Meta-information (constructor names, etc.)</source>
          <target state="translated">元信息(构造函数名称等)</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="1ce80809f59fb3e44fb71f48daaa5004423cdbcf" translate="yes" xml:space="preserve">
          <source>Methods for the RealFrac instances for &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, with specialised versions for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的RealFrac实例的方法，以及用于 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的特殊版本。</target>
        </trans-unit>
        <trans-unit id="056ba157b3837c9d7e53cf9a40b8f90212f59c28" translate="yes" xml:space="preserve">
          <source>Micro</source>
          <target state="translated">Micro</target>
        </trans-unit>
        <trans-unit id="064b3c6c13a563b40aaf45097d6cc83685cba7e9" translate="yes" xml:space="preserve">
          <source>Milan Straka 2014</source>
          <target state="translated">2014年米兰-斯特拉卡</target>
        </trans-unit>
        <trans-unit id="90b5d11de357d4d026169517972bc20fb4c73559" translate="yes" xml:space="preserve">
          <source>Milli</source>
          <target state="translated">Milli</target>
        </trans-unit>
        <trans-unit id="7eb0cee888ab55b559592d38eec027e9118d7d35" translate="yes" xml:space="preserve">
          <source>Min</source>
          <target state="translated">Min</target>
        </trans-unit>
        <trans-unit id="2afa51042312a9e6905578605fd22a3a6cf486b0" translate="yes" xml:space="preserve">
          <source>Min/Max</source>
          <target state="translated">Min/Max</target>
        </trans-unit>
        <trans-unit id="e4a689975026b0f86f50d77f497034f70d01b4fa" translate="yes" xml:space="preserve">
          <source>Minimal complete definition</source>
          <target state="translated">最低限度的完整定义</target>
        </trans-unit>
        <trans-unit id="ac6d77ddd397a6c5eefaab2dc1cbd2ec7a9c37eb" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;control-monad-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="665f3b3bb2b72327a6fd69442668299a386cb99c" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-monad-error-class#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab7e52c60d681dae189f8720979ee422a3d05064" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:noMsg&quot;&gt;noMsg&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#v:strMsg&quot;&gt;strMsg&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fd6feae02a9278c6dea240fd40b8aeb536aa561" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f44945409c6023d19bee5e3d0ed6a60092084206" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt;. Using &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; can be more efficient for complex types.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 。对于复杂类型，使用 &lt;code&gt;&lt;a href=&quot;data-ord#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 可能更有效。</target>
        </trans-unit>
        <trans-unit id="af209dc37f96b74f9773c4c4d607b8e40fe1baaf" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7953d2f2689ba6cdd1d813d83ee82da633d40079" translate="yes" xml:space="preserve">
          <source>Minimal complete definition: either &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt;. Using &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; can be more efficient for complex types.</source>
          <target state="translated">最小完整定义： &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 。对于复杂类型，使用 &lt;code&gt;&lt;a href=&quot;prelude#v:compare&quot;&gt;compare&lt;/a&gt;&lt;/code&gt; 可能更有效。</target>
        </trans-unit>
        <trans-unit id="8799ac72cc46a81952dd429d7c4af0260005305d" translate="yes" xml:space="preserve">
          <source>Minimal definition is either both of &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; or just &lt;code&gt;state&lt;/code&gt;</source>
          <target state="translated">最小定义要么是 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 要么只是 &lt;code&gt;state&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af4f6aa56d4f948a03f18d3a1d4d1605a2212012" translate="yes" xml:space="preserve">
          <source>Minimal size of next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 的最小大小。</target>
        </trans-unit>
        <trans-unit id="36461254172845cccb18d0bf80dba5e9c41d913e" translate="yes" xml:space="preserve">
          <source>Minimal verbosity: print one line per compilation (this is the default when &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">最小的详细程度：每次编译仅打印一行（这是&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt;启用时的默认设置）。</target>
        </trans-unit>
        <trans-unit id="13dd082aed431f232c24aac55d18467c2b663e2e" translate="yes" xml:space="preserve">
          <source>Minimum % ⟨n⟩ of heap which must be available for allocation.</source>
          <target state="translated">最小的百分比 ⟨n⟩的堆必须是可供分配的。</target>
        </trans-unit>
        <trans-unit id="b2c5225f522390e3a01cad15518a7fad4845c00b" translate="yes" xml:space="preserve">
          <source>Minimum of two size hints.</source>
          <target state="translated">至少有两个尺寸提示。</target>
        </trans-unit>
        <trans-unit id="6375390ec9f90418a19031fe946ea7c8b08c7ed6" translate="yes" xml:space="preserve">
          <source>Minor utilities for the HPC tools.</source>
          <target state="translated">HPC工具的小工具。</target>
        </trans-unit>
        <trans-unit id="0f40575a4f8fcd450cc8e24d023e408e6a539894" translate="yes" xml:space="preserve">
          <source>MiscFlags</source>
          <target state="translated">MiscFlags</target>
        </trans-unit>
        <trans-unit id="2aa593cd19b234155d3652986effbe2cabb181f4" translate="yes" xml:space="preserve">
          <source>Miscelaneous information available for debugging purposes.</source>
          <target state="translated">可用于调试的杂项信息。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="6b75dbc2d8c884fa76ebd1fab5321c113f5bdcc6" translate="yes" xml:space="preserve">
          <source>Miscellaneous GMP-provided operations</source>
          <target state="translated">GMP提供的杂项业务</target>
        </trans-unit>
        <trans-unit id="5e68c0546c69483d4d1cb26b8fe241467b0b0496" translate="yes" xml:space="preserve">
          <source>Miscellaneous backend dumps</source>
          <target state="translated">杂项后端转储</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">杂项职能</target>
        </trans-unit>
        <trans-unit id="766dde0dd177116968305ecf5af25276425044a7" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions on tactics</source>
          <target state="translated">战术方面的杂项功能</target>
        </trans-unit>
        <trans-unit id="fc807e2d7976d257c9171d114a6eb3efc8cab20a" translate="yes" xml:space="preserve">
          <source>Miscellaneous information about the system environment.</source>
          <target state="translated">关于系统环境的各种信息。</target>
        </trans-unit>
        <trans-unit id="bddea403651e35362ffdbaad6b7106a982b909aa" translate="yes" xml:space="preserve">
          <source>Miscellaneous information available for debugging purposes.</source>
          <target state="translated">可供调试用的杂项信息。</target>
        </trans-unit>
        <trans-unit id="142e1b72c08ab742f64274e6c7d575bbcc8429f4" translate="yes" xml:space="preserve">
          <source>Miscellaneous parameters</source>
          <target state="translated">杂项参数</target>
        </trans-unit>
        <trans-unit id="75614093589ee1a6ed1d6b3a9a321b001454bfa9" translate="yes" xml:space="preserve">
          <source>Miscellaneous tactic functions</source>
          <target state="translated">杂项战术功能</target>
        </trans-unit>
        <trans-unit id="120f9c9998409369934eaac96bbbad1e69990044" translate="yes" xml:space="preserve">
          <source>Mismatch between the argument types and the format string, as well as any other syntactic or semantic errors in the format string, will cause an exception to be thrown at runtime.</source>
          <target state="translated">参数类型和格式字符串之间的不匹配,以及格式字符串中的任何其他语法或语义错误,都会导致在运行时抛出异常。</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="a5446b7cafd6f64fa36d064009daafea44ba609c" translate="yes" xml:space="preserve">
          <source>Mix DataStructure</source>
          <target state="translated">混合数据结构</target>
        </trans-unit>
        <trans-unit id="832e98200646adcbff0ea6a3b2b8398b73caa5ed" translate="yes" xml:space="preserve">
          <source>MixEntry</source>
          <target state="translated">MixEntry</target>
        </trans-unit>
        <trans-unit id="517dcc2aab9ff981e3d03a30ce6935c8e5ebac7e" translate="yes" xml:space="preserve">
          <source>MixEntryDom</source>
          <target state="translated">MixEntryDom</target>
        </trans-unit>
        <trans-unit id="d6840928afb9e96dced0538038e4e1c1eac39e1f" translate="yes" xml:space="preserve">
          <source>MkSystemTime</source>
          <target state="translated">MkSystemTime</target>
        </trans-unit>
        <trans-unit id="30376c6ee888990666c554e49bebf998120a5703" translate="yes" xml:space="preserve">
          <source>Mn: Mark, Non-Spacing</source>
          <target state="translated">Mn:标记,无间隔</target>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="f149e0b10681e7408d843a0239621f9345205680" translate="yes" xml:space="preserve">
          <source>ModJulianDate</source>
          <target state="translated">ModJulianDate</target>
        </trans-unit>
        <trans-unit id="7a6df6254eeab02c96836922ac0139d166dad965" translate="yes" xml:space="preserve">
          <source>ModName</source>
          <target state="translated">ModName</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="e6c089b7ef71ad84d0b5ea7857ddf7e884d95cec" translate="yes" xml:space="preserve">
          <source>Mode wrappers</source>
          <target state="translated">模式包装纸</target>
        </trans-unit>
        <trans-unit id="6fd961190d330e230cb25033021abb41924a952f" translate="yes" xml:space="preserve">
          <source>Mode: A mode may be used on the command line only. You can pass only one mode flag. For example, &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt;. The available modes are listed in &lt;a href=&quot;#modes&quot;&gt;Modes of operation&lt;/a&gt;.</source>
          <target state="translated">模式：模式只能在命令行上使用。您只能传递一个模式标志。例如，-- &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt;。可用模式在&lt;a href=&quot;#modes&quot;&gt;操作&lt;/a&gt;模式中列出。</target>
        </trans-unit>
        <trans-unit id="b0b30babf16ffbe6c525df9ecff6598de4eeedcf" translate="yes" xml:space="preserve">
          <source>ModifiedJulianDay</source>
          <target state="translated">ModifiedJulianDay</target>
        </trans-unit>
        <trans-unit id="ad8932265b6513f8f4632598479d16d811295a0e" translate="yes" xml:space="preserve">
          <source>ModifierLetter</source>
          <target state="translated">ModifierLetter</target>
        </trans-unit>
        <trans-unit id="06e78e77af950abb3de1917e6c715f81fbe8971c" translate="yes" xml:space="preserve">
          <source>ModifierParser</source>
          <target state="translated">ModifierParser</target>
        </trans-unit>
        <trans-unit id="a6384fc88bd1c896276b41e4e1213a85a46e0ff7" translate="yes" xml:space="preserve">
          <source>ModifierSymbol</source>
          <target state="translated">ModifierSymbol</target>
        </trans-unit>
        <trans-unit id="612cabf63b0ae37796ad667f19fbb51eec48245e" translate="yes" xml:space="preserve">
          <source>Modify the ambient monad used during code generation. For example, you can use &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; to handle a state effect: &lt;code&gt;
  handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a
  handleState = hoistCode (flip runState 0)
 &lt;/code&gt;</source>
          <target state="translated">修改代码生成过程中使用的环境单子。例如，您可以使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; 处理状态效果： &lt;code&gt; handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a handleState = hoistCode (flip runState 0) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbb225bd76a44ecd21f3cad93b922d790b638f86" translate="yes" xml:space="preserve">
          <source>Modify the ambient monad used during code generation. For example, you can use &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; to handle a state effect: &lt;code&gt;
  handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a
  handleState = hoistCode (flip runState 0)
 &lt;/code&gt;</source>
          <target state="translated">修改代码生成过程中使用的环境单子。例如，您可以使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:hoistCode&quot;&gt;hoistCode&lt;/a&gt;&lt;/code&gt; 处理状态效果： &lt;code&gt; handleState :: Code (StateT Int Q) a -&amp;gt; Code Q a handleState = hoistCode (flip runState 0) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6320257ec347ce7461b6559133a0cc26667c4e6d" translate="yes" xml:space="preserve">
          <source>Modify the contents of a &lt;code&gt;MutVar#&lt;/code&gt;, returning the previous contents and the result of applying the given function to the previous contents.</source>
          <target state="translated">修改 &lt;code&gt;MutVar#&lt;/code&gt; 的内容，返回先前的内容以及将给定函数应用于先前的内容的结果。</target>
        </trans-unit>
        <trans-unit id="f0a2b227aefd779ece79d3f6ad8baef4e51ab448" translate="yes" xml:space="preserve">
          <source>Modify the contents of a &lt;code&gt;MutVar#&lt;/code&gt;, returning the previous contents and the result of applying the given function to the previous contents. Note that this isn't strictly speaking the correct type for this function; it should really be &lt;code&gt;MutVar# s a -&amp;gt; (a -&amp;gt; (a,b)) -&amp;gt; State# s -&amp;gt; (# State# s, a, (a, b) #)&lt;/code&gt;, but we don't know about pairs here.</source>
          <target state="translated">修改 &lt;code&gt;MutVar#&lt;/code&gt; 的内容，返回先前的内容以及将给定函数应用于先前的内容的结果。请注意，严格来讲，这并不是该函数的正确类型；它实际上应该是 &lt;code&gt;MutVar# s a -&amp;gt; (a -&amp;gt; (a,b)) -&amp;gt; State# s -&amp;gt; (# State# s, a, (a, b) #)&lt;/code&gt; ，但是我们不知道对这里。</target>
        </trans-unit>
        <trans-unit id="6ecabc24fa376f8bfdd5f9771659364d02446fee" translate="yes" xml:space="preserve">
          <source>Modify the depth of the evaluation history tracked by GHCi.</source>
          <target state="translated">修改GHCi跟踪的评价历史深度。</target>
        </trans-unit>
        <trans-unit id="18199c686f30decfd6449ba999c8002260a92575" translate="yes" xml:space="preserve">
          <source>Modify the value of an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修改 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="34813144ec19f74db4ddda85d08e6849e3f1487f" translate="yes" xml:space="preserve">
          <source>Modifying the code slightly, however, produces code which will not compile:</source>
          <target state="translated">但是,稍微修改一下代码,就会产生无法编译的代码。</target>
        </trans-unit>
        <trans-unit id="4c32fd82ceb8daf13a6616a1ab5a958038171a59" translate="yes" xml:space="preserve">
          <source>Modifying the user environment</source>
          <target state="translated">修改用户环境</target>
        </trans-unit>
        <trans-unit id="e075617bae1ed6d213cacf5b4a1963cf2b558270" translate="yes" xml:space="preserve">
          <source>Modular arithmetic</source>
          <target state="translated">模块化算术</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="40b31c77d57b0de63020f3b87cedcf39795f6b82" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">模块&lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;提供可存储数组的接口。它们是类 &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 的实例（带有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad）。</target>
        </trans-unit>
        <trans-unit id="dfbffd6a6167f932043b8ceb3531f4ecd4669be4" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">模块&lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;提供可存储数组的接口。它们是类 &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; （带有 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad）的实例。</target>
        </trans-unit>
        <trans-unit id="6b407bb0936075a0d89e6cf1e7e32901f003e72c" translate="yes" xml:space="preserve">
          <source>Module &lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt; provides the interface of storable arrays. They are instances of class &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; (with the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad).</source>
          <target state="translated">模块&lt;a href=&quot;data-array-marray&quot;&gt;Data.Array.MArray&lt;/a&gt;提供可存储数组的接口。它们是类 &lt;code&gt;&lt;a href=&quot;data-array-marray#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; （带有 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad）的实例。</target>
        </trans-unit>
        <trans-unit id="59fc78cc7268113b6d14c7ba3a0c68ede04edd9f" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Y&lt;/code&gt; exports all the entities defined in &lt;code&gt;Y&lt;/code&gt;, namely the data constructors &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt;, and &lt;em&gt;implicitly&lt;/em&gt; the data family &lt;code&gt;D&lt;/code&gt;, even though it&amp;rsquo;s defined in &lt;code&gt;X&lt;/code&gt;. This means you can write &lt;code&gt;import Y( D(D1,D2) )&lt;/code&gt;&lt;em&gt;without&lt;/em&gt; giving an explicit export list like this:</source>
          <target state="translated">模块 &lt;code&gt;Y&lt;/code&gt; 导出在 &lt;code&gt;Y&lt;/code&gt; 中定义的所有实体，即数据构造函数 &lt;code&gt;D1&lt;/code&gt; 和 &lt;code&gt;D2&lt;/code&gt; ，以及&lt;em&gt;隐式&lt;/em&gt;的数据族 &lt;code&gt;D&lt;/code&gt; ，即使它在 &lt;code&gt;X&lt;/code&gt; 中定义。这意味着您可以编写 &lt;code&gt;import Y( D(D1,D2) )&lt;/code&gt; &lt;em&gt;而无需&lt;/em&gt;给出像这样的显式导出列表：</target>
        </trans-unit>
        <trans-unit id="7ca5283a9401b368ad7082d2368aee85af976008" translate="yes" xml:space="preserve">
          <source>Module Data.Typeable re-exported for convenience</source>
          <target state="translated">为方便起见,模块Data.Typeable被重新导出。</target>
        </trans-unit>
        <trans-unit id="ec22b40d47f573ceb3764447b0fd39403f6d6c2d" translate="yes" xml:space="preserve">
          <source>Module authors using the &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; language extension for a module &lt;code&gt;M&lt;/code&gt; should ensure that &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s public API (the symbols exposed by its export list) can&amp;rsquo;t be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.</source>
          <target state="translated">使用模块 &lt;code&gt;M&lt;/code&gt; 的&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;语言扩展的模块作者应确保不能以不安全的方式使用 &lt;code&gt;M&lt;/code&gt; 的公共API（其导出列表公开的符号）。这意味着导出的符号应遵守类型安全性和引用透明性。</target>
        </trans-unit>
        <trans-unit id="91ba4bca6673e09b576e66d35a05c3026f377972" translate="yes" xml:space="preserve">
          <source>Module authors using the &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; language extension for a module &lt;code&gt;M&lt;/code&gt; should ensure that &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s public API (the symbols exposed by its export list) can&amp;rsquo;t be used in an unsafe manner. This mean that symbols exported should respect type safety and referential transparency.</source>
          <target state="translated">使用模块 &lt;code&gt;M&lt;/code&gt; 的&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;语言扩展的模块作者应确保不会以不安全的方式使用 &lt;code&gt;M&lt;/code&gt; 的公共API（其导出列表中显示的符号）。这意味着导出的符号应遵守类型安全性和引用透明性。</target>
        </trans-unit>
        <trans-unit id="58b8208bcfdac835bd589f0a0f394caee9130541" translate="yes" xml:space="preserve">
          <source>Module names</source>
          <target state="translated">模块名称</target>
        </trans-unit>
        <trans-unit id="9ae357fac1f871ab051702ee0509a637ca73c454" translate="yes" xml:space="preserve">
          <source>Module over monad operator for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Monad运算符上的模块 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Code&quot;&gt;Code&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb27714f2a03885159601b0fa4f8b118e5c3a120" translate="yes" xml:space="preserve">
          <source>Module prefix of a name, if it exists.</source>
          <target state="translated">名称的模块前缀,如果存在的话。</target>
        </trans-unit>
        <trans-unit id="00d767e865b30777f85d5e023407cb4c65ee4110" translate="yes" xml:space="preserve">
          <source>Module signatures actually consist of two closely related features:</source>
          <target state="translated">模块签名实际上由两个密切相关的特征组成。</target>
        </trans-unit>
        <trans-unit id="80246c9711a49a29d3a5e03817c371dd6ae4cbfc" translate="yes" xml:space="preserve">
          <source>ModuleAnnotation</source>
          <target state="translated">ModuleAnnotation</target>
        </trans-unit>
        <trans-unit id="538831de95e10dc8de9dab5d4714b91d07aa6e76" translate="yes" xml:space="preserve">
          <source>ModuleInfo</source>
          <target state="translated">ModuleInfo</target>
        </trans-unit>
        <trans-unit id="17c49dd9a2601ed05a4293ce1094e4ae4f9be60b" translate="yes" xml:space="preserve">
          <source>Modules compiled with this option can be freely mixed with modules compiled without it; indeed, most libraries will typically be compiled without &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt;. When the program is run, coverage data will only be generated for those modules that were compiled with &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt;, and the &lt;strong&gt;hpc&lt;/strong&gt; tool will only show information about those modules.</source>
          <target state="translated">使用此选项编译的模块可以与不使用此选项编译的模块自由混合；实际上，大多数库通常在不使用&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; 的&lt;/a&gt;情况下进行编译。运行该程序时，将仅为使用&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt;编译的模块生成覆盖率数据，而&lt;strong&gt;hpc&lt;/strong&gt;工具将仅显示有关这些模块的信息。</target>
        </trans-unit>
        <trans-unit id="7f34a515a9849c6d1d6359aa243ee958639d54b5" translate="yes" xml:space="preserve">
          <source>Modules reexported by this package. This list takes the form of &lt;code&gt;pkg:OldName as NewName (A@orig-pkg-0.1-HASH)&lt;/code&gt;: the first portion of the string is the user-written reexport specification (possibly omitting the package qualifier and the renaming), while the parenthetical is the original package which exposed the module under are particular name. Reexported modules have a relaxed overlap constraint: it&amp;rsquo;s permissible for two packages to reexport the same module as the same name if the reexported moduleis identical.</source>
          <target state="translated">此软件包重新导出的模块。此列表采用 &lt;code&gt;pkg:OldName as NewName (A@orig-pkg-0.1-HASH)&lt;/code&gt; 的形式（A@orig-pkg-0.1-HASH）：字符串的第一部分是用户编写的重新导出规范（可能省略了包限定符和重命名），而在括号中是在特定名称下暴露模块的原始包装。重新导出的模块具有宽松的重叠约束：如果重新导出的模块相同，则允许两个包以相同的名称重新导出相同的模块。</target>
        </trans-unit>
        <trans-unit id="44309d68cfcd4f5d92e2cc5899604b23cc2ee7ad" translate="yes" xml:space="preserve">
          <source>Modules using unboxed tuples or sums will automatically enable &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">使用未装箱的元组或总和的模块将自动启用&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3bc4d952ccd3346da0175b0abdc685fcb3a3272" translate="yes" xml:space="preserve">
          <source>Modulus of natural numbers. &lt;code&gt;Mod x 0&lt;/code&gt; is undefined (i.e., it cannot be reduced).</source>
          <target state="translated">自然数的模数。 &lt;code&gt;Mod x 0&lt;/code&gt; 是未定义的（即无法减少）。</target>
        </trans-unit>
        <trans-unit id="11531c3c6a7c6d49562c188b9bdc843a54288d30" translate="yes" xml:space="preserve">
          <source>Monad</source>
          <target state="translated">Monad</target>
        </trans-unit>
        <trans-unit id="f117e306f3bfe1ed114c24f6bd68d2322d3b742f" translate="yes" xml:space="preserve">
          <source>Monad comprehensions generalise the list comprehension notation, including parallel comprehensions (&lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;) and transform comprehensions (&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) to work for any monad.</source>
          <target state="translated">Monad理解概括了列表理解表示法，包括并行理解（&lt;a href=&quot;#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;）和转换理解（&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;广义（类似于SQL的）List Comprehensions&lt;/a&gt;）适用于任何monad。</target>
        </trans-unit>
        <trans-unit id="e9a1db2a2bc244dd09436f1dc6c3b604a440f9fe" translate="yes" xml:space="preserve">
          <source>Monad comprehensions generalise the list comprehension notation, including parallel comprehensions (&lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;) and transform comprehensions (&lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) to work for any monad.</source>
          <target state="translated">Monad理解概括了列表理解表示法，包括并行理解（&lt;a href=&quot;parallel_list_comprehensions#parallel-list-comprehensions&quot;&gt;Parallel List Comprehensions&lt;/a&gt;）和转换理解（&lt;a href=&quot;generalised_list_comprehensions#generalised-list-comprehensions&quot;&gt;广义（类似于SQL的）List Comprehensions&lt;/a&gt;）以适用于任何monad。</target>
        </trans-unit>
        <trans-unit id="2b154b6a867643b57ffe3e50fb7555800ae79d0a" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support rebindable syntax (&lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;). Without rebindable syntax, the operators from the &amp;ldquo;standard binding&amp;rdquo; module are used; with rebindable syntax, the operators are looked up in the current lexical scope. For example, parallel comprehensions will be typechecked and desugared using whatever &amp;ldquo;&lt;code&gt;mzip&lt;/code&gt;&amp;rdquo; is in scope.</source>
          <target state="translated">Monad理解支持可重新绑定的语法（&lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable语法和隐式Prelude import&lt;/a&gt;）。在没有可重新绑定语法的情况下，将使用&amp;ldquo;标准绑定&amp;rdquo;模块中的运算符；使用可重新绑定的语法，在当前词法范围内查找运算符。例如，并行理解将使用范围内的任何&amp;ldquo; &lt;code&gt;mzip&lt;/code&gt; &amp;rdquo; 进行类型检查和删除。</target>
        </trans-unit>
        <trans-unit id="7cb902b1da8088200b68ff6ba9cddaada5c6c71a" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support rebindable syntax (&lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;). Without rebindable syntax, the operators from the &amp;ldquo;standard binding&amp;rdquo; module are used; with rebindable syntax, the operators are looked up in the current lexical scope. For example, parallel comprehensions will be typechecked and desugared using whatever &amp;ldquo;&lt;code&gt;mzip&lt;/code&gt;&amp;rdquo; is in scope.</source>
          <target state="translated">Monad理解支持可重新绑定的语法（&lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable语法和隐式Prelude import&lt;/a&gt;）。在没有可重新绑定语法的情况下，将使用&amp;ldquo;标准绑定&amp;rdquo;模块中的运算符；使用可重新绑定的语法，在当前词法范围内查找运算符。例如，将使用范围内的任何&amp;ldquo; &lt;code&gt;mzip&lt;/code&gt; &amp;rdquo;对并行理解进行类型检查和删除。</target>
        </trans-unit>
        <trans-unit id="9118814255c8cbff0f92707b31e2747bffbb4a14" translate="yes" xml:space="preserve">
          <source>Monad comprehensions support:</source>
          <target state="translated">单体理解力支持。</target>
        </trans-unit>
        <trans-unit id="ccf5f31df2b47a5c8b3c7b4b8bec553c0e566b1a" translate="yes" xml:space="preserve">
          <source>Monad transformation</source>
          <target state="translated">单体转换</target>
        </trans-unit>
        <trans-unit id="1c0fd921dbc28d4c0620875213e77e22d440c417" translate="yes" xml:space="preserve">
          <source>Monad transformations</source>
          <target state="translated">单元变换</target>
        </trans-unit>
        <trans-unit id="b85021f1542ee4ad142b965dc1641cf10fd4260f" translate="yes" xml:space="preserve">
          <source>Monad values are functions from the environment to a value. The bound function is applied to the bound value, and both have access to the shared environment.</source>
          <target state="translated">单元值是环境到值的函数。绑定函数应用于绑定值,两者都可以访问共享环境。</target>
        </trans-unit>
        <trans-unit id="5a1aa98499a1d957e619f8fa4af2de6d1152500b" translate="yes" xml:space="preserve">
          <source>MonadComprehensions</source>
          <target state="translated">MonadComprehensions</target>
        </trans-unit>
        <trans-unit id="c6fb342904057550b8ef01f426ca92e465116ed4" translate="yes" xml:space="preserve">
          <source>MonadCont</source>
          <target state="translated">MonadCont</target>
        </trans-unit>
        <trans-unit id="89861c606303650c7e7f0d7c743da67de31d69c7" translate="yes" xml:space="preserve">
          <source>MonadCont class</source>
          <target state="translated">MonadCont类</target>
        </trans-unit>
        <trans-unit id="39a661caab336fa22d832d7beffd7388def93e46" translate="yes" xml:space="preserve">
          <source>MonadError</source>
          <target state="translated">MonadError</target>
        </trans-unit>
        <trans-unit id="6971cd3387fcb89462309d104896a63aacd3ef19" translate="yes" xml:space="preserve">
          <source>MonadException</source>
          <target state="translated">MonadException</target>
        </trans-unit>
        <trans-unit id="16fc28da849b4c8c2a56c99fe357bebb2ee341a7" translate="yes" xml:space="preserve">
          <source>MonadFail</source>
          <target state="translated">MonadFail</target>
        </trans-unit>
        <trans-unit id="7fdd52d0e4c29c94ae163aa3e69f06596bf4ebd0" translate="yes" xml:space="preserve">
          <source>MonadFailDesugaring</source>
          <target state="translated">MonadFailDesugaring</target>
        </trans-unit>
        <trans-unit id="8cd3e027e126ef51355bf4e476d5b9c913c5824c" translate="yes" xml:space="preserve">
          <source>MonadFix</source>
          <target state="translated">MonadFix</target>
        </trans-unit>
        <trans-unit id="464a90d352252a57d56693a4858884c98810e3a1" translate="yes" xml:space="preserve">
          <source>MonadIO</source>
          <target state="translated">MonadIO</target>
        </trans-unit>
        <trans-unit id="741fdf5e9791ce30c278a5afdbd3129dd2c1ead9" translate="yes" xml:space="preserve">
          <source>MonadPlus</source>
          <target state="translated">MonadPlus</target>
        </trans-unit>
        <trans-unit id="e59b4d8e1e1b084ca225560b46a86c3f02b6c3c8" translate="yes" xml:space="preserve">
          <source>MonadReader</source>
          <target state="translated">MonadReader</target>
        </trans-unit>
        <trans-unit id="a68c00a3ea80c75e5ccf937dfcb38fee6f14dbc7" translate="yes" xml:space="preserve">
          <source>MonadReader class</source>
          <target state="translated">MonadReader类</target>
        </trans-unit>
        <trans-unit id="4dbbde36c5c41657a758435796e76b6fee9c0240" translate="yes" xml:space="preserve">
          <source>MonadState</source>
          <target state="translated">MonadState</target>
        </trans-unit>
        <trans-unit id="f176c139b4727308ec824a9344e742f670f0aa3b" translate="yes" xml:space="preserve">
          <source>MonadState class</source>
          <target state="translated">MonadState类</target>
        </trans-unit>
        <trans-unit id="a2e64d3be4f20e02142a613432a291ee3dae4677" translate="yes" xml:space="preserve">
          <source>MonadState class.</source>
          <target state="translated">MonadState类。</target>
        </trans-unit>
        <trans-unit id="29e37501f89d2caf27053c9fb3f8913750d9897a" translate="yes" xml:space="preserve">
          <source>MonadTrans</source>
          <target state="translated">MonadTrans</target>
        </trans-unit>
        <trans-unit id="3f2f8d76eb3c2357f757275d57fffc9c8d4ee396" translate="yes" xml:space="preserve">
          <source>MonadTrans (&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; s u)</source>
          <target state="translated">MonadTrans（&lt;a href=&quot;text-parsec#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; su）</target>
        </trans-unit>
        <trans-unit id="60a504062889fae8b9e846460fc07b21f50fb371" translate="yes" xml:space="preserve">
          <source>MonadTrans (&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; s u)</source>
          <target state="translated">MonadTrans（&lt;a href=&quot;text-parsec-prim#t:ParsecT&quot;&gt;ParsecT&lt;/a&gt; su）</target>
        </trans-unit>
        <trans-unit id="652f00fb36c1c38645bc9e90431a168567726128" translate="yes" xml:space="preserve">
          <source>MonadWriter</source>
          <target state="translated">MonadWriter</target>
        </trans-unit>
        <trans-unit id="f9be51da3714e0cf4aee03cf4cecccec8f06c1ad" translate="yes" xml:space="preserve">
          <source>MonadWriter class</source>
          <target state="translated">MonadWriter类</target>
        </trans-unit>
        <trans-unit id="52dae74b8add8e5bac5ef90f8e6def33af0626f8" translate="yes" xml:space="preserve">
          <source>MonadZip</source>
          <target state="translated">MonadZip</target>
        </trans-unit>
        <trans-unit id="37921d15310812cb15bb950e0e8c69478968709e" translate="yes" xml:space="preserve">
          <source>Monadic actions</source>
          <target state="translated">单项行动</target>
        </trans-unit>
        <trans-unit id="be38a4e3e1a34b178a11a5fbcae21f0a5b3e86dc" translate="yes" xml:space="preserve">
          <source>Monadic fixpoints.</source>
          <target state="translated">一元的fixpoints。</target>
        </trans-unit>
        <trans-unit id="79464d099a2a04a0be206b18bf0034c16bdc124c" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure, associating to the left, i.e. from left to right.</source>
          <target state="translated">在结构元素上的单元折叠,向左关联,即从左到右。</target>
        </trans-unit>
        <trans-unit id="0f4ba0ee1732f5a3212ba30683790be701be210c" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure, associating to the right, i.e. from right to left.</source>
          <target state="translated">在结构的元素上进行单元折叠,向右联想,即从右到左。</target>
        </trans-unit>
        <trans-unit id="ccb232023546e12a237e28f888ebb5702510f0c0" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure. This type of fold is left-associative in the monadic effects, and right-associative in the output value.</source>
          <target state="translated">在结构的元素上进行单项折叠。这种类型的折叠在单体效果上是左关联的,在输出值上是右关联的。</target>
        </trans-unit>
        <trans-unit id="5c2c7207e0e94b1363bbea4d7345d4fdd0da8444" translate="yes" xml:space="preserve">
          <source>Monadic fold over the elements of a structure. This type of fold is right-associative in the monadic effects, and left-associative in the output value.</source>
          <target state="translated">在结构的元素上进行单项折叠。这种类型的折叠在单体效果上是右关联的,在输出值上是左关联的。</target>
        </trans-unit>
        <trans-unit id="5595a6b57f768b1b94cd5faeef182cec9288c190" translate="yes" xml:space="preserve">
          <source>Monadic forest builder, in breadth-first order</source>
          <target state="translated">一元化森林建设者,以广度为第一顺序。</target>
        </trans-unit>
        <trans-unit id="8b5e9251f6a7731c5728c4734b226c8f0fb9eb58" translate="yes" xml:space="preserve">
          <source>Monadic forest builder, in depth-first order</source>
          <target state="translated">一元化森林建设者,深入一阶。</target>
        </trans-unit>
        <trans-unit id="92e8f6d8093ef19a3fbeb20205bdce42d7b88c0f" translate="yes" xml:space="preserve">
          <source>Monadic front-end to Text.PrettyPrint</source>
          <target state="translated">Text.PrettyPrint的单体前端。</target>
        </trans-unit>
        <trans-unit id="4700a1dc5dbcbeb872e70164fe9a3ec9d66a7714" translate="yes" xml:space="preserve">
          <source>Monadic lifting operators</source>
          <target state="translated">单体吊装操作员</target>
        </trans-unit>
        <trans-unit id="cb3f1c0525f059418665af747bb13d9f2d7d0703" translate="yes" xml:space="preserve">
          <source>Monadic state transformer.</source>
          <target state="translated">单元状态的变压器。</target>
        </trans-unit>
        <trans-unit id="afd12b25574336c915d17d02eed63bdd6790c29d" translate="yes" xml:space="preserve">
          <source>Monadic tree builder, in breadth-first order.</source>
          <target state="translated">一元建树者,以广度为第一顺序。</target>
        </trans-unit>
        <trans-unit id="1c0844a453139b42e240b3dbd8899eb7e45afa2d" translate="yes" xml:space="preserve">
          <source>Monadic tree builder, in depth-first order.</source>
          <target state="translated">单元建树器,深度一阶。</target>
        </trans-unit>
        <trans-unit id="751701098af9ceab4eca10e3e9e72843e8819c96" translate="yes" xml:space="preserve">
          <source>Monadic variation on &lt;code&gt;&lt;a href=&quot;data-data#v:fromConstrB&quot;&gt;fromConstrB&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:fromConstrB&quot;&gt;fromConstrB&lt;/a&gt;&lt;/code&gt; 的单子变体</target>
        </trans-unit>
        <trans-unit id="9159bd85753caa0996e8d4ad3b128a9014c50e05" translate="yes" xml:space="preserve">
          <source>Monadic zipping (used for monad comprehensions)</source>
          <target state="translated">单项式扎法</target>
        </trans-unit>
        <trans-unit id="250083fc6df0956d1673cca1cb1611bfc11ab137" translate="yes" xml:space="preserve">
          <source>Monads and functors</source>
          <target state="translated">单子和漏斗</target>
        </trans-unit>
        <trans-unit id="9fade08cca7ae6ce3b29ed4f480ac77d554be713" translate="yes" xml:space="preserve">
          <source>Monads having fixed points with a 'knot-tying' semantics. Instances of &lt;code&gt;&lt;a href=&quot;control-monad-fix#t:MonadFix&quot;&gt;MonadFix&lt;/a&gt;&lt;/code&gt; should satisfy the following laws:</source>
          <target state="translated">具有&amp;ldquo;打结&amp;rdquo;语义的定点的Monad。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#t:MonadFix&quot;&gt;MonadFix&lt;/a&gt;&lt;/code&gt; 的实例应满足以下法律：</target>
        </trans-unit>
        <trans-unit id="3ab257a5f129af1981f621c8ddf84b2fd68c88ba" translate="yes" xml:space="preserve">
          <source>Monads in which &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computations may be embedded. Any monad built by applying a sequence of monad transformers to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad will be an instance of this class.</source>
          <target state="translated">可以在其中嵌入 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算的Monad 。通过将一系列monad转换器应用于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad而构建的任何monad 都将是此类的一个实例。</target>
        </trans-unit>
        <trans-unit id="bec921c5487ea6eaf795a69781d0904af33f534a" translate="yes" xml:space="preserve">
          <source>Monads that also support choice and failure.</source>
          <target state="translated">单元,也支持选择和失败。</target>
        </trans-unit>
        <trans-unit id="20f29bb326b4b655b5b0354aa1b0ff90343d0044" translate="yes" xml:space="preserve">
          <source>Monads with error handling</source>
          <target state="translated">具有错误处理功能的单项式</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="36181aae20a5a2ae5ba1584c42b3b9779dffec5e" translate="yes" xml:space="preserve">
          <source>Monday-starting week number (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">星期一开始的星期数（以 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;%W&lt;/code&gt; 表示）。</target>
        </trans-unit>
        <trans-unit id="b5307adf2da7c702cf60f2a0dad66c188a1c8b3b" translate="yes" xml:space="preserve">
          <source>MonoLocalBinds</source>
          <target state="translated">MonoLocalBinds</target>
        </trans-unit>
        <trans-unit id="db3026559eb3ab8db4d183918b45caef643c418f" translate="yes" xml:space="preserve">
          <source>MonoPatBinds</source>
          <target state="translated">MonoPatBinds</target>
        </trans-unit>
        <trans-unit id="9c5483b826379f2567e8ee89ca55b9c52e011529" translate="yes" xml:space="preserve">
          <source>Monoid</source>
          <target state="translated">Monoid</target>
        </trans-unit>
        <trans-unit id="0220c03411dbd64cddd0b0ccca5475f10ebe0331" translate="yes" xml:space="preserve">
          <source>Monoid functions</source>
          <target state="translated">单体函数</target>
        </trans-unit>
        <trans-unit id="e0ac9d688b93e0a5de738795a1f225343db79584" translate="yes" xml:space="preserve">
          <source>Monoid operations</source>
          <target state="translated">单体运算</target>
        </trans-unit>
        <trans-unit id="3a1b4f214513abdcdf27e4ab6401c3d176d9757e" translate="yes" xml:space="preserve">
          <source>Monoid under &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 下的Monoid 。</target>
        </trans-unit>
        <trans-unit id="8f6543d6abb3998d23fb62d545057fa1ab18548a" translate="yes" xml:space="preserve">
          <source>Monoid under addition.</source>
          <target state="translated">加法下的单体。</target>
        </trans-unit>
        <trans-unit id="7029b0947bbd5af2e213d2e9bb3c221593a86f9d" translate="yes" xml:space="preserve">
          <source>Monoid under multiplication.</source>
          <target state="translated">乘法下的单体。</target>
        </trans-unit>
        <trans-unit id="3e61bbeed3f08fcc986f97d9c436530dd737834a" translate="yes" xml:space="preserve">
          <source>Monomorphic equality operators</source>
          <target state="translated">单形平等运算符</target>
        </trans-unit>
        <trans-unit id="129d16939021f97809d6e9d8b3a79a644e52d05b" translate="yes" xml:space="preserve">
          <source>MonomorphismRestriction</source>
          <target state="translated">MonomorphismRestriction</target>
        </trans-unit>
        <trans-unit id="b9bd340d94bbe1799fa2827ad776ca607d3614ba" translate="yes" xml:space="preserve">
          <source>Morally, builder primitives are like functions &lt;code&gt;a -&amp;gt; Builder&lt;/code&gt;, that is they take a value and encode it as a sequence of bytes, represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. Of course their implementation is a bit more specialised.</source>
          <target state="translated">从道德上讲，构建器原语就像a- &lt;code&gt;a -&amp;gt; Builder&lt;/code&gt; 函数，也就是说，它们采用一个值并将其编码为字节序列，表示为 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。当然，它们的实现更加专业。</target>
        </trans-unit>
        <trans-unit id="d66f6edcbd906b2619c8ac8ef5055169fffaa86c" translate="yes" xml:space="preserve">
          <source>More concretely, if &lt;code&gt;nameAndLineCount&lt;/code&gt; counts the number of lines in a file, returning a pair with input filename and the line count, then traversal over a list of file names produces an IO action that evaluates to a list of &lt;strong&gt;&lt;code&gt;(fileName, lineCount)&lt;/code&gt;&lt;/strong&gt; pairs:</source>
          <target state="translated">更具体地讲，如果 &lt;code&gt;nameAndLineCount&lt;/code&gt; 对文件中的行数进行计数，并返回具有输入文件名和行数的线对，则遍历文件名列表将产生IO操作，其结果为&lt;strong&gt; &lt;code&gt;(fileName, lineCount)&lt;/code&gt; &lt;/strong&gt;对的列表：</target>
        </trans-unit>
        <trans-unit id="a9713777f0ffc9301f9aa702f90a88fc96cd4daa" translate="yes" xml:space="preserve">
          <source>More concretely, the input to a command consists of a pair of an environment and a stack. Each value on the stack is paired with the remainder of the stack, with an empty stack being &lt;code&gt;()&lt;/code&gt;. So operators like &lt;code&gt;handleA&lt;/code&gt; that pass extra inputs to their subcommands can be designed for use with the notation by placing the values on the stack paired with the environment in this way. More precisely, the type of each argument of the operator (and its result) should have the form</source>
          <target state="translated">更具体地说，命令的输入由一对环境和一个堆栈组成。堆栈上的每个值都与堆栈的其余部分配对，空堆栈为 &lt;code&gt;()&lt;/code&gt; 。因此，可以通过将值放在与环境配对的堆栈上，将像 &lt;code&gt;handleA&lt;/code&gt; 这样的运算符传递额外的输入到其子命令，以将其设计为与该符号一起使用。更准确地说，运算符的每个参数的类型（及其结果）应具有以下形式：</target>
        </trans-unit>
        <trans-unit id="8806e84b84beada4d40a025a8b169a5dd3603418" translate="yes" xml:space="preserve">
          <source>More crucially, we can also directly define the key building block for generative recursion:</source>
          <target state="translated">更关键的是,我们还可以直接定义生成式递归的关键构件。</target>
        </trans-unit>
        <trans-unit id="31b13373cbfa12cceaf613513d103c95459cbf88" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;debugging#options-debugging&quot;&gt;Debugging the compiler&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;debugging#options-debugging&quot;&gt;调试编译器中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="c0cecd44911066c36d923fdbe5a19b53168e3dcf" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;extending_ghc#compiler-plugins&quot;&gt;Compiler Plugins&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;extending_ghc#compiler-plugins&quot;&gt;编译器插件中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="17420796ed603dd509d02e3a8d1da517181cd7d5" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;ghci#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ghci#ghci-dot-files&quot;&gt;.ghci和.haskeline文件&lt;/a&gt;中的更多详细信息</target>
        </trans-unit>
        <trans-unit id="37e9d2c958040b445e2912cfe73b6aa30dc6a6e6" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;packages#packages&quot;&gt;套餐中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="baf1294ef868c2abc05ce0421bd9b43c7f792cad" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#c-pre-processor&quot;&gt;影响C预处理器的选项中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="51d1ab0e22b2ab0d231fb2c5972d2be780b12e73" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#forcing-options-through&quot;&gt;Forcing options to a particular phase&lt;/a&gt;</source>
          <target state="translated">将&lt;a href=&quot;phases#forcing-options-through&quot;&gt;选项强制到特定阶段中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="7983553fdee60c62d0851647dd220831bd52e4c8" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#options-codegen&quot;&gt;影响代码生成的选项中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="a16863701609094692f0c3f835ccc3d878e7e100" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="8adac53d0127ee0d97906718b6336057dbda2f90" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;phases#replacing-phases&quot;&gt;Replacing the program for one or more phases&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;phases#replacing-phases&quot;&gt;一个或多个阶段替换程序中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="31663a68122cfc30712ddae060ef7c0c26fb2a9b" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;profiling#hpc&quot;&gt;Observing Code Coverage&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;profiling#hpc&quot;&gt;观察代码覆盖率中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="e2f3306e90d0fd9056b2e721c5d6c4dbfb662ff2" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;profiling#profiling&quot;&gt;分析中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="57bc71d308e6ee5ef978190de473b462803d8a22" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#hi-options&quot;&gt;与接口文件相关的其他选项中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="32f905a10099284e5b8eb48c14cea142a33e05ef" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#keeping-intermediates&quot;&gt;Keeping Intermediate Files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#keeping-intermediates&quot;&gt;保留中间文件中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="01ef1b0434fb54d267252cfe67e63278a877ae6d" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#options-output&quot;&gt;重定向编译输出中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="eac718647e3fed68fe7ca2678bdddded1bfb9bff" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#recomp&quot;&gt;重新编译检查器中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="a74b1204653431c31312edd9978554b178635f3f" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#search-path&quot;&gt;搜索路径中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="9dc4a10a5929dae029a66e7ac4365b025fb671f9" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;separate_compilation#temp-files&quot;&gt;Redirecting temporary files&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;separate_compilation#temp-files&quot;&gt;重定向临时文件中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="0af5bfe303303a371ced3d780b07e43b27e4b3ba" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#modes&quot;&gt;操作模式中的&lt;/a&gt;更多细节</target>
        </trans-unit>
        <trans-unit id="1408534385bbc206247b2d0cacd5fc927e1376cf" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#options-help&quot;&gt;详细选项中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="4561b34d24c52f31aefc4effb398748be0d2b234" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#options-order&quot;&gt;批处理编译器模式下的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="968f4ed399272e126f045721eacf076df218221c" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using#options-platform&quot;&gt;Platform-specific Flags&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using#options-platform&quot;&gt;平台特定标志中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="920c16a3909f0ffbf5534e62118ba2d6b6ff57fd" translate="yes" xml:space="preserve">
          <source>More details in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全性检查中的&lt;/a&gt;更多详细信息</target>
        </trans-unit>
        <trans-unit id="50fd034f800c349a7431cd23c8f6ce2a124f77fa" translate="yes" xml:space="preserve">
          <source>More details:</source>
          <target state="translated">更多详情。</target>
        </trans-unit>
        <trans-unit id="a5c3d993dce9c18048d2dd451f76a4bbd8fe5e29" translate="yes" xml:space="preserve">
          <source>More documentation can be found in the &lt;a href=&quot;https://wiki.haskell.org/Functional_dependencies&quot;&gt;Haskell Wiki&lt;/a&gt;.</source>
          <target state="translated">更多文档可以在&lt;a href=&quot;https://wiki.haskell.org/Functional_dependencies&quot;&gt;Haskell Wiki中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="b6ff0bd29737185cd5b1918e0904197bf24a1392" translate="yes" xml:space="preserve">
          <source>More formally, the desugaring is as follows. We write &lt;code&gt;D[ e | Q]&lt;/code&gt; to mean the desugaring of the monad comprehension &lt;code&gt;[ e | Q]&lt;/code&gt;:</source>
          <target state="translated">更正式地讲，减法如下。我们写 &lt;code&gt;D[ e | Q]&lt;/code&gt; 的意思单子理解的脱糖 &lt;code&gt;[ e | Q]&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2085068fa8f84e11b2c779916cc311b96fc67d3f" translate="yes" xml:space="preserve">
          <source>More generally, dependencies take the form &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt;, where &lt;code&gt;x1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;xn&lt;/code&gt;, and &lt;code&gt;y1&lt;/code&gt;, &amp;hellip;, &lt;code&gt;yn&lt;/code&gt; are type variables with n&amp;gt;0 and m&amp;gt;=0, meaning that the &lt;code&gt;y&lt;/code&gt; parameters are uniquely determined by the &lt;code&gt;x&lt;/code&gt; parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in &lt;code&gt;t -&amp;gt; a b&lt;/code&gt;. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of &lt;code&gt;E&lt;/code&gt; above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don&amp;rsquo;t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include &lt;code&gt;a -&amp;gt; a&lt;/code&gt;, &lt;code&gt;a -&amp;gt; a a&lt;/code&gt;, &lt;code&gt;a -&amp;gt;&lt;/code&gt;, etc. There can also be some redundancy if multiple dependencies are given, as in &lt;code&gt;a-&amp;gt;b&lt;/code&gt;, &lt;code&gt;b-&amp;gt;c&lt;/code&gt;, &lt;code&gt;a-&amp;gt;c&lt;/code&gt;, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</source>
          <target state="translated">更一般地，依赖项采用 &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt; ，其中 &lt;code&gt;x1&lt;/code&gt; ，&amp;hellip;， &lt;code&gt;xn&lt;/code&gt; 和 &lt;code&gt;y1&lt;/code&gt; ，&amp;hellip;， &lt;code&gt;yn&lt;/code&gt; 是类型变量，其中n&amp;gt; 0且m&amp;gt; = 0，这意味着 &lt;code&gt;y&lt;/code&gt; 参数由 &lt;code&gt;x&lt;/code&gt; 参数唯一确定。如果在依赖项的任何一侧出现多个变量，则可以将空格用作分隔符，例如 &lt;code&gt;t -&amp;gt; a b&lt;/code&gt; 。请注意，如 &lt;code&gt;E&lt;/code&gt; 的定义所示，可以使用逗号作为分隔符来给类添加多个依赖项。以上。我们可以用这种表示法编写的某些依赖项是多余的，由于它们没有任何作用，因此将被拒绝，它们可能表示程序中有错误。像这样的依赖关系的例子包括 &lt;code&gt;a -&amp;gt; a&lt;/code&gt; ， &lt;code&gt;a -&amp;gt; a a&lt;/code&gt; ， &lt;code&gt;a -&amp;gt;&lt;/code&gt; 等也可以有一定的冗余度，如果多个依赖给出，如在 &lt;code&gt;a-&amp;gt;b&lt;/code&gt; ， &lt;code&gt;b-&amp;gt;c&lt;/code&gt; ， &lt;code&gt;a-&amp;gt;c&lt;/code&gt; ，其中某些子集暗含了剩余的依赖项。此类示例不会被视为错误。请注意，依赖项仅出现在类声明中，而不出现在语言的任何其他部分。特别是，实例声明，类约束和类型的语法完全不变。</target>
        </trans-unit>
        <trans-unit id="2ce620eb436f6437f620c767d1f4df6c98830db2" translate="yes" xml:space="preserve">
          <source>More generally, dependencies take the form &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt;, where &lt;code&gt;x1&lt;/code&gt;, ..., &lt;code&gt;xn&lt;/code&gt;, and &lt;code&gt;y1&lt;/code&gt;, ..., &lt;code&gt;yn&lt;/code&gt; are type variables with n&amp;gt;0 and m&amp;gt;=0, meaning that the &lt;code&gt;y&lt;/code&gt; parameters are uniquely determined by the &lt;code&gt;x&lt;/code&gt; parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in &lt;code&gt;t -&amp;gt; a b&lt;/code&gt;. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of &lt;code&gt;E&lt;/code&gt; above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don&amp;rsquo;t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include &lt;code&gt;a -&amp;gt; a&lt;/code&gt;, &lt;code&gt;a -&amp;gt; a a&lt;/code&gt;, &lt;code&gt;a -&amp;gt;&lt;/code&gt;, etc. There can also be some redundancy if multiple dependencies are given, as in &lt;code&gt;a-&amp;gt;b&lt;/code&gt;, &lt;code&gt;b-&amp;gt;c&lt;/code&gt;, &lt;code&gt;a-&amp;gt;c&lt;/code&gt;, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</source>
          <target state="translated">更一般而言，依存关系采用 &lt;code&gt;x1 ... xn -&amp;gt; y1 ... ym&lt;/code&gt; ，其中 &lt;code&gt;x1&lt;/code&gt; ，...， &lt;code&gt;xn&lt;/code&gt; 和 &lt;code&gt;y1&lt;/code&gt; ，...， &lt;code&gt;yn&lt;/code&gt; 是n&amp;gt; 0和m&amp;gt; = 0的类型变量，表示 &lt;code&gt;y&lt;/code&gt; 参数由 &lt;code&gt;x&lt;/code&gt; 参数唯一确定。如果在依赖项的任何一侧出现多个变量，则可以将空格用作分隔符，例如 &lt;code&gt;t -&amp;gt; a b&lt;/code&gt; 。请注意，如 &lt;code&gt;E&lt;/code&gt; 的定义所示，可以使用逗号作为分隔符来为类添加多个依赖项。以上。我们可以用这种表示法编写的某些依赖项是多余的，由于它们没有任何作用，因此将被拒绝，而可能表示程序中有错误。像这样的依赖关系的例子包括 &lt;code&gt;a -&amp;gt; a&lt;/code&gt; ， &lt;code&gt;a -&amp;gt; a a&lt;/code&gt; ， &lt;code&gt;a -&amp;gt;&lt;/code&gt; 等也可以有一定的冗余度，如果多个依赖给出，如在 &lt;code&gt;a-&amp;gt;b&lt;/code&gt; ， &lt;code&gt;b-&amp;gt;c&lt;/code&gt; ， &lt;code&gt;a-&amp;gt;c&lt;/code&gt; ，其中某些子集暗含了剩余的依赖项。此类示例不会被视为错误。请注意，依赖项仅出现在类声明中，而不出现在语言的任何其他部分。特别是，实例声明，类约束和类型的语法完全不变。</target>
        </trans-unit>
        <trans-unit id="174c1aad58978f69590dd72b60851d08b234e600" translate="yes" xml:space="preserve">
          <source>More in-depth information can be found on the &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Roles&quot;&gt;Roles wiki page&lt;/a&gt;</source>
          <target state="translated">可以在&amp;ldquo; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Roles&quot;&gt;角色&amp;rdquo;维基页面&lt;/a&gt;上找到更深入的信息。</target>
        </trans-unit>
        <trans-unit id="f30bdf45636fdc98dcf55a5628219c150e7f67cd" translate="yes" xml:space="preserve">
          <source>More in-depth information can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/roles&quot;&gt;Roles wiki page&lt;/a&gt;</source>
          <target state="translated">可以在&amp;ldquo;&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/roles&quot;&gt;角色&amp;rdquo; Wiki页面&lt;/a&gt;上找到更深入的信息。</target>
        </trans-unit>
        <trans-unit id="e14ab6cf4fdb8d4413797b405b5b9102d3c1bc86" translate="yes" xml:space="preserve">
          <source>More information is given for explicit holes (i.e. ones that start with an underscore), than for out-of-scope variables, because the latter are often unintended typos, so the extra information is distracting. If you want the detailed information, use a leading underscore to make explicit your intent to use a hole.</source>
          <target state="translated">明确的洞(即以下划线开头的洞)比范围外的变量提供更多的信息,因为后者通常是无意的错别字,所以额外的信息会让人分心。如果你想要详细的信息,请使用前导下划线来明确你使用漏洞的意图。</target>
        </trans-unit>
        <trans-unit id="cdb9413519e4acd2573608f8f06f43a109139ea4" translate="yes" xml:space="preserve">
          <source>More precisely, the scoping rules are:</source>
          <target state="translated">更确切地说,范围规则是:</target>
        </trans-unit>
        <trans-unit id="1f08e1cae5fd42d45181559f708b9f948ac50f46" translate="yes" xml:space="preserve">
          <source>More precisely, the semantics of pattern matching is given in &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17&quot;&gt;Section 3.17 of the Haskell 2010 report&lt;/a&gt;. To the informal semantics in Section 3.17.2 we add this extra rule:</source>
          <target state="translated">更精确地，模式匹配的语义&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17&quot;&gt;在Haskell 2010报告的3.17节中&lt;/a&gt;给出。在第3.17.2节的非正式语义中，我们添加了以下额外规则：</target>
        </trans-unit>
        <trans-unit id="e4c589fb3b275a240038aa72aafa4cfbf0c4831b" translate="yes" xml:space="preserve">
          <source>More precisely, warn if a binding brings into scope a variable that is not used, except if the variable&amp;rsquo;s name starts with an underscore. The &amp;ldquo;starts-with-underscore&amp;rdquo; condition provides a way to selectively disable the warning.</source>
          <target state="translated">更准确地说，如果绑定将未使用的变量引入范围，则发出警告，除非该变量的名称以下划线开头。&amp;ldquo;下划线启动&amp;rdquo;条件提供了一种有选择地禁用警告的方法。</target>
        </trans-unit>
        <trans-unit id="4e142cf9dbc576682f7db5f9767bc39f19e16ad2" translate="yes" xml:space="preserve">
          <source>More sophisticated combinators for expressing parallelism are available from the &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; module in the &lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;parallel package&lt;/a&gt;. This module builds functionality around &lt;code&gt;par&lt;/code&gt;, expressing more elaborate patterns of parallel computation, such as parallel &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://hackage.haskell.org/package/parallel&quot;&gt;并行包中&lt;/a&gt;的 &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; 模块提供了用于表达并行性的更复杂的组合器。该模块围绕 &lt;code&gt;par&lt;/code&gt; 构建功能，表示更复杂的并行计算模式，例如parallel &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ed6b588d942e43b985dc1ef91eaa6acb3407601" translate="yes" xml:space="preserve">
          <source>More sophisticated combinators for expressing parallelism are available from the &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; module in the &lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;parallel package&lt;/a&gt;. This module builds functionality around &lt;code&gt;par&lt;/code&gt;, expressing more elaborate patterns of parallel computation, such as parallel &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hackage.haskell.org/package/parallel&quot;&gt;并行包中&lt;/a&gt;的 &lt;code&gt;Control.Parallel.Strategies&lt;/code&gt; 模块提供了用于表达并行性的更复杂的组合器。该模块围绕 &lt;code&gt;par&lt;/code&gt; 构建功能，表示更复杂的并行计算模式，例如parallel &lt;code&gt;map&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7efbe8954f7d8bb33318735e14097d00de7a9a64" translate="yes" xml:space="preserve">
          <source>More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls.</source>
          <target state="translated">更具体地说,这些字节字符串被认为是在0-255码点所覆盖的Unicode子集中。这包括Unicode基本拉丁文、拉丁文-1补充和C0+C1控制。</target>
        </trans-unit>
        <trans-unit id="86749f35327922682f80058567d622a5b5a74e48" translate="yes" xml:space="preserve">
          <source>More specifically, consider the following modules:</source>
          <target state="translated">具体来说,考虑以下模块。</target>
        </trans-unit>
        <trans-unit id="49ae26a58091afd7797c7d608cef98d9b3bd88ed" translate="yes" xml:space="preserve">
          <source>More substantially, an anonymous records library could provide &lt;code&gt;HasField&lt;/code&gt; instances for its anonymous records, and thus be compatible with the polymorphic record selectors introduced by this proposal. For example, something like this makes it possible to use &lt;code&gt;getField&lt;/code&gt; to access &lt;code&gt;Record&lt;/code&gt; values with the appropriate string in the type-level list of fields:</source>
          <target state="translated">更重要的是，匿名记录库可以为其匿名记录提供 &lt;code&gt;HasField&lt;/code&gt; 实例，从而与该提案引入的多态记录选择器兼容。例如，类似这样的东西使得可以使用 &lt;code&gt;getField&lt;/code&gt; 在类型级别的字段列表中使用适当的字符串访问 &lt;code&gt;Record&lt;/code&gt; 值：</target>
        </trans-unit>
        <trans-unit id="005be1b0ad130c7c10cd96e65aa29871ac012aff" translate="yes" xml:space="preserve">
          <source>Moreover genuinely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (#10318)</source>
          <target state="translated">而且，真正递归的超类有时很有用。这是一个真实的示例（＃10318）</target>
        </trans-unit>
        <trans-unit id="48fbf1fc9f3d27864af0185af07555a2ed71738b" translate="yes" xml:space="preserve">
          <source>Moreover genuninely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (#10318)</source>
          <target state="translated">此外，纯递归超类有时很有用。这是一个真实的示例（＃10318）</target>
        </trans-unit>
        <trans-unit id="aee6d8add66d57251c294e797e38ba98f856c59e" translate="yes" xml:space="preserve">
          <source>Moreover genuninely-recursive superclasses are sometimes useful. Here&amp;rsquo;s a real-life example (Trac #10318)</source>
          <target state="translated">此外，纯递归超类有时很有用。这是一个真实的示例（跟踪＃10318）</target>
        </trans-unit>
        <trans-unit id="9daae4c546da3c409b18a41ad5d587143e25c7b1" translate="yes" xml:space="preserve">
          <source>Moreover you often don&amp;rsquo;t even need the &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in the first place. When compiling a module &lt;code&gt;M&lt;/code&gt;, GHC&amp;rsquo;s optimiser (when given the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag) automatically considers each top-level overloaded function declared in &lt;code&gt;M&lt;/code&gt;, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. The optimiser &lt;em&gt;also&lt;/em&gt; considers each &lt;em&gt;imported&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; overloaded function, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. So in our example, it would be enough for &lt;code&gt;lookup&lt;/code&gt; to be called at type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">而且，您通常甚至根本不需要&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;编译指示。编译模块 &lt;code&gt;M&lt;/code&gt; 时，GHC的优化器（在给&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;标志时）会自动考虑 &lt;code&gt;M&lt;/code&gt; 中声明的每个顶级重载函数，并将其专门化为 &lt;code&gt;M&lt;/code&gt; 中调用它的不同类型。优化器&lt;em&gt;还&lt;/em&gt;考虑每个&lt;em&gt;导入的&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;重载函数，并将其专用于 &lt;code&gt;M&lt;/code&gt; 中调用它的不同类型。因此，在我们的示例中，在类型 &lt;code&gt;T&lt;/code&gt; 处调用 &lt;code&gt;lookup&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="2b9d1405f104daf49ed40d4d63a24458c96232a6" translate="yes" xml:space="preserve">
          <source>Moreover you often don&amp;rsquo;t even need the &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in the first place. When compiling a module &lt;code&gt;M&lt;/code&gt;, GHC&amp;rsquo;s optimiser (when given the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag) automatically considers each top-level overloaded function declared in &lt;code&gt;M&lt;/code&gt;, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. The optimiser &lt;em&gt;also&lt;/em&gt; considers each &lt;em&gt;imported&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; overloaded function, and specialises it for the different types at which it is called in &lt;code&gt;M&lt;/code&gt;. So in our example, it would be enough for &lt;code&gt;lookup&lt;/code&gt; to be called at type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">而且，您通常甚至根本不需要&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;编译指示。编译模块 &lt;code&gt;M&lt;/code&gt; 时，GHC的优化器（当给&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;标志时）会自动考虑 &lt;code&gt;M&lt;/code&gt; 中声明的每个顶级重载函数，并将其专门化为 &lt;code&gt;M&lt;/code&gt; 中被调用的不同类型。优化器&lt;em&gt;还&lt;/em&gt;考虑每个&lt;em&gt;导入的&lt;/em&gt;&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;重载函数，并将其专用于 &lt;code&gt;M&lt;/code&gt; 中调用它的不同类型。因此，在我们的示例中，在类型 &lt;code&gt;T&lt;/code&gt; 处调用 &lt;code&gt;lookup&lt;/code&gt; 就足够了：</target>
        </trans-unit>
        <trans-unit id="1b09c524376f62eb132cfc4d87068c7c414ce987" translate="yes" xml:space="preserve">
          <source>Moreover, GHC will only inline the function if it is &lt;em&gt;fully applied&lt;/em&gt;, where &amp;ldquo;fully applied&amp;rdquo; means applied to as many arguments as appear (syntactically) on the LHS of the function definition. For example:</source>
          <target state="translated">此外，GHC仅在&lt;em&gt;完全应用&lt;/em&gt;时才内联该函数，其中&amp;ldquo;完全应用&amp;rdquo;是指应用于（在语法上）出现在函数定义的LHS上的尽可能多的参数。例如：</target>
        </trans-unit>
        <trans-unit id="6284ba052c710bcfe1b333b0499c004a62fd7cbd" translate="yes" xml:space="preserve">
          <source>Moreover, a local fixity declaration &lt;em&gt;must&lt;/em&gt; accompany a local binding of that name: it is not possible to revise the fixity of name bound elsewhere, as in</source>
          <target state="translated">此外，本地固定性声明&lt;em&gt;必须&lt;/em&gt;伴随该名称的本地绑定：无法修改其他地方绑定的名称的固定性，例如</target>
        </trans-unit>
        <trans-unit id="435226f4fb8d01545e71ad9e8e0b16ea37149391" translate="yes" xml:space="preserve">
          <source>Moreover, every module that imports &lt;code&gt;Client&lt;/code&gt; (or imports a module that imports &lt;code&gt;Client&lt;/code&gt;, transitively) will &amp;ldquo;see&amp;rdquo;, and make use of, the specialised version of &lt;code&gt;lookup&lt;/code&gt;. You don&amp;rsquo;t need to put a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma in every module.</source>
          <target state="translated">此外，每个导入 &lt;code&gt;Client&lt;/code&gt; 的模块（或导入一个可过渡地导入 &lt;code&gt;Client&lt;/code&gt; 的模块）都将&amp;ldquo;查看&amp;rdquo;并使用 &lt;code&gt;lookup&lt;/code&gt; 的专用版本。您无需在每个模块中都放置一个&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="641bceca79503a5b46c154c94304a197aa140c0b" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;Applicative&lt;/code&gt; instance declarations:</source>
          <target state="translated">此外，在 &lt;code&gt;Applicative&lt;/code&gt; 实例声明中：</target>
        </trans-unit>
        <trans-unit id="97508f66cdde54922c388601bbdb4ef006e66daf" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;MonadFail&lt;/code&gt; instance declarations:</source>
          <target state="translated">此外，在 &lt;code&gt;MonadFail&lt;/code&gt; 实例声明中：</target>
        </trans-unit>
        <trans-unit id="667b008ae7d33f2434031b95fad3289972f0f759" translate="yes" xml:space="preserve">
          <source>Moreover, in &lt;code&gt;Semigroup&lt;/code&gt; instance declarations:</source>
          <target state="translated">此外，在 &lt;code&gt;Semigroup&lt;/code&gt; 实例声明中：</target>
        </trans-unit>
        <trans-unit id="9b463d35e3037a7b25fba6436d573b43c738063f" translate="yes" xml:space="preserve">
          <source>Moreover, we can ask &lt;code&gt;gdb&lt;/code&gt; to tell us the flow of execution that lead us to this point in the program,</source>
          <target state="translated">此外，我们可以要求 &lt;code&gt;gdb&lt;/code&gt; 告诉我们执行流程，从而引导我们到达程序的这一点，</target>
        </trans-unit>
        <trans-unit id="8feac72447d42dc6b03b07306f6ad6196a53f4dd" translate="yes" xml:space="preserve">
          <source>Most GHC users will not need to worry about levity polymorphism or unboxed types. For these users, seeing the levity polymorphism in the type of &lt;code&gt;$&lt;/code&gt; is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type &lt;code&gt;RuntimeRep&lt;/code&gt; to be &lt;code&gt;'LiftedRep&lt;/code&gt; when printing, and printing &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; as &lt;code&gt;Type&lt;/code&gt; (or &lt;code&gt;*&lt;/code&gt; when &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">大多数GHC用户无需担心levity多态性或未装箱的类型。对于这些用户，看到 &lt;code&gt;$&lt;/code&gt; 类型的levity多态性是无济于事的。因此，默认情况下，它被抑制，通过假设类型的所有类型变量 &lt;code&gt;RuntimeRep&lt;/code&gt; 是 &lt;code&gt;'LiftedRep&lt;/code&gt; 打印时，以及打印 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 作为 &lt;code&gt;Type&lt;/code&gt; （或 &lt;code&gt;*&lt;/code&gt; 当&lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;是上）。</target>
        </trans-unit>
        <trans-unit id="17b1a5f71734de963b1a50b74875ef3731d2a5ac" translate="yes" xml:space="preserve">
          <source>Most GHC users will not need to worry about levity polymorphism or unboxed types. For these users, seeing the levity polymorphism in the type of &lt;code&gt;$&lt;/code&gt; is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type &lt;code&gt;RuntimeRep&lt;/code&gt; to be &lt;code&gt;'LiftedRep&lt;/code&gt; when printing, and printing &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; as &lt;code&gt;Type&lt;/code&gt; (or &lt;code&gt;*&lt;/code&gt; when &lt;a href=&quot;poly_kinds#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; is on).</source>
          <target state="translated">大多数GHC用户将无需担心levity多态性或未装箱的类型。对于这些用户，查看 &lt;code&gt;$&lt;/code&gt; 类型的levity多态性是无济于事的。因此，默认情况下，它被抑制，通过假设类型的所有类型变量 &lt;code&gt;RuntimeRep&lt;/code&gt; 是 &lt;code&gt;'LiftedRep&lt;/code&gt; 打印时，以及打印 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 作为 &lt;code&gt;Type&lt;/code&gt; （或 &lt;code&gt;*&lt;/code&gt; 当&lt;a href=&quot;poly_kinds#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;是上）。</target>
        </trans-unit>
        <trans-unit id="a9bfd07736bd17bc98ea30aef5ff00a2993638a7" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">大多数手柄还将具有当前的I / O位置，指示下一个输入或输出操作将在哪里发生。如果句柄仅管理输入或同时管理输入和输出，则它是&lt;em&gt;可读的&lt;/em&gt;。同样，如果仅管理输出或同时管理输入和输出，则可&lt;em&gt;写&lt;/em&gt;。第一次分配时，句柄是&lt;em&gt;打开的&lt;/em&gt;。一旦关闭它，就不能再将其用作输入或输出，尽管在保留引用的情况下实现无法重用其存储。句柄在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类中。通过显示句柄产生的字符串取决于系统；它应包含足够的信息以标识调试的句柄。根据 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 句柄相等只对自己没有尝试比较不同句柄的内部状态是否相等。</target>
        </trans-unit>
        <trans-unit id="56a261d402c64f03bfdfa4dbbe6dc5df89e9511b" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">大多数手柄还将具有当前的I / O位置，指示下一个输入或输出操作将在何处发生。如果句柄仅管理输入或同时管理输入和输出，则它是&lt;em&gt;可读的&lt;/em&gt;。同样，如果仅管理输出或同时管理输入和输出，则可&lt;em&gt;写&lt;/em&gt;。第一次分配时，句柄是&lt;em&gt;打开的&lt;/em&gt;。一旦关闭它，就不能再将其用于输入或输出，尽管在保留引用的情况下实现无法重用其存储。句柄在 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类中。通过显示一个句柄产生的字符串是系统相关的。它应包含足够的信息以标识调试的句柄。句柄根据 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 等于只对自己没有尝试比较不同句柄的内部状态是否相等。</target>
        </trans-unit>
        <trans-unit id="26dd0443f8df18358fdb53a2bfd90e3b2ecb015a" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">大多数手柄还将具有当前的I / O位置，指示下一个输入或输出操作将在何处发生。如果句柄仅管理输入或同时管理输入和输出，则它是&lt;em&gt;可读的&lt;/em&gt;。同样，如果仅管理输出或同时管理输入和输出，则可&lt;em&gt;写&lt;/em&gt;。第一次分配时，句柄是&lt;em&gt;打开的&lt;/em&gt;。一旦关闭它，就不能再将其用于输入或输出，尽管在保留引用的情况下实现无法重用其存储。句柄在 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类中。通过显示一个句柄产生的字符串是系统相关的。它应包含足够的信息以标识调试的句柄。句柄根据 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 等于只对自己没有尝试比较不同句柄的内部状态是否相等。</target>
        </trans-unit>
        <trans-unit id="d2995cc8024bf7aa8ba13dcae171563836b90420" translate="yes" xml:space="preserve">
          <source>Most handles will also have a current I/O position indicating where the next input or output operation will occur. A handle is &lt;em&gt;readable&lt;/em&gt; if it manages only input or both input and output; likewise, it is &lt;em&gt;writable&lt;/em&gt; if it manages only output or both input and output. A handle is &lt;em&gt;open&lt;/em&gt; when first allocated. Once it is closed it can no longer be used for either input or output, though an implementation cannot re-use its storage while references remain to it. Handles are in the &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes. The string produced by showing a handle is system dependent; it should include enough information to identify the handle for debugging. A handle is equal according to &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; only to itself; no attempt is made to compare the internal state of different handles for equality.</source>
          <target state="translated">大多数手柄还将具有当前的I / O位置，指示下一个输入或输出操作将在哪里发生。如果句柄仅管理输入或同时管理输入和输出，则它是&lt;em&gt;可读的&lt;/em&gt;。同样，如果仅管理输出或同时管理输入和输出，则可&lt;em&gt;写&lt;/em&gt;。第一次分配时，句柄是&lt;em&gt;打开的&lt;/em&gt;。一旦关闭它，就不能再将其用作输入或输出，尽管在保留引用的情况下实现无法重用其存储。句柄在 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类中。通过显示句柄产生的字符串取决于系统；它应包含足够的信息以标识调试的句柄。根据 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 句柄相等只对自己没有尝试比较不同句柄的内部状态是否相等。</target>
        </trans-unit>
        <trans-unit id="9be69b82ce264090f2137a15a7648633cb206f8e" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">大多数monad转换器模块包括将转换器应用于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的特殊情况。例如， &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 是一个缩写 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0c60abd2cf0ff60dc7be795cfcb03f696cc8115" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">大多数monad变压器模块都包含将变压器应用于 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的特殊情况。例如， &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 是一个缩写 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f05ad7826cba7566bcebc4116870e810986741e" translate="yes" xml:space="preserve">
          <source>Most monad transformer modules include the special case of applying the transformer to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; is an abbreviation for &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">大多数monad变压器模块都包含将变压器应用于 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 的特殊情况。例如， &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:State&quot;&gt;State&lt;/a&gt; s&lt;/code&gt; 是一个缩写 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt; s &lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1446d57bbc11269458b5fff18c4a2fbea47e1423" translate="yes" xml:space="preserve">
          <source>Most of the command-line options accepted by GHC (see &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;) also make sense in interactive mode. The ones that don&amp;rsquo;t make sense are mostly obvious.</source>
          <target state="translated">GHC接受的大多数命令行选项（请参阅&lt;a href=&quot;using#using-ghc&quot;&gt;使用GHC&lt;/a&gt;）在交互模式下也是有意义的。那些毫无意义的通常是显而易见的。</target>
        </trans-unit>
        <trans-unit id="d49b83194eaa0ec88c028d8df0d8eb5797ada48a" translate="yes" xml:space="preserve">
          <source>Most of the conventions GHC expects when using packages are described in &lt;a href=&quot;packages#building-packages&quot;&gt;Building a package from Haskell source&lt;/a&gt;. In addition note that GHC expects the &lt;code&gt;.hi&lt;/code&gt; files to use the extension &lt;code&gt;.dyn_hi&lt;/code&gt;. The other requirements are the same as for C libraries and are described below, in particular the use of the flags &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC在使用软件包时期望的大多数约定在&amp;ldquo; &lt;a href=&quot;packages#building-packages&quot;&gt;从Haskell源码构建&lt;/a&gt;软件包&amp;rdquo;中进行了介绍。另外请注意，GHC希望 &lt;code&gt;.hi&lt;/code&gt; 文件使用扩展名 &lt;code&gt;.dyn_hi&lt;/code&gt; 。其他要求与C库的要求相同，并在下面进行描述，尤其是标志&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; 的使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c17ee9cdb3b8c7cbc538d3e35bb5401d0f3d8af1" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module are subject to &lt;em&gt;fusion&lt;/em&gt;, meaning that a pipeline of such functions will usually allocate at most one &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">此模块中的大多数功能都需要进行&lt;em&gt;融合&lt;/em&gt;，这意味着此类功能的管道通常将最多分配一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="cff6fb1dc40bd9bd236bb1c241939a66f53cfba3" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module are subject to &lt;em&gt;fusion&lt;/em&gt;, meaning that a pipeline of such functions will usually allocate at most one &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">此模块中的大多数功能都需要进行&lt;em&gt;融合&lt;/em&gt;，这意味着此类功能的管道通常将最多分配一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="3b644a39e26dfc78bdc3acb69da17cabd5dd58c1" translate="yes" xml:space="preserve">
          <source>Most of the performance gain stems from using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt;, which encodes a list of values from left-to-right with a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;. It exploits the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; internals to avoid unnecessary function compositions (i.e., concatenations). In the future, we might expect the compiler to perform the optimizations implemented in &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt;. However, it seems that the code is currently to complicated for the compiler to see through. Therefore, we provide the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; escape hatch, which allows data structures to provide very efficient encoding traversals, like &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; for lists.</source>
          <target state="translated">大部分的性能增益源于使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; ，其中从左向右与编码值的列表 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。它利用了 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 内部，以避免不必要的功能组合（即，串联）。将来，我们可能希望编译器执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; 中实现的优化。但是，对于编译器来说，目前看来代码很复杂。因此，我们提供了 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 转义阴影，它允许数据结构提供非常有效的编码遍历，例如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapListBounded&quot;&gt;primMapListBounded&lt;/a&gt;&lt;/code&gt; 用于列表。</target>
        </trans-unit>
        <trans-unit id="93a85b72f189888c0727de2215a65f643a090a37" translate="yes" xml:space="preserve">
          <source>Most of these options are boolean and have options to turn them both &amp;ldquo;on&amp;rdquo; and &amp;ldquo;off&amp;rdquo; (beginning with the prefix &lt;code&gt;no-&lt;/code&gt;). For instance, while &lt;code&gt;-fspecialise&lt;/code&gt; enables specialisation, &lt;code&gt;-fno-specialise&lt;/code&gt; disables it. When multiple flags for the same option appear in the command-line they are evaluated from left to right. For instance, &lt;code&gt;-fno-specialise -fspecialise&lt;/code&gt; will enable specialisation.</source>
          <target state="translated">这些选项中的大多数都是布尔值，并且具有将其&amp;ldquo;打开&amp;rdquo;和&amp;ldquo;关闭&amp;rdquo;（以前缀 &lt;code&gt;no-&lt;/code&gt; 开头）的选项。例如，虽然 &lt;code&gt;-fspecialise&lt;/code&gt; 启用专用化，但是 &lt;code&gt;-fno-specialise&lt;/code&gt; 禁用专用化。当同一选项的多个标志出现在命令行中时，它们将从左到右进行评估。例如， &lt;code&gt;-fno-specialise -fspecialise&lt;/code&gt; 将启用专业化。</target>
        </trans-unit>
        <trans-unit id="b4872c5b9a708f91ab972a558b461f19d44ba677" translate="yes" xml:space="preserve">
          <source>Most packages (see &lt;a href=&quot;packages#using-packages&quot;&gt;Using Packages&lt;/a&gt;) are available without needing to specify any extra flags at all: they will be automatically loaded the first time they are needed.</source>
          <target state="translated">大多数软件包（请参阅&lt;a href=&quot;packages#using-packages&quot;&gt;使用软件包&lt;/a&gt;）都可以使用，而无需完全指定任何额外的标志：它们将在第一次需要它们时自动加载。</target>
        </trans-unit>
        <trans-unit id="f17588b3f000b1c04f72f8264ac2012d913333ca" translate="yes" xml:space="preserve">
          <source>Most profiling runtime options are only available when you compile your program for profiling (see &lt;a href=&quot;profiling#prof-compiler-options&quot;&gt;Compiler options for profiling&lt;/a&gt;, and &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for the runtime options). However, there is one profiling option that is available for ordinary non-profiled executables:</source>
          <target state="translated">大多数概要分析运行时选项仅在编译程序进行概要分析时才可用（有关运行时选项，请参见&lt;a href=&quot;profiling#prof-compiler-options&quot;&gt;用于概要分析的编译器选项&lt;/a&gt;和&lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;用于堆概要分析的RTS&lt;/a&gt;选项）。但是，有一个配置文件选项可用于普通的非概要文件可执行文件：</target>
        </trans-unit>
        <trans-unit id="7dd31ae39f49dd0f0c21b3aa4545a982531a6c6b" translate="yes" xml:space="preserve">
          <source>Most programs should not worry about the canonicity of a path. In particular, despite the name, the function does not truly guarantee canonicity of the returned path due to the presence of hard links, mount points, etc.</source>
          <target state="translated">大多数程序不应该担心路径的正则性。特别是,尽管名字很好听,但由于存在硬链接、挂载点等,该函数并不能真正保证返回路径的规范性。</target>
        </trans-unit>
        <trans-unit id="f735bd28bb08e83da41ac3d34e730c92c26193d9" translate="yes" xml:space="preserve">
          <source>Most specific instance, &lt;code&gt;Ix&lt;/code&gt;, defined in an &lt;code&gt;-XSafe&lt;/code&gt; compiled module.</source>
          <target state="translated">在 &lt;code&gt;-XSafe&lt;/code&gt; 编译模块中定义的最特定的实例 &lt;code&gt;Ix&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16ea8e72c52685784f78037d3d05d2240b22d1c7" translate="yes" xml:space="preserve">
          <source>Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object. The representation of a Haskell &lt;code&gt;Int&lt;/code&gt;, for example, is a two-word heap object. An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved.</source>
          <target state="translated">GHC中的大多数类型都用方框框起来，这意味着该类型的值由指向堆对象的指针表示。例如，Haskell &lt;code&gt;Int&lt;/code&gt; 的表示形式是一个两个单词的堆对象。但是，未装箱的类型由值本身表示，不涉及指针或堆分配。</target>
        </trans-unit>
        <trans-unit id="26a91b89d1f0afee1a3b838d3e07c9dda8c7019a" translate="yes" xml:space="preserve">
          <source>Most users don&amp;rsquo;t need to worry about the details described in this section. This discussion is primarily targeted at tooling authors who need to interpret the GHC-specific DWARF annotations contained in compiled binaries.</source>
          <target state="translated">大多数用户无需担心本节中描述的细节。本讨论主要针对需要解释编译的二进制文件中包含的特定于GHC的DWARF注释的工具作者。</target>
        </trans-unit>
        <trans-unit id="50978952002c3f3475a398ad4c47f7515dcb5f8c" translate="yes" xml:space="preserve">
          <source>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">向前推进历史中的步骤。omittedn如果省略则为1。有关GHCi调试工具的更多信息，请参见&lt;a href=&quot;#tracing&quot;&gt;跟踪和历史记录&lt;/a&gt;。另见&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ba04ac0c40eac8685578c04462bb11965eb4878" translate="yes" xml:space="preserve">
          <source>Move the last two elements from the end of the first list onto the beginning of the second one.</source>
          <target state="translated">将第一个列表末尾的最后两个元素移到第二个列表的开头。</target>
        </trans-unit>
        <trans-unit id="2bb8ee2f3add85c2116c7a3a51024dad403c385b" translate="yes" xml:space="preserve">
          <source>MoveFileFlag</source>
          <target state="translated">MoveFileFlag</target>
        </trans-unit>
        <trans-unit id="5a8dfd20d44353d4ab01bf308e18462987143fb9" translate="yes" xml:space="preserve">
          <source>Moved to their own module to not bloat GHC.Float further.</source>
          <target state="translated">移到自己的模块中,以免GHC.Float进一步膨胀。</target>
        </trans-unit>
        <trans-unit id="14766b11b99f48495ad4c21d250367a73f20edac" translate="yes" xml:space="preserve">
          <source>Msg</source>
          <target state="translated">Msg</target>
        </trans-unit>
        <trans-unit id="d136009ea859ae789c419997ed8d15cac71cf2c5" translate="yes" xml:space="preserve">
          <source>Much like lists can be constructed and matched using the &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; constructors, sequences can be constructed and matched using the &lt;code&gt;&lt;a href=&quot;data-sequence#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v::-60--124-&quot;&gt;:&amp;lt;|&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v::-124--62-&quot;&gt;:|&amp;gt;&lt;/a&gt;&lt;/code&gt; pattern synonyms.</source>
          <target state="translated">可以使用 &lt;code&gt;:&lt;/code&gt; 和 &lt;code&gt;[]&lt;/code&gt; 构造函数构造和匹配很多类似的列表，可以使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v::-60--124-&quot;&gt;:&amp;lt;|&lt;/a&gt;&lt;/code&gt; 构造和匹配序列。和 &lt;code&gt;&lt;a href=&quot;data-sequence#v::-124--62-&quot;&gt;:|&amp;gt;&lt;/a&gt;&lt;/code&gt; 模式同义词。</target>
        </trans-unit>
        <trans-unit id="3985ab0ae942e14710d14c6d2571f7087252a32c" translate="yes" xml:space="preserve">
          <source>Much of &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s interface can be implemented with &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt;. Some of the rest can be implemented with a new &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; function and either &lt;code&gt;&lt;a href=&quot;data-monoid#t:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-monoid#t:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的许多界面都可以使用 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alter&quot;&gt;alter&lt;/a&gt;&lt;/code&gt; 来实现。其余一些可以使用新的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 函数以及 &lt;code&gt;&lt;a href=&quot;data-monoid#t:First&quot;&gt;First&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Last&quot;&gt;Last&lt;/a&gt;&lt;/code&gt; 来实现：</target>
        </trans-unit>
        <trans-unit id="ae55e00af65836b6d405f596f97e4f57bbe9ffb4" translate="yes" xml:space="preserve">
          <source>MulArrowT</source>
          <target state="translated">MulArrowT</target>
        </trans-unit>
        <trans-unit id="5cc6d803a39452a5550042d0878f9a4d2b3338ea" translate="yes" xml:space="preserve">
          <source>Multi-parameter type classes are permitted, with extension &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">允许使用多参数类型类，扩展名为&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="791ab6cd505e26e3db8530867157bb7dff3226cc" translate="yes" xml:space="preserve">
          <source>Multi-signal a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">多信号 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb0ebb79c7eefbdf0b5b3cf945169c1e60647b5a" translate="yes" xml:space="preserve">
          <source>Multi-way Trees and Forests</source>
          <target state="translated">多向树和森林</target>
        </trans-unit>
        <trans-unit id="639132eb39afa461a8de30e021cb71678c2bd9f6" translate="yes" xml:space="preserve">
          <source>Multi-way if expressions introduce a new layout context. So the example above is equivalent to:</source>
          <target state="translated">多向if表达式引入了一个新的布局上下文。所以上面的例子相当于。</target>
        </trans-unit>
        <trans-unit id="9be2f47cbdcfe4a4ba58091a84da2eccde0463fc" translate="yes" xml:space="preserve">
          <source>MultiParamTypeClasses</source>
          <target state="translated">MultiParamTypeClasses</target>
        </trans-unit>
        <trans-unit id="16bfc155ed662e5fdfa3b7a44cb917e2896838df" translate="yes" xml:space="preserve">
          <source>MultiShot</source>
          <target state="translated">MultiShot</target>
        </trans-unit>
        <trans-unit id="7081cd2ce6a6f92ebb8e5d3af341d3d4335873da" translate="yes" xml:space="preserve">
          <source>MultiWayIf</source>
          <target state="translated">MultiWayIf</target>
        </trans-unit>
        <trans-unit id="0393d78dbbfc9e70fdf48e5344e361858dbe507c" translate="yes" xml:space="preserve">
          <source>Multiline mode is useful when entering monadic &lt;code&gt;do&lt;/code&gt; statements:</source>
          <target state="translated">在输入monadic &lt;code&gt;do&lt;/code&gt; 语句时，多行模式非常有用：</target>
        </trans-unit>
        <trans-unit id="2e295ccb8d7c53c8f3ea7ba9cfb2f93b20c6dd1d" translate="yes" xml:space="preserve">
          <source>Multiplication of type-level naturals.</source>
          <target state="translated">类型级本体的乘法。</target>
        </trans-unit>
        <trans-unit id="c3daf9662fef96010a16df2f6f60f2f626bb4ea3" translate="yes" xml:space="preserve">
          <source>Multiplicity polymorphism is incomplete and experimental. You may have success using it, or you may not. Expect it to be really unreliable.</source>
          <target state="translated">多重性多态性是不完整的,是实验性的。你可能使用它成功,也可能不成功。期待它真的不可靠。</target>
        </trans-unit>
        <trans-unit id="abaf136782049164460366f9afe2dee04f6b2e91" translate="yes" xml:space="preserve">
          <source>Multiply two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">乘两个 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="909b32ffe66a26d38ff55c0ae1de2d5a81a56aaf" translate="yes" xml:space="preserve">
          <source>Multiply two vectors element-wise.</source>
          <target state="translated">将两个向量元素相乘。</target>
        </trans-unit>
        <trans-unit id="05a69b1ec67732f09635ef86734c3b1a99517a9c" translate="yes" xml:space="preserve">
          <source>Multiply-defined array elements not checked</source>
          <target state="translated">不检查乘法定义的数组元素</target>
        </trans-unit>
        <trans-unit id="5848ccab6e8123c4df2d4c1561fe81cd64b56b8f" translate="yes" xml:space="preserve">
          <source>MutVar#</source>
          <target state="translated">MutVar#</target>
        </trans-unit>
        <trans-unit id="52b9d6898e795eda124f4c552cab7ce01664480c" translate="yes" xml:space="preserve">
          <source>Mutable array type, for use in the ST monad.</source>
          <target state="translated">可变数组类型,用于ST单体。</target>
        </trans-unit>
        <trans-unit id="215e56b349d3105e5186b842d419bb7207c023b0" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad 中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="515636c71d60349203d8732bedde03c1e6d4b604" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad 中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="2c7c15d19968866fe48793de76acdf671dc080e3" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="31247b9a8722b87ffd65d7883ea3909ce04233ac" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="8f85576fded6d39e38070c85bed31a7dca70f0a1" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st#v:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="619a054c943d7350b1a002ab683879f563a166f9" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变装箱和拆箱阵列。</target>
        </trans-unit>
        <trans-unit id="3bcf35d6b49f587009acea897dbec9a7205cd79b" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the IO monad.</source>
          <target state="translated">在IO单体中的可互换盒装和非盒装数组。</target>
        </trans-unit>
        <trans-unit id="440cc7a8eb8ee990439d9b0c275e863e6bd50dfb" translate="yes" xml:space="preserve">
          <source>Mutable boxed and unboxed arrays in the IO monad. . Safe API only of &lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO&lt;/a&gt;.</source>
          <target state="translated">IO monad中可变的装箱和拆箱阵列。。仅&lt;a href=&quot;data-array-io&quot;&gt;Data.Array.IO的&lt;/a&gt;安全API 。</target>
        </trans-unit>
        <trans-unit id="3fb3ae51bcbb4d7a420b0ebdc8a4c6115c91d585" translate="yes" xml:space="preserve">
          <source>Mutable references in the (strict) ST monad.</source>
          <target state="translated">(严格的)ST单体中的可变引用。</target>
        </trans-unit>
        <trans-unit id="42749e4461b51d539ec768df8df05dca87a2bacc" translate="yes" xml:space="preserve">
          <source>Mutable references in the IO monad.</source>
          <target state="translated">IO单体中的可变引用。</target>
        </trans-unit>
        <trans-unit id="1f817ca4b49a2a2210c658ea8fd1e259ead274d2" translate="yes" xml:space="preserve">
          <source>Mutable references in the lazy ST monad.</source>
          <target state="translated">懒惰的ST单体中的可变引用。</target>
        </trans-unit>
        <trans-unit id="04916e4ec1fe3dc428e8538332487b612dc2bd11" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad 中的可变，带框的非严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="211618f366b0b487ea1225369f9859d9b05e4ebf" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变，带框的非严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="11382766a0d791915a7503d6ac8e7df2555a1f47" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中的可变，带框的非严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="48f88ae9ac44602611ed4f45283d41180f01bbf0" translate="yes" xml:space="preserve">
          <source>Mutable, boxed, non-strict arrays in the &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad 中的可变，带框的非严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="6cb43316285255ffc42363e8387f0053efdb7cd7" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 中的可变，未装箱的严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="a301c7b2f899d4e9c83b2d431bcea04bd569480b" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中的可变，未装箱的严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="c1956fd705ef698a7aa6808b42979d8096d57754" translate="yes" xml:space="preserve">
          <source>Mutable, unboxed, strict arrays in the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中的可变，未装箱的严格数组。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="9925971623b1ac9311a057c1e6621841f8a448f7" translate="yes" xml:space="preserve">
          <source>MutableArray#</source>
          <target state="translated">MutableArray#</target>
        </trans-unit>
        <trans-unit id="40bb1cc17c060c6bd43dbf016d618af652f8c837" translate="yes" xml:space="preserve">
          <source>MutableArrayArray#</source>
          <target state="translated">MutableArrayArray#</target>
        </trans-unit>
        <trans-unit id="68b676eacbb0a7843cf46324a527ccbb0beed645" translate="yes" xml:space="preserve">
          <source>MutableByteArray#</source>
          <target state="translated">MutableByteArray#</target>
        </trans-unit>
        <trans-unit id="ddc210a400b5481a3abcf1bcd6083f807abd8b39" translate="yes" xml:space="preserve">
          <source>Mutate the contents of a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;N.B.&lt;/em&gt;, this version is non-strict.</source>
          <target state="translated">变异 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 的内容。&lt;em&gt;注意&lt;/em&gt;，此版本是非严格的。</target>
        </trans-unit>
        <trans-unit id="29f6dd6604a4083b037e5b08c77d32e780b2deac" translate="yes" xml:space="preserve">
          <source>Mutate the contents of an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="65a480fe4d2e3102f2ecc2852d563e994ffa8ae8" translate="yes" xml:space="preserve">
          <source>Mutate the contents of an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="beef505a6a01c0417026ebb4ed6aa4fbdd93ebfe" translate="yes" xml:space="preserve">
          <source>Mutation: In both &lt;code&gt;foreign import unsafe&lt;/code&gt; and &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls, it is safe to mutate a &lt;code&gt;MutableByteArray&lt;/code&gt;. Mutating any other type of array leads to undefined behavior. Reason: Mutable arrays of heap objects record writes for the purpose of garbage collection. An array of heap objects is passed to a foreign C function, the runtime does not record any writes. Consequently, it is not safe to write to an array of heap objects in a foreign function. Since the runtime has no facilities for tracking mutation of a &lt;code&gt;MutableByteArray#&lt;/code&gt;, these can be safely mutated in any foreign function.</source>
          <target state="translated">突变：在 &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI调用和 &lt;code&gt;foreign import safe&lt;/code&gt; FFI调用中，对 &lt;code&gt;MutableByteArray&lt;/code&gt; 进行突变都是安全的。突变任何其他类型的数组都会导致未定义的行为。原因：堆对象的可变数组记录用于垃圾回收的写操作。堆对象数组传递给外部C函数，运行时不记录任何写操作。因此，在外部函数中写入堆对象数组是不安全的。由于运行时没有用于跟踪 &lt;code&gt;MutableByteArray#&lt;/code&gt; 突变的工具，因此可以在任何外来函数中安全地对其进行突变。</target>
        </trans-unit>
        <trans-unit id="18d35073b15c0f266e315c4a406057c1c9e30791" translate="yes" xml:space="preserve">
          <source>NB! This is a legacy feature, see &lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt;&lt;code&gt;StandaloneKindSignatures&lt;/code&gt;&lt;/a&gt; for the modern replacement.</source>
          <target state="translated">注意！这是一项旧功能，请参阅&lt;a href=&quot;#extension-StandaloneKindSignatures&quot;&gt; &lt;code&gt;StandaloneKindSignatures&lt;/code&gt; &lt;/a&gt;以了解最新的替代方法。</target>
        </trans-unit>
        <trans-unit id="6d4bc7da7f8019e6ba579c7168ed8ef8e123de9f" translate="yes" xml:space="preserve">
          <source>NB. Be very careful with these finalizers. One common trap is that if a finalizer references another finalized value, it does not prevent that value from being finalized. In particular, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s are finalized objects, so a finalizer should not refer to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">注意 这些终结器要非常小心。一个常见的陷阱是，如果终结器引用了另一个终结值，则不会阻止该值被终结。特别是， &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 是终结对象，因此终结器不应引用 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; （包括 &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="374a0e14aef11d696ae0e12a6af249af24d04c07" translate="yes" xml:space="preserve">
          <source>NB. This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">注意 在预处理Haskell源代码和C源代码（包括从Haskell模块生成的C源代码（即 &lt;code&gt;.hs&lt;/code&gt; ， &lt;code&gt;.lhs&lt;/code&gt; ， &lt;code&gt;.c&lt;/code&gt; 和 &lt;code&gt;.hc&lt;/code&gt; 文件））时，将设置此宏。</target>
        </trans-unit>
        <trans-unit id="ef6198823084d192389d02aee66353f70e110347" translate="yes" xml:space="preserve">
          <source>NB: &lt;code&gt;isValidBigNat# nullBigNat&lt;/code&gt; is false</source>
          <target state="translated">注意： &lt;code&gt;isValidBigNat# nullBigNat&lt;/code&gt; 为false</target>
        </trans-unit>
        <trans-unit id="ccbbb1b26af40cc778cde005c4f658b4a6d44e97" translate="yes" xml:space="preserve">
          <source>NB: This treatment of superclasses goes beyond &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;the paper&lt;/a&gt;, but is specifically desired by users.</source>
          <target state="translated">注意：对超类的这种处理超出&lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;了本文的范围&lt;/a&gt;，但是用户特别希望这样做。</target>
        </trans-unit>
        <trans-unit id="5cfb84a3255f99b3a5dc5c0b199025e1ab8a956d" translate="yes" xml:space="preserve">
          <source>NFData</source>
          <target state="translated">NFData</target>
        </trans-unit>
        <trans-unit id="8bef8898d5726a9645ab52735e823a1b3b2a58ed" translate="yes" xml:space="preserve">
          <source>NFData1</source>
          <target state="translated">NFData1</target>
        </trans-unit>
        <trans-unit id="418a51c8aef1b7b43f9f69603188a3fc934fb298" translate="yes" xml:space="preserve">
          <source>NFData2</source>
          <target state="translated">NFData2</target>
        </trans-unit>
        <trans-unit id="8157bf312f87194c1b8385054be3f190c76145cd" translate="yes" xml:space="preserve">
          <source>NLSVERSIONINFOEX</source>
          <target state="translated">NLSVERSIONINFOEX</target>
        </trans-unit>
        <trans-unit id="a74c32096f555276472737ff5840787516207d4d" translate="yes" xml:space="preserve">
          <source>NOTE for GHC users: unless you use the &lt;code&gt;-threaded&lt;/code&gt; flag, &lt;code&gt;hWaitForInput hdl t&lt;/code&gt; where &lt;code&gt;t &amp;gt;= 0&lt;/code&gt; will block all other Haskell threads for the duration of the call. It behaves like a &lt;code&gt;safe&lt;/code&gt; foreign call in this respect.</source>
          <target state="translated">注：为GHC用户：除非你使用 &lt;code&gt;-threaded&lt;/code&gt; 标志， &lt;code&gt;hWaitForInput hdl t&lt;/code&gt; ，其中 &lt;code&gt;t &amp;gt;= 0&lt;/code&gt; 将阻止所有其他的Haskell线程调用的持续时间。在这方面，它的行为就像一个 &lt;code&gt;safe&lt;/code&gt; 外国电话。</target>
        </trans-unit>
        <trans-unit id="f8bec3400a00d95de2aca056e95477c68ba1eb54" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; may block, because it has to attempt to read from the stream to determine whether there is any more data to be read.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 可能会阻塞，因为它必须尝试从流中读取以确定是否还有更多数据要读取。</target>
        </trans-unit>
        <trans-unit id="e177a44ba2f2969ccf14799a97fd335989430f30" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; may block, because it has to attempt to read from the stream to determine whether there is any more data to be read.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 可能会阻塞，因为它必须尝试从流中读取以确定是否还有更多数据要读取。</target>
        </trans-unit>
        <trans-unit id="b1bbe2aede4f3fac96050d9ca6e8622d57dc7d43" translate="yes" xml:space="preserve">
          <source>NOTE: Since this library is built on top of the curses interface, it is not thread-safe.</source>
          <target state="translated">注意:由于这个库是建立在curses接口之上的,所以它不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="63561186ffbbc0f2e4ac1c402f5b46d5450d885c" translate="yes" xml:space="preserve">
          <source>NOTE: The implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt; is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">注意：隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API的一部分，我们可能会决定在将来更改实现。</target>
        </trans-unit>
        <trans-unit id="73283dfca92bcfe835f52a5a26a21a5f2a2e5acc" translate="yes" xml:space="preserve">
          <source>NOTE: The implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt; is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">注意：隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API的一部分，我们可能会决定在将来更改实现。</target>
        </trans-unit>
        <trans-unit id="98b32b5a6dce9bba2f73fac9f444388673ea544d" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">注意：勇敢的用户可能会注意到 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 只是隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 的别名。这是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API的一部分，我们可能会决定将来更改实现。</target>
        </trans-unit>
        <trans-unit id="d4652f803bbd5a4299b501fa174c8494ddc7084c" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">注意：勇敢的用户可能会注意到 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 只是隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 的别名。这是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API的一部分，我们可能会决定将来更改实现。</target>
        </trans-unit>
        <trans-unit id="04964a8b393aeb4c81203022d841d735724a3657" translate="yes" xml:space="preserve">
          <source>NOTE: The intrepid user may notice that &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">注意：勇敢的用户可能会注意到 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 只是隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 的别名。这是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; API的一部分，我们可能会决定将来更改实现。</target>
        </trans-unit>
        <trans-unit id="74a3caaaf7af6b131af05747420d7f407dc4b9e0" translate="yes" xml:space="preserve">
          <source>NOTE: createHardLink is &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatibility for Unix.</source>
          <target state="translated">注意：createHardLink被&lt;em&gt;翻转&lt;/em&gt;以提供与Unix的兼容性。</target>
        </trans-unit>
        <trans-unit id="173f40eb49608b0a9f5c7dfe7826130ac61ad0f2" translate="yes" xml:space="preserve">
          <source>NOTE: createHardLink is &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatiblity for Unix.</source>
          <target state="translated">注意：createHardLink是&lt;em&gt;翻转参数，&lt;/em&gt;以提供Unix的兼容性。</target>
        </trans-unit>
        <trans-unit id="4d19907a6a79e56c857a5f3e68218d937122f148" translate="yes" xml:space="preserve">
          <source>NOTE: createSymbolicLink* functions are &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatibility for Unix, except &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：createSymbolicLink *函数是可&lt;em&gt;翻转的参数，&lt;/em&gt;以提供与Unix的兼容性，但 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="65538d1f35d9ff80cfc7afb1ba3058d20b90d2b2" translate="yes" xml:space="preserve">
          <source>NOTE: createSymbolicLink* functions are &lt;em&gt;flipped arguments&lt;/em&gt; to provide compatiblity for Unix, except &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：createSymbolicLink *函数是可&lt;em&gt;翻转的参数&lt;/em&gt;，用于为Unix提供兼容性，但 &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; 除外。</target>
        </trans-unit>
        <trans-unit id="9a289febc0a62ac0fd3ddf47889458ad201b28af" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="27648f423ffb7efa59e5c0832d0545992c2e7a71" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="a2f5862ab04e7d70c9d237cade16ad082f1f892f" translate="yes" xml:space="preserve">
          <source>NOTE: on Windows, this function does not work correctly; it behaves identically to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">注意：在Windows上，此功能无法正常工作；它的行为与 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="217551d8f091b6742427b78f8d4d21b8576d5bcf" translate="yes" xml:space="preserve">
          <source>NPlusKPatterns</source>
          <target state="translated">NPlusKPatterns</target>
        </trans-unit>
        <trans-unit id="16011665a1d6a1793f7af5691f78690f7db8e797" translate="yes" xml:space="preserve">
          <source>NT namespace: &lt;code&gt;\&lt;/code&gt;</source>
          <target state="translated">NT命名空间： &lt;code&gt;\&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09b181fc210e2f1a3662ae262c26a3cf3bb2036d" translate="yes" xml:space="preserve">
          <source>NTFS only supprts this functionality.</source>
          <target state="translated">NTFS只支持这个功能。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="e11bc388c83c1b8b82ae73a235837ab0ef1b8869" translate="yes" xml:space="preserve">
          <source>Name lookup</source>
          <target state="translated">姓名查询</target>
        </trans-unit>
        <trans-unit id="c1dd5c5a3c784d1dc660322bd2d8b0aadd9447a3" translate="yes" xml:space="preserve">
          <source>Name of the Haskell file.</source>
          <target state="translated">Haskell文件的名称。</target>
        </trans-unit>
        <trans-unit id="d34370b884a4e0c6661e9211124b058e6efe6336" translate="yes" xml:space="preserve">
          <source>Name of the module where the static pointer is defined</source>
          <target state="translated">定义静态指针的模块名称。</target>
        </trans-unit>
        <trans-unit id="241f55c9dbd4332d828c31c2528891c3f79c4291" translate="yes" xml:space="preserve">
          <source>NameFlavour</source>
          <target state="translated">NameFlavour</target>
        </trans-unit>
        <trans-unit id="43bd2e139f7efc3fb707f38288858777f7d29f55" translate="yes" xml:space="preserve">
          <source>NameIs</source>
          <target state="translated">NameIs</target>
        </trans-unit>
        <trans-unit id="e784a5acc01d14b30b1b161e2114eac0f9da4a44" translate="yes" xml:space="preserve">
          <source>NameS</source>
          <target state="translated">NameS</target>
        </trans-unit>
        <trans-unit id="285f33209f1413ce6482de704071ed860f4ee1f7" translate="yes" xml:space="preserve">
          <source>NameSpace</source>
          <target state="translated">NameSpace</target>
        </trans-unit>
        <trans-unit id="af5f97c76eceeda41176655ffdf797f38db674a9" translate="yes" xml:space="preserve">
          <source>Named arguments can also be given explicit kind signatures if needed. Just as with &lt;a href=&quot;#gadt&quot;&gt;GADT declarations&lt;/a&gt; named arguments are entirely optional, so that we can declare &lt;code&gt;Array&lt;/code&gt; alternatively with</source>
          <target state="translated">如果需要，还可以给命名实参赋予显式种类签名。正如&lt;a href=&quot;#gadt&quot;&gt;GADT声明&lt;/a&gt;命名参数是完全可选的，这样我们就可以声明 &lt;code&gt;Array&lt;/code&gt; 与交替</target>
        </trans-unit>
        <trans-unit id="e62d156320deceb36f700d974fa40eaf6fd11436" translate="yes" xml:space="preserve">
          <source>Named arguments can also be given explicit kind signatures if needed. Just as with &lt;a href=&quot;gadt#gadt&quot;&gt;GADT declarations&lt;/a&gt; named arguments are entirely optional, so that we can declare &lt;code&gt;Array&lt;/code&gt; alternatively with</source>
          <target state="translated">如果需要，还可以给命名实参赋予显式种类签名。正如&lt;a href=&quot;gadt#gadt&quot;&gt;GADT声明&lt;/a&gt;命名参数是完全可选的，这样我们就可以声明 &lt;code&gt;Array&lt;/code&gt; 与交替</target>
        </trans-unit>
        <trans-unit id="453d20a6d115195746f780ef6b881f77130889c3" translate="yes" xml:space="preserve">
          <source>Named wildcards &lt;em&gt;should not be confused with type variables&lt;/em&gt;. Even though syntactically similar, named wildcards can unify with monotypes as well as be generalised over (and behave as type variables).</source>
          <target state="translated">命名通配符&lt;em&gt;不应与类型变量混淆&lt;/em&gt;。即使在语法上相似，命名通配符也可以与单型统一，也可以泛化（并充当类型变量）。</target>
        </trans-unit>
        <trans-unit id="efd83b1022b74e5c3478447290339e566cb15ae5" translate="yes" xml:space="preserve">
          <source>NamedWildCards</source>
          <target state="translated">NamedWildCards</target>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="b2390be51f0839e05354a4edc7bfb9b402fb9775" translate="yes" xml:space="preserve">
          <source>Names constructed using &lt;code&gt;newName&lt;/code&gt; and &lt;code&gt;mkName&lt;/code&gt; may be used in bindings (such as &lt;code&gt;let x = ...&lt;/code&gt; or &lt;code&gt;x -&amp;gt; ...&lt;/code&gt;), but names constructed using &lt;code&gt;lookupValueName&lt;/code&gt;, &lt;code&gt;lookupTypeName&lt;/code&gt;, &lt;code&gt;'f&lt;/code&gt;, &lt;code&gt;''T&lt;/code&gt; may not.</source>
          <target state="translated">使用 &lt;code&gt;newName&lt;/code&gt; 和 &lt;code&gt;mkName&lt;/code&gt; 构造的名称可以在绑定中使用（例如 &lt;code&gt;let x = ...&lt;/code&gt; 或 &lt;code&gt;x -&amp;gt; ...&lt;/code&gt; ），但是使用 &lt;code&gt;lookupValueName&lt;/code&gt; ， &lt;code&gt;lookupTypeName&lt;/code&gt; ， &lt;code&gt;'f&lt;/code&gt; 和 &lt;code&gt;''T&lt;/code&gt; 构造的名称则不能使用。</target>
        </trans-unit>
        <trans-unit id="34803b64f16548b242233b7132d75f6e5f8fe8e6" translate="yes" xml:space="preserve">
          <source>Naming conventions</source>
          <target state="translated">命名惯例</target>
        </trans-unit>
        <trans-unit id="9f71fd1007f8c4abc458163409fae654630b9e86" translate="yes" xml:space="preserve">
          <source>Nano</source>
          <target state="translated">Nano</target>
        </trans-unit>
        <trans-unit id="2e3e963e975a60a6a8a003da6ed817e4d4499a19" translate="yes" xml:space="preserve">
          <source>Nat</source>
          <target state="translated">Nat</target>
        </trans-unit>
        <trans-unit id="fcc28bb1503dac338f555a7ce7320bdbab52e7c3" translate="yes" xml:space="preserve">
          <source>Nat Kind</source>
          <target state="translated">纳特-金德</target>
        </trans-unit>
        <trans-unit id="7322348943287d68f8c176b2c1566795ccc03b7e" translate="yes" xml:space="preserve">
          <source>Native code generator</source>
          <target state="translated">本地代码生成器</target>
        </trans-unit>
        <trans-unit id="ea26876daa9a0a0caf49391472053413ac06277e" translate="yes" xml:space="preserve">
          <source>Natural</source>
          <target state="translated">Natural</target>
        </trans-unit>
        <trans-unit id="7f0b8727de826105bbce9ba7b95859488d5a3633" translate="yes" xml:space="preserve">
          <source>Natural number</source>
          <target state="translated">自然数</target>
        </trans-unit>
        <trans-unit id="6dfc30c819c79fca570a6d67601933511b292394" translate="yes" xml:space="preserve">
          <source>Naturality</source>
          <target state="translated">Naturality</target>
        </trans-unit>
        <trans-unit id="a6a233fd10e66b739809092ee7ea7beda5f628ec" translate="yes" xml:space="preserve">
          <source>Nd: Number, Decimal</source>
          <target state="translated">Nd:数字,十进制</target>
        </trans-unit>
        <trans-unit id="58af6d921b3520c3002a4fbc054962eb72c7ec5b" translate="yes" xml:space="preserve">
          <source>Needed to optimize support for different IO Managers on Windows. See Note [The need for getIoManagerFlag]</source>
          <target state="translated">需要优化对Windows上不同IO管理器的支持。参见注解[getIoManagerFlag的必要性]。</target>
        </trans-unit>
        <trans-unit id="ee52746bd96005ef182ba2d9b60655a4e0ac20d1" translate="yes" xml:space="preserve">
          <source>Negate &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">取反 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06b8058bc282e46c01399ffa04dcfaf5551d96ef" translate="yes" xml:space="preserve">
          <source>Negate element-wise.</source>
          <target state="translated">从元素上否定。</target>
        </trans-unit>
        <trans-unit id="1c22f0963e34858feada46efcb0a5e32c38f2754" translate="yes" xml:space="preserve">
          <source>Negation (e.g. &amp;ldquo;&lt;code&gt;- (f x)&lt;/code&gt;&amp;rdquo;) means &amp;ldquo;&lt;code&gt;negate (f x)&lt;/code&gt;&amp;rdquo;, both in numeric patterns, and expressions.</source>
          <target state="translated">否定（例如&amp;ldquo; &lt;code&gt;- (f x)&lt;/code&gt; &amp;rdquo;）在数字模式和表达式中均表示&amp;ldquo; &lt;code&gt;negate (f x)&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dd048e1f91db2495004257dbd5282e263424faee" translate="yes" xml:space="preserve">
          <source>Negative exponents are supported if an inverse modulo &lt;code&gt;&lt;em&gt;m&lt;/em&gt;&lt;/code&gt; exists.</source>
          <target state="translated">如果存在反模 &lt;code&gt;&lt;em&gt;m&lt;/em&gt;&lt;/code&gt; ,则支持负指数。</target>
        </trans-unit>
        <trans-unit id="f4f4481fb4d6d71c0fcfc0047e37c0bbb90861f5" translate="yes" xml:space="preserve">
          <source>Negative literals, such as &lt;code&gt;-3&lt;/code&gt;, are specified by (a careful reading of) the Haskell Report as meaning &lt;code&gt;Prelude.negate (Prelude.fromInteger 3)&lt;/code&gt;. So &lt;code&gt;-2147483648&lt;/code&gt; means &lt;code&gt;negate (fromInteger 2147483648)&lt;/code&gt;. Since &lt;code&gt;fromInteger&lt;/code&gt; takes the lower 32 bits of the representation, &lt;code&gt;fromInteger (2147483648::Integer)&lt;/code&gt;, computed at type &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;-2147483648::Int&lt;/code&gt;. The &lt;code&gt;negate&lt;/code&gt; operation then overflows, but it is unchecked, so &lt;code&gt;negate (-2147483648::Int)&lt;/code&gt; is just &lt;code&gt;-2147483648&lt;/code&gt;. In short, one can write &lt;code&gt;minBound::Int&lt;/code&gt; as a literal with the expected meaning (but that is not in general guaranteed).</source>
          <target state="translated">负数（例如 &lt;code&gt;-3&lt;/code&gt; ）由Haskell报告（仔细阅读）指定为含义 &lt;code&gt;Prelude.negate (Prelude.fromInteger 3)&lt;/code&gt; 。因此 &lt;code&gt;-2147483648&lt;/code&gt; 表示 &lt;code&gt;negate (fromInteger 2147483648)&lt;/code&gt; 。由于 &lt;code&gt;fromInteger&lt;/code&gt; 采用表示的低32位，因此 &lt;code&gt;fromInteger (2147483648::Integer)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 类型计算为 &lt;code&gt;-2147483648::Int&lt;/code&gt; 。在 &lt;code&gt;negate&lt;/code&gt; 操作随后溢流，但未被选中，所以 &lt;code&gt;negate (-2147483648::Int)&lt;/code&gt; 仅仅是 &lt;code&gt;-2147483648&lt;/code&gt; 。简而言之，可以编写 &lt;code&gt;minBound::Int&lt;/code&gt; 作为具有预期含义的文字（但通常不能保证）。</target>
        </trans-unit>
        <trans-unit id="3e0a90cf89e0e38e6ded6a27d6e570ec770c082d" translate="yes" xml:space="preserve">
          <source>Negative numbers must be parenthesized when they appear in function argument position. &lt;code&gt;f (-5)&lt;/code&gt; is correct, whereas &lt;code&gt;f -5&lt;/code&gt; is parsed as &lt;code&gt;(-) f 5&lt;/code&gt;.</source>
          <target state="translated">当负数出现在函数参数位置时，必须将其括在括号中。 &lt;code&gt;f (-5)&lt;/code&gt; 是正确的，而 &lt;code&gt;f -5&lt;/code&gt; 被解析为 &lt;code&gt;(-) f 5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d52baec47edee13dda9979236d74b3a6e53bb526" translate="yes" xml:space="preserve">
          <source>Negative precision is taken as 0. The meaning of the precision depends on the conversion type.</source>
          <target state="translated">负精度为0,精度的意义取决于转换类型。</target>
        </trans-unit>
        <trans-unit id="f622cbbe6dc0bf9f80a40c77e1e302b16367df00" translate="yes" xml:space="preserve">
          <source>NegativeLiterals</source>
          <target state="translated">NegativeLiterals</target>
        </trans-unit>
        <trans-unit id="ac634bf99f709c9e754d7e578de589c844f2186a" translate="yes" xml:space="preserve">
          <source>Neither name of the University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</source>
          <target state="translated">未经特定的书面许可,不得使用大学的名称或其贡献者的姓名来认可或推广本软件的产品。</target>
        </trans-unit>
        <trans-unit id="522182dd21569f6be17220e3cac4e333aa5e69ba" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">将文档嵌套（或缩进）给定数量的位置（也可以是负数）。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 符合法律规定：</target>
        </trans-unit>
        <trans-unit id="949a22e40a67eb32fd127980e8bf7757812da720" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">将文档嵌套（或缩进）给定数量的位置（也可以是负数）。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 符合法律规定：</target>
        </trans-unit>
        <trans-unit id="2fd44f8ebe0a7e3b2bea5c918f154b8513f223e1" translate="yes" xml:space="preserve">
          <source>Nest (or indent) a document by a given number of positions (which may also be negative). &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; satisfies the laws:</source>
          <target state="translated">将文档嵌套（或缩进）给定数量的位置（也可以是负数）。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:nest&quot;&gt;nest&lt;/a&gt;&lt;/code&gt; 符合法律规定：</target>
        </trans-unit>
        <trans-unit id="2344677d8f01e8e2fca317a5c561cc80f092e37c" translate="yes" xml:space="preserve">
          <source>Nested</source>
          <target state="translated">Nested</target>
        </trans-unit>
        <trans-unit id="720741a1472872a68ca3c388c3c11a286d659bd3" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;do&lt;/code&gt; blocks do not affect each other&amp;rsquo;s meanings.</source>
          <target state="translated">嵌套的 &lt;code&gt;do&lt;/code&gt; 块不会影响彼此的含义。</target>
        </trans-unit>
        <trans-unit id="d67a4e0cdcad34714be98100536800680402b530" translate="yes" xml:space="preserve">
          <source>NestedAtomically</source>
          <target state="translated">NestedAtomically</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="a2577c561d86f6ba3c73b6eefeafce792f6e11cc" translate="yes" xml:space="preserve">
          <source>Nevertheless one can pretend that the following three kinds of instances exist. First, as a trivial base-case:</source>
          <target state="translated">然而,我们可以假设存在以下三种情况。首先,作为一个微不足道的基例。</target>
        </trans-unit>
        <trans-unit id="cfe594798e5ee5a9536eb68772725a21269ab358" translate="yes" xml:space="preserve">
          <source>New parsing functions</source>
          <target state="translated">新的解析功能</target>
        </trans-unit>
        <trans-unit id="1523c8acdb2ee4d7786ae768261d0c785a7a6dd4" translate="yes" xml:space="preserve">
          <source>New path</source>
          <target state="translated">新路</target>
        </trans-unit>
        <trans-unit id="2f086c7950ef417a974e200114c1f6896effacb4" translate="yes" xml:space="preserve">
          <source>New reserved words and symbols: character sequences which are no longer available for use as identifiers in the program.</source>
          <target state="translated">新的保留字和符号:程序中不再作为标识符使用的字符序列。</target>
        </trans-unit>
        <trans-unit id="2b86793d71ec22bae7c09d67603a4b5ca57fee12" translate="yes" xml:space="preserve">
          <source>New size of array</source>
          <target state="translated">阵列的新尺寸</target>
        </trans-unit>
        <trans-unit id="d706a7f27906e3a8bf4f4fed0f9c3d7edc4a240a" translate="yes" xml:space="preserve">
          <source>Newline</source>
          <target state="translated">Newline</target>
        </trans-unit>
        <trans-unit id="08342fdb7e4d5979ac614e4583b9d664b9d3d88c" translate="yes" xml:space="preserve">
          <source>Newline conversion</source>
          <target state="translated">新线转换</target>
        </trans-unit>
        <trans-unit id="ada069b2de824a0d3a8b152fde78626a8e8b8ade" translate="yes" xml:space="preserve">
          <source>NewlineMode</source>
          <target state="translated">NewlineMode</target>
        </trans-unit>
        <trans-unit id="9b709dfae84cfac1c978bbe397d4df6e001163d1" translate="yes" xml:space="preserve">
          <source>Newly created slots initialized to this element. Only used when array is grown.</source>
          <target state="translated">新创建的插槽初始化到这个元素。仅在数组增长时使用。</target>
        </trans-unit>
        <trans-unit id="9d70c1effde2f8c015bfb84f7838e84613e007f3" translate="yes" xml:space="preserve">
          <source>NewtypeStrategy</source>
          <target state="translated">NewtypeStrategy</target>
        </trans-unit>
        <trans-unit id="ca33c65ffa7a8e2e461597acbdf8adbf2c6312c3" translate="yes" xml:space="preserve">
          <source>Newtypes are better than datatypes:</source>
          <target state="translated">Newtypes比datatypes更好。</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bb1a13dad76ab6476212d16d134ffcbc89390074" translate="yes" xml:space="preserve">
          <source>Next free byte in current &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">当前 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 中的下一个空闲字节</target>
        </trans-unit>
        <trans-unit id="4ae9c52b894383b8025369fa03e4f1485c55d887" translate="yes" xml:space="preserve">
          <source>Next free byte in current &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当前 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 中的下一个空闲字节。</target>
        </trans-unit>
        <trans-unit id="6ae27512f7d04b93e6ab0f5a142fdb6a159a3a6d" translate="yes" xml:space="preserve">
          <source>Next position calculating function.</source>
          <target state="translated">下一个位置计算功能。</target>
        </trans-unit>
        <trans-unit id="499df2c9156f9e7492c202932262c12764a363a7" translate="yes" xml:space="preserve">
          <source>Next there is information about the garbage collections done. For each generation it says how many garbage collections were done, how many of those collections were done in parallel, the total CPU time used for garbage collecting that generation, and the total wall clock time elapsed while garbage collecting that generation.</source>
          <target state="translated">接下来是关于所做的垃圾收集的信息。对于每一代,它都会说做了多少次垃圾收集,其中有多少次是并行完成的,该代垃圾收集所使用的总CPU时间,以及该代垃圾收集时经过的总壁钟时间。</target>
        </trans-unit>
        <trans-unit id="833ff1d27fbdf158e7b505b01c19b8b1b95cec80" translate="yes" xml:space="preserve">
          <source>Next there is the CPU time and wall clock time elapsed broken down by what the runtime system was doing at the time. INIT is the runtime system initialisation. MUT is the mutator time, i.e. the time spent actually running your code. GC is the time spent doing garbage collection. RP is the time spent doing retainer profiling. PROF is the time spent doing other profiling. EXIT is the runtime system shutdown time. And finally, Total is, of course, the total.</source>
          <target state="translated">接下来是按运行时系统当时在做什么来划分的CPU时间和墙钟时间。INIT是运行时系统初始化的时间。MUT是突变器时间,即实际运行代码的时间。GC是做垃圾收集的时间。RP是做保留剖析的时间。PROF是做其他剖析的时间。EXIT是运行时系统关闭的时间。最后,Total当然是总和。</target>
        </trans-unit>
        <trans-unit id="6e08ae4fe787b1e828f2d0c8f144343e2fec4132" translate="yes" xml:space="preserve">
          <source>Next to &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; there are a few more type constructors that occur in the representations of other datatypes.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 之后，其他数据类型的表示形式中还有更多类型构造函数。</target>
        </trans-unit>
        <trans-unit id="64a331e6f60cb1a7ad554cbc5ac1d707fce97281" translate="yes" xml:space="preserve">
          <source>Next, it will perform the actions in the &lt;code&gt;actions&lt;/code&gt; list in order from left to right.</source>
          <target state="translated">接下来，它将按从左到右的顺序执行 &lt;code&gt;actions&lt;/code&gt; 列表中的动作。</target>
        </trans-unit>
        <trans-unit id="c916da70cd4a32512ca71d70e5cc765d00357df4" translate="yes" xml:space="preserve">
          <source>Nil</source>
          <target state="translated">Nil</target>
        </trans-unit>
        <trans-unit id="01254dc62ba02c8f98ce116687b65348bfae9d10" translate="yes" xml:space="preserve">
          <source>Nils Anders Danielsson 2006</source>
          <target state="translated">Nils Anders Danielsson,2006年</target>
        </trans-unit>
        <trans-unit id="c6b76279a253069e49509991acb2a0fc6c0289e6" translate="yes" xml:space="preserve">
          <source>Nl: Number, Letter</source>
          <target state="translated">Nl:数字,字母</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="e18dd77372be6a1409a708e6d14bcd9b7f68a5f9" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;-RTS&lt;/code&gt; option is required if the runtime-system options extend to the end of the command line, as in this example:</source>
          <target state="translated">如果运行时系统选项扩展到命令行的末尾，则不需要 &lt;code&gt;-RTS&lt;/code&gt; 选项，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="707c81ee0c3909e525ac07b27c0a7023a5bea3e3" translate="yes" xml:space="preserve">
          <source>No finalizer. If there is no intent to add a finalizer at any point in the future, consider &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:FinalPtr&quot;&gt;FinalPtr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; instead since these perform fewer allocations.</source>
          <target state="translated">没有终结器。如果将来无意添加终结器，请考虑使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:FinalPtr&quot;&gt;FinalPtr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:PlainPtr&quot;&gt;PlainPtr&lt;/a&gt;&lt;/code&gt; ,因为它们执行的分配较少。</target>
        </trans-unit>
        <trans-unit id="899c963a8035b8eff10bff6d0639741ad4e409cb" translate="yes" xml:space="preserve">
          <source>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first submap less than all elements in the second, and so on).</source>
          <target state="translated">不能保证碎片的大小;一个内部的但确定的过程决定了这一点。然而,它保证返回的碎片将按升序排列(第一个子图中的所有元素小于第二个子图中的所有元素,以此类推)。</target>
        </trans-unit>
        <trans-unit id="5b4acda8d542358f213b8f3e4e1650164df9bfe7" translate="yes" xml:space="preserve">
          <source>No guarantee is made as to the sizes of the pieces; an internal, but deterministic process determines this. However, it is guaranteed that the pieces returned will be in ascending order (all elements in the first subset less than all elements in the second, and so on).</source>
          <target state="translated">不保证碎片的大小;一个内部但确定的过程决定了这一点。但是,保证返回的碎片将按升序排列(第一个子集的所有元素小于第二个子集的所有元素,依此类推)。</target>
        </trans-unit>
        <trans-unit id="77c3849165d91154401b080a528c1f07258f9117" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">没有缩进，可以使用无限长的行（忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ），但是可以使用显式的新行，即 &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d21eb7c7dc916ac561e541148784eed9a679e1bb" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">没有缩进，可以使用无限长的行（忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ），但是可以使用显式的新行，即 &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="538a5adae1b6b87754931f19e7d8936b73a4e244" translate="yes" xml:space="preserve">
          <source>No indentation, infinitely long lines (&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ignored), but explicit new lines, i.e., &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt;, are respected.</source>
          <target state="translated">没有缩进，可以使用无限长的行（忽略 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; ），但是可以使用显式的新行，即 &lt;code&gt;text &quot;one&quot; $$ text &quot;two&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbe83843190c4d65bded786e194509b323e2b4b6" translate="yes" xml:space="preserve">
          <source>No language extension is required to use typed holes. The lexeme &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo; was previously illegal in Haskell, but now has a more informative error message. The lexeme &amp;ldquo;&lt;code&gt;_x&lt;/code&gt;&amp;rdquo; is a perfectly legal variable, and its behaviour is unchanged when it is in scope. For example</source>
          <target state="translated">使用键入孔不需要语言扩展。字母&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;以前在Haskell中是非法的，但现在具有更多信息。lexeme&amp;ldquo; &lt;code&gt;_x&lt;/code&gt; &amp;rdquo;是一个完全合法的变量，在范围内时其行为不变。例如</target>
        </trans-unit>
        <trans-unit id="e9413c2cb6cce1148a677bc74e708c4b678606be" translate="yes" xml:space="preserve">
          <source>No longer set the special variable &lt;code&gt;it&lt;/code&gt;.</source>
          <target state="translated">不再设置特殊变量 &lt;code&gt;it&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba52b26fd5e250674e73b63230f34aa9f35b6cbc" translate="yes" xml:space="preserve">
          <source>No permissions.</source>
          <target state="translated">没有权限。</target>
        </trans-unit>
        <trans-unit id="ed1a8e9d366a2d42a52953aa766c21a8b8f47167" translate="yes" xml:space="preserve">
          <source>No thread can be blocked indefinitely on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; unless another thread holds that &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; indefinitely. One usual implementation of this fairness guarantee is that threads blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; are served in a first-in-first-out fashion, but this is not guaranteed in the semantics.</source>
          <target state="translated">除非另一个线程无限期地持有该 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; ,否则无法无限期地在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上阻塞该线程。此公平性保证的一种通常实现方式是，以先进先出的方式为 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上阻塞的线程服务，但这在语义上不能保证。</target>
        </trans-unit>
        <trans-unit id="e89a24f8be4016dc5286a75b757316d4b7da6b5e" translate="yes" xml:space="preserve">
          <source>No type variable has more occurrences in the constraint than in the head</source>
          <target state="translated">没有任何类型变量在约束中出现的次数比在头部出现的次数多。</target>
        </trans-unit>
        <trans-unit id="55d4b4e7dd7bd572505570594fa8970268f4ed9d" translate="yes" xml:space="preserve">
          <source>No variable may have a levity-polymorphic type.</source>
          <target state="translated">任何变量都不可以有轻重多态的类型。</target>
        </trans-unit>
        <trans-unit id="8537ab3e90e8c51e2b9081150af774e31041f634" translate="yes" xml:space="preserve">
          <source>No: Number, Other</source>
          <target state="translated">否:数量,其他</target>
        </trans-unit>
        <trans-unit id="fa97e7279198646152703496467a958452203e8b" translate="yes" xml:space="preserve">
          <source>NoBuffering</source>
          <target state="translated">NoBuffering</target>
        </trans-unit>
        <trans-unit id="0d317c9df796aacafead371d325df7dc06bab899" translate="yes" xml:space="preserve">
          <source>NoFinalizers</source>
          <target state="translated">NoFinalizers</target>
        </trans-unit>
        <trans-unit id="187e10d0186766ac8ef38b6b2737dbcd0a0167a3" translate="yes" xml:space="preserve">
          <source>NoFlushOnInterrupt</source>
          <target state="translated">NoFlushOnInterrupt</target>
        </trans-unit>
        <trans-unit id="70c98d57d8ada0b33fa9e5d439c03bb6aa7f0530" translate="yes" xml:space="preserve">
          <source>NoGCStats</source>
          <target state="translated">NoGCStats</target>
        </trans-unit>
        <trans-unit id="e97b63987d7eba398a31aaf58656483d162d92ad" translate="yes" xml:space="preserve">
          <source>NoHeapProfiling</source>
          <target state="translated">NoHeapProfiling</target>
        </trans-unit>
        <trans-unit id="c0bb723db37af9d0e89d2d4da6bdcdd3458e352e" translate="yes" xml:space="preserve">
          <source>NoIO</source>
          <target state="translated">NoIO</target>
        </trans-unit>
        <trans-unit id="6ded8bea31740baa2d151730d57c270b35577c09" translate="yes" xml:space="preserve">
          <source>NoInline</source>
          <target state="translated">NoInline</target>
        </trans-unit>
        <trans-unit id="444ea91c7df550f94f3d747738c1f1a3466e0cc6" translate="yes" xml:space="preserve">
          <source>NoMethodError</source>
          <target state="translated">NoMethodError</target>
        </trans-unit>
        <trans-unit id="0574b23b4939ce65f86fe9caa145b7ac867f74b5" translate="yes" xml:space="preserve">
          <source>NoRep</source>
          <target state="translated">NoRep</target>
        </trans-unit>
        <trans-unit id="1f05476b651d40952a09c240ebf9fac1ee2f0ecf" translate="yes" xml:space="preserve">
          <source>NoSig</source>
          <target state="translated">NoSig</target>
        </trans-unit>
        <trans-unit id="4f1a01f2c1623f4835ba19bede7f20adf4398de2" translate="yes" xml:space="preserve">
          <source>NoSignalSpecificInfo</source>
          <target state="translated">NoSignalSpecificInfo</target>
        </trans-unit>
        <trans-unit id="3d74bf1957091d8e6ef1871b6be8c6329c5dc42a" translate="yes" xml:space="preserve">
          <source>NoSourceStrictness</source>
          <target state="translated">NoSourceStrictness</target>
        </trans-unit>
        <trans-unit id="0c2a4e95086b0b409bb4f59152de8186a4620e2e" translate="yes" xml:space="preserve">
          <source>NoSourceUnpackedness</source>
          <target state="translated">NoSourceUnpackedness</target>
        </trans-unit>
        <trans-unit id="2c12d214fa2aec0228a5d637aa7ea65cc010993a" translate="yes" xml:space="preserve">
          <source>NoSpecConstr</source>
          <target state="translated">NoSpecConstr</target>
        </trans-unit>
        <trans-unit id="c87682f274a125492ffb6e8e300878ad8dfd10c4" translate="yes" xml:space="preserve">
          <source>NoStream</source>
          <target state="translated">NoStream</target>
        </trans-unit>
        <trans-unit id="a07ff5298c0951a2189ecc18db227733a60fe41f" translate="yes" xml:space="preserve">
          <source>NoSuchThing</source>
          <target state="translated">NoSuchThing</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="7b31028629115aecb301b21cc97f7edef2c73b0d" translate="yes" xml:space="preserve">
          <source>Noindex:</source>
          <target state="translated">Noindex:</target>
        </trans-unit>
        <trans-unit id="80e02bcdfb29620da030c45545609a5abf4202d6" translate="yes" xml:space="preserve">
          <source>NominalDiffTime</source>
          <target state="translated">NominalDiffTime</target>
        </trans-unit>
        <trans-unit id="abf94255694225d9e3e43eaf362134e8526f6ae7" translate="yes" xml:space="preserve">
          <source>NominalR</source>
          <target state="translated">NominalR</target>
        </trans-unit>
        <trans-unit id="037918d2c5120c9cbb587548e13bc313033ab3b2" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被该变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20d74269687af42f4b4b46a0d3082a85e712f116" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被该变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="807536be49abd7e4ede9ecfbdfd745c107cf953a" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被此变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25418d52199dc7c513f4cee3f73d6d7310cf1f5c" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被此变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89158cc3bd13635840be9cbac3e6748db2d907e1" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被此变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="712bf5b3c0722204bbfa5e5b29cc7f28e9d26a6a" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被此变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="170135375b67e03b02c70f49ab98d2f0cdc114a4" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被该变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07172365937f11c692e2378e135c9de0a6c4fc1d" translate="yes" xml:space="preserve">
          <source>Non-I/O exceptions are not caught by this variant; to catch all exceptions, use &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;.</source>
          <target state="translated">非I / O异常不会被该变量捕获；捕获所有异常，使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;control-exception&quot;&gt;Control.Exception&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a175d95577964fb56cb4711f1d7a40794f1985b" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。</target>
        </trans-unit>
        <trans-unit id="25aed430b07f146833188f2c98703c7e3ef2511c" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。</target>
        </trans-unit>
        <trans-unit id="15bf21e487b389622890a596e34f6fc7e8f358bf" translate="yes" xml:space="preserve">
          <source>Non-breaking space.</source>
          <target state="translated">非突破性空间。</target>
        </trans-unit>
        <trans-unit id="657f262735772874a296a8f71e1b1c62bf07d9a2" translate="yes" xml:space="preserve">
          <source>Non-empty (and non-strict) list type.</source>
          <target state="translated">非空(和非严格)列表类型。</target>
        </trans-unit>
        <trans-unit id="b5705ef9b6ed9ffaa0586c5a035fc344b83d2dc7" translate="yes" xml:space="preserve">
          <source>Non-empty stream transformations</source>
          <target state="translated">非空流转换</target>
        </trans-unit>
        <trans-unit id="66475509406517f2fea398ae5c038a688074d402" translate="yes" xml:space="preserve">
          <source>Non-empty, possibly infinite, multi-way trees; also known as &lt;em&gt;rose trees&lt;/em&gt;.</source>
          <target state="translated">非空的，可能是无限的多路树；又称&lt;em&gt;玫瑰树&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="118fcb6b47ea6e15234cae7f675b98f3c5573c53" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">非孤儿 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例只为限定 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 和以后; &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;半组&lt;/a&gt;软件包提供了较旧的GHC的孤立实例</target>
        </trans-unit>
        <trans-unit id="ecdd09903f2088ad3dbc8beaa6ad86be3ab5df1c" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">非孤儿 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例只为限定 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 和以后; &lt;a href=&quot;http://hackage.haskell.org/package/semigroups&quot;&gt;半组&lt;/a&gt;软件包提供了较旧的GHC的孤立实例</target>
        </trans-unit>
        <trans-unit id="e92086f9c87448dcbfcc888dbd80a2acee59efe1" translate="yes" xml:space="preserve">
          <source>Non-orphan &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance only defined for &lt;code&gt;base-4.9.0.0&lt;/code&gt; and later; orphan instances for older GHCs are provided by the &lt;a href=&quot;https://hackage.haskell.org/package/semigroups&quot;&gt;semigroups&lt;/a&gt; package</source>
          <target state="translated">非孤儿 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例只为限定 &lt;code&gt;base-4.9.0.0&lt;/code&gt; 和以后; &lt;a href=&quot;https://hackage.haskell.org/package/semigroups&quot;&gt;半组&lt;/a&gt;软件包提供了较旧的GHC的孤立实例</target>
        </trans-unit>
        <trans-unit id="32a62670f2797b774ced2a5536c4d0d7d1acb628" translate="yes" xml:space="preserve">
          <source>Non-portable (Win32 API)</source>
          <target state="translated">非便携式(Win32 API)</target>
        </trans-unit>
        <trans-unit id="de79a7eacd9c8f0b77168b00c602dc91ea05f6b2" translate="yes" xml:space="preserve">
          <source>Non-portable, host-dependent</source>
          <target state="translated">非便携式、依赖主机</target>
        </trans-unit>
        <trans-unit id="92677a20e8a5fd94c0d5c1b4a2da0341122cf84c" translate="yes" xml:space="preserve">
          <source>NonBlockingRead</source>
          <target state="translated">NonBlockingRead</target>
        </trans-unit>
        <trans-unit id="5b969d02f949f3f49405f19ebd47eac2c53d5a3b" translate="yes" xml:space="preserve">
          <source>NonEmpty</source>
          <target state="translated">NonEmpty</target>
        </trans-unit>
        <trans-unit id="40c6def45ece9471c76046198d964195df309603" translate="yes" xml:space="preserve">
          <source>NonSpacingMark</source>
          <target state="translated">NonSpacingMark</target>
        </trans-unit>
        <trans-unit id="b990552d62e10bbd5a741b4ac2ab3d4c18f945d9" translate="yes" xml:space="preserve">
          <source>NonTermination</source>
          <target state="translated">NonTermination</target>
        </trans-unit>
        <trans-unit id="3784bca2cdaf835e7f86ca7f9511c965f0a8c209" translate="yes" xml:space="preserve">
          <source>NondecreasingIndentation</source>
          <target state="translated">NondecreasingIndentation</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="bfdd57f5fd1d7e78a4d4d0ea99c256bf3ed1633e" translate="yes" xml:space="preserve">
          <source>None of the process-creation functions in this library wait for termination: they all return a &lt;code&gt;&lt;a href=&quot;system-process#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; which may be used to wait for the process later.</source>
          <target state="translated">该库中没有任何进程创建函数等待终止：它们都返回一个 &lt;code&gt;&lt;a href=&quot;system-process#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; ，该函数可用于稍后等待进程。</target>
        </trans-unit>
        <trans-unit id="c599027fb1d35ffa00b3e30d51774d4325f6d3cd" translate="yes" xml:space="preserve">
          <source>None of the process-creation functions in this library wait for termination: they all return a &lt;code&gt;&lt;a href=&quot;system-process-internals#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; which may be used to wait for the process later.</source>
          <target state="translated">该库中没有任何进程创建函数等待终止：它们都返回一个 &lt;code&gt;&lt;a href=&quot;system-process-internals#t:ProcessHandle&quot;&gt;ProcessHandle&lt;/a&gt;&lt;/code&gt; ，可用于稍后等待进程。</target>
        </trans-unit>
        <trans-unit id="64d718b604b802439e898076aa4d8e2656afd5eb" translate="yes" xml:space="preserve">
          <source>None of these restrictions are enforced at compile time. Failure to heed these restrictions will lead to runtime errors that can be very difficult to track down. (The errors likely will not manifest until garbage collection happens.) In tabular form, these restrictions are:</source>
          <target state="translated">这些限制都不是在编译时执行的。如果不注意这些限制,将导致运行时的错误,而这些错误是很难追踪的。(这些错误很可能在垃圾收集发生之前不会表现出来。)以表格的形式,这些限制是。</target>
        </trans-unit>
        <trans-unit id="179bfbb77ce151401fc8902ad181e29e5aa72b44" translate="yes" xml:space="preserve">
          <source>None of these scenarios gives rise to an error on its own &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;1&lt;/a&gt;, but they may have some interesting consequences. For instance, if you have a type &lt;code&gt;M.T&lt;/code&gt; from version 1 of package &lt;code&gt;P&lt;/code&gt;, then this is &lt;em&gt;not&lt;/em&gt; the same as the type &lt;code&gt;M.T&lt;/code&gt; from version 2 of package &lt;code&gt;P&lt;/code&gt;, and GHC will report an error if you try to use one where the other is expected.</source>
          <target state="translated">这些情况都不会单独产生错误&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;1&lt;/a&gt;，但是它们可能会产生一些有趣的后果。举例来说，如果你有型 &lt;code&gt;M.T&lt;/code&gt; 从包的版本1 &lt;code&gt;P&lt;/code&gt; ，那么这是&lt;em&gt;不&lt;/em&gt;一样的类型 &lt;code&gt;M.T&lt;/code&gt; 从包的版本2 &lt;code&gt;P&lt;/code&gt; ，如果您尝试使用一个在其他预计GHC将报错。</target>
        </trans-unit>
        <trans-unit id="7a74eb719911afcf06b21975147c785a0bc25d01" translate="yes" xml:space="preserve">
          <source>None of these scenarios gives rise to an error on its own &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, but they may have some interesting consequences. For instance, if you have a type &lt;code&gt;M.T&lt;/code&gt; from version 1 of package &lt;code&gt;P&lt;/code&gt;, then this is &lt;em&gt;not&lt;/em&gt; the same as the type &lt;code&gt;M.T&lt;/code&gt; from version 2 of package &lt;code&gt;P&lt;/code&gt;, and GHC will report an error if you try to use one where the other is expected.</source>
          <target state="translated">这些情况都不会单独导致错误&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;，但可能会产生一些有趣的后果。举例来说，如果你有型 &lt;code&gt;M.T&lt;/code&gt; 从包的版本1 &lt;code&gt;P&lt;/code&gt; ，那么这是&lt;em&gt;不&lt;/em&gt;一样的类型 &lt;code&gt;M.T&lt;/code&gt; 从包的版本2 &lt;code&gt;P&lt;/code&gt; ，如果您尝试使用一个在其他预计GHC将报错。</target>
        </trans-unit>
        <trans-unit id="69de0eaa26a62ea07b1802cfb77025b19669e630" translate="yes" xml:space="preserve">
          <source>None, one or many flags: FORCE_DOWNLOAD, NEW_SESSION, LOGON_UI, PASSWORD_UI</source>
          <target state="translated">无,一个或多个标志。FORCE_DOWNLOAD,NEW_SESSION,LOGON_UI,PASSWORD_UI。</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="3956b2dc6672b7a8aeba865f33ebd6d3f65e6bf3" translate="yes" xml:space="preserve">
          <source>Nor this, since we can&amp;rsquo;t match the type variable &lt;code&gt;b&lt;/code&gt; with the concrete type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">也不是，因为我们无法将类型变量 &lt;code&gt;b&lt;/code&gt; 与具体类型 &lt;code&gt;Int&lt;/code&gt; 相匹配：</target>
        </trans-unit>
        <trans-unit id="d20bdaf69fe8a19867cb42c9cdb8f5cb996bbe72" translate="yes" xml:space="preserve">
          <source>Normal GHC command-line options may also be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;. For example, to turn on &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;, you would say:</source>
          <target state="translated">普通的GHC命令行选项也可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置&lt;/a&gt;。例如，要打开&lt;a href=&quot;using-warnings#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt;，您将说：</target>
        </trans-unit>
        <trans-unit id="513df9742a975687401c53473a16fb97236fc768" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">普通渲染（尊重 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; '）。</target>
        </trans-unit>
        <trans-unit id="8783461cc620ec6206ab159d2917107156d93ac4" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">普通渲染（尊重 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; '）。</target>
        </trans-unit>
        <trans-unit id="1141a9ad4c5428e5700498684f4c71b8dcf76603" translate="yes" xml:space="preserve">
          <source>Normal rendering (&lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; respected').</source>
          <target state="translated">普通渲染（尊重 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:lineLength&quot;&gt;lineLength&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:ribbonsPerLine&quot;&gt;ribbonsPerLine&lt;/a&gt;&lt;/code&gt; '）。</target>
        </trans-unit>
        <trans-unit id="22f3e78d5abb68171706a8fafe82f673d997000a" translate="yes" xml:space="preserve">
          <source>Normalise a file</source>
          <target state="translated">归一化文件</target>
        </trans-unit>
        <trans-unit id="611ffe5a187425b7883a55311ee06c6a7a49d00e" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; replaces the default package stack. For example, all of the following commands are equivalent, creating a stack with db1 at the top followed by db2 (use &lt;code&gt;;&lt;/code&gt; instead of &lt;code&gt;:&lt;/code&gt; on Windows):</source>
          <target state="translated">通常， &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 会替换默认的程序包堆栈。例如，所有以下命令是等效的，在顶部创建与DB1堆叠随后DB2（使用 &lt;code&gt;;&lt;/code&gt; 而不是 &lt;code&gt;:&lt;/code&gt; 在Windows上）：</target>
        </trans-unit>
        <trans-unit id="c4d28ac1c5fe75c0d62d49db7673ea2ff1f98808" translate="yes" xml:space="preserve">
          <source>Normally GHC will do a reasonable job of deciding by itself when it is a good idea to inline a function. However, sometimes you might want to override the default behaviour. For example, if you have a key function that is important to inline because it leads to further optimisations, but GHC judges it to be too big to inline.</source>
          <target state="translated">通常情况下,GHC会自行决定何时内联一个函数是个好主意。然而,有时你可能想要覆盖默认行为。例如,如果你有一个重要的关键函数需要内联,因为它可以带来进一步的优化,但是GHC判断它太大了,不能内联。</target>
        </trans-unit>
        <trans-unit id="eded18b2562ae6d637501fe2701b0cdec14061a3" translate="yes" xml:space="preserve">
          <source>Normally GHCi runs the interpreted code in the same process as GHC itself, on top of the same RTS and sharing the same heap. However, if the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; is given, then GHC will spawn a separate process for running interpreted code, and communicate with it using messages over a pipe.</source>
          <target state="translated">通常，GHCi在与GHC本身相同的过程中，在相同的RTS之上并共享相同的堆，运行解释后的代码。但是，如果给出了&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;标志，那么GHC将生成一个单独的进程来运行解释后的代码，并通过管道使用消息与之通信。</target>
        </trans-unit>
        <trans-unit id="c241ae0454c5e6b2d8549ed450bb4a03abf609b0" translate="yes" xml:space="preserve">
          <source>Normally a profile is limited to 20 bands with additional identifiers being grouped into an &lt;code&gt;OTHER&lt;/code&gt; band. The &lt;code&gt;-l&lt;/code&gt; flag removes this 20 band and limit, producing as many bands as necessary. No key is produced as it won&amp;rsquo;t fit!. It is useful for creation time profiles with many bands.</source>
          <target state="translated">通常，配置文件仅限于20个频段，其他标识符分组为 &lt;code&gt;OTHER&lt;/code&gt; 频段。的 &lt;code&gt;-l&lt;/code&gt; 标志除去这20条带和限制，从而产生尽可能多的频带是必要的。没有密钥，因为它不合适！这对于创建具有多个频段的时间配置文件很有用。</target>
        </trans-unit>
        <trans-unit id="64c59b3d2432ce6c3b8d68909de92442ecb84597" translate="yes" xml:space="preserve">
          <source>Normally a profile is limited to 20 bands with additional identifiers being grouped into an &lt;code&gt;OTHER&lt;/code&gt; band. The &lt;code&gt;-m&lt;/code&gt; flag specifies an alternative band limit (the maximum is 20).</source>
          <target state="translated">通常，配置文件仅限于20个频段，其他标识符分组为 &lt;code&gt;OTHER&lt;/code&gt; 频段。所述 &lt;code&gt;-m&lt;/code&gt; 标志指定的替代频带限制（最大为20）。</target>
        </trans-unit>
        <trans-unit id="558fdf57db5511e0c5ebfaa119295e9295b0c4b3" translate="yes" xml:space="preserve">
          <source>Normally pre-compiled code for a module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces a module to be loaded as byte-code.</source>
          <target state="translated">通常，将加载模块的预编译代码（如果可用），否则，模块将被编译为字节码。使用 &lt;code&gt;*&lt;/code&gt; 前缀强制将模块作为字节码加载。</target>
        </trans-unit>
        <trans-unit id="ecdcacb1582613bd12eb621f5b461a7931c33bbc" translate="yes" xml:space="preserve">
          <source>Normally there is no fixed relationship between Haskell threads and OS threads. This means that when you make a foreign call, that call may take place in an unspecified OS thread. Furthermore, there is no guarantee that multiple calls made by one Haskell thread will be made by the same OS thread.</source>
          <target state="translated">通常Haskell线程和OS线程之间没有固定的关系。这意味着,当你进行一个外来调用时,该调用可能会发生在一个未指定的OS线程中。此外,也不能保证一个Haskell线程进行的多次调用会被同一个OS线程进行。</target>
        </trans-unit>
        <trans-unit id="937628f8a7dc9eb81b2263a9e21be33c5aea1828" translate="yes" xml:space="preserve">
          <source>Normally trace elements which sum to a total of less than 1% of the profile are removed from the profile. The &lt;code&gt;-t&lt;/code&gt; option allows this percentage to be modified (maximum 5%).</source>
          <target state="translated">通常，从轮廓中删除总计少于轮廓的1％的痕量元素。的 &lt;code&gt;-t&lt;/code&gt; 选项允许这一百分比要被修改（最多5％）。</target>
        </trans-unit>
        <trans-unit id="4d52c3563db7da009beb065365791027b03554cf" translate="yes" xml:space="preserve">
          <source>Normally ⟨x⟩ should be chosen to match the number of CPU cores on the machine &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. For example, on a dual-core machine we would probably use &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt;.</source>
          <target state="translated">通常应选择&amp;ldquo; &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;x&amp;rdquo;&lt;/a&gt;以匹配计算机1上的CPU内核数。例如，在双核计算机上，我们可能会使用 &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1424cc5421e827770c2528e2d213a27497f17fe" translate="yes" xml:space="preserve">
          <source>Normally ⟨x⟩ should be chosen to match the number of CPU cores on the machine &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. For example, on a dual-core machine we would probably use &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt;.</source>
          <target state="translated">通常应选择&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;&amp;ldquo; x&amp;rdquo;&lt;/a&gt;以匹配计算机上的CPU内核数[1]。例如，在双核计算机上，我们可能会使用 &lt;code&gt;+RTS -N2 -RTS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adae5b8f3d2301963310d04fce57a7e110596baf" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;hp2ps&lt;/code&gt; puts the title of the graph in a small box at the top of the page. However, if the JOB string is too long to fit in a small box (more than 35 characters), then &lt;code&gt;hp2ps&lt;/code&gt; will choose to use a big box instead. The &lt;code&gt;-b&lt;/code&gt; option forces &lt;code&gt;hp2ps&lt;/code&gt; to use a big box.</source>
          <target state="translated">通常， &lt;code&gt;hp2ps&lt;/code&gt; 将图形的标题放在页面顶部的小框中。但是，如果JOB字符串太长而无法容纳在一个小盒子（超过35个字符）中，则 &lt;code&gt;hp2ps&lt;/code&gt; 将选择使用一个大盒子代替。该 &lt;code&gt;-b&lt;/code&gt; 选项强制 &lt;code&gt;hp2ps&lt;/code&gt; 用一个大箱子。</target>
        </trans-unit>
        <trans-unit id="c386c8961f160187b7f41a883437a0e96c21de44" translate="yes" xml:space="preserve">
          <source>Normally, &lt;em&gt;constraints&lt;/em&gt; (which appear in types to the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; arrow) have a very restricted syntax. They can only be:</source>
          <target state="translated">通常，&lt;em&gt;约束&lt;/em&gt;（以 &lt;code&gt;=&amp;gt;&lt;/code&gt; 箭头的左侧类型显示）的语法非常受限制。它们只能是：</target>
        </trans-unit>
        <trans-unit id="5f3b656a0be36fb8e60655756fc57d49ccf589ac" translate="yes" xml:space="preserve">
          <source>Normally, GHC&amp;rsquo;s runtime system provides a &lt;code&gt;main()&lt;/code&gt;, which arranges to invoke &lt;code&gt;Main.main&lt;/code&gt; in the Haskell program. However, you might want to link some Haskell code into a program which has a main function written in another language, say C. In order to do this, you have to initialize the Haskell runtime system explicitly.</source>
          <target state="translated">通常，GHC的运行时系统提供 &lt;code&gt;main()&lt;/code&gt; ，它安排在Haskell程序中调用 &lt;code&gt;Main.main&lt;/code&gt; 。但是，您可能需要将某些Haskell代码链接到一个程序，该程序具有用另一种语言编写的主要功能（例如C）。为此，必须显式初始化Haskell运行时系统。</target>
        </trans-unit>
        <trans-unit id="b5878d2676aa27f57a51768346833740d2d73c3e" translate="yes" xml:space="preserve">
          <source>Normally, a permutation parser is first build with special operators like (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) and than transformed into a normal parser using &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常，首先使用（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ）之类的特殊运算符来构建置换解析器，然后使用 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 将其转换为普通解析器。</target>
        </trans-unit>
        <trans-unit id="be63fc241b13b25bbbfbb8119202738448bc7f25" translate="yes" xml:space="preserve">
          <source>Normally, any evaluation of top-level expressions (otherwise known as CAFs or Constant Applicative Forms) in loaded modules is retained between evaluations. Turning on &lt;code&gt;+r&lt;/code&gt; causes all evaluation of top-level expressions to be discarded after each evaluation (they are still retained &lt;em&gt;during&lt;/em&gt; a single evaluation).</source>
          <target state="translated">通常，在评估之间保留对已加载模块中顶级表达式（也称为CAF或常量应用形式）的任何评估。开启 &lt;code&gt;+r&lt;/code&gt; 会使所有顶级表达式的求值在每次求值后都被丢弃（在一次求值&lt;em&gt;期间&lt;/em&gt;它们仍保留）。</target>
        </trans-unit>
        <trans-unit id="cd32d0c154484c3ec18509a839994848298d2636" translate="yes" xml:space="preserve">
          <source>Normally, setting the &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-V ⟨secs⟩&lt;/code&gt;&lt;/a&gt; option directly is not necessary: the resolution of the RTS timer is adjusted automatically if a short interval is requested with the &lt;code&gt;-C ⟨s⟩&lt;/code&gt; or &lt;a href=&quot;#rts-flag--i%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-i
⟨secs⟩&lt;/code&gt;&lt;/a&gt; options. However, setting &lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt;&lt;code&gt;-V ⟨secs⟩&lt;/code&gt;&lt;/a&gt; is required in order to increase the resolution of the time profiler.</source>
          <target state="translated">通常，没有必要直接设置&lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; &lt;/a&gt;选项：如果使用 &lt;code&gt;-C ⟨s⟩&lt;/code&gt; 或&lt;a href=&quot;#rts-flag--i%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-i ⟨secs⟩&lt;/code&gt; &lt;/a&gt;选项请求较短的间隔，则会自动调整RTS计时器的分辨率。但是，需要设置&lt;a href=&quot;#rts-flag--V%20%E2%9F%A8secs%E2%9F%A9&quot;&gt; &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; &lt;/a&gt;才能提高时间分析器的分辨率。</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="78ccb4fb66097bf7ec98982f1e04cc05bbdcec21" translate="yes" xml:space="preserve">
          <source>Not all subexpressions are potential breakpoint locations. Single variables are typically not considered to be breakpoint locations (unless the variable is the right-hand-side of a function definition, lambda, or case alternative). The rule of thumb is that all redexes are breakpoint locations, together with the bodies of functions, lambdas, case alternatives and binding statements. There is normally no breakpoint on a let expression, but there will always be a breakpoint on its body, because we are usually interested in inspecting the values of the variables bound by the let.</source>
          <target state="translated">并非所有的子表达式都是潜在的断点位置。单个变量通常不被认为是断点位置(除非该变量是函数定义、lambda或case alternative的右侧)。经验法则是,所有的redexes都是断点位置,还有函数、lambdas、case alternative和绑定语句的主体。通常在let表达式上没有断点,但在它的主体上总会有一个断点,因为我们通常对检查由let绑定的变量的值感兴趣。</target>
        </trans-unit>
        <trans-unit id="4ab7fbf9aa0be7d87015cd3b43f6141b9208bf3f" translate="yes" xml:space="preserve">
          <source>Not all systems support &lt;code&gt;utimensat&lt;/code&gt;, in which case the function can only emulate the behavior by reading the access time and then setting both the access and modification times together. On systems where &lt;code&gt;utimensat&lt;/code&gt; is supported, the modification time is set atomically with nanosecond precision.</source>
          <target state="translated">并非所有系统都支持 &lt;code&gt;utimensat&lt;/code&gt; ，在这种情况下，该功能只能通过读取访问时间，然后同时设置访问时间和修改时间来模拟行为。在支持 &lt;code&gt;utimensat&lt;/code&gt; 的系统上，修改时间以原子级精度设置为纳秒。</target>
        </trans-unit>
        <trans-unit id="fa0085970940cf874c9d2594cf9d4dd7a8d8194f" translate="yes" xml:space="preserve">
          <source>Not all systems support &lt;code&gt;utimensat&lt;/code&gt;, in which case the function can only emulate the behavior by reading the modification time and then setting both the access and modification times together. On systems where &lt;code&gt;utimensat&lt;/code&gt; is supported, the access time is set atomically with nanosecond precision.</source>
          <target state="translated">并非所有系统都支持 &lt;code&gt;utimensat&lt;/code&gt; ，在这种情况下，该功能只能通过读取修改时间，然后同时设置访问时间和修改时间来模拟行为。在支持 &lt;code&gt;utimensat&lt;/code&gt; 的系统上，原子访问时间的原子级设置为ns。</target>
        </trans-unit>
        <trans-unit id="b2afb94fa1ad8b2117ab0fcdb5aa0be0a87a1018" translate="yes" xml:space="preserve">
          <source>Not combined (tricky):</source>
          <target state="translated">不结合(棘手)。</target>
        </trans-unit>
        <trans-unit id="c0dd126e18fca943161e0d20a36b21e212c3c99b" translate="yes" xml:space="preserve">
          <source>Not combined:</source>
          <target state="translated">未合并。</target>
        </trans-unit>
        <trans-unit id="78133acc4cfff50b8f073295fd4a15e10edaae9e" translate="yes" xml:space="preserve">
          <source>Not every index within the bounds of the array need appear in the association list, but the values associated with indices that do not appear will be undefined (i.e. bottom).</source>
          <target state="translated">并非数组范围内的每个索引都需要出现在关联列表中,但没有出现的索引所关联的值将是未定义的(即底部)。</target>
        </trans-unit>
        <trans-unit id="a5c24f03828759592657815b91d4e8eac318fcb9" translate="yes" xml:space="preserve">
          <source>Not every index within the bounds of the array need appear in the association list, but the values associated with indices that do not appear will be undefined.</source>
          <target state="translated">并非数组范围内的每个索引都需要出现在关联列表中,但与未出现的索引相关联的值将被未定义。</target>
        </trans-unit>
        <trans-unit id="b8634acd7e6ee3c03ecde3208f3a307f2f045508" translate="yes" xml:space="preserve">
          <source>Not only do we now know the type of &lt;code&gt;left&lt;/code&gt;, but all the other partial types have also been resolved. So we can ask for the value of &lt;code&gt;a&lt;/code&gt;, for example:</source>
          <target state="translated">现在，我们不仅知道 &lt;code&gt;left&lt;/code&gt; 的类型，而且还解析了所有其他部分类型。因此，我们可以要求 &lt;code&gt;a&lt;/code&gt; 的值，例如：</target>
        </trans-unit>
        <trans-unit id="4035b9c2b5847ce2b4b7d233cc698ae5fa143ff0" translate="yes" xml:space="preserve">
          <source>Not-equal predicate.</source>
          <target state="translated">不等式谓词。</target>
        </trans-unit>
        <trans-unit id="122fe604627a6b3c6c7479e2e3d9b217a06c8a81" translate="yes" xml:space="preserve">
          <source>NotAssigned</source>
          <target state="translated">NotAssigned</target>
        </trans-unit>
        <trans-unit id="029164befa1985fe4c7c950daf75d5070657a309" translate="yes" xml:space="preserve">
          <source>NotAssociative</source>
          <target state="translated">NotAssociative</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="54ab9353b38cfd8cfc741410b64bcd8b4ace3d86" translate="yes" xml:space="preserve">
          <source>Note also that the following declaration is not allowed, even by itself:</source>
          <target state="translated">还请注意,以下声明是不允许的,即使是其本身。</target>
        </trans-unit>
        <trans-unit id="e14be39fd5d5beacf8aca731e7b645e488e01620" translate="yes" xml:space="preserve">
          <source>Note also the following points</source>
          <target state="translated">还要注意以下几点</target>
        </trans-unit>
        <trans-unit id="e391e16c3d6dadad7a54ff544e2321aabfc38d3d" translate="yes" xml:space="preserve">
          <source>Note also the inter-module dependencies at the end of the Makefile, which take the form</source>
          <target state="translated">也请注意Makefile结尾处的模块间依赖关系,其形式为</target>
        </trans-unit>
        <trans-unit id="0f69bf791521771e7eed4606436969fb2e27e8cf" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">请注意，此运算符与功能组合 &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 相似：</target>
        </trans-unit>
        <trans-unit id="c5d2df4cb0a27c46da53e1c8dd36d7ee084e8ccd" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">请注意此运算符与函数组合 &lt;code&gt;(&lt;a href=&quot;../base-4.14.1.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 相似之处：</target>
        </trans-unit>
        <trans-unit id="3cdf7a8e9b7d9967c0312d67976a62b0219eb7cd" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">请注意此运算符与函数组合 &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 相似之处：</target>
        </trans-unit>
        <trans-unit id="58c74ad1a011259a6e943fb74b3e3c3c2695a3b0" translate="yes" xml:space="preserve">
          <source>Note how this operator resembles function composition &lt;code&gt;(&lt;a href=&quot;data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt;:</source>
          <target state="translated">请注意，此运算符与功能组合 &lt;code&gt;(&lt;a href=&quot;data-function#v:.&quot;&gt;.&lt;/a&gt;)&lt;/code&gt; 相似：</target>
        </trans-unit>
        <trans-unit id="9feb1e502abb28d277cb1a7670feb6125b53c153" translate="yes" xml:space="preserve">
          <source>Note how we can define a uniform instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;, because we completely disregard all meta-information:</source>
          <target state="translated">注意我们如何为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 定义一个统一实例，因为我们完全忽略了所有元信息：</target>
        </trans-unit>
        <trans-unit id="45519c1953b86b55e65ecc080a301283fb324351" translate="yes" xml:space="preserve">
          <source>Note how we write an initial tag byte to indicate each variant of the data type.</source>
          <target state="translated">请注意,我们如何写一个初始标签字节来表示数据类型的每个变体。</target>
        </trans-unit>
        <trans-unit id="c9cb756c35baef541318a2fa53e969cf959a31f5" translate="yes" xml:space="preserve">
          <source>Note in particular that the main program thread (the thread running &lt;code&gt;Main.main&lt;/code&gt;) is always a bound thread, so for good concurrency performance you should ensure that the main thread is not doing repeated communication with other threads in the system. Typically this means forking subthreads to do the work using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, and waiting for the results in the main thread.</source>
          <target state="translated">特别要注意的是，主程序线程（运行 &lt;code&gt;Main.main&lt;/code&gt; 的线程）始终是绑定线程，因此，为了获得良好的并发性能，您应确保主线程未与系统中的其他线程进行重复通信。通常，这意味着派生子线程使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 进行工作，并在主线程中等待结果。</target>
        </trans-unit>
        <trans-unit id="31f3f6f5adc996e06ed48014b2b93cc6d3ecc2dc" translate="yes" xml:space="preserve">
          <source>Note in particular that the translation for a &lt;code&gt;rec&lt;/code&gt; block only involves wrapping a call to &lt;code&gt;mfix&lt;/code&gt;: it performs no other analysis on the bindings. The latter is the task for the &lt;code&gt;mdo&lt;/code&gt; notation, which is described next.</source>
          <target state="translated">特别要注意的是， &lt;code&gt;rec&lt;/code&gt; 块的转换仅涉及包装对 &lt;code&gt;mfix&lt;/code&gt; 的调用：它不对绑定执行任何其他分析。后者是 &lt;code&gt;mdo&lt;/code&gt; 表示法的任务，将在下面进行描述。</target>
        </trans-unit>
        <trans-unit id="3639d52b7d40ee212b47bb683d401fdb19f2b8d7" translate="yes" xml:space="preserve">
          <source>Note on rewrite rules:</source>
          <target state="translated">关于改写规则的说明。</target>
        </trans-unit>
        <trans-unit id="da7038b6159ab37164aeb7442907c881108aff7e" translate="yes" xml:space="preserve">
          <source>Note that</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="2bbeb687e1b7425b59bec3bcf47cccd24fd58a0f" translate="yes" xml:space="preserve">
          <source>Note that (7.) and (8.) do &lt;em&gt;not&lt;/em&gt; require &lt;code&gt;&lt;a href=&quot;data-ord#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; to return either of their arguments. The result is merely required to &lt;em&gt;equal&lt;/em&gt; one of the arguments in terms of &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，（7）和（8）都&lt;em&gt;没有&lt;/em&gt;要求 &lt;code&gt;&lt;a href=&quot;data-ord#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ord#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; 要么返回他们的论据。仅要求结果&lt;em&gt;等于&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt; 的参数之一。</target>
        </trans-unit>
        <trans-unit id="3e828fd5138d7798acc9021c701b389b03f3b726" translate="yes" xml:space="preserve">
          <source>Note that (7.) and (8.) do &lt;em&gt;not&lt;/em&gt; require &lt;code&gt;&lt;a href=&quot;prelude#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; to return either of their arguments. The result is merely required to &lt;em&gt;equal&lt;/em&gt; one of the arguments in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，（7）和（8）都&lt;em&gt;没有&lt;/em&gt;要求 &lt;code&gt;&lt;a href=&quot;prelude#v:min&quot;&gt;min&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:max&quot;&gt;max&lt;/a&gt;&lt;/code&gt; 要么返回他们的论据。仅要求结果&lt;em&gt;等于&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;(==)&lt;/a&gt;&lt;/code&gt; 的参数之一。</target>
        </trans-unit>
        <trans-unit id="041e17d2804b0af5a76a5a97a0bba4a277288826" translate="yes" xml:space="preserve">
          <source>Note that 0 &amp;lt;= &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:todSec&quot;&gt;todSec&lt;/a&gt;&lt;/code&gt; &amp;lt; 61, accomodating leap seconds. Any local minute may have a leap second, since leap seconds happen in all zones simultaneously</source>
          <target state="translated">注意0 &amp;lt;= &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:todSec&quot;&gt;todSec&lt;/a&gt;&lt;/code&gt; &amp;lt;61，可容纳，秒。任何本地分钟都可能具有a秒，因为leap秒在所有区域中同时发生</target>
        </trans-unit>
        <trans-unit id="4fc3cfabe43b8bcfa1705a3dbc018667744dc410" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-via&quot;&gt;Deriving via&lt;/a&gt;) uses essentially the same specification to derive instances of associated type families as well (except that it uses the &lt;code&gt;via&lt;/code&gt; type instead of the underlying &lt;code&gt;rep-type&lt;/code&gt; of a newtype).</source>
          <target state="translated">请注意，&lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#deriving-via&quot;&gt;Deriving via&lt;/a&gt;）也使用基本上相同的规范来派生关联类型系列的实例（除了它使用 &lt;code&gt;via&lt;/code&gt; 类型而不是 &lt;code&gt;rep-type&lt;/code&gt; 的基础rep-type）。</target>
        </trans-unit>
        <trans-unit id="20cfa8d6154c21f756b99008f5e887fb998ca694" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt;&lt;code&gt;-Wunused-matches&lt;/code&gt;&lt;/a&gt; does not warn about variables which arise from type-level patterns, as found in type family and data family instances. This must be enabled separately through the &lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">请注意，&lt;a href=&quot;#ghc-flag--Wunused-matches&quot;&gt; &lt;code&gt;-Wunused-matches&lt;/code&gt; &lt;/a&gt;不会警告在类型系列和数据系列实例中发现的由类型级别模式引起的变量。必须通过&lt;a href=&quot;#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;标志单独启用它。</target>
        </trans-unit>
        <trans-unit id="a0394f5adfc4a1a13e3b86c72f2c51c040f42596" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt;&lt;code&gt;--nonmoving-gc&lt;/code&gt;&lt;/a&gt; cannot be used with &lt;code&gt;-G1&lt;/code&gt;, &lt;a href=&quot;profiling#rts-flag--hc&quot;&gt;&lt;code&gt;profiling&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，-- &lt;a href=&quot;#rts-flag---nonmoving-gc&quot;&gt; &lt;code&gt;--nonmoving-gc&lt;/code&gt; &lt;/a&gt;不能与 &lt;code&gt;-G1&lt;/code&gt; ，&lt;a href=&quot;profiling#rts-flag--hc&quot;&gt; &lt;code&gt;profiling&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 一起使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="115cb711c4af39c249438db0b383137d0cb50d56" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;deriving_via#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;deriving_via#deriving-via&quot;&gt;Deriving via&lt;/a&gt;) uses essentially the same specification to derive instances of associated type families as well (except that it uses the &lt;code&gt;via&lt;/code&gt; type instead of the underlying &lt;code&gt;rep-type&lt;/code&gt; of a newtype).</source>
          <target state="translated">请注意，&lt;a href=&quot;deriving_via#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;deriving_via#deriving-via&quot;&gt;Deriving via&lt;/a&gt;）也使用基本上相同的规范来派生关联类型族的实例（除了它使用 &lt;code&gt;via&lt;/code&gt; 类型而不是 &lt;code&gt;rep-type&lt;/code&gt; 的基础rep-type）。</target>
        </trans-unit>
        <trans-unit id="bf7f360a57aee7e3f0b50c89a317cf8b42dfa6db" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">注意 &lt;code&gt;(&lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 在其结果类型中是多态的，因此 &lt;code&gt;foo &lt;a href=&quot;data-function#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; ，其中 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 是正确类型的。</target>
        </trans-unit>
        <trans-unit id="50352b9744490cab4f40a77337fe0f29b0ce0106" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">注意 &lt;code&gt;(&lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 在其结果类型中是多态的，因此 &lt;code&gt;foo &lt;a href=&quot;ghc-base#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; ，其中 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 是正确类型的。</target>
        </trans-unit>
        <trans-unit id="e8b2b6839b756e03ca674d6cc20259793fba403d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; is levity-polymorphic in its result type, so that &lt;code&gt;foo &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; where &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; is well-typed.</source>
          <target state="translated">注意 &lt;code&gt;(&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;)&lt;/code&gt; 在其结果类型中是多态的，因此 &lt;code&gt;foo &lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt; True&lt;/code&gt; ，其中 &lt;code&gt;foo :: Bool -&amp;gt; Int#&lt;/code&gt; 是正确类型的。</target>
        </trans-unit>
        <trans-unit id="123d4fdb08ddd5f13ffc17d9c9b8108ebcc613a2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(RunIO return)&lt;/code&gt; is an incorrect implementation, since it does not separate the pure and impure parts of the monadic action. This module defines implementations for several common monad transformers.</source>
          <target state="translated">请注意， &lt;code&gt;(RunIO return)&lt;/code&gt; 是不正确的实现，因为它没有将单子动作的纯净部分和不纯净部分分开。该模块定义了几种常见的monad转换器的实现。</target>
        </trans-unit>
        <trans-unit id="2364cca1f2893be828dc285c3d3e946361aaaff8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-rtsopts&lt;/code&gt; has no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意，当与&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;一起使用时， &lt;code&gt;-rtsopts&lt;/code&gt; 无效；有关详细信息，请参见&lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59f5f5ff16e9a38088c4dc6203d56f4f8fc6a9aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-rtsopts&lt;/code&gt; has no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意，当与&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;一起使用时， &lt;code&gt;-rtsopts&lt;/code&gt; 无效；有关详细信息，请参见&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7093e90bb866365952af6e50a0522c2320078eb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-with-rtsopts&lt;/code&gt; has no effect when used with &lt;code&gt;-no-hs-main&lt;/code&gt;; see &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意，当 &lt;code&gt;-with-rtsopts&lt;/code&gt; 与 &lt;code&gt;-no-hs-main&lt;/code&gt; 一起使用时，它无效。有关详细信息，请参见&lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce579c6f316db1c83cacd820fffea2c995a62db3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-with-rtsopts&lt;/code&gt; has no effect when used with &lt;code&gt;-no-hs-main&lt;/code&gt;; see &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for details.</source>
          <target state="translated">注意 &lt;code&gt;-with-rtsopts&lt;/code&gt; 与 &lt;code&gt;-no-hs-main&lt;/code&gt; 一起使用时无效；有关详细信息，请参见&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3251b2749b31476313c89aa83d9865be6457e1bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; has no concept of fairness, and there is no guarantee that threads blocked in &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; will be unblocked in the same order; in fact they will all be unblocked at the same time and will fight over the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt;. Hence &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is not suitable if you expect there to be a high number of threads contending for the resource. However, like other STM abstractions, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; is composable.</source>
          <target state="translated">注意， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 没有公平性的概念，不能保证在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; 中阻塞的线程将以相同的顺序解除阻塞。实际上，它们都将同时 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 并会为TSem争战。因此，如果您期望有大量线程争用资源，则 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 不适合。但是，与其他STM抽象一样， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; 是可组合的。</target>
        </trans-unit>
        <trans-unit id="23d023ee2a96a8f414c4d59de19543cf5936dac9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and friends &lt;em&gt;do not&lt;/em&gt; have a similar default, because there is no exception handler in this case. Don't use &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; for recovering from an asynchronous exception.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 和friends &lt;em&gt;没有&lt;/em&gt;类似的默认值，因为在这种情况下没有异常处理程序。不要使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 从异步异常中恢复。</target>
        </trans-unit>
        <trans-unit id="2718dae009fe5e3d1238b1c135ae52c90ac37837" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are a bit verbose, but quite versatile. Here is an example of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; for combined HTML escaping and UTF-8 encoding. It exploits that the escaped character with the maximal Unicode codepoint is '&amp;gt;'.</source>
          <target state="translated">注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 有点冗长，但是用途广泛。这是一个结合HTML转义和UTF-8编码的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 示例。它利用最大Unicode代码点的转义字符为'&amp;gt;'。</target>
        </trans-unit>
        <trans-unit id="cde3b09d583614c69aacef3bde117f6bdd3d0e24" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="2dc83523aa02bd92c967a0a3d0ae6d7af0d9ac4f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are &lt;code&gt;Contravariant&lt;/code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;Contravariant&lt;/code&gt; 的&lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="2ee6deeaabf24f4412e1e49868879a0b5b1aa1c9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Complex Float&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-complex#t:Complex&quot;&gt;Complex&lt;/a&gt;&lt;/code&gt; 的实例继承了type参数的不足之处。例如， &lt;code&gt;Complex Float&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="3e1f90e9e322b989e73d82fdede82115af771f84" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dced2e98ed0e357e8b533e5a5a89a9d764b8df7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;data-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dedd1659c7efcc5ad810d0e5c4b39237ba9eb03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-list#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60f7565d417c50efc94986aa99cb5f4a947f5ff6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;data-ratio#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 的实例从type参数的实例继承缺陷。例如， &lt;code&gt;Ratio Natural&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="7cefd424b19607d5edc1403e68699fc8f6d2f620" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (in the guise of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt;) can still occur in a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; representation, namely when the datatype has a field that does not mention the parameter.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; （以 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 为幌子）仍可以以 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 表示形式出现，即，当数据类型的字段中未提及参数时。</target>
        </trans-unit>
        <trans-unit id="281ca52e047c00d45cb2f86224fe53a9a4fae794" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a858cff92b21869646f30a2b371df6ee5495052" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="fc2f4f0bfb855f7375943aa12d1fb8ac219a3580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="6dbd9a25c551eff23fa22c53698220086818ffcf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;inits (xs ++ _|_) = inits xs ++ _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd1e7ed5d4e140984d3791f7195f3b569e53a3a5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3220254f0cec09ffeb96b93db4b6d62483e447b2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; has the following strictness property: &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 具有以下严格性属性： &lt;code&gt;tails _|_ = _|_ : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e52e647e2604f5fb2a960fb656ed98c28cb82a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; does not suffice for this purpose due to &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac #5041&lt;/a&gt;.</source>
          <target state="translated">请注意，由于&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/5041&quot;&gt;Trac＃5041&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; 不足以满足此目的。</target>
        </trans-unit>
        <trans-unit id="4590a66ec7900e5ee4d377de0bdd011b81fe11e5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; does not suffice for this purpose due to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5041&quot;&gt;#5041&lt;/a&gt;.</source>
          <target state="translated">请注意，由于&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5041&quot;&gt;＃5041&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readField&quot;&gt;readField&lt;/a&gt;&lt;/code&gt; 不足以满足此目的。</target>
        </trans-unit>
        <trans-unit id="08f4018cb49ca32078d9a1bef08f427eb4907a21" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt;'s instances inherit the deficiencies from the type parameter's. For example, &lt;code&gt;Ratio Natural&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance has similar problems to &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 的实例从type参数的实例继承缺陷。例如， &lt;code&gt;Ratio Natural&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例与 &lt;code&gt;&lt;a href=&quot;numeric-natural#v:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的问题类似。</target>
        </trans-unit>
        <trans-unit id="042d76d30eab792b60df6af7b09723fdf10e8be4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0之外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="e88d411cc968059e325ae13439252f0afd371b01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; instance isn't a ring: no element but 0 has an additive inverse. It is a semiring though.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 实例不是一个环：除了0以外没有元素具有加法逆。虽然这是半圆环。</target>
        </trans-unit>
        <trans-unit id="1e81757f506803c58656ee3360e5e3fcdb790671" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; for a strict variant of this function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;prelude#v:iterate&quot;&gt;iterate&lt;/a&gt;&lt;/code&gt; 是懒惰的，如果消费者不强迫每个迭代，则可能会导致积聚。有关此功能的严格变体，请参见 &lt;code&gt;&lt;a href=&quot;ghc-list#v:iterate-39-&quot;&gt;iterate'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="692875f553a19ed51b447480be26cc2da0a377bb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 将文字字符串写入文件。要像 &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样写入任何可打印类型的值，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 函数首先将值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="82ee7c2d72b3eb91473ef9443731d0f34073a559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; write a literal string to a file. To write a value of any printable type, as with &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; function to convert the value to a string first.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; 将文字字符串写入文件。要像 &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 一样写入任何可打印类型的值，请使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 函数首先将值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="b7939772f8f7e35e3f9e1df2549a55f3569ee2cb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;F0&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F2&lt;/code&gt;, &lt;code&gt;FD1&lt;/code&gt;, and &lt;code&gt;FD2&lt;/code&gt; all have identical standalone kind signatures. The arity is inferred from the type family header.</source>
          <target state="translated">请注意， &lt;code&gt;F0&lt;/code&gt; ， &lt;code&gt;F1&lt;/code&gt; ， &lt;code&gt;F2&lt;/code&gt; ， &lt;code&gt;FD1&lt;/code&gt; 和 &lt;code&gt;FD2&lt;/code&gt; 都具有相同的独立种类签名。从类型族头中推断出Arity。</target>
        </trans-unit>
        <trans-unit id="b8ad5d4ac1dbd955a15cabf62ecf4ebbe8794aa4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;FUN m a b&lt;/code&gt; permits levity-polymorphism in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that types like &lt;code&gt;Int# -&amp;gt; Int#&lt;/code&gt; can still be well-kinded.</source>
          <target state="translated">请注意， &lt;code&gt;FUN m a b&lt;/code&gt; 允许 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都具有多态性，因此 &lt;code&gt;Int# -&amp;gt; Int#&lt;/code&gt; 类的类型仍然可以很好地区分。</target>
        </trans-unit>
        <trans-unit id="5a5d841ba3035a60d47bde6683188e551f1ba64a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt; or &lt;code&gt;std_out&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">请注意，通过CreateProcess记录为 &lt;code&gt;std_in&lt;/code&gt; 或 &lt;code&gt;std_out&lt;/code&gt; 提供的 &lt;code&gt;Handle&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="146678c0e776f2ff851c7e2c8dcebc022186f041" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;Handle&lt;/code&gt; s提供了 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 通过 &lt;code&gt;UseHandle&lt;/code&gt; 构造函数将调用此函数关闭。这并不总是所需的行为。如果您希望在生成子进程之后使 &lt;code&gt;Handle&lt;/code&gt; 保持打开状态，请改用 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 。所有创建的 &lt;code&gt;Handle&lt;/code&gt; 最初都处于文本模式；如果需要它们处于二进制模式，则使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ff010b0f63ecc96eaf9bd3fa189d17e640c8eb8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;Handle&lt;/code&gt; s提供了 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 通过 &lt;code&gt;UseHandle&lt;/code&gt; 构造函数将调用此函数关闭。这并不总是所需的行为。如果您希望在生成子进程之后使 &lt;code&gt;Handle&lt;/code&gt; 保持打开状态，请改用 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 。所有创建的 &lt;code&gt;Handle&lt;/code&gt; 最初都处于文本模式；如果需要它们处于二进制模式，则使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="060ea5a8335f3e38195f74d7156afc215fb95950" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the &lt;code&gt;UseHandle&lt;/code&gt; constructor will be closed by calling this function. This is not always the desired behavior. In cases where you would like to leave the &lt;code&gt;Handle&lt;/code&gt; open after spawning the child process, please use &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; instead. All created &lt;code&gt;Handle&lt;/code&gt;s are initially in text mode; if you need them to be in binary mode then use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;Handle&lt;/code&gt; s提供了 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 通过 &lt;code&gt;UseHandle&lt;/code&gt; 构造函数将调用此函数关闭。这并不总是所需的行为。如果您希望在生成子进程之后使 &lt;code&gt;Handle&lt;/code&gt; 保持打开状态，请改用 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess_&quot;&gt;createProcess_&lt;/a&gt;&lt;/code&gt; 。所有创建的 &lt;code&gt;Handle&lt;/code&gt; 最初都处于文本模式；如果需要它们处于二进制模式，则使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0bc50405f92753187a855ca32c150ffebfb1ca1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Handle&lt;/code&gt;s provided for &lt;code&gt;std_in&lt;/code&gt;, &lt;code&gt;std_out&lt;/code&gt;, or &lt;code&gt;std_err&lt;/code&gt; via the CreateProcess record will be ignored.</source>
          <target state="translated">请注意，通过CreateProcess记录为 &lt;code&gt;std_in&lt;/code&gt; ， &lt;code&gt;std_out&lt;/code&gt; 或 &lt;code&gt;std_err&lt;/code&gt; 提供的 &lt;code&gt;Handle&lt;/code&gt; 将被忽略。</target>
        </trans-unit>
        <trans-unit id="741bc7436d7860a8b9d202657fd8dd01f62d1a12" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;M.join&lt;/code&gt; is only needed if the final expression is not identifiably a &lt;code&gt;return&lt;/code&gt;. With &lt;code&gt;-XQualifiedDo&lt;/code&gt; enabled, &lt;code&gt;-XApplicativeDo&lt;/code&gt; looks only for the qualified &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;pure&lt;/code&gt; in a qualified do-block.</source>
          <target state="translated">请注意，仅当最终表达式不是可识别的 &lt;code&gt;return&lt;/code&gt; 时才需要 &lt;code&gt;M.join&lt;/code&gt; 。随着 &lt;code&gt;-XQualifiedDo&lt;/code&gt; 启用， &lt;code&gt;-XApplicativeDo&lt;/code&gt; 仅查找合格的 &lt;code&gt;return&lt;/code&gt; / &lt;code&gt;pure&lt;/code&gt; 一份合格的DO-块。</target>
        </trans-unit>
        <trans-unit id="fb75a50ee8a25d92207e02df9efd12ab2bbd9b08" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\case&lt;/code&gt; starts a layout, so you can write</source>
          <target state="translated">请注意 &lt;code&gt;\case&lt;/code&gt; 开始布局，因此您可以编写</target>
        </trans-unit>
        <trans-unit id="ef8c98fb1e9ccb919f4d179a7222663f9bc06990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;f&lt;/code&gt; is not overloaded; the &lt;code&gt;Eq&lt;/code&gt; constraint arising from the use of &lt;code&gt;==&lt;/code&gt; is discharged by the pattern match on &lt;code&gt;T1&lt;/code&gt; and similarly the &lt;code&gt;Show&lt;/code&gt; constraint arising from the use of &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;f&lt;/code&gt; 没有过载。使用 &lt;code&gt;==&lt;/code&gt; 引起的 &lt;code&gt;Eq&lt;/code&gt; 约束由 &lt;code&gt;T1&lt;/code&gt; 上的模式匹配释放，并且类似地，由于使用 &lt;code&gt;show&lt;/code&gt; 产生 &lt;code&gt;Show&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="01a09441c6e85b11dd8ac3855c0f8d219030d13a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ghc -M&lt;/code&gt; 需要在依赖关系图中为每个模块找到一个&lt;em&gt;源文件&lt;/em&gt;，以便它可以解析导入声明并遵循依赖关系。因此，任何没有源文件的预编译模块都必须属于程序包&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5d5971cd304a24fd7e0c3cb761f12d88c0c5300" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ghc -M&lt;/code&gt; needs to find a &lt;em&gt;source file&lt;/em&gt; for each module in the dependency graph, so that it can parse the import declarations and follow dependencies. Any pre-compiled modules without source files must therefore belong to a package &lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;ghc -M&lt;/code&gt; 需要在依赖关系图中为每个模块找到一个&lt;em&gt;源文件&lt;/em&gt;，以便它可以解析导入声明并遵循依赖关系。因此，任何没有源文件的预编译模块都必须属于包&lt;a href=&quot;#id5&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9ad10b105a7bebae4f8165fa8685e319e4cd138" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;hTestEquality&lt;/code&gt; takes two arguments where the type variable &lt;code&gt;t&lt;/code&gt; is applied to types of different kinds. That type variable must then be polykinded. Accordingly, the kind of &lt;code&gt;HTestEquality&lt;/code&gt; (the class) is &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt;, a higher-rank kind.</source>
          <target state="translated">请注意， &lt;code&gt;hTestEquality&lt;/code&gt; 带有两个参数，其中类型变量 &lt;code&gt;t&lt;/code&gt; 适用于不同类型的类型。然后必须对该类型变量进行多类化。因此， &lt;code&gt;HTestEquality&lt;/code&gt; 的类型（该类）是 &lt;code&gt;(forall k. k -&amp;gt; Type) -&amp;gt; Constraint&lt;/code&gt; k。k- &amp;gt; Type）-&amp;gt; Constraint，一种较高等级的类型。</target>
        </trans-unit>
        <trans-unit id="d49f48cab2336da3b33335456da6ac1c62fd042c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; tests whether all the keys in &lt;code&gt;m1&lt;/code&gt; are also keys in &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;isSubmapOfBy (_ _ -&amp;gt; True) m1 m2&lt;/code&gt; 测试 &lt;code&gt;m1&lt;/code&gt; 中的所有键是否也是 &lt;code&gt;m2&lt;/code&gt; 中的键。</target>
        </trans-unit>
        <trans-unit id="8d87919fed4910f020e65cc52017097a20305800" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;it&lt;/code&gt; is shadowed by the new value each time you evaluate a new expression, and the old value of &lt;code&gt;it&lt;/code&gt; is lost.</source>
          <target state="translated">请注意， &lt;code&gt;it&lt;/code&gt; 是由新的值每次评估新的表达时间的阴影，和旧的价值 &lt;code&gt;it&lt;/code&gt; 将丢失。</target>
        </trans-unit>
        <trans-unit id="8965b5ad7e3a3d0f07f953f01997900513413179" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;k2&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;, and that &lt;code&gt;k&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;. Also, note that &lt;code&gt;k2&lt;/code&gt; is written here in braces. As explained with &lt;a href=&quot;#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called &lt;em&gt;inferred&lt;/em&gt; variables.) Such variables are written in braces with &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="translated">请注意， &lt;code&gt;k2&lt;/code&gt; 放在 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;，而 &lt;code&gt;k&lt;/code&gt; 放在 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。另外，请注意， &lt;code&gt;k2&lt;/code&gt; 用大括号写在这里。如有关&lt;a href=&quot;#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; 的&lt;/a&gt;说明（&lt;a href=&quot;#inferred-vs-specified&quot;&gt;推断的vs.指定的类型变量&lt;/a&gt;）所述，GHC泛化但未写在原始程序中的类型和种类变量不适用于可见类型应用程序。（这些称为&lt;em&gt;推断&lt;/em&gt;变量。）在启用&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; 的情况下,将&lt;/a&gt;这些变量写在括号中。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="816ae0198397860aa9fd60cc59c11d1ed2b5d997" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;k2&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;k&lt;/code&gt;, and that &lt;code&gt;k&lt;/code&gt; is placed &lt;em&gt;before&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;. Also, note that &lt;code&gt;k2&lt;/code&gt; is written here in braces. As explained with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called &lt;em&gt;inferred&lt;/em&gt; variables.) Such variables are written in braces.</source>
          <target state="translated">请注意， &lt;code&gt;k2&lt;/code&gt; 放在 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;，而 &lt;code&gt;k&lt;/code&gt; 放在 &lt;code&gt;a&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;。另外，请注意， &lt;code&gt;k2&lt;/code&gt; 用大括号写在这里。如有关&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; 的&lt;/a&gt;说明（&lt;a href=&quot;type_applications#inferred-vs-specified&quot;&gt;推断的vs.指定的类型变量&lt;/a&gt;）所述，GHC概括但未写在原始程序中的类型和种类变量不适用于可见类型应用程序。（这些称为&lt;em&gt;推断&lt;/em&gt;变量。）此类变量用大括号编写。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a55de5915599f1590abb3356c8fe6ece583ed02" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;let&lt;/code&gt; bindings do not automatically print the value bound, unlike monadic bindings.</source>
          <target state="translated">请注意，与单键绑定不同， &lt;code&gt;let&lt;/code&gt; 绑定不会自动打印值绑定。</target>
        </trans-unit>
        <trans-unit id="5f999ecaeb1e7a69b4163c053a67ca1cf1c9ff63" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mkName&lt;/code&gt; may be used with qualified names:</source>
          <target state="translated">请注意， &lt;code&gt;mkName&lt;/code&gt; 可以与限定名称一起使用：</target>
        </trans-unit>
        <trans-unit id="01c07aa245695205a32a04f4daab1815beac9b5c" translate="yes" xml:space="preserve">
          <source>Note that GHC can only follow dependencies if it has the source file available, so if your program includes a module for which there is no source file, even if you have an object and an interface file for the module, then GHC will complain. The exception to this rule is for package modules, which may or may not have source files.</source>
          <target state="translated">需要注意的是,GHC只有在有源文件的情况下才能跟踪依赖关系,所以如果你的程序包含了一个没有源文件的模块,即使你有该模块的对象和接口文件,GHC也会抱怨。这个规则的例外是包模块,它可能有也可能没有源文件。</target>
        </trans-unit>
        <trans-unit id="628959edf33f1bf4af75378e5117a34fc0ac8086" translate="yes" xml:space="preserve">
          <source>Note that a &quot;minute&quot; of &lt;code&gt;DiffTime&lt;/code&gt; is simply 60 SI seconds, rather than a minute of civil time. Use &lt;code&gt;NominalDiffTime&lt;/code&gt; to work with civil time, ignoring any leap seconds.</source>
          <target state="translated">请注意， &lt;code&gt;DiffTime&lt;/code&gt; 的&amp;ldquo;分钟&amp;rdquo; 仅为60 SI秒，而不是一分钟的民用时间。使用 &lt;code&gt;NominalDiffTime&lt;/code&gt; 来处理民用时间，而忽略任何seconds秒。</target>
        </trans-unit>
        <trans-unit id="db63214ed45116be549d0295c81ce0bf585bc000" translate="yes" xml:space="preserve">
          <source>Note that a given &lt;code&gt;mdo&lt;/code&gt; expression can cause the creation of multiple &lt;code&gt;rec&lt;/code&gt; blocks. If there are no recursive dependencies, &lt;code&gt;mdo&lt;/code&gt; will introduce no &lt;code&gt;rec&lt;/code&gt; blocks. In this latter case an &lt;code&gt;mdo&lt;/code&gt; expression is precisely the same as a &lt;code&gt;do&lt;/code&gt; expression, as one would expect.</source>
          <target state="translated">请注意，给定的 &lt;code&gt;mdo&lt;/code&gt; 表达式可以导致创建多个 &lt;code&gt;rec&lt;/code&gt; 块。如果没有递归依赖性，则 &lt;code&gt;mdo&lt;/code&gt; 将不引入 &lt;code&gt;rec&lt;/code&gt; 块。在后一种情况下， &lt;code&gt;mdo&lt;/code&gt; 表达式与 &lt;code&gt;do&lt;/code&gt; 表达式完全相同，正如人们所期望的那样。</target>
        </trans-unit>
        <trans-unit id="edb8824abf3adc676b8fc9d4d2a15be4648aabba" translate="yes" xml:space="preserve">
          <source>Note that after splitting the string at newline characters, the last part of the string is considered a line even if it doesn't end with a newline. For example,</source>
          <target state="translated">请注意,在换行符处拆分字符串后,即使字符串的最后部分没有以换行符结束,也会被视为一行。例如</target>
        </trans-unit>
        <trans-unit id="e48d232edc1ec00a99a6fd6c27346f29f36049ef" translate="yes" xml:space="preserve">
          <source>Note that after the closing brace, GHCi knows that the current statement is finished, so no empty line is required.</source>
          <target state="translated">需要注意的是,在结束括号之后,GHCi知道当前语句已经结束,所以不需要空行。</target>
        </trans-unit>
        <trans-unit id="629c79c2f8b660ab85b6013a5e3159a0a225a4a6" translate="yes" xml:space="preserve">
          <source>Note that although the above translation suggests that &lt;code&gt;let&lt;/code&gt;-bound variables like &lt;code&gt;z&lt;/code&gt; must be monomorphic, the actual translation produces Core, so polymorphic variables are allowed.</source>
          <target state="translated">请注意，尽管以上翻译建议 &lt;code&gt;let&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 这样的让绑定变量必须是单态的，但实际的翻译会生成Core，因此允许使用多态变量。</target>
        </trans-unit>
        <trans-unit id="629818198328cd462665ec73736ee33ba93fceb4" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; is often absolutely essential. Consider the rose-tree example</source>
          <target state="translated">请注意，明确的 &lt;code&gt;forall&lt;/code&gt; 通常是绝对必要的。考虑玫瑰树的例子</target>
        </trans-unit>
        <trans-unit id="92e28e232c8219184dccc4e81df68cd45a16bf4c" translate="yes" xml:space="preserve">
          <source>Note that an explicit &lt;code&gt;forall&lt;/code&gt; must appear at the front of the type signature and is not permitted to appear nested within the type, as in the following (erroneous) examples:</source>
          <target state="translated">请注意，显式的 &lt;code&gt;forall&lt;/code&gt; 必须出现在类型签名的前面，并且不允许嵌套在类型内，如以下（错误的）示例所示：</target>
        </trans-unit>
        <trans-unit id="1fedd4b9525d691022adec17bbc58c0482f1424f" translate="yes" xml:space="preserve">
          <source>Note that any multi-parameter constraints &lt;code&gt;(D a b)&lt;/code&gt; or &lt;code&gt;(D [a] Int)&lt;/code&gt; do not participate in the process (either to help or to hinder); but they must of course be soluble once the defaulting process is complete.</source>
          <target state="translated">请注意，任何多参数约束 &lt;code&gt;(D a b)&lt;/code&gt; 或 &lt;code&gt;(D [a] Int)&lt;/code&gt; 都不参与该过程（帮助或阻碍）；但是，一旦默认设置完成，它们当然必须是可溶解的。</target>
        </trans-unit>
        <trans-unit id="c67cc7b453618af847cc15ad44d064d4550a5b4a" translate="yes" xml:space="preserve">
          <source>Note that any non-flag arguments are never passed to GHC. An unused non-flag argument will be considered as the name of the program to run. If a GHC flag takes an argument use &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; to pass the argument to GHC. For example, if you want to pass &lt;code&gt;-package foo&lt;/code&gt; to GHC use any of the following:</source>
          <target state="translated">请注意，任何非标志参数都不会传递给GHC。未使用的非标志参数将被视为要运行的程序的名称。如果GHC标志采用参数，请使用 &lt;code&gt;--ghc-arg=&amp;lt;arg&amp;gt;&lt;/code&gt; 将参数传递给GHC。例如，如果您要将 &lt;code&gt;-package foo&lt;/code&gt; 传递给GHC，请使用以下任一方法：</target>
        </trans-unit>
        <trans-unit id="1d2d4c489f4d5c10bf98bfdb6c95992494ea1737" translate="yes" xml:space="preserve">
          <source>Note that because constraints are just handled as types of a particular kind, this extension allows type constraint synonyms:</source>
          <target state="translated">请注意,由于约束只是作为特定种类的类型来处理,所以这个扩展允许类型约束同义词。</target>
        </trans-unit>
        <trans-unit id="1e70909e8298e18a428bd14a078ccbac8a33b1c3" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is only safe to use, therefore, if the immutable array is never referenced again in this thread, and there is no possibility that it can be also referenced in another thread. If you use an unsafeThaw&lt;em&gt;write&lt;/em&gt;unsafeFreeze sequence in a multi-threaded setting, then you must ensure that this sequence is atomic with respect to other threads, or a garbage collector crash may result (because the write may be writing to a frozen array).</source>
          <target state="translated">请注意，由于可能未复制数组，因此对数组的可变版本进行的任何后续修改都可以与不可变版本共享。因此，如果不可变数组在该线程中不再被引用，并且只有在另一个线程中也可以被引用时，才可以安全使用。如果在多线程设置中使用unsafeThaw &lt;em&gt;写入&lt;/em&gt; unsafeFreeze序列，则必须确保该序列相对于其他线程是原子的，否则可能导致垃圾收集器崩溃（因为该写入可能正在写入冻结的数组）。</target>
        </trans-unit>
        <trans-unit id="312ce308d507158c0dbd1448754583dfb49275af" translate="yes" xml:space="preserve">
          <source>Note that because the array is possibly not copied, any subsequent modifications made to the mutable version of the array may be shared with the immutable version. It is safe to use, therefore, if the mutable version is never modified after the freeze operation.</source>
          <target state="translated">请注意,由于数组可能不会被复制,因此对数组的可变版本的任何后续修改都可能与不可变版本共享。因此,如果在冻结操作后从未修改过可变版本,那么使用该方法是安全的。</target>
        </trans-unit>
        <trans-unit id="cf2145147a60ace311fa33d22d382ca44077b49d" translate="yes" xml:space="preserve">
          <source>Note that calling `breakSubstring x` does some preprocessing work, so you should avoid unnecessarily duplicating breakSubstring calls with the same pattern.</source>
          <target state="translated">请注意,调用 &quot;breakSubstring x &quot;会做一些预处理工作,所以应该避免不必要地重复调用相同模式的breakSubstring。</target>
        </trans-unit>
        <trans-unit id="fc9763765bf9b4fd333d384e2c7f6d48a5f90bb7" translate="yes" xml:space="preserve">
          <source>Note that class instances are always for particular &lt;em&gt;instances&lt;/em&gt; of a data family and never for an entire family as a whole. This is for essentially the same reasons that we cannot define a toplevel function that performs pattern matching on the data constructors of &lt;em&gt;different&lt;/em&gt; instances of a single type family. It would require a form of extensible case construct.</source>
          <target state="translated">请注意，类实例始终用于数据族的特定&lt;em&gt;实例&lt;/em&gt;，而不是整个族的整体。出于本质上相同的原因，我们无法定义一个顶级函数来对单个类型族的&lt;em&gt;不同&lt;/em&gt;实例的数据构造函数执行模式匹配。这将需要一种可扩展的案例构造形式。</target>
        </trans-unit>
        <trans-unit id="3fd26db2c5a937cd006a71ef434cb9a6ac571280" translate="yes" xml:space="preserve">
          <source>Note that command-line options are &lt;em&gt;order-dependent&lt;/em&gt;, with arguments being evaluated from left-to-right. This can have seemingly strange effects in the presence of flag implication. For instance, consider &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fno-specialise&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt;&lt;code&gt;-O1&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt;&lt;code&gt;-fspecialise&lt;/code&gt;&lt;/a&gt;). These two command lines mean very different things:</source>
          <target state="translated">请注意，命令行选项是&lt;em&gt;顺序相关的&lt;/em&gt;，参数是从左到右评估的。在存在标志含义的情况下，这可能会产生看似奇怪的效果。例如，考虑&lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fno-specialise&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-optimisation#ghc-flag--O1&quot;&gt; &lt;code&gt;-O1&lt;/code&gt; &lt;/a&gt;（这意味着&lt;a href=&quot;using-optimisation#ghc-flag--fspecialise&quot;&gt; &lt;code&gt;-fspecialise&lt;/code&gt; &lt;/a&gt;）。这两个命令行的含义非常不同：</target>
        </trans-unit>
        <trans-unit id="76091aaf5e35a41319f5ec500de56fcd89951658" translate="yes" xml:space="preserve">
          <source>Note that deriving &lt;code&gt;Eq&lt;/code&gt; is necessary for the pattern matching to work since it gets translated into an equality comparison.</source>
          <target state="translated">请注意，派生 &lt;code&gt;Eq&lt;/code&gt; 对于模式匹配起作用是必需的，因为它将转换为相等比较。</target>
        </trans-unit>
        <trans-unit id="5e66a3c265c4c5b432263a07a725a136b6324e29" translate="yes" xml:space="preserve">
          <source>Note that due to Haskell's unspecified evaluation order, an expression may throw one of several possible exceptions: consider the expression &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt;. Does the expression throw &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt;, or &lt;code&gt;DivideByZero&lt;/code&gt;?</source>
          <target state="translated">请注意，由于Haskell的评估顺序未指定，表达式可能会引发以下几种可能的异常之一：考虑表达式 &lt;code&gt;(error &quot;urk&quot;) + (1 `div` 0)&lt;/code&gt; 。表达式是否抛出 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 或 &lt;code&gt;DivideByZero&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="a38e6766cff20e461dc54ded66126b634b012173" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="0ef6487a6a1f23d9e6d0eab035203c36999e612c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="718b6ec1eedc7b0e6b0505f3537b21d4d5090824" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="b2e8c03bc2025303c4c75357649bb45ee1572579" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="8bb133570167aeb8235fd7aa64e771323ce317b8" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="b8c80f9a804d45f8387d652852d3f1b319e89bab" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="abaa8283c8c82c454b3f39dc4e8b3b95dea832bf" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="efa258be8dec869f272beb6b3b0719e9c9136d95" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="cc8602ae6c9f5374c5b3e2f4892e8ddead96cf59" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="434b11a6a2c5a23f490c3dca6b67c53a554a0d1b" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="6077357d3de95b1c68b9540f7bddf5fc70a526b4" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足自反性。</target>
        </trans-unit>
        <trans-unit id="2043553ccd4d376d49787321f94def08da904851" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="194e7c783a359ef09d66938c7b166d817c622581" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="9890f34bd7580f2b47b85fe9349066eb034aa874" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="9dcbc1e84d812484382f7054b4ea09eece714d9c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="20c322bafd53e5e4ac584f0f4c7683ecf396fc66" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance does not satisfy reflexivity.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例不满足反射性。</target>
        </trans-unit>
        <trans-unit id="e775258fb33a9c99aae311b322919c0b7003500f" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="1f89c3ca9731aeeb8476c132b53e6e61c23b4594" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="24ad6371739df6cce2c9d49e41a79e67a4549c98" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="59b02bd4bf7fdf2cce1cbde77a7195b31de26236" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="5b8a7de16c8d613620813c9851308e5845856e62" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="c868d72c8e906befa9b0e16299d79ca57971708c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="da59b4a14361d344a87c211c8c8c17fcca4de300" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="96f2507b88b419212359ae0a529d1957a3da8fe1" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="6105c208b7c6f44c6b239700c54851ff6acd9f7c" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="9187cd519377bc44a76fe47963badb1dfb10c1de" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="0dc5c80ae44926709a883abad455c22674f3d607" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an additive inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有加法逆。</target>
        </trans-unit>
        <trans-unit id="7935bc741f62235ae7bf01a48ecac728f0a179e3" translate="yes" xml:space="preserve">
          <source>Note that due to the presence of &lt;code&gt;NaN&lt;/code&gt;, not all elements of &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; have an multiplicative inverse.</source>
          <target state="translated">请注意，由于存在 &lt;code&gt;NaN&lt;/code&gt; ，并非 &lt;code&gt;&lt;a href=&quot;prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的所有元素都具有乘法逆。</target>
        </trans-unit>
        <trans-unit id="eeb5083fb742894713808d1bf407187ed8b72976" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">请注意，即使基本的 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例合法，对于大多数 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; s而言，该实例也不合法。如果将此实例与列表 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 一起使用，则以下习惯法将不成立：</target>
        </trans-unit>
        <trans-unit id="3853fcb3c30f45ae120a9243010c94f95839f0f3" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">请注意，即使基本的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例合法，对于大多数 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; s而言，该实例也不合法。如果将此实例与列表 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 一起使用，则以下习惯法将不成立：</target>
        </trans-unit>
        <trans-unit id="27585464cfdd8d01e677b0406967c001ac3c9e76" translate="yes" xml:space="preserve">
          <source>Note that even if the underlying &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instances are lawful, for most &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;s, this instance will not be lawful. If you use this instance with the list &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt;, the following customary laws will not hold:</source>
          <target state="translated">请注意，即使基本的 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例合法，对于大多数 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; s而言，该实例也不合法。如果将此实例与列表 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 一起使用，则以下习惯法将不成立：</target>
        </trans-unit>
        <trans-unit id="646e8b4539cacf2e9e9d3ae0b8e3c032a0312c22" translate="yes" xml:space="preserve">
          <source>Note that even with &lt;code&gt;--install-signal-handlers=no&lt;/code&gt;, the RTS interval timer signal is still enabled. The timer signal is either SIGVTALRM or SIGALRM, depending on the RTS configuration and OS capabilities. To disable the timer signal, use the &lt;code&gt;-V0&lt;/code&gt; RTS option (see &lt;code&gt;-V ⟨secs⟩&lt;/code&gt;).</source>
          <target state="translated">请注意，即使使用 &lt;code&gt;--install-signal-handlers=no&lt;/code&gt; ，RTS间隔计时器信号仍然启用。计时器信号可以是SIGVTALRM或SIGALRM，具体取决于RTS配置和OS功能。要禁用计时器信号，请使用 &lt;code&gt;-V0&lt;/code&gt; RTS选项（请参见 &lt;code&gt;-V ⟨secs⟩&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4432323376182dfbdca3fdc7130f34b9170ab0c0" translate="yes" xml:space="preserve">
          <source>Note that exceptions which are thrown to the current thread are thrown in turn to the thread that is executing the given computation. This ensures there's always a way of killing the forked thread.</source>
          <target state="translated">请注意,向当前线程抛出的异常会反过来抛给正在执行给定计算的线程。这确保了总有办法杀死分叉的线程。</target>
        </trans-unit>
        <trans-unit id="4e7cb7371c58bd222ab2560f3a7d99af3af20d16" translate="yes" xml:space="preserve">
          <source>Note that fixed primitives can be considered as a special case of bounded primitives, and we can lift from fixed to bounded.</source>
          <target state="translated">请注意,固定基元可以看作是有界基元的特例,我们可以从固定提升到有界。</target>
        </trans-unit>
        <trans-unit id="56b0f705789ec7ac7e04637b1063cafb79dc672b" translate="yes" xml:space="preserve">
          <source>Note that for consistency &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Word64&lt;/code&gt;, and &lt;code&gt;Int64&lt;/code&gt; constructor fields are unpacked on 32-bit platforms, even though they are technically larger than a pointer on those platforms.</source>
          <target state="translated">请注意，为了保持一致性， &lt;code&gt;Double&lt;/code&gt; ， &lt;code&gt;Word64&lt;/code&gt; 和 &lt;code&gt;Int64&lt;/code&gt; 构造函数字段在32位平台上解压缩，即使它们在技术上比那些平台上的指针大。</target>
        </trans-unit>
        <trans-unit id="6128c2afaa4b4099fa2f7f80159c3c3eb7d037da" translate="yes" xml:space="preserve">
          <source>Note that for non-C languages (for example C++) &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; directives must be used to get symbols that we can access from Haskell.</source>
          <target state="translated">请注意，对于非C语言（例如C ++），必须使用 &lt;code&gt;extern &lt;a href=&quot;c&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 指令来获取可从Haskell访问的符号。</target>
        </trans-unit>
        <trans-unit id="250d6d584d95f50004937c03dc209e45f1572a99" translate="yes" xml:space="preserve">
          <source>Note that for scripts and interactive sessions, this is the path to the interpreter (e.g. ghci.)</source>
          <target state="translated">请注意,对于脚本和交互式会话,这是通往解释器的路径(如ghci.)。</target>
        </trans-unit>
        <trans-unit id="2a64a1dfeaac3f04e05a2dfa765d6f00da1d204a" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;package-db&lt;/code&gt; directive, if a relative path is given it must be relative to the location of the package environment file.</source>
          <target state="translated">请注意，对于 &lt;code&gt;package-db&lt;/code&gt; 指令，如果给出了相对路径，则它必须相对于软件包环境文件的位置。</target>
        </trans-unit>
        <trans-unit id="96e9f8d44f9309d061a4735a30dbfcf393329303" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of injectivity check in bullets (4) and (5) GHC uses a special variant of unification algorithm that treats type family applications as possibly unifying with anything.</source>
          <target state="translated">请注意,为了在子弹(4)和(5)中进行注入性检查,GHC使用了一种特殊的统一算法变体,将类型族应用视为可能与任何东西统一。</target>
        </trans-unit>
        <trans-unit id="b361a1480c4039f0cd985063822cba34298460c6" translate="yes" xml:space="preserve">
          <source>Note that foreign calls made by different Haskell threads may execute in &lt;em&gt;parallel&lt;/em&gt;, even when the &lt;code&gt;+RTS -N&lt;/code&gt; flag is not being used (&lt;a href=&quot;../using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;). The &lt;code&gt;-N ⟨x⟩&lt;/code&gt; flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the &lt;code&gt;+RTS -N&lt;/code&gt; value.</source>
          <target state="translated">请注意，即使未使用 &lt;code&gt;+RTS -N&lt;/code&gt; 标志（&lt;a href=&quot;../using-concurrent#parallel-options&quot;&gt;SMP并行性的RTS选项&lt;/a&gt;），由不同的Haskell线程进行的外部调用也可能&lt;em&gt;并行&lt;/em&gt;执行。在 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 标志控制的Haskell线程并行执行，但也有可能在任一个时刻在进展中外来呼叫的任意数量，而不管的 &lt;code&gt;+RTS -N&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="ffa639807aa32c333508357828c548fb4190cf20" translate="yes" xml:space="preserve">
          <source>Note that foreign calls made by different Haskell threads may execute in &lt;em&gt;parallel&lt;/em&gt;, even when the &lt;code&gt;+RTS -N&lt;/code&gt; flag is not being used (&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;). The &lt;code&gt;-N ⟨x⟩&lt;/code&gt; flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the &lt;code&gt;+RTS -N&lt;/code&gt; value.</source>
          <target state="translated">请注意，即使未使用 &lt;code&gt;+RTS -N&lt;/code&gt; 标志（&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;SMP并行性的RTS选项&lt;/a&gt;），由不同的Haskell线程进行的外部调用也可能&lt;em&gt;并行&lt;/em&gt;执行。在 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 标志控制的Haskell线程并行执行，但也有可能在任一个时刻在进展中外来呼叫的任意数量，而不管的 &lt;code&gt;+RTS -N&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b570082e206f3882d05ae56cc37de0fcb8caa829" translate="yes" xml:space="preserve">
          <source>Note that functions marked with &quot;&lt;em&gt;Heavy inlining.&lt;/em&gt;&quot; are forced to be inlined because they must be specialized for concrete encodings, but are rather heavy in terms of code size. We recommend to define a top-level function for every concrete instantiation of such a function in order to share its code. A typical example is the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;, which is implemented as follows.</source>
          <target state="translated">请注意，标记为&amp;ldquo; &lt;em&gt;Heavy inlining。&lt;/em&gt; &amp;rdquo;的函数被强制内联，因为它们必须专门用于具体编码，但是在代码大小方面却相当繁琐。我们建议为该函数的每个具体实例定义一个顶级函数，以共享其代码。一个典型的例子是功能 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:byteStringHex&quot;&gt;byteStringHex&lt;/a&gt;&lt;/code&gt; 从&lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;，这是如下实现的。</target>
        </trans-unit>
        <trans-unit id="e12827f70b05908494f598eac9c4f60068827e87" translate="yes" xml:space="preserve">
          <source>Note that functions marked with &quot;&lt;em&gt;Heavy inlining.&lt;/em&gt;&quot; are forced to be inlined because they must be specialized for concrete encodings, but are rather heavy in terms of code size. We recommend to define a top-level function for every concrete instantiation of such a function in order to share its code. A typical example is the function &lt;code&gt;byteStringHex&lt;/code&gt; from &lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;, which is implemented as follows.</source>
          <target state="translated">请注意，标记为&amp;ldquo; &lt;em&gt;Heavy inlining。&lt;/em&gt; &amp;rdquo;的函数被强制内联，因为它们必须专门用于具体编码，但是在代码大小方面相当繁琐。我们建议为该函数的每个具体实例定义一个顶层函数，以共享其代码。一个典型的例子是功能 &lt;code&gt;byteStringHex&lt;/code&gt; 从&lt;a href=&quot;data-bytestring-builder-ascii&quot;&gt;Data.ByteString.Builder.ASCII&lt;/a&gt;，这是如下实现的。</target>
        </trans-unit>
        <trans-unit id="a81cbfbf457be603965ed8e6e32f7b3176154d2b" translate="yes" xml:space="preserve">
          <source>Note that functions requiring varargs arguments are unsupported by the &lt;code&gt;ccall&lt;/code&gt; calling convention. Foreign imports needing to call such functions should rather use the &lt;code&gt;capi&lt;/code&gt; convention, giving an explicit signature for the needed call-pattern. For instance, one could write:</source>
          <target state="translated">请注意， &lt;code&gt;ccall&lt;/code&gt; 调用约定不支持需要varargs参数的函数。需要调用此类函数的外国进口产品应使用 &lt;code&gt;capi&lt;/code&gt; 约定，为所需的调用模式提供明确的签名。例如，可以写：</target>
        </trans-unit>
        <trans-unit id="2216bc2850d8b97233a3efc13f854171f19bee87" translate="yes" xml:space="preserve">
          <source>Note that higher optimisation levels cause more cross-module optimisation to be performed, which can have an impact on how much of your program needs to be recompiled when you change something. This is one reason to stick to no-optimisation when developing code.</source>
          <target state="translated">请注意,更高的优化级别会导致更多的跨模块优化,这可能会影响到当你改变一些东西时,你的程序需要重新编译的程度。这也是开发代码时坚持不优化的一个原因。</target>
        </trans-unit>
        <trans-unit id="30a1f39225163748211fd926207dd09b8855fbec" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="c4c0dcced941ac54917c55caf21e22d4636d250c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="2364a113ff09ab00bf106323a9ba1b4c3714d917" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="11abb5f8d9b5fba3f33fa0b7e155694cf82d23ad" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="620ca9a9df68bf26044f5d872190781472e76ff1" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="55ba0c9a076ac9b515d71482f78bc92a96d264e8" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="ade933651993a04a370b1b74f8baa0d698471747" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="d66210fda4350eaec16e5b09b559810cf819baea" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="53bdddcd649e7c0b18af6cbb0a2342c2614754df" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果将当前线程作为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="12809b4532f5331b24f07fd2836313e5463fa8a2" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is called with the current thread as the target, the exception will be thrown even if the thread is currently inside &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果以当前线程为目标调用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ，则即使线程当前位于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 中，也会引发异常。</target>
        </trans-unit>
        <trans-unit id="0cd84aceb1741c1097100af32525f39087b79c2c" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;C&lt;/code&gt; does not contain any class methods, the instance context is wholly unnecessary, and as such GHC will instead generate:</source>
          <target state="translated">请注意，如果 &lt;code&gt;C&lt;/code&gt; 不包含任何类方法，则实例上下文是完全不必要的，因此GHC会生成：</target>
        </trans-unit>
        <trans-unit id="28c37978b95dd575e513b0b23b8deb28631dd7fb" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="288715920cc43c37cbcf03237a6afbc9e9f1ca44" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;f&lt;/code&gt; is strict, &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt;.</source>
          <target state="translated">注意，如果 &lt;code&gt;f&lt;/code&gt; 是严格的，则 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#v:fixST&quot;&gt;fixST&lt;/a&gt; f = _|_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23075918281a3d4a9a4393210ab00757f30add13" translate="yes" xml:space="preserve">
          <source>Note that if Haskeline is built against a version of the &lt;code&gt;Win32&lt;/code&gt; library earlier than 2.5, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; will incorrectly echo back input on MinTTY consoles (such as Cygwin or MSYS).</source>
          <target state="translated">请注意，如果Haskeline是针对 &lt;code&gt;Win32&lt;/code&gt; 库的2.5 版之前的版本构建的，则 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getPassword&quot;&gt;getPassword&lt;/a&gt;&lt;/code&gt; 将错误地回显MinTTY控制台（例如Cygwin或MSYS）上的输入。</target>
        </trans-unit>
        <trans-unit id="748b314274792a265ed7c2434a739a0777fcbd47" translate="yes" xml:space="preserve">
          <source>Note that if the expression can&amp;rsquo;t be translated into uses of &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; only, then it will incur a &lt;code&gt;Monad&lt;/code&gt; constraint as usual. This happens when there is a dependency on a value produced by an earlier statement in the &lt;code&gt;do&lt;/code&gt;-block:</source>
          <target state="translated">请注意，如果表达式不能仅转换为 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 的使用，则它将照常受到 &lt;code&gt;Monad&lt;/code&gt; 约束。当对 &lt;code&gt;do&lt;/code&gt; -block中的较早语句产生的值有依赖性时，就会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="3cbb7152b808b31e2c0cac825f8fb2dae7c7b28d" translate="yes" xml:space="preserve">
          <source>Note that if you do need to interpret file paths or environment strings as text, then some Unicode encoding or decoding should be applied first.</source>
          <target state="translated">请注意,如果你确实需要将文件路径或环境字符串解释为文本,那么应该先应用一些Unicode编码或解码。</target>
        </trans-unit>
        <trans-unit id="727e91ac7cf7235ceb01512e066f5fa194d7f879" translate="yes" xml:space="preserve">
          <source>Note that if you want an efficient left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt;. The reason is that the latter does not force the &quot;inner&quot; results, resulting in a thunk chain which then must be evaluated from the outside-in.</source>
          <target state="translated">请注意，如果您想要有效的左折，则可能要使用 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl-39-&quot;&gt;bifoldl'&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 。原因是后者不会强制执行&amp;ldquo;内部&amp;rdquo;结果，从而导致必须从外到内评估链状链。</target>
        </trans-unit>
        <trans-unit id="3f920b899f0a93de7b234be63afb284d817b0204" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;S2&lt;/code&gt; and &lt;code&gt;S3&lt;/code&gt;, the kind of the right-hand side is rather apparent, but it is still not considered to have a complete signature &amp;ndash; no inference can be done before detecting the signature.</source>
          <target state="translated">请注意，在 &lt;code&gt;S2&lt;/code&gt; 和 &lt;code&gt;S3&lt;/code&gt; 中，右侧的种类非常明显，但仍不认为它具有完整的签名-在检测到签名之前无法进行推断。</target>
        </trans-unit>
        <trans-unit id="1ed65ace60cec8fe502a481f05e3dda7d603ff35" translate="yes" xml:space="preserve">
          <source>Note that in GHCi, and &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode, the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for &lt;em&gt;source&lt;/em&gt; files, whereas in standard batch-compilation mode the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option is used to specify the search path for interface files, see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;.</source>
          <target state="translated">请注意，在GHCI和&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式下，&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项来指定搜索路径&lt;em&gt;源&lt;/em&gt;文件，而在标准批处理编译模式的&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项来指定接口文件的搜索路径，看到&lt;a href=&quot;separate_compilation#search-path&quot;&gt;的搜索路径&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f74e9b413c970241bf9e71c360a313d3c98064d3" translate="yes" xml:space="preserve">
          <source>Note that in the last example, it&amp;rsquo;s impossible to learn that &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;k&lt;/code&gt; in the body of the &lt;code&gt;forall&lt;/code&gt; (that is, the &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt;). And so GHC rejects the program.</source>
          <target state="translated">请注意，在最后一个例子，这是不可能得知 &lt;code&gt;a&lt;/code&gt; 依赖于 &lt;code&gt;k&lt;/code&gt; 在体内 &lt;code&gt;forall&lt;/code&gt; （也就是 &lt;code&gt;Sing k -&amp;gt; Sing a -&amp;gt; ()&lt;/code&gt; ）。因此，GHC拒绝了该计划。</target>
        </trans-unit>
        <trans-unit id="585d2c2d29d7e260cd5cf60d36a2bb2eded38317" translate="yes" xml:space="preserve">
          <source>Note that in this example, &lt;code&gt;a&lt;/code&gt; is a universal variable in the data type &lt;code&gt;T&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is existential. When writing the pattern synonym, both types are allowed to be specified or inferred.</source>
          <target state="translated">请注意，在此示例中， &lt;code&gt;a&lt;/code&gt; 是数据类型 &lt;code&gt;T&lt;/code&gt; 中的通用变量，其中 &lt;code&gt;b&lt;/code&gt; 是存在变量。编写模式同义词时，允许指定或推断两种类型。</target>
        </trans-unit>
        <trans-unit id="3c3f39847ba19e77a6a582f15278eee9d18590bf" translate="yes" xml:space="preserve">
          <source>Note that invariant checking (namely the &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;alwaysSucceeds&lt;/code&gt; functions) has been removed. See ticket &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;#14324&lt;/a&gt; and the &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;removal proposal&lt;/a&gt;. Existing users are encouraged to encapsulate their STM operations in safe abstractions which can perform the invariant checking without help from the runtime system.</source>
          <target state="translated">请注意，不变检查（即 &lt;code&gt;always&lt;/code&gt; 和 &lt;code&gt;alwaysSucceeds&lt;/code&gt; 函数）已被删除。请参阅票证&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/14324&quot;&gt;＃14324&lt;/a&gt;和&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0011-deprecate-stm-invariants.rst&quot;&gt;拆除建议&lt;/a&gt;。鼓励现有用户将其STM操作封装为安全的抽象，这些抽象可以执行不变性检查而无需运行时系统的帮助。</target>
        </trans-unit>
        <trans-unit id="bfd5ca80319611f2ad6a6d58665d93fcbb3c156f" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;希望 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 的类型实例实现一个字段。但是， &lt;code&gt;base&lt;/code&gt; 中的所有实例都可以。</target>
        </trans-unit>
        <trans-unit id="525bc9621da46140b66110bf09981d8c0a2b7083" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; implement a field. However, all instances in &lt;code&gt;base&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;希望 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 的类型实例实现一个字段。但是， &lt;code&gt;base&lt;/code&gt; 中的所有实例都可以。</target>
        </trans-unit>
        <trans-unit id="ccaf9ee57d711da801bed84dfadd525a75d70df7" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;期望 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的类型实例都实现有序环。事实上，在 &lt;code&gt;base&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 做的。</target>
        </trans-unit>
        <trans-unit id="0b0ebefaf6a8fd7841a426ebbf90075219fca0d8" translate="yes" xml:space="preserve">
          <source>Note that it &lt;em&gt;isn't&lt;/em&gt; customarily expected that a type instance of both &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; implement an ordered ring. Indeed, in &lt;code&gt;base&lt;/code&gt; only &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; do.</source>
          <target state="translated">请注意，&lt;em&gt;通常不&lt;/em&gt;期望 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的类型实例都实现有序环。事实上，在 &lt;code&gt;base&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-ratio#v:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; 做的。</target>
        </trans-unit>
        <trans-unit id="c2c82e2d7986abad0ba04ff393eba4038a79448c" translate="yes" xml:space="preserve">
          <source>Note that it &lt;strong&gt;does not&lt;/strong&gt; regard CR (&lt;code&gt;'\r'&lt;/code&gt;) as a newline character.</source>
          <target state="translated">请注意，它&lt;strong&gt;不会&lt;/strong&gt;将CR（ &lt;code&gt;'\r'&lt;/code&gt; ）视为换行符。</target>
        </trans-unit>
        <trans-unit id="b265c3aed4a0fae4215ed6797047f0fad0de3ff1" translate="yes" xml:space="preserve">
          <source>Note that it doesn&amp;rsquo;t fully negate the effects of &lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; - the warning will still be enabled.</source>
          <target state="translated">请注意，它并未完全消除 &lt;code&gt;-Werror=&amp;lt;wflag&amp;gt;&lt;/code&gt; 的影响 -该警告仍将启用。</target>
        </trans-unit>
        <trans-unit id="3552763f2d02369b30ff3cbbef7706ae37b7af80" translate="yes" xml:space="preserve">
          <source>Note that it is acceptable to use parentheses in a &lt;code&gt;inst_head&lt;/code&gt;. For instance, &lt;code&gt;instance (C a)&lt;/code&gt; is accepted, as is &lt;code&gt;instance forall a. (C a)&lt;/code&gt;.</source>
          <target state="translated">注意，在 &lt;code&gt;inst_head&lt;/code&gt; 中使用括号是可以接受的。例如， &lt;code&gt;instance (C a)&lt;/code&gt; 被接受，所有a的实例也被接受 &lt;code&gt;instance forall a. (C a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea6254822cea7a64100f40aab8def82b94101fda" translate="yes" xml:space="preserve">
          <source>Note that it is acceptable to use parentheses in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. For instance, &lt;code&gt;MkV1 :: forall a. (a) -&amp;gt; (V1)&lt;/code&gt; is acceptable, as is &lt;code&gt;MkV2 :: forall a. (a -&amp;gt; V2)&lt;/code&gt;.</source>
          <target state="translated">请注意，可以在 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 中使用括号。例如， &lt;code&gt;MkV1 :: forall a. (a) -&amp;gt; (V1)&lt;/code&gt; 是可接受的， &lt;code&gt;MkV2 :: forall a. (a -&amp;gt; V2)&lt;/code&gt; 也是可接受的。（a-&amp;gt; V2）。</target>
        </trans-unit>
        <trans-unit id="c83014bf24d82bb0e1a70474d5dce7c56ea55a43" translate="yes" xml:space="preserve">
          <source>Note that it is safe to call &lt;code&gt;waitForProcess&lt;/code&gt; for the same process in multiple threads. When the process ends, threads blocking on this call will wake in FIFO order.</source>
          <target state="translated">请注意，在多个线程中为同一进程调用 &lt;code&gt;waitForProcess&lt;/code&gt; 是安全的。当进程结束时，在此调用上阻塞的线程将以FIFO顺序唤醒。</target>
        </trans-unit>
        <trans-unit id="7005610565a4c7898f3b659dd8d96fce7be60db0" translate="yes" xml:space="preserve">
          <source>Note that line numbers start counting at one, but column numbers start at zero. This choice was made to follow existing convention (i.e. this is how Emacs does it).</source>
          <target state="translated">请注意,行号从1开始计数,但列号从0开始。这种选择是为了遵循现有的惯例(即Emacs是这样做的)。</target>
        </trans-unit>
        <trans-unit id="b58c5082533c6ce920a238e2630b3a0a649c4aa4" translate="yes" xml:space="preserve">
          <source>Note that memory allocation is unrelated to &lt;em&gt;live memory&lt;/em&gt;, also known as &lt;em&gt;heap residency&lt;/em&gt;. A thread can allocate a large amount of memory and retain anything between none and all of it. It is better to think of the allocation limit as a limit on &lt;em&gt;CPU time&lt;/em&gt;, rather than a limit on memory.</source>
          <target state="translated">请注意，内存分配与&lt;em&gt;活动内存&lt;/em&gt;无关，也称为&lt;em&gt;堆驻留时间&lt;/em&gt;。线程可以分配大量内存，并在所有内存之间保留任何内容。最好将分配限制视为对&lt;em&gt;CPU时间&lt;/em&gt;的限制，而不是对内存的限制。</target>
        </trans-unit>
        <trans-unit id="273d41914c5c6dac58d5704a8903f640ae883fcf" translate="yes" xml:space="preserve">
          <source>Note that module &lt;code&gt;D&lt;/code&gt; was compiled, but in this instance because its source hadn&amp;rsquo;t really changed, its interface remained the same, and the recompilation checker determined that &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; didn&amp;rsquo;t need to be recompiled.</source>
          <target state="translated">请注意，模块 &lt;code&gt;D&lt;/code&gt; 已编译，但是在这种情况下，由于其源代码并没有真正更改，因此其接口保持不变，并且重新编译检查器确定不需要重新编译 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa9b10733e365e8f6145122de16aa95fd734e161" translate="yes" xml:space="preserve">
          <source>Note that no assumptions may be made about the values representing stable pointers. In fact, they need not even be valid memory addresses. The only guarantee provided is that if they are passed back to Haskell land, the function &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; will be able to reconstruct the Haskell value referred to by the stable pointer.</source>
          <target state="translated">注意，不能对表示稳定指针的值做任何假设。实际上，它们甚至不必是有效的内存地址。唯一提供的保证是，如果将它们传递回Haskell领域，则函数 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:deRefStablePtr&quot;&gt;deRefStablePtr&lt;/a&gt;&lt;/code&gt; 将能够重建稳定指针引用的Haskell值。</target>
        </trans-unit>
        <trans-unit id="ebfa96acca93e187bf978a8f0c66831f5deb550f" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">请注意，即使&lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;会更改是否引用Prelude，也不会对隐式引用Prelude的语法给出警告。例如，当 &lt;code&gt;368&lt;/code&gt; 表示 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; （其中 &lt;code&gt;Prelude&lt;/code&gt; 指代实际的Prelude模块，而不考虑正在编译的模块的导入），则不会给出警告。</target>
        </trans-unit>
        <trans-unit id="cc4fefad8cc30b2189f543b2c01f22060d9ca1a7" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">请注意，即使&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt;会更改其是否引用Prelude，也不会对隐式引用Prelude的语法给出警告。例如，当 &lt;code&gt;368&lt;/code&gt; 表示 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; （其中 &lt;code&gt;Prelude&lt;/code&gt; 指代实际的Prelude模块，而不考虑正在编译的模块的导入），则不会给出警告。</target>
        </trans-unit>
        <trans-unit id="49a7cd2da732a498264fe69cdc55ccc2e5f59d22" translate="yes" xml:space="preserve">
          <source>Note that no warning is given for syntax that implicitly refers to the Prelude, even if &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; would change whether it refers to the Prelude. For example, no warning is given when &lt;code&gt;368&lt;/code&gt; means &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; (where &lt;code&gt;Prelude&lt;/code&gt; refers to the actual Prelude module, regardless of the imports of the module being compiled).</source>
          <target state="translated">请注意，即使&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;会更改是否引用Prelude，也不会对隐式引用Prelude的语法给出警告。例如，当 &lt;code&gt;368&lt;/code&gt; 表示 &lt;code&gt;Prelude.fromInteger (368::Prelude.Integer)&lt;/code&gt; （其中 &lt;code&gt;Prelude&lt;/code&gt; 指代实际的Prelude模块，而不考虑正在编译的模块的导入），则不会给出警告。</target>
        </trans-unit>
        <trans-unit id="b3961e6b1d44470d139a066bd7e5e99b36cc380d" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，此函数可解析ASCII范围之外的数字（例如&amp;ldquo; ٤&amp;rdquo;或 &lt;code&gt;U+0664&lt;/code&gt; 0664之类的阿拉伯文数字）以及不是数字的数字字符，但不会解析 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ed51f37ef06c30fed9104ea5ecb01d29f66f7e" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range (such as arabic-indic digits like e.g. &quot;٤&quot; or &lt;code&gt;U+0664&lt;/code&gt;), as well as numeric characters which aren't digits, are parsed by this function but not by &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，此函数可解析ASCII范围之外的数字（例如&amp;ldquo; ٤&amp;rdquo;或 &lt;code&gt;U+0664&lt;/code&gt; 0664之类的阿拉伯文数字）以及不是数字的数字字符，但不会解析 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-char#v:digit&quot;&gt;digit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aca93abfde5ec064588876b85a983dba2e1d897" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">请注意，使用此功能而不是 &lt;code&gt;&lt;a href=&quot;data-char#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 可以选择ASCII范围之外的数字以及不是数字的数字字符。这样的字符可能是标识符的一部分，但打印机和阅读器不使用它来表示数字。</target>
        </trans-unit>
        <trans-unit id="f6ca479e6c19d19f7cbdf53fa1975eb3bf201fe0" translate="yes" xml:space="preserve">
          <source>Note that numeric digits outside the ASCII range, as well as numeric characters which aren't digits, are selected by this function but not by &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt;. Such characters may be part of identifiers but are not used by the printer and reader to represent numbers.</source>
          <target state="translated">请注意，使用此功能而不是 &lt;code&gt;&lt;a href=&quot;ghc-unicode#v:isDigit&quot;&gt;isDigit&lt;/a&gt;&lt;/code&gt; 可以选择ASCII范围之外的数字以及不是数字的数字字符。这样的字符可能是标识符的一部分，但打印机和阅读器不使用它来表示数字。</target>
        </trans-unit>
        <trans-unit id="00198523cbc0082fb3428e68e1d61ecf58a45ae8" translate="yes" xml:space="preserve">
          <source>Note that on Windows parent directories &lt;code&gt;..&lt;/code&gt; are always fully expanded before the symbolic links, as consistent with the rest of the Windows API (such as &lt;code&gt;GetFullPathName&lt;/code&gt;). In contrast, on POSIX systems parent directories &lt;code&gt;..&lt;/code&gt; are expanded alongside symbolic links from left to right. To put this more concretely: if &lt;code&gt;L&lt;/code&gt; is a symbolic link for &lt;code&gt;R/P&lt;/code&gt;, then on Windows &lt;code&gt;L\..&lt;/code&gt; refers to &lt;code&gt;.&lt;/code&gt;, whereas on other operating systems &lt;code&gt;L/..&lt;/code&gt; refers to &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">请注意，在Windows上，父目录 &lt;code&gt;..&lt;/code&gt; 始终在符号链接之前完全展开，这与Windows API的其余部分（例如 &lt;code&gt;GetFullPathName&lt;/code&gt; ）一致。相反，在POSIX系统上，父目录 &lt;code&gt;..&lt;/code&gt; 与符号链接一起从左到右扩展。更具体地说：如果 &lt;code&gt;L&lt;/code&gt; 是 &lt;code&gt;R/P&lt;/code&gt; 的符号链接，则在Windows上 &lt;code&gt;L\..&lt;/code&gt; 是指 &lt;code&gt;.&lt;/code&gt; 的，而在其他操作系统上 &lt;code&gt;L/..&lt;/code&gt; 是指 &lt;code&gt;R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce57e0602bd626d4114bc65f1120819b7a872c0" translate="yes" xml:space="preserve">
          <source>Note that packages only contain compiled code, so debugging a package requires finding its source and loading that directly.</source>
          <target state="translated">需要注意的是,包只包含编译后的代码,所以调试包需要找到它的源码并直接加载。</target>
        </trans-unit>
        <trans-unit id="92c2203dfd5a194d5612dfeec8df42a4f09f5338" translate="yes" xml:space="preserve">
          <source>Note that primitives are &lt;code&gt;Contrafunctors&lt;/code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意，原语是 &lt;code&gt;Contrafunctors&lt;/code&gt; &lt;a href=&quot;http://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="9748416b7c720b60f4c8302a487524d4091598b0" translate="yes" xml:space="preserve">
          <source>Note that primitives are &lt;code&gt;Contravariant&lt;/code&gt;&lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;. Hence, the following laws hold.</source>
          <target state="translated">请注意，原语是 &lt;code&gt;Contravariant&lt;/code&gt; &lt;a href=&quot;https://hackage.haskell.org/package/contravariant&quot;&gt;http://hackage.haskell.org/package/contravariant&lt;/a&gt;。因此，以下法律成立。</target>
        </trans-unit>
        <trans-unit id="b038144c16c5927ecb1a6490213329a05b30c08f" translate="yes" xml:space="preserve">
          <source>Note that processes which use the POSIX &lt;code&gt;exec&lt;/code&gt; system call (e.g. &lt;code&gt;gcc&lt;/code&gt;) require special care on Windows. Specifically, the &lt;code&gt;msvcrt&lt;/code&gt; C runtime used frequently on Windows emulates &lt;code&gt;exec&lt;/code&gt; in a non-POSIX compliant manner, where the caller will be terminated (with exit code 0) and execution will continue in a new process. As a result, on Windows it will appear as though a child process which has called &lt;code&gt;exec&lt;/code&gt; has terminated despite the fact that the process would still be running on a POSIX-compliant platform.</source>
          <target state="translated">请注意，在Windows上，使用POSIX &lt;code&gt;exec&lt;/code&gt; 系统调用的进程（例如 &lt;code&gt;gcc&lt;/code&gt; ）需要特别注意。具体来说，Windows上经常使用的 &lt;code&gt;msvcrt&lt;/code&gt; C运行时以不符合POSIX的方式模拟 &lt;code&gt;exec&lt;/code&gt; ，在此方式下，调用方将被终止（退出代码为0），并且执行将在新进程中继续。结果，在Windows上，尽管该进程仍将在符合POSIX的平台上运行，但似乎已终止了名为 &lt;code&gt;exec&lt;/code&gt; 的子进程。</target>
        </trans-unit>
        <trans-unit id="5e2096ed561c2bf3900c21383006ef3f61805855" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">注意，来自终结器的引用不一定会阻止另一个对象被终结。如果A的终结器引用B（也许使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; ，则唯一的保证是B的终结器将永远不会在A之前启动。如果A和B都无法访问，则这两个终结器将一起启动。有关终结器排序的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1e90d7572d19320cf7344ae3b1d0ce896d5029a" translate="yes" xml:space="preserve">
          <source>Note that references from a finalizer do not necessarily prevent another object from being finalized. If A's finalizer refers to B (perhaps using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;, then the only guarantee is that B's finalizer will never be started before A's. If both A and B are unreachable, then both finalizers will start together. See &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; for more on finalizer ordering.</source>
          <target state="translated">注意，来自终结器的引用不一定会阻止另一个对象被终结。如果A的终结器引用B（也许使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; ，则唯一的保证是B的终结器将永远不会在A之前启动。如果A和B都无法访问，则这两个终结器将一起启动。有关终结器排序的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc356b8793bb083a67ad53425e549e6eaf817f79" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is ignored. For example,</source>
          <target state="translated">注意 &lt;code&gt;:^:&lt;/code&gt; 右关联性被忽略。例如，</target>
        </trans-unit>
        <trans-unit id="ea16129864c9bc69b1267cd317e60b8e1cd54033" translate="yes" xml:space="preserve">
          <source>Note that right-associativity of &lt;code&gt;:^:&lt;/code&gt; is unused.</source>
          <target state="translated">请注意， &lt;code&gt;:^:&lt;/code&gt; 的右相关性未使用。</target>
        </trans-unit>
        <trans-unit id="cb25fb232eaa8d92d1074e6f26210af239a4d814" translate="yes" xml:space="preserve">
          <source>Note that sequences are typically &lt;em&gt;slower&lt;/em&gt; than lists when using only operations for which they have the same big-(O) complexity: sequences make rather mediocre stacks!</source>
          <target state="translated">请注意，当仅使用序列具有相同的大（O）复杂度的操作时，序列通常比列表&lt;em&gt;慢&lt;/em&gt;：序列构成相当平庸的堆栈！</target>
        </trans-unit>
        <trans-unit id="c723aeed4af9dd83a9b82069c07b9c3ccbc5da99" translate="yes" xml:space="preserve">
          <source>Note that signature matching does check if &lt;em&gt;fixity&lt;/em&gt; matches, so be sure specify fixity of ordinary identifiers if you intend to use them with backticks.</source>
          <target state="translated">请注意，签名匹配会检查&lt;em&gt;固定性是否&lt;/em&gt;匹配，因此，如果要与反引号一起使用，请确保指定普通标识符的固定性。</target>
        </trans-unit>
        <trans-unit id="f095c03ad06a310fd52b2a6d717b98f26776e7da" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;integer-gmp&lt;/code&gt; does not depend on &lt;code&gt;base&lt;/code&gt;, error reporting via exceptions, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt; is not available. Instead, the low-level functions will crash the runtime if called with invalid arguments.</source>
          <target state="translated">请注意，由于 &lt;code&gt;integer-gmp&lt;/code&gt; 不依赖于 &lt;code&gt;base&lt;/code&gt; ，因此无法通过异常， &lt;code&gt;error&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 进行错误报告。相反，如果使用无效参数调用，则低级函数将使运行时崩溃。</target>
        </trans-unit>
        <trans-unit id="9b83514c0ce414a47b834dc48f510e88bcd807c9" translate="yes" xml:space="preserve">
          <source>Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group</source>
          <target state="translated">需要注意的是,由于表达式拼接无法引用同一声明组中的声明,我们可以引入一个顶层(空)拼接来分解声明组</target>
        </trans-unit>
        <trans-unit id="19af66470dd0fd372aaa290faf9416a29cb5103d" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">请注意，由于结果表达式的头部是通过将运算符应用于列表的第一个元素而产生的，因此如果给定运算符的右参数是惰性的，则 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无边界列表产生终止表达式。</target>
        </trans-unit>
        <trans-unit id="1edeaaceca22d9e6e48a4ec76b65a79cb29fc0dc" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">请注意，由于结果表达式的头部是通过将运算符应用于列表的第一个元素而产生的，因此如果给定运算符的右参数是惰性的，则 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无边界列表产生终止表达式。</target>
        </trans-unit>
        <trans-unit id="6fa5cc95e997d42e3f9b2f8917f3475eae62b8bc" translate="yes" xml:space="preserve">
          <source>Note that since the head of the resulting expression is produced by an application of the operator to the first element of the list, given an operator lazy in its right argument, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; can produce a terminating expression from an unbounded list.</source>
          <target state="translated">请注意，由于结果表达式的头部是通过将运算符应用于列表的第一个元素而产生的，因此如果给定运算符的右参数是惰性的，则 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 可以从无边界列表产生终止表达式。</target>
        </trans-unit>
        <trans-unit id="a74f896437a88c7d014238b3770a7c1c62b51099" translate="yes" xml:space="preserve">
          <source>Note that the 32-bit x86 native code generator only supports excess-precision mode, so neither &lt;code&gt;-fexcess-precision&lt;/code&gt; nor &lt;code&gt;-fno-excess-precision&lt;/code&gt; has any effect. This is a known bug, see &lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;.</source>
          <target state="translated">请注意，32位x86本机代码生成器仅支持超精度模式，因此 &lt;code&gt;-fexcess-precision&lt;/code&gt; 和 &lt;code&gt;-fno-excess-precision&lt;/code&gt; 均无效。这是一个已知的错误，请参阅&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC中的错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="330613fe18f73ee23466f7511d7b202676e5cd38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-odir&lt;/code&gt; option does &lt;em&gt;not&lt;/em&gt; affect where the interface files are put; use the &lt;code&gt;-hidir&lt;/code&gt; option for that. In the above example, they would still be put in &lt;code&gt;parse/Foo.hi&lt;/code&gt;, &lt;code&gt;parse/Bar.hi&lt;/code&gt;, and &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;-odir&lt;/code&gt; 选项并&lt;em&gt;不会&lt;/em&gt;影响在接口文件放在; &lt;code&gt;-hidir&lt;/code&gt; 使用-hidir选项。在上面的示例中，它们仍将放在 &lt;code&gt;parse/Foo.hi&lt;/code&gt; ， &lt;code&gt;parse/Bar.hi&lt;/code&gt; 和 &lt;code&gt;gurgle/Bumble.hi&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="309a5bb3e84ee602253ec738970608aecfccc201" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 并不是特别懒惰。要产生任何结果，将需要与各个结果序列的对数之和成正比的时间。</target>
        </trans-unit>
        <trans-unit id="ecf7bfd1b411f608d1147e0ef0a9518d1e3597b7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 并不是特别懒惰。要产生任何结果，将需要与各个结果序列的对数之和成正比的时间。</target>
        </trans-unit>
        <trans-unit id="9baa0deab26388879fdb97317652cc5b58ef6ba5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; method, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, is not particularly lazy. It will take time proportional to the sum of the logarithms of the individual result sequences to produce anything whatsoever.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 方法 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 并不是特别懒惰。要产生任何结果，将需要与各个结果序列的对数之和成正比的时间。</target>
        </trans-unit>
        <trans-unit id="5e6f2cf53da86d8f316c7d0c0ffc6df711b35a02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致在文件中写入额外的字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="532a96aa546fe516b65f4c317f8d98964d1adb0b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致将额外的字节顺序标记写入文件。</target>
        </trans-unit>
        <trans-unit id="5177125357c8ba392c64ff5a83db619e0110c256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致在文件中写入额外的字节顺序标记。</target>
        </trans-unit>
        <trans-unit id="2204063e4c34f1c3a4a4b15d40a00171735eecd7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; remembers nothing about the state of the encoder/decoder in use on this &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. For example, if the encoding in use is UTF-16, then using &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; to save and restore the encoding may result in an extra byte-order-mark being written to the file.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 不会记住此 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 上使用的编码器/解码器的状态。例如，如果使用的编码是UTF-16，则使用 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetEncoding&quot;&gt;hGetEncoding&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 保存和恢复编码可能会导致将额外的字节顺序标记写入文件。</target>
        </trans-unit>
        <trans-unit id="2b693c1b448bc94cf66607a78730b10d509a368a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Lift&lt;/code&gt; typeclass takes advantage of &lt;a href=&quot;#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt; in order to support instances involving unboxed types. This means &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; also works for these types:</source>
          <target state="translated">请注意， &lt;code&gt;Lift&lt;/code&gt; 类型类利用&lt;a href=&quot;#runtime-rep&quot;&gt;Levity多态性&lt;/a&gt;来支持涉及未装箱类型的实例。这意味着&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;也适用于以下类型：</target>
        </trans-unit>
        <trans-unit id="7e0b7ebca01c04086bce79e74e8b55a503cf518c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Lift&lt;/code&gt; typeclass takes advantage of &lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;Levity polymorphism&lt;/a&gt; in order to support instances involving unboxed types. This means &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; also works for these types:</source>
          <target state="translated">请注意， &lt;code&gt;Lift&lt;/code&gt; 类型类利用&lt;a href=&quot;levity_polymorphism#runtime-rep&quot;&gt;Levity多态性&lt;/a&gt;来支持涉及未装箱类型的实例。这意味着&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;也适用于以下类型：</target>
        </trans-unit>
        <trans-unit id="9f1e65aa301e4b1be82f664f9499398a1e7e1f92" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Prelude&lt;/code&gt; import is marked as implicit. It can be overridden with an explicit &lt;code&gt;Prelude&lt;/code&gt; import, just like in a Haskell module.</source>
          <target state="translated">请注意， &lt;code&gt;Prelude&lt;/code&gt; 导入被标记为隐式。可以使用显式的 &lt;code&gt;Prelude&lt;/code&gt; 导入来覆盖它，就像在Haskell模块中一样。</target>
        </trans-unit>
        <trans-unit id="502132d21d5978b3a8ec6cd6de231a4d98125ce2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;nominal&lt;/code&gt; type arguments are equal, the &lt;code&gt;representational&lt;/code&gt; type arguments can differ, but need to have a &lt;code&gt;Coercible&lt;/code&gt; instance themself, and the &lt;code&gt;phantom&lt;/code&gt; type arguments can be changed arbitrarily.</source>
          <target state="translated">请注意， &lt;code&gt;nominal&lt;/code&gt; 类型参数是相等的， &lt;code&gt;representational&lt;/code&gt; 类型参数可以不同，但​​是 &lt;code&gt;Coercible&lt;/code&gt; 自己需要具有Coercible实例，并且 &lt;code&gt;phantom&lt;/code&gt; 类型参数可以任意更改。</target>
        </trans-unit>
        <trans-unit id="e840ae12e6ff09c359b921347e60a8e6a051ed31" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87a7979be5edffeddb07b20613db6dbe774e135f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="454010dcf1120ceeb3132c227f791c724eec83d9" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态恢复为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="170a4ee31f2d0f202d220168ec1fdc8ad29400b0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态还原为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3624d40bf59c16249f1f5a20a1a937e21d71882b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;restore&lt;/code&gt; action passed to the argument to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; does not necessarily unmask asynchronous exceptions, it just restores the masking state to that of the enclosing context. Thus if asynchronous exceptions are already masked, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; cannot be used to unmask exceptions again. This is so that if you call a library function with exceptions masked, you can be sure that the library call will not be able to unmask exceptions again. If you are writing library code and need to use asynchronous exceptions, the only way is to create a new thread; see &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，传递给 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 参数的 &lt;code&gt;restore&lt;/code&gt; 操作不一定会取消屏蔽异步异常，它只是将屏蔽状态还原为封闭上下文的状态。因此，如果异步异常已经被屏蔽，则不能使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 再次取消屏蔽异常。这样一来，如果您调用带屏蔽的异常的库函数，则可以确保该库调用将无法再次取消屏蔽异常。如果您正在编写库代码并且需要使用异步异常，则唯一的方法是创建一个新线程；参见 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e60d714ad07dfbcb448ae9178edf63b83c268312" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;via&lt;/code&gt; type does not have to be a &lt;code&gt;newtype&lt;/code&gt;. The only restriction is that it is coercible with the original data type. This means there can be arbitrary nesting of newtypes, as in the following example:</source>
          <target state="translated">注意，过 &lt;code&gt;via&lt;/code&gt; 类型不必是 &lt;code&gt;newtype&lt;/code&gt; 。唯一的限制是它可以与原始数据类型一起使用。这意味着新类型可以有任意嵌套，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="49a9ad3bbf35b1a32c2be7eda4a33ddd430bcebb" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">请注意，ASCII编码是UTF-8编码的子集，这就是为什么我们可以使用优化的函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 将具有UTF-8编码数字的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字的原因。使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 比 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 更有效。显示，因为它避免构造中间 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。避免使用这种中间数据结构会显着提高性能，因为编码 &lt;code&gt;Cell&lt;/code&gt; 是渲染CSV表的核心操作。有关如何提高 &lt;code&gt;renderString&lt;/code&gt; 性能的更多信息，请参见&lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0dbdccc6b0227bdbf0bac2e7e966328224fe997" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">请注意，ASCII编码是UTF-8编码的子集，这就是为什么我们可以使用优化函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 将具有UTF-8编码数字的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字的原因。使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 比 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.14.1.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 更有效。显示，因为它避免构造中间 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。避免使用这种中间数据结构会显着提高性能，因为编码 &lt;code&gt;Cell&lt;/code&gt; 是渲染CSV表的核心操作。有关如何提高 &lt;code&gt;renderString&lt;/code&gt; 性能的更多信息，请参见&lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72baf6503424ff97ce5c5dd03531e15932ab0bf3" translate="yes" xml:space="preserve">
          <source>Note that the ASCII encoding is a subset of the UTF-8 encoding, which is why we can use the optimized function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; to encode an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; as a decimal number with UTF-8 encoded digits. Using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; is more efficient than &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;, as it avoids constructing an intermediate &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. Avoiding this intermediate data structure significantly improves performance because encoding &lt;code&gt;Cell&lt;/code&gt;s is the core operation for rendering CSV-tables. See &lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt; for further information on how to improve the performance of &lt;code&gt;renderString&lt;/code&gt;.</source>
          <target state="translated">请注意，ASCII编码是UTF-8编码的子集，这就是为什么我们可以使用优化函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 将具有UTF-8编码数字的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字的原因。使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 比 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:stringUtf8&quot;&gt;stringUtf8&lt;/a&gt; . &lt;a href=&quot;../base-4.15.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 更有效。显示，因为它避免构造中间 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。避免使用这种中间数据结构会显着提高性能，因为编码 &lt;code&gt;Cell&lt;/code&gt; 是渲染CSV表的核心操作。有关如何提高 &lt;code&gt;renderString&lt;/code&gt; 性能的更多信息，请参见&lt;a href=&quot;data-bytestring-builder-prim&quot;&gt;Data.ByteString.Builder.Prim&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72f06bfc55bfbd403475823742e13e429c0ca2e0" translate="yes" xml:space="preserve">
          <source>Note that the RTS will not set CPU affinity for bound threads and threads entering Haskell from C/C++, so if your program uses bound threads you should ensure that each bound thread calls the RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; from C/C++ before calling into Haskell. Otherwise there could be a mismatch between the CPU that the thread is running on and the memory it is using while running Haskell code, which will negate any benefits of &lt;code&gt;--numa&lt;/code&gt;.</source>
          <target state="translated">请注意，RTS不会为绑定线程和从C / C ++进入Haskell的线程设置CPU关联性，因此，如果您的程序使用绑定线程，则应确保每个绑定线程在从C / C ++ 调用RTS API &lt;code&gt;rts_setInCallCapability(c,1)&lt;/code&gt; 之前召集到Haskell。否则，在运行Haskell代码时线程正在运行的CPU与它正在使用的内存之间可能会出现不匹配，这将抵消 &lt;code&gt;--numa&lt;/code&gt; 的任何好处。</target>
        </trans-unit>
        <trans-unit id="33e79ebf6a7ee502ff6ae1da2ae2588427c0bcf7" translate="yes" xml:space="preserve">
          <source>Note that the ability to catch an exception does &lt;em&gt;not&lt;/em&gt; guarantee that we can deal with all possible exit points from a computation. Some monads, such as continuation-based stacks, allow for more than just a success/failure strategy, and therefore &lt;code&gt;catch&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; be used by those monads to properly implement a function such as &lt;code&gt;finally&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadMask&quot;&gt;MonadMask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，捕获异常的能力并&lt;em&gt;不能&lt;/em&gt;保证我们可以处理计算中所有可能的退出点。有些monad，例如基于连续的堆栈，不仅允许成功/失败策略使用，因此，这些monad&lt;em&gt;无法&lt;/em&gt;使用 &lt;code&gt;catch&lt;/code&gt; 来正确实现诸如 &lt;code&gt;finally&lt;/code&gt; 的功能。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;control-monad-catch#t:MonadMask&quot;&gt;MonadMask&lt;/a&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58d5dd0ddd0336b419dba13d539e292846c264a2" translate="yes" xml:space="preserve">
          <source>Note that the application of &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; is not an action in the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; context, as &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; type. While the fresh bindings in the following example will force the &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; expressions to be reduced every time the &lt;code&gt;do&lt;/code&gt;-block is executed, &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; would only be reduced once, and the message would only be printed once. If your monad is in &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; may be a better option.</source>
          <target state="translated">需要注意的是应用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 不在动作 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 背景下，作为 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 类型。尽管以下示例中的新绑定将强制每次执行 &lt;code&gt;do&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceM&quot;&gt;traceM&lt;/a&gt;&lt;/code&gt; 时都减少traceM表达式，但 &lt;code&gt;traceM &quot;not crashed&quot;&lt;/code&gt; 将仅减少一次，并且消息仅打印一次。如果您的monad在 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 中，请使用 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt; . &lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 。&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;可能是一个更好的选择。</target>
        </trans-unit>
        <trans-unit id="84f82e7fb65a174913c30b1e72c6c8b2742829f2" translate="yes" xml:space="preserve">
          <source>Note that the bang has no effect at all in this case</source>
          <target state="translated">请注意,在这种情况下,爆炸根本没有任何影响</target>
        </trans-unit>
        <trans-unit id="b4b32cd6cbf824718f0bdfb9b704b062cdf90b8a" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回三个以上的子图,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="68d7fa1f654e15d8602e5a0f9e4ae840941c5c24" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than three subsets, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回三个以上的子集,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="adfda92db68ba407dc5fdfba24f554547fcbb251" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two submaps, but you should not depend on this behaviour because it can change in the future without notice.</source>
          <target state="translated">请注意,当前的实现不会返回两个以上的子图,但你不应该依赖这种行为,因为它可能在未来不经通知就会改变。</target>
        </trans-unit>
        <trans-unit id="a8b5ab808606c44886a770fd7971f5bf90a9f368" translate="yes" xml:space="preserve">
          <source>Note that the current implementation does not return more than two subsets, but you should not depend on this behaviour because it can change in the future without notice. Also, the current version does not continue splitting all the way to individual singleton sets -- it stops at some point.</source>
          <target state="translated">请注意,当前的实现不会返回两个以上的子集,但你不应该依赖这种行为,因为它可能会在未来不经意间改变。另外,当前的版本并不会一直拆分到单个单子集--它会在某个点上停止。</target>
        </trans-unit>
        <trans-unit id="086a1162aacfb2236087d8ed35712ce6942f14ad" translate="yes" xml:space="preserve">
          <source>Note that the datatype &lt;code&gt;G&lt;/code&gt; is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion. It is thus only possible to use this feature if you have provided a complete user-supplied kind signature for the datatype (&lt;a href=&quot;#complete-kind-signatures&quot;&gt;Complete user-supplied kind signatures and polymorphic recursion&lt;/a&gt;).</source>
          <target state="translated">请注意，数据类型 &lt;code&gt;G&lt;/code&gt; 在其主体中使用了不同的种类，因此种类索引的GADT使用一种多态递归形式。因此，只有在为数据类型提供了完整的用户提供的种类签名（&lt;a href=&quot;#complete-kind-signatures&quot;&gt;完整的用户提供的种类签名和多态递归&lt;/a&gt;）后，才能使用此功能。</target>
        </trans-unit>
        <trans-unit id="442f6f35f8b2e112d5cfdda0a46fff2deeaa6cc5" translate="yes" xml:space="preserve">
          <source>Note that the following operator interactions are expected to hold:</source>
          <target state="translated">请注意,以下运算符的交互作用预计会成立。</target>
        </trans-unit>
        <trans-unit id="c120d45347ef3551abdd412d6c3c744d162a17b6" translate="yes" xml:space="preserve">
          <source>Note that the foreign function &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;ccall&lt;/code&gt; calling convention.</source>
          <target state="translated">请注意，外部函数&lt;em&gt;必须&lt;/em&gt;使用 &lt;code&gt;ccall&lt;/code&gt; 调用约定。</target>
        </trans-unit>
        <trans-unit id="2b614124ab834b2d7b11895f2dcc340c5cee01ee" translate="yes" xml:space="preserve">
          <source>Note that the formatting for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; types is currently a bit different from that of C &lt;code&gt;printf(3)&lt;/code&gt;, conforming instead to &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; (and their alternate versions &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt;). This is hard to fix: the fixed versions would format in a backward-incompatible way. In any case the Haskell behavior is generally more sensible than the C behavior. A brief summary of some key differences:</source>
          <target state="translated">请注意，当前 &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 类型的格式与C &lt;code&gt;printf(3)&lt;/code&gt; 的格式略有不同，取而代之的是 &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt;&lt;/code&gt; （以及它们的替代版本 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloatAlt&quot;&gt;showFFloatAlt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloatAlt&quot;&gt;showGFloatAlt&lt;/a&gt;&lt;/code&gt; ）。这很难解决：固定版本将以向后不兼容的方式格式化。在任何情况下，Haskell行为通常比C行为更明智。一些主要区别的简要摘要：</target>
        </trans-unit>
        <trans-unit id="6333d0cd3c8a1c9277e720de89a814eceeaca59c" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; （在下面使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 编写）足以为所有非递归代数数据类型构造 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="e5834f94034f4c9c7099a4fe839728a49c4d2727" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; (written below using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt;) suffice to construct &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s for all non-recursive algebraic datatypes. For example,</source>
          <target state="translated">请注意，函数 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:eitherB&quot;&gt;eitherB&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:pairB&quot;&gt;pairB&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:contramapB&quot;&gt;contramapB&lt;/a&gt;&lt;/code&gt; （在下面使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--36--60-&quot;&gt;&amp;gt;$&amp;lt;&lt;/a&gt;&lt;/code&gt; 编写）足以为所有非递归代数数据类型构造 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="8f8de4b46e9fc5311e12637212df5e73b817991a" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;#8657&lt;/a&gt;.</source>
          <target state="translated">请注意，图形着色分配器是一个实验性的操作，当遇到具有较高寄存器压力的代码时可能会失败&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;＃8657&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45346d36f74c21a2830e97a59a45b659f59ada4b" translate="yes" xml:space="preserve">
          <source>Note that the graph colouring allocator is a bit experimental and may fail when faced with code with high register pressure &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue #8657&lt;/a&gt;.</source>
          <target state="translated">请注意，图形着色分配器只是一个实验，可能在遇到具有较高寄存器压力的代码&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8657&quot;&gt;Issue＃8657&lt;/a&gt;时失败。</target>
        </trans-unit>
        <trans-unit id="96e6fa4ccd6707887b270260302a346013c42cc4" translate="yes" xml:space="preserve">
          <source>Note that the implementation is &lt;em&gt;left-biased&lt;/em&gt; -- the elements of a first argument are always preferred to the second, for example in &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，实现是&lt;em&gt;偏左的&lt;/em&gt; -第一个参数的元素始终优先于第二个参数，例如，在 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="26e0c734ac95701d148351fdd4b47d9138fb0c9b" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="259d0e9c405d160a835af61c7ce39b23637e93f5" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="70bb8bafe9d5794e15a6e0a9bc59a3fd519eaaca" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="f2ac01eed48e680198fa41a99d8fed147ac41510" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="38d11ff08ef387c96608bffa08a777dba57a2a33" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two maps as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the values in the first argument to those in the second.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个映射作为参数并将其组合的函数（例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的值而不是第二个参数中的值。</target>
        </trans-unit>
        <trans-unit id="cb352c04cf593932ccc7109649ee4df971ea1e0e" translate="yes" xml:space="preserve">
          <source>Note that the implementation is generally &lt;em&gt;left-biased&lt;/em&gt;. Functions that take two sets as arguments and combine them, such as &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;, prefer the entries in the first argument to those in the second. Of course, this bias can only be observed when equality is an equivalence relation instead of structural equality.</source>
          <target state="translated">注意，该实现通常是&lt;em&gt;偏左的&lt;/em&gt;。将两个集合作为参数并将它们组合在一起的函数（例如 &lt;code&gt;&lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-set#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; ）更喜欢第一个参数中的条目而不是第二个参数中的条目。当然，只有当平等是等价关系而不是结构平等时，才能观察到这种偏见。</target>
        </trans-unit>
        <trans-unit id="42a24a4ea20d65f2df9e64aaf0077349c30737f9" translate="yes" xml:space="preserve">
          <source>Note that the kind of &lt;code&gt;a&lt;/code&gt; is specified in the kind of &lt;code&gt;C&lt;/code&gt; but inferred in the kind of &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;a&lt;/code&gt; 的种类由 &lt;code&gt;C&lt;/code&gt; 的种类指定，但由 &lt;code&gt;F&lt;/code&gt; 的种类推断。</target>
        </trans-unit>
        <trans-unit id="b863c9095848a793815119dcb80b73aa065664bb" translate="yes" xml:space="preserve">
          <source>Note that the line information in this section is not nearly as rich as the information provided in &lt;code&gt;.debug_info&lt;/code&gt;. Whereas &lt;code&gt;.debug_line&lt;/code&gt; requires that each instruction is assigned exactly one source location, the DIEs in &lt;code&gt;.debug_info&lt;/code&gt; can be used to identify all relevant sources locations.</source>
          <target state="translated">请注意，本节中的行信息并不比 &lt;code&gt;.debug_info&lt;/code&gt; 中提供的信息丰富。而 &lt;code&gt;.debug_line&lt;/code&gt; 要求每个指令被分配一个源位置，在模具 &lt;code&gt;.debug_info&lt;/code&gt; 可用于识别所有有关来源的位置。</target>
        </trans-unit>
        <trans-unit id="cf810684fcb41725f6886705bdc64d801b1f9b52" translate="yes" xml:space="preserve">
          <source>Note that the local variables at each step in the history have been preserved, and can be examined as usual. Also note that the prompt has changed to indicate that we&amp;rsquo;re currently examining the first step in the history: &lt;code&gt;-1&lt;/code&gt;. The command &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt; can be used to traverse forward in the history.</source>
          <target state="translated">请注意，历史记录中每个步骤的局部变量均已保留，可以照常检查。另请注意，提示已更改，以指示我们当前正在检查历史记录的第一步： &lt;code&gt;-1&lt;/code&gt; 。&lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt;命令可用于在历史记录中向前移动。</target>
        </trans-unit>
        <trans-unit id="d8e761e2ee0af0b91555a2d86f5cd5907f02009f" translate="yes" xml:space="preserve">
          <source>Note that the operations to be qualified must be in scope for QualifiedDo to work. I.e. &lt;code&gt;import MAC (label)&lt;/code&gt; in the example above would result in an error, since &lt;code&gt;MAC.&amp;gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;MAC.&amp;gt;&amp;gt;&lt;/code&gt; would not be in scope.</source>
          <target state="translated">请注意，要限定的操作必须在QualifiedDo范围内。即上例中的 &lt;code&gt;import MAC (label)&lt;/code&gt; 将导致错误，因为 &lt;code&gt;MAC.&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;MAC.&amp;gt;&amp;gt;&lt;/code&gt; 不在范围内。</target>
        </trans-unit>
        <trans-unit id="34cdea8f3371da06ac1a345345c3c5002304f5fa" translate="yes" xml:space="preserve">
          <source>Note that the package might still end up being linked into the final program, if it is a dependency (direct or indirect) of another exposed package.</source>
          <target state="translated">请注意,如果这个包是另一个暴露的包的依赖(直接或间接),那么它可能最终还是会被链接到最终程序中。</target>
        </trans-unit>
        <trans-unit id="654350bad2f19f9da14ea79da18d4e92d82c3375" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">请注意，窥视和戳功能可能需要正确对齐的地址才能正常运行。这取决于体系结构；因此，可移植代码应确保在偷看或戳取某些类型 &lt;code&gt;a&lt;/code&gt; 的值时，满足由函数 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 给出的 &lt;code&gt;a&lt;/code&gt; 的对齐约束。</target>
        </trans-unit>
        <trans-unit id="3e394d38fdeaac337578117a43906351c1d79b5f" translate="yes" xml:space="preserve">
          <source>Note that the peek and poke functions might require properly aligned addresses to function correctly. This is architecture dependent; thus, portable code should ensure that when peeking or poking values of some type &lt;code&gt;a&lt;/code&gt;, the alignment constraint for &lt;code&gt;a&lt;/code&gt;, as given by the function &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; is fulfilled.</source>
          <target state="translated">请注意，窥视和戳功能可能需要正确对齐的地址才能正常运行。这取决于体系结构；因此，可移植代码应确保在偷看或戳取某些类型 &lt;code&gt;a&lt;/code&gt; 的值时，满足由函数 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:alignment&quot;&gt;alignment&lt;/a&gt;&lt;/code&gt; 给出的 &lt;code&gt;a&lt;/code&gt; 的对齐约束。</target>
        </trans-unit>
        <trans-unit id="e73723a6b46c23d5ed4a216d4c7a2b7c6b5806fa" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d82712c12c8cee5b77f4ba6fbc419e98e702525b" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22e279d3458c2e34319e6e20c6829368879e2a50" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1166a95e8823cf3e0d0bc99a95c0278ded704bed" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bfbd6466cf9031a0e65d2f5ee134d92903f93ba" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/pretty-1.1.3.6/Text-PrettyPrint.html#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48307915548614ed31e55439a104a2889c670ae0" translate="yes" xml:space="preserve">
          <source>Note that the precedence level is a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; so there is an unlimited number of levels. This module re-exports &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，优先级别是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ,因此存在无限数量的级别。此模块重新导出 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f8de5a86d574b2ca399eee3e30f64be312fc9bc" translate="yes" xml:space="preserve">
          <source>Note that the rather verbose syntax for composition stems from the requirement to be able to compute the size / size bound at compile time.</source>
          <target state="translated">请注意,组成的相当啰嗦的语法源于在编译时能够计算大小/尺寸约束的要求。</target>
        </trans-unit>
        <trans-unit id="54b1d4f1be10b0845077542d67e90448dc344e0a" translate="yes" xml:space="preserve">
          <source>Note that the second example has a &lt;code&gt;forall&lt;/code&gt; that binds both a kind &lt;code&gt;k&lt;/code&gt; and a type variable &lt;code&gt;a&lt;/code&gt; of kind &lt;code&gt;k&lt;/code&gt;. In general, there is no limit to how deeply nested this sort of dependency can work. However, the dependency must be well-scoped: &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; is an error.</source>
          <target state="translated">注意，第二实施例具有 &lt;code&gt;forall&lt;/code&gt; 结合两者一种 &lt;code&gt;k&lt;/code&gt; 和类型可变 &lt;code&gt;a&lt;/code&gt; 种 &lt;code&gt;k&lt;/code&gt; 。通常，对此类依赖项可以嵌套到多深没有限制。但是，依赖项必须具有良好的范围： &lt;code&gt;forall (a :: k) k. ...&lt;/code&gt; 是一个错误。</target>
        </trans-unit>
        <trans-unit id="1b1310d229e7aede634064e0ec7e66e799d19c89" translate="yes" xml:space="preserve">
          <source>Note that the second item only at the &lt;em&gt;head&lt;/em&gt; of the quantified constraint, not its context. Reason: the head is the new goal that has to be solved if we use the instance declaration.</source>
          <target state="translated">请注意，第二项仅位于量化约束的&lt;em&gt;开头&lt;/em&gt;，而不是其上下文。原因：如果我们使用实例声明，那么head是必须解决的新目标。</target>
        </trans-unit>
        <trans-unit id="3c8c63d3b44c41dfd3ecc9855ec677afa1387569" translate="yes" xml:space="preserve">
          <source>Note that the strictness of &lt;code&gt;f&lt;/code&gt; differs from that of &lt;code&gt;g&lt;/code&gt; defined below:</source>
          <target state="translated">请注意， &lt;code&gt;f&lt;/code&gt; 的严格性与以下定义的 &lt;code&gt;g&lt;/code&gt; 的严格性不同：</target>
        </trans-unit>
        <trans-unit id="b0d67f48c00a6048890cd9462dc5217e24546eeb" translate="yes" xml:space="preserve">
          <source>Note that the suffix rules are all repeated twice, once for normal Haskell source files, and once for &lt;code&gt;hs-boot&lt;/code&gt; files (see &lt;a href=&quot;#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;).</source>
          <target state="translated">请注意，所有后缀规则均重复两次，一次用于普通的Haskell源文件，一次用于 &lt;code&gt;hs-boot&lt;/code&gt; 文件（请参阅&lt;a href=&quot;#mutual-recursion&quot;&gt;如何编译相互递归的模块&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ca6ebf983fc1a2fd926f4a83f66b04b8d23d1437" translate="yes" xml:space="preserve">
          <source>Note that the unmask function passed to the child thread should only be used in that thread; the behaviour is undefined if it is invoked in a different thread.</source>
          <target state="translated">需要注意的是,传递给子线程的解除掩码函数只能在该线程中使用,如果在不同的线程中调用该函数,则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="cf747bb4028682f6c8c46cd28564c6d642c94e32" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s in instance declarations is somewhat restricted in comparison to other types. For example, instance declarations are not allowed to contain nested &lt;a href=&quot;#id3&quot;&gt;&lt;span id=&quot;id4&quot;&gt;``&lt;/span&gt;&lt;/a&gt;forall``s. See &lt;a href=&quot;instances#formal-instance-syntax&quot;&gt;Formal syntax for instance declaration types&lt;/a&gt; for more information.</source>
          <target state="translated">请注意，与其他类型相比，实例声明中使用&lt;a href=&quot;#id1&quot;&gt;&lt;span id=&quot;id2&quot;&gt;&amp;ldquo;&lt;/span&gt;&lt;/a&gt; forall &lt;span id=&quot;id2&quot;&gt;&amp;rdquo;&lt;/span&gt;受到了一些限制。例如，实例声明不允许包含嵌套的&lt;a href=&quot;#id3&quot;&gt;&lt;span id=&quot;id4&quot;&gt;``&lt;/span&gt;&lt;/a&gt; forall``s。有关更多信息，请参见&lt;a href=&quot;instances#formal-instance-syntax&quot;&gt;实例声明类型的形式语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1c671757e9a3af40d5bdde86bfebfd0651c0310" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; in this module conflicts with an operator with the same name that is being exported by &lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;. However, this package re-exports (most of) the contents of Data.Monoid, so to use semigroups and monoids in the same package just</source>
          <target state="translated">请注意，在此模块中使用 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 与&lt;a href=&quot;data-monoid&quot;&gt;Data.Monoid&lt;/a&gt;导出的同名运算符冲突。但是，此程序包会重新导出（大部分）Data.Monoid的内容，因此仅在同一程序包中使用半组和monoid</target>
        </trans-unit>
        <trans-unit id="da3869327f08d21fab9f4a7548818e33dbc49531" translate="yes" xml:space="preserve">
          <source>Note that there is an orphan &lt;code&gt;Binary&lt;/code&gt; instance for this type supplied by the &lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt; module provided by &lt;code&gt;ghc-boot&lt;/code&gt;. We can't provide here as this would require adding transitive dependencies to the &lt;code&gt;template-haskell&lt;/code&gt; package, which must have a minimal dependency set.</source>
          <target state="translated">请注意， &lt;code&gt;ghc-boot&lt;/code&gt; 提供的&lt;a href=&quot;ghc-languageextensions&quot;&gt;GHC.LanguageExtensions&lt;/a&gt;模块提供了此类型的孤立 &lt;code&gt;Binary&lt;/code&gt; 实例。我们此处无法提供，因为这将需要向 &lt;code&gt;template-haskell&lt;/code&gt; 包中添加传递性依赖，该包必须具有最小的依赖集。</target>
        </trans-unit>
        <trans-unit id="25f165099a7186900fe29f29d734746be66f7ff0" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">请注意,不支持使用大写字符。如果您的应用程序不能在没有使用大写字符的十六进制编码的情况下工作,请联系维护者。</target>
        </trans-unit>
        <trans-unit id="42fd927f1ef5d9b3a3e3d4ec201b36298d76dcdc" translate="yes" xml:space="preserve">
          <source>Note that there is no support for using upper-case characters. Please contact the maintainer, if your application cannot work without hexadecimal encodings that use upper-case characters.</source>
          <target state="translated">请注意,不支持使用大写字符。如果您的应用程序不能在没有使用大写字符的十六进制编码的情况下工作,请联系维护者。</target>
        </trans-unit>
        <trans-unit id="815e86136be57ff7983e8867a1653ca3748062a4" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 7 release series.</source>
          <target state="translated">需要注意的是,这个GHC版本期待7版本系列的LLVM版本。</target>
        </trans-unit>
        <trans-unit id="054fc5bfe46fd252b25912f49de7b42d063bf60e" translate="yes" xml:space="preserve">
          <source>Note that this GHC release expects an LLVM version in the 9 release series.</source>
          <target state="translated">需要注意的是,这个GHC版本期待9版本系列的LLVM版本。</target>
        </trans-unit>
        <trans-unit id="140a5a874045474c447887a9c7534e65797715b8" translate="yes" xml:space="preserve">
          <source>Note that this change relies on an existing meta-rule to resolve ambiguities:</source>
          <target state="translated">请注意,这一变化依靠现有的元规则来解决含糊不清的问题。</target>
        </trans-unit>
        <trans-unit id="6daa68880e86cbbf8117c1ecf2aaa1d59b601a6d" translate="yes" xml:space="preserve">
          <source>Note that this compatibility condition is independent of whether the type family is associated or not, and it is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">请注意,这个兼容性条件与类型族是否关联无关,它不仅是一个一致性的问题,也是一个类型安全的问题。</target>
        </trans-unit>
        <trans-unit id="6a49b31c7b3933e096f19de10387ce395bfc388b" translate="yes" xml:space="preserve">
          <source>Note that this feature is intended for debugging, and should not be relied on for the correct operation of your program. There is no guarantee that the garbage collector will be accurate enough to detect your deadlock, and no guarantee that the garbage collector will run in a timely enough manner. Basically, the same caveats as for finalizers apply to deadlock detection.</source>
          <target state="translated">请注意,这个功能是用来调试的,不应该依靠这个功能来保证你的程序的正确运行。不能保证垃圾回收器能足够准确地检测到你的死锁,也不能保证垃圾回收器能足够及时地运行。基本上,与终结器相同的注意事项也适用于死锁检测。</target>
        </trans-unit>
        <trans-unit id="09a81f8404822ee34cd07d9b5aaca225d5f7984b" translate="yes" xml:space="preserve">
          <source>Note that this flag makes GHC&amp;rsquo;s parser more strict so programs which are accepted without Haddock may be rejected with &lt;a href=&quot;#ghc-flag--haddock&quot;&gt;&lt;code&gt;-haddock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，此标志使GHC的解析器更加严格，因此可以使用&lt;a href=&quot;#ghc-flag--haddock&quot;&gt; &lt;code&gt;-haddock&lt;/code&gt; &lt;/a&gt;拒绝不使用Haddock接受的程序。</target>
        </trans-unit>
        <trans-unit id="f93e105b95e71dad1e256717f21218ff603f0e60" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">请注意，此功能在操作上非常&lt;em&gt;严格&lt;/em&gt;。也就是说， &lt;code&gt;catchAny undefined b == _|_&lt;/code&gt; 。有关详细信息，请参见。</target>
        </trans-unit>
        <trans-unit id="4a3f1beae872eb8d0767738fe954a7102092701f" translate="yes" xml:space="preserve">
          <source>Note that this function is &lt;em&gt;strict&lt;/em&gt; in the action. That is, &lt;code&gt;catchException undefined b == _|_&lt;/code&gt;. See  for details.</source>
          <target state="translated">请注意，此功能在操作上非常&lt;em&gt;严格&lt;/em&gt;。也就是说， &lt;code&gt;catchException undefined b == _|_&lt;/code&gt; 。有关详细信息，请参见。</target>
        </trans-unit>
        <trans-unit id="164ca1931ad3e1b8b8f22ee4c67b74af2bb32823" translate="yes" xml:space="preserve">
          <source>Note that this function may be called by multiple threads simultaneously.</source>
          <target state="translated">请注意,这个函数可以被多个线程同时调用。</target>
        </trans-unit>
        <trans-unit id="be14bcfbfa87beefee836b26fb76d5e01c5bceae" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="4677b22a99bb8480062aaee7c99a3069c99501b0" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="204ab198814021ed6627310d82463388c4393515" translate="yes" xml:space="preserve">
          <source>Note that this function should not be used to express dependencies between finalizers on &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s. For example, if the finalizer for a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F1&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; on a second &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;F2&lt;/code&gt;, then the only guarantee is that the finalizer for &lt;code&gt;F2&lt;/code&gt; is never started before the finalizer for &lt;code&gt;F1&lt;/code&gt;. They might be started together if for example both &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt; are otherwise unreachable, and in that case the scheduler might end up running the finalizer for &lt;code&gt;F2&lt;/code&gt; first.</source>
          <target state="translated">请注意，不应将此函数用于表示 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 上的终结器之间的依赖关系。例如，如果一个终结 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F1&lt;/code&gt; 呼吁 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 在第二 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;F2&lt;/code&gt; ，那么唯一的保证是，终结 &lt;code&gt;F2&lt;/code&gt; 终结了之前从未开始过 &lt;code&gt;F1&lt;/code&gt; 。如果例如 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; 都无法访问，则它们可能一起启动，并且在这种情况下，调度程序可能最终会先运行 &lt;code&gt;F2&lt;/code&gt; 的终结器。</target>
        </trans-unit>
        <trans-unit id="6e3ecf4648736200d9ff929266ddf8cefc397759" translate="yes" xml:space="preserve">
          <source>Note that this is a &quot;shallow&quot; test; the declarations returned merely have instance heads which unify with &lt;code&gt;nm tys&lt;/code&gt;, they need not actually be satisfiable.</source>
          <target state="translated">注意，这是一个&amp;ldquo;浅&amp;rdquo;测试；返回的声明仅具有与 &lt;code&gt;nm tys&lt;/code&gt; 统一的实例头，它们实际上不一定是可满足的。</target>
        </trans-unit>
        <trans-unit id="439905505d9474fed9ffc65381b6ac6111a52311" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="a0ff55b445dc3b8027838fa247f8b759ea676ef6" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="159781685c28a0f652ef7a2657affedee9b597c8" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="ade4eadc51bb90be35da5528bf329479e583e59a" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="191887df22eeccf7c1081143dfdd938d7b2699e9" translate="yes" xml:space="preserve">
          <source>Note that this is a change of behaviour for consistency with &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; &amp;ndash; versions prior to 0.5 threw an error if the &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; was already empty.</source>
          <target state="translated">请注意，这是为了与 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 保持一致而进行的行为更改-如果 &lt;code&gt;&lt;a href=&quot;data-intset-internal#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 已经为空，则0.5之前的版本会引发错误。</target>
        </trans-unit>
        <trans-unit id="b569264b0537b82b52a587dd6185d1e70e6667fe" translate="yes" xml:space="preserve">
          <source>Note that this is an &lt;em&gt;expensive&lt;/em&gt; operation that forces the whole lazy ByteString into memory and then copies all the data. If possible, try to avoid converting back and forth between strict and lazy bytestrings.</source>
          <target state="translated">请注意，这是一个&lt;em&gt;昂贵的&lt;/em&gt;操作，它将整个惰性ByteString强制放入内存，然后复制所有数据。如果可能，请尝试避免在严格字节字符串和惰性字节字符串之间来回转换。</target>
        </trans-unit>
        <trans-unit id="94e1d743d6549fd6c8f8a3e5156f86de80dc015d" translate="yes" xml:space="preserve">
          <source>Note that this is essentially a type-specialized version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt;. This function has a more common signature (matching the signature from &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;), and is often more convenient to use. By contrast, &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; is more expressive, allowing us to implement other functions like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这本质上是 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 的类型专用版本。此函数具有更通用的签名（与&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的签名匹配），并且通常更易于使用。相比之下， &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 更具表现力，它使我们可以实现其他功能，例如 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2df90bf5e787f12773d403c246b319494ad6a673" translate="yes" xml:space="preserve">
          <source>Note that this is essentially a type-specialized version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt;. This function has a more common signature (matching the signature from &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;), and is often more convenient to use. By contrast, &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; is more expressive, allowing us to implement other functions like &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，这本质上是 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 的类型专用版本。此函数具有更通用的签名（与&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的签名匹配），并且通常更易于使用。相比之下， &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:generalBracket&quot;&gt;generalBracket&lt;/a&gt;&lt;/code&gt; 更具表现力，它使我们可以实现其他功能，例如 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracketOnError&quot;&gt;bracketOnError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6aebbc89aa137801ec2b9b8db93a16d46e98c00" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as a grapheme (e.g. a composition of code points that form one visual symbol). For instance, consider the grapheme &quot;&amp;auml;&quot;. This symbol has two Unicode representations: a single code-point representation &lt;code&gt;U+00E4&lt;/code&gt; (the &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; code point), and a two code point representation &lt;code&gt;U+0061&lt;/code&gt; (the &quot;&lt;code&gt;A&lt;/code&gt;&quot; code point) and &lt;code&gt;U+0308&lt;/code&gt; (the &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; code point).</source>
          <target state="translated">请注意，这与字素不一样（例如，组成一个视觉符号的代码点的组合）。例如，考虑字素&amp;ldquo;&amp;auml;&amp;rdquo;。此符号具有两种Unicode表示形式：一个代码点表示形式 &lt;code&gt;U+00E4&lt;/code&gt; （ &lt;code&gt;LATIN SMALL LETTER A WITH DIAERESIS&lt;/code&gt; 代码点的拉丁文小写字母A）和两个代码点表示形式 &lt;code&gt;U+0061&lt;/code&gt; （&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;代码点）和 &lt;code&gt;U+0308&lt;/code&gt; （所述 &lt;code&gt;COMBINING DIAERESIS&lt;/code&gt; 代码点）。</target>
        </trans-unit>
        <trans-unit id="f1fb7a0e32b7e5f879759dbeacfe592b9604fb63" translate="yes" xml:space="preserve">
          <source>Note that this is only a specification, not necessarily the concrete implementation of the function.</source>
          <target state="translated">注意,这只是一个规范,不一定是函数的具体实现。</target>
        </trans-unit>
        <trans-unit id="669d9533b1634ff933892e992fae9bef3085f70e" translate="yes" xml:space="preserve">
          <source>Note that this is unsafe as it allows you to construct ill-kinded types.</source>
          <target state="translated">请注意,这是不安全的,因为它允许你构建恶意的类型。</target>
        </trans-unit>
        <trans-unit id="d02571c77536bd22aa42f3d92c1dd568dc209d06" translate="yes" xml:space="preserve">
          <source>Note that this kind of backtracking parser is very inefficient; reading a large structure may be quite slow (cf &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">请注意，这种回溯解析器效率很低。读取大型结构可能会非常慢（请 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="436febebad9716edb3813b0bdb233588fd016eb7" translate="yes" xml:space="preserve">
          <source>Note that this option also has an effect on code generation (see above).</source>
          <target state="translated">请注意,这个选项对代码生成也有影响(见上文)。</target>
        </trans-unit>
        <trans-unit id="a6b15405a93ed10e85a7b3a620cdf673c82ced0d" translate="yes" xml:space="preserve">
          <source>Note that this policy has changed slightly in GHC 7.4.1 relative to earlier versions, and may yet change further, feedback is welcome.</source>
          <target state="translated">需要注意的是,这个政策在GHC 7.4.1中相对于之前的版本有了细微的变化,还可能会有进一步的变化,欢迎反馈。</target>
        </trans-unit>
        <trans-unit id="b69c87ebe8336d7ccf7274b115a1b224456d8a37" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，如果与&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; 一起&lt;/a&gt;使用，此警告将不会引发错误。</target>
        </trans-unit>
        <trans-unit id="371339dae687a1a51a3fb07f036275ab96d4f0aa" translate="yes" xml:space="preserve">
          <source>Note that this warning will not throw errors if used with &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，如果与&lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; 一起&lt;/a&gt;使用，此警告将不会引发错误。</target>
        </trans-unit>
        <trans-unit id="690fcd2d09231ef4b1eb51f1d47ac594a9ff2305" translate="yes" xml:space="preserve">
          <source>Note that this will also match a function type,</source>
          <target state="translated">请注意,这也将匹配一个函数类型。</target>
        </trans-unit>
        <trans-unit id="38577a39855d6c49037bc139ad505bfea55af18e" translate="yes" xml:space="preserve">
          <source>Note that to avoid wasting space, this value should typically be less than 10% of the size of a stack chunk (&lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-kc ⟨size⟩&lt;/code&gt;&lt;/a&gt;), because in a chain of stack chunks, each chunk will have a gap of unused space of this size.</source>
          <target state="translated">请注意，为避免浪费空间，该值通常应小于堆栈块大小（&lt;a href=&quot;#rts-flag--kc%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-kc ⟨size⟩&lt;/code&gt; &lt;/a&gt;）的10％，因为在堆栈块链中，每个块都将有一个未使用空间尺寸。</target>
        </trans-unit>
        <trans-unit id="50c38f07d65fbe728d13e67127cf7478adb9040c" translate="yes" xml:space="preserve">
          <source>Note that to change some, but not all permissions, a construct on the following lines must be used.</source>
          <target state="translated">需要注意的是,如果要改变部分而非全部的权限,必须使用下面一行结构。</target>
        </trans-unit>
        <trans-unit id="66851a84c14b94c80085f7f6434bc9436c845696" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要产生运算符的最外层应用，必须遍历整个输入列表。像所有的左结合褶皱， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 如果给出一个无限列表将发散。</target>
        </trans-unit>
        <trans-unit id="a61c274d0b954c6dca484514778958a431247b5e" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要产生运算符的最外层应用，必须遍历整个输入列表。像所有的左结合褶皱， &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 如果给出一个无限列表将发散。</target>
        </trans-unit>
        <trans-unit id="9b90a1692bdb0a28629187868f305ac5e1a54c18" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. Like all left-associative folds, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要产生运算符的最外层应用，必须遍历整个输入列表。像所有的左结合褶皱， &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 如果给出一个无限列表将发散。</target>
        </trans-unit>
        <trans-unit id="948767acfa623815c2e53deacab04e0b2b72ef49" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要生成运算符的最外层应用程序，必须遍历整个输入列表。这意味着如果给出无限的列表， &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 将会发散。</target>
        </trans-unit>
        <trans-unit id="1c06bd2a9205927068bd825ef9aa825d38908e90" translate="yes" xml:space="preserve">
          <source>Note that to produce the outermost application of the operator the entire input list must be traversed. This means that &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; will diverge if given an infinite list.</source>
          <target state="translated">请注意，要生成运算符的最外层应用程序，必须遍历整个输入列表。这意味着如果给出无限的列表， &lt;code&gt;&lt;a href=&quot;data-list#v:foldl-39-&quot;&gt;foldl'&lt;/a&gt;&lt;/code&gt; 将会发散。</target>
        </trans-unit>
        <trans-unit id="09a9ad7f696385ace7655fee5e3964335e8ceabd" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;&lt;a href=&quot;data-set#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-set#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; replace an element equal to the given value.</source>
          <target state="translated">请注意，与 &lt;code&gt;&lt;a href=&quot;data-set#v:insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-set#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 将&lt;em&gt;不会&lt;/em&gt;替换元素等于给定值。</target>
        </trans-unit>
        <trans-unit id="639bcb4a8a84771a9594ddef615c26a4482fa193" translate="yes" xml:space="preserve">
          <source>Note that using this option when linking causes GHC to link against shared libraries.</source>
          <target state="translated">请注意,在链接时使用这个选项会导致GHC与共享库链接。</target>
        </trans-unit>
        <trans-unit id="15c08fdbeb90f2cad5ab816623c21e3981596c4c" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">请注意，将投射出合成后期未使用的变量。使用&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义的重写规则（请参见&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;）进行简化后，这可以简化为</target>
        </trans-unit>
        <trans-unit id="d081dca768500d8bfebb68333b03740fb45995ab" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">请注意，将投射出合成后期未使用的变量。使用&lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义的重写规则（请参见&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;）进行简化后，这可以简化为</target>
        </trans-unit>
        <trans-unit id="9afd9087ab3e281f2d9f79e8753dffedc3950893" translate="yes" xml:space="preserve">
          <source>Note that variables not used later in the composition are projected out. After simplification using rewrite rules (see &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) defined in the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module, this reduces to</source>
          <target state="translated">请注意，将投射出合成后期未使用的变量。使用&lt;a href=&quot;../../libraries/base-4.15.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中定义的重写规则（请参见&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;）进行简化后，这可以简化为</target>
        </trans-unit>
        <trans-unit id="e5449f9493cc87f80694124b3b78a072657bfaa5" translate="yes" xml:space="preserve">
          <source>Note that we do promote existential data constructors that are otherwise suitable. For example, consider the following:</source>
          <target state="translated">需要注意的是,我们确实提倡存在性数据构造器,否则就会被认为是合适的。例如,考虑以下内容。</target>
        </trans-unit>
        <trans-unit id="314ff3aa2a3753338a78c5d3b1a3ae5cc49a2871" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">请注意，我们必须给 &lt;code&gt;e&lt;/code&gt; 提供类型签名，否则程序将不会进行类型检查，因为类型不明确。虽然可以捕获任何类型的异常，但是请参见&amp;ldquo;捕获所有异常&amp;rdquo;一节（在&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception中&lt;/a&gt;）以获取有关这样做的问题的说明。</target>
        </trans-unit>
        <trans-unit id="7e4fcbcc185ba6453250d12b73264bd5a24e8c57" translate="yes" xml:space="preserve">
          <source>Note that we have to give a type signature to &lt;code&gt;e&lt;/code&gt;, or the program will not typecheck as the type is ambiguous. While it is possible to catch exceptions of any type, see the section &quot;Catching all exceptions&quot; (in &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;) for an explanation of the problems with doing so.</source>
          <target state="translated">请注意，我们必须给 &lt;code&gt;e&lt;/code&gt; 提供类型签名，否则程序将不会进行类型检查，因为类型是模棱两可的。尽管可以捕获任何类型的异常，但是请参见&amp;ldquo;捕获所有异常&amp;rdquo;一节（在&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception中&lt;/a&gt;）以获取有关这样做的问题的说明。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
