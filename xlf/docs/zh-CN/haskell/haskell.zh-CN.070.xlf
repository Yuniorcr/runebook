<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="bc89363b3d736091da072542a570e3138b391d30" translate="yes" xml:space="preserve">
          <source>The following uses of &lt;code&gt;unsafeCoerce#&lt;/code&gt; are supposed to work (i.e. not lead to spurious compile-time or run-time crashes):</source>
          <target state="translated">&lt;code&gt;unsafeCoerce#&lt;/code&gt; 的以下用法应该（即不会导致虚假的编译时或运行时崩溃）：</target>
        </trans-unit>
        <trans-unit id="1c72fa99c47cb70fcbd686ee80df427b2899a75e" translate="yes" xml:space="preserve">
          <source>The following will fail with an &amp;ldquo;Illegal unboxed tuple&amp;rdquo; error, since the derived instance produced by the compiler makes use of unboxed tuple syntax,</source>
          <target state="translated">由于编译器生成的派生实例使用了拆箱元组语法，因此以下操作将失败，并显示&amp;ldquo;非法拆箱元组&amp;rdquo;错误，</target>
        </trans-unit>
        <trans-unit id="bbe044a46ef1c2c19252cc897f6025061c027f6f" translate="yes" xml:space="preserve">
          <source>The followup discussion that changed the behavior of &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is archived here: &lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;Proposal: Allow gunfold for Data.Map, ...&lt;/a&gt;</source>
          <target state="translated">更改 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 行为的后续讨论存储在此处：&lt;a href=&quot;http://markmail.org/message/trovdc6zkphyi3cr#query:+page:1+mid:a46der3iacwjcf6n+state:results&quot;&gt;建议：允许对Data.Map进行折叠，...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cee1c36106928daf538418e53cc5b65ec5381bc2" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt; and all its methods &lt;em&gt;and associated types&lt;/em&gt;.</source>
          <target state="translated">形式 &lt;code&gt;C(..)&lt;/code&gt; （其中 &lt;code&gt;C&lt;/code&gt; 是一个类）将类 &lt;code&gt;C&lt;/code&gt; 及其所有方法&lt;em&gt;和相关类型&lt;/em&gt;命名。</target>
        </trans-unit>
        <trans-unit id="16df0b26ad83c27523378eaf1216ddacafe4cfa5" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is a class, names the class &lt;code&gt;C&lt;/code&gt;, and the specified methods &lt;code&gt;mi&lt;/code&gt; and associated types &lt;code&gt;Tj&lt;/code&gt;. The types need a keyword &amp;ldquo;&lt;code&gt;type&lt;/code&gt;&amp;rdquo; to distinguish them from data constructors.</source>
          <target state="translated">形式为 &lt;code&gt;C(.., mi, .., type Tj, ..)&lt;/code&gt; ，其中 &lt;code&gt;C&lt;/code&gt; 是一个类，将其命名为 &lt;code&gt;C&lt;/code&gt; ，指定的方法 &lt;code&gt;mi&lt;/code&gt; 和相关类型 &lt;code&gt;Tj&lt;/code&gt; 。类型需要关键字&amp;ldquo; &lt;code&gt;type&lt;/code&gt; &amp;rdquo;以将其与数据构造函数区分开。</target>
        </trans-unit>
        <trans-unit id="54deed429c05521fb5fa3d0bb8ceb609130a547f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names the family &lt;code&gt;T&lt;/code&gt; and all the in-scope constructors (whether in scope qualified or unqualified) that are data instances of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">形式 &lt;code&gt;T(..)&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是数据族，命名族 &lt;code&gt;T&lt;/code&gt; 和所有作用域内的构造函数（无论是在范围内是合格的还是不合格的）都是 &lt;code&gt;T&lt;/code&gt; 的数据实例。</target>
        </trans-unit>
        <trans-unit id="784438eaf0aa44838a323a050c855ee268899421" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a data family, names &lt;code&gt;T&lt;/code&gt; and the specified constructors &lt;code&gt;ci&lt;/code&gt; and fields &lt;code&gt;fj&lt;/code&gt; as usual. The constructors and field names must belong to some data instance of &lt;code&gt;T&lt;/code&gt;, but are not required to belong to the &lt;em&gt;same&lt;/em&gt; instance.</source>
          <target state="translated">形式为 &lt;code&gt;T(.., ci, .., fj, ..)&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是数据族，其名称为 &lt;code&gt;T&lt;/code&gt; ，并且照常指定名称的构造函数 &lt;code&gt;ci&lt;/code&gt; 和字段 &lt;code&gt;fj&lt;/code&gt; 。构造函数和字段名称必须属于 &lt;code&gt;T&lt;/code&gt; 的某些数据实例，但不必属于&lt;em&gt;同一&lt;/em&gt;实例。</target>
        </trans-unit>
        <trans-unit id="e19f785765e870b264c7a6f5303ec2d2e122f27d" translate="yes" xml:space="preserve">
          <source>The form is called a &amp;ldquo;GADT-style declaration&amp;rdquo; because Generalised Algebraic Data Types, described in &lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;, can only be declared using this form.</source>
          <target state="translated">该格式称为&amp;ldquo; GADT样式的声明&amp;rdquo;，因为只能使用此格式来声明&lt;a href=&quot;#gadt&quot;&gt;通用代数数据类型（GADT）中&lt;/a&gt;描述的通用代数数据类型。</target>
        </trans-unit>
        <trans-unit id="ccb8198ff02595b7c5252294cca08712b727694b" translate="yes" xml:space="preserve">
          <source>The form with a type variable at the head allows this:</source>
          <target state="translated">在头部带有类型变量的表单允许这样做。</target>
        </trans-unit>
        <trans-unit id="33fa9d40a30aa7e6dce906a9649768430ce7ca3a" translate="yes" xml:space="preserve">
          <source>The format character &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; was invoked with. &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; should fail unless this character matches the type. It is normal to handle many different format characters for a single type.</source>
          <target state="translated">调用格式字符 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 。除非此字符与类型匹配，否则 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 应该失败。通常为一个类型处理许多不同格式的字符。</target>
        </trans-unit>
        <trans-unit id="2d9a19d4aec50fa6639cb12bdd8357cf823eed22" translate="yes" xml:space="preserve">
          <source>The format in which GHC currently stores its typechecked AST, makes it costly to collect the types for some expressions nodes. For the sake of performance, GHC currently chooses to skip over these, so not all expression nodes should be expected to have type information on them. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;Issue #16233&lt;/a&gt; for more.</source>
          <target state="translated">GHC当前存储其类型检查的AST的格式，使得收集某些表达式节点的类型的成本很高。为了提高性能，GHC当前选择跳过这些，因此，并非所有表达式节点都应该具有类型信息。有关更多信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/16233&quot;&gt;问题＃16233&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d12d8f748fe76f6f798cf8384f400dd6e25b26a" translate="yes" xml:space="preserve">
          <source>The format of the log file is described by the header &lt;code&gt;EventLogFormat.h&lt;/code&gt; that comes with GHC, and it can be parsed in Haskell using the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; library. To dump the contents of a &lt;code&gt;.eventlog&lt;/code&gt; file as text, use the tool &lt;code&gt;ghc-events show&lt;/code&gt; that comes with the &lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt; package.</source>
          <target state="translated">日志文件的格式由GHC附带的标头 &lt;code&gt;EventLogFormat.h&lt;/code&gt; 描述，可以使用&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;库在Haskell中对其进行解析。要将 &lt;code&gt;.eventlog&lt;/code&gt; 文件的内容转储为文本，请使用&lt;a href=&quot;http://hackage.haskell.org/package/ghc-events&quot;&gt;ghc-events&lt;/a&gt;软件包随附的 &lt;code&gt;ghc-events show&lt;/code&gt; 工具。</target>
        </trans-unit>
        <trans-unit id="be4698f989f63506bf7e347d2e60a53dbb0e6400" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary characters and &lt;em&gt;conversion specifications&lt;/em&gt;, which specify how to format one of the arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; in the output string. A format specification is introduced by the &lt;code&gt;%&lt;/code&gt; character; this character can be self-escaped into the format string using &lt;code&gt;%%&lt;/code&gt;. A format specification ends with a &lt;em&gt;format character&lt;/em&gt; that provides the primary information about how to format the value. The rest of the conversion specification is optional. In order, one may have flag characters, a width specifier, a precision specifier, and type-specific modifier characters.</source>
          <target state="translated">格式字符串由普通字符和&lt;em&gt;转换规范组成&lt;/em&gt;，它们指定如何格式化输出字符串中 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的参数之一。格式规范由 &lt;code&gt;%&lt;/code&gt; 字符引入；可以使用 &lt;code&gt;%%&lt;/code&gt; 将其自动转义为格式字符串。格式规范以&lt;em&gt;格式字符&lt;/em&gt;结尾，该&lt;em&gt;字符&lt;/em&gt;提供有关如何格式化值的主要信息。转换规范的其余部分是可选的。按顺序，可以具有标志字符，宽度说明符，精度说明符和特定于类型的修饰符字符。</target>
        </trans-unit>
        <trans-unit id="25e09c7cb4393ecfca8f299ffa2b0d2ecb753a77" translate="yes" xml:space="preserve">
          <source>The former will result in far better code.</source>
          <target state="translated">前者会带来更好的代码。</target>
        </trans-unit>
        <trans-unit id="64194ba26d3825d046086abae5391759fabeb498" translate="yes" xml:space="preserve">
          <source>The full Haskell import syntax is supported, including &lt;code&gt;hiding&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; clauses. The prompt shows the modules that are currently imported, but it omits details about &lt;code&gt;hiding&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, and so on. To see the full story, use &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">支持完整的Haskell导入语法，包括 &lt;code&gt;hiding&lt;/code&gt; 和 &lt;code&gt;as&lt;/code&gt; 子句。提示显示了当前导入的模块，但是省略了有关 &lt;code&gt;hiding&lt;/code&gt; ， &lt;code&gt;as&lt;/code&gt; 等等的详细信息。要查看全文，请使用&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6d2ba0a02591100122d7720b515c37aa08242448" translate="yes" xml:space="preserve">
          <source>The full set of warning options is described below. To turn off any warning, simply give the corresponding &lt;code&gt;-Wno-...&lt;/code&gt; option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with &lt;code&gt;-f(no-)warn-*&lt;/code&gt; instead of &lt;code&gt;-W(no-)*&lt;/code&gt;.</source>
          <target state="translated">全套警告选项如下所述。要关闭任何警告，只需在命令行上提供相应的 &lt;code&gt;-Wno-...&lt;/code&gt; 选项。为了向后兼容8.0之前的GHC版本，所有这些警告仍可以使用 &lt;code&gt;-f(no-)warn-*&lt;/code&gt; 代替 &lt;code&gt;-W(no-)*&lt;/code&gt; 来控制。</target>
        </trans-unit>
        <trans-unit id="dc028589c7596178a298d55a5adc62737995f4c1" translate="yes" xml:space="preserve">
          <source>The fully-qualified name of the module where the type is declared</source>
          <target state="translated">类型被声明的模块的全称。</target>
        </trans-unit>
        <trans-unit id="a1840c040d0f137dff3d86a1c41a473b6f4799b8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; is like &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;, but it takes an extra argument which is an &lt;em&gt;exception predicate&lt;/em&gt;, a function which selects which type of exceptions we're interested in.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ，但是它需要一个额外的参数，它是一个&lt;em&gt;异常谓词&lt;/em&gt;，该函数选择我们感兴趣的异常类型。</target>
        </trans-unit>
        <trans-unit id="6c24fa3787eba0e6f28035b825969cadbe339326" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; takes a complex number and returns a (magnitude, phase) pair in canonical form: the magnitude is nonnegative, and the phase in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;; if the magnitude is zero, then so is the phase.</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;data-complex#v:polar&quot;&gt;polar&lt;/a&gt;&lt;/code&gt; 具有一个复数，并以典范形式返回（量级，相位）对：幅度为非负数，且相位在 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; 范围内；如果幅度为零，则相位也为零。</target>
        </trans-unit>
        <trans-unit id="d424b407dc86bdf0a0767c07efa10515030815a2" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">应用于实数浮点数的函数 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 返回以 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和适当缩放的指数（ &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）表示的有效位数。如果 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 产生 &lt;code&gt;(m,n)&lt;/code&gt; ，则 &lt;code&gt;x&lt;/code&gt; 的值等于 &lt;code&gt;m*b^^n&lt;/code&gt; ，其中 &lt;code&gt;b&lt;/code&gt; 是浮点基数，此外， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 均为零，否则 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; ，其中 &lt;code&gt;d&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ghc-float#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; 的值。特别是， &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。如果该类型包含负零，则还需 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; 。&lt;em&gt;如果&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;或&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; x中的任何一个&lt;em&gt;为&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,&lt;em&gt;则未指定&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;的结果&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe262135e4b1d91cb57eb1b81744970db71313a5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 采用一个实数分数 &lt;code&gt;x&lt;/code&gt; ,并返回一对 &lt;code&gt;(n,f)&lt;/code&gt; ，使得 &lt;code&gt;x = n+f&lt;/code&gt; ，并且：</target>
        </trans-unit>
        <trans-unit id="afbc2bb6bd9e243f694f4d3b3dece0b75ced87dd" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; applied to a real floating-point number returns the significand expressed as an &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; and an appropriately scaled exponent (an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;). If &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; yields &lt;code&gt;(m,n)&lt;/code&gt;, then &lt;code&gt;x&lt;/code&gt; is equal in value to &lt;code&gt;m*b^^n&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix, and furthermore, either &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are both zero or else &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; is the value of &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt;. In particular, &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt;. If the type contains a negative zero, also &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt;. &lt;em&gt;The result of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is unspecified if either of&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;or&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">应用于实数浮点数的函数 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; 返回以 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 和适当缩放的指数（ &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）表示的有效位数。如果 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; 产生 &lt;code&gt;(m,n)&lt;/code&gt; ，则 &lt;code&gt;x&lt;/code&gt; 的值等于 &lt;code&gt;m*b^^n&lt;/code&gt; ，其中 &lt;code&gt;b&lt;/code&gt; 是浮点基数，此外， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 都为零，否则 &lt;code&gt;b^(d-1) &amp;lt;= &lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; m &amp;lt; b^d&lt;/code&gt; ，其中 &lt;code&gt;d&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;prelude#v:floatDigits&quot;&gt;floatDigits&lt;/a&gt; x&lt;/code&gt; 的值。特别是， &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; 0 = (0,0)&lt;/code&gt; 。如果该类型包含负零，则还需 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; (-0.0) = (0,0)&lt;/code&gt; 。&lt;em&gt;如果&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isNaN&quot;&gt;isNaN&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;或&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:isInfinite&quot;&gt;isInfinite&lt;/a&gt; x&lt;/code&gt; x中的任何一个&lt;em&gt;为&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,&lt;em&gt;则未指定&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt; x&lt;/code&gt; x &lt;em&gt;的结果&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="079629951658e63a1aceb4ed5c824cc91a0b5d86" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; takes a real fractional number &lt;code&gt;x&lt;/code&gt; and returns a pair &lt;code&gt;(n,f)&lt;/code&gt; such that &lt;code&gt;x = n+f&lt;/code&gt;, and:</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 采用一个实数分数 &lt;code&gt;x&lt;/code&gt; ,并返回一对 &lt;code&gt;(n,f)&lt;/code&gt; ，使得 &lt;code&gt;x = n+f&lt;/code&gt; ，并且：</target>
        </trans-unit>
        <trans-unit id="88f909330278d9f82a3312e25ef59ec6d2186b36" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;coerce&lt;/code&gt; allows you to safely convert between values of types that have the same representation with no run-time overhead. In the simplest case you can use it instead of a newtype constructor, to go from the newtype's concrete type to the abstract type. But it also works in more complicated settings, e.g. converting a list of newtypes to a list of concrete types.</source>
          <target state="translated">函数 &lt;code&gt;coerce&lt;/code&gt; 使您可以在没有运行时开销的情况下，在具有相同表示形式的类型的值之间安全地进行转换。在最简单的情况下，您可以使用它代替newtype构造函数，以将newtype的具体类型转换为abstract类型。但是它也可以在更复杂的设置中工作，例如将新类型列表转换为具体类型列表。</target>
        </trans-unit>
        <trans-unit id="a9426870a71de06c1f556cf879bcdaf0553394f4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f3&lt;/code&gt; has a rank-3 type; it has rank-2 types on the left of a function arrow.</source>
          <target state="translated">函数 &lt;code&gt;f3&lt;/code&gt; 具有3级类型；它在功能箭头的左侧具有等级2类型。</target>
        </trans-unit>
        <trans-unit id="4bebe5f1a75a0eddf8839f635c3decbffc5557dc" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt;&lt;code&gt;-Wincomplete-record-updates&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">下面的函数 &lt;code&gt;f&lt;/code&gt; 在应用于 &lt;code&gt;Bar&lt;/code&gt; 时将失败，因此，当启用&lt;a href=&quot;#ghc-flag--Wincomplete-record-updates&quot;&gt; &lt;code&gt;-Wincomplete-record-updates&lt;/code&gt; &lt;/a&gt;时，编译器将对此发出警告。</target>
        </trans-unit>
        <trans-unit id="782d3d59f72773f7952ce1ebae2822b75b04a8b7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;f&lt;/code&gt; from the previous section has a more accurate type:</source>
          <target state="translated">上一节中的函数 &lt;code&gt;f&lt;/code&gt; 具有更准确的类型：</target>
        </trans-unit>
        <trans-unit id="7ec7041ec2658984f17f499a66ced25885c4a3a1" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromList&lt;/code&gt; constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;.</source>
          <target state="translated">该功能 &lt;code&gt;fromList&lt;/code&gt; 构造结构 &lt;code&gt;l&lt;/code&gt; 从给定的列表 &lt;code&gt;Item l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53dd445850b902910cfbc7105e43df3c60dfa18d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fromListN&lt;/code&gt; takes the input list&amp;rsquo;s length as a hint. Its behaviour should be equivalent to &lt;code&gt;fromList&lt;/code&gt;. The hint can be used for more efficient construction of the structure &lt;code&gt;l&lt;/code&gt; compared to &lt;code&gt;fromList&lt;/code&gt;. If the given hint is not equal to the input list&amp;rsquo;s length the behaviour of &lt;code&gt;fromListN&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;code&gt;fromListN&lt;/code&gt; 函数将输入列表的长度作为提示。它的行为应等效于 &lt;code&gt;fromList&lt;/code&gt; 。与 &lt;code&gt;fromList&lt;/code&gt; 相比，可以将提示用于结构 &lt;code&gt;l&lt;/code&gt; 的更有效构造。如果给定的提示不等于输入列表的长度，则不指定 &lt;code&gt;fromListN&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="b2c51e1ae6a25019f5b8dcb68c7e1cc6360380a0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;g&lt;/code&gt; from the previous section is now rejected with a type error as we would hope because the type of &lt;code&gt;f&lt;/code&gt; does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the &lt;code&gt;Collects&lt;/code&gt; class is nowhere near as general as the original class seemed to be: only one of the four instances for &lt;code&gt;Collects&lt;/code&gt; given above can be used with this version of Collects because only one of them&amp;mdash;the instance for lists&amp;mdash;has a collection type that can be written in the form &lt;code&gt;c
e&lt;/code&gt;, for some type constructor &lt;code&gt;c&lt;/code&gt;, and element type &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">正如我们希望的那样，上一节中的函数 &lt;code&gt;g&lt;/code&gt; 现在被拒绝，类型错误，因为 &lt;code&gt;f&lt;/code&gt; 的类型不允许两个参数具有不同的类型。因此，这是一个多参数类的示例，该类实际上在实践中确实运行得很好，没有歧义问题。但是，有一个陷阱。这个版本的 &lt;code&gt;Collects&lt;/code&gt; 类与原始类看起来并不通用：上面给出的 &lt;code&gt;Collects&lt;/code&gt; 的四个实例中的一个只能与该版本的Collects一起使用，因为只有其中一个（列表的实例）具有对于某些类型构造函数 &lt;code&gt;c&lt;/code&gt; 和元素类型，可以以 &lt;code&gt;c e&lt;/code&gt; 形式编写的集合类型 &lt;code&gt;e&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e1caf69d4b138be614d3615769e3ef6ea6617e4" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;toList&lt;/code&gt; should be the inverse of &lt;code&gt;fromList&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;toList&lt;/code&gt; 应该是fromList的逆 &lt;code&gt;fromList&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f8ca21e6067d938666eb5fad69ffc6307e5c9d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;unsafeCoerce#&lt;/code&gt; allows you to side-step the typechecker entirely. That is, it allows you to coerce any type into any other type. If you use this function, you had better get it right, otherwise segmentation faults await. It is generally used when you want to write a program that you know is well-typed, but where Haskell's type system is not expressive enough to prove that it is well typed.</source>
          <target state="translated">函数 &lt;code&gt;unsafeCoerce#&lt;/code&gt; 可让您完全避开类型检查器。也就是说，它允许您将任何类型强制转换为任何其他类型。如果使用此功能，则最好将其正确设置，否则将出现分段错误。通常，当您要编写知道类型正确的程序，但Haskell的类型系统表现力不足以证明其类型正确时，通常使用它。</target>
        </trans-unit>
        <trans-unit id="4078d840830c2b32e85bca92ef57e0c6f82bd822" translate="yes" xml:space="preserve">
          <source>The function also returns two new handles: * an I/O Completion Port handle on which events will be signaled. * a Job handle which can be used to kill all running processes.</source>
          <target state="translated">该函数还返回两个新的句柄。*一个I/O完成端口句柄,事件将在这个句柄上发出信号.*一个Job句柄,可用于杀死所有正在运行的进程。</target>
        </trans-unit>
        <trans-unit id="f6e72213f9f513b34bc27c803b9c687fb47fd6c8" translate="yes" xml:space="preserve">
          <source>The function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt; is &lt;code&gt;infixr&lt;/code&gt; with fixity -1.</source>
          <target state="translated">功能箭头 &lt;code&gt;-&amp;gt;&lt;/code&gt; 是 &lt;code&gt;infixr&lt;/code&gt; 与固定性-1。</target>
        </trans-unit>
        <trans-unit id="54424bef429db403f4735db658be9ddb164137b0" translate="yes" xml:space="preserve">
          <source>The function creates a temporary file in ReadWrite mode. The created file isn't deleted automatically, so you need to delete it manually.</source>
          <target state="translated">该功能在读写模式下创建一个临时文件。创建的文件不会自动删除,所以需要手动删除。</target>
        </trans-unit>
        <trans-unit id="4d31db636076141a2d374629e18c022c852ebef1" translate="yes" xml:space="preserve">
          <source>The function doesn't verify whether the path exists.</source>
          <target state="translated">该函数并不验证路径是否存在。</target>
        </trans-unit>
        <trans-unit id="add6d8a8d14a017a7abdc22d6a499ce254500df6" translate="yes" xml:space="preserve">
          <source>The function is assumed to define a total ordering.</source>
          <target state="translated">该函数被假定为定义总排序。</target>
        </trans-unit>
        <trans-unit id="8c87908085624472ff4238bfb948223b787875d2" translate="yes" xml:space="preserve">
          <source>The function that applies a parser must now unwrap each of the monad transformers in turn:</source>
          <target state="translated">应用解析器的函数现在必须依次解包每个单体变换器。</target>
        </trans-unit>
        <trans-unit id="83dbb4039dba1fe07aa4bcd8c6ba58bf457a2ec1" translate="yes" xml:space="preserve">
          <source>The function to modify the environment.</source>
          <target state="translated">修改环境的功能。</target>
        </trans-unit>
        <trans-unit id="1ccbf33c88dc57758ba1b802fb4f53d665b9edec" translate="yes" xml:space="preserve">
          <source>The function type constructor.</source>
          <target state="translated">函数类型构造函数。</target>
        </trans-unit>
        <trans-unit id="f0f44ae6963080cf76e0ebf83f004dc8df761919" translate="yes" xml:space="preserve">
          <source>The function will return the corresponding value as &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the key isn't in the map.</source>
          <target state="translated">该函数将返回对应的值 &lt;code&gt;(&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; value)&lt;/code&gt; ，如果键不在地图中，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce3cf6b1fb41916c15598ef7c7a2316d0affe736" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to a comparison function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">该函数通常会应用于比较函数,但更通用的类型确保实现使用它来比较第一个容器的元素和第二个容器的元素。</target>
        </trans-unit>
        <trans-unit id="57722a7fa81914229dcd7f438a467425fc2444d4" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to an equality function, but the more general type ensures that the implementation uses it to compare elements of the first container with elements of the second.</source>
          <target state="translated">该函数通常会被应用于一个平等函数,但更通用的类型确保实现使用它来比较第一个容器的元素和第二个容器的元素。</target>
        </trans-unit>
        <trans-unit id="a2f33e33f25cc5b116bd53d1e8871c737f431f0f" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to comparison functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">该函数通常会应用于比较函数,但更通用的类型确保实现使用它们来比较第一个容器的元素和第二个容器的元素。</target>
        </trans-unit>
        <trans-unit id="4fea0a18b8df51f28201953f3c7f75703eb47939" translate="yes" xml:space="preserve">
          <source>The function will usually be applied to equality functions, but the more general type ensures that the implementation uses them to compare elements of the first container with elements of the second.</source>
          <target state="translated">该函数通常会应用于等价函数,但更通用的类型确保实现使用它们来比较第一个容器的元素和第二个容器的元素。</target>
        </trans-unit>
        <trans-unit id="6b6bc4aeee7f2323c64ee51bd60f90b62c365dcb" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f2&lt;/code&gt; and &lt;code&gt;g2&lt;/code&gt; have rank-2 types; the &lt;code&gt;forall&lt;/code&gt; is on the left of a function arrow. As &lt;code&gt;g2&lt;/code&gt; shows, the polymorphic type on the left of the function arrow can be overloaded.</source>
          <target state="translated">函数 &lt;code&gt;f2&lt;/code&gt; 和 &lt;code&gt;g2&lt;/code&gt; 具有等级2类型；在 &lt;code&gt;forall&lt;/code&gt; 是一个功能箭头的左侧。如 &lt;code&gt;g2&lt;/code&gt; 所示，功能箭头左侧的多态类型可以重载。</target>
        </trans-unit>
        <trans-unit id="436e2ff4e3f10ce06692935420d28156ccb98ad6" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; have the same body, but only &lt;code&gt;f&lt;/code&gt; is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function&amp;rsquo;s type.</source>
          <target state="translated">函数 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 具有相同的主体，但仅给 &lt;code&gt;f&lt;/code&gt; 提供类型签名。当GHC弄清楚如何处理可见类型的应用程序时，它必须知道要实例化的变量。因此，它必须能够对函数类型中的类型变量提供排序。</target>
        </trans-unit>
        <trans-unit id="709a35f15e3b44bedbeb0d4b4dddb4664dc2f475" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;g5&lt;/code&gt; and &lt;code&gt;g6&lt;/code&gt; mean exactly the same thing. But &lt;code&gt;g7&lt;/code&gt; evaluates &lt;code&gt;(f x)&lt;/code&gt;, binds &lt;code&gt;y&lt;/code&gt; to the result, and then evaluates &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">函数 &lt;code&gt;g5&lt;/code&gt; 和 &lt;code&gt;g6&lt;/code&gt; 的含义完全相同。但是 &lt;code&gt;g7&lt;/code&gt; 评估 &lt;code&gt;(f x)&lt;/code&gt; ，将 &lt;code&gt;y&lt;/code&gt; 绑定到结果，然后评估 &lt;code&gt;body&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b19b31f5cbfb6277d7255768c1a9509164d5a55" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; are careful to force values before installing them in an &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;中的函数在将值安装到 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 中之前，请务必先对其进行强制。在懒惰不是必需的情况下，这通常会更有效。该模块中的功能不这样做。</target>
        </trans-unit>
        <trans-unit id="670d1298e5cb7a4e8403b208919c4f9aa9e19f28" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt; are careful to force values before installing them in a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. This is usually more efficient in cases where laziness is not essential. The functions in this module do not do so.</source>
          <target state="translated">&lt;a href=&quot;data-map-strict&quot;&gt;Data.Map.Strict&lt;/a&gt;中的函数在将值安装到 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 中之前，请务必先对其进行强制。在懒惰不是必需的情况下，这通常会更有效。该模块中的功能不这样做。</target>
        </trans-unit>
        <trans-unit id="d7ac968071ec3d6db992b2e9189f08e304a943fb" translate="yes" xml:space="preserve">
          <source>The functions in this library use the following naming conventions:</source>
          <target state="translated">本库中的函数使用以下命名约定。</target>
        </trans-unit>
        <trans-unit id="4d771bd73e07b4943d9ccd53e1231da21d4a47f0" translate="yes" xml:space="preserve">
          <source>The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings.</source>
          <target state="translated">本模块中的函数服从运行时系统的locale、字符集编码和行尾转换设置。</target>
        </trans-unit>
        <trans-unit id="d0245bbfde5cb4645880f74fa8998ab54478221f" translate="yes" xml:space="preserve">
          <source>The general form is &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; are optional.</source>
          <target state="translated">通用格式为 &lt;code&gt;%&amp;lt;modifier&amp;gt;&amp;lt;width&amp;gt;&amp;lt;alternate&amp;gt;&amp;lt;specifier&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;modifier&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;alternate&amp;gt;&lt;/code&gt; 是可选的。</target>
        </trans-unit>
        <trans-unit id="d87f5dd37c519e3511a8db8b010d4f7ff96c2337" translate="yes" xml:space="preserve">
          <source>The general interface</source>
          <target state="translated">总界面</target>
        </trans-unit>
        <trans-unit id="ec767503aee97b2532b6ed4020896fc0a3c857b5" translate="yes" xml:space="preserve">
          <source>The general principle is this:</source>
          <target state="translated">总的原则是这样的。</target>
        </trans-unit>
        <trans-unit id="63fa8f01398fe9d9b6a5c91481c5c9f9c693d55d" translate="yes" xml:space="preserve">
          <source>The general rendering interface, supporting annotations. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">通用渲染界面，支持注释。请参考 &lt;code&gt;Style&lt;/code&gt; 和 &lt;code&gt;Mode&lt;/code&gt; 类型以获取渲染模式，行长和功能区的描述。</target>
        </trans-unit>
        <trans-unit id="443a3115347a69de80f7eab2e438bb5e78262ac7" translate="yes" xml:space="preserve">
          <source>The general rendering interface. Please refer to the &lt;code&gt;Style&lt;/code&gt; and &lt;code&gt;Mode&lt;/code&gt; types for a description of rendering mode, line length and ribbons.</source>
          <target state="translated">通用渲染界面。请参考 &lt;code&gt;Style&lt;/code&gt; 和 &lt;code&gt;Mode&lt;/code&gt; 类型以获取渲染模式，行长和功能区的描述。</target>
        </trans-unit>
        <trans-unit id="2c8107939525836136417ba263c01627df220ab0" translate="yes" xml:space="preserve">
          <source>The generated code for the &lt;code&gt;Functor Wrong&lt;/code&gt; instance would look exactly the same, except with &lt;code&gt;Wrong&lt;/code&gt; replacing every occurrence of &lt;code&gt;Right&lt;/code&gt;. The problem is now that &lt;code&gt;fmap&lt;/code&gt; is being applied recursively to a value of type &lt;code&gt;Either a Int&lt;/code&gt;. This cannot possibly produce a value of type &lt;code&gt;Either b Int&lt;/code&gt;, as &lt;code&gt;fmap&lt;/code&gt; can only change the last type parameter! This causes the generated code to be ill-typed.</source>
          <target state="translated">为 &lt;code&gt;Functor Wrong&lt;/code&gt; 实例生成的代码看起来将完全相同，除了用 &lt;code&gt;Wrong&lt;/code&gt; 替换每次出现的 &lt;code&gt;Right&lt;/code&gt; 之外。现在的问题是 &lt;code&gt;fmap&lt;/code&gt; 递归地应用于类型为 &lt;code&gt;Either a Int&lt;/code&gt; 的值。这不可能产生 &lt;code&gt;Either b Int&lt;/code&gt; 类型的值，因为 &lt;code&gt;fmap&lt;/code&gt; 只能更改最后一个类型参数！这将导致生成的代码输入错误。</target>
        </trans-unit>
        <trans-unit id="32903708d002dac9c0ac078342e2e27cabf0d2dd" translate="yes" xml:space="preserve">
          <source>The generation number of this GC</source>
          <target state="translated">这个GC的世代号</target>
        </trans-unit>
        <trans-unit id="878b032694848adb77a2b859c02bd1b95a7bae5c" translate="yes" xml:space="preserve">
          <source>The goal here is to &lt;code&gt;lift&lt;/code&gt; from monad &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;t2 m&lt;/code&gt; and then &lt;code&gt;lift&lt;/code&gt; this again into &lt;code&gt;t1 (t2 m)&lt;/code&gt;. However, this second &lt;code&gt;lift&lt;/code&gt; can only be accepted when &lt;code&gt;(t2 m)&lt;/code&gt; is a monad and there is no way of establishing that this fact universally holds.</source>
          <target state="translated">此处的目标是将单子 &lt;code&gt;m&lt;/code&gt; &lt;code&gt;lift&lt;/code&gt; 至 &lt;code&gt;t2 m&lt;/code&gt; ，然后再次将其 &lt;code&gt;lift&lt;/code&gt; 至 &lt;code&gt;t1 (t2 m)&lt;/code&gt; 。但是，仅当 &lt;code&gt;(t2 m)&lt;/code&gt; 为单子时才能接受此第二次 &lt;code&gt;lift&lt;/code&gt; 并且无法确定该事实是否普遍存在。</target>
        </trans-unit>
        <trans-unit id="cbfa1f88a3966514e5f590037e0742d3e33e28f3" translate="yes" xml:space="preserve">
          <source>The goal is to preserve the meaning of paths better than &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">目标是保留路径的意义要比 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:normalise&quot;&gt;normalise&lt;/a&gt;&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="4e6155b86f48a01b347dfb545d9546dfe24b006f" translate="yes" xml:space="preserve">
          <source>The goal of the roles system is to track when two types have the same underlying representation. In the example above, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation. But, the corresponding instances of &lt;code&gt;BadIdea&lt;/code&gt; would &lt;em&gt;not&lt;/em&gt; have the same representation, because the types of the implementations of &lt;code&gt;bad&lt;/code&gt; would be different.</source>
          <target state="translated">角色系统的目标是跟踪两种类型何时具有相同的基础表示。在上面的示例中， &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; 具有相同的表示形式。但是， &lt;code&gt;BadIdea&lt;/code&gt; 的对应实例将&lt;em&gt;不会&lt;/em&gt;具有相同的表示形式，因为 &lt;code&gt;bad&lt;/code&gt; 的实现的类型将不同。</target>
        </trans-unit>
        <trans-unit id="ae5a7fa8ebdfcbe0b2302748233617b3ca55c26a" translate="yes" xml:space="preserve">
          <source>The goal of typed holes is to help with writing Haskell code rather than to change the type system. Typed holes can be used to obtain extra information from the type checker, which might otherwise be hard to get. Normally, using GHCi, users can inspect the (inferred) type signatures of all top-level bindings. However, this method is less convenient with terms that are not defined on top-level or inside complex expressions. Holes allow the user to check the type of the term they are about to write.</source>
          <target state="translated">类型孔的目标是帮助编写Haskell代码,而不是改变类型系统。类型孔可以用来从类型检查器中获得额外的信息,否则可能很难获得。通常,使用GHCi,用户可以检查所有顶层绑定的(推断的)类型签名。然而,这种方法对于没有定义在顶层或复杂表达式内部的术语就不太方便了。洞允许用户检查他们将要写的术语的类型。</target>
        </trans-unit>
        <trans-unit id="0cbbcd933189820e27a73038da6c88d11c5e0b90" translate="yes" xml:space="preserve">
          <source>The gory details:</source>
          <target state="translated">血淋淋的细节。</target>
        </trans-unit>
        <trans-unit id="19256158b7bc99497456b028690add2697259def" translate="yes" xml:space="preserve">
          <source>The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible.</source>
          <target state="translated">语法对于lambda抽象、let表达式和条件式的范围是模糊的。通过元规则解决了这一含糊不清的问题,即这些结构中的每一个都尽可能向右延伸。</target>
        </trans-unit>
        <trans-unit id="13bcdca0f47d6db8faa9273bbcc3a3514eb3a812" translate="yes" xml:space="preserve">
          <source>The graph obtained by reversing all edges.</source>
          <target state="translated">通过反转所有边缘得到的图。</target>
        </trans-unit>
        <trans-unit id="84d579939cacc525ddd770c640be60c5f760cbb9" translate="yes" xml:space="preserve">
          <source>The graph: a list of nodes uniquely identified by keys, with a list of keys of nodes this node has edges to. The out-list may contain keys that don't correspond to nodes of the graph; such edges are ignored.</source>
          <target state="translated">图:由键唯一标识的节点列表,以及这个节点有边的节点的键列表。列表外可能包含与图中节点不对应的键,这种边将被忽略。</target>
        </trans-unit>
        <trans-unit id="19a77ba5e8a6424783c2bacf9d044768e5056e5e" translate="yes" xml:space="preserve">
          <source>The group database</source>
          <target state="translated">集团数据库</target>
        </trans-unit>
        <trans-unit id="f37dce2ec9ac848392eba760bfa9b2a8e001c3e2" translate="yes" xml:space="preserve">
          <source>The hash sign does not change semantics at all. We tend to use variable names ending in &amp;ldquo;#&amp;rdquo; for unboxed values or types (e.g. &lt;code&gt;Int#&lt;/code&gt;), but there is no requirement to do so; they are just plain ordinary variables. Nor does the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension bring anything into scope. For example, to bring &lt;code&gt;Int#&lt;/code&gt; into scope you must import &lt;code&gt;GHC.Prim&lt;/code&gt; (see &lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;); the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension then allows you to &lt;em&gt;refer&lt;/em&gt; to the &lt;code&gt;Int#&lt;/code&gt; that is now in scope. Note that with this option, the meaning of &lt;code&gt;x#y = 0&lt;/code&gt; is changed: it defines a function &lt;code&gt;x#&lt;/code&gt; taking a single argument &lt;code&gt;y&lt;/code&gt;; to define the operator &lt;code&gt;#&lt;/code&gt;, put a space: &lt;code&gt;x # y = 0&lt;/code&gt;.</source>
          <target state="translated">哈希符号根本不会改变语义。对于未装箱的值或类型（例如 &lt;code&gt;Int#&lt;/code&gt; ），我们倾向于使用以&amp;ldquo;＃&amp;rdquo;结尾的变量名，但是没有必要这样做；它们只是普通的普通变量。&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展也不会将任何内容纳入范围。例如，要将 &lt;code&gt;Int#&lt;/code&gt; 纳入范围，您必须导入 &lt;code&gt;GHC.Prim&lt;/code&gt; （请参阅未装箱的&lt;a href=&quot;#primitives&quot;&gt;类型和基本操作&lt;/a&gt;）；然后，&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展允许您&lt;em&gt;引用&lt;/em&gt;当前作用域中的 &lt;code&gt;Int#&lt;/code&gt; 。请注意，使用此选项时， &lt;code&gt;x#y = 0&lt;/code&gt; 的含义已更改：它定义了带有单个参数的函数 &lt;code&gt;x#&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; ; 要定义运算符 &lt;code&gt;#&lt;/code&gt; ，请放置一个空格： &lt;code&gt;x # y = 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2210882c0ad0919709f59e7db6b4f28dc98cefd9" translate="yes" xml:space="preserve">
          <source>The header line is followed by ⟨l⟩ lines each containing one completion candidate encoded as (quoted) string literal. Here are some example invocations showing the various cases:</source>
          <target state="translated">头行之后是⟨l⟩行,每一行都包含一个以(引号)字符串文字形式编码的完成候选人。下面是一些显示各种情况的调用示例。</target>
        </trans-unit>
        <trans-unit id="de913877c8fa30a91fa438399fb16f39f34a7e00" translate="yes" xml:space="preserve">
          <source>The header of a signature is &lt;code&gt;signature A where ...&lt;/code&gt; (instead of the usual &lt;code&gt;module A where ...&lt;/code&gt;).</source>
          <target state="translated">签名的头是 &lt;code&gt;signature A where ...&lt;/code&gt; （而不是通常的 &lt;code&gt;module A where ...&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="78e62bbf377912fb128bb2f1870fb9fa408d92d9" translate="yes" xml:space="preserve">
          <source>The heap profiler can produce output to GHC&amp;rsquo;s event log, allowing samples to be correlated with other event log events over the program&amp;rsquo;s lifecycle.</source>
          <target state="translated">堆分析器可以将输出生成到GHC的事件日志，从而使样本可以与程序生命周期中的其他事件日志事件相关联。</target>
        </trans-unit>
        <trans-unit id="5cd522d72de3dbc3a1ac632468d70b83c0446184" translate="yes" xml:space="preserve">
          <source>The heap-overflow message.</source>
          <target state="translated">堆溢出信息。</target>
        </trans-unit>
        <trans-unit id="baec639ab942341375f18c11aa4da668c27baef2" translate="yes" xml:space="preserve">
          <source>The hexadecimal notation for floating point literals is useful when you need to specify floating point constants precisely, as the literal notation corresponds closely to the underlying bit-encoding of the number.</source>
          <target state="translated">当你需要精确地指定浮点常数时,十六进制的浮点符号非常有用,因为文字符号与数字的底层位编码密切相关。</target>
        </trans-unit>
        <trans-unit id="0542015ab0e10f3b338b694e109bbc36d0e1ca73" translate="yes" xml:space="preserve">
          <source>The history is only available when using &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;; the reason for this is we found that logging each breakpoint in the history cuts performance by a factor of 2 or more.</source>
          <target state="translated">历史记录仅在使用&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;时可用。原因是我们发现记录历史记录中的每个断点都会使性能降低2倍或更多。</target>
        </trans-unit>
        <trans-unit id="8e8742e7091ac952b2100b44f6fcab38011c36c7" translate="yes" xml:space="preserve">
          <source>The hpc command has several sub-commands:</source>
          <target state="translated">hpc命令有几个子命令。</target>
        </trans-unit>
        <trans-unit id="cd85d2b986388d0386fde70a80e9bce5adc09ca4" translate="yes" xml:space="preserve">
          <source>The hpc tool assumes you are in the top-level directory of the location where you built your application, and the &lt;code&gt;.tix&lt;/code&gt; file is in the same top-level directory. You can use the flag &lt;code&gt;--srcdir&lt;/code&gt; to use &lt;code&gt;hpc&lt;/code&gt; for any other directory, and use &lt;code&gt;--srcdir&lt;/code&gt; multiple times to analyse programs compiled from difference locations, as is typical for packages.</source>
          <target state="translated">hpc工具假定您位于构建应用程序的位置的顶级目录中，而 &lt;code&gt;.tix&lt;/code&gt; 文件位于同一顶级目录中。您可以使用 &lt;code&gt;--srcdir&lt;/code&gt; 标志将 &lt;code&gt;hpc&lt;/code&gt; 用于任何其他目录，并多次使用 &lt;code&gt;--srcdir&lt;/code&gt; 来分析从不同位置编译的程序，这对于软件包来说是典型的。</target>
        </trans-unit>
        <trans-unit id="ae95e293d652aa6b2e442077a87caf492f54c808" translate="yes" xml:space="preserve">
          <source>The idea is that &lt;code&gt;a&lt;/code&gt; should really be a representational parameter, but role inference assigns it to phantom. This makes some level of sense: a pointer to an &lt;code&gt;Int&lt;/code&gt; really is representationally the same as a pointer to a &lt;code&gt;Bool&lt;/code&gt;. But, that&amp;rsquo;s not at all how we want to use &lt;code&gt;Ptr&lt;/code&gt;s! So, we want to be able to say</source>
          <target state="translated">想法是 &lt;code&gt;a&lt;/code&gt; 应该确实是一个表示性参数，但是角色推断会将其分配给幻像。这在某种意义上是有意义的：指向 &lt;code&gt;Int&lt;/code&gt; 的指针实际上与指向 &lt;code&gt;Bool&lt;/code&gt; 的指针相同。但是，这根本不是我们要使用 &lt;code&gt;Ptr&lt;/code&gt; 的方式！所以，我们希望能够说</target>
        </trans-unit>
        <trans-unit id="e9b8ad3e3c7027edac335bae313b7046d76ae478" translate="yes" xml:space="preserve">
          <source>The idea is that we can then use &lt;code&gt;Point&lt;/code&gt; just as if we had defined a new datatype &lt;code&gt;MyPoint&lt;/code&gt; with two fields &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">这个想法是，然后我们就可以像使用两个字段 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 定义新数据类型 &lt;code&gt;MyPoint&lt;/code&gt; 一样使用 &lt;code&gt;Point&lt;/code&gt; 了。</target>
        </trans-unit>
        <trans-unit id="b5577da026d4ae923963655859a7950c0d959c92" translate="yes" xml:space="preserve">
          <source>The idea is that we have a new fundamental type constant &lt;code&gt;TYPE&lt;/code&gt;, which is parameterised by a &lt;code&gt;RuntimeRep&lt;/code&gt;. We thus get &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt;. Anything with a type of the form &lt;code&gt;TYPE x&lt;/code&gt; can appear to either side of a function arrow &lt;code&gt;-&amp;gt;&lt;/code&gt;. We can thus say that &lt;code&gt;-&amp;gt;&lt;/code&gt; has type &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt;. The result is always lifted because all functions are lifted in GHC.</source>
          <target state="translated">这个想法是，我们有了一个新的基本类型常量 &lt;code&gt;TYPE&lt;/code&gt; ，它由 &lt;code&gt;RuntimeRep&lt;/code&gt; 参数化。因此，我们得到 &lt;code&gt;Int# :: TYPE 'IntRep&lt;/code&gt; 和 &lt;code&gt;Bool :: TYPE 'LiftedRep&lt;/code&gt; 。类型为 &lt;code&gt;TYPE x&lt;/code&gt; 的任何内容都可以出现在功能箭头 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的两侧。因此，我们可以说 &lt;code&gt;-&amp;gt;&lt;/code&gt; 具有类型 &lt;code&gt;TYPE r1 -&amp;gt; TYPE r2 -&amp;gt; TYPE 'LiftedRep&lt;/code&gt; 。由于GHC中的所有功能都已解除，因此总是会解除结果。</target>
        </trans-unit>
        <trans-unit id="fa2009e07206ad049abebf85b239bfe1d707aee1" translate="yes" xml:space="preserve">
          <source>The idea is there can be no legal calls to &lt;code&gt;f&lt;/code&gt; because every call will give rise to an ambiguous constraint. Indeed, the &lt;em&gt;only&lt;/em&gt; purpose of the ambiguity check is to report functions that cannot possibly be called. We could soundly omit the ambiguity check on type signatures entirely, at the expense of delaying ambiguity errors to call sites. Indeed, the language extension &lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt;&lt;code&gt;AllowAmbiguousTypes&lt;/code&gt;&lt;/a&gt; switches off the ambiguity check.</source>
          <target state="translated">这个想法是不可能对 &lt;code&gt;f&lt;/code&gt; 进行合法的调用，因为每次调用都会引起模棱两可的约束。确实，歧义检查的&lt;em&gt;唯一&lt;/em&gt;目的是报告无法调用的功能。我们可以完全忽略对类型签名的歧义检查，但要以延迟调用站点的歧义错误为代价。实际上，语言扩展&lt;a href=&quot;#extension-AllowAmbiguousTypes&quot;&gt; &lt;code&gt;AllowAmbiguousTypes&lt;/code&gt; &lt;/a&gt;关闭了歧义检查。</target>
        </trans-unit>
        <trans-unit id="9edc673edb982c2282b649a46c26961301e8081f" translate="yes" xml:space="preserve">
          <source>The idea of using existential quantification in data type declarations was suggested by Perry, and implemented in Hope+ (Nigel Perry, &lt;em&gt;The Implementation of Practical Functional Programming Languages&lt;/em&gt;, PhD Thesis, University of London, 1991). It was later formalised by Laufer and Odersky (&lt;em&gt;Polymorphic type inference and abstract data types&lt;/em&gt;, TOPLAS, 16(5), pp. 1411-1430, 1994). It&amp;rsquo;s been in Lennart Augustsson&amp;rsquo;s &lt;code&gt;hbc&lt;/code&gt; Haskell compiler for several years, and proved very useful. Here&amp;rsquo;s the idea. Consider the declaration:</source>
          <target state="translated">Perry提出了在数据类型声明中使用存在量化的想法，并在Hope +中得到了实现（Nigel Perry，&lt;em&gt;《实用函数编程语言的实现》&lt;/em&gt;，伦敦大学博士学位论文，1991年）。后来由Laufer和Odersky对其进行了形式化处理（&lt;em&gt;多态类型推断和抽象数据类型&lt;/em&gt;，TOPLAS，16（5），第1411-1430页，1994）。它已经在Lennart Augustsson的 &lt;code&gt;hbc&lt;/code&gt; Haskell编译器中使用了几年，并且证明非常有用。这是主意。考虑一下声明：</target>
        </trans-unit>
        <trans-unit id="f61001cad70bbaad44a625a79404312846844b51" translate="yes" xml:space="preserve">
          <source>The identity arrow, which plays the role of &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in arrow notation.</source>
          <target state="translated">身份箭头，以箭头符号的形式充当 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 的角色。</target>
        </trans-unit>
        <trans-unit id="d797741d4a3ad156d7b9784f618a05a1d311a057" translate="yes" xml:space="preserve">
          <source>The identity functor and monad.</source>
          <target state="translated">身份漏斗和单子。</target>
        </trans-unit>
        <trans-unit id="7c8b0e59b588b67f3edbe61854791ee47cfe12bb" translate="yes" xml:space="preserve">
          <source>The identity monad transformer</source>
          <target state="translated">身份单体变换器</target>
        </trans-unit>
        <trans-unit id="54f9712c13de60b181bae26ad1f4c1f7a1f328db" translate="yes" xml:space="preserve">
          <source>The identity monad transformer.</source>
          <target state="translated">身份单体变换器。</target>
        </trans-unit>
        <trans-unit id="bf1cafdec594d8369ed303bb1c662b40aaf0daff" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 的身份</target>
        </trans-unit>
        <trans-unit id="a4ceda1c87510537b203d25ca80c04c39b54cdf6" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 的身份。它也应该满足方程</target>
        </trans-unit>
        <trans-unit id="deee9983cee920e92095b678fac9a903e0f11845" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; 的身份</target>
        </trans-unit>
        <trans-unit id="034960daf8bea9c51407ed94a1c25464ed2788bc" translate="yes" xml:space="preserve">
          <source>The identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt;. It should also satisfy the equations</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 的身份。它也应该满足方程</target>
        </trans-unit>
        <trans-unit id="5dbaaef3597110434c54ae1a2138fb5629731bbb" translate="yes" xml:space="preserve">
          <source>The implementation does not support system calls.</source>
          <target state="translated">实施中不支持系统调用。</target>
        </trans-unit>
        <trans-unit id="7512c5f22af2e468e091d738afee317bd6f3ab0c" translate="yes" xml:space="preserve">
          <source>The implementation is based on</source>
          <target state="translated">实施的依据是</target>
        </trans-unit>
        <trans-unit id="4406a52eaac6bbe886c15f95aa7c9a4f4887ba65" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。另外，基准测试表明，与通用的大小平衡地图实现相比，插入和删除的速度（快得多）（请参见&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="42cee383ad635f6c8d6a1715e198b017fcd560b8" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。另外，基准测试表明，与通用的大小平衡地图实现相比，插入和删除的速度（快得多）（请参见&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5899bda78d1b99406df43306b7f1534696819133" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. Additionally, benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。另外，基准测试表明，与通用的大小平衡地图实现相比，插入和删除的速度（快得多）（请参见&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="78d8c8ee898c5c545e70528f4e14f986552f2ded" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation (see &lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。但是，我的基准测试表明，与一般的大小平衡地图实现（请参阅&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;）相比，它在插入和删除上的速度也快得多。</target>
        </trans-unit>
        <trans-unit id="24c8616bf917dc1c69eac297bc08b786fe0c06a6" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intset#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intset#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。但是，我的基准测试表明，与通用的大小平衡的set实现相比，插入和删除的速度（快得多）（请参见&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="55fccc3b15937a9358c0161b537d1afd44dfe908" translate="yes" xml:space="preserve">
          <source>The implementation is based on &lt;em&gt;big-endian patricia trees&lt;/em&gt;. This data structure performs especially well on binary operations like &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt;. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced set implementation (see &lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;).</source>
          <target state="translated">该实现基于&lt;em&gt;大端方的patricia树&lt;/em&gt;。该数据结构在诸如 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intset-internal#v:intersection&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; 类的二进制运算中表现尤其出色。但是，我的基准测试表明，与通用的大小平衡的set实现相比，插入和删除的速度（快得多）（请参见&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="178e58b7fb96bd95fd580401e99f441f886cc770" translate="yes" xml:space="preserve">
          <source>The implementation is based on the traditional purely-functional queue representation that uses two lists to obtain amortised O(1) enqueue and dequeue operations.</source>
          <target state="translated">该实现基于传统的纯功能队列表示,使用两个列表来获得摊销的O(1)enqueue和dequeue操作。</target>
        </trans-unit>
        <trans-unit id="4463036bd69024477097c960a434a6af09c8061f" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that reordering of memory operations cannot cause type-correct code to go wrong. In particular, when inspecting the value read from an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, the memory writes that created that value must have occurred from the point of view of the current thread.</source>
          <target state="translated">需要实现以确保内存操作的重新排序不会导致类型正确的代码出错。特别是，当检查从 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 读取的值时，从当前线程的角度来看，创建该值的内存写操作必须已经发生。</target>
        </trans-unit>
        <trans-unit id="fb8ec445b14ea757e9282327414d673b0305ee28" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;. If the function passed to &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">实施 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 。如果传递给 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 的函数检查其参数，则结果操作将抛出 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f5d1702e3170c14a64676532aebf2fd23b667a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的实现基于&lt;em&gt;大小平衡的&lt;/em&gt;二叉树（或&lt;em&gt;有界的&lt;/em&gt;树），具体描述如下：</target>
        </trans-unit>
        <trans-unit id="f3594b695ff2e4cfc4a3fffda3940bb5f4b15f6c" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的实现基于&lt;em&gt;大小平衡的&lt;/em&gt;二叉树（或&lt;em&gt;有界的&lt;/em&gt;树），具体描述如下：</target>
        </trans-unit>
        <trans-unit id="f3ded865df489185e9f39c1a5890fb3ac2d0d16a" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is based on &lt;em&gt;size balanced&lt;/em&gt; binary trees (or trees of &lt;em&gt;bounded balance&lt;/em&gt;) as described by:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 的实现基于&lt;em&gt;大小平衡的&lt;/em&gt;二叉树（或&lt;em&gt;有界的平衡&lt;/em&gt;树），其描述如下：</target>
        </trans-unit>
        <trans-unit id="2eb1e65a073f89d353d1b82491d0d335135d9d69" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:RunTH&quot;&gt;RunTH&lt;/a&gt;&lt;/code&gt; 消息的执行</target>
        </trans-unit>
        <trans-unit id="0444f9d8082237d5b98f84df587436a9614cf1ab" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; message: create a new IORef QState, and return a RemoteRef to it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghci-message#v:StartTH&quot;&gt;StartTH&lt;/a&gt;&lt;/code&gt; 消息的实现：创建一个新的IORef QState，并向其返回一个RemoteRef。</target>
        </trans-unit>
        <trans-unit id="6bc3fa0b81755563203b0ca242878725420112c8" translate="yes" xml:space="preserve">
          <source>The implementation uses 2-3 finger trees annotated with sizes, as described in section 4.2 of</source>
          <target state="translated">实施中使用了2-3棵带大小标注的指状树,如在4.2节中所述。</target>
        </trans-unit>
        <trans-unit id="a87c4ceafe0cd86c1c0f98a96d0e26cff7b08cc5" translate="yes" xml:space="preserve">
          <source>The implementation uses the call-stack simulation maintained by the profiler, so it only works if the program was compiled with &lt;code&gt;-prof&lt;/code&gt; and contains suitable SCC annotations (e.g. by using &lt;code&gt;-fprof-auto&lt;/code&gt;). Otherwise, the list returned is likely to be empty or uninformative.</source>
          <target state="translated">该实现使用了探查器维护的调用堆栈模拟，因此，仅当程序使用 &lt;code&gt;-prof&lt;/code&gt; 编译且包含适当的SCC注释（例如，通过使用 &lt;code&gt;-fprof-auto&lt;/code&gt; ）时，该方法才有效。否则，返回的列表可能为空或无用。</target>
        </trans-unit>
        <trans-unit id="b6788a58c1982f00220dd59a9ac7e8fe15617f19" translate="yes" xml:space="preserve">
          <source>The incoming &lt;code&gt;x&lt;/code&gt; is converted using &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt;, then we dispatch to the generic instances using &lt;code&gt;encode'&lt;/code&gt;. We use this as a default definition for &lt;code&gt;encode&lt;/code&gt;. We need the &lt;code&gt;default encode&lt;/code&gt; signature because ordinary Haskell default methods must not introduce additional class constraints, but our generic default does.</source>
          <target state="translated">传入的 &lt;code&gt;x&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:from&quot;&gt;from&lt;/a&gt;&lt;/code&gt; 进行转换，然后我们使用 &lt;code&gt;encode'&lt;/code&gt; 分派到通用实例。我们将其用作 &lt;code&gt;encode&lt;/code&gt; 的默认定义。我们需要 &lt;code&gt;default encode&lt;/code&gt; 签名，因为普通的Haskell默认方法不能引入附加的类约束，而我们的通用默认方法却可以。</target>
        </trans-unit>
        <trans-unit id="2cdd8c06c5214198e849b6d05981aab3d32d8114" translate="yes" xml:space="preserve">
          <source>The incremental input interface</source>
          <target state="translated">增量输入接口</target>
        </trans-unit>
        <trans-unit id="982c0c54fd891b5bd49cff179145ac54d3aa5b07" translate="yes" xml:space="preserve">
          <source>The incremental interface consumes a strict &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; at a time, each being part of the total amount of input. If your decoder needs more input to finish it will return a &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; with a continuation. If there is no more input, provide it &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">增量接口一次消耗一个严格的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，每个都是总输入量的一部分。如果您的解码器需要更多输入才能完成，它将返回带有延续的 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Partial&quot;&gt;Partial&lt;/a&gt;&lt;/code&gt; 。如果没有更多输入，则不提供 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3146e319b6642665d719ade7d912bb954ff2d63" translate="yes" xml:space="preserve">
          <source>The incremental interface gives you more control over how input is provided during parsing. This lets you e.g. interleave parsing and I/O.</source>
          <target state="translated">增量接口让您可以在解析过程中对输入的方式进行更多的控制。这让你可以将解析和I/O交错进行。</target>
        </trans-unit>
        <trans-unit id="c051b888dc5371d4c7a1728cceef03c9f9b40699" translate="yes" xml:space="preserve">
          <source>The information is formatted such that it can be read as a of type &lt;code&gt;[(String, String)]&lt;/code&gt;. Currently the following fields are present:</source>
          <target state="translated">信息被格式化为可以读取为 &lt;code&gt;[(String, String)]&lt;/code&gt; 类型的a 。当前存在以下字段：</target>
        </trans-unit>
        <trans-unit id="5a76a6fe1392f713b6ebeea929ebb56029f377be" translate="yes" xml:space="preserve">
          <source>The initial counter value can be negative which denotes a resource &quot;debt&quot; that requires a respective amount of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; operations to counter-balance.</source>
          <target state="translated">初始计数器值可以为负，这表示资源&amp;ldquo;债务&amp;rdquo;，需要相应数量的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:signalTSem&quot;&gt;signalTSem&lt;/a&gt;&lt;/code&gt; 操作来进行平衡。</target>
        </trans-unit>
        <trans-unit id="2dec26d2e77fa146664e92628931f0bd402a7a5d" translate="yes" xml:space="preserve">
          <source>The initial value left and right of the cursor</source>
          <target state="translated">光标左右的初始值。</target>
        </trans-unit>
        <trans-unit id="c7b64e8e48e54908c3b727b4c3f0042b5289f865" translate="yes" xml:space="preserve">
          <source>The initialisation routine, &lt;code&gt;mylib_init&lt;/code&gt;, calls &lt;code&gt;hs_init()&lt;/code&gt; as normal to initialise the Haskell runtime, and the corresponding deinitialisation function &lt;code&gt;mylib_end()&lt;/code&gt; calls &lt;code&gt;hs_exit()&lt;/code&gt; to shut down the runtime.</source>
          <target state="translated">初始化例程 &lt;code&gt;mylib_init&lt;/code&gt; 照常调用 &lt;code&gt;hs_init()&lt;/code&gt; 来初始化Haskell运行时，相应的 &lt;code&gt;mylib_end()&lt;/code&gt; 初始化函数mylib_end（）调用 &lt;code&gt;hs_exit()&lt;/code&gt; 来关闭运行时。</target>
        </trans-unit>
        <trans-unit id="74ecac49867880c39edcc9122f73fce73221a98f" translate="yes" xml:space="preserve">
          <source>The input file should end with .hsc (it should be plain Haskell source only; literate Haskell is not supported at the moment). Output files by default get names with the &lt;code&gt;.hsc&lt;/code&gt; suffix replaced:</source>
          <target state="translated">输入文件应以.hsc结尾（仅应为纯Haskell源；目前不支持识字Haskell）。默认情况下，输出文件的名称以 &lt;code&gt;.hsc&lt;/code&gt; 后缀替换：</target>
        </trans-unit>
        <trans-unit id="54a5800cd273f30522c8241f5237a75f5ea6ce1e" translate="yes" xml:space="preserve">
          <source>The input lines stored in the history (newest first)</source>
          <target state="translated">存储在历史记录中的输入行(最新的优先)。</target>
        </trans-unit>
        <trans-unit id="6c739498395288f23756ffacf049c5d728041bb8" translate="yes" xml:space="preserve">
          <source>The input prompt</source>
          <target state="translated">输入提示</target>
        </trans-unit>
        <trans-unit id="57092b7ab7c2a987bc9c90336b0ad9cdf5249eb0" translate="yes" xml:space="preserve">
          <source>The input value that caused the error. If the error arose because the end of input was reached or could not be identified precisely, this value will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">导致错误的输入值。如果由于到达输入终点或无法准确识别输入而出现错误，则此值为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38d4405c8eebc2938893eeda1606e7e5691e0dd1" translate="yes" xml:space="preserve">
          <source>The installer that installs GHC on Win32 also sets up the file-suffix associations for &amp;rdquo;.hs&amp;rdquo; and &amp;rdquo;.lhs&amp;rdquo; files so that double-clicking them starts &lt;code&gt;ghci&lt;/code&gt;.</source>
          <target state="translated">在Win32上安装GHC的安装程序还设置了&amp;ldquo; .hs&amp;rdquo;和&amp;ldquo; .lhs&amp;rdquo;文件的文件后缀关联，以便双击它们即可启动 &lt;code&gt;ghci&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeaab7d9918fe1175bfdf3172a8ff60d6d574ffa" translate="yes" xml:space="preserve">
          <source>The instance axioms : &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</source>
          <target state="translated">实例公理： &lt;code&gt;(B a, D a, E a) =&amp;gt; F a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d82e643d691468293fcd6f5135cfe7a24d9a1" translate="yes" xml:space="preserve">
          <source>The instance context is determined by the type signatures of the derived class&amp;rsquo;s methods. For instance, if the class is:</source>
          <target state="translated">实例上下文由派生类的方法的类型签名确定。例如，如果该类是：</target>
        </trans-unit>
        <trans-unit id="ead7524ad446883d4bbd99873e64016bb63c69da" translate="yes" xml:space="preserve">
          <source>The instance declaration is only relevant if the type &lt;code&gt;T&lt;/code&gt; is in use, and if so, GHC will have visited &lt;code&gt;A&lt;/code&gt;&amp;lsquo;s interface file to find &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s definition.</source>
          <target state="translated">只有在使用类型 &lt;code&gt;T&lt;/code&gt; 的情况下，实例声明才有意义，如果这样，GHC将访问 &lt;code&gt;A&lt;/code&gt; 的接口文件以查找 &lt;code&gt;T&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="c7c21710f81c09d49133c941cdff45d1b58bd4f0" translate="yes" xml:space="preserve">
          <source>The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.</source>
          <target state="translated">在一个程序中使用的数据族的实例声明可能完全不重叠,与它们是否关联无关。与类型类实例相比,这不仅是一个一致性的问题,也是一个类型安全的问题。</target>
        </trans-unit>
        <trans-unit id="8cc7dac373c8ecc1b365857145ddad40214eea96" translate="yes" xml:space="preserve">
          <source>The instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is slightly awkward (but also rarely used):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 的实例有点笨拙（但也很少使用）：</target>
        </trans-unit>
        <trans-unit id="289b8b3ebc33cd2f4157166d16a368f79f089f26" translate="yes" xml:space="preserve">
          <source>The instance for an associated type can be omitted in class instances. In that case, unless there is a default instance (see &lt;a href=&quot;#assoc-decl-defs&quot;&gt;Associated type synonym defaults&lt;/a&gt;), the corresponding instance type is not inhabited; i.e., only diverging expressions, such as &lt;code&gt;undefined&lt;/code&gt;, can assume the type.</source>
          <target state="translated">关联类型的实例可以在类实例中省略。在这种情况下，除非存在默认实例（请参见&lt;a href=&quot;#assoc-decl-defs&quot;&gt;关联类型同义词defaults&lt;/a&gt;），否则不会有人居住相应的实例类型；即，只有不同的表达式（例如 &lt;code&gt;undefined&lt;/code&gt; ）才能采用该类型。</target>
        </trans-unit>
        <trans-unit id="59904cb0ab2fe8f19f68bd984f2b517b8091cc17" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;前奏中&lt;/a&gt;定义的列表 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 满足这些定律。</target>
        </trans-unit>
        <trans-unit id="585199a1b65eac2628d79ac97b369b88ce05f950" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;前奏中&lt;/a&gt;定义的列表 &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 满足这些定律。</target>
        </trans-unit>
        <trans-unit id="1581053810276ec21d30df3978e3008a7ff9fc55" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;前奏中&lt;/a&gt;定义的列表 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 满足这些定律。</target>
        </trans-unit>
        <trans-unit id="1a017b052435df19797d88fb110f1e8782d90594" translate="yes" xml:space="preserve">
          <source>The instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; for lists, &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; defined in the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; satisfy these laws.</source>
          <target state="translated">&lt;a href=&quot;prelude&quot;&gt;前奏中&lt;/a&gt;定义的列表 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例， &lt;code&gt;&lt;a href=&quot;data-maybe#v:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 满足这些定律。</target>
        </trans-unit>
        <trans-unit id="f9f0c8e6289e586cc5baeea5fcfbbbe115d5e7f6" translate="yes" xml:space="preserve">
          <source>The intention is for &lt;code&gt;IsLabel&lt;/code&gt; to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular &lt;code&gt;(-&amp;gt;)&lt;/code&gt;) in the future.</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; 的目的是用于支持重载的记录字段，甚至可能支持匿名记录。因此，将来可能会为基础数据类型（尤其是 &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ）提供实例。</target>
        </trans-unit>
        <trans-unit id="26b1329858bfddb7f19887db1797b6a20a449184" translate="yes" xml:space="preserve">
          <source>The interact function takes a function of type &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">交互函数将 &lt;code&gt;ByteString -&amp;gt; ByteString&lt;/code&gt; 类型的函数作为其参数。来自标准输入设备的全部输入作为其参数传递给此函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="28bb27e789e236bd63cc99925076154513d01eb7" translate="yes" xml:space="preserve">
          <source>The interactive classes (only relevant when &lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt;&lt;code&gt;ExtendedDefaultRules&lt;/code&gt;&lt;/a&gt; is in effect) are: any numeric class, &lt;code&gt;Show&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Traversable&lt;/code&gt;.</source>
          <target state="translated">交互式类（仅在&lt;a href=&quot;#extension-ExtendedDefaultRules&quot;&gt; &lt;code&gt;ExtendedDefaultRules&lt;/code&gt; &lt;/a&gt;生效时才相关）是：任何数字类， &lt;code&gt;Show&lt;/code&gt; ， &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Foldable&lt;/code&gt; 或 &lt;code&gt;Traversable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c15d5fb52d82aa70762f462a28f7dddcf408ca0" translate="yes" xml:space="preserve">
          <source>The interface file, which normally ends in a &lt;code&gt;.hi&lt;/code&gt; suffix, contains the information that GHC needs in order to compile further modules that depend on this module. It contains things like the types of exported functions, definitions of data types, and so on. It is stored in a binary format, so don&amp;rsquo;t try to read one; use the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option instead (see &lt;a href=&quot;#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">该接口文件通常以 &lt;code&gt;.hi&lt;/code&gt; 后缀结尾，包含GHC为了编译依赖于该模块的其他模块所需的信息。它包含诸如导出函数的类型，数据类型的定义等内容。它以二进制格式存储，因此不要尝试读取它。请改用 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 选项（请参阅&lt;a href=&quot;#hi-options&quot;&gt;与接口文件有关的其他选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="01f926777c79e4e6d52fb1a2cf6afecc0a8b7f65" translate="yes" xml:space="preserve">
          <source>The interface output may be directed to another file &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; with the option &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; (not recommended).</source>
          <target state="translated">所述接口输出可以被引导到另一个文件 &lt;code&gt;bar2/Wurble.iface&lt;/code&gt; 使用选项 &lt;code&gt;-ohi bar2/Wurble.iface&lt;/code&gt; （不推荐）。</target>
        </trans-unit>
        <trans-unit id="d422eff6b38b54b7b01cf3f23285761f3009b5be" translate="yes" xml:space="preserve">
          <source>The interface provides &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, a type representation which can be safely decomposed and composed. See &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; for an example of this.</source>
          <target state="translated">该接口提供 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; ，可以安全地分解和组成类型表示。有关此示例，请参见&lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7525fed411a95f2aba1be67c722e982ae098165e" translate="yes" xml:space="preserve">
          <source>The interpreter can&amp;rsquo;t load modules with foreign export declarations!</source>
          <target state="translated">解释器无法使用国外出口声明装载模块！</target>
        </trans-unit>
        <trans-unit id="c6f1b29cc56478e029057e80fde7617996385c3a" translate="yes" xml:space="preserve">
          <source>The interpreter doesn&amp;rsquo;t support unboxed tuples, so GHCi will automatically compile these modules, and all modules they depend on, to object code instead of bytecode.</source>
          <target state="translated">解释器不支持未装箱的元组，因此GHCi将自动将这些模块及其依赖的所有模块编译为目标代码而不是字节码。</target>
        </trans-unit>
        <trans-unit id="bcc96915fbf058774c86b1ad6764191d649fe219" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 的倒数。</target>
        </trans-unit>
        <trans-unit id="960baabb94ec6d41e7f419f3f0516ce7cfa51827" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 的倒数。</target>
        </trans-unit>
        <trans-unit id="25e108698be586db7ffe3f616a94bfc73b7ee1a2" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year, the number of the Monday-starting week, and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:mondayStartWeek&quot;&gt;mondayStartWeek&lt;/a&gt;&lt;/code&gt; 的逆函数。获得 &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 给出的一年，星期一开始一周的数量，和星期几。第一个星期一为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%W&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2617db8ad5e573ea343c5794cabc4dfe2b8d32ba" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt;. Get a &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; given the year and the number of the day of a Sunday-starting week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-time-calendar-ordinaldate#v:sundayStartWeek&quot;&gt;sundayStartWeek&lt;/a&gt;&lt;/code&gt; 的反函数。获得 &lt;code&gt;&lt;a href=&quot;data-time-calendar#t:Day&quot;&gt;Day&lt;/a&gt;&lt;/code&gt; 给出的一年周日启动星期几的数量。第一个星期天为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%U&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8e1d7169fde4f120c1aa4f3ece9ee57253f95f60" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; 相反，即，我们具有标识</target>
        </trans-unit>
        <trans-unit id="085f4b1b3304279a7c72a59a48e1ceb8b934a83e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt;, i.e., we have the identity</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-stable#v:castStablePtrToPtr&quot;&gt;castStablePtrToPtr&lt;/a&gt;&lt;/code&gt; 相反，即，我们具有标识</target>
        </trans-unit>
        <trans-unit id="bdd2cce8158f1320bcd058983fb015f9d2fa4781" translate="yes" xml:space="preserve">
          <source>The key component of a typechecker plugin is a function of type &lt;code&gt;TcPluginSolver&lt;/code&gt;, like this:</source>
          <target state="translated">&lt;code&gt;TcPluginSolver&lt;/code&gt; 插件的关键组件是TcPluginSolver类型的函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="50146b4ed40e4fdb3a0f98772092c373b41b7b82" translate="yes" xml:space="preserve">
          <source>The key difference here is that we abstract over the type constructor &lt;code&gt;c&lt;/code&gt; that is used to form the collection type &lt;code&gt;c e&lt;/code&gt;, and not over that collection type itself, represented by &lt;code&gt;ce&lt;/code&gt; in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt;, which is not ambiguous.</source>
          <target state="translated">此处的主要区别在于，我们对用于形成集合类型 &lt;code&gt;c e&lt;/code&gt; 的类型构造函数 &lt;code&gt;c&lt;/code&gt; 进行抽象，而不是对原始类声明中 &lt;code&gt;ce&lt;/code&gt; 表示的该集合类型本身进行抽象。这避免了我们上面提到的直接问题：empty具有类型 &lt;code&gt;Collects e c =&amp;gt; c e&lt;/code&gt; ，这不是模糊的。</target>
        </trans-unit>
        <trans-unit id="d931654af7b546e8d6ff7d64be51ee7d51eed95b" translate="yes" xml:space="preserve">
          <source>The key point about GADTs is that &lt;em&gt;pattern matching causes type refinement&lt;/em&gt;. For example, in the right hand side of the equation</source>
          <target state="translated">GADT的关键是&lt;em&gt;模式匹配会导致类型优化&lt;/em&gt;。例如，在等式的右侧</target>
        </trans-unit>
        <trans-unit id="1c6ccf2ae2f2b690d9a1832c4814300edcd715a9" translate="yes" xml:space="preserve">
          <source>The key to defining your own datatype-generic functions is to understand how to represent datatypes using the given set of type constructors.</source>
          <target state="translated">定义自己的数据类型-通用函数的关键是了解如何使用给定的类型构造器集来表示数据类型。</target>
        </trans-unit>
        <trans-unit id="101f96a1728772ac592ac70565bf2d4fd3554ddc" translate="yes" xml:space="preserve">
          <source>The key tool to use in making your Haskell program run faster are GHC&amp;rsquo;s profiling facilities, described separately in &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;. There is &lt;em&gt;no substitute&lt;/em&gt; for finding where your program&amp;rsquo;s time/space is &lt;em&gt;really&lt;/em&gt; going, as opposed to where you imagine it is going.</source>
          <target state="translated">用于使Haskell程序更快运行的关键工具是GHC的性能分析工具，在&amp;ldquo;性能&lt;a href=&quot;profiling#profiling&quot;&gt;分析&amp;rdquo;&lt;/a&gt;中有单独介绍。有&lt;em&gt;没有替代品&lt;/em&gt;寻找你的程序的时间/空间&lt;em&gt;真的&lt;/em&gt;走，而不是在那里你能想象这是怎么回事。</target>
        </trans-unit>
        <trans-unit id="52cd9e5fb65950d32847b984e9879cffe2f00ec9" translate="yes" xml:space="preserve">
          <source>The keypad</source>
          <target state="translated">键盘</target>
        </trans-unit>
        <trans-unit id="89852fc3a3f80fb4cacd31fc13b712715ce5683a" translate="yes" xml:space="preserve">
          <source>The kind &lt;code&gt;Type&lt;/code&gt; (imported from &lt;code&gt;Data.Kind&lt;/code&gt;) classifies ordinary types. With &lt;a href=&quot;#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; (currently enabled by default), &lt;code&gt;*&lt;/code&gt; is desugared to &lt;code&gt;Type&lt;/code&gt;, but using this legacy syntax is not recommended due to conflicts with &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;. This also applies to &lt;code&gt;★&lt;/code&gt;, the Unicode variant of &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;Type&lt;/code&gt; （从 &lt;code&gt;Data.Kind&lt;/code&gt; 导入）对普通类型进行分类。使用&lt;a href=&quot;#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;（当前默认启用）时， &lt;code&gt;*&lt;/code&gt; 被减为 &lt;code&gt;Type&lt;/code&gt; ，但由于与&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;冲突，因此不建议使用此旧式语法。这也适用于 &lt;code&gt;★&lt;/code&gt; ，它是 &lt;code&gt;*&lt;/code&gt; 的Unicode变体。</target>
        </trans-unit>
        <trans-unit id="0cd808c3a0aa47774f7ee55994f44b345c1912bc" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Foo&lt;/code&gt;&amp;lsquo;s parameter is &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt;, but the kind of &lt;code&gt;Proxy&lt;/code&gt; is &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt;, where &lt;code&gt;{k}&lt;/code&gt; denotes that the kind variable &lt;code&gt;k&lt;/code&gt; is to be inferred, not specified by the user. (See &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt; for more discussion on the inferred-specified distinction). GHC does not consider &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; to be equal at the kind level, and thus rejects &lt;code&gt;Foo Proxy&lt;/code&gt; as ill-kinded.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 的参数的种类为全 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; ，但种 &lt;code&gt;Proxy&lt;/code&gt; 是 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; ，其中 &lt;code&gt;{k}&lt;/code&gt; 表示要推导类型变量 &lt;code&gt;k&lt;/code&gt; ，而不是由用户指定。 （有关推断的区别的更多讨论，请参见&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型应用程序&lt;/a&gt;）。 GHC不会考虑所有 &lt;code&gt;forall k. k -&amp;gt; Type&lt;/code&gt; 和全部 &lt;code&gt;forall {k}. k -&amp;gt; Type&lt;/code&gt; 在种类级别上相等，因此拒绝 &lt;code&gt;Foo Proxy&lt;/code&gt; 的类型不正确。</target>
        </trans-unit>
        <trans-unit id="d650258dfa554e9a0a612c8d7a0289cda5964e46" translate="yes" xml:space="preserve">
          <source>The kind of &lt;code&gt;Vec&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt;. This means that, e.g., &lt;code&gt;Vec Int Char&lt;/code&gt; is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</source>
          <target state="translated">&lt;code&gt;Vec&lt;/code&gt; 的 &lt;code&gt;Type -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; 是Type- &amp;gt; Type- &amp;gt; Type。这意味着，例如， &lt;code&gt;Vec Int Char&lt;/code&gt; 是一种类型良好的类型，即使这不是我们在定义长度索引矢量时想要的类型。</target>
        </trans-unit>
        <trans-unit id="6bdcf0025de5c2355bf036fb20350561d0e1ffc4" translate="yes" xml:space="preserve">
          <source>The kind of constraints, like &lt;code&gt;Show a&lt;/code&gt;</source>
          <target state="translated">那种约束，比如 &lt;code&gt;Show a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3970d2a390e8339e6194fae0a800fd7ee383f1f3" translate="yes" xml:space="preserve">
          <source>The kind of types with values. For example &lt;code&gt;Int :: Type&lt;/code&gt;.</source>
          <target state="translated">具有值的类型的种类。例如 &lt;code&gt;Int :: Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2ff1eafaf2cf50aa099b7bed39cd8ce178efc2" translate="yes" xml:space="preserve">
          <source>The kind-polymorphism from the class declaration makes &lt;code&gt;D1&lt;/code&gt; kind-polymorphic, but not so &lt;code&gt;D2&lt;/code&gt;; and similarly &lt;code&gt;F1&lt;/code&gt;, &lt;code&gt;F1&lt;/code&gt;.</source>
          <target state="translated">来自类声明的kind-polymorphism 使 &lt;code&gt;D1&lt;/code&gt; 为 kind-polymorphic，但不是 &lt;code&gt;D2&lt;/code&gt; ；同样是 &lt;code&gt;F1&lt;/code&gt; ， &lt;code&gt;F1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="142a287b02ca78aabf16196f308cd74692a41234" translate="yes" xml:space="preserve">
          <source>The kinds of the literals and all other low-level operations for this feature are defined in module &lt;code&gt;GHC.TypeLits&lt;/code&gt;. Note that the module defines some type-level operators that clash with their value-level counterparts (e.g. &lt;code&gt;(+)&lt;/code&gt;). Import and export declarations referring to these operators require an explicit namespace annotation (see &lt;a href=&quot;#explicit-namespaces&quot;&gt;Explicit namespaces in import/export&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;GHC.TypeLits&lt;/code&gt; 模块中定义了此文字的种类以及所有其他低级操作。请注意，该模块定义了一些类型级别的运算符，这些运算符与它们的值级别的运算符（例如 &lt;code&gt;(+)&lt;/code&gt; ）冲突。引用这些运算符的导入和导出声明需要显式的名称空间注释（请参见&lt;a href=&quot;#explicit-namespaces&quot;&gt;import / export中的Explicit名称空间&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f14aa2c065169defb0f47595c9265ce4ba5857e8" translate="yes" xml:space="preserve">
          <source>The lag stage, which is the time between creation and the first use of the object,</source>
          <target state="translated">滞后阶段,即对象从创建到第一次使用的时间。</target>
        </trans-unit>
        <trans-unit id="67f729cc5793b907e6283b32042b3a6379b975b3" translate="yes" xml:space="preserve">
          <source>The language &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; changes this behaviour:</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;语言会更改此行为：</target>
        </trans-unit>
        <trans-unit id="96eef94888750b6bf04df904c79af345e5cf88c6" translate="yes" xml:space="preserve">
          <source>The language definition for the Haskell language.</source>
          <target state="translated">Haskell语言的语言定义。</target>
        </trans-unit>
        <trans-unit id="f35e66eca43d1117d42cef793c6da9da1b53ea98" translate="yes" xml:space="preserve">
          <source>The language definition for the language Mondrian.</source>
          <target state="translated">语言蒙德里安的语言定义。</target>
        </trans-unit>
        <trans-unit id="c6db1b982530559c016310cc1374654d4e113cec" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; adds support for expressing integer literals in binary notation with the prefix &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;. For instance, the binary integer literal &lt;code&gt;0b11001001&lt;/code&gt; will be desugared into &lt;code&gt;fromInteger 201&lt;/code&gt; when &lt;a href=&quot;#extension-BinaryLiterals&quot;&gt;&lt;code&gt;BinaryLiterals&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;添加了对以前缀 &lt;code&gt;0b&lt;/code&gt; 或 &lt;code&gt;0B&lt;/code&gt; 的二进制符号表示整数文字的支持。例如，当启用&lt;a href=&quot;#extension-BinaryLiterals&quot;&gt; &lt;code&gt;BinaryLiterals&lt;/code&gt; &lt;/a&gt;时，二进制整数常量 &lt;code&gt;0b11001001&lt;/code&gt; 将被从Integer &lt;code&gt;fromInteger 201&lt;/code&gt; 还原。</target>
        </trans-unit>
        <trans-unit id="2aa01e6792de69a814fc51631fa469117dc53520" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; allows &lt;code&gt;#&lt;/code&gt; as a postfix modifier to identifiers. Thus, &lt;code&gt;x#&lt;/code&gt; is a valid variable, and &lt;code&gt;T#&lt;/code&gt; is a valid type constructor or data constructor.</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;允许使用 &lt;code&gt;#&lt;/code&gt; 作为标识符的后缀修饰符。因此， &lt;code&gt;x#&lt;/code&gt; 是有效变量，而 &lt;code&gt;T#&lt;/code&gt; 是有效类型构造函数或数据构造函数。</target>
        </trans-unit>
        <trans-unit id="482fac3caa33dc4889f02993b124d842b7fc23c8" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumDecimals&quot;&gt;&lt;code&gt;NumDecimals&lt;/code&gt;&lt;/a&gt; allows you to also use the floating literal syntax for instances of &lt;code&gt;Integral&lt;/code&gt;, and have values like &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-NumDecimals&quot;&gt; &lt;code&gt;NumDecimals&lt;/code&gt; &lt;/a&gt;允许您还对 &lt;code&gt;Integral&lt;/code&gt; 实例使用浮动文字语法，并且具有类似 &lt;code&gt;(1.2e6 :: Num a =&amp;gt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7301f20dd6642c45e1a8ac269b635e38af928e05" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; adds support for expressing underscores in numeric literals. For instance, the numeric literal &lt;code&gt;1_000_000&lt;/code&gt; will be parsed into &lt;code&gt;1000000&lt;/code&gt; when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. That is, underscores in numeric literals are ignored when &lt;a href=&quot;#extension-NumericUnderscores&quot;&gt;&lt;code&gt;NumericUnderscores&lt;/code&gt;&lt;/a&gt; is enabled. See also &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;Issue #14473&lt;/a&gt;.</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;添加了对以数字文字表示下划线的支持。例如，启用&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;时，数字文字 &lt;code&gt;1_000_000&lt;/code&gt; 将被解析为 &lt;code&gt;1000000&lt;/code&gt; 。也就是说，启用&lt;a href=&quot;#extension-NumericUnderscores&quot;&gt; &lt;code&gt;NumericUnderscores&lt;/code&gt; &lt;/a&gt;时，数字文字中的下划线将被忽略。另请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/14473&quot;&gt;问题＃14473&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1df0d3ed5fc3e05e0b2f091352293e402f435759" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; adds a new syntactic form &lt;code&gt;static e&lt;/code&gt;, which stands for a reference to the closed expression ⟨e⟩. This reference is stable and portable, in the sense that it remains valid across different processes on possibly different machines. Thus, a process can create a reference and send it to another process that can resolve it to ⟨e⟩.</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;添加了新的语法形式 &lt;code&gt;static e&lt;/code&gt; ，它表示对闭合表达式⟨e⟩的引用。从可能在不同机器上的不同进程中保持有效的意义上来说，此引用是稳定且可移植的。因此，一个进程可以创建一个引用并将其发送到另一个可以将其解析为&amp;ldquo; e&amp;rdquo;的进程。</target>
        </trans-unit>
        <trans-unit id="1164d109e3a8912c2bd8dbd337b1bd95e59931eb" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; allows much more flexible constraints in superclasses.</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; &lt;/a&gt;允许超类中更加灵活的约束。</target>
        </trans-unit>
        <trans-unit id="a23afb63a5225acfa62366c99fa9002b8bd272d4" translate="yes" xml:space="preserve">
          <source>The language extension &lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; enables Unicode characters to be used to stand for certain ASCII character sequences. The following alternatives are provided:</source>
          <target state="translated">语言扩展&lt;a href=&quot;#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;UnicodeSyntax&lt;/code&gt; &lt;/a&gt;使Unicode字符可用于表示某些ASCII字符序列。提供了以下替代方法：</target>
        </trans-unit>
        <trans-unit id="0f020db4c2779c8a84447ac375908f8cf1851cd7" translate="yes" xml:space="preserve">
          <source>The language extensions control what variation of the language are permitted.</source>
          <target state="translated">语言扩展控制着语言的哪些变化是被允许的。</target>
        </trans-unit>
        <trans-unit id="1e3e7e5b927ef3a07b1708c8234ccb8fab69c087" translate="yes" xml:space="preserve">
          <source>The language extensions known to GHC.</source>
          <target state="translated">GHC已知的语言扩展。</target>
        </trans-unit>
        <trans-unit id="47f8be94c2ca864c563003d6cd62e96954c9f6b8" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt; enables an alternative translation for the do-notation, which uses the operators &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, along with &lt;code&gt;join&lt;/code&gt; as far as possible. There are two main reasons for wanting to do this:</source>
          <target state="translated">语言选项&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;启用了do-notation的替代翻译，该翻译尽可能使用运算符 &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 以及 &lt;code&gt;join&lt;/code&gt; 。想要这样做的主要原因有两个：</target>
        </trans-unit>
        <trans-unit id="6758c18bb77d5105f15261fc6f768c32b1ac1a54" translate="yes" xml:space="preserve">
          <source>The language option &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; (which implies &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt;) enables higher-rank types. That is, you can nest &lt;code&gt;forall&lt;/code&gt;s arbitrarily deep in function arrows. For example, a forall-type (also called a &amp;ldquo;type scheme&amp;rdquo;), including a type-class context, is legal:</source>
          <target state="translated">语言选项&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;（这意味着&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;）启用了更高级别的类型。也就是说，您可以将 &lt;code&gt;forall&lt;/code&gt; 任意嵌套在功能箭头中。例如，包括类型类上下文的forall类型（也称为&amp;ldquo;类型方案&amp;rdquo;）是合法的：</target>
        </trans-unit>
        <trans-unit id="e43581d03051421db388e53bc00c80ed362d21f6" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">非空结构中相对于给定比较函数的最大元素。</target>
        </trans-unit>
        <trans-unit id="a09e69c04a0fae36b18bfad0cec44eb5b7dac599" translate="yes" xml:space="preserve">
          <source>The largest element of a non-empty structure.</source>
          <target state="translated">一个非空结构中最大的元素。</target>
        </trans-unit>
        <trans-unit id="1c3c62ef7c501b737425bd024e6b97dd8602a4d0" translate="yes" xml:space="preserve">
          <source>The last of these examples will generate a RULE with a somewhat-complex left-hand side (try it yourself), so it might not fire very well. If you use this kind of specialisation, let us know how well it works.</source>
          <target state="translated">最后一个例子会生成一个左手边有点复杂的rule(自己试试),所以可能不会很火。如果你使用这种特殊化,请让我们知道它的效果如何。</target>
        </trans-unit>
        <trans-unit id="c09c37300640da9fa5a1e825531f7baf46e4a4a9" translate="yes" xml:space="preserve">
          <source>The last point means that, for example, this program:</source>
          <target state="translated">最后一点的意思是,比如说,这个程序。</target>
        </trans-unit>
        <trans-unit id="c7b0fe0f98d69788b12fc3fe8961316784922da5" translate="yes" xml:space="preserve">
          <source>The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case &lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt;&lt;code&gt;:type-at&lt;/code&gt;&lt;/a&gt; falls back to a general &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; like lookup.</source>
          <target state="translated">最后一个字符串参数在跨度过期时（即文件已更改且代码已移动）很有用。在这种情况下，&lt;a href=&quot;#ghci-cmd-:type-at&quot;&gt; &lt;code&gt;:type-at&lt;/code&gt; &lt;/a&gt;会回退到类似于查找的常规&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74662c9c171e1f11f6d4c17936e04e8cfc73a0a4" translate="yes" xml:space="preserve">
          <source>The last time we looked, this bug still wasn&amp;rsquo;t fixed in the BFD codebase, and there wasn&amp;rsquo;t any noticeable interest in fixing it when we reported the bug back in 2001 or so.</source>
          <target state="translated">上次查看时，此错误仍未在BFD代码库中修复，并且当我们在2001年左右报告该错误时，对其修复没有任何明显的兴趣。</target>
        </trans-unit>
        <trans-unit id="cc178347052a701ca8893682ca3efb8b74c8a5b7" translate="yes" xml:space="preserve">
          <source>The latter two extensions are simply a way to avoid littering high-performance code with bang patterns, making it harder to read.</source>
          <target state="translated">后面两个扩展只是为了避免高性能的代码被bang模式所污染,使其更难读。</target>
        </trans-unit>
        <trans-unit id="83ef67ff9e0acbd2b46b885ad1e2b9746fa12727" translate="yes" xml:space="preserve">
          <source>The layout rule applies in a pragma. Currently no new indentation level is set, so if you put several rules in single &lt;code&gt;RULES&lt;/code&gt; pragma and wish to use layout to separate them, you must lay out the starting in the same column as the enclosing definitions.</source>
          <target state="translated">布局规则适用于杂注。当前没有设置新的缩进级别，因此，如果将多个规则放在单个 &lt;code&gt;RULES&lt;/code&gt; 编译指令中，并希望使用布局将它们分开，则必须在与封闭定义相同的列中布置起始位置。</target>
        </trans-unit>
        <trans-unit id="d2d17886ee9122e995c736b68557cda7950811bf" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">懒惰的 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; sa的计算 &lt;code&gt; returns a value of type &lt;/code&gt; a 的值 &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; s中执行 &lt;code&gt;. The &lt;/code&gt; 小号@参数是</target>
        </trans-unit>
        <trans-unit id="cb5e3600ef521edc02534f8316cf1842086384c6" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad.
 The ST monad allows for destructive updates, but is escapable (unlike IO).
 A computation of type &lt;/code&gt;&lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; s a&lt;code&gt; returns a value of type &lt;/code&gt;a&lt;code&gt;, and
 execute in &quot;thread&quot; &lt;/code&gt;s&lt;code&gt;. The &lt;/code&gt;s@ parameter is either</source>
          <target state="translated">懒惰的 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt; monad. The ST monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; sa的计算 &lt;code&gt; returns a value of type &lt;/code&gt; a 的值 &lt;code&gt;, and execute in &quot;thread&quot; &lt;/code&gt; s中执行 &lt;code&gt;. The &lt;/code&gt; 小号@参数是</target>
        </trans-unit>
        <trans-unit id="40d868f620139062b248b76538a36b443a676fd8" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds accumulation capabilities (such as declarations or document patches) to a given monad.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;control-monad-trans-accum#t:AccumT&quot;&gt;AccumT&lt;/a&gt;&lt;/code&gt; monad转换器，它为给定的monad增加了累积功能（例如声明或文档补丁）。</target>
        </trans-unit>
        <trans-unit id="0148fab25056e7d25108af73020e1e1fd6b568bc" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="460dbda305fa0fdf243ff4aaca3b36cbface9176" translate="yes" xml:space="preserve">
          <source>The lazy &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">懒惰的 &lt;code&gt;ByteString&lt;/code&gt; 类型和表示形式</target>
        </trans-unit>
        <trans-unit id="cd66658dbdbc20cd277316b5f47a31d85a5a657d" translate="yes" xml:space="preserve">
          <source>The lazy ByteString that results from &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; can be written to disk, and read from disk using Data.ByteString.Lazy IO functions, such as hPutStr or writeFile:</source>
          <target state="translated">可以将 &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; 产生的惰性ByteString 写入磁盘，并使用Data.ByteString.Lazy IO函数（例如hPutStr或writeFile）从磁盘读取：</target>
        </trans-unit>
        <trans-unit id="81b4ea9d6659ffec90b8a98fd916cb7519cdd284" translate="yes" xml:space="preserve">
          <source>The lazy input interface</source>
          <target state="translated">懒人输入接口</target>
        </trans-unit>
        <trans-unit id="18194b6ea93e37e29c30dcb32e97e5e2850d4eab" translate="yes" xml:space="preserve">
          <source>The lazy interface consumes a single lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It's the easiest interface to get started with, but it doesn't support interleaving I/O and parsing, unless lazy I/O is used.</source>
          <target state="translated">惰性接口使用单个惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。这是最容易上手的接口，但是除非使用惰性I / O，否则它不支持交错I / O和解析。</target>
        </trans-unit>
        <trans-unit id="d0f94810b2d4d1d107dde9a11881d98fcdccae35" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure with respect to the given comparison function.</source>
          <target state="translated">相对于给定的比较函数,一个非空结构的最小元素。</target>
        </trans-unit>
        <trans-unit id="07d9943e6fdf33ee01fbdf7cd0db14fb536c6243" translate="yes" xml:space="preserve">
          <source>The least element of a non-empty structure.</source>
          <target state="translated">一个非空结构的最小元素。</target>
        </trans-unit>
        <trans-unit id="0e70192fc1725fb44e6261baa525bb34fe0d8271" translate="yes" xml:space="preserve">
          <source>The left hand side of a rule must consist of a top-level variable applied to arbitrary expressions. For example, this is &lt;em&gt;not&lt;/em&gt; OK:</source>
          <target state="translated">规则的左侧必须包含应用于任意表达式的顶级变量。例如，这&lt;em&gt;不行&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="9bbc16e1c3670ac6be9b561d2b10f00b7e4c905c" translate="yes" xml:space="preserve">
          <source>The length of a given month in the Gregorian or Julian calendars. First arg is leap year flag.</source>
          <target state="translated">在公历或朱利安历中,某个月的长度。第一个参数是闰年标志。</target>
        </trans-unit>
        <trans-unit id="02862fec4929a80083ca47de3fabc777823d03ea" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reserved name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid identifier. A &lt;code&gt;reserved&lt;/code&gt; word is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">lexeme解析器的 &lt;code&gt;reserved name&lt;/code&gt; 解析 &lt;code&gt;symbol name&lt;/code&gt; ，但它还会检查 &lt;code&gt;name&lt;/code&gt; 是否不是有效标识符的前缀。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;reserved&lt;/code&gt; 字视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="12483176ac2649de2ec04abe4c197ebb522e5167" translate="yes" xml:space="preserve">
          <source>The lexeme parser &lt;code&gt;reservedOp name&lt;/code&gt; parses &lt;code&gt;symbol
 name&lt;/code&gt;, but it also checks that the &lt;code&gt;name&lt;/code&gt; is not a prefix of a valid operator. A &lt;code&gt;reservedOp&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">lexeme解析器 &lt;code&gt;reservedOp name&lt;/code&gt; 解析 &lt;code&gt;symbol name&lt;/code&gt; ，但它还会检查该 &lt;code&gt;name&lt;/code&gt; 不是有效运算符的前缀。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;reservedOp&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="6fe325967df8e680315725cbc04cfb4a0cda946a" translate="yes" xml:space="preserve">
          <source>The libraries listed in &lt;code&gt;extra-libraries&lt;/code&gt; may be any libraries supported by your system&amp;rsquo;s linker, including dynamic libraries (&lt;code&gt;.so&lt;/code&gt; on Unix, &lt;code&gt;.DLL&lt;/code&gt; on Windows).</source>
          <target state="translated">&lt;code&gt;extra-libraries&lt;/code&gt; 库中列出的库可以是系统链接程序支持的任何库，包括动态库（在Unix 上为 &lt;code&gt;.so&lt;/code&gt; ，在Windows 上为 &lt;code&gt;.DLL&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="177074a86a1a2bfb7162db93da0c7658d94219a2" translate="yes" xml:space="preserve">
          <source>The lifetime of an event registration.</source>
          <target state="translated">活动登记的寿命。</target>
        </trans-unit>
        <trans-unit id="abc2a96639fca06ac1cbe729983e770d28dcf330" translate="yes" xml:space="preserve">
          <source>The limitations here are listed in Haskell Report order (roughly).</source>
          <target state="translated">这里的限制是按照Haskell报告的顺序(大致)列出的。</target>
        </trans-unit>
        <trans-unit id="d2f24eb430e5f7113d1bb42457d3209f32c4782e" translate="yes" xml:space="preserve">
          <source>The linker standard library search can also be overriden on some systems using the &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; environment variable. Because of some implementation detail on Windows, setting &lt;code&gt;LIBRARY_PATH&lt;/code&gt; will also extend the system loader path for any library it finds. So often setting &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; is enough.</source>
          <target state="translated">在某些系统上，也可以使用 &lt;code id=&quot;index-20&quot;&gt;LIBRARY_PATH&lt;/code&gt; 环境变量来覆盖链接程序标准库搜索。由于Windows上有一些实现细节，因此设置 &lt;code&gt;LIBRARY_PATH&lt;/code&gt; 还将扩展它找到的任何库的系统加载程序路径。因此经常设置 &lt;code id=&quot;index-21&quot;&gt;LIBRARY_PATH&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="35439bfe005709a8b0e917ffb02271e76a64cd30" translate="yes" xml:space="preserve">
          <source>The linker to use (default: &lt;code&gt;gcc&lt;/code&gt;).</source>
          <target state="translated">要使用的链接器（默认值： &lt;code&gt;gcc&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eeafbb95d04ce25f7a78da969fb894e2ec069b3e" translate="yes" xml:space="preserve">
          <source>The list is ordered by most recent call.</source>
          <target state="translated">名单按最近一次通话排序。</target>
        </trans-unit>
        <trans-unit id="1f523c49a9fa8705bc3372a7af5bd59d5259f47e" translate="yes" xml:space="preserve">
          <source>The list must be finite.</source>
          <target state="translated">列表必须是有限的。</target>
        </trans-unit>
        <trans-unit id="95bb9fda3d0750b05641de34c2d4bc742e5f26cc" translate="yes" xml:space="preserve">
          <source>The list of all possible separators.</source>
          <target state="translated">所有可能的分隔符的列表。</target>
        </trans-unit>
        <trans-unit id="140110a0fe6147ee6523b90cc08f34ea3d3d7870" translate="yes" xml:space="preserve">
          <source>The list of associations of an array in index order.</source>
          <target state="translated">按索引顺序排列的数组的关联列表。</target>
        </trans-unit>
        <trans-unit id="4db5b3fb0ce028bd2eb08c3da0fe9c3bade145e2" translate="yes" xml:space="preserve">
          <source>The list of breakpoints currently enabled can be displayed using &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当前启用的断点列表可以使用&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; 显示&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="6840298fc1ff7b758a2385cba92227fe7cb9d802" translate="yes" xml:space="preserve">
          <source>The list of elements of an array in index order.</source>
          <target state="translated">数组中按索引顺序排列的元素列表。</target>
        </trans-unit>
        <trans-unit id="920d0464cfa124351a5c124482bb76f7bb005ea6" translate="yes" xml:space="preserve">
          <source>The list of indices of an array in ascending order.</source>
          <target state="translated">数组中按升序排列的索引列表。</target>
        </trans-unit>
        <trans-unit id="c272635afded4d839339a1be1f84abe89e36c500" translate="yes" xml:space="preserve">
          <source>The list of paths is split using &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt;, which on Windows is a semicolon.</source>
          <target state="translated">路径列表是使用 &lt;code&gt;&lt;a href=&quot;../filepath-1.4.2.1/system-filepath#v:searchPathSeparator&quot;&gt;searchPathSeparator&lt;/a&gt;&lt;/code&gt; 分割的，在Windows上是分号。</target>
        </trans-unit>
        <trans-unit id="dc809c8f4a7b8427301c5f620413f00381ab3112" translate="yes" xml:space="preserve">
          <source>The list of possible &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt;s in the API documentation is not exhaustive. The full list may vary by platform and/or evolve over time.</source>
          <target state="translated">API文档中可能的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 的列表并不详尽。完整列表可能会因平台而异和/或随时间而变化。</target>
        </trans-unit>
        <trans-unit id="c6f1b33fdad02db727e19018a482ecf607406289" translate="yes" xml:space="preserve">
          <source>The list of reserved identifiers.</source>
          <target state="translated">保留的标识符清单;</target>
        </trans-unit>
        <trans-unit id="91edba8a3a46eed84d044f0b039fdf7160f70fd8" translate="yes" xml:space="preserve">
          <source>The list of reserved operators.</source>
          <target state="translated">保留的操作人员名单;</target>
        </trans-unit>
        <trans-unit id="c39f3749d7b0f0a59a29e12553ad09d0740f4541" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is found by checking which bindings in scope would fit into the hole. As an example, compiling the following module with GHC:</source>
          <target state="translated">通过检查范围内的哪些绑定会适合该孔,就可以找到有效的孔匹配列表。举个例子,用GHC编译以下模块。</target>
        </trans-unit>
        <trans-unit id="a1d5e76811a70379851fd0870f7be2601a8c80c1" translate="yes" xml:space="preserve">
          <source>The list of valid hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有效孔配合的列表受到限制，因为每个孔最多显示6个孔配合。可以通过该标志设置所​​示的孔配合数量。使用 &lt;code&gt;-fno-max-valid-hole-fits&lt;/code&gt; 关闭限制会显示所有找到的孔配合。</target>
        </trans-unit>
        <trans-unit id="d8490f70aa9b2cb5e8e7f8af8e97ea93b083ee94" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is generated by considering hole fits with a varying amount of additional holes. The amount of holes in a refinement can be set by this flag. If the flag is set to 0 or not set at all, no valid refinement hole fits will be suggested.</source>
          <target state="translated">有效的精炼孔配合列表是通过考虑不同数量的附加孔配合产生的。精炼中的孔数量可以由这个标志设置。如果标志被设置为0或者根本没有设置,没有有效的精炼孔配合将被建议。</target>
        </trans-unit>
        <trans-unit id="0e9c3cb541a9f4b1ef3a2b89a4f5da3c5f2f0b80" translate="yes" xml:space="preserve">
          <source>The list of valid refinement hole fits is limited by displaying up to 6 hole fits per hole. The number of hole fits shown can be set by this flag. Turning the limit off with &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; displays all found hole fits.</source>
          <target state="translated">有效细化孔配合的列表受到限制，因为每个孔最多显示6个孔配合。可以通过该标志设置所​​示的孔配合数量。使用 &lt;code&gt;-fno-max-refinement-hole-fits&lt;/code&gt; 关闭极限会显示所有找到的孔配合。</target>
        </trans-unit>
        <trans-unit id="b86a88a2e8b5e2bcc9593f30db6f5ffae5340c3d" translate="yes" xml:space="preserve">
          <source>The list of values in the subrange defined by a bounding pair.</source>
          <target state="translated">边界对所定义的子范围内的数值列表。</target>
        </trans-unit>
        <trans-unit id="c06dff0a9cb5a38686c70f9512cbd43e5942e7dc" translate="yes" xml:space="preserve">
          <source>The literal &lt;code&gt;-123&lt;/code&gt; is, according to Haskell98 and Haskell 2010, desugared as &lt;code&gt;negate (fromInteger 123)&lt;/code&gt;. The language extension &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; means that it is instead desugared as &lt;code&gt;fromInteger (-123)&lt;/code&gt;.</source>
          <target state="translated">根据Haskell98和Haskell 2010，字面值 &lt;code&gt;-123&lt;/code&gt; &lt;code&gt;negate (fromInteger 123)&lt;/code&gt; 取自Integer 123）。语言扩展&lt;a href=&quot;#extension-NegativeLiterals&quot;&gt; &lt;code&gt;NegativeLiterals&lt;/code&gt; &lt;/a&gt;表示将其改为 &lt;code&gt;fromInteger (-123)&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="0e4c18eaf2be8a9b015eed5cef929f88b0717761" translate="yes" xml:space="preserve">
          <source>The local axioms from the instance context : &lt;code&gt;B a&lt;/code&gt;, &lt;code&gt;D a&lt;/code&gt; and &lt;code&gt;E a&lt;/code&gt;</source>
          <target state="translated">实例上下文中的局部公理： &lt;code&gt;B a&lt;/code&gt; ， &lt;code&gt;D a&lt;/code&gt; 和 &lt;code&gt;E a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47ffc1a6bb0aa38dfc306316588a7559300ef95b" translate="yes" xml:space="preserve">
          <source>The location at which this computation is spliced.</source>
          <target state="translated">这个计算的拼接位置。</target>
        </trans-unit>
        <trans-unit id="eeb6dd18dd0c7cd9fc57a8f2ff6c2bb37bc4af79" translate="yes" xml:space="preserve">
          <source>The lowercase versions (&lt;em&gt;syntax operators&lt;/em&gt;) of these constructors are preferred to these constructors, since they compose better with quotations (&lt;code&gt;[| |]&lt;/code&gt;) and splices (&lt;code&gt;$( ... )&lt;/code&gt;)</source>
          <target state="translated">这些构造函数的小写版本（&lt;em&gt;语法运算符&lt;/em&gt;）比这些构造函数更可取，因为它们与引号（ &lt;code&gt;[| |]&lt;/code&gt; ）和拼接点（ &lt;code&gt;$( ... )&lt;/code&gt; ）组成更好</target>
        </trans-unit>
        <trans-unit id="abe92315667ac8537af92643ee70ab06a908884e" translate="yes" xml:space="preserve">
          <source>The machine architecture on which the program is running.</source>
          <target state="translated">程序运行的机器架构。</target>
        </trans-unit>
        <trans-unit id="32815c54d6aac2d0c3f3ab1768e3826958371ab4" translate="yes" xml:space="preserve">
          <source>The main advantages to using &lt;code&gt;ghc --make&lt;/code&gt; over traditional &lt;code&gt;Makefile&lt;/code&gt;s are:</source>
          <target state="translated">与传统的 &lt;code&gt;Makefile&lt;/code&gt; 相比，使用 &lt;code&gt;ghc --make&lt;/code&gt; 的主要优点是：</target>
        </trans-unit>
        <trans-unit id="8f8b11338657365b7972c69ff46bf6811e5d4123" translate="yes" xml:space="preserve">
          <source>The main idea is to add a single new production to the syntax of patterns:</source>
          <target state="translated">主要思想是在模式的语法中增加一个新的生产。</target>
        </trans-unit>
        <trans-unit id="fb265d0d99b20462c3bedd36be578770dd2b3955" translate="yes" xml:space="preserve">
          <source>The main library you need to use is the &lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm library&lt;/a&gt;. The main features supported are these:</source>
          <target state="translated">您需要使用的主要库是&lt;a href=&quot;http://hackage.haskell.org/package/stm&quot;&gt;stm库&lt;/a&gt;。支持的主要功能包括：</target>
        </trans-unit>
        <trans-unit id="5e1d49c28d217785350db1f824835b79bff3fc25" translate="yes" xml:space="preserve">
          <source>The main reason for using phase control on specialisations is so that you can write optimisation RULES that fire early in the compilation pipeline, and only &lt;em&gt;then&lt;/em&gt; specialise the calls to the function. If specialisation is done too early, the optimisation rules might fail to fire.</source>
          <target state="translated">在专门化上使用阶段控制的主要原因是，您可以编写在编译管道中较早触发的优化规则，&lt;em&gt;然后再&lt;/em&gt;专门化对函数的调用。如果专业化做得太早，优化规则可能会失败。</target>
        </trans-unit>
        <trans-unit id="bd99fbab8c2a96e5d1994f5a584841ebedd4fc5c" translate="yes" xml:space="preserve">
          <source>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</source>
          <target state="translated">这里的主要要求是,在任何Haskell代码被调用之前,运行时需要被初始化,所以你的库应该提供初始化和去初始化的入口点,用C或C++实现。比如说</target>
        </trans-unit>
        <trans-unit id="a36b3b528156f09407c2aa49bd251573cb91ec76" translate="yes" xml:space="preserve">
          <source>The main thread principle also applies to calls to Haskell from outside, using &lt;code&gt;foreign export&lt;/code&gt;. When the &lt;code&gt;foreign export&lt;/code&gt;ed function is invoked, it starts a new main thread, and it returns when this main thread terminates. If the call causes new threads to be forked, they may remain in the system after the &lt;code&gt;foreign export&lt;/code&gt;ed function has returned.</source>
          <target state="translated">主线程原则也适用于使用 &lt;code&gt;foreign export&lt;/code&gt; 从外部调用Haskell的情况。当 &lt;code&gt;foreign export&lt;/code&gt; 调用编辑功能，启动新的主线程，并返回时，主线程终止。如果该调用导致派生新线程，则在返回 &lt;code&gt;foreign export&lt;/code&gt; 函数后，它们可能会保留在系统中。</target>
        </trans-unit>
        <trans-unit id="a8aa707c2a5513daf094974e7984d291b1194cb2" translate="yes" xml:space="preserve">
          <source>The maintainers are glad to accept patches for further standard encodings of standard Haskell values.</source>
          <target state="translated">维护者很高兴接受为进一步的标准Haskell值的标准编码打补丁。</target>
        </trans-unit>
        <trans-unit id="744ef2d7aabc6bab260fc29bb9d92f2367435b58" translate="yes" xml:space="preserve">
          <source>The major effect of an &lt;code&gt;INLINE&lt;/code&gt; pragma is to declare a function&amp;rsquo;s &amp;ldquo;cost&amp;rdquo; to be very low. The normal unfolding machinery will then be very keen to inline it. However, an &lt;code&gt;INLINE&lt;/code&gt; pragma for a function &amp;ldquo;&lt;code&gt;f&lt;/code&gt;&amp;rdquo; has a number of other effects:</source>
          <target state="translated">&lt;code&gt;INLINE&lt;/code&gt; 编译指示的主要作用是声明函数的&amp;ldquo;成本&amp;rdquo;非常低。普通的展开机将非常热衷于内联它。但是，函数&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo; 的 &lt;code&gt;INLINE&lt;/code&gt; 编译指示还有许多其他作用：</target>
        </trans-unit>
        <trans-unit id="1159d0b17e1c60d7b892bb9301ccde55977e5feb" translate="yes" xml:space="preserve">
          <source>The manifest file that GHC generates when linking a binary on Windows is also embedded in the executable itself, by default. This means that the binary can be distributed without having to supply the manifest file too. The embedding is done by running &lt;strong&gt;windres&lt;/strong&gt;; to see exactly what GHC does to embed the manifest, use the &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt; flag. A GHC installation comes with its own copy of &lt;code&gt;windres&lt;/code&gt; for this reason.</source>
          <target state="translated">默认情况下，GHC在Windows上链接二进制文件时生成的清单文件也嵌入在可执行文件本身中。这意味着可以分发二进制文件而不必也提供清单文件。嵌入是通过运行&lt;strong&gt;风向标&lt;/strong&gt;完成的；要确切了解GHC嵌入清单的功能，请使用&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;标志。一个GHC安装有它自己的拷贝 &lt;code&gt;windres&lt;/code&gt; 这个原因。</target>
        </trans-unit>
        <trans-unit id="3378e6fba41b187d6615b43817c87aba7dfb73d6" translate="yes" xml:space="preserve">
          <source>The marshalling converts each Haskell character, representing a Unicode code point, to one or more bytes in a manner that, by default, is determined by the current locale. As a consequence, no guarantees can be made about the relative length of a Haskell string and its corresponding C string, and therefore all the marshalling routines include memory allocation. The translation between Unicode and the encoding of the current locale may be lossy.</source>
          <target state="translated">marshalling将代表Unicode码点的每个Haskell字符转换为一个或多个字节,其方式默认由当前的locale决定。因此,不能保证一个 Haskell 字符串和其对应的 C 字符串的相对长度,因此所有的 marshalling 例程都包括内存分配。Unicode 和当前locale的编码之间的翻译可能是有损的。</target>
        </trans-unit>
        <trans-unit id="ce3ddf92b0204346524d60c5ce7d32e072cd0d54" translate="yes" xml:space="preserve">
          <source>The matching behaviour is also influenced by two module-level language extension flags: &lt;a href=&quot;#extension-OverlappingInstances&quot;&gt;&lt;code&gt;OverlappingInstances&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt;. These extensions are now deprecated (since GHC 7.10) in favour of the fine-grained per-instance pragmas.</source>
          <target state="translated">匹配行为还受两个模块级语言扩展标志的影响：&lt;a href=&quot;#extension-OverlappingInstances&quot;&gt; &lt;code&gt;OverlappingInstances&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt;。现在不推荐使用这些扩展名（自GHC 7.10起），而推荐使用细粒度的按实例编译指示。</target>
        </trans-unit>
        <trans-unit id="e2ff7a2e018dbc48e22ad18efcef13edd8c486f6" translate="yes" xml:space="preserve">
          <source>The matrix of platforms that:</source>
          <target state="translated">平台的矩阵,。</target>
        </trans-unit>
        <trans-unit id="07015c741417849721502853df57df8b2fae7145" translate="yes" xml:space="preserve">
          <source>The maximal prefix of &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; that could be decoded from the given input.</source>
          <target state="translated">可以从给定输入中解码的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的最大前缀。</target>
        </trans-unit>
        <trans-unit id="aa2a714293d353e1ff3212bd761cfba481644c07" translate="yes" xml:space="preserve">
          <source>The maximal size of a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that is copied. &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; to guarantee that on average a chunk is of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">复制的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的最大大小。 &lt;code&gt;2 * &lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 以确保平均而言，一个块的大小为 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:smallChunkSize&quot;&gt;smallChunkSize&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d1640b5c03c6ca6aaac14f9e05c39afaa8e1c64" translate="yes" xml:space="preserve">
          <source>The maximum heap size also affects other garbage collection parameters: when the amount of live data in the heap exceeds a certain fraction of the maximum heap size, compacting collection will be automatically enabled for the oldest generation, and the &lt;code&gt;-F&lt;/code&gt; parameter will be reduced in order to avoid exceeding the maximum heap size.</source>
          <target state="translated">最大堆大小还会影响其他垃圾收集参数：当堆中的活动数据量超过最大堆大小的某个分数时，将自动为最旧的一代启用压缩收集，并且在 &lt;code&gt;-F&lt;/code&gt; 参数中将减小为了避免超出最大堆大小。</target>
        </trans-unit>
        <trans-unit id="7deac0bbef1cce9de070bc6eff250887dc27e012" translate="yes" xml:space="preserve">
          <source>The maximum number of lines stored in the history. If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the history storage is unlimited.</source>
          <target state="translated">历史记录中存储的最大行数。如果为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则历史存储空间是无限的。</target>
        </trans-unit>
        <trans-unit id="d734e50598efc9c9203e0509468ba84ba10e6429" translate="yes" xml:space="preserve">
          <source>The maximum number of of colors on the screen.</source>
          <target state="translated">画面上的最大颜色数量。</target>
        </trans-unit>
        <trans-unit id="b7d459650a2ba9b1231e79e180aceb1bd015d81c" translate="yes" xml:space="preserve">
          <source>The maximum space actually used by your program is the &amp;ldquo;bytes maximum residency&amp;rdquo; figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.</source>
          <target state="translated">程序实际使用的最大空间是&amp;ldquo;最大驻留字节数&amp;rdquo;。仅在主要垃圾回收期间才检查此内容，因此它只是一个近似值；样本数量告诉您检查了多少次。</target>
        </trans-unit>
        <trans-unit id="8b43db138dc3a233b97e08a96f2e5508bd7bc2ca" translate="yes" xml:space="preserve">
          <source>The maximum tuple size</source>
          <target state="translated">最大元组大小</target>
        </trans-unit>
        <trans-unit id="3c1ae6c029d2317f8ba5fb3110e02abfdbf30bfa" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. (See &lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS options for heap profiling&lt;/a&gt; for details.)</source>
          <target state="translated">缩写&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;的含义取决于您的程序是否已进行概要分析。（有关详细信息，请参见&lt;a href=&quot;profiling#rts-options-heap-prof&quot;&gt;RTS选项以进行堆分析&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="d87c8b0eb65b8cb788e02129482e2e2b711668c6" translate="yes" xml:space="preserve">
          <source>The meaning of the shortened &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is dependent on whether your program was compiled for profiling. When compiled for profiling, &lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;#rts-flag--hc&quot;&gt;&lt;code&gt;-hc&lt;/code&gt;&lt;/a&gt;, but otherwise is equivalent to &lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">缩写&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;的含义取决于您的程序是否已编译以进行概要分析。当编译剖析，&lt;a href=&quot;runtime_control#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;相当于&lt;a href=&quot;#rts-flag--hc&quot;&gt; &lt;code&gt;-hc&lt;/code&gt; &lt;/a&gt;，但在其他方面等同于&lt;a href=&quot;runtime_control#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt;（见&lt;a href=&quot;runtime_control#rts-profiling&quot;&gt;用于剖析RTS选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2c90c10f5a199858ea71a07e1f9c65a1b0281964" translate="yes" xml:space="preserve">
          <source>The mechanism is simple: whenever the program evaluates an expression with an SCC annotation, &lt;code&gt;{-# SCC c -#} E&lt;/code&gt;, the cost centre &lt;code&gt;c&lt;/code&gt; is pushed on the current stack, and the entry count for this stack is incremented by one. The stack also sometimes has to be saved and restored; in particular when the program creates a thunk (a lazy suspension), the current cost-centre stack is stored in the thunk, and restored when the thunk is evaluated. In this way, the cost-centre stack is independent of the actual evaluation order used by GHC at runtime.</source>
          <target state="translated">机制很简单：每当程序对带有SCC注释 &lt;code&gt;{-# SCC c -#} E&lt;/code&gt; 的表达式求值时，成本中心 &lt;code&gt;c&lt;/code&gt; 就会被推入当前堆栈，并且该堆栈的条目计数会增加1。有时还需要保存和恢复堆栈。特别是当程序创建一个thunk（一个懒惰的悬浮）时，当前的成本中心堆栈将存储在thunk中，并在评估thunk时恢复。这样，成本中心堆栈便独立于GHC在运行时使用的实际评估顺序。</target>
        </trans-unit>
        <trans-unit id="f7c0a3feb5345a104be8d4a49924286ed63663fa" translate="yes" xml:space="preserve">
          <source>The member functions of this class facilitate writing values of primitive types to raw memory (which may have been allocated with the above mentioned routines) and reading values from blocks of raw memory. The class, furthermore, includes support for computing the storage requirements and alignment restrictions of storable types.</source>
          <target state="translated">该类的成员函数有助于将基元类型的值写入原始内存(可能已经通过上述例程分配),并从原始内存块中读取值。此外,该类还包括支持计算可存储类型的存储需求和对齐限制。</target>
        </trans-unit>
        <trans-unit id="cba31954fa26087a15e99fd14a2e8df87f705a4d" translate="yes" xml:space="preserve">
          <source>The members &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class map all values of &lt;code&gt;CT&lt;/code&gt; to the corresponding value of &lt;code&gt;t&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的成员 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:poke&quot;&gt;poke&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;CT&lt;/code&gt; 的所有值映射到 &lt;code&gt;t&lt;/code&gt; 的对应值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="723dfa6d14019cdcb7ea8b493daa172324f5d5cf" translate="yes" xml:space="preserve">
          <source>The memory is freed when &lt;code&gt;f&lt;/code&gt; terminates (either normally or via an exception), so the pointer passed to &lt;code&gt;f&lt;/code&gt; must &lt;em&gt;not&lt;/em&gt; be used after this.</source>
          <target state="translated">当存储器被释放 &lt;code&gt;f&lt;/code&gt; 结束（正常或经由一个例外），所以传递给指针 &lt;code&gt;f&lt;/code&gt; 必须&lt;em&gt;不&lt;/em&gt;被在此之后使用。</target>
        </trans-unit>
        <trans-unit id="30cdd2b8067e97ef326db4b7a7649ae2a1d70b50" translate="yes" xml:space="preserve">
          <source>The memory management overhead. Currently this is tuned for GHC only.</source>
          <target state="translated">的内存管理开销。目前这个只针对GHC进行了调整。</target>
        </trans-unit>
        <trans-unit id="296145d71ce1908abeb930aa215c007de95d6dac" translate="yes" xml:space="preserve">
          <source>The memory may be deallocated using &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; when no longer required.</source>
          <target state="translated">当不再需要时，可以使用 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:finalizerFree&quot;&gt;finalizerFree&lt;/a&gt;&lt;/code&gt; 释放内存。</target>
        </trans-unit>
        <trans-unit id="b7786c976f2ff7540d0a6e4b59833c22c599315f" translate="yes" xml:space="preserve">
          <source>The memory may freed at any point after the subcomputation terminates, so the pointer to the storage must *not* be used after this.</source>
          <target state="translated">存储器可能在子计算终止后的任何时候被释放,所以在这之后一定不能*使用存储的指针。</target>
        </trans-unit>
        <trans-unit id="51295ee3cd81001e8a30ec8543497b0e8c877217" translate="yes" xml:space="preserve">
          <source>The merit of this is that you can derive instances for GADTs and other exotic data types, providing only that the boilerplate code does indeed typecheck. For example:</source>
          <target state="translated">这样做的好处是,你可以派生出GADTs和其他外来数据类型的实例,只需提供锅炉模板代码确实进行了类型检查。例如</target>
        </trans-unit>
        <trans-unit id="09ce093d9b8936752c951269f1ca598cad553080" translate="yes" xml:space="preserve">
          <source>The message printed if &lt;code&gt;malloc&lt;/code&gt; fails.</source>
          <target state="translated">如果 &lt;code&gt;malloc&lt;/code&gt; 失败，则显示消息。</target>
        </trans-unit>
        <trans-unit id="7c55c4a564eeb697e2553fd6d32d12eec12c5af2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 提供，允许程序员给解析值列表的专业方式。例如，此类型由 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例使用，在该实例中，应期望 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值使用双引号而不是方括号。</target>
        </trans-unit>
        <trans-unit id="2bb9dae247f1417713fe2e3ff89e568a58dd2064" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;ghc-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 被提供以允许程序员，得到表示值的列表的一个专门的方法。例如，这由 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例使用，其中 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值应该用双引号显示，而不是在方括号之间。</target>
        </trans-unit>
        <trans-unit id="9b206e34c8564a26770cfb63266e92dafdef2f00" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;prelude#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 提供，允许程序员给解析值列表的专业方式。例如，此类型由 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例使用，在该实例中，应期望 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值使用双引号而不是方括号。</target>
        </trans-unit>
        <trans-unit id="0b9ba8a954c2ae61c20aa36e469332d7313c7d48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;prelude#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 被提供以允许程序员，得到表示值的列表的一个专门的方法。例如，这由 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例使用，其中 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值应该用双引号显示，而不是在方括号之间。</target>
        </trans-unit>
        <trans-unit id="332ed4acf796a389b61681f06e5d3b89101d146a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of parsing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be are expected to use double quotes, rather than square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 提供，允许程序员给解析值列表的专业方式。例如，此类型由 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例使用，在该实例中，应期望 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值使用双引号而不是方括号。</target>
        </trans-unit>
        <trans-unit id="1e8a0b574789d1de5cf8d746837c55989fd9ec8f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; is provided to allow the programmer to give a specialised way of showing lists of values. For example, this is used by the predefined &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; type, where values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; should be shown in double quotes, rather than between square brackets.</source>
          <target state="translated">该方法 &lt;code&gt;&lt;a href=&quot;text-show#v:showList&quot;&gt;showList&lt;/a&gt;&lt;/code&gt; 被提供以允许程序员，得到表示值的列表的一个专门的方法。例如，这由 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 类型的预定义 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例使用，其中 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值应该用双引号显示，而不是在方括号之间。</target>
        </trans-unit>
        <trans-unit id="a55e07264dbb157af3468bbfef9f673d9ed1c760" translate="yes" xml:space="preserve">
          <source>The method names refer to the monoid of lists under concatenation, but there are many other instances.</source>
          <target state="translated">方法名称指的是连接下的列表单体,但还有很多其他实例。</target>
        </trans-unit>
        <trans-unit id="14f5aff046cf43c34ac7e373b3ac53e710239001" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt; defines the following:</source>
          <target state="translated">模块&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-records&quot;&gt;GHC.Records&lt;/a&gt;定义以下内容：</target>
        </trans-unit>
        <trans-unit id="6fe9f2287d708875ff918672eee840079c919130" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt; provides operations to allocate and deallocate blocks of raw memory (i.e., unstructured chunks of memory outside of the area maintained by the Haskell storage manager). These memory blocks are commonly used to pass compound data structures to foreign functions or to provide space in which compound result values are obtained from foreign functions.</source>
          <target state="translated">模块&lt;a href=&quot;foreign-marshal-alloc&quot;&gt;Foreign.Marshal.Alloc&lt;/a&gt;提供用于分配和取消分配原始内存块（即，由Haskell存储管理器维护的区域之外的非结构化内存块）的操作。这些存储块通常用于将复合数据结构传递给外部函数，或提供从外部函数获得复合结果值的空间。</target>
        </trans-unit>
        <trans-unit id="0aaac35805022709131420c56844a405405859b9" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy (except for &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt;):</source>
          <target state="translated">模块&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;重新导出 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 层次结构中的其他模块（ &lt;code&gt;Foreign.Marshal.Unsafe&lt;/code&gt; 除外）：</target>
        </trans-unit>
        <trans-unit id="b1df10bb69bf2b89bf3830cfbd382b7d65aa4ba2" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt; re-exports the other modules in the &lt;code&gt;Foreign.Marshal&lt;/code&gt; hierarchy:</source>
          <target state="translated">模块&lt;a href=&quot;foreign-marshal-safe&quot;&gt;Foreign.Marshal.Safe&lt;/a&gt;重新导出 &lt;code&gt;Foreign.Marshal&lt;/code&gt; 层次结构中的其他模块：</target>
        </trans-unit>
        <trans-unit id="28a8a8e9077c7af6ee0166e9bad843be62034b8c" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt; provides most elementary support for marshalling and is part of the language-independent portion of the Foreign Function Interface (FFI), and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;foreign-storable&quot;&gt;Foreign.Storable&lt;/a&gt;模块为编组提供了最基本的支持，并且是Foreign Function Interface（FFI）的与语言无关的部分的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="7b7c64247943d5ed0c07fe913e3a4cc1b0d102fc" translate="yes" xml:space="preserve">
          <source>The module header (including the export list), and import statements, are exactly as in Haskell, and so are the scoping rules. Hence, to mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">模块头(包括导出列表)和导入语句与 Haskell 中的完全一样,范围规则也是如此。因此,要提到一个非Prelude类型或类,你必须导入它。</target>
        </trans-unit>
        <trans-unit id="4ce45cb81b574e7a52ecde45d4ee5f41764d49db" translate="yes" xml:space="preserve">
          <source>The module must import &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;.</source>
          <target state="translated">该模块必须导入&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="271abdd5800add2d2a429d3960db113d446e207f" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">该模块是使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的</target>
        </trans-unit>
        <trans-unit id="61f9fc1e39c23939a82e428406225578b440fb61" translate="yes" xml:space="preserve">
          <source>The module was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">该模块由&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译</target>
        </trans-unit>
        <trans-unit id="8638db98256357d4532755afc9c9f9aac9ff4038" translate="yes" xml:space="preserve">
          <source>The monad and its operations</source>
          <target state="translated">单体及其操作</target>
        </trans-unit>
        <trans-unit id="da5e8905606683d3d0ad467ab40cd56a8717786c" translate="yes" xml:space="preserve">
          <source>The monoid of endomorphisms under composition.</source>
          <target state="translated">组成下的内构体单体。</target>
        </trans-unit>
        <trans-unit id="e9ccf96ea16ca69c701719763f3afb8aa9f150cf" translate="yes" xml:space="preserve">
          <source>The most common usage of &lt;code&gt;COMPLETE&lt;/code&gt; pragmas is with &lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern synonyms&lt;/a&gt;. On its own, the checker is very naive and assumes that any match involving a pattern synonym will fail. As a result, any pattern match on a pattern synonym is regarded as incomplete unless the user adds a catch-all case.</source>
          <target state="translated">&lt;code&gt;COMPLETE&lt;/code&gt; 用法最常见的用法是使用&lt;a href=&quot;#pattern-synonyms&quot;&gt;Pattern同义词&lt;/a&gt;。就其本身而言，检查器非常幼稚，并假定任何涉及模式同义词的匹配都将失败。结果，除非用户添加了全部情况，否则在模式同义词上的任何模式匹配都被认为是不完整的。</target>
        </trans-unit>
        <trans-unit id="063a9618d36844f08d6ef94989127397ea9b9b40" translate="yes" xml:space="preserve">
          <source>The most common way this can happen is when you&amp;rsquo;re evaluating a CAF (e.g. main), stop at a breakpoint, and ask for the value of the CAF at the prompt again.</source>
          <target state="translated">发生这种情况的最常见方式是，当您评估CAF（例如主），在断点处停止并在提示时再次询问CAF的值时。</target>
        </trans-unit>
        <trans-unit id="75340b8409f86aba60aed6656112aab745923bcd" translate="yes" xml:space="preserve">
          <source>The most commonly used ISO 8601 format for this type.</source>
          <target state="translated">这种类型最常用的ISO 8601格式。</target>
        </trans-unit>
        <trans-unit id="bfe39e2ecd43cfd563f91e4eca3de1502694fa6f" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在Identity Monad上运行解析器的最通用方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; 在令牌 &lt;code&gt;input&lt;/code&gt; 的输入列表上运行解析器 &lt;code&gt;p&lt;/code&gt; ，该令牌输入是从具有初始用户状态 &lt;code&gt;st&lt;/code&gt; 的源 &lt;code&gt;filePath&lt;/code&gt; 获得的。的 &lt;code&gt;filePath&lt;/code&gt; 只在错误消息中使用，并且可以是空字符串。返回 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）或类型 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）的值。</target>
        </trans-unit>
        <trans-unit id="aeb3d7e2ffb679903cf3a78fe1e8a43f4f5df8ed" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser over the Identity monad. &lt;code&gt;runParser p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在Identity Monad上运行解析器的最通用方法。 &lt;code&gt;runParser p state filePath input&lt;/code&gt; 在令牌 &lt;code&gt;input&lt;/code&gt; 的输入列表上运行解析器 &lt;code&gt;p&lt;/code&gt; ，该令牌输入是从具有初始用户状态 &lt;code&gt;st&lt;/code&gt; 的源 &lt;code&gt;filePath&lt;/code&gt; 获得的。的 &lt;code&gt;filePath&lt;/code&gt; 只在错误消息中使用，并且可以是空字符串。返回 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）或类型 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）的值。</target>
        </trans-unit>
        <trans-unit id="2c5053914782286bf569d388ab06bfb0dd58462e" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">运行解析器的最通用方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 在令牌 &lt;code&gt;input&lt;/code&gt; 的输入列表上运行解析器 &lt;code&gt;p&lt;/code&gt; ，该令牌输入是从源 &lt;code&gt;filePath&lt;/code&gt; 获得的，初始用户状态为 &lt;code&gt;st&lt;/code&gt; 。的 &lt;code&gt;filePath&lt;/code&gt; 只在错误消息中使用，并且可以是空字符串。返回基础单子 &lt;code&gt;m&lt;/code&gt; 中的计算，该计算返回 &lt;code&gt;&lt;a href=&quot;text-parsec#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）或类型 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）的值。</target>
        </trans-unit>
        <trans-unit id="0c6a5560b83d86896cc9662f87720adba5507322" translate="yes" xml:space="preserve">
          <source>The most general way to run a parser. &lt;code&gt;runParserT p state filePath
 input&lt;/code&gt; runs parser &lt;code&gt;p&lt;/code&gt; on the input list of tokens &lt;code&gt;input&lt;/code&gt;, obtained from source &lt;code&gt;filePath&lt;/code&gt; with the initial user state &lt;code&gt;st&lt;/code&gt;. The &lt;code&gt;filePath&lt;/code&gt; is only used in error messages and may be the empty string. Returns a computation in the underlying monad &lt;code&gt;m&lt;/code&gt; that return either a &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt;) or a value of type &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">运行解析器的最通用方法。 &lt;code&gt;runParserT p state filePath input&lt;/code&gt; 在令牌 &lt;code&gt;input&lt;/code&gt; 的输入列表上运行解析器 &lt;code&gt;p&lt;/code&gt; ，该令牌输入是从源 &lt;code&gt;filePath&lt;/code&gt; 获得的，初始用户状态为 &lt;code&gt;st&lt;/code&gt; 。的 &lt;code&gt;filePath&lt;/code&gt; 只在错误消息中使用，并且可以是空字符串。返回基础单子 &lt;code&gt;m&lt;/code&gt; 中的计算，该计算返回 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:ParseError&quot;&gt;ParseError&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; ）或类型 &lt;code&gt;a&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; ）的值。</target>
        </trans-unit>
        <trans-unit id="b5be00a95c813a0dae9db110b897e76b924717d2" translate="yes" xml:space="preserve">
          <source>The motivation for the change is that it means &lt;code&gt;IO a&lt;/code&gt; actions default to &lt;code&gt;IO ()&lt;/code&gt;, which in turn means that ghci won&amp;rsquo;t try to print a result when running them. This is particularly important for &lt;code&gt;printf&lt;/code&gt;, which has an instance that returns &lt;code&gt;IO a&lt;/code&gt;. However, it is only able to return &lt;code&gt;undefined&lt;/code&gt; (the reason for the instance having this type is so that printf doesn&amp;rsquo;t require extensions to the class system), so if the type defaults to &lt;code&gt;Integer&lt;/code&gt; then ghci gives an error when running a printf.</source>
          <target state="translated">进行更改的动机是，这意味着 &lt;code&gt;IO a&lt;/code&gt; 操作默认为 &lt;code&gt;IO ()&lt;/code&gt; ，这又意味着ghci在运行它们时不会尝试打印结果。这对于 &lt;code&gt;printf&lt;/code&gt; 尤其重要，后者的实例返回 &lt;code&gt;IO a&lt;/code&gt; 。但是，它只能返回 &lt;code&gt;undefined&lt;/code&gt; （实例具有这种类型的原因是，使得printf不需要扩展类系统），因此，如果类型默认为 &lt;code&gt;Integer&lt;/code&gt; ,则ghci在运行printf时会给出错误。</target>
        </trans-unit>
        <trans-unit id="c736836da3c61a5b28a8e40cd26c58ac3671ca42" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; is used to illustrate the relationship to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;: where &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; is shallow in the sense that it only evaluates the top level of its argument, &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; traverses the entire data structure evaluating it completely.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 名称用于说明与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 的关系： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 是浅层的，因为它仅评估其参数的顶级， &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 遍历整个对其进行评估的数据结构。</target>
        </trans-unit>
        <trans-unit id="ecfeb2264bf3f2219dcf11640cc5f23d975957a1" translate="yes" xml:space="preserve">
          <source>The name of an executable with a list of arguments</source>
          <target state="translated">带有参数列表的可执行文件的名称。</target>
        </trans-unit>
        <trans-unit id="e05e238891a0e5d7a1ad5addb5acbfa1d828b57f" translate="yes" xml:space="preserve">
          <source>The name of the constructor</source>
          <target state="translated">构造者的名称</target>
        </trans-unit>
        <trans-unit id="2372d4365121c955cf759525401a9a51abda2da3" translate="yes" xml:space="preserve">
          <source>The name of the datatype (unqualified)</source>
          <target state="translated">数据类型的名称(未限定)。</target>
        </trans-unit>
        <trans-unit id="4ad137cef439e5cbd9d31d951cbeeb39fa772cfe" translate="yes" xml:space="preserve">
          <source>The name of the dynamic library on Windows systems (optional).</source>
          <target state="translated">Windows系统中动态库的名称(可选)。</target>
        </trans-unit>
        <trans-unit id="a75d937e0b98713b032f66a0d3ddc12a66577a2c" translate="yes" xml:space="preserve">
          <source>The name of the interface file is derived using the same rules, except that the suffix is ⟨hisuf⟩ (&lt;code&gt;.hi&lt;/code&gt; by default) instead of ⟨osuf⟩, and the relevant options are &lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-odir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt;&lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">接口文件的名称使用同样的规则得出，只是后缀为⟨hisuf⟩（ &lt;code&gt;.hi&lt;/code&gt; 默认情况下），而不是⟨osuf⟩，以及相关的选项有&lt;a href=&quot;#ghc-flag--hidir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-hidir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--hisuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-hisuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;代替的&lt;a href=&quot;#ghc-flag--odir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--osuf%20%E2%9F%A8suffix%E2%9F%A9&quot;&gt; &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; &lt;/a&gt;分别。</target>
        </trans-unit>
        <trans-unit id="6453686e83ae95972b7e17f3b926e084c57ab74f" translate="yes" xml:space="preserve">
          <source>The name of the library on Unix and Windows (mingw) systems. Note that we don&amp;rsquo;t support building dynamic libraries of Haskell code on Unix systems.</source>
          <target state="translated">Unix和Windows（mingw）系统上的库名称。请注意，我们不支持在Unix系统上构建Haskell代码的动态库。</target>
        </trans-unit>
        <trans-unit id="d0f5dc8321c09ce84049b074ac570bfbec19828a" translate="yes" xml:space="preserve">
          <source>The name of the object file generated by GHC is derived according to the following rules, where ⟨osuf⟩ is the object-file suffix (this can be changed with the &lt;code&gt;-osuf&lt;/code&gt; option).</source>
          <target state="translated">由GHC生成的目标文件的名称是根据以下规则得出的，其中⟨osuf⟩是目标文件的后缀（可以使用 &lt;code&gt;-osuf&lt;/code&gt; 选项更改）。</target>
        </trans-unit>
        <trans-unit id="6861c4770b27354d7d4cfab408a9a6ca379e4807" translate="yes" xml:space="preserve">
          <source>The name of the pattern synonym is in the same namespace as proper data constructors. Like normal data constructors, pattern synonyms can be imported and exported through association with a type constructor or independently.</source>
          <target state="translated">模式同义词的名称与正统的数据构造器在同一个命名空间。与普通数据构造器一样,模式同义词可以通过与类型构造器关联或独立地导入和导出。</target>
        </trans-unit>
        <trans-unit id="1be799bf296167235ebb2ca091eee552b142616f" translate="yes" xml:space="preserve">
          <source>The name of the program</source>
          <target state="translated">程序名称</target>
        </trans-unit>
        <trans-unit id="39a42659e6043aff3532b0014c5b4fae37244931" translate="yes" xml:space="preserve">
          <source>The name of the selector</source>
          <target state="translated">选择器的名称</target>
        </trans-unit>
        <trans-unit id="7c51ecee2db2e110dbf3d1d2d9420bc2a5044c61" translate="yes" xml:space="preserve">
          <source>The name of the zone, typically a three- or four-letter acronym.</source>
          <target state="translated">区的名称,一般是三个或四个字母的缩写。</target>
        </trans-unit>
        <trans-unit id="4e49908da6a172e68a423a7eb23e95b552938d75" translate="yes" xml:space="preserve">
          <source>The name of this group (gr_name)</source>
          <target state="translated">该组的名称(gr_name)</target>
        </trans-unit>
        <trans-unit id="fae25b47526c2bd90bbb6d0b312e7136e668661b" translate="yes" xml:space="preserve">
          <source>The name of this operator is an allusion to &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt;. Note the similarities between their types:</source>
          <target state="translated">此运算符的名称表示 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 。注意它们的类型之间的相似之处：</target>
        </trans-unit>
        <trans-unit id="3bffd90620f4f0f826e5aaf337b1fe1334e782e4" translate="yes" xml:space="preserve">
          <source>The name without its module prefix.</source>
          <target state="translated">没有模块前缀的名称。</target>
        </trans-unit>
        <trans-unit id="646f96f37bb735ef8278fbc57b542fce8c940d51" translate="yes" xml:space="preserve">
          <source>The named wildcard forces the argument and result types to be the same. Lacking a signature, GHC would have inferred &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt;. A named wildcard can be mentioned in constraints, provided it also occurs in the monotype part of the type signature to make sure that it unifies with something:</source>
          <target state="translated">命名通配符强制参数和结果类型相同。缺少签名，GHC可以推断出 &lt;code&gt;forall a b. (Char, a) -&amp;gt; (Char, b)&lt;/code&gt; 。可以在约束中提及已命名的通配符，条件是该通配符也应出现在类型签名的单型部分中，以确保其与以下内容统一：</target>
        </trans-unit>
        <trans-unit id="1eb6c48a77c3ff916d6d31d64741779306bc02b7" translate="yes" xml:space="preserve">
          <source>The names in this module resemble those in the &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; family of modules, but are shorter due to the assumption of qualified naming.</source>
          <target state="translated">该模块中的名称与 &lt;code&gt;&lt;a href=&quot;data#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 系列模块中的名称相似，但由于假设使用合格的命名而使名称更短。</target>
        </trans-unit>
        <trans-unit id="2a298a889af18ee73428f1b23010db1d461094d5" translate="yes" xml:space="preserve">
          <source>The namespaces are:</source>
          <target state="translated">这些命名空间是:</target>
        </trans-unit>
        <trans-unit id="c41bfe70547efc280b4b232c6db8795351037886" translate="yes" xml:space="preserve">
          <source>The naming scheme may look a bit weird, but it has the purpose of allowing the co-existence of import libraries with ordinary static libraries (e.g., &lt;code&gt;libHSfoo.a&lt;/code&gt; and &lt;code&gt;libHSfoo.dll.a&lt;/code&gt;. Additionally, when the compiler driver is linking in non-static mode, it will rewrite occurrence of &lt;code&gt;-lHSfoo&lt;/code&gt; on the command line to &lt;code&gt;-lHSfoo.dll&lt;/code&gt;. By doing this for you, switching from non-static to static linking is simply a question of adding &lt;code&gt;-static&lt;/code&gt; to your command line.</source>
          <target state="translated">命名方案可能看起来有些怪异，但其目的是允许导入库与普通静态库（例如 &lt;code&gt;libHSfoo.a&lt;/code&gt; 和 &lt;code&gt;libHSfoo.dll.a&lt;/code&gt; )共存。此外，当编译器驱动程序以非静态方式链接时， -static模式，它将在命令行上出现的 &lt;code&gt;-lHSfoo&lt;/code&gt; 重写为 &lt;code&gt;-lHSfoo.dll&lt;/code&gt; 。通过为您执行此操作，从非静态链接切换到静态链接仅是将 &lt;code&gt;-static&lt;/code&gt; 添加到命令行的问题。</target>
        </trans-unit>
        <trans-unit id="a0044db577b12199ca68313af424ef55cbf96d30" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">当前平台的本机换行符表示形式：Unix系统上的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; ，Windows 系统上的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17286b53488467d11ce996bb67e9ac72d58ccc97" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">当前平台的本机换行符表示形式：Unix系统上的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; ，Windows 系统上的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-types#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78f21582e0027e530ef578f9b561481600ae0181" translate="yes" xml:space="preserve">
          <source>The native newline representation for the current platform: &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; on Unix systems, &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; on Windows.</source>
          <target state="translated">当前平台的本机换行符表示形式：Unix系统上的 &lt;code&gt;&lt;a href=&quot;system-io#v:LF&quot;&gt;LF&lt;/a&gt;&lt;/code&gt; ，Windows 系统上的 &lt;code&gt;&lt;a href=&quot;system-io#v:CRLF&quot;&gt;CRLF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f38af79343aeda66e3c105c4d632b98dde240785" translate="yes" xml:space="preserve">
          <source>The natural generated &lt;code&gt;Eq&lt;/code&gt; code would result in these instance declarations:</source>
          <target state="translated">自然生成的 &lt;code&gt;Eq&lt;/code&gt; 代码将导致以下实例声明：</target>
        </trans-unit>
        <trans-unit id="2aa75ff914d05468b9b141013cb484ac0d26b5d2" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 共享原始的终结器，从终结的角度来看，等同于仅创建对原始的另一个引用。也就是说，终结器将不会在新的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 无法访问之前被调用，也不会由于此调用而被调用额外的时间，并且终结器将使用与该调用不会发生的地址相同的地址进行调用，*不是*新地址。</target>
        </trans-unit>
        <trans-unit id="d537ecc2a0a7273339bdcd281e6203980acce3cf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; shares the finalizer of the original, equivalent from a finalization standpoint to just creating another reference to the original. That is, the finalizer will not be called before the new &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is unreachable, nor will it be called an additional time due to this call, and the finalizer will be called with the same address that it would have had this call not happened, *not* the new address.</source>
          <target state="translated">新的 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 共享原始的终结器，从终结的角度来看，等同于仅创建对原始的另一个引用。也就是说，终结器将不会在新的 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 无法访问之前被调用，也不会由于此调用而被调用额外的时间，并且终结器将使用与该调用不会发生的地址相同的地址进行调用，*不是*新地址。</target>
        </trans-unit>
        <trans-unit id="9565bf7af2fc32661af4296e391a5a4f73420f53" translate="yes" xml:space="preserve">
          <source>The new algorithm considers all outgoing edges of a basic blocks for code layout instead of only the last jump instruction. It also builds a control flow graph for functions, tries to find hot code paths and place them sequentially leading to better cache utilization and performance.</source>
          <target state="translated">新的算法考虑了基本块的所有出库边,而不是只考虑最后一条跳转指令,进行代码布局。它还为函数建立了一个控制流图,试图找到热代码路径并按顺序放置,从而提高缓存利用率和性能。</target>
        </trans-unit>
        <trans-unit id="0e6b6e161e08547e4c2e84b69fc3ce69fd7fe2bd" translate="yes" xml:space="preserve">
          <source>The new prompt is &lt;code&gt;*Main&lt;/code&gt;, which indicates that we are typing expressions in the context of the top-level of the &lt;code&gt;Main&lt;/code&gt; module. Everything that is in scope at the top-level in the module &lt;code&gt;Main&lt;/code&gt; we just loaded is also in scope at the prompt (probably including &lt;code&gt;Prelude&lt;/code&gt;, as long as &lt;code&gt;Main&lt;/code&gt; doesn&amp;rsquo;t explicitly hide it).</source>
          <target state="translated">新的提示是 &lt;code&gt;*Main&lt;/code&gt; ，它指示我们在 &lt;code&gt;Main&lt;/code&gt; 模块的顶级上下文中键入表达式。我们刚刚加载的模块 &lt;code&gt;Main&lt;/code&gt; 顶层范围内的所有内容也在提示符下也包含在范围内（可能包括 &lt;code&gt;Prelude&lt;/code&gt; ，只要 &lt;code&gt;Main&lt;/code&gt; 没有显式隐藏它即可）。</target>
        </trans-unit>
        <trans-unit id="53f5b2e47a4b9ae427e19c9dbf1f618026a18fe1" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新线程继承父对象的&lt;em&gt;被屏蔽&lt;/em&gt;状态（请参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d318f738e712b9a7c49deddbf087cc0b4b1ac85" translate="yes" xml:space="preserve">
          <source>The new thread inherits the &lt;em&gt;masked&lt;/em&gt; state of the parent (see &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">新线程继承父对象的&lt;em&gt;被屏蔽&lt;/em&gt;状态（请参见 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f49ffa4a3cda912cfa43024b34a8d1f99a2d6f8d" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新线程将是轻量级的&lt;em&gt;未绑定&lt;/em&gt;线程。不能保证此线程进行的外部调用不能由任何特定的OS线程进行；如果您需要通过特定的OS线程进行外部调用，请改用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d79262bf7af143e8fe77bde10bec763c9abf1332" translate="yes" xml:space="preserve">
          <source>The new thread will be a lightweight, &lt;em&gt;unbound&lt;/em&gt; thread. Foreign calls made by this thread are not guaranteed to be made by any particular OS thread; if you need foreign calls to be made by a particular OS thread, then use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">新线程将是轻量级的&lt;em&gt;未绑定&lt;/em&gt;线程。不能保证此线程进行的外部调用不能由任何特定的OS线程进行；如果您需要通过特定的OS线程进行外部调用，请改用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc43222cc5f22f48444dca9a33addd84a41162b9" translate="yes" xml:space="preserve">
          <source>The newly created thread has an exception handler that discards the exceptions &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt;, and passes all other exceptions to the uncaught exception handler.</source>
          <target state="translated">新创建的线程具有一个异常处理程序，该异常处理程序将丢弃 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 异常，并将所有其他异常传递给未捕获的异常处理程序。</target>
        </trans-unit>
        <trans-unit id="06467093ec13b99be21e49f501d476baef2995e0" translate="yes" xml:space="preserve">
          <source>The next Sunday strictly after a given day.</source>
          <target state="translated">严格在某一天后的下一个星期天。</target>
        </trans-unit>
        <trans-unit id="00554018ca7c76296e2e972dcf6e4032903f571e" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">仅在某些数组类型对之间支持非复制实现。一个约束是数组类型必须具有相同的表示形式。在GHC中，以下几对数组类型具有 &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeFreeze&quot;&gt;unsafeFreeze&lt;/a&gt;&lt;/code&gt; 的非复制O（1）实现。因为优化版本是由专业启用的，所以您需要使用优化（-O）进行编译才能获得它们。</target>
        </trans-unit>
        <trans-unit id="a17dd35e1a788245fc2675b10d198269467558f5" translate="yes" xml:space="preserve">
          <source>The non-copying implementation is supported between certain pairs of array types only; one constraint is that the array types must have identical representations. In GHC, The following pairs of array types have a non-copying O(1) implementation of &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt;. Because the optimised versions are enabled by specialisations, you will need to compile with optimisation (-O) to get them.</source>
          <target state="translated">仅在某些数组类型对之间支持非复制实现。一个约束是数组类型必须具有相同的表示形式。在GHC中，以下几对数组类型具有 &lt;code&gt;&lt;a href=&quot;data-array-unsafe#v:unsafeThaw&quot;&gt;unsafeThaw&lt;/a&gt;&lt;/code&gt; 的非复制O（1）实现。因为优化版本是由专业启用的，所以您需要使用优化（-O）进行编译才能获得它们。</target>
        </trans-unit>
        <trans-unit id="4065cd5ff81b5cc613fc73a9059855b99c8be0cc" translate="yes" xml:space="preserve">
          <source>The non-termination is reported like this:</source>
          <target state="translated">非终止是这样报告的。</target>
        </trans-unit>
        <trans-unit id="7d6d02244fcddd7ae83db06c2e068263589664bf" translate="yes" xml:space="preserve">
          <source>The nonnegative magnitude of a complex number.</source>
          <target state="translated">复数的非负数级。</target>
        </trans-unit>
        <trans-unit id="2ff00bf6c0c197af17057ab64282dcdcec685b3e" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; function with right associativity instead of left.</source>
          <target state="translated">具有右侧关联而不是左侧的法线 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="e8ea10bfd840fdd3f1f9ba01648e552adcfe5390" translate="yes" xml:space="preserve">
          <source>The normal rule in Haskell is that your program must supply a &lt;code&gt;main&lt;/code&gt; function in module &lt;code&gt;Main&lt;/code&gt;. When testing, it is often convenient to change which function is the &amp;ldquo;main&amp;rdquo; one, and the &lt;code&gt;-main-is&lt;/code&gt; flag allows you to do so. The ⟨thing⟩ can be one of:</source>
          <target state="translated">Haskell中的一般规则是您的程序必须在 &lt;code&gt;Main&lt;/code&gt; 模块中提供 &lt;code&gt;main&lt;/code&gt; 函数。测试时，更改哪个功能是&amp;ldquo;主要&amp;rdquo;功能通常很方便，并且 &lt;code&gt;-main-is&lt;/code&gt; 标志允许您执行此操作。&amp;ldquo;事物&amp;rdquo;可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="8565c7cc336e9d2bc02ea4c1cab0de9e55beac01" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;a -&amp;gt; b&lt;/code&gt; used here between the &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; symbols &amp;mdash; not to be confused with a function type &amp;mdash; indicates that the &lt;code&gt;a&lt;/code&gt; parameter uniquely determines the &lt;code&gt;b&lt;/code&gt; parameter, and might be read as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; determines &lt;code&gt;b&lt;/code&gt;.&amp;rdquo; Thus &lt;code&gt;D&lt;/code&gt; is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of &lt;code&gt;E&lt;/code&gt;, we can see that &lt;code&gt;E&lt;/code&gt; represents a (partial) one-to-one mapping between types.</source>
          <target state="translated">在 &lt;code&gt;|&lt;/code&gt; 之间使用的符号a- &lt;code&gt;a -&amp;gt; b&lt;/code&gt; 和 &lt;code&gt;where&lt;/code&gt; 符号-不与函数类型混淆-表示 &lt;code&gt;a&lt;/code&gt; 参数唯一地确定的 &lt;code&gt;b&lt;/code&gt; 参数，并且可能被理解为&amp;ldquo; &lt;code&gt;a&lt;/code&gt; 确定 &lt;code&gt;b&lt;/code&gt; &amp;rdquo;。因此， &lt;code&gt;D&lt;/code&gt; 不仅是一个关系，而且实际上是一个（部分）函数。类似地，从 &lt;code&gt;E&lt;/code&gt; 定义中包含的两个依赖关系中，我们可以看到 &lt;code&gt;E&lt;/code&gt; 表示类型之间的（部分）一对一映射。</target>
        </trans-unit>
        <trans-unit id="65e0f3cb1cdca573b0a31816dea29f6e08943a92" translate="yes" xml:space="preserve">
          <source>The null address.</source>
          <target state="translated">空地址。</target>
        </trans-unit>
        <trans-unit id="6f24da5886263ef92cea0da538817aecc2d6f529" translate="yes" xml:space="preserve">
          <source>The number of bytes that must be consumed</source>
          <target state="translated">必须消耗的字节数。</target>
        </trans-unit>
        <trans-unit id="ca0f126d79cabf7e2c5e95757d200444f569118d" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Gregorian calendar. First argument is year, second is month.</source>
          <target state="translated">根据格里高利历,某月的天数。第一个参数是年,第二个参数是月。</target>
        </trans-unit>
        <trans-unit id="9391d34aef57b18832247680a9bb961c2cb802e0" translate="yes" xml:space="preserve">
          <source>The number of days in a given month according to the proleptic Julian calendar. First argument is year, second is month.</source>
          <target state="translated">根据无序的朱利安历,某月的天数。第一个参数是年,第二个参数是月。</target>
        </trans-unit>
        <trans-unit id="0419481cf5884d86b99e61181cced8b51e95c26d" translate="yes" xml:space="preserve">
          <source>The number of elements in the array.</source>
          <target state="translated">数组中元素的数量。</target>
        </trans-unit>
        <trans-unit id="43d9d47c41193f72155e7e7c1d8d822460113e6b" translate="yes" xml:space="preserve">
          <source>The number of minutes offset from UTC. Positive means local time will be later in the day than UTC.</source>
          <target state="translated">与UTC的偏移分钟数。正数表示当地时间将比UTC晚一天。</target>
        </trans-unit>
        <trans-unit id="69b816c0ec0e62c60a64cad0412b6307fc8984cc" translate="yes" xml:space="preserve">
          <source>The number of times this particular point in the call tree was entered.</source>
          <target state="translated">呼叫树中这个特定点被输入的次数。</target>
        </trans-unit>
        <trans-unit id="d0ef27c2e92d99ce3709f3c8cd8149198afbb479" translate="yes" xml:space="preserve">
          <source>The numeric branch for this version. This reflects the fact that most software versions are tree-structured; there is a main trunk which is tagged with versions at various points (1,2,3...), and the first branch off the trunk after version 3 is 3.1, the second branch off the trunk after version 3 is 3.2, and so on. The tree can be branched arbitrarily, just by adding more digits.</source>
          <target state="translated">这个版本的数字分支。这反映了大多数软件版本都是树状结构的;有一个主干,在不同的点上标有版本(1,2,3...),版本3之后的第一个分支是3.1,版本3之后的第二个分支是3.2,以此类推。这棵树可以任意分支,只要增加更多的数字就可以了。</target>
        </trans-unit>
        <trans-unit id="4f31d4347cd14b9ff9a95c759d4f40a65f6f736b" translate="yes" xml:space="preserve">
          <source>The object file, which normally ends in a &lt;code&gt;.o&lt;/code&gt; suffix, contains the compiled code for the module.</source>
          <target state="translated">目标文件通常以 &lt;code&gt;.o&lt;/code&gt; 后缀结尾，其中包含模块的编译代码。</target>
        </trans-unit>
        <trans-unit id="805b61067737cd38cfcd7f8a184e0af8d81d4642" translate="yes" xml:space="preserve">
          <source>The object files, &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Bar.o&lt;/code&gt;, and &lt;code&gt;Bumble.o&lt;/code&gt; would be put into a subdirectory named after the architecture of the executing machine (&lt;code&gt;x86&lt;/code&gt;, &lt;code&gt;mips&lt;/code&gt;, etc).</source>
          <target state="translated">该目标文件， &lt;code&gt;Foo.o&lt;/code&gt; ， &lt;code&gt;Bar.o&lt;/code&gt; 和 &lt;code&gt;Bumble.o&lt;/code&gt; 会被放入一个执行机（的架构命名的子目录 &lt;code&gt;x86&lt;/code&gt; ， &lt;code&gt;mips&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="75f3688b610f29c49c2454cfe45bd0a8cb6e12b0" translate="yes" xml:space="preserve">
          <source>The object version of the library used by GHCi.</source>
          <target state="translated">GHCi使用的库的对象版本。</target>
        </trans-unit>
        <trans-unit id="838855ecfc9a22622038d43b1adcde548a91e7ce" translate="yes" xml:space="preserve">
          <source>The obsolete language options &lt;code&gt;PolymorphicComponents&lt;/code&gt; and &lt;a href=&quot;#extension-Rank2Types&quot;&gt;&lt;code&gt;Rank2Types&lt;/code&gt;&lt;/a&gt; are synonyms for &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;. They used to specify finer distinctions that GHC no longer makes. (They should really elicit a deprecation warning, but they don&amp;rsquo;t, purely to avoid the need to library authors to change their old flags specifications.)</source>
          <target state="translated">过时的语言选项 &lt;code&gt;PolymorphicComponents&lt;/code&gt; 和&lt;a href=&quot;#extension-Rank2Types&quot;&gt; &lt;code&gt;Rank2Types&lt;/code&gt; &lt;/a&gt;是同义词&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;。他们过去通常指定GHC不再做出的更好区分。（他们确实应该引发弃用警告，但并非如此，纯粹是为了避免需要库作者更改其旧标志规范。）</target>
        </trans-unit>
        <trans-unit id="de0046d717353b2193c161124220232a1d8fd82e" translate="yes" xml:space="preserve">
          <source>The old, shadowed, version of &lt;code&gt;T&lt;/code&gt; is displayed as &lt;code&gt;main::Interactive.T&lt;/code&gt; by GHCi in an attempt to distinguish it from the new &lt;code&gt;T&lt;/code&gt;, which is displayed as simply &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">老，阴影，版本的 &lt;code&gt;T&lt;/code&gt; 显示为 &lt;code&gt;main::Interactive.T&lt;/code&gt; 以试图从所述新区分它由GHCI &lt;code&gt;T&lt;/code&gt; ，其被显示为简单地 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c88cd7b17fb54593c249863957ba4ed3bfbb9b4a" translate="yes" xml:space="preserve">
          <source>The one exception to this rule is &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, since deriving an instance via &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; simply generates an empty instance declaration, which does not require the use of any constructors. See the &lt;a href=&quot;#derive-any-class&quot;&gt;deriving any class&lt;/a&gt; section for more details.</source>
          <target state="translated">此规则的一个例外是&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，因为通过&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;派生实例只是生成了一个空的实例声明，不需要使用任何构造函数。有关更多详细信息，请参见&lt;a href=&quot;#derive-any-class&quot;&gt;派生任何类&lt;/a&gt;一节。</target>
        </trans-unit>
        <trans-unit id="0268dcd59bf97b0cda9fb2201599f6e5dff9ca67" translate="yes" xml:space="preserve">
          <source>The only IO operations allowed in the IO action passed to &lt;code&gt;unsafeLocalState&lt;/code&gt; are (a) local allocation (&lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;allocaBytes&lt;/code&gt; and derived operations such as &lt;code&gt;withArray&lt;/code&gt; and &lt;code&gt;withCString&lt;/code&gt;), and (b) pointer operations (&lt;code&gt;Foreign.Storable&lt;/code&gt; and &lt;code&gt;Foreign.Ptr&lt;/code&gt;) on the pointers to local storage, and (c) foreign functions whose only observable effect is to read and/or write the locally allocated memory. Passing an IO operation that does not obey these rules results in undefined behaviour.</source>
          <target state="translated">传递给 &lt;code&gt;unsafeLocalState&lt;/code&gt; 的 IO操作中唯一允许的IO操作是（a）本地分配（ &lt;code&gt;alloca&lt;/code&gt; ， &lt;code&gt;allocaBytes&lt;/code&gt; 和派生操作，例如 &lt;code&gt;withArray&lt;/code&gt; 和 &lt;code&gt;withCString&lt;/code&gt; ），以及（b）指针上的指针操作（ &lt;code&gt;Foreign.Storable&lt;/code&gt; 和 &lt;code&gt;Foreign.Ptr&lt;/code&gt; ） （c）外部函数，其唯一可观察到的作用是读取和/或写入本地分配的内存。传递不遵守这些规则的IO操作会导致不确定的行为。</target>
        </trans-unit>
        <trans-unit id="e9a1db195c814668311158eb1709c1054c413cfc" translate="yes" xml:space="preserve">
          <source>The only difference between the two groups is that in the second group &lt;code&gt;len_acc&lt;/code&gt; is given a type signature. In the former case, &lt;code&gt;len_acc1&lt;/code&gt; is monomorphic in its own right-hand side, so the implicit parameter &lt;code&gt;?acc&lt;/code&gt; is not passed to the recursive call. In the latter case, because &lt;code&gt;len_acc2&lt;/code&gt; has a type signature, the recursive call is made to the &lt;em&gt;polymorphic&lt;/em&gt; version, which takes &lt;code&gt;?acc&lt;/code&gt; as an implicit parameter. So we get the following results in GHCi:</source>
          <target state="translated">两组之间的唯一区别是，在第二组中， &lt;code&gt;len_acc&lt;/code&gt; 具有类型签名。在前一种情况下， &lt;code&gt;len_acc1&lt;/code&gt; 在其右侧是单态的，因此隐式参数 &lt;code&gt;?acc&lt;/code&gt; 不会传递给递归调用。在后一种情况下，因为 &lt;code&gt;len_acc2&lt;/code&gt; 具有类型签名，所以将对&lt;em&gt;多态&lt;/em&gt;版本进行递归调用，该&lt;em&gt;多态&lt;/em&gt;版本将 &lt;code&gt;?acc&lt;/code&gt; 作为隐式参数。因此，我们在GHCi中得到以下结果：</target>
        </trans-unit>
        <trans-unit id="ac6054b6f6b6ca4251de8b08424a09d5460a4c6c" translate="yes" xml:space="preserve">
          <source>The only permissible implementation of such a signature is a module which reexports precisely the same entity:</source>
          <target state="translated">这种签字的唯一允许的执行方式是一个模块,该模块重新输出的是同一个实体。</target>
        </trans-unit>
        <trans-unit id="99f45ecbd145f7b28b73197352d367ab369881f7" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">应该显式调用 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 解析器的唯一点是主解析器的开始，以便跳过任何前导空白。</target>
        </trans-unit>
        <trans-unit id="0d17721b8d0f0086bd5ec1ab600c24a5629c442f" translate="yes" xml:space="preserve">
          <source>The only point where the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; parser should be called explicitly is the start of the main parser in order to skip any leading white space.</source>
          <target state="translated">应该显式调用 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:whiteSpace&quot;&gt;whiteSpace&lt;/a&gt;&lt;/code&gt; 解析器的唯一点是主解析器的开始，以便跳过任何前导空白。</target>
        </trans-unit>
        <trans-unit id="bb632a82c8eebfabcb7f6f7ed3c1cccfca2ac4bd" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one that does nothing:</source>
          <target state="translated">唯一的预定义实例是明显的一个什么都不做的实例。</target>
        </trans-unit>
        <trans-unit id="b74e3ab63478dc88412921dd78460cac468112a4" translate="yes" xml:space="preserve">
          <source>The only predefined instance is the obvious one to make strings work as usual:</source>
          <target state="translated">唯一的预定义实例是显而易见的,让字符串照常工作。</target>
        </trans-unit>
        <trans-unit id="225b573fdeb899c7024573c1625d7b7bcfcbe5a0" translate="yes" xml:space="preserve">
          <source>The only problem comes when a module contains an instance declaration and GHC has no other reason for visiting the module. Example:</source>
          <target state="translated">唯一的问题是,当一个模块包含一个实例声明,而GHC没有其他理由访问该模块时。例子:</target>
        </trans-unit>
        <trans-unit id="a77af1dde4bfd3f080f8a163fea93aea7a444506" translate="yes" xml:space="preserve">
          <source>The only thing left to do now is to define a &amp;ldquo;front-end&amp;rdquo; class, which is exposed to the user:</source>
          <target state="translated">现在剩下要做的就是定义一个&amp;ldquo;前端&amp;rdquo;类，该类向用户公开：</target>
        </trans-unit>
        <trans-unit id="4957a1ff0c6373e596985963e968abbd42fa8755" translate="yes" xml:space="preserve">
          <source>The only use for the &lt;code&gt;Unused&lt;/code&gt; constructor was to force the correct kind for the type variable &lt;code&gt;cxt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Unused&lt;/code&gt; 构造函数的唯一用途是为类型变量 &lt;code&gt;cxt&lt;/code&gt; 强制使用正确的类型。</target>
        </trans-unit>
        <trans-unit id="69d170600f85b05b40716ccd35bcd4f06954e076" translate="yes" xml:space="preserve">
          <source>The operating system on which the program is running.</source>
          <target state="translated">程序运行的操作系统。</target>
        </trans-unit>
        <trans-unit id="34731bb0d80073cd13a1f4f0433438861e603be9" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is either a directory or a symbolic link to a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且是目录或目录的符号链接，则 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesDirectoryExist&quot;&gt;doesDirectoryExist&lt;/a&gt;&lt;/code&gt; 操作将返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abe2bcec36d3cfe98f8b3b771acf0e3cbe03a0c1" translate="yes" xml:space="preserve">
          <source>The operation &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the argument file exists and is not a directory, and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">如果参数文件存在并且不是目录，则操作 &lt;code&gt;&lt;a href=&quot;system-directory#v:doesFileExist&quot;&gt;doesFileExist&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ,否则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1014ad70a94098ad03145dbaaa5e10a46dcfeb3" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setCurrentDirectory&quot;&gt;setCurrentDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="d1a77a11f3e83e3fc7cb291c25444400219866a2" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但与 &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="ec1e5f517351d98a1317840aae7a3f6d64c13a50" translate="yes" xml:space="preserve">
          <source>The operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该操作可能会失败，但具有与 &lt;code&gt;&lt;a href=&quot;system-directory#v:listDirectory&quot;&gt;listDirectory&lt;/a&gt;&lt;/code&gt; 相同的例外。</target>
        </trans-unit>
        <trans-unit id="b0c5c7f2e239edbf825df9ce2a38beea0ba143ba" translate="yes" xml:space="preserve">
          <source>The operation may fail with:</source>
          <target state="translated">该操作可能会失败,因为:</target>
        </trans-unit>
        <trans-unit id="8c066a4952b72a09ccd45c4c56e69a302b836518" translate="yes" xml:space="preserve">
          <source>The operations on strings are similar.</source>
          <target state="translated">对字符串的操作也是类似的。</target>
        </trans-unit>
        <trans-unit id="d278879460916dc24a386ba29fcbbca12720c53d" translate="yes" xml:space="preserve">
          <source>The operator section is treated like function application of an undefined function, while the lambda form is in WHNF that contains an application of an undefined function.</source>
          <target state="translated">运算符部分被当作未定义函数的函数应用,而lambda形式是在WHNF中包含未定义函数的应用。</target>
        </trans-unit>
        <trans-unit id="90d2b833a3ae58e36d089e36990a3439898a2cf2" translate="yes" xml:space="preserve">
          <source>The optimisation also works for GADTs which bind dictionaries. If we statically know which class dictionary we need then we will solve it directly rather than indirectly using the one passed in at run time.</source>
          <target state="translated">该优化同样适用于绑定字典的GADT。如果我们静态地知道我们需要哪个类字典,那么我们将直接解决它,而不是间接地使用运行时传入的字典。</target>
        </trans-unit>
        <trans-unit id="560d5fd1f4bc4b620b6067d2806fe1c21df3d911" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--C&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; is only available when GHC is built in unregisterised mode. See &lt;a href=&quot;codegens#unreg&quot;&gt;Unregisterised compilation&lt;/a&gt; for more details.</source>
          <target state="translated">仅当GHC在未注册模式下构建时，选项&lt;a href=&quot;#ghc-flag--C&quot;&gt; &lt;code&gt;-C&lt;/code&gt; &lt;/a&gt;才可用。有关更多详细信息，请参见&lt;a href=&quot;codegens#unreg&quot;&gt;未注册的编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00a060100430958f91df26ba43eebf619fa4ae0a" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--E&quot;&gt;&lt;code&gt;-E&lt;/code&gt;&lt;/a&gt; runs just the pre-processing passes of the compiler, dumping the result in a file.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--E&quot;&gt; &lt;code&gt;-E&lt;/code&gt; &lt;/a&gt;仅运行编译器的预处理过程，并将结果转储到文件中。</target>
        </trans-unit>
        <trans-unit id="0964a10be81d642da333713be7237fbcfb02fa70" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; warns about places where a pattern-match might fail at runtime. The function &lt;code&gt;g&lt;/code&gt; below will fail when applied to non-empty lists, so the compiler will emit a warning about this when &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;警告有关在运行时模式匹配可能失败的地方。下面的函数 &lt;code&gt;g&lt;/code&gt; 在应用于非空列表时将失败，因此当启用&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;时，编译器将发出有关此警告。</target>
        </trans-unit>
        <trans-unit id="ccd337cf3edfdd4e01711e8e069283d6a4d19280" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; warns about record fields that could fail when accessed via a lacking constructor. The function &lt;code&gt;f&lt;/code&gt; below will fail when applied to &lt;code&gt;Bar&lt;/code&gt;, so the compiler will emit a warning at its definition when &lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt;&lt;code&gt;-Wpartial-fields&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">选项&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;警告有关通过缺少构造函数访问的记录字段可能失败的记录。下面的函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;Bar&lt;/code&gt; 时将失败，因此启用&lt;a href=&quot;#ghc-flag--Wpartial-fields&quot;&gt; &lt;code&gt;-Wpartial-fields&lt;/code&gt; &lt;/a&gt;时，编译器将在其定义时发出警告。</target>
        </trans-unit>
        <trans-unit id="f50424482bd3ed523aa1fb5ace8902d19e5c6938" translate="yes" xml:space="preserve">
          <source>The option &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; causes each thunk to be blackholed as soon as evaluation begins. The default is &amp;ldquo;lazy blackholing&amp;rdquo;, whereby thunks are only marked as being under evaluation when a thread is paused for some reason. Lazy blackholing is typically more efficient (by 1-2% or so), because most thunks don&amp;rsquo;t need to be blackholed. However, eager blackholing can avoid more repeated computation in a parallel program, and this often turns out to be important for parallelism.</source>
          <target state="translated">选项&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;使每个thunk在评估开始后就被黑洞化。默认值为&amp;ldquo;懒惰黑洞&amp;rdquo;，其中，仅当线程由于某种原因暂停时，才将thunk标记为正在评估中。懒惰黑洞通常效率更高（提高1-2％左右），因为大多数暴徒不需要黑洞。但是，急切的漏洞可以避免在并行程序中进行更多的重复计算，这对于并行性通常很重要。</target>
        </trans-unit>
        <trans-unit id="dc3e0ec3b48b83ee97a18d535f56695193e4148b" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; is enabled, in order to apply special defaulting rules to expressions typed at the prompt (see &lt;a href=&quot;#extended-default-rules&quot;&gt;Type defaulting in GHCi&lt;/a&gt;).</source>
          <target state="translated">启用选项 &lt;code&gt;-XExtendedDefaultRules&lt;/code&gt; ，以便将特殊的默认规则应用于在提示符下键入的表达式（请参见&lt;a href=&quot;#extended-default-rules&quot;&gt;GHCi中的Type defaulting&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a172fb76c6f9f556ecc7ed1e53e547b76840fe25" translate="yes" xml:space="preserve">
          <source>The option descriptions (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">选项说明（请参阅 &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:OptDescr&quot;&gt;OptDescr&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="90c51e481e3ef85be23988058a9d8ffbfe523dad" translate="yes" xml:space="preserve">
          <source>The order requirements (see &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">订单要求（请参阅 &lt;code&gt;&lt;a href=&quot;system-console-getopt#t:ArgOrder&quot;&gt;ArgOrder&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a48428e93cda469aec76c5bbf3a45a3d1d4c0eca" translate="yes" xml:space="preserve">
          <source>The original discussion is archived here: &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;could we get a Data instance for Data.Text.Text?&lt;/a&gt;</source>
          <target state="translated">原始讨论存储在这里：&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2010-January/072379.html&quot;&gt;我们可以获取Data.Text.Text的Data实例吗？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3f3ab7a20ae1158bd257f4656d1c486a0bcb46f" translate="yes" xml:space="preserve">
          <source>The original program is just plain wrong. Here&amp;rsquo;s another sort of error</source>
          <target state="translated">原始程序完全是错误的。这是另一种错误</target>
        </trans-unit>
        <trans-unit id="6a36573f2a76f839bf0ccfbddc9a2d1af4b0c55c" translate="yes" xml:space="preserve">
          <source>The original set of data constructors for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的原始数据构造函数集</target>
        </trans-unit>
        <trans-unit id="026c8d8f9302a24eb8eb077091c8693319be6e8f" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operation, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, has a suitable type for lifting using &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">另外一个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，具有适合使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:mapStateT&quot;&gt;mapStateT&lt;/a&gt;&lt;/code&gt; 进行提升的类型：</target>
        </trans-unit>
        <trans-unit id="1421877ede54d6e7f4dbd61b5345c2c064b769f8" translate="yes" xml:space="preserve">
          <source>The other combinators have sensible default definitions, which may be overridden for efficiency.</source>
          <target state="translated">其他的组合器都有合理的默认定义,为了提高效率,可以重写。</target>
        </trans-unit>
        <trans-unit id="ab98415919b10ecc3cc9f0ce7f01d77f22a18942" translate="yes" xml:space="preserve">
          <source>The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</source>
          <target state="translated">其他方法的默认定义如下,可以用相应的专门实现来覆盖。</target>
        </trans-unit>
        <trans-unit id="1ac58fe3cbf02ef4899da15f0408247b3325cf81" translate="yes" xml:space="preserve">
          <source>The other place where role annotations may be necessary are in &lt;code&gt;hs-boot&lt;/code&gt; files (&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;), where the right-hand sides of definitions can be omitted. As usual, the types/classes declared in an &lt;code&gt;hs-boot&lt;/code&gt; file must match up with the definitions in the &lt;code&gt;hs&lt;/code&gt; file, including down to the roles. The default role for datatypes is representational in &lt;code&gt;hs-boot&lt;/code&gt; files, corresponding to the common use case.</source>
          <target state="translated">可能需要角色注释的其他地方是在 &lt;code&gt;hs-boot&lt;/code&gt; 文件（&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块&lt;/a&gt;）中，在这里可以省略定义的右侧。像往常一样，在 &lt;code&gt;hs-boot&lt;/code&gt; 文件中声明的类型/类必须与 &lt;code&gt;hs&lt;/code&gt; 文件中的定义匹配，包括角色。数据类型的默认角色是 &lt;code&gt;hs-boot&lt;/code&gt; 文件中的代表性角色，与常见用例相对应。</target>
        </trans-unit>
        <trans-unit id="ce2fa55812a38ce84cedcaac2cdc1ef31b6202dc" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是对 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 的特殊情况的优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="3063f59fc82d5bcf9d848a0f374f0dfb94c93aae" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是特殊情况下 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="ac62773ad5362997c71d7ab264fe5c75fd2faaf0" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是对 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMaybeMissing&quot;&gt;mapMaybeMissing&lt;/a&gt;&lt;/code&gt; 的特殊情况的优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="b158418f40f40b703534feba48e0a39163932604" translate="yes" xml:space="preserve">
          <source>The other tactics below are optimizations or simplifications of &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; for special cases. Most importantly,</source>
          <target state="translated">下面的其他策略是特殊情况下 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:traverseMaybeMissing&quot;&gt;traverseMaybeMissing&lt;/a&gt;&lt;/code&gt; 优化或简化。最重要的是，</target>
        </trans-unit>
        <trans-unit id="dd0ae12fb273623c47053fb946e9734ec1504f3d" translate="yes" xml:space="preserve">
          <source>The other time when &lt;code&gt;ghc-pkg recache&lt;/code&gt; is useful is for registering packages manually: it is possible to register a package by simply putting the appropriate file in the package database directory and invoking &lt;code&gt;ghc-pkg recache&lt;/code&gt; to update the cache. This method of registering packages may be more convenient for automated packaging systems.</source>
          <target state="translated">&lt;code&gt;ghc-pkg recache&lt;/code&gt; 有用的另一时间是手动注册软件包：可以通过简单地将适当的文件放在软件包数据库目录中并调用 &lt;code&gt;ghc-pkg recache&lt;/code&gt; 来更新软件包来注册软件包。对于自动包装系统，这种注册包装的方法可能更方便。</target>
        </trans-unit>
        <trans-unit id="0861b9b6f0ebfe21a1fd22a4af5949eaf3c859aa" translate="yes" xml:space="preserve">
          <source>The outer type constructor of the type</source>
          <target state="translated">类型的外类型构造函数</target>
        </trans-unit>
        <trans-unit id="e52891e976f0923c9c450c24bf9a613b4e6090fe" translate="yes" xml:space="preserve">
          <source>The outermost pattern of all pattern matches gets an implicit bang, unless disabled with &lt;code&gt;~&lt;/code&gt;. This applies to case expressions, patterns in lambda, do-notation, list comprehension, and so on. For example</source>
          <target state="translated">除非使用 &lt;code&gt;~&lt;/code&gt; 禁用，否则所有模式匹配项中最外面的模式都会隐式爆炸。这适用于case表达式，lambda中的模式，do-notation，列表理解等。例如</target>
        </trans-unit>
        <trans-unit id="50fd86f2281248d9b015c6814bb25ce010f3a96e" translate="yes" xml:space="preserve">
          <source>The output &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is the unused portion of the left half of the line, reversed.</source>
          <target state="translated">输出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是该行左半部分的未使用部分，取反了。</target>
        </trans-unit>
        <trans-unit id="cb7e26fd34291e2acd5790d7394332a842bf49bb" translate="yes" xml:space="preserve">
          <source>The output contains one report for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each report looks something like this:</source>
          <target state="translated">输出中包含了程序中每一个异常的报告(程序在执行过程中可能会引发和捕获多个异常),其中每个报告的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="05194572a5381678c8a688228784f26b016a976f" translate="yes" xml:space="preserve">
          <source>The output is buffered using the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s associated buffer. If this buffer is too small to execute one step of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action, then it is replaced with a large enough buffer.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的关联缓冲区对输出进行缓冲。如果此缓冲区太小而无法执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 动作的一个步骤，则将其替换为足够大的缓冲区。</target>
        </trans-unit>
        <trans-unit id="0c8e73b419eae441e273e393df1e5bc3d4c312e7" translate="yes" xml:space="preserve">
          <source>The output is placed in ⟨file⟩. If ⟨file⟩ is omitted, then the output is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">输出放置在&amp;ldquo;文件&amp;rdquo;中。如果省略⟨file⟩，那么输出将发送到 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c175e78b8f75a38f3457e0b934e42a19295ad3d3" translate="yes" xml:space="preserve">
          <source>The output of &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; begins with a header line containing three space-delimited fields:</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; &lt;/a&gt;的输出从包含三个以空格分隔的字段的标题行开始：</target>
        </trans-unit>
        <trans-unit id="28802857a982ea85a85714f0425defb468c55946" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;+RTS -s&lt;/code&gt; tells you how many &amp;ldquo;sparks&amp;rdquo; were created and executed during the run of the program (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;), which will give you an idea how well your &lt;code&gt;par&lt;/code&gt; annotations are working.</source>
          <target state="translated">&lt;code&gt;+RTS -s&lt;/code&gt; 的输出告诉您在程序运行期间创建和执行了多少&amp;ldquo;火花&amp;rdquo;（请参阅&lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS选项以控制垃圾收集器&lt;/a&gt;），这将使您了解 &lt;code&gt;par&lt;/code&gt; 批注的工作状况。</target>
        </trans-unit>
        <trans-unit id="5ec2bae52b2cc3a473ad80eff58c4a7008471d7a" translate="yes" xml:space="preserve">
          <source>The output of this program:</source>
          <target state="translated">这个程序的输出。</target>
        </trans-unit>
        <trans-unit id="2446a2868a9a29723ecfffcf757a87c6d61bb061" translate="yes" xml:space="preserve">
          <source>The overloaded immutable array interface</source>
          <target state="translated">重载的不可变数组接口</target>
        </trans-unit>
        <trans-unit id="1e0e89b8710fb95ffae85a663ed5283ed9621513" translate="yes" xml:space="preserve">
          <source>The package name of the module where the type is declared</source>
          <target state="translated">类型被声明的模块的包名。</target>
        </trans-unit>
        <trans-unit id="48d90d755f55a500041350382bef98a10e9d0ca5" translate="yes" xml:space="preserve">
          <source>The package specification must be a package that isn&amp;rsquo;t already installed.</source>
          <target state="translated">软件包规格必须是尚未安装的软件包。</target>
        </trans-unit>
        <trans-unit id="f92b41996d348be77128232f9506df91b9529223" translate="yes" xml:space="preserve">
          <source>The pair returned by &lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; should be the same pair as &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-either#v:partitionEithers&quot;&gt;partitionEithers&lt;/a&gt; x&lt;/code&gt; 返回的对应该与 &lt;code&gt;(&lt;a href=&quot;data-either#v:lefts&quot;&gt;lefts&lt;/a&gt; x, &lt;a href=&quot;data-either#v:rights&quot;&gt;rights&lt;/a&gt; x)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="87fe52a309c7ffdc572bfe5a6172b7ecd3b52888" translate="yes" xml:space="preserve">
          <source>The paper &lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;Quantified class constraints&lt;/a&gt; (by Bottu, Karachalias, Schrijvers, Oliveira, Wadler, Haskell Symposium 2017) describes this feature in technical detail, with examples, and so is a primary reference source for this proposal.</source>
          <target state="translated">论文《&lt;a href=&quot;http://i.cs.hku.hk/~bruno//papers/hs2017.pdf&quot;&gt;量化类约束》&lt;/a&gt;（由Bottu，Karachalias，Schrijvers，Oliveira，Wadler，Haskell Symposium 2017撰写）详细介绍了此功能，并附有示例，因此是该提案的主要参考资料。</target>
        </trans-unit>
        <trans-unit id="dced94497d68754bb216a7cf6251afa8e9bde139" translate="yes" xml:space="preserve">
          <source>The parameterizable exception monad.</source>
          <target state="translated">可参数化的异常单子。</target>
        </trans-unit>
        <trans-unit id="b8f1d6b1bf477c0c166957c6d1222206673e1984" translate="yes" xml:space="preserve">
          <source>The parameterizable maybe monad, obtained by composing an arbitrary monad with the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">可参数化的monad，可以通过将任意monad与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; monad组合而成。</target>
        </trans-unit>
        <trans-unit id="74b1844d5fa42c50cd76f5db0bf9f59ef141a0c6" translate="yes" xml:space="preserve">
          <source>The parameterizable reader monad.</source>
          <target state="translated">可参数化的阅读器单体。</target>
        </trans-unit>
        <trans-unit id="6146efa10903bbbf156fa5c26b4d5e4f6606ce79" translate="yes" xml:space="preserve">
          <source>The parentheses are required.</source>
          <target state="translated">括号是必须的。</target>
        </trans-unit>
        <trans-unit id="397c15a9095569645dd284901afa170c9778710f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsec#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="70b77746def41feea7c0cc0c441ef8e1338f1075" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="959f106f98eb9f3ad1febb52797880e72fcf614c" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;anyToken&lt;/code&gt; accepts any kind of token. It is for example used to implement &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt;. Returns the accepted token.</source>
          <target state="translated">解析器 &lt;code&gt;anyToken&lt;/code&gt; 接受任何种类的令牌。例如，它用于实现 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。返回接受的令牌。</target>
        </trans-unit>
        <trans-unit id="032f4f1c69665e22c5b13c0fd126547d28a038f1" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; behaves as parser &lt;code&gt;p&lt;/code&gt;, but whenever the parser &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, it replaces expect error messages with the expect error message &lt;code&gt;msg&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;p &amp;lt;?&amp;gt; msg&lt;/code&gt; 行为与解析器 &lt;code&gt;p&lt;/code&gt; 相同，但是只要解析器 &lt;code&gt;p&lt;/code&gt; 在&lt;em&gt;不消耗任何输入的情况下&lt;/em&gt;发生故障，它就会将预期错误消息替换为预期错误消息 &lt;code&gt;msg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8f1cafb19ba2c6dd478998d4b66d545fc48222e" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;permute perm&lt;/code&gt; parses a permutation of parser described by &lt;code&gt;perm&lt;/code&gt;. For example, suppose we want to parse a permutation of: an optional string of &lt;code&gt;a&lt;/code&gt;'s, the character &lt;code&gt;b&lt;/code&gt; and an optional &lt;code&gt;c&lt;/code&gt;. This can be described by:</source>
          <target state="translated">解析器 &lt;code&gt;permute perm&lt;/code&gt; 解析由 &lt;code&gt;perm&lt;/code&gt; 描述的解析器的排列。例如，假设我们要分析的置换：一个可选的串 &lt;code&gt;a&lt;/code&gt; 的，字符 &lt;code&gt;b&lt;/code&gt; 和可选 &lt;code&gt;c&lt;/code&gt; 。这可以通过以下方式描述：</target>
        </trans-unit>
        <trans-unit id="8e254f70fe9adf4383093f8ce0d95f1c2bcda2e8" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;satisfy f&lt;/code&gt; succeeds for any character for which the supplied function &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;. Returns the character that is actually parsed.</source>
          <target state="translated">对于提供的函数 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 的任何字符，解析器 &lt;code&gt;satisfy f&lt;/code&gt; 成功。返回实际解析的字符。</target>
        </trans-unit>
        <trans-unit id="1bfb2b49655a713a162727e182fda358189b4c0f" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The source position of the &lt;code&gt;t&lt;/code&gt; should be returned by &lt;code&gt;posFromTok t&lt;/code&gt; and the token can be shown using &lt;code&gt;showTok t&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;token showTok posFromTok testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的令牌 &lt;code&gt;t&lt;/code&gt; 。 &lt;code&gt;t&lt;/code&gt; 的源位置应由 &lt;code&gt;posFromTok t&lt;/code&gt; 返回，并且可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。</target>
        </trans-unit>
        <trans-unit id="c8a05309fd4e0b7bbf92681d8e8ae0f5ce9a9e73" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; accepts a token &lt;code&gt;t&lt;/code&gt; with result &lt;code&gt;x&lt;/code&gt; when the function &lt;code&gt;testTok t&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt;. The token can be shown using &lt;code&gt;showTok t&lt;/code&gt;. The position of the &lt;em&gt;next&lt;/em&gt; token should be returned when &lt;code&gt;nextPos&lt;/code&gt; is called with the current source position &lt;code&gt;pos&lt;/code&gt;, the current token &lt;code&gt;t&lt;/code&gt; and the rest of the tokens &lt;code&gt;toks&lt;/code&gt;, &lt;code&gt;nextPos pos t toks&lt;/code&gt;.</source>
          <target state="translated">当函数 &lt;code&gt;testTok t&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; x&lt;/code&gt; x时，解析器 &lt;code&gt;tokenPrim showTok nextPos testTok&lt;/code&gt; 接受带有结果 &lt;code&gt;x&lt;/code&gt; 的标记 &lt;code&gt;t&lt;/code&gt; 。可以使用 &lt;code&gt;showTok t&lt;/code&gt; 显示令牌。所述的位置&lt;em&gt;下&lt;/em&gt;时，令牌应该返回 &lt;code&gt;nextPos&lt;/code&gt; 调用与所述电流源位置 &lt;code&gt;pos&lt;/code&gt; ，当前令牌 &lt;code&gt;t&lt;/code&gt; 和令牌的其余 &lt;code&gt;toks&lt;/code&gt; ， &lt;code&gt;nextPos pos t toks&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="284e02f9430552d71dd41595aab5dc530d4b9da6" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;try p&lt;/code&gt; behaves like parser &lt;code&gt;p&lt;/code&gt;, except that it pretends that it hasn't consumed any input when an error occurs.</source>
          <target state="translated">解析器 &lt;code&gt;try p&lt;/code&gt; 的行为与解析器 &lt;code&gt;p&lt;/code&gt; 相似，除了它假装在发生错误时没有消耗任何输入。</target>
        </trans-unit>
        <trans-unit id="d3107597af9e1ca4d6874447085190c38569263b" translate="yes" xml:space="preserve">
          <source>The parser &lt;code&gt;unexpected msg&lt;/code&gt; always fails with an unexpected error message &lt;code&gt;msg&lt;/code&gt; without consuming any input.</source>
          <target state="translated">解析器 &lt;code&gt;unexpected msg&lt;/code&gt; 总是失败，并意外的错误消息 &lt;code&gt;msg&lt;/code&gt; 而不消耗任何输入。</target>
        </trans-unit>
        <trans-unit id="248c447e9af3733e32f0c2f859f725b0237051c8" translate="yes" xml:space="preserve">
          <source>The parser is called &lt;em&gt;predictive&lt;/em&gt; since &lt;code&gt;q&lt;/code&gt; is only tried when parser &lt;code&gt;p&lt;/code&gt; didn't consume any input (i.e.. the look ahead is 1). This non-backtracking behaviour allows for both an efficient implementation of the parser combinators and the generation of good error messages.</source>
          <target state="translated">该解析器称为&lt;em&gt;预测性&lt;/em&gt;解析器，因为 &lt;code&gt;q&lt;/code&gt; 仅在解析器 &lt;code&gt;p&lt;/code&gt; 不使用任何输入（即，前瞻为1）时才尝试使用q。这种非回溯行为既可以实现解析器组合器的有效实现，又可以生成良好的错误消息。</target>
        </trans-unit>
        <trans-unit id="c654c33ff97b96ae7e18c028c030987b14161463" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="5368ea498695499b712c681c0cc89fba27b8d208" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="128ec374e35c570797eef5701a7459bc72bdf064" translate="yes" xml:space="preserve">
          <source>The parsers &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;unexpected&lt;/code&gt; are the three parsers used to generate error messages. Of these, only (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt;) is commonly used. For an example of the use of &lt;code&gt;unexpected&lt;/code&gt;, see the definition of &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解析器 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; ，（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;unexpected&lt;/code&gt; 解析器是用于生成错误消息的三个解析器。其中，通常仅使用（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。有关 &lt;code&gt;unexpected&lt;/code&gt; 使用的示例，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="f4818ed8827f047325509f05e7e58db632c0a9b1" translate="yes" xml:space="preserve">
          <source>The part before the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;context&lt;/em&gt;, while the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo; is the &lt;em&gt;head&lt;/em&gt; of the instance declaration.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;rdquo; 之前的部分是&lt;em&gt;上下文&lt;/em&gt;，而&amp;ldquo; &lt;code&gt;=&amp;gt;&lt;/code&gt; &amp;rdquo; 之后的部分是实例声明的&lt;em&gt;头部&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="8c4af47c225f8bda2b21acfa7343627c8d8e9119" translate="yes" xml:space="preserve">
          <source>The partially filled last buffer together with the result.</source>
          <target state="translated">最后一个缓冲区的部分填充和结果。</target>
        </trans-unit>
        <trans-unit id="76555f01f592b0a2cdc627f47763c8dfacb0c6f2" translate="yes" xml:space="preserve">
          <source>The password for this group (gr_passwd)</source>
          <target state="translated">该组的密码(gr_passwd)</target>
        </trans-unit>
        <trans-unit id="2d3745d1a12b2bebf51e7faab541e80ec1f0a40f" translate="yes" xml:space="preserve">
          <source>The path returned by &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; corresponds to the program that would be executed by &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; when passed the same string (as a &lt;code&gt;RawCommand&lt;/code&gt;, not a &lt;code&gt;ShellCommand&lt;/code&gt;), provided that &lt;code&gt;name&lt;/code&gt; is not a relative path with more than one segment.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt; name&lt;/code&gt; 返回的路径对应于传递相同字符串（作为 &lt;code&gt;RawCommand&lt;/code&gt; ，不是 &lt;code&gt;ShellCommand&lt;/code&gt; ）时由 &lt;code&gt;&lt;a href=&quot;http://hackage.haskell.org/package/process/docs/System-Process.html#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 执行的程序，但前提是该 &lt;code&gt;name&lt;/code&gt; 不是具有多个段的相对路径。</target>
        </trans-unit>
        <trans-unit id="9dcaa800bf3364bc2f0c84de7ea08da5a42f3563" translate="yes" xml:space="preserve">
          <source>The path to the directory you want to make</source>
          <target state="translated">你要制作的目录的路径</target>
        </trans-unit>
        <trans-unit id="1e9c6b10b0fdf62a37b5bb885fce58f3a72f52f0" translate="yes" xml:space="preserve">
          <source>The pattern</source>
          <target state="translated">模式</target>
        </trans-unit>
        <trans-unit id="80e42327db0e35402f1cf71bace675478feffb85" translate="yes" xml:space="preserve">
          <source>The pattern syntax reflects the term syntax:</source>
          <target state="translated">模式语法反映的是术语语法。</target>
        </trans-unit>
        <trans-unit id="1c7f40f56c74434aacb6e8837492766e4ad8a9e2" translate="yes" xml:space="preserve">
          <source>The pattern type signature makes the type variable available on the right-hand side of the equation.</source>
          <target state="translated">模式类型签名使类型变量在等式的右侧可用。</target>
        </trans-unit>
        <trans-unit id="64cba4adeb973c40ed7ade97bdcc25e2ee42d42d" translate="yes" xml:space="preserve">
          <source>The peak memory the RTS has allocated from the OS.</source>
          <target state="translated">RTS从操作系统分配的峰值内存。</target>
        </trans-unit>
        <trans-unit id="22eefa908237bf9e53141f656837f953dc52cd51" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call and all of its sub-calls.</source>
          <target state="translated">这个调用及其所有子调用占程序总内存分配的百分比(不包括剖析开销)。</target>
        </trans-unit>
        <trans-unit id="65fb5b8744f0d8b0724f16ce7115e8c2ec9bf85b" translate="yes" xml:space="preserve">
          <source>The percentage of the total memory allocations (excluding profiling overheads) of the program made by this call.</source>
          <target state="translated">本次调用占程序总内存分配的百分比(不包括剖析开销)。</target>
        </trans-unit>
        <trans-unit id="068fb517248f218c1fba65bf915d364e543e8fec" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent at this point in the call tree.</source>
          <target state="translated">程序总运行时间中花在调用树这一点上的百分比。</target>
        </trans-unit>
        <trans-unit id="7c2cbfcc5414f5b7bbe22870e814c3e36aa5a19a" translate="yes" xml:space="preserve">
          <source>The percentage of the total run time of the program spent below this point in the call tree.</source>
          <target state="translated">程序总运行时间在调用树的这一点以下的百分比。</target>
        </trans-unit>
        <trans-unit id="6d1e32ad3dc0bf0fc541838e24bd7ba405c901ce" translate="yes" xml:space="preserve">
          <source>The phase of a complex number, in the range &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt;. If the magnitude is zero, then so is the phase.</source>
          <target state="translated">复数的相位，范围为 &lt;code&gt;(-&lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;, &lt;a href=&quot;numeric#v:pi&quot;&gt;pi&lt;/a&gt;]&lt;/code&gt; 。如果大小为零，则相位也是如此。</target>
        </trans-unit>
        <trans-unit id="5ec5d9e6ba55f7a9e7cb0eba6a8d8b520103da78" translate="yes" xml:space="preserve">
          <source>The platform specific type for a process identifier.</source>
          <target state="translated">流程标识符的平台特定类型。</target>
        </trans-unit>
        <trans-unit id="05ce8c49af72e9c0812629a99bef4d7bdcd57f07" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">数组内容的指针由 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="f752177391a2368cd5aff90c60b692550ec7f6f2" translate="yes" xml:space="preserve">
          <source>The pointer to the array contents is obtained by &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;. The idea is similar to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; (used internally here). The pointer should be used only during execution of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action retured by the function passed as argument to &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">数组内容的指针由 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 获得。这个想法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; （在此内部使用）。仅在执行由作为参数传递给 &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:withStorableArray&quot;&gt;withStorableArray&lt;/a&gt;&lt;/code&gt; 的函数所处理的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作期间才使用该指针。</target>
        </trans-unit>
        <trans-unit id="0b20c9f030aa51113089e5842b41d705c082ffe5" translate="yes" xml:space="preserve">
          <source>The polymorphic kind of this type allows it to be used in several settings. For instance, it can be used as a constraint, e.g. to provide a better error message for a non-existent instance,</source>
          <target state="translated">这种类型的多态性使得它可以在多种环境下使用。例如,它可以作为一个约束条件,例如,为一个不存在的实例提供更好的错误信息。</target>
        </trans-unit>
        <trans-unit id="7dd3eeff891b51deab88c6a4902ae766c6f21033" translate="yes" xml:space="preserve">
          <source>The position of a subscript in the subrange.</source>
          <target state="translated">子范围内的下标位置。</target>
        </trans-unit>
        <trans-unit id="559ede6970ff4191905ab3f6622d825b5bd8500d" translate="yes" xml:space="preserve">
          <source>The practical implication of this difference is that due to the &lt;em&gt;imprecise exceptions&lt;/em&gt; semantics,</source>
          <target state="translated">这种差异的实际含义是，由于&lt;em&gt;异常&lt;/em&gt;语义的&lt;em&gt;不精确性&lt;/em&gt;，</target>
        </trans-unit>
        <trans-unit id="8190358d9c4e04dbcfc369855323f1dc1ed11104" translate="yes" xml:space="preserve">
          <source>The pragma must occur inside the &lt;code&gt;where&lt;/code&gt; part of the instance declaration.</source>
          <target state="translated">编译指示必须出现在实例声明的 &lt;code&gt;where&lt;/code&gt; 部分内。</target>
        </trans-unit>
        <trans-unit id="031c8f6ef621f154509b2aed1694bc1a7e8c617f" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;code&gt;OVERLAPPING&lt;/code&gt;, &lt;code&gt;OVERLAPPABLE&lt;/code&gt;, &lt;code&gt;OVERLAPS&lt;/code&gt;, &lt;code&gt;INCOHERENT&lt;/code&gt; are used to specify the overlap behavior for individual instances, as described in Section &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;. The pragmas are written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword, like this:</source>
          <target state="translated">语法 &lt;code&gt;OVERLAPPING&lt;/code&gt; ， &lt;code&gt;OVERLAPPABLE&lt;/code&gt; ， &lt;code&gt;OVERLAPS&lt;/code&gt; ， &lt;code&gt;INCOHERENT&lt;/code&gt; 用于指定各个实例的重叠行为，如&amp;ldquo; &lt;a href=&quot;#instance-overlap&quot;&gt;重叠实例&amp;rdquo;一&lt;/a&gt;节中所述。编译指示立即写在 &lt;code&gt;instance&lt;/code&gt; 关键字之后，如下所示：</target>
        </trans-unit>
        <trans-unit id="80dd1dde937515d8dba7eb30a62ee2aee1dbce22" translate="yes" xml:space="preserve">
          <source>The pre-processor is run just before the Haskell compiler proper processes the Haskell input, but after the literate markup has been stripped away and (possibly) the C pre-processor has washed the Haskell input.</source>
          <target state="translated">预处理器是在Haskell编译器正确处理Haskell输入之前运行的,但在识字标记被剥离之后,而且(可能)C预处理器已经清洗了Haskell输入。</target>
        </trans-unit>
        <trans-unit id="3b0af5d5c36b657cc7d9ed4c1b41c0833ec4e287" translate="yes" xml:space="preserve">
          <source>The precise color scheme is controlled by the environment variable &lt;code&gt;GHC_COLORS&lt;/code&gt; (or &lt;code&gt;GHC_COLOURS&lt;/code&gt;). This can be set to colon-separated list of &lt;code&gt;key=value&lt;/code&gt; pairs. These are the default settings:</source>
          <target state="translated">精确的配色方案由环境变量 &lt;code&gt;GHC_COLORS&lt;/code&gt; （或 &lt;code&gt;GHC_COLOURS&lt;/code&gt; ）控制。可以将其设置为以冒号分隔的 &lt;code&gt;key=value&lt;/code&gt; 对列表。这些是默认设置：</target>
        </trans-unit>
        <trans-unit id="2fc32854b4e2e98d1d21502bcb28d7b8e12f08ad" translate="yes" xml:space="preserve">
          <source>The precision for Integral types is accomplished by zero-padding. If both precision and zero-pad are given for an Integral field, the zero-pad is ignored.</source>
          <target state="translated">Integral类型的精度是通过零点填充来实现的,如果一个Integral字段同时给出精度和零点填充,那么零点填充将被忽略。如果一个积分字段同时给出了精度和零位数,则忽略零位数。</target>
        </trans-unit>
        <trans-unit id="6427936fd3378899feeb71f267643f93c076799f" translate="yes" xml:space="preserve">
          <source>The predicate is assumed to define an equivalence.</source>
          <target state="translated">谓词被假定为定义一个等价物。</target>
        </trans-unit>
        <trans-unit id="97c46e75defc42b19335cc4acd7f7b8d23b0ab48" translate="yes" xml:space="preserve">
          <source>The prefix `&lt;code&gt;generic&lt;/code&gt;' indicates an overloaded function that is a generalized version of a &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; function.</source>
          <target state="translated">前缀` &lt;code&gt;generic&lt;/code&gt; '表示重载函数，是&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;函数的广义版本。</target>
        </trans-unit>
        <trans-unit id="4e5998474098f5954e11b07869ce4b965aab5cd3" translate="yes" xml:space="preserve">
          <source>The preprocessor cannot cope with other Haskell extensions. These would have to go in separate modules.</source>
          <target state="translated">预处理器无法处理其他 Haskell 扩展。这些必须放在单独的模块中。</target>
        </trans-unit>
        <trans-unit id="48cdcef6c8bba47873b2657cefbebf9a582e8376" translate="yes" xml:space="preserve">
          <source>The primary difficulty with managing shared libraries is arranging things such that programs can find the libraries they need at runtime. The details of how this works varies between platforms, in particular the three major systems: Unix ELF platforms, Windows and Mac OS X.</source>
          <target state="translated">管理共享库的主要难点是安排好程序在运行时能找到所需的库。不同的平台,特别是三大系统之间的工作细节有所不同。Unix ELF平台,Windows和Mac OS X。</target>
        </trans-unit>
        <trans-unit id="1b94ab7b19971d0143cb6a1dc0aaaa9d62aab435" translate="yes" xml:space="preserve">
          <source>The primary source of asynchronous exceptions, however, is &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">但是，异步异常的主要来源是 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="db2ba14a4921403cf0313fa72d18649bbc679eef" translate="yes" xml:space="preserve">
          <source>The primitive parser combinators.</source>
          <target state="translated">原始解析器组合器。</target>
        </trans-unit>
        <trans-unit id="f13d852fb55e7d4ce977dd12fee90d0bc1dc9fe0" translate="yes" xml:space="preserve">
          <source>The primops make extensive use of &lt;a href=&quot;#glasgow-unboxed&quot;&gt;unboxed types&lt;/a&gt; and &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt;, which we briefly summarise here.</source>
          <target state="translated">primops广泛使用未&lt;a href=&quot;#glasgow-unboxed&quot;&gt;装箱的类型&lt;/a&gt;和未&lt;a href=&quot;#unboxed-tuples&quot;&gt;装箱的元组&lt;/a&gt;，我们在这里简要地进行总结。</target>
        </trans-unit>
        <trans-unit id="17617bbcaecd4caffa758995817fc1d0e3af127e" translate="yes" xml:space="preserve">
          <source>The problem here is that this instance would allow one particular choice of &lt;code&gt;[a]&lt;/code&gt; to be associated with more than one choice for &lt;code&gt;b&lt;/code&gt;, which contradicts the dependency specified in the definition of &lt;code&gt;D&lt;/code&gt;. More generally, this means that, in any instance of the form:</source>
          <target state="translated">这里的问题在于，此实例将允许 &lt;code&gt;[a]&lt;/code&gt; 的一个特定选择与 &lt;code&gt;b&lt;/code&gt; 的一个以上选择相关联，这与 &lt;code&gt;D&lt;/code&gt; 的定义中指定的依赖性相矛盾。更一般而言，这意味着在任何形式的情况下：</target>
        </trans-unit>
        <trans-unit id="e0f5743627f2c13906299b1a7e64c44a8ec050dd" translate="yes" xml:space="preserve">
          <source>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking system calls which works for most system calls on both Unix and Windows. When the &lt;code&gt;InterruptibleFFI&lt;/code&gt; extension is enabled, a foreign call can be annotated with &lt;code&gt;interruptible&lt;/code&gt; instead of &lt;code&gt;safe&lt;/code&gt; or &lt;code&gt;unsafe&lt;/code&gt;:</source>
          <target state="translated">问题在于，通常不可能安全地打断外线电话。但是，GHC确实提供了一种中断阻塞系统调用的方法，该方法适用于Unix和Windows上的大多数系统调用。当 &lt;code&gt;InterruptibleFFI&lt;/code&gt; 启用扩展，外国通话可以与注释 &lt;code&gt;interruptible&lt;/code&gt; ，而不是 &lt;code&gt;safe&lt;/code&gt; 或 &lt;code&gt;unsafe&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d34cc9fd2e90a4c7e190d8e316ee751917d80db" translate="yes" xml:space="preserve">
          <source>The problem with using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel is that if it is only written to and never read, items will pile up in memory. By using &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; to create the broadcast channel, items can be garbage collected after clients have seen them.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChan&quot;&gt;newTChan&lt;/a&gt;&lt;/code&gt; 创建广播频道的问题在于，如果仅将其写入而从不读取，则项目将堆积在内存中。通过使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChan&quot;&gt;newBroadcastTChan&lt;/a&gt;&lt;/code&gt; 创建广播频道，可以在客户看到项目后对其进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="abc76e2f497ab466ec7ca65dcd335b801b282966" translate="yes" xml:space="preserve">
          <source>The procedure to check if a module is trusted or not depends on if the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is present. The check is similar in both cases with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag enabling an extra requirement for trustworthy modules to be regarded as trusted.</source>
          <target state="translated">检查模块是否受信任的过程取决于&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志是否存在。两种情况下的检查都类似，带有&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志，使对可信赖模块的额外要求被视为可信赖。</target>
        </trans-unit>
        <trans-unit id="ada084bff7147867e37d2b21221c961521d29596" translate="yes" xml:space="preserve">
          <source>The process has insufficient privileges to perform the operation.</source>
          <target state="translated">进程的权限不足,无法执行操作。</target>
        </trans-unit>
        <trans-unit id="58c80733d659717ab91216ecfc11c90f2165a6c0" translate="yes" xml:space="preserve">
          <source>The process is slightly complicated when the binding is polymorphic. We show the process by means of an example. To keep things simple, we will use the well known &lt;code&gt;map&lt;/code&gt; function:</source>
          <target state="translated">当绑定是多态的时，该过程会稍微复杂一些。我们通过一个例子来展示这个过程。为了简单起见，我们将使用众所周知的 &lt;code&gt;map&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="355fc82b6533b2538478ddb7b7f9868d90ea5c2a" translate="yes" xml:space="preserve">
          <source>The process signal mask</source>
          <target state="translated">过程信号掩码</target>
        </trans-unit>
        <trans-unit id="505d4ae162b670335f91963acc1d97b4cead190f" translate="yes" xml:space="preserve">
          <source>The profile data itself is described by the &lt;code&gt;profile&lt;/code&gt; field, which contains a tree-like object (which we&amp;rsquo;ll call a &amp;ldquo;cost-centre stack&amp;rdquo; here) with the following properties,</source>
          <target state="translated">配置文件数据本身由 &lt;code&gt;profile&lt;/code&gt; 字段描述，该字段包含具有以下属性的树状对象（在此我们将其称为&amp;ldquo;成本中心堆栈&amp;rdquo;），</target>
        </trans-unit>
        <trans-unit id="60512792acedb21616d84dd583523fdb5bfdbd7f" translate="yes" xml:space="preserve">
          <source>The profile tree itself</source>
          <target state="translated">简介树本身</target>
        </trans-unit>
        <trans-unit id="73c7e4bcf702d08f9fbe508aab53b3b722fac243" translate="yes" xml:space="preserve">
          <source>The program &lt;strong&gt;hp2ps&lt;/strong&gt; program converts a &lt;code&gt;.hp&lt;/code&gt; file produced by the &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; runtime option into a PostScript graph of the heap profile. By convention, the file to be processed by &lt;strong&gt;hp2ps&lt;/strong&gt; has a &lt;code&gt;.hp&lt;/code&gt; extension. The PostScript output is written to &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt;. If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; is omitted entirely, then the program behaves as a filter.</source>
          <target state="translated">程序&lt;strong&gt;hp2ps&lt;/strong&gt;程序将 &lt;code&gt;-h&amp;lt;break-down&amp;gt;&lt;/code&gt; 运行时选项生成的 &lt;code&gt;.hp&lt;/code&gt; 文件转换为堆配置文件的PostScript图形。按照惯例，被处理的文件&lt;strong&gt;hp2ps&lt;/strong&gt;有 &lt;code&gt;.hp&lt;/code&gt; 扩展。PostScript输出被写入 &lt;code&gt;&lt;em&gt;file&lt;/em&gt;@.ps&lt;/code&gt; @ .ps。如果 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 完全省略，则程序将充当过滤器。&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="146c7ee2b2dbd1e6430b6a92386c207342ed1810" translate="yes" xml:space="preserve">
          <source>The program text itself, the C stack, any non-heap data (e.g. data allocated by foreign libraries, and data allocated by the RTS), and &lt;code&gt;mmap()&lt;/code&gt;&amp;lsquo;d memory are not counted in the heap profile.</source>
          <target state="translated">程序文本本身，C堆栈，任何非堆数据（例如，由外部库分配的数据和由RTS分配的数据）以及 &lt;code&gt;mmap()&lt;/code&gt; 的内存都不会计入堆配置文件中。</target>
        </trans-unit>
        <trans-unit id="608f29767e628bc3908a6f9a3b5c8447d29874fc" translate="yes" xml:space="preserve">
          <source>The program's heap is reaching its limit, and the program should take action to reduce the amount of live data it has. Notes:</source>
          <target state="translated">程序的堆已达到极限,程序应采取措施减少其拥有的实时数据量。注意事项</target>
        </trans-unit>
        <trans-unit id="42403ff8e7d02a582ef311693ed3c81d360f6281" translate="yes" xml:space="preserve">
          <source>The programmer can specify rewrite rules as part of the source program (in a pragma). Here is an example:</source>
          <target state="translated">程序员可以指定重写规则作为源程序的一部分(在pragma中)。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="7913df84bb2ae3b02dcb56dbc5ad5cfcbd49b3ac" translate="yes" xml:space="preserve">
          <source>The pseudo-object file &lt;code&gt;A.o-boot&lt;/code&gt; is empty (don&amp;rsquo;t link it!), but it is very useful when using a Makefile, to record when the &lt;code&gt;A.hi-boot&lt;/code&gt; was last brought up to date (see &lt;a href=&quot;#using-make&quot;&gt;Using make&lt;/a&gt;).</source>
          <target state="translated">伪目标文件 &lt;code&gt;A.o-boot&lt;/code&gt; 是空的（请不要链接它！），但是在使用Makefile时，它非常有用，它可以记录 &lt;code&gt;A.hi-boot&lt;/code&gt; 的最新更新时间（请参阅&lt;a href=&quot;#using-make&quot;&gt;使用make&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="db524ce2791037ca05d5828a71f6846facf22e65" translate="yes" xml:space="preserve">
          <source>The public face of Template Haskell</source>
          <target state="translated">模板Haskell的公众形象</target>
        </trans-unit>
        <trans-unit id="23463757868e42fe8367dadcedc764a10dfe3e71" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; is to provide a common interface for I/O devices that can read and write data through a buffer. Devices that implement &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; include ordinary files, memory-mapped files, and bytestrings. The underlying device implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; must provide &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 的目的是为可以通过缓冲区读取和写入数据的I / O设备提供一个通用接口。实现 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 的设备包括普通文件，内存映射文件和字节串。实现 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的基础设备必须提供 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#t:BufferedIO&quot;&gt;BufferedIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd5d324fb68ef0a9578edac19d7cc075670db732" translate="yes" xml:space="preserve">
          <source>The purpose of the installed package ID is to detect problems caused by re-installing a package without also recompiling the packages that depend on it. Recompiling dependencies is necessary, because the newly compiled package may have a different ABI (Application Binary Interface) than the previous version, even if both packages were built from the same source code using the same compiler. With installed package IDs, a recompiled package will have a different installed package ID from the previous version, so packages that depended on the previous version are now orphaned - one of their dependencies is not satisfied. Packages that are broken in this way are shown in the &lt;code&gt;ghc-pkg list&lt;/code&gt; output either in red (if possible) or otherwise surrounded by braces. In the following example, we have recompiled and reinstalled the &lt;code&gt;filepath&lt;/code&gt; package, and this has caused various dependencies including &lt;code&gt;Cabal&lt;/code&gt; to break:</source>
          <target state="translated">已安装程序包ID的目的是检测由重新安装程序包引起的问题，而无需重新编译依赖于该程序包的程序包。重新编译依赖项是必要的，因为即使两个软件包都是使用相同的编译器从相同的源代码构建的，新编译的软件包可能具有与先前版本不同的ABI（应用程序二进制接口）。使用已安装的程序包ID，重新编译的程序包将具有与先前版本不同的已安装程序包ID，因此现在将孤立依赖于先前版本的程序包-不满足其依赖关系之一。 &lt;code&gt;ghc-pkg list&lt;/code&gt; 中显示了以此方式破坏的软件包输出为红色（如果可能）或用大括号包围。在以下示例中，我们重新编译并重新安装了 &lt;code&gt;filepath&lt;/code&gt; 软件包，这导致包括 &lt;code&gt;Cabal&lt;/code&gt; 在内的各种依赖关系中断：</target>
        </trans-unit>
        <trans-unit id="61845a19ad288b45ffb2fcd9525a2a7e4ba4eab7" translate="yes" xml:space="preserve">
          <source>The purpose of using builder primitives is to improve the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. These improvements stem from making the two most common steps performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; more efficient. We explain these two steps in turn.</source>
          <target state="translated">使用构建器原语的目的是提高 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的性能。这些改进源于使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行的两个最常见的步骤更加高效。我们依次解释这两个步骤。</target>
        </trans-unit>
        <trans-unit id="457568e28e80e66fe1efa03405736fd1dd831161" translate="yes" xml:space="preserve">
          <source>The quantification in &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s type signature is explicit. For example:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名中的量化是显式的。例如：</target>
        </trans-unit>
        <trans-unit id="b2a0aea25ac8727b745c955a5b510d60c52345ef" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</source>
          <target state="translated">引用的⟨string⟩可以是任意的,可以包含换行。</target>
        </trans-unit>
        <trans-unit id="349650fae25bef4c0203cca3a1569d66bff63fe6" translate="yes" xml:space="preserve">
          <source>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; instead), and make your quoter function interpret &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; as &lt;code&gt;&quot;|]&quot;&lt;/code&gt;. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;Issue #5348&lt;/a&gt; for details.</source>
          <target state="translated">带引号的&amp;ldquo;字符串&amp;rdquo;在两个字符序列 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 首次出现时结束。绝对不会执行转义。如果要在字符串中嵌入该字符序列，则必须发明自己的转义符（例如，使用字符串 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; ），并使引用程序函数将 &lt;code&gt;&quot;|~]&quot;&lt;/code&gt; 解释为 &lt;code&gt;&quot;|]&quot;&lt;/code&gt; 。一种实现此方法的方法是在报价程序中添加预处理通道，以执行转义转换。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5348&quot;&gt;问题＃5348中&lt;/a&gt;的讨论。</target>
        </trans-unit>
        <trans-unit id="767b19d5997c1561a35b16bb492c27dcece0b46f" translate="yes" xml:space="preserve">
          <source>The rationale for this more conservative strategy is given in &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;the papers&lt;/a&gt; &amp;ldquo;Let should not be generalised&amp;rdquo; and &amp;ldquo;Modular type inference with local assumptions&amp;rdquo;, and a related &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp-outsidein.pdf&quot;&gt;论文&lt;/a&gt; &amp;ldquo;不应该被概括&amp;rdquo;和&amp;ldquo;采用局部假设的模块化类型推论&amp;rdquo;以及相关&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7&quot;&gt;博客文章中&lt;/a&gt;给出了这种更为保守的策略的原理。</target>
        </trans-unit>
        <trans-unit id="849e06109e6633ff65fca6836e32e867a5ee49f7" translate="yes" xml:space="preserve">
          <source>The raw number of time &amp;ldquo;ticks&amp;rdquo; which were attributed to this cost-centre; from this, we get the &lt;code&gt;%time&lt;/code&gt; figure mentioned above.</source>
          <target state="translated">归因于此成本中心的时间&amp;ldquo;滴答声&amp;rdquo;的原始数量；由此，我们得到上面提到的 &lt;code&gt;%time&lt;/code&gt; 数字。</target>
        </trans-unit>
        <trans-unit id="075d071c18a7d6b84d43703f15e6485084ed0703" translate="yes" xml:space="preserve">
          <source>The reader monad transformer, which adds a read-only environment to the given monad.</source>
          <target state="translated">读者单体变换器,它为给定的单体添加一个只读环境。</target>
        </trans-unit>
        <trans-unit id="ecd219a50b8d392987e91be61182f89babccea17" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;gdb&lt;/code&gt; doesn&amp;rsquo;t show this symbol name in the backtrace output is an infidelity in its interpretation of debug information, which assumes an invariant preserved in C but not Haskell programs. Unfortunately it is necessary to work around this manually until this behivior is fixed upstream.</source>
          <target state="translated">&lt;code&gt;gdb&lt;/code&gt; 在回溯输出中未显示此符号名称的原因是其对调试信息的解释是不忠实的，它假定C中保留了不变式，但Haskell程序中并未保留。不幸的是，必须手动解决此问题，直到此行为被固定在上游。</target>
        </trans-unit>
        <trans-unit id="2b6817263ed46c0c59f4fb0e7df2a91e7de71d71" translate="yes" xml:space="preserve">
          <source>The reason for the latter restriction is that there is no way to check for instance matching. Consider</source>
          <target state="translated">后一种限制的原因是没有办法检查实例匹配。考虑到</target>
        </trans-unit>
        <trans-unit id="3292261ccecbbe56c864dbca83a9f104595c5227" translate="yes" xml:space="preserve">
          <source>The reason the call to &lt;code&gt;mergeQs&lt;/code&gt; is lazy is that it will be bottom for the last element in the queue, preventing us from evaluating the fully sorted sequence.</source>
          <target state="translated">对 &lt;code&gt;mergeQs&lt;/code&gt; 的调用之所以懒惰是因为它将在队列中的最后一个元素的底部，从而阻止我们评估完全排序的序列。</target>
        </trans-unit>
        <trans-unit id="edf4240fa18eff64428292cd48a993b1b77fd9cc" translate="yes" xml:space="preserve">
          <source>The reason there are two modes of checking trust is that the extra requirement enabled by &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; causes the design of Safe Haskell to be invasive. Packages using Safe Haskell when the flag is enabled may or may not compile depending on the state of trusted packages on a user&amp;rsquo;s machine. This is both fragile, and causes compilation failures for everyone, even if they aren&amp;rsquo;t trying to use any of the guarantees provided by Safe Haskell. Disabling &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; by default and turning it into a flag makes Safe Haskell an opt-in extension rather than an always on feature.</source>
          <target state="translated">存在两种检查信任方式的原因是&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;支持的额外要求导致Safe Haskell的设计具有侵入性。启用该标志时使用Safe Haskell的软件包可能会编译，也可能不会编译，具体取决于用户计算机上受信任软件包的状态。这既脆弱，又会导致每个人的编译失败，即使他们没有尝试使用Safe Haskell提供的任何保证也是如此。默认情况下禁用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;并将其转换为标志，可使Safe Haskell成为选择加入扩展而不是始终启用功能。</target>
        </trans-unit>
        <trans-unit id="159c99e34aff08a973c8421fe23cb3b0d5c07141" translate="yes" xml:space="preserve">
          <source>The rebindable operators must have the &amp;ldquo;Expected type&amp;rdquo; given in the table above. These types are surprisingly general. For example, you can use a bind operator with the type</source>
          <target state="translated">可重新绑定的运算符必须具有上表中给出的&amp;ldquo;期望类型&amp;rdquo;。这些类型令人惊讶地通用。例如，您可以将绑定运算符与类型</target>
        </trans-unit>
        <trans-unit id="109e20de090fa1c1b399a775d6b526e390949383" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="3b4b03fcea2b02b1be1981e46342fb710629897c" translate="yes" xml:space="preserve">
          <source>The recomended way to assemble lazy ByteStrings from smaller parts is to use the builder monoid from &lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder&lt;/a&gt;.</source>
          <target state="translated">从较小的部分组装惰性ByteString的推荐方法是使用&lt;a href=&quot;data-bytestring-builder&quot;&gt;Data.ByteString.Builder中&lt;/a&gt;的生成器monoid 。</target>
        </trans-unit>
        <trans-unit id="971c0f87b4ec7b2e7c3c7a4e19d1ae863981807b" translate="yes" xml:space="preserve">
          <source>The recommended chunk size. Currently set to 4k, less the memory management overhead</source>
          <target state="translated">推荐的分块大小。目前设置为4k,减去内存管理开销。</target>
        </trans-unit>
        <trans-unit id="16cfd92a1589e5e42d0809eabdbac78c22e8ab8a" translate="yes" xml:space="preserve">
          <source>The record field &lt;code&gt;f&lt;/code&gt; is in scope somehow (either qualified or unqualified).</source>
          <target state="translated">记录字段 &lt;code&gt;f&lt;/code&gt; 以某种方式在范围内（合格或不合格）。</target>
        </trans-unit>
        <trans-unit id="9f86b5036b23f14de358102557f9b2feb9bc01db" translate="yes" xml:space="preserve">
          <source>The recursive use of &lt;code&gt;T&lt;/code&gt; forced the second argument to have kind &lt;code&gt;Type&lt;/code&gt;. However, just as in type inference, you can achieve polymorphic recursion by giving a &lt;em&gt;complete user-supplied kind signature&lt;/em&gt; (or CUSK) for &lt;code&gt;T&lt;/code&gt;. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的递归使用迫使第二个参数具有 &lt;code&gt;Type&lt;/code&gt; 类型。但是，就像类型推断一样，您可以通过为 &lt;code&gt;T&lt;/code&gt; &lt;em&gt;提供完整的用户提供的种类签名&lt;/em&gt;（或CUSK）来实现多态递归。当所有参数类型和结果类型都已知时，无需进行推断就可以提出CUSK。例如：</target>
        </trans-unit>
        <trans-unit id="1d0b6b616ac33870a76db9dfeee72d989646c528" translate="yes" xml:space="preserve">
          <source>The references must be created on the caller process.</source>
          <target state="translated">这些引用必须在调用者进程中创建。</target>
        </trans-unit>
        <trans-unit id="cd1d9b57d9e1f2da5f01c8a0b23b6bcae81f914b" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;find-first-set operation&lt;/a&gt; can be expressed in terms of &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; as follows</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:countTrailingZeros&quot;&gt;countTrailingZeros&lt;/a&gt;&lt;/code&gt; 表示相关的&lt;a href=&quot;http://en.wikipedia.org/wiki/Find_first_set&quot;&gt;查找优先操作&lt;/a&gt;，如下所示</target>
        </trans-unit>
        <trans-unit id="564781d2dff109b716b0d2471e109284c4e81426" translate="yes" xml:space="preserve">
          <source>The rendering mode.</source>
          <target state="translated">渲染模式。</target>
        </trans-unit>
        <trans-unit id="7132980ad9037a15d16a77f68d4d766cf683fbea" translate="yes" xml:space="preserve">
          <source>The representation &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; is ever so slightly different from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. Let us look at &lt;code&gt;Tree&lt;/code&gt; as an example again:</source>
          <target state="translated">表示 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep1&quot;&gt;Rep1&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 稍有不同。让我们再次以 &lt;code&gt;Tree&lt;/code&gt; 为例：</target>
        </trans-unit>
        <trans-unit id="80113248ad71c5d6cf6ea8aa34e9ecf1815e1b9b" translate="yes" xml:space="preserve">
          <source>The representation of Typ is held abstract, permitting implementations to use a fancy representation (e.g., hash-consing to manage sharing). Without view patterns, using this signature is a little inconvenient:</source>
          <target state="translated">Typ的表示方式是举行抽象的,允许实现者使用花哨的表示方式(例如,用哈希凝聚来管理共享)。如果没有视图模式,使用这个签名有点不方便。</target>
        </trans-unit>
        <trans-unit id="ce09571bea4175cf0b61d56e33f52dd06fcf9579" translate="yes" xml:space="preserve">
          <source>The representation of a newline in the external file or stream.</source>
          <target state="translated">外部文件或流中换行的表示。</target>
        </trans-unit>
        <trans-unit id="7b7630e352dcb7bfcd09fc6c495339d580d997c4" translate="yes" xml:space="preserve">
          <source>The representation produced by GHC for conjuring up the kind of a &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由GHC产生的表示形式，用于表示 &lt;code&gt;&lt;a href=&quot;data-typeable#v:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 的种类。</target>
        </trans-unit>
        <trans-unit id="aa5cd6402de01324e41f0be34f809686f8aa3e73" translate="yes" xml:space="preserve">
          <source>The representation reuses &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; (and thereby &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;) as well as &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;. (This reusability is the reason that we carry around the dummy type argument for kind-&lt;code&gt;*&lt;/code&gt;-types, but there are already enough different names involved without duplicating each of these.)</source>
          <target state="translated">表示重用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; （从而 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; ），以及 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 。（这种可重用性是我们为kind- &lt;code&gt;*&lt;/code&gt; -types 携带伪类型参数的原因，但是已经包含足够多的不同名称，而无需重复其中的每个。）</target>
        </trans-unit>
        <trans-unit id="6718f5e7eb98e2ba45cb31a79fe17fb174159077" translate="yes" xml:space="preserve">
          <source>The representation used by this module is suitable for high performance use and for streaming large quantities of data. It provides a means to manipulate a large body of text without requiring that the entire content be resident in memory.</source>
          <target state="translated">该模块使用的表示方法适合于高性能的使用和大量数据的流式传输。它提供了一种操作大量文本的方法,而不要求将全部内容储存在内存中。</target>
        </trans-unit>
        <trans-unit id="26b7e0bcafa80352886c3f224d6fc81197b8c13d" translate="yes" xml:space="preserve">
          <source>The representations of the types &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt;, and the function &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; which is used by derived instances of &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; to construct &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">类型的表示 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; ，函数 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#v:mkTyCon&quot;&gt;mkTyCon&lt;/a&gt;&lt;/code&gt; 其中使用由衍生实例 &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 来构造 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="dfb69b0bd4ce1104852d70ba458a8bfd36b537ab" translate="yes" xml:space="preserve">
          <source>The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS option. After a rescheduling &quot;tick&quot; the running thread is pre-empted as soon as possible.</source>
          <target state="translated">默认情况下，重新计划计时器以20毫秒的粒度运行，但是可以使用 &lt;code&gt;-i&amp;lt;n&amp;gt;&lt;/code&gt; RTS选项更改此计时器。重新安排&amp;ldquo;滴答&amp;rdquo;之后，正在运行的线程将尽快被抢占。</target>
        </trans-unit>
        <trans-unit id="5ccf3c631aa004c7a4328462d6c6f7c7c056c904" translate="yes" xml:space="preserve">
          <source>The resolution of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;getCurrentTime&lt;/code&gt;, &lt;code&gt;getPOSIXTime&lt;/code&gt;</source>
          <target state="translated">的分辨率 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;getCurrentTime&lt;/code&gt; ， &lt;code&gt;getPOSIXTime&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a55460c2a715b4f949aab992e6307c6595c7ef" translate="yes" xml:space="preserve">
          <source>The rest of this section gives further details about GADT-style data type declarations.</source>
          <target state="translated">本节其余部分将进一步详细介绍GADT风格的数据类型声明。</target>
        </trans-unit>
        <trans-unit id="19d3d68095be8adb122dbb0abbee590b0795bdfa" translate="yes" xml:space="preserve">
          <source>The rest of this section outlines the extensions to GHC that support GADTs. The extension is enabled with &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt; extension also sets &lt;a href=&quot;#extension-GADTSyntax&quot;&gt;&lt;code&gt;GADTSyntax&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本节的其余部分概述了支持GADT的GHC扩展。扩展程序通过&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;启用。该&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;扩展还设置&lt;a href=&quot;#extension-GADTSyntax&quot;&gt; &lt;code&gt;GADTSyntax&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7fc3cff348af6d0057b280081d4e52f199855d1b" translate="yes" xml:space="preserve">
          <source>The restrictions on functional dependencies (&lt;a href=&quot;#functional-dependencies&quot;&gt;Functional dependencies&lt;/a&gt;) are particularly troublesome. It is tempting to introduce type variables in the context that do not appear in the head, something that is excluded by the normal rules. For example:</source>
          <target state="translated">对功能依赖项的限制（&lt;a href=&quot;#functional-dependencies&quot;&gt;功能依赖项&lt;/a&gt;）特别麻烦。引人注意的是在上下文中引入类型变量，这些变量不会出现在头部，这是常规规则所排除的。例如：</target>
        </trans-unit>
        <trans-unit id="fe30b8393929aa46afe3ba1601056b94f8b1e95e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e162d7d3e549dfb287c4d837722595657b805b3e" translate="yes" xml:space="preserve">
          <source>The result expression of the comprehension is the &lt;em&gt;last&lt;/em&gt; of the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt;s, and should be a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">修真的结果表达式是&lt;em&gt;最后&lt;/em&gt;的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Stmt&quot;&gt;Stmt&lt;/a&gt;&lt;/code&gt; s，而应该是一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NoBindS&quot;&gt;NoBindS&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="710e76d5addaf1f899275d53172aecc9354da03d" translate="yes" xml:space="preserve">
          <source>The result is that a hole or a variable will behave like &lt;code&gt;undefined&lt;/code&gt;, but with the added benefits that it shows a warning at compile time, and will show the same message if it gets evaluated at runtime. This behaviour follows that of the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; option, which implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt;.</source>
          <target state="translated">结果是，孔或变量的行为将类似于 &lt;code&gt;undefined&lt;/code&gt; ，但具有额外的好处，即它在编译时显示警告，并且在运行时求值时也会显示相同的消息。此行为遵循&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;选项的行为，该选项表示&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。请参见将&lt;a href=&quot;#defer-type-errors&quot;&gt;类型错误推迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f91260437a64c0bf7ba3f383cbdaa028dbaaf14c" translate="yes" xml:space="preserve">
          <source>The result kind annotation is optional and defaults to &lt;code&gt;Type&lt;/code&gt; (like argument kinds) if omitted. Polykinded type families can be declared using a parameter in the kind annotation:</source>
          <target state="translated">结果类型注释是可选的，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; （如参数类型）。可以使用种类注释中的参数声明多种类类型族：</target>
        </trans-unit>
        <trans-unit id="719264555b0951fe0a4d18be61f0d63372d62021" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e395cc90b3823d714718102043b3b6ff7d03845d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="e710dfc2405f9e2c8e759d75351536fb10cbd249" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的结果是在语法上正确的Haskell表达式，其中仅包含常量，并且在声明类型的那一刻使用了固定性声明。它仅包含在数据类型，括号和空格中定义的构造函数名称。使用带标签的构造函数字段时，还使用大括号，逗号，字段名称和等号。</target>
        </trans-unit>
        <trans-unit id="94b285ade7413e35c67b8f133c21227a5def2f92" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; as the final continuation.</source>
          <target state="translated">运行CPS计算的结果，并将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 作为最后的延续。</target>
        </trans-unit>
        <trans-unit id="2b871831fa284400865f590f83f36a493f64dd34" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6d14e5fbfa50ec1c145f7227bc08876962cef6e2" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with a given final continuation. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">以给定的最终连续性运行CPS计算的结果。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-cont#v:cont&quot;&gt;cont&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="fc8678bffd077c0bbb42fb756db0c09316a348b9" translate="yes" xml:space="preserve">
          <source>The result of running a CPS computation with the identity as the final continuation.</source>
          <target state="translated">以身份作为最后的延续,运行CPS计算的结果。</target>
        </trans-unit>
        <trans-unit id="7be0d32b03742647a7734d3d21c2b8a2fbadd5ac" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature &quot;ﬓ&quot; (men now, U+FB13) is case folded to the sequence &quot;մ&quot; (men, U+0574) followed by &quot;ն&quot; (now, U+0576), while the Greek &quot;&amp;micro;&quot; (micro sign, U+00B5) is case folded to &quot;&amp;mu;&quot; (small letter mu, U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能比输入字符串长，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，亚美尼亚语的小连字&amp;ldquo; ﬓ&amp;rdquo;（现在为U + FB13）被折叠为序列&amp;ldquo;մ&amp;rdquo;（男人，U + 0574），后跟&amp;ldquo;ն&amp;rdquo;（现在为U + 0576），而希腊文将&amp;ldquo; &amp;micro;&amp;rdquo;（微符号，U + 00B5）而不是其自身折叠为&amp;ldquo;&amp;mu;&amp;rdquo;（小写字母mu，U + 03BC）。</target>
        </trans-unit>
        <trans-unit id="f1f067d31c498d308c7527edc24e5abe084a8aef" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="b57c640dd113a5ef9f93ec6e9fa6c4901f3490dd" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string, and may differ from applying &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; to the input string. For instance, the Armenian small ligature men now (U+FB13) is case folded to the bigram men now (U+0574 U+0576), while the micro sign (U+00B5) is case folded to the Greek small letter letter mu (U+03BC) instead of itself.</source>
          <target state="translated">结果字符串可能长于输入字符串，并且可能与将 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:toLower&quot;&gt;toLower&lt;/a&gt;&lt;/code&gt; 应用于输入字符串不同。例如，现在将亚美尼亚小结扎字母（U + FB13）折叠到现在的双峰（U + 0574 U + 0576），而将微符号（U + 00B5）折叠到希腊小写字母mu （U + 03BC），而不是本身。</target>
        </trans-unit>
        <trans-unit id="d7d1ee7a53d61c5066bf7c6b99507274cf414cc2" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For example, the Latin small ligature ﬂ (U+FB02) is converted to the sequence Latin capital letter F (U+0046) followed by Latin small letter l (U+006C).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文小舌音符 &quot;U+FB02 &quot;被转换为拉丁文大写字母F(U+0046)和拉丁文小字母l(U+006C)的序列。</target>
        </trans-unit>
        <trans-unit id="cb6d1fe8a7f7ce6500d2e6aeea87ffd462ba9559" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, &quot;İ&quot; (Latin capital letter I with dot above, U+0130) maps to the sequence &quot;i&quot; (Latin small letter i, U+0069) followed by &quot; ̇&quot; (combining dot above, U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,&quot;İ&quot; (拉丁文大写字母I,上面有点,U+0130)映射到序列 &quot;i&quot;(拉丁文小写字母i,U+0069),后面是&quot;̇&quot; (以上结合点,U+0307)。</target>
        </trans-unit>
        <trans-unit id="59d5af9a9e862a6261e0531052f3b7332bd96132" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German &quot;&amp;szlig;&quot; (eszett, U+00DF) maps to the two-letter sequence &quot;SS&quot;.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如，德语&amp;ldquo;&amp;szlig;&amp;rdquo;（埃塞特，U + 00DF）映射到两个字母的序列&amp;ldquo; SS&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="187c0a7ad1ec133af85262cf2aefbee65363c294" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the German eszett (U+00DF) maps to the two-letter sequence SS.</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,德文eszett (U+00DF)映射到两个字母序列SS。</target>
        </trans-unit>
        <trans-unit id="3bcb0ada5949116a1ec956043ccada7f764943ad" translate="yes" xml:space="preserve">
          <source>The result string may be longer than the input string. For instance, the Latin capital letter I with dot above (U+0130) maps to the sequence Latin small letter i (U+0069) followed by combining dot above (U+0307).</source>
          <target state="translated">结果字符串可能比输入字符串长。例如,拉丁文大写字母I和上面的点(U+0130)映射到序列拉丁文小写字母i(U+0069),然后是上面的组合点(U+0307)。</target>
        </trans-unit>
        <trans-unit id="267f91be8361e6b486bf16241ee4a2ca1c72d153" translate="yes" xml:space="preserve">
          <source>The result type is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">结果类型是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="ff72841077011df112090a92ab49b6f760730161" translate="yes" xml:space="preserve">
          <source>The result type is not &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">结果类型不是 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bd69cf03243d72a4d327360fffc77c84f470ae1" translate="yes" xml:space="preserve">
          <source>The result type must also be unambiguous. Usually this can be inferred but when all the pattern synonyms in a group are polymorphic in the constructor the user must provide a type signature.</source>
          <target state="translated">结果类型也必须是明确的。通常这一点可以推断出来,但是当一个组中的所有模式同义词在构造函数中都是多态的时候,用户必须提供一个类型签名。</target>
        </trans-unit>
        <trans-unit id="e51fdef8c98fee655b68c4b681ce174c3c7038dc" translate="yes" xml:space="preserve">
          <source>The result type of each data constructor must begin with the type constructor being defined. If the result type of all constructors has the form &lt;code&gt;T a1 ... an&lt;/code&gt;, where &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables, then the data type is &lt;em&gt;ordinary&lt;/em&gt;; otherwise is a &lt;em&gt;generalised&lt;/em&gt; data type (&lt;a href=&quot;#gadt&quot;&gt;Generalised Algebraic Data Types (GADTs)&lt;/a&gt;).</source>
          <target state="translated">每个数据构造函数的结果类型必须从定义的类型构造函数开始。如果所有构造函数的结果类型均为 &lt;code&gt;T a1 ... an&lt;/code&gt; ，其中 &lt;code&gt;a1 ... an&lt;/code&gt; 是不同的类型变量，则数据类型为&lt;em&gt;普通&lt;/em&gt;；否则为&lt;em&gt;通用&lt;/em&gt;数据类型（&lt;a href=&quot;#gadt&quot;&gt;通用代数数据类型（GADT）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7542961c89b6c461de16b24fa92766645c70980" translate="yes" xml:space="preserve">
          <source>The result will be a (possibly) recursive set of bindings, binding only simple variables on the left hand side. (One could go one step further, as in the Haskell Report and make the recursive bindings non-recursive using &lt;code&gt;fix&lt;/code&gt;, but we do not do so in Core, and it only obfuscates matters, so we do not do so here.)</source>
          <target state="translated">结果将是一组（可能是）递归绑定，仅绑定左侧的简单变量。（可以像在Haskell报告中那样向前迈进一步，并使用 &lt;code&gt;fix&lt;/code&gt; 来使递归绑定成为非递归绑定，但是我们在Core中不这样做，并且它只会混淆问题，因此我们在这里不这样做。）</target>
        </trans-unit>
        <trans-unit id="87462ec88b42724161b7cc8f2f63b59ae8384ebd" translate="yes" xml:space="preserve">
          <source>The resulting block is not known to the GC until &lt;code&gt;compactFixupPointers#&lt;/code&gt; is called on it, and care must be taken so that the address does not escape or memory will be leaked.</source>
          <target state="translated">直到 &lt;code&gt;compactFixupPointers#&lt;/code&gt; ，GC才知道结果块，并且必须格外小心，以免地址逃脱或内存泄漏。</target>
        </trans-unit>
        <trans-unit id="44b0b01d6fc72a9ebc6e569ea7b7a4acf9c3f0f1" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d168a5662d111348c5652178bf35438b7d7e5d7d" translate="yes" xml:space="preserve">
          <source>The return codes and possible failures are the same as for &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">返回代码和可能的故障与 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c84126d5da79081acd0696fd7bf7e6755dd26714" translate="yes" xml:space="preserve">
          <source>The return value is either &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; (which should be &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt;, but Haskell's type system makes this hard).</source>
          <target state="translated">返回值为 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a)&lt;/code&gt; （应为 &lt;code&gt;(&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; ())&lt;/code&gt; ，但是Haskell的类型系统使此操作变得很困难）。</target>
        </trans-unit>
        <trans-unit id="0f6dd3e83915d6810f63269b6047123bac8e9627" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="de3f75faf8980c76bf0430052903fea92d219a50" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; depends on when the garbage collector runs, hence it is in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的返回值取决于垃圾收集器的运行时间，因此它位于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="c5bb2aac698e0ab4acfe10c33904a9c6ea7a4ffd" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;ghc-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;ghc-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5277d01d4cf93639a960e6c2b422210d104ab497" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; may return a different &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; after an object is evaluated.</source>
          <target state="translated">相反的情况不一定成立：如果两个稳定名称不相等，则它们命名的对象可能仍然相等。特别注意，在评估对象之后， &lt;code&gt;&lt;a href=&quot;system-mem-stablename#v:makeStableName&quot;&gt;makeStableName&lt;/a&gt;&lt;/code&gt; 可能返回不同的 &lt;code&gt;&lt;a href=&quot;system-mem-stablename#t:StableName&quot;&gt;StableName&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ee861d7191d03480270623b0c278f3e796515d5" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;control-monad#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="090562c4f4dc69d8f3d635e5732725c84ce56598" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">相反的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:when&quot;&gt;when&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4201a99f5e0cf83a88c84b37a22d265b4759a2" translate="yes" xml:space="preserve">
          <source>The rewrite is only performed by the compiler when it spots applications of &lt;code&gt;Control.Exception.assert&lt;/code&gt;, so you can still define and use your own versions of &lt;code&gt;assert&lt;/code&gt;, should you so wish. If not, import &lt;code&gt;Control.Exception&lt;/code&gt; to make use &lt;code&gt;assert&lt;/code&gt; in your code.</source>
          <target state="translated">仅当编译器发现 &lt;code&gt;Control.Exception.assert&lt;/code&gt; 应用程序时，才由重写器执行重写，因此，您仍然可以根据需要定义和使用自己的 &lt;code&gt;assert&lt;/code&gt; 版本。如果不是，请导入 &lt;code&gt;Control.Exception&lt;/code&gt; 以在代码中使用 &lt;code&gt;assert&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a203db3467cf5555838881627c38d194d3093046" translate="yes" xml:space="preserve">
          <source>The rule for record update is this:</source>
          <target state="translated">记录更新的规则是这样的。</target>
        </trans-unit>
        <trans-unit id="c2a3d9f840c6b0b6b05ca67275951ae59e8720e2" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d29e4936cf91ded40f7b191a687c4dd53e33e0f9" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; to force or handle exceptions in lazy values. If, on the other hand, you are forcing a lazy value for efficiency reasons only and do not care about exceptions, you may use &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="translated">经验法则是使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 来强制或处理惰性值中的异常。另一方面，如果您仅出于效率原因而强制采用惰性值，并且不关心异常，则可以使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31b88d72206b36249f66b725cc9bbead67a01dc" translate="yes" xml:space="preserve">
          <source>The rules are these:</source>
          <target state="translated">规则是这样的:</target>
        </trans-unit>
        <trans-unit id="cad458489bec4a53c044a1cc9e76951b0e492b13" translate="yes" xml:space="preserve">
          <source>The rules for export lists (Haskell Report &lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;Section 5.2&lt;/a&gt;) needs adjustment for type families:</source>
          <target state="translated">导出列表规则（Haskell报告&lt;a href=&quot;http://www.haskell.org/onlinereport/modules.html#sect5.2&quot;&gt;第5.2节&lt;/a&gt;）需要针对类型族进行调整：</target>
        </trans-unit>
        <trans-unit id="e971c3e68673f355040db3c25b4189ad831663fc" translate="yes" xml:space="preserve">
          <source>The rules for lexically-scoped type variables (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;) apply to pattern-synonym signatures. As those rules specify, only the type variables from an explicit, syntactically-visible outer &lt;code&gt;forall&lt;/code&gt; (the universals) scope over the definition of the pattern synonym; the existentials, bound by the inner forall, do not. For example</source>
          <target state="translated">词法范围的类型变量的规则（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法范围的类型变量&lt;/a&gt;）适用于模式同义词签名。如这些规则所指定的，只有模式显式同义词的定义中来自显式的，在语法上可见的 &lt;code&gt;forall&lt;/code&gt; （通用）范围内的类型变量；被内在的一切所束缚的存在不存在。例如</target>
        </trans-unit>
        <trans-unit id="fdf820a27fadf4bd22b75f1d8f664efea7b721ca" translate="yes" xml:space="preserve">
          <source>The rules for solving `Typeable` constraints are as follows:</source>
          <target state="translated">解决 &quot;类型化 &quot;约束的规则如下。</target>
        </trans-unit>
        <trans-unit id="f36a018d059c7c4d04382dae985b5d3771e4cf06" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6455d6be1aa6dc5e07209062c07959f5e933541f" translate="yes" xml:space="preserve">
          <source>The rules that hold for &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over a bounded type such as &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (see the section of the Haskell report dealing with arithmetic sequences) also hold for the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instances over the various &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; types defined here.</source>
          <target state="translated">适用于有限类型（例如 &lt;code&gt;&lt;a href=&quot;prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; )的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例的规则（请参见Haskell报告中涉及算术序列的部分）也适用于此处定义的各种 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="287275684f46fad5e60ea4e63f2b3989a859dcc8" translate="yes" xml:space="preserve">
          <source>The runtime manages a set of virtual processors, which we call &lt;em&gt;capabilities&lt;/em&gt;, the number of which is determined by the &lt;code&gt;-N&lt;/code&gt; option. Each capability can run one Haskell thread at a time, so the number of capabilities is equal to the number of Haskell threads that can run physically in parallel. A capability is animated by one or more OS threads; the runtime manages a pool of OS threads for each capability, so that if a Haskell thread makes a foreign call (see &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;) another OS thread can take over that capability.</source>
          <target state="translated">运行时管理一组虚拟处理器，我们称其为&lt;em&gt;功能&lt;/em&gt;，其数量由 &lt;code&gt;-N&lt;/code&gt; 选项确定。每个功能可以一次运行一个Haskell线程，因此功能的数量等于可以物理并行运行的Haskell线程的数量。功能由一个或多个OS线程激活；运行时会为每种功能管理一个OS线程池，因此，如果Haskell线程进行外部调用（请参阅&lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;多线程和FFI&lt;/a&gt;），则另一个OS线程可以接管该功能。</target>
        </trans-unit>
        <trans-unit id="0bf54255cb34f158e27d2a0117da364ec1bb6e6e" translate="yes" xml:space="preserve">
          <source>The runtime will run a Haskell thread using any of the available worker OS threads. If you need control over which particular OS thread is used to run a given Haskell thread, perhaps because you need to call a foreign library that uses OS-thread-local state, then you need bound threads (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">运行时将使用任何可用的工作程序OS线程运行Haskell线程。如果您需要控制使用哪个特定的OS线程来运行给定的Haskell线程，也许是因为您需要调用使用OS-thread-local状态的外部库，那么就需要绑定线程（请参见&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d9bdd79c3248e72d8f8184d783c66c7199f4ffdb" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v2&lt;/code&gt;, except that in addition the full command line (if appropriate) for each compilation phase is also printed.</source>
          <target state="translated">与 &lt;code&gt;-v2&lt;/code&gt; 相同，除了另外还会打印每个编译阶段的完整命令行（如果适用）。</target>
        </trans-unit>
        <trans-unit id="7a04f812bf453bed7d5a0caca4f5add0ec2c5d47" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;-v3&lt;/code&gt; except that the intermediate program representation after each compilation phase is also printed (excluding preprocessed and C/assembly files).</source>
          <target state="translated">与 &lt;code&gt;-v3&lt;/code&gt; 相同，除了在每个编译阶段之后还会打印中间程序表示形式（不包括预处理和C /汇编文件）。</target>
        </trans-unit>
        <trans-unit id="a2f32cc087f14553948fee64bcdc2ba34e644d9e" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="8625552121606097b2d5857951839ce9043083ac" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt;, but for non-IO computations. Used for wrapping &lt;code&gt;foreign export&lt;/code&gt; and &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; when these are used to export Haskell functions with non-IO types.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-tophandler#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 相同，但用于非IO计算。当它们用于导出具有非IO类型的Haskell函数时，用于包装 &lt;code&gt;foreign export&lt;/code&gt; 和 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0648b1616676c9114b65de58cfeaaf5383529541" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;prelude#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="9e5b130c850d3ae23a8be04b3fa2ce4fa7fa0fb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="aa026dba543148cd2b273f964a160b184bdfeb30" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; 相同，但是添加了换行符。</target>
        </trans-unit>
        <trans-unit id="b8d8ca41d6eb5a3c9f60bb5bd1f3f55e1d6d7bbc" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt;, but adds a newline character.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-io#v:putStr&quot;&gt;putStr&lt;/a&gt;&lt;/code&gt; 相同，但添加换行符。</target>
        </trans-unit>
        <trans-unit id="6843b9b5a417fec3fae3876bec15b17db894f832" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;register&lt;/code&gt;, except that if a package of the same name is already installed, it is replaced by the new one.</source>
          <target state="translated">与 &lt;code&gt;register&lt;/code&gt; 相同，除了如果已安装相同名称的软件包，将其替换为新的软件包。</target>
        </trans-unit>
        <trans-unit id="4eb269dc2a06d69045a2a36c859373422e12ad50" translate="yes" xml:space="preserve">
          <source>The same as a regular Haskell pair, but</source>
          <target state="translated">和普通的Haskell对一样,但却是</target>
        </trans-unit>
        <trans-unit id="4f89735e4671a45444902a2195c78bc1da818092" translate="yes" xml:space="preserve">
          <source>The same behaviour for &amp;ldquo;&lt;code&gt;Variable out of scope&lt;/code&gt;&amp;rdquo; errors, it terminates compilation by default. You can defer such errors by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by out of scope variables until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于&amp;ldquo; &lt;code&gt;Variable out of scope&lt;/code&gt; &amp;rdquo;错误，其行为相同，默认情况下会终止编译。您可以使用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志来推迟此类错误。该标志将超出范围的变量产生的错误推迟到运行时，并将它们转换为编译时警告。反过来，这些警告可以完全由&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wno-deferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;抑制。</target>
        </trans-unit>
        <trans-unit id="8543dc86d96439208628a8b1d7af30e1ee08694f" translate="yes" xml:space="preserve">
          <source>The same flag is necessary even if we compiled the modules from source, because GHC still reckons it&amp;rsquo;s in batch mode:</source>
          <target state="translated">即使我们从源代码编译模块，也需要相同的标志，因为GHC仍认为它处于批处理模式：</target>
        </trans-unit>
        <trans-unit id="ba3027bbf0fcb7bae35aa9ca1f45ea5074c50762" translate="yes" xml:space="preserve">
          <source>The same functor, but with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances that process the elements in the reverse order.</source>
          <target state="translated">相同的函子，但具有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和可 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例，这些实例以相反的顺序处理元素。</target>
        </trans-unit>
        <trans-unit id="1c1f71fccfe0e9e481708999ce54008fd68d4d10" translate="yes" xml:space="preserve">
          <source>The same functor, but with an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; instance that performs actions in the reverse order.</source>
          <target state="translated">相同的函子，但具有以相反顺序执行操作的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="c9c5f788326fc36e1f3b48e98542218be99c253c" translate="yes" xml:space="preserve">
          <source>The same information is summarised here:</source>
          <target state="translated">同样的信息在此汇总。</target>
        </trans-unit>
        <trans-unit id="ce5a33c04c63ab14da95d7e82ff9a7fdffb21817" translate="yes" xml:space="preserve">
          <source>The same phase-numbering control is available for &lt;code&gt;RULE&lt;/code&gt;s (&lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;).</source>
          <target state="translated">相同的相位编号控件可用于 &lt;code&gt;RULE&lt;/code&gt; （&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d09ef3d38a83d48d1f4c76f8672633a3afd70db" translate="yes" xml:space="preserve">
          <source>The same refined dependency analysis also allows the type signatures of mutually-recursive functions to have different contexts, something that is illegal in Haskell 98 (Section 4.5.2, last sentence). GHC only insists that the type signatures of a &lt;em&gt;refined&lt;/em&gt; group have identical type signatures; in practice this means that only variables bound by the same pattern binding must have the same context. For example, this is fine:</source>
          <target state="translated">相同的精细依赖关系分析还允许相互递归函数的类型签名具有不同的上下文，这在Haskell 98中是非法的（第4.5.2节，最后一句话）。GHC仅坚持要求&lt;em&gt;精制&lt;/em&gt;组的类型签名具有相同的类型签名；实际上，这意味着仅由相同模式绑定绑定的变量必须具有相同的上下文。例如，这很好：</target>
        </trans-unit>
        <trans-unit id="8a7f218302834b3d894808ca735f7557a9dbe8d2" translate="yes" xml:space="preserve">
          <source>The same restrictions apply to instances generated by &lt;code&gt;deriving&lt;/code&gt; clauses. Thus the following is accepted:</source>
          <target state="translated">相同的限制适用于 &lt;code&gt;deriving&lt;/code&gt; 子句生成的实例。因此，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="9c526491ec37b7cc0b42d99e653f9e9274cc77d9" translate="yes" xml:space="preserve">
          <source>The scenario here is much like in &lt;a href=&quot;#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</source>
          <target state="translated">这里的场景与&lt;a href=&quot;#using-own-main&quot;&gt;使用您自己的main（）中&lt;/a&gt;的场景非常相似，除了目标不是链接完整的程序，而是从Haskell代码中创建一个库，该库可以按照与部署C库相同的方式进行部署码。</target>
        </trans-unit>
        <trans-unit id="a7be4622eea3de88ed1a96151065af1cf68b5eb8" translate="yes" xml:space="preserve">
          <source>The search path by default contains a single directory: &amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo; (i.e. the current directory). The following options can be used to add to or change the contents of the search path:</source>
          <target state="translated">默认情况下，搜索路径包含一个目录：&amp;ldquo;&amp;rdquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;（即当前目录）。以下选项可用于添加或更改搜索路径的内容：</target>
        </trans-unit>
        <trans-unit id="8249f40a7c74a660887a3e9aa4b80efa30b048ab" translate="yes" xml:space="preserve">
          <source>The search path for finding source files is specified with the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option on the GHCi command line, like so:</source>
          <target state="translated">查找源文件的搜索路径是通过GHCi命令行上的&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项指定的，如下所示：</target>
        </trans-unit>
        <trans-unit id="097279f54de9a88bc11286150e5f678f203fd020" translate="yes" xml:space="preserve">
          <source>The second argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters. Note: if the second argument is an absolute path, it will just return the second argument.</source>
          <target state="translated">第二个参数通常是应用程序的名称。因为它将被整合到路径中,所以它必须由有效的路径字符组成。注意:如果第二个参数是绝对路径,它将只返回第二个参数。</target>
        </trans-unit>
        <trans-unit id="c8c52aa6b540d63fbb2366f65727bf3d9dc7ec2c" translate="yes" xml:space="preserve">
          <source>The second clause is a little more interesting. It says that two overlapping type family instances are allowed if the right-hand sides coincide in the region of overlap. Some examples help here:</source>
          <target state="translated">第二个子句比较有趣。它说,如果右手边在重叠区域内重合,则允许两个重叠的类型族实例。一些例子在这里有帮助。</target>
        </trans-unit>
        <trans-unit id="1b82bdc74d0800be180d02d7bcd708e9c96094a1" translate="yes" xml:space="preserve">
          <source>The second constructor consists of two fields. Each is a recursive field of type &lt;code&gt;Tree a&lt;/code&gt;, represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt;. Representations of individual fields are combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">第二个构造函数由两个字段组成。每个字段都是 &lt;code&gt;Tree a&lt;/code&gt; 类型的递归字段，表示为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; (Tree a)&lt;/code&gt; 。使用二进制类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; 组合各个字段的表示形式。</target>
        </trans-unit>
        <trans-unit id="69067e45a2d5620e94c67c0a1174c1c5e40697f6" translate="yes" xml:space="preserve">
          <source>The second most common step performed by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is to fill a buffer using a bounded primitives, which works as follows. The &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; checks whether there is enough space left to execute the bounded primitive. If there is, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; executes the bounded primitive and calls the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; with the updated buffer. Otherwise, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; signals its driver that it requires a new buffer. This buffer must be at least as large as the bound of the primitive. We can use bounded primitives to reduce the number of buffer-free checks by fusing the buffer-free checks of consecutive &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. We can also use bounded primitives to simplify the control flow for signalling that a buffer is full by ensuring that we check first that there is enough space left and only then decide on how to encode a given value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行的第二个最常见的步骤是使用有界图元填充缓冲区，其工作方式如下。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 检查是否有留下来执行有限的原始足够的空间。如果存在，那么 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 将执行有界原语并使用更新的缓冲区调用下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 器会向其驱动程序发出信号，告知它需要新的缓冲区。该缓冲区必须至少与图元的边界一样大。我们可以使用有界原语通过融合连续 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的无缓冲区检查来减少无缓冲区检查的次数s。通过确保首先检查是否还有足够的空间，然后再决定如何编码给定值，我们还可以使用有界原语来简化表示缓冲区已满的信号的控制流程。</target>
        </trans-unit>
        <trans-unit id="e3adff620b84d87073094a0d1e40cfb431f3fc23" translate="yes" xml:space="preserve">
          <source>The second of those cases, in which a type is unequal to the type parameter but does contain the type parameter, can be surprisingly tricky. For example, the following example compiles:</source>
          <target state="translated">其中第二种情况,即一个类型与类型参数不等,但确实包含类型参数,这可能是令人惊讶的棘手问题。例如,下面的例子可以编译。</target>
        </trans-unit>
        <trans-unit id="9eb91d87bd37f6664f6bb87879f2252a0136d8dd" translate="yes" xml:space="preserve">
          <source>The second option is to add the flag &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There&amp;rsquo;s no need to compile the code twice, just add &lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</source>
          <target state="translated">第二个选项是添加标志&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程&lt;/a&gt;中运行解释器），该标志在单独的进程中运行解释器，在该进程中，它可以直接加载和运行配置文件的代码。无需两次编译代码，只需添加&lt;a href=&quot;ghci#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;即可。（此选项在GHC 8.0.x中是实验性的，但在将来的版本中可能会成为默认选项）。</target>
        </trans-unit>
        <trans-unit id="1fe592ef22fd84069dc46f6e28d2597f0796d538" translate="yes" xml:space="preserve">
          <source>The second part of the file is a break-down by cost centre of the most costly functions in the program. In this case, there was only one significant function in the program, namely &lt;code&gt;fib&lt;/code&gt;, and it was responsible for 100% of both the time and allocation costs of the program.</source>
          <target state="translated">文件的第二部分是按成本中心划分的程序中最昂贵的功能。在这种情况下，程序中只有一个重要功能，即 &lt;code&gt;fib&lt;/code&gt; ，它负责程序的时间和分配成本的100％。</target>
        </trans-unit>
        <trans-unit id="b8df1be0cd5e2537cf6f141763056fb7615154f3" translate="yes" xml:space="preserve">
          <source>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (&lt;a href=&quot;#inferring-variable-order&quot;&gt;Inferring the order of variables in a type/class declaration&lt;/a&gt;).</source>
          <target state="translated">本手册中有关种类多态性的部分介绍了如何对类型和类声明中&lt;a href=&quot;#inferring-variable-order&quot;&gt;的变量&lt;/a&gt;进行排序（推断类型/类声明中的变量顺序）。</target>
        </trans-unit>
        <trans-unit id="688179792a83dd0d7ac02a615c37eb7cae624b2d" translate="yes" xml:space="preserve">
          <source>The selector function to apply to the environment.</source>
          <target state="translated">适用于环境的选择器功能。</target>
        </trans-unit>
        <trans-unit id="ab7e699fcd26948a260d7ff833362f9c40e09439" translate="yes" xml:space="preserve">
          <source>The selector's strictness annotation (if any)</source>
          <target state="translated">选择器的严格性注释(如有)。</target>
        </trans-unit>
        <trans-unit id="bbaa3124e273f9bbeae5e4b775012fe09975055e" translate="yes" xml:space="preserve">
          <source>The selector's unpackedness annotation (if any)</source>
          <target state="translated">选择器的解包性注释(如果有的话</target>
        </trans-unit>
        <trans-unit id="66f2ee62244d552545951793286b38aaf65937a4" translate="yes" xml:space="preserve">
          <source>The semantics in this case is that the set of required entities is defined exclusively by its exports; if an entity is not mentioned in the export list, it is not required. The motivation behind this feature is to allow a library author to provide an omnibus signature containing the type of every function someone might want to use, while a client thins down the exports to the ones they actually require. For example, supposing that you have inherited a signature for strings, you might write a local signature of this form, listing only the entities that you need:</source>
          <target state="translated">这种情况下的语义是,所需实体的集合只由其导出项来定义;如果导出项列表中没有提到某个实体,它就不是必需的。这个特性背后的动机是允许库作者提供一个总括签名,其中包含了别人可能想要使用的每个函数的类型,而客户则将导出的函数缩减到他们实际需要的函数。例如,假设你继承了一个字符串的签名,你可以写一个这种形式的本地签名,只列出你需要的实体。</target>
        </trans-unit>
        <trans-unit id="56586055c1a973adf6bc976c7f0c5948635e349a" translate="yes" xml:space="preserve">
          <source>The semantics of &lt;code&gt;rec&lt;/code&gt; is fairly straightforward. Whenever GHC finds a &lt;code&gt;rec&lt;/code&gt; group, it will compute its set of bound variables, and will introduce an appropriate call to the underlying monadic value-recursion operator &lt;code&gt;mfix&lt;/code&gt;, belonging to the &lt;code&gt;MonadFix&lt;/code&gt; class. Here is an example:</source>
          <target state="translated">&lt;code&gt;rec&lt;/code&gt; 的语义非常简单。只要GHC找到一个 &lt;code&gt;rec&lt;/code&gt; 组，它将计算其绑定变量集，并将对 &lt;code&gt;MonadFix&lt;/code&gt; 类的基础 &lt;code&gt;mfix&lt;/code&gt; 值递归运算符mfix进行适当的调用。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="b6ee2b36fc137b76acfc45249fe3e6a495362536" translate="yes" xml:space="preserve">
          <source>The semantics of Haskell pattern matching is described in &lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;Section 3.17.2&lt;/a&gt; of the Haskell Report. To this description add one extra item 10, saying:</source>
          <target state="translated">Haskell模式匹配的语义在Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/exps.html#sect3.17.2&quot;&gt;3.17.2节中&lt;/a&gt;进行了描述。在此描述中添加一个额外的项目10，说：</target>
        </trans-unit>
        <trans-unit id="6864c1eb13210b08463d051de2f706ed1978f9af" translate="yes" xml:space="preserve">
          <source>The semantics of a pattern &lt;code&gt;(&lt;/code&gt; ⟨exp⟩ &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; are as follows:</source>
          <target state="translated">模式 &lt;code&gt;(&lt;/code&gt; ⟨exp⟨- &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨pat⟩ &lt;code&gt;)&lt;/code&gt; 的语义如下：</target>
        </trans-unit>
        <trans-unit id="a49b20375791de9003bfc8d14ce130dc3774a912" translate="yes" xml:space="preserve">
          <source>The server-side Template Haskell state. This is created by the StartTH message. A new one is created per module that GHC typechecks.</source>
          <target state="translated">服务器端模板 Haskell 状态。这是由StartTH消息创建的。每个GHC类型检查的模块都会创建一个新的状态。</target>
        </trans-unit>
        <trans-unit id="880e48518d2af8b17f9fbbf6826532563177f0bb" translate="yes" xml:space="preserve">
          <source>The set of keys used for locating static pointers in the Static Pointer Table is not guaranteed to remain stable for different program binaries. Or in other words, only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">静态指针表中用于定位静态指针的键集不能保证在不同的程序二进制中保持稳定。或者换句话说,只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="dce2b77db6ba22442abb84bf3fa8f872ca37ee0c" translate="yes" xml:space="preserve">
          <source>The set of known encodings is system-dependent, but includes at least:</source>
          <target state="translated">已知的编码集取决于系统,但至少包括:</target>
        </trans-unit>
        <trans-unit id="ed757898094aff99841d9541019b43be5923bde9" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;in scope&lt;/em&gt; at the prompt. This set is modified by &lt;code&gt;import&lt;/code&gt; and &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt;, and it is also modified automatically after &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, as described above. The set of modules in scope can be shown with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">提示符下当前&lt;em&gt;作用域内&lt;/em&gt;的模块集。如上所述，此集合由 &lt;code&gt;import&lt;/code&gt; 和&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;修改，并且也会在&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;之后自动修改。范围内的模块集可以用&lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51b1bf1f03c7acf30bf735e70b82dfebbaab8737" translate="yes" xml:space="preserve">
          <source>The set of modules that are currently &lt;em&gt;loaded&lt;/em&gt;. This set is modified by &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:add&quot;&gt;&lt;code&gt;:add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt;, and can be shown with &lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt;&lt;code&gt;:show modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当前正在&lt;em&gt;加载&lt;/em&gt;的模块集。该集合由&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:add&quot;&gt; &lt;code&gt;:add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; 修改&lt;/a&gt;，并可以与&lt;a href=&quot;#ghci-cmd-:show%20modules&quot;&gt; &lt;code&gt;:show modules&lt;/code&gt; &lt;/a&gt;一起显示。</target>
        </trans-unit>
        <trans-unit id="4532383c79df86a71369071f6d14da2f5e99ce9c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="e35ac63dcda6789b67e6cd555f46f1f50139eee5" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="78c75f7b1cf88eb962a211ac91c885339428b11f" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is necessary because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; has height 1, while &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; has no height.</source>
          <target state="translated">最后一条定律的附带条件是必要的，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt; &quot;&quot;&lt;/code&gt; 高度为1，而 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 高度为1 。</target>
        </trans-unit>
        <trans-unit id="7a38da53d66a8da2924f4490445d6a8597e51f56" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="1b01edfa1c723af20aa00f5a449572814388533c" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="d2031546b63b6ae221df9dd4d7437db7bf7d7abf" translate="yes" xml:space="preserve">
          <source>The side condition on the last law is needed because &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is a left identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">需要最后一条定律的附带条件，因为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; 的左标识。</target>
        </trans-unit>
        <trans-unit id="0a539d9419888c0404d1209818ed699951d45c48" translate="yes" xml:space="preserve">
          <source>The signature gives a type for a function binding or a bare variable binding, not a pattern binding. For example:</source>
          <target state="translated">签名给出的是函数绑定或裸变量绑定的类型,而不是模式绑定。例如:</target>
        </trans-unit>
        <trans-unit id="ff30f1e0ca7431f3c51b29f5935841acd7e3621c" translate="yes" xml:space="preserve">
          <source>The simplest interface to run a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; decoder. If the decoder runs into an error, calls &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt;, or runs out of input, it will call &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 解码器的最简单的接口。如果解码器遇到错误，调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或输入用完，它将调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4171317271f9701924c5612cace202985932b94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt; :: &lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="60d63bdb6773052d3664fc612f9f7c5d02a759c0" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="3cdb54d22332866769de89f6af0995d2941f5088" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, the behaviour of the sequence is undefined. This is unlikely to occur in most applications, but some care may be required when using &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, particularly repeatedly and particularly in combination with &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的大小不得超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，并且如果超出大小限制，则序列的行为不确定。这是不太可能在大多数应用中发生，但可能需要一些护理使用时 &lt;code&gt;&lt;a href=&quot;data-sequence#v:-62--60-&quot;&gt;&amp;gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-42--62-&quot;&gt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62-&quot;&gt;&amp;gt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ，特别是重复且特别是与组合 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-sequence#v:fromFunction&quot;&gt;fromFunction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68b39ad023d3f11bcc8409b018ab8336d3bbbfec" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。</target>
        </trans-unit>
        <trans-unit id="639cfdba7720e86e3a5a012ef353f96a357f6789" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the associated values will be combined using &lt;code&gt;c&lt;/code&gt;. The value at the greater of the two original keys is used as the first argument to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将使用 &lt;code&gt;c&lt;/code&gt; 组合关联的值。两个原始键中较大者的值用作 &lt;code&gt;c&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="048cc6a4527ae04b4d309fa4f47c7a471d6d47b2" translate="yes" xml:space="preserve">
          <source>The size of the result may be smaller if &lt;code&gt;f&lt;/code&gt; maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained.</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 将两个或更多不同的键映射到同一新键，则结果的大小可能会更小。在这种情况下，将保留原始键最大的值。</target>
        </trans-unit>
        <trans-unit id="60b72fd8bb3e5f4a06fde0ee0bf443bff7e4e932" translate="yes" xml:space="preserve">
          <source>The size of the sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 生成的字节序列的大小。</target>
        </trans-unit>
        <trans-unit id="ea5ea3bbb55b918ed6ea55188cf64e0d86600e17" translate="yes" xml:space="preserve">
          <source>The size of the set must not exceed &lt;code&gt;maxBound::Int&lt;/code&gt;. Violation of this condition is not detected and if the size limit is exceeded, its behaviour is undefined.</source>
          <target state="translated">集合的大小不能超过 &lt;code&gt;maxBound::Int&lt;/code&gt; 。未检测到违反此条件的情况，如果超出大小限制，则其行为不确定。</target>
        </trans-unit>
        <trans-unit id="fb09dc2a9c4d162d88ca14ed072d0aed53b01f64" translate="yes" xml:space="preserve">
          <source>The size of the subrange defined by a bounding pair.</source>
          <target state="translated">一个边界对所定义的子范围的大小。</target>
        </trans-unit>
        <trans-unit id="d626e1e8a07f4e02db6c2c2e1323369febdb90fc" translate="yes" xml:space="preserve">
          <source>The sized integral datatypes, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">已调整大小的整数数据类型 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int8&quot;&gt;Int8&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int16&quot;&gt;Int16&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int32&quot;&gt;Int32&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-int#t:Int64&quot;&gt;Int64&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34be630267a2f34532e3f61be86bde91aa72b2" translate="yes" xml:space="preserve">
          <source>The sledgehammer you can bring to bear is the &lt;code&gt;INLINE&lt;/code&gt; pragma, used thusly:</source>
          <target state="translated">您可以使用的大锤是 &lt;code&gt;INLINE&lt;/code&gt; 编译指示，因此使用：</target>
        </trans-unit>
        <trans-unit id="0cda2a4753e71bf4b99293af09e40ba00c0db06e" translate="yes" xml:space="preserve">
          <source>The solution is to define the instance-specific function yourself, with a pragma to prevent it being inlined too early, and give a RULE for it:</source>
          <target state="translated">解决办法是自己定义实例专用函数,用pragma防止过早内联,并给它一个rule。</target>
        </trans-unit>
        <trans-unit id="a143118fd55bf0e45fde2c00d4308bb63967230b" translate="yes" xml:space="preserve">
          <source>The source files for the program don&amp;rsquo;t all need to be in the same directory; the &lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt;&lt;code&gt;-i&lt;/code&gt;&lt;/a&gt; option can be used to add directories to the search path (see &lt;a href=&quot;separate_compilation#search-path&quot;&gt;The search path&lt;/a&gt;).</source>
          <target state="translated">该程序的源文件并不需要全部都在同一目录中。在&lt;a href=&quot;separate_compilation#ghc-flag--i&quot;&gt; &lt;code&gt;-i&lt;/code&gt; &lt;/a&gt;选项可以用来将目录添加到搜索路径（见&lt;a href=&quot;separate_compilation#search-path&quot;&gt;的搜索路径&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7242f5a8794ecd7a9adc72221dcd6d3bf9cd57f6" translate="yes" xml:space="preserve">
          <source>The source location</source>
          <target state="translated">来源地</target>
        </trans-unit>
        <trans-unit id="bff14f9be362d2c46b6dfec1a6f40516c9ee7a4d" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard data declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准数据声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="3b7b5cbf731a1d6d5a127ef030fdc4cd00939e17" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;family&lt;/code&gt; distinguishes family from standard type declarations. The result kind annotation is optional and, as usual, defaults to &lt;code&gt;Type&lt;/code&gt; if omitted. An example is</source>
          <target state="translated">特殊 &lt;code&gt;family&lt;/code&gt; 将族与标准类型声明区分开来。结果类型批注是可选的，并且与往常一样，如果省略，则默认为 &lt;code&gt;Type&lt;/code&gt; 。一个例子是</target>
        </trans-unit>
        <trans-unit id="952b7f739ae18492bdd3551b26083ef12a4de0fd" translate="yes" xml:space="preserve">
          <source>The special package name &lt;code&gt;this&lt;/code&gt; can be used to refer to the current package being built.</source>
          <target state="translated">专门的软件包名称 &lt;code&gt;this&lt;/code&gt; 可以用来指代当前包在建。</target>
        </trans-unit>
        <trans-unit id="f6fec8a577698b9ef729ece863f1fe5c0db5311e" translate="yes" xml:space="preserve">
          <source>The specification ends with a format character:</source>
          <target state="translated">该规范以格式字符结束。</target>
        </trans-unit>
        <trans-unit id="e0644f44c0a9f69e8ff30c1b7ba3cca8f1d8012c" translate="yes" xml:space="preserve">
          <source>The specified file gets included into the C program, the compiled Haskell file, and the C header. &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; is included automatically.</source>
          <target state="translated">指定的文件包含在C程序，已编译的Haskell文件和C标头中。 &lt;code&gt;&amp;lt;HsFFI.h&amp;gt;&lt;/code&gt; 是自动包含的。</target>
        </trans-unit>
        <trans-unit id="761a2c36ed9e89b5d391f9fcda8b027fe4d8b2e1" translate="yes" xml:space="preserve">
          <source>The specifiers for &lt;code&gt;DiffTime&lt;/code&gt;, &lt;code&gt;NominalDiffTime&lt;/code&gt;, &lt;code&gt;CalendarDiffDays&lt;/code&gt;, and &lt;code&gt;CalendarDiffTime&lt;/code&gt; are semantically separate from the other types. Specifiers on negative time differences will generally be negative (think &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;DiffTime&lt;/code&gt; ， &lt;code&gt;NominalDiffTime&lt;/code&gt; ， &lt;code&gt;CalendarDiffDays&lt;/code&gt; 和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; 的说明符在语义上与其他类型分开。负时差的说明 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 通常为负（认为rem而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ea0203e7d159675d01a82f8d0629d8fedd3302a1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah1)&lt;/code&gt; cannot refer to the function &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; is part of a later declaration group, and thus invisible, similarly, &lt;code&gt;$(blah1)&lt;/code&gt; cannot see the definition of &lt;code&gt;h&lt;/code&gt; (since it is part of the same declaration group as &lt;code&gt;$(blah1)&lt;/code&gt;. However, the splice &lt;code&gt;$(blah1)&lt;/code&gt; can see the definition of &lt;code&gt;f&lt;/code&gt; (since it is in the immediately preceding declaration group).</source>
          <target state="translated">接头 &lt;code&gt;$(blah1)&lt;/code&gt; 无法引用函数 &lt;code&gt;w&lt;/code&gt; - &lt;code&gt;w&lt;/code&gt; 是后面的声明组的一部分，因此是不可见的，类似地， &lt;code&gt;$(blah1)&lt;/code&gt; 也看不到 &lt;code&gt;h&lt;/code&gt; 的定义（因为它与 &lt;code&gt;$(blah1)&lt;/code&gt; 是同一声明组的一部分）（blah1）。但是，拼接 &lt;code&gt;$(blah1)&lt;/code&gt; 可以看到 &lt;code&gt;f&lt;/code&gt; 的定义（因为它在紧接的声明组中）。</target>
        </trans-unit>
        <trans-unit id="aff3f00779b326bffbfbc12657deeca9ca823bb1" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(blah2)&lt;/code&gt; would see the same definitions as the splice &lt;code&gt;$(th2 ...)&lt;/code&gt; (but &lt;em&gt;not&lt;/em&gt; any bindings it creates).</source>
          <target state="translated">拼接 &lt;code&gt;$(blah2)&lt;/code&gt; 会看到作为拼接相同的定义 &lt;code&gt;$(th2 ...)&lt;/code&gt; （但&lt;em&gt;没有&lt;/em&gt;任何绑定它创建）。</target>
        </trans-unit>
        <trans-unit id="23568e32cf98b6540af26102a798c92ac5cc17bb" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt; - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; 将看到 &lt;code&gt;f&lt;/code&gt; 的定义-接头是顶级的，因此可见在先前声明组中的所有定义（即，模块中的所有定义，包括但不包括：接头本身）。</target>
        </trans-unit>
        <trans-unit id="66ae13b13f09d43d7d7022adb99559db22c69352" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th1 ...)&lt;/code&gt;&lt;em&gt;cannot&lt;/em&gt; refer to &lt;code&gt;D&lt;/code&gt; - it is in the same declaration group.</source>
          <target state="translated">接头 &lt;code&gt;$(th1 ...)&lt;/code&gt; &lt;em&gt;不能&lt;/em&gt;引用 &lt;code&gt;D&lt;/code&gt; -它在同一声明组中。</target>
        </trans-unit>
        <trans-unit id="cfd7f431c58d50783a5438978201e850185fd6f9" translate="yes" xml:space="preserve">
          <source>The splice &lt;code&gt;$(th2 ...)&lt;/code&gt; would see the definition of &lt;code&gt;f&lt;/code&gt;, all the bindings created by &lt;code&gt;$(th1 ...)&lt;/code&gt;, the definition of &lt;code&gt;h&lt;/code&gt; and all bindings created by &lt;code&gt;[qq|blah|]&lt;/code&gt; (they are all in previous declaration groups).</source>
          <target state="translated">拼接 &lt;code&gt;$(th2 ...)&lt;/code&gt; 会看到的定义 &lt;code&gt;f&lt;/code&gt; ，通过创建的所有绑定 &lt;code&gt;$(th1 ...)&lt;/code&gt; ，定义 &lt;code&gt;h&lt;/code&gt; 和创建的所有绑定 &lt;code&gt;[qq|blah|]&lt;/code&gt; 他们都在前面声明组）。</target>
        </trans-unit>
        <trans-unit id="fd5a42cc6f0856988a6988150fdee908257d806e" translate="yes" xml:space="preserve">
          <source>The splice to run</source>
          <target state="translated">拼接运行</target>
        </trans-unit>
        <trans-unit id="47923b168fb732c024dc494400d461bd0f3e5688" translate="yes" xml:space="preserve">
          <source>The stack isn&amp;rsquo;t counted in the heap profile by default. See the RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">默认情况下，堆栈配置文件中不计算堆栈。请参阅RTS &lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="f8363fc1e95626b191f2da3fd7dd2880aae6eb17" translate="yes" xml:space="preserve">
          <source>The stack trace may often begin with something uninformative like &lt;code&gt;GHC.List.CAF&lt;/code&gt;; this is an artifact of GHC&amp;rsquo;s optimiser, which lifts out exceptions to the top-level where the profiling system assigns them to the cost centre &amp;ldquo;CAF&amp;rdquo;. However, &lt;code&gt;+RTS -xc&lt;/code&gt; doesn&amp;rsquo;t just print the current stack, it looks deeper and reports the stack at the time the CAF was evaluated, and it may report further stacks until a non-CAF stack is found. In the example above, the next stack (after &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt;) contains plenty of information about what the program was doing when it evaluated &lt;code&gt;head []&lt;/code&gt;.</source>
          <target state="translated">堆栈跟踪通常可能以诸如 &lt;code&gt;GHC.List.CAF&lt;/code&gt; 之类的无信息的内容开始；这是GHC的优化程序的一种人工产物，它可以将异常提升到顶级，在顶级系统中，性能分析系统会将异常分配给成本中心&amp;ldquo; CAF&amp;rdquo;。但是， &lt;code&gt;+RTS -xc&lt;/code&gt; 不仅打印当前堆栈，它看起来更深，并在评估CAF时报告堆栈，并且它可能会报告其他堆栈，直到找到非CAF堆栈为止。在上面的示例中，下一个堆栈（在 &lt;code&gt;--&amp;gt; evaluated by&lt;/code&gt; 符之后）包含许多有关程序在评估 &lt;code&gt;head []&lt;/code&gt; 时正在执行的操作的信息。</target>
        </trans-unit>
        <trans-unit id="f357097f00a6468c2d3427445e00b165cb07e564" translate="yes" xml:space="preserve">
          <source>The stack-overflow message.</source>
          <target state="translated">堆栈溢出的消息。</target>
        </trans-unit>
        <trans-unit id="e0a326a9e00b997f5fb0b784326a904a6e7b5eaa" translate="yes" xml:space="preserve">
          <source>The stand-alone syntax is generalised for newtypes in exactly the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses are generalised (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;). For example:</source>
          <target state="translated">独立语法针对新类型的泛化与普通 &lt;code&gt;deriving&lt;/code&gt; 子句的泛化完全相同（&lt;a href=&quot;#newtype-deriving&quot;&gt;针对新类型的广义派生实例&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="45542d7c9b7a614f41aca25452eef03382fd8b7e" translate="yes" xml:space="preserve">
          <source>The standalone deriving declaration does not need to be in the same module as the data type declaration. (But be aware of the dangers of orphan instances (&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt;).</source>
          <target state="translated">独立的派生声明不必与数据类型声明位于同一模块中。（但是要注意孤立实例的危险（&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9c93dc2af6ef75fd7905ebfe43102d59d1f187ca" translate="yes" xml:space="preserve">
          <source>The standard C99 &lt;code&gt;fenv.h&lt;/code&gt; header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</source>
          <target state="translated">标准的C99 &lt;code&gt;fenv.h&lt;/code&gt; 标头提供了用于检查和修改浮点单元的状态的操作。特别是，可以更改浮点运算所使用的舍入模式，并且可以测试异常标志。</target>
        </trans-unit>
        <trans-unit id="9da3d7146865193067ad8c49db6bf7867c4feacc" translate="yes" xml:space="preserve">
          <source>The standard CPUTime library.</source>
          <target state="translated">标准的CPUTime库。</target>
        </trans-unit>
        <trans-unit id="c1534047809870fc776b9636db7a2f0d8217f803" translate="yes" xml:space="preserve">
          <source>The standard IO library.</source>
          <target state="translated">标准的IO库。</target>
        </trans-unit>
        <trans-unit id="dada1f21d1ada812f4cdf347467d780f571ac73f" translate="yes" xml:space="preserve">
          <source>The standard assumption on Darwin/Mac OS X is that dynamic libraries will be stamped at build time with an &amp;ldquo;install name&amp;rdquo;, which is the full ultimate install path of the library file. Any libraries or executables that subsequently link against it (even if it hasn&amp;rsquo;t been installed yet) will pick up that path as their runtime search location for it. When compiling with ghc directly, the install name is set by default to the location where it is built. You can override this with the &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; option (which passes &lt;code&gt;-install_name&lt;/code&gt; to the Apple linker). Cabal does this for you. It automatically sets the install name for dynamic libraries to the absolute path of the ultimate install location.</source>
          <target state="translated">Darwin / Mac OS X上的标准假设是，动态库将在构建时用&amp;ldquo;安装名称&amp;rdquo;标记，这是库文件的完整最终安装路径。随后链接到该库的任何库或可执行文件（即使尚未安装）也将选择该路径作为其运行时搜索位置。直接使用ghc进行编译时，默认情况下会将安装名称设置为生成位置。您可以使用 &lt;code&gt;-dylib-install-name ⟨path⟩&lt;/code&gt; 选项（将 &lt;code&gt;-install_name&lt;/code&gt; 传递给Apple链接程序）覆盖此选项。 Cabal为您做到这一点。它将自动将动态库的安装名称设置为最终安装位置的绝对路径。</target>
        </trans-unit>
        <trans-unit id="a4171f107795c00f458d3b7816f1b704314edbe3" translate="yes" xml:space="preserve">
          <source>The standard defaulting rule is extended thus: defaulting applies when all the unresolved constraints involve standard classes &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;; and at least one is a numeric class &lt;em&gt;or&lt;/em&gt;&lt;code&gt;IsString&lt;/code&gt;.</source>
          <target state="translated">因此，扩展了标准默认规则：当所有未解决的约束都涉及标准类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 时，将应用默认值；至少一个是数字类&lt;em&gt;或&lt;/em&gt; &lt;code&gt;IsString&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b90689216583cd41f330d5e5b4b7eba42ec2fd80" translate="yes" xml:space="preserve">
          <source>The standard function &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</source>
          <target state="translated">标准函数 &lt;code&gt;hs_free_stable_ptr&lt;/code&gt; 锁定稳定指针表，释放给定的稳定指针，然后再次解锁稳定指针表。一次释放许多稳定的指针时，通常一次锁定和解锁表会更有效。</target>
        </trans-unit>
        <trans-unit id="668fc1031df30471faf0816d4347dfd7e6b9a3b7" translate="yes" xml:space="preserve">
          <source>The standard functions for encoding and decoding text are strict, which is to say that they throw exceptions on invalid input. This is often unhelpful on real world input, so alternative functions exist that accept custom handlers for dealing with invalid inputs. These &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; handlers are normal Haskell functions. You can use one of the presupplied functions in this module, or you can write a custom handler of your own.</source>
          <target state="translated">编码和解码文本的标准功能很严格，也就是说，它们对无效输入会抛出异常。这通常对现实世界的输入没有帮助，因此存在替代功能，这些功能接受用于处理无效输入的自定义处理程序。这些 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnError&quot;&gt;OnError&lt;/a&gt;&lt;/code&gt; 处理程序是常规的Haskell函数。您可以使用此模块中预先提供的功能之一，也可以编写自己的自定义处理程序。</target>
        </trans-unit>
        <trans-unit id="fd1929edeb7d09363083e46bcd3c301839eb47a2" translate="yes" xml:space="preserve">
          <source>The standard idiom used with &lt;code&gt;callCC&lt;/code&gt; is to provide a lambda-expression to name the continuation. Then calling the named continuation anywhere within its scope will escape from the computation, even if it is many layers deep within nested computations.</source>
          <target state="translated">与 &lt;code&gt;callCC&lt;/code&gt; 一起使用的标准习惯用法是提供lambda表达式来命名延续。然后，即使在嵌套计算中有很多层，在其范围内的任何地方调用命名的连续都将退出计算。</target>
        </trans-unit>
        <trans-unit id="725c149b8ea2ab588b227befe8a0a38299e1f811" translate="yes" xml:space="preserve">
          <source>The standard libraries do not have direct support for this device type, but a user implementation is expected to provide a list of file names in the directory, in any order, separated by &lt;code&gt;'\0'&lt;/code&gt; characters, excluding the &lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; names. See also &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt;. Seek operations are not supported on directories (other than to the zero position).</source>
          <target state="translated">标准库不直接支持此设备类型，但是用户实现应期望以任意顺序在目录中提供文件名列表，并以 &lt;code&gt;'\0'&lt;/code&gt; 字符分隔，但不包括 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 名称。另请参见 &lt;code&gt;&lt;a href=&quot;system-directory#v:getDirectoryContents&quot;&gt;getDirectoryContents&lt;/a&gt;&lt;/code&gt; 。目录（除零位以外）不支持搜寻操作。</target>
        </trans-unit>
        <trans-unit id="e8a916de96b5a1348d801040a8c4f1a1a8827fbc" translate="yes" xml:space="preserve">
          <source>The standard library search path for your system loader, which on some systems may be overridden by setting the &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">系统加载程序的标准库搜索路径，在某些系统上，可以通过设置 &lt;code id=&quot;index-19&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量来覆盖该路径。</target>
        </trans-unit>
        <trans-unit id="19505176a01ce854f810479f684294743406e341" translate="yes" xml:space="preserve">
          <source>The state of the execution stack</source>
          <target state="translated">执行栈的状态</target>
        </trans-unit>
        <trans-unit id="f7e67ea8aa9dfee2731a58a175262adf6a4d0499" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; means &amp;ldquo;execute &lt;code&gt;return 42&lt;/code&gt; in the &lt;code&gt;IO&lt;/code&gt; monad, and bind the result to &lt;code&gt;x&lt;/code&gt;&amp;rdquo;. We can then use &lt;code&gt;x&lt;/code&gt; in future statements, for example to print it as we did above.</source>
          <target state="translated">语句 &lt;code&gt;x &amp;lt;- return 42&lt;/code&gt; 表示&amp;ldquo; 在 &lt;code&gt;IO&lt;/code&gt; monad中执行 &lt;code&gt;return 42&lt;/code&gt; ，并将结果绑定到 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。然后，我们可以在以后的语句中使用 &lt;code&gt;x&lt;/code&gt; ，例如像上面一样打印它。</target>
        </trans-unit>
        <trans-unit id="c88d72a338b6ab0349b2edbe2a444fed0466129c" translate="yes" xml:space="preserve">
          <source>The statement is not a binding, or it is a monadic binding (&lt;code&gt;p &amp;lt;- e&lt;/code&gt;) that binds exactly one variable.</source>
          <target state="translated">该语句不是绑定，或者它是仅绑定一个变量的单子绑定（ &lt;code&gt;p &amp;lt;- e&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26713db50737151b3061c0a0f90970614125b4e0" translate="yes" xml:space="preserve">
          <source>The stored values don't represent large virtual data structures to be lazily computed.</source>
          <target state="translated">存储值并不代表大的虚拟数据结构,可以懒得计算。</target>
        </trans-unit>
        <trans-unit id="5a195b06cb90447dc9776264506496aa92aefc45" translate="yes" xml:space="preserve">
          <source>The strategy of combining computations that can throw exceptions by bypassing bound functions from the point an exception is thrown to the point that it is handled.</source>
          <target state="translated">从抛出异常到处理异常的过程中,通过绕过约束函数,将能抛出异常的计算组合起来的策略。</target>
        </trans-unit>
        <trans-unit id="a281a63e6736007299339dba190a3fb504a19a81" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="7afb89a781054b4b6d53c66cdbade7065f50d3d8" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="2d98a56131e0f04de337d0882771e394acb9d5b6" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-cps#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="4dc8357833da3292394aae6b46a123bbe223bc0c" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad transformer, which adds collection of outputs (such as a count or string output) to a given monad.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-strict#t:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; monad转换器，可将输出集合（例如计数或字符串输出）添加到给定的monad中。</target>
        </trans-unit>
        <trans-unit id="7c186abcf6ac752f3c38badaf602dca2e58877f2" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type requires that an entire string fit into memory at once. The lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is capable of streaming strings that are larger than memory using a small memory footprint. In many cases, the overhead of chunked streaming makes the lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type slower than its strict counterpart, but this is not always the case. Sometimes, the time complexity of a function in one module may be different from the other, due to their differing internal structures.</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型要求整个字符串一次放入内存。惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型能够使用较小的内存占用量流传输比内存大的字符串。在许多情况下，分块流传输的开销使惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型比其严格对应类型慢，但并非总是如此。有时，一个功能在一个模块中的时间复杂度可能会因另一个模块的内部结构不同而有所不同。</target>
        </trans-unit>
        <trans-unit id="65527fd492a2c24e97d357e54b9019d2cf4c0b6f" translate="yes" xml:space="preserve">
          <source>The strict &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad allows for destructive updates, but is escapable (unlike IO). A computation of type &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; returns a value of type &lt;code&gt;a&lt;/code&gt;, and execute in &quot;thread&quot; &lt;code&gt;s&lt;/code&gt;. The &lt;code&gt;s&lt;/code&gt; parameter is either</source>
          <target state="translated">严格的 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad。在 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子允许破坏性的更新，但允许脱离（不像IO）。类型 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt; s a&lt;/code&gt; 计算返回类型 &lt;code&gt;a&lt;/code&gt; 的值，并在&amp;ldquo;线程&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 中执行。该 &lt;code&gt;s&lt;/code&gt; 参数是</target>
        </trans-unit>
        <trans-unit id="8767e7a8a38c16ab0bb2841059262444985ec93e" translate="yes" xml:space="preserve">
          <source>The strictness analyser figures out when arguments and variables in a function can be treated &amp;lsquo;strictly&amp;rsquo; (that is they are always evaluated in the function at some point). This allow GHC to apply certain optimisations such as unboxing that otherwise don&amp;rsquo;t apply as they change the semantics of the program when applied to lazy arguments.</source>
          <target state="translated">严格性分析器指出何时可以&amp;ldquo;严格地&amp;rdquo;对待函数中的参数和变量（即始终在函数中对它们进行评估）。这使GHC可以进行某些优化，例如取消装箱，否则将不适用，因为当应用于延迟参数时，它们会更改程序的语义。</target>
        </trans-unit>
        <trans-unit id="6e2011ddb103ca8a7d059229ae604d364befac79" translate="yes" xml:space="preserve">
          <source>The strictness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的严格程度。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="452caeb84acbb77ee8c95de9c60b64d7a53f7406" translate="yes" xml:space="preserve">
          <source>The strictness that GHC infers for a field during compilation. Whereas there are nine different combinations of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt;, the strictness that GHC decides will ultimately be one of lazy, strict, or unpacked. What GHC decides is affected both by what the user writes in the source code and by GHC flags. As an example, consider this data type:</source>
          <target state="translated">在编译过程中，GHC推断字段的严格性。尽管 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceUnpackedness&quot;&gt;SourceUnpackedness&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:SourceStrictness&quot;&gt;SourceStrictness&lt;/a&gt;&lt;/code&gt; 有九种不同的组合，但是GHC决定的严格性最终将是惰性，严格或未打包的一种。GHC决定的内容受用户在源代码中编写的内容以及GHC标志的影响。例如，请考虑以下数据类型：</target>
        </trans-unit>
        <trans-unit id="89a584f7d6318b24a421c9d75de2b615ce3c18f3" translate="yes" xml:space="preserve">
          <source>The strictness that the compiler inferred for the selector</source>
          <target state="translated">编译器对选择器推断的严格程度。</target>
        </trans-unit>
        <trans-unit id="874f9293737bf29e2db184d41d8db8a32987eb82" translate="yes" xml:space="preserve">
          <source>The string capabilities in this module are the character sequences corresponding to user input such as arrow keys and function keys.</source>
          <target state="translated">该模块中的字符串功能是对应于用户输入的字符序列,如方向键和功能键。</target>
        </trans-unit>
        <trans-unit id="1f4ad8b7962c51a61e8c4bd613c54e8011e48fb7" translate="yes" xml:space="preserve">
          <source>The string in parentheses after the package name is the installed package ID: it normally begins with the package name and version, and ends in a hash string derived from the compiled package. Dependencies between packages are expressed in terms of installed package IDs, rather than just packages and versions. For example, take a look at the dependencies of the &lt;code&gt;haskell98&lt;/code&gt; package:</source>
          <target state="translated">软件包名称后括号中的字符串是已安装的软件包ID：通常以软件包名称和版本开头，并以从已编译的软件包派生的哈希字符串结尾。软件包之间的依赖关系以已安装的软件包ID表示，而不仅仅是软件包和版本。例如，看一下 &lt;code&gt;haskell98&lt;/code&gt; 软件包的依赖关系：</target>
        </trans-unit>
        <trans-unit id="800c652caf58afbb39f126fbcdbcf23d8117aa7a" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted.</source>
          <target state="translated">有向图的强连接分量,反向拓扑排序。</target>
        </trans-unit>
        <trans-unit id="ddf6268ee3b3ab45015db89ef43dec769f4bad14" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a directed graph, reverse topologically sorted. The function is the same as &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt;, except that all the information about each node retained. This interface is used when you expect to apply &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; to (some of) the result of &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt;, so you don't want to lose the dependency information.</source>
          <target state="translated">有向图的强连接组件，按逆向拓扑排序。该函数与 &lt;code&gt;&lt;a href=&quot;data-graph#v:stronglyConnComp&quot;&gt;stronglyConnComp&lt;/a&gt;&lt;/code&gt; 相同，只是保留了有关每个节点的所有信息。当您希望申请该接口用于 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 来（一些）的结果 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; ，所以你不想失去相关性信息。</target>
        </trans-unit>
        <trans-unit id="a57d36a00a23d146f6ef5c2dc372f9cf337806de" translate="yes" xml:space="preserve">
          <source>The strongly connected components of a graph, in reverse topological order.</source>
          <target state="translated">图的强连接分量,按反向拓扑顺序。</target>
        </trans-unit>
        <trans-unit id="43a19690de2f9d1d8be09c13cbb22de3789cc278" translate="yes" xml:space="preserve">
          <source>The subtraction operation, and the greater-than-or-equal test, in &lt;code&gt;n+k&lt;/code&gt; patterns use whatever &lt;code&gt;(-)&lt;/code&gt; and &lt;code&gt;(&amp;gt;=)&lt;/code&gt; are in scope.</source>
          <target state="translated">在 &lt;code&gt;n+k&lt;/code&gt; 模式中，减法运算和大于等于检验使用范围内的 &lt;code&gt;(-)&lt;/code&gt; 和 &lt;code&gt;(&amp;gt;=)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4012471429ca5c7ba04bc705b681a94410ab1849" translate="yes" xml:space="preserve">
          <source>The suffix of the &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that could not be decoded due to insufficient input.</source>
          <target state="translated">由于输入不足而无法解码的 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 后缀。</target>
        </trans-unit>
        <trans-unit id="bc55708fbbcc2f6408e01cba514ffdea99d3c7fa" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">概括 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biconcat&quot;&gt;biconcat&lt;/a&gt;&lt;/code&gt; 的动作集合的总和。</target>
        </trans-unit>
        <trans-unit id="f4ea1e538ad4b53fa66cdfd634dcb4ac8d35e514" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3b60db9348af6943b179b2e86b7211b8058b8a2" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;control-monad#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dbb19dea24b4fb38846d955f10c5e44271be4ab" translate="yes" xml:space="preserve">
          <source>The sum of a collection of actions, generalizing &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt;. As of base 4.8.0.0, &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; is just &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt;, specialized to &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">动作集合的总和，概括为 &lt;code&gt;&lt;a href=&quot;data-foldable#v:concat&quot;&gt;concat&lt;/a&gt;&lt;/code&gt; 。从4.8.0.0版开始， &lt;code&gt;&lt;a href=&quot;data-foldable#v:msum&quot;&gt;msum&lt;/a&gt;&lt;/code&gt; 只是 &lt;code&gt;&lt;a href=&quot;data-foldable#v:asum&quot;&gt;asum&lt;/a&gt;&lt;/code&gt; ，专用于 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34ab21e6e1aaae1bca96ae7ec03ef891e22c67a2" translate="yes" xml:space="preserve">
          <source>The superclass instances should satisfy the following:</source>
          <target state="translated">超类实例应满足以下要求。</target>
        </trans-unit>
        <trans-unit id="601c418a63c60900d136bd4720ff47c285ee0785" translate="yes" xml:space="preserve">
          <source>The symbols defined by GHC are listed below. To check which symbols are defined by your local GHC installation, the following trick is useful:</source>
          <target state="translated">下面列出了GHC定义的符号。要检查哪些符号是由你本地安装的GHC定义的,下面的技巧很有用。</target>
        </trans-unit>
        <trans-unit id="09212832b3e34d72dce2fff3badb2d4c72e1995b" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="31649ab7ec4ff56487760fbbe409d363750ae3e3" translate="yes" xml:space="preserve">
          <source>The syntax accepted by this function is the same as for &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数接受的语法与 &lt;code&gt;&lt;a href=&quot;data-text-read#v:rational&quot;&gt;rational&lt;/a&gt;&lt;/code&gt; 的语法相同。</target>
        </trans-unit>
        <trans-unit id="c7ced7f7fed6d217b69c558540eb691be95e7fb5" translate="yes" xml:space="preserve">
          <source>The syntax and semantics of pattern synonyms are elaborated in the following subsections. There are also lots more details in the &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="translated">以下小节将详细说明模式同义词的语法和语义。也有在其它更多细节&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/pattern-synonyms-Haskell16.pdf&quot;&gt;纸&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1898dd084c771828aecaee9b8e697bb13e36ea3" translate="yes" xml:space="preserve">
          <source>The syntax for minimal complete definition is:</source>
          <target state="translated">最小完整定义的语法是:</target>
        </trans-unit>
        <trans-unit id="6d4d4090d2ca1b67d53de25f5ccbc8a40e760887" translate="yes" xml:space="preserve">
          <source>The syntax in the prompt &lt;code&gt;*module&lt;/code&gt; indicates that it is the full top-level scope of ⟨module⟩ that is contributing to the scope for expressions typed at the prompt. Without the &lt;code&gt;*&lt;/code&gt;, just the exports of the module are visible.</source>
          <target state="translated">提示 &lt;code&gt;*module&lt;/code&gt; 中的语法表明，是&amp;ldquo; 模块&amp;rdquo;的完整顶级范围才有助于在提示中键入的表达式的范围。如果没有 &lt;code&gt;*&lt;/code&gt; ，则仅显示模块的导出。</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">语法是</target>
        </trans-unit>
        <trans-unit id="e90385697e013355d38615469e8cfd75a3c62ed9" translate="yes" xml:space="preserve">
          <source>The syntax is identical to that of an ordinary instance declaration apart from (a) the keyword &lt;code&gt;deriving&lt;/code&gt;, and (b) the absence of the &lt;code&gt;where&lt;/code&gt; part.</source>
          <target state="translated">除了（a）关键字 &lt;code&gt;deriving&lt;/code&gt; 和（b）缺少 &lt;code&gt;where&lt;/code&gt; 部分之外，该语法与普通实例声明的语法相同。</target>
        </trans-unit>
        <trans-unit id="c439f2f4a3a3244db28746190d4b4754f0a2dbfb" translate="yes" xml:space="preserve">
          <source>The syntax is the same as for &lt;code&gt;case&lt;/code&gt; expressions, except that the bodies of the alternatives are commands rather than expressions. The translation is similar to that of &lt;code&gt;if&lt;/code&gt; commands.</source>
          <target state="translated">语法与 &lt;code&gt;case&lt;/code&gt; 表达式相同，除了替代方法的主体是命令而不是表达式。转换类似于 &lt;code&gt;if&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="06b82b71139eb6105985a9ea822a6da5f567e6c2" translate="yes" xml:space="preserve">
          <source>The syntax of a cost centre annotation for expressions is</source>
          <target state="translated">表达式的成本中心注释的语法是</target>
        </trans-unit>
        <trans-unit id="39642abd7096bcb01814d7cae1861c218f39c272" translate="yes" xml:space="preserve">
          <source>The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell &lt;code&gt;do&lt;/code&gt; expression. However, there&amp;rsquo;s no monad overloading here: statements typed at the prompt must be in the &lt;code&gt;IO&lt;/code&gt; monad.</source>
          <target state="translated">GHCi提示符下接受的语句的语法与Haskell &lt;code&gt;do&lt;/code&gt; 表达式中的语句的语法完全相同。但是，这里没有monad重载：在提示符下键入的语句必须在 &lt;code&gt;IO&lt;/code&gt; monad中。</target>
        </trans-unit>
        <trans-unit id="57bd174f58802ef0f51feabdb13a1ea1a660c409" translate="yes" xml:space="preserve">
          <source>The syntax of the value depends on the field. The various field types are:</source>
          <target state="translated">值的语法取决于字段。各种字段类型有:</target>
        </trans-unit>
        <trans-unit id="202a394073135e421a152f8ce9fd5cd3dfc192e0" translate="yes" xml:space="preserve">
          <source>The table below summarises where each kind of pattern synonym can be used.</source>
          <target state="translated">下表总结了每一种模式同义词的使用范围。</target>
        </trans-unit>
        <trans-unit id="63a6c28c376561a6f590d22eabde559eabb51ab0" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="a934fce6fdd2ffdb39bbed5c280b561fba32c363" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="c26d3376b4a836bb67a06339918f835307d1d509" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="ff8bb3eff7d145417d7bd237ecabdafc3547dcf3" translate="yes" xml:space="preserve">
          <source>The tactics described for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; work for &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; as well. Furthermore, the following are available.</source>
          <target state="translated">所描述的用于 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 工作的策略也是如此。此外，以下内容可用。</target>
        </trans-unit>
        <trans-unit id="d865c7a90982fb62dc4ae75514e4dcae088ee2b0" translate="yes" xml:space="preserve">
          <source>The template file (see below).</source>
          <target state="translated">模板文件(见下文)。</target>
        </trans-unit>
        <trans-unit id="0b4e99c29e9e1110faab1ac222008a4dc83498a8" translate="yes" xml:space="preserve">
          <source>The temporary storage is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must &lt;em&gt;not&lt;/em&gt; be used after this function returns.</source>
          <target state="translated">子计算终止时（正常或通过异常）释放临时存储，因此在该函数返回后，&lt;em&gt;不得&lt;/em&gt;使用指向临时存储的指针。</target>
        </trans-unit>
        <trans-unit id="5843b93328315843899ef67d9ac21737c6ec6f80" translate="yes" xml:space="preserve">
          <source>The term &amp;ldquo;unregisterised&amp;rdquo; really means &amp;ldquo;compile via vanilla C&amp;rdquo;, disabling some of the platform-specific tricks that GHC normally uses to make programs go faster. When compiling unregisterised, GHC simply generates a C file which is compiled via gcc.</source>
          <target state="translated">&amp;ldquo;未注册&amp;rdquo;一词的真正含义是&amp;ldquo;通过香草C编译&amp;rdquo;，从而禁用了GHC通常用来使程序运行更快的某些特定于平台的技巧。当编译未注册的内容时，GHC会简单地生成一个通过gcc编译的C文件。</target>
        </trans-unit>
        <trans-unit id="e2c5e0b321bb9e70feb67c2d09ee38018c4bf2af" translate="yes" xml:space="preserve">
          <source>The term level syntax is similar. Leading and preceding bars (&lt;code&gt;|&lt;/code&gt;) indicate which alternative it is. Here are two terms of the type shown above:</source>
          <target state="translated">术语级别的语法相似。前导和前杠（ &lt;code&gt;|&lt;/code&gt; ）指示它是哪个替代项。这是上面显示的两种类型的术语：</target>
        </trans-unit>
        <trans-unit id="c6feeb4ddd15050ca18ee294869d49815d5f2066" translate="yes" xml:space="preserve">
          <source>The third and final section of the file gives a profile break-down by cost-centre stack. This is roughly a call-tree profile of the program. In the example above, it is clear that the costly call to &lt;code&gt;fib&lt;/code&gt; came from &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">该文件的第三部分也是最后一部分提供了按成本中心堆栈划分的配置文件细分。这大致是程序的调用树配置文件。在上面的示例中，很明显，对 &lt;code&gt;fib&lt;/code&gt; 的昂贵调用来自 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="006833f98130a8f76b519213e28557b98c68aabc" translate="yes" xml:space="preserve">
          <source>The third instance declaration does not obey the coverage condition; and indeed the (somewhat strange) definition:</source>
          <target state="translated">第三例声明不服从覆盖条件;事实上(有点奇怪)定义。</target>
        </trans-unit>
        <trans-unit id="05cc827b35cf7b3c105e9a9c20e954f8071d852d" translate="yes" xml:space="preserve">
          <source>The third kind of instance exists for every &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; and comes in two variants, namely</source>
          <target state="translated">对于每种新类型 &lt;code&gt;newtype NT = MkNT T&lt;/code&gt; ，都存在第三种实例，它有两个变体，即</target>
        </trans-unit>
        <trans-unit id="3bd2c3ed5890f250e2002920ec679aa2cdafcf5e" translate="yes" xml:space="preserve">
          <source>The third kind of wildcard is the &lt;em&gt;extra-constraints wildcard&lt;/em&gt;. The presence of an extra-constraints wildcard indicates that an arbitrary number of extra constraints may be inferred during type checking and will be added to the type signature. In the example below, the extra-constraints wildcard is used to infer three extra constraints.</source>
          <target state="translated">第三种通配符是&lt;em&gt;Extra-constraints通配符&lt;/em&gt;。额外约束通配符的存在指示在类型检查期间可以推断任意数量的额外约束，并将其添加到类型签名中。在下面的示例中，额外约束通配符用于推断三个额外约束。</target>
        </trans-unit>
        <trans-unit id="e3f90c4625109b43c8084cce4940a68a10e8c40f" translate="yes" xml:space="preserve">
          <source>The thread is blocked on an &lt;code&gt;MVar&lt;/code&gt;, but there are no other references to the &lt;code&gt;MVar&lt;/code&gt; so it can't ever continue.</source>
          <target state="translated">该线程在 &lt;code&gt;MVar&lt;/code&gt; 上被阻止，但是没有其他对 &lt;code&gt;MVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="153d4dcc14c4b83f4dd90f15af80d80779678ce4" translate="yes" xml:space="preserve">
          <source>The thread is waiting to retry an STM transaction, but there are no other references to any &lt;code&gt;TVar&lt;/code&gt;s involved, so it can't ever continue.</source>
          <target state="translated">该线程正在等待重试STM事务，但是没有其他涉及任何 &lt;code&gt;TVar&lt;/code&gt; 的引用，因此它永远无法继续。</target>
        </trans-unit>
        <trans-unit id="e47d3507c379ee5ecfefb0d652582554ff9592ce" translate="yes" xml:space="preserve">
          <source>The thread making the foreign call is sent a &lt;code&gt;SIGPIPE&lt;/code&gt; signal using &lt;code&gt;pthread_kill()&lt;/code&gt;. This is usually enough to cause a blocking system call to return with &lt;code&gt;EINTR&lt;/code&gt; (GHC by default installs an empty signal handler for &lt;code&gt;SIGPIPE&lt;/code&gt;, to override the default behaviour which is to terminate the process immediately).</source>
          <target state="translated">使用 &lt;code&gt;pthread_kill()&lt;/code&gt; 向发出外部调用的线程发送 &lt;code&gt;SIGPIPE&lt;/code&gt; 信号。这通常足以导致阻塞的系统调用返回 &lt;code&gt;EINTR&lt;/code&gt; （默认情况下，GHC为 &lt;code&gt;SIGPIPE&lt;/code&gt; 安装一个空信号处理程序，以覆盖默认行为，即立即终止进程）。</target>
        </trans-unit>
        <trans-unit id="dc3f55c5bbf83854f6c0fbdab69d4f8ac8efc219" translate="yes" xml:space="preserve">
          <source>The threaded runtime system provides the following benefits:</source>
          <target state="translated">线程运行系统具有以下优点。</target>
        </trans-unit>
        <trans-unit id="0857013e6b098dcf4a2991653bd77bab36770599" translate="yes" xml:space="preserve">
          <source>The time and allocation incurred by a given part of the program is displayed in two ways: &amp;ldquo;individual&amp;rdquo;, which are the costs incurred by the code covered by this cost centre stack alone, and &amp;ldquo;inherited&amp;rdquo;, which includes the costs incurred by all the children of this node.</source>
          <target state="translated">程序给定部分所花费的时间和分配以两种方式显示：&amp;ldquo;个人&amp;rdquo;，即由该成本中心堆栈所覆盖的代码所产生的成本；以及&amp;ldquo;继承&amp;rdquo;，其包括所有成本所引起的成本该节点的子代。</target>
        </trans-unit>
        <trans-unit id="ba821c7b2c68328012c9090eb3761d8e93f68a1c" translate="yes" xml:space="preserve">
          <source>The time elapsed during GC itself</source>
          <target state="translated">气象局本身所耗费的时间</target>
        </trans-unit>
        <trans-unit id="51d9a82a9f3d64e8432722f74df5f02d64a529e0" translate="yes" xml:space="preserve">
          <source>The time elapsed during synchronisation before GC</source>
          <target state="translated">在同步化过程中,GC之前所经过的时间。</target>
        </trans-unit>
        <trans-unit id="7c0735b2391960bf71874071a3ad1522abfcdaab" translate="yes" xml:space="preserve">
          <source>The time locale.</source>
          <target state="translated">时间地点。</target>
        </trans-unit>
        <trans-unit id="635699c1de3bbf03eeb4589396236f0563a33d91" translate="yes" xml:space="preserve">
          <source>The time value, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the input could not be parsed using the given format.</source>
          <target state="translated">时间值，如果无法使用给定格式解析输入，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b879d81d9e92215265250a4d9dbf254f8e1ceccb" translate="yes" xml:space="preserve">
          <source>The time value.</source>
          <target state="translated">时间值。</target>
        </trans-unit>
        <trans-unit id="d67a73e76fb4a63dbec3bae1d772d92896ac5e8e" translate="yes" xml:space="preserve">
          <source>The total number of bytes allocated by the program over the whole run.</source>
          <target state="translated">程序在整个运行过程中分配的总字节数。</target>
        </trans-unit>
        <trans-unit id="659dcc49ad7db77aa436a59a26fe4ff143fda38c" translate="yes" xml:space="preserve">
          <source>The total number of garbage collections performed.</source>
          <target state="translated">进行垃圾收集的总次数。</target>
        </trans-unit>
        <trans-unit id="c34c589e65c946035b07b2931096cc65473c816d" translate="yes" xml:space="preserve">
          <source>The total wall time of the program&amp;rsquo;s execution in seconds.</source>
          <target state="translated">程序执行的总时间（以秒为单位）。</target>
        </trans-unit>
        <trans-unit id="70c58cb0b1b679f8dbf2b38d7d0722b07c314a3c" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="8c79225ca289cd5ba4c8a1fb91fc94c1d3935a10" translate="yes" xml:space="preserve">
          <source>The transaction may have seen an inconsistent view of memory when the IO runs. Invariants that you expect to be true throughout your program may not be true inside a transaction, due to the way transactions are implemented. Normally this wouldn't be visible to the programmer, but using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; can expose it.</source>
          <target state="translated">IO运行时，事务可能会看到不一致的内存视图。由于实现事务的方式，您期望整个程序中的不变量在事务内可能不是正确的。通常，这对于程序员来说是不可见的，但是使用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 可以将其公开。</target>
        </trans-unit>
        <trans-unit id="59680a93a71d010858520603ea1e8e61b91ff0e7" translate="yes" xml:space="preserve">
          <source>The translation is carefully crafted to make bang patterns meaningful for recursive and polymorphic bindings as well as straightforward non-recursive bindings.</source>
          <target state="translated">译文经过精心设计,使bang模式对递归和多态绑定以及直接的非递归绑定都有意义。</target>
        </trans-unit>
        <trans-unit id="ebea5cebfd88bea17758c13e86ea6a4d0e1d2c76" translate="yes" xml:space="preserve">
          <source>The translation of such forms uses the &lt;code&gt;loop&lt;/code&gt; combinator, so the arrow concerned must belong to the &lt;code&gt;ArrowLoop&lt;/code&gt; class.</source>
          <target state="translated">这种形式的翻译使用 &lt;code&gt;loop&lt;/code&gt; 组合器，因此有关的箭头必须属于 &lt;code&gt;ArrowLoop&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="dfd95fc9633151cbaf9c86c13c1e83646b8ce5db" translate="yes" xml:space="preserve">
          <source>The trivial monad transformer, which maps a monad to an equivalent monad.</source>
          <target state="translated">三元单体变换器,它将一个单体映射到一个等价单体上。</target>
        </trans-unit>
        <trans-unit id="cf37054a4b01f1fddda009bf4a01c4e8cca69192" translate="yes" xml:space="preserve">
          <source>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module&amp;rsquo;s interface would otherwise be of any use. See &lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;Orphan modules and instance declarations&lt;/a&gt; for details.</source>
          <target state="translated">孤儿的麻烦在于，GHC必须主动读取所有孤儿模块的接口文件，以防万一它们的实例或规则起作用，而无论模块接口是否可以使用。有关详细信息，请参见&lt;a href=&quot;separate_compilation#orphan-modules&quot;&gt;孤立模块和实例声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd2fc9c6f6439ffd8e46493e079adf0e00b62d37" translate="yes" xml:space="preserve">
          <source>The two are treated identically, except that the latter may bring type variables into scope (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;).</source>
          <target state="translated">两者的处理方式相同，只是后者可能会将类型变量带入范围（请参阅&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexical作用域类型变量&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3e1a8fe74af6e6a8cdd2677c908de8ccfe0c2eeb" translate="yes" xml:space="preserve">
          <source>The two constructors have the types you&amp;rsquo;d expect:</source>
          <target state="translated">这两个构造函数具有您期望的类型：</target>
        </trans-unit>
        <trans-unit id="bf5989a27408738db3d0883d648567d3eb763546" translate="yes" xml:space="preserve">
          <source>The two functions &lt;code&gt;comp1&lt;/code&gt; and &lt;code&gt;comp2&lt;/code&gt; have the same semantics, but &lt;code&gt;comp1&lt;/code&gt; will be inlined when applied to &lt;em&gt;two&lt;/em&gt; arguments, while &lt;code&gt;comp2&lt;/code&gt; requires &lt;em&gt;three&lt;/em&gt;. This might make a big difference if you say</source>
          <target state="translated">两个函数 &lt;code&gt;comp1&lt;/code&gt; 和 &lt;code&gt;comp2&lt;/code&gt; 具有相同的语义，但是 &lt;code&gt;comp1&lt;/code&gt; 在应用于&lt;em&gt;两个&lt;/em&gt;参数时将被内联，而 &lt;code&gt;comp2&lt;/code&gt; 需要&lt;em&gt;三个&lt;/em&gt;。如果您说这可能会有很大的不同</target>
        </trans-unit>
        <trans-unit id="fba374fd5b03a3d47d674283e790f74d219af40d" translate="yes" xml:space="preserve">
          <source>The two sets of options are initialised as follows. First, both sets of options are initialised as described in &lt;a href=&quot;#ghci-dot-files&quot;&gt;The .ghci and .haskeline files&lt;/a&gt;. Then the interactive options are modified as follows:</source>
          <target state="translated">两组选项的初始化如下。首先，&lt;a href=&quot;#ghci-dot-files&quot;&gt;如.ghci和.haskeline文件中&lt;/a&gt;所述初始化两组选项。然后，对交互选项进行如下修改：</target>
        </trans-unit>
        <trans-unit id="4f082e0361fdf6edb4a33604e967da5739b7056c" translate="yes" xml:space="preserve">
          <source>The two sets of options can be inspected using the &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; commands respectively, with no arguments. For example, in a clean GHCi session we might see something like this:</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;命令分别检查两组选项，不带参数。例如，在干净的GHCi会话中，我们可能会看到以下内容：</target>
        </trans-unit>
        <trans-unit id="7caf43f8ce0ab145605d6b69de0c3897baa9da80" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="ed78adfe8300c790978c92161f3422d92e969883" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="419ee8e65889bcd48fbc5fc15fe89139aefad4e4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="1f1f3e2498fc3dc454f35f0c13d62c79ebcfbca7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; represents references to objects that are maintained in a foreign language, i.e., that are not part of the data structures usually managed by the Haskell storage manager. The essential difference between &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;s and vanilla memory references of type &lt;code&gt;Ptr a&lt;/code&gt; is that the former may be associated with &lt;em&gt;finalizers&lt;/em&gt;. A finalizer is a routine that is invoked when the Haskell storage manager detects that - within the Haskell heap and stack - there are no more references left that are pointing to the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. Typically, the finalizer will, then, invoke routines in the foreign language that free the resources bound by the foreign object.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 表示对以外语维护的对象的引用，即，这些对象不是通常由Haskell存储管理器管理的数据结构的一部分。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Ptr a&lt;/code&gt; 类型的普通内存引用之间的本质区别在于，前者可能与&lt;em&gt;终结器&lt;/em&gt;相关联。终结器是一个例程，当Haskell存储管理器检测到该例程时（在Haskell堆和堆栈中），不再有指向 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的引用。通常，终结器随后将使用外语调用例程，以释放由外来对象绑定的资源。</target>
        </trans-unit>
        <trans-unit id="4d4f963e4969ef845301b6512e9387a803cf233d" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is the type of values which can be either a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor can be used only on &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是其可以是一个值的类型 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数只能上使用 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; s，并且 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造只能用来 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; S：</target>
        </trans-unit>
        <trans-unit id="66ab93edaefb73f810fbe09019f9b02482d161f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Simple&lt;/code&gt; has its parameter at role representational, which is generally the most common case. &lt;code&gt;Simple Age&lt;/code&gt; would have the same representation as &lt;code&gt;Simple Int&lt;/code&gt;. The type &lt;code&gt;Complex&lt;/code&gt;, on the other hand, has its parameter at role nominal, because &lt;code&gt;Complex Age&lt;/code&gt; and &lt;code&gt;Complex Int&lt;/code&gt; are &lt;em&gt;not&lt;/em&gt; the same. Lastly, &lt;code&gt;Phant Age&lt;/code&gt; and &lt;code&gt;Phant Bool&lt;/code&gt; have the same representation, even though &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Bool&lt;/code&gt; are unrelated.</source>
          <target state="translated">&lt;code&gt;Simple&lt;/code&gt; 类型在角色表示中具有其参数，这通常是最常见的情况。 &lt;code&gt;Simple Age&lt;/code&gt; 与 &lt;code&gt;Simple Int&lt;/code&gt; 具有相同的表示形式。类型 &lt;code&gt;Complex&lt;/code&gt; ，而另一方面，有其在标称的作用参数，因为 &lt;code&gt;Complex Age&lt;/code&gt; 和 &lt;code&gt;Complex Int&lt;/code&gt; 是&lt;em&gt;不&lt;/em&gt;一样的。最后，尽管 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Bool&lt;/code&gt; 无关，但 &lt;code&gt;Phant Age&lt;/code&gt; 和 &lt;code&gt;Phant Bool&lt;/code&gt; 具有相同的表示形式。</target>
        </trans-unit>
        <trans-unit id="3c4014baea40eec814c3def2f55ce0d628bbaefa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;StreamPermParser s st a&lt;/code&gt; denotes a permutation parser that, when converted by the &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; function, parses &lt;code&gt;s&lt;/code&gt; streams with user state &lt;code&gt;st&lt;/code&gt; and returns a value of type &lt;code&gt;a&lt;/code&gt; on success.</source>
          <target state="translated">类型 &lt;code&gt;StreamPermParser s st a&lt;/code&gt; 表示一个置换分析器，当由 &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:permute&quot;&gt;permute&lt;/a&gt;&lt;/code&gt; 函数转换时，它将分析具有用户状态 &lt;code&gt;st&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 流，并在成功时返回a类型 &lt;code&gt;a&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="c22ce23b8a65ad0bce0abd3a477d13efd3e09be5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="370b7cbf7eb99c94429a5901c2c830ab76f33e79" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;a&lt;/code&gt; will often be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; which provides the marshalling operations. However this is not essential, and you can provide your own operations to access the pointer. For example you might write small foreign functions to get or set the fields of a C &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;a&lt;/code&gt; 通常是 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例，该类提供编组操作。但是，这不是必需的，您可以提供自己的操作来访问指针。例如，您可能编写小的外部函数来获取或设置C &lt;code&gt;struct&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="6c3e2e4b4159097f9e4b78db1290fd9ab1184135" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;t&lt;/code&gt; is an arbitrary type.</source>
          <target state="translated">类型 &lt;code&gt;t&lt;/code&gt; 是任意类型。</target>
        </trans-unit>
        <trans-unit id="ff3ca6f1e2f18d7218da226b719c5d115f82e6ca" translate="yes" xml:space="preserve">
          <source>The type checker sometimes displays a fragment of the type environment in error messages, but only up to some maximum number, set by this flag. Turning it off with &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; gives an unlimited number. Syntactically top-level bindings are also usually excluded (since they may be numerous), but &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; includes them too.</source>
          <target state="translated">类型检查器有时会在错误消息中显示类型环境的片段，但是最多显示此标志设置的最大数量。使用 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 将其关闭可提供无限数量。从语法上讲，顶级绑定通常也被排除（因为它们可能很多），但是 &lt;code&gt;-fno-max-relevant-bindings&lt;/code&gt; 也包括它们。</target>
        </trans-unit>
        <trans-unit id="a1736df80e93e16ffd674b3951d956f327a670ca" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; is type to which you can unsafely coerce any lifted type, and back. More concretely, for a lifted type &lt;code&gt;t&lt;/code&gt; and value &lt;code&gt;x :: t&lt;/code&gt;, -- &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; is equivalent to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Any&quot;&gt;Any&lt;/a&gt;&lt;/code&gt; 是可以安全地将任何提升类型强制转换为反向的类型。更具体地说，对于提升类型 &lt;code&gt;t&lt;/code&gt; 和值 &lt;code&gt;x :: t&lt;/code&gt; ， &lt;code&gt;unsafeCoerce (unsafeCoerce x :: Any) :: t&lt;/code&gt; 等效于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea123257a3ea77501373eb40af6b37206703f285" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; is a variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="55d3829bd0947962c7f37d5290cf7fb9ebbb1e05" translate="yes" xml:space="preserve">
          <source>The type constructor &lt;code&gt;Proxy#&lt;/code&gt; is used to bear witness to some type variable. It's used when you want to pass around proxy values for doing things like modelling type applications. A &lt;code&gt;Proxy#&lt;/code&gt; is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free.</source>
          <target state="translated">类型构造函数 &lt;code&gt;Proxy#&lt;/code&gt; 用于见证某些类型变量。当您要传递代理值以进行诸如对类型应用程序建模之类的操作时，可以使用它。一个 &lt;code&gt;Proxy#&lt;/code&gt; 不仅拆箱，它也有一个多态样了，有没有运行时表示，是完全免费的。</target>
        </trans-unit>
        <trans-unit id="56d9865b671376bed7c725718b4b3598bbdc080b" translate="yes" xml:space="preserve">
          <source>The type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; are all variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">类型构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt;&lt;/code&gt; 都是 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的变体：</target>
        </trans-unit>
        <trans-unit id="427f7d138a9c24f5fd34b3ac2e117fbf5b6e9472" translate="yes" xml:space="preserve">
          <source>The type function &lt;code&gt;Item&lt;/code&gt; returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">类型函数 &lt;code&gt;Item&lt;/code&gt; 返回结构 &lt;code&gt;l&lt;/code&gt; 的项目类型。</target>
        </trans-unit>
        <trans-unit id="8367a0b18542e7e434fc0f6304e749d0f89ce162" translate="yes" xml:space="preserve">
          <source>The type in a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can be any type that is less polymorphic than the type of the original function. In concrete terms, if the original function is &lt;code&gt;f&lt;/code&gt; then the pragma</source>
          <target state="translated">在一个类型 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示可以是任何类型，它是比原来的功能的类型少的多态性。具体来说，如果原始函数为 &lt;code&gt;f&lt;/code&gt; ,则说明语用</target>
        </trans-unit>
        <trans-unit id="6a5c083af5b39446fdb74fc301ec9287b848c4cb" translate="yes" xml:space="preserve">
          <source>The type may contain a class context too, of course:</source>
          <target state="translated">当然,该类型也可以包含一个类上下文。</target>
        </trans-unit>
        <trans-unit id="f38fe9f69c2a95d7c4f30f267130d69388ac39b4" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is a headache, but operationally it is a simple generalisation of a list fold.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的类型令人头疼，但是在操作上它是列表折叠的简单概括。</target>
        </trans-unit>
        <trans-unit id="67ce2acf5b412fb046750a70729d01c5751bba50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;elem&lt;/code&gt; is illegal in Haskell 98, because it contains the constraint &lt;code&gt;Eq a&lt;/code&gt;, which constrains only the class type variable (in this case &lt;code&gt;a&lt;/code&gt;). this case &lt;code&gt;a&lt;/code&gt;). More precisely, a constraint in a class method signature is rejected if</source>
          <target state="translated">&lt;code&gt;elem&lt;/code&gt; 的类型在Haskell 98中是非法的，因为它包含约束 &lt;code&gt;Eq a&lt;/code&gt; ，该约束仅约束类类型变量（在这种情况下为 &lt;code&gt;a&lt;/code&gt; ）。这种情况 &lt;code&gt;a&lt;/code&gt; ）。更准确地说，如果以下情况被拒绝，则拒绝类方法签名中的约束：</target>
        </trans-unit>
        <trans-unit id="f45425f3fa8bef6aae90934b75c4fbd7b74b6954" translate="yes" xml:space="preserve">
          <source>The type of any free variable mentioned in any of the &lt;code&gt;case&lt;/code&gt; alternatives must be rigid.</source>
          <target state="translated">任何一种 &lt;code&gt;case&lt;/code&gt; 提到的任何自由变量的类型都必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="745bb7ba75f0f40b920b56af8d91fc7035fd3d5d" translate="yes" xml:space="preserve">
          <source>The type of immutable non-strict (boxed) arrays with indices in &lt;code&gt;i&lt;/code&gt; and elements in &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">不可变的非严格（装箱）数组的类型，其索引在 &lt;code&gt;i&lt;/code&gt; 中，元素在 &lt;code&gt;e&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="635ffd579754d6af7e5c946097cca0d521883477" translate="yes" xml:space="preserve">
          <source>The type of non-empty streams</source>
          <target state="translated">非空流的类型</target>
        </trans-unit>
        <trans-unit id="baf7178ecc15f8f15e23e50e1c918ba63de7aef2" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;enum&lt;/code&gt; method is &lt;code&gt;[a]&lt;/code&gt;, and this is also the type of the default method. You can lift this restriction and give another type to the default method using the extension &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;. For instance, if you have written a generic implementation of enumeration in a class &lt;code&gt;GEnum&lt;/code&gt; with method &lt;code&gt;genum&lt;/code&gt; in terms of &lt;code&gt;GHC.Generics&lt;/code&gt;, you can specify a default method that uses that generic implementation:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 方法的类型为 &lt;code&gt;[a]&lt;/code&gt; ，这也是默认方法的类型。您可以取消此限制，并使用扩展名&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;为默认方法提供其他类型。例如，如果你在一个类写一个通用实现枚举的 &lt;code&gt;GEnum&lt;/code&gt; 与方法 &lt;code&gt;genum&lt;/code&gt; 来讲 &lt;code&gt;GHC.Generics&lt;/code&gt; ，你可以指定一个默认的方法，它使用通用的实现：</target>
        </trans-unit>
        <trans-unit id="5a6d2b6921b02fa113109fd505bf3ca7ae784ac9" translate="yes" xml:space="preserve">
          <source>The type of the argument can, as usual, be more general than the type required, as &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; shows. (&lt;code&gt;reverse&lt;/code&gt; does not need the &lt;code&gt;Ord&lt;/code&gt; constraint.)</source>
          <target state="translated">正如 &lt;code&gt;(MkSwizzle reverse)&lt;/code&gt; 所示，参数的类型通常可以比所需的类型更一般。（ &lt;code&gt;reverse&lt;/code&gt; 不需要 &lt;code&gt;Ord&lt;/code&gt; 约束。）</target>
        </trans-unit>
        <trans-unit id="a3cd0d91471726689bc984c8ebae6cee3ed30fb7" translate="yes" xml:space="preserve">
          <source>The type of the entire &lt;code&gt;case&lt;/code&gt; expression must be rigid.</source>
          <target state="translated">整个 &lt;code&gt;case&lt;/code&gt; 表达式的类型必须是固定的。</target>
        </trans-unit>
        <trans-unit id="2dd2e80c536cca089cdcb5a70cf104cd60ae01b1" translate="yes" xml:space="preserve">
          <source>The type of the expression being updated will not be inferred, and no constraint-solving will be performed, so the following will be rejected as ambiguous:</source>
          <target state="translated">被更新的表达式的类型不会被推断出来,也不会进行约束解,所以以下内容会被视为模棱两可而被拒绝。</target>
        </trans-unit>
        <trans-unit id="3a2054583d66d61226f35d028b4a26f1b1f3dc5b" translate="yes" xml:space="preserve">
          <source>The type of the object must be an instance of &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, which ensures that only monomorphically-typed objects may be converted to &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;. To convert a polymorphic object into &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt;, give it a monomorphic type signature. For example:</source>
          <target state="translated">对象的类型必须是 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 的实例，以确保只能将单态类型的对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 。要将多态对象转换为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; ，请为其提供单态类型签名。例如：</target>
        </trans-unit>
        <trans-unit id="459ed51d92aa384f112f0d4508119aa781e99a11" translate="yes" xml:space="preserve">
          <source>The type of the record that holds lexical parsers that work on &lt;code&gt;s&lt;/code&gt; streams with state &lt;code&gt;u&lt;/code&gt; over a monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">该类型保存词法分析器是工作记录的 &lt;code&gt;s&lt;/code&gt; 与国家流 &lt;code&gt;u&lt;/code&gt; 在单子 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a771e46469f4ad150a88bc265d7240c0b42178a7" translate="yes" xml:space="preserve">
          <source>The type of the scrutinee must be rigid.</source>
          <target state="translated">审稿人的类型必须是刚性的。</target>
        </trans-unit>
        <trans-unit id="979bbf6913a49836de61dced0e41ea9872ed2cf7" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;c_m&lt;/code&gt; occurs once in each of the type variables of &lt;code&gt;T1&lt;/code&gt; through &lt;code&gt;Tk&lt;/code&gt;. Imagine a class where this condition didn&amp;rsquo;t hold. For example:</source>
          <target state="translated">类型参数 &lt;code&gt;c_m&lt;/code&gt; 在 &lt;code&gt;T1&lt;/code&gt; 到 &lt;code&gt;Tk&lt;/code&gt; 的每个类型变量中出现一次。想象一个没有这种情况的课堂。例如：</target>
        </trans-unit>
        <trans-unit id="d8d7616108b7358a6ff7d651d02802bd3f54a508" translate="yes" xml:space="preserve">
          <source>The type parameter should be an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型参数应该是 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="72be687a9472d52b3ba6b265c8d95d06ffd98dec" translate="yes" xml:space="preserve">
          <source>The type parameters must all be type variables, of course, and some (but not necessarily all) of then can be the class parameters. Each class parameter may only be used at most once per associated type, but some may be omitted and they may be in an order other than in the class head. Hence, the following contrived example is admissible:</source>
          <target state="translated">当然,类型参数必须都是类型变量,其中一些(但不一定全部)可以是类参数。每个类参数在每个关联类型中最多只能使用一次,但有些可以省略,它们的顺序也可以不在类头中。因此,下面这个人为的例子是可以接受的。</target>
        </trans-unit>
        <trans-unit id="e48ed805d22716f6596791f0192736bc9bd803b6" translate="yes" xml:space="preserve">
          <source>The type patterns in this pair equal if &lt;code&gt;x&lt;/code&gt; is replaced by an infinite nesting of lists. Rejecting instances such as these is necessary for type soundness.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 被列表的无限嵌套替换，则这对中的类型模式相等。对于类型健全性，必须拒绝此类实例。</target>
        </trans-unit>
        <trans-unit id="851ffb061ccd0ba4140a0e2aced43cb02b2b4642" translate="yes" xml:space="preserve">
          <source>The type signature for &lt;code&gt;f&lt;/code&gt; brings the type variable &lt;code&gt;a&lt;/code&gt; into scope, because of the explicit &lt;code&gt;forall&lt;/code&gt; (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;). The type variables bound by a &lt;code&gt;forall&lt;/code&gt; scope over the entire definition of the accompanying value declaration. In this example, the type variable &lt;code&gt;a&lt;/code&gt; scopes over the whole definition of &lt;code&gt;f&lt;/code&gt;, including over the type signature for &lt;code&gt;ys&lt;/code&gt;. In Haskell 98 it is not possible to declare a type for &lt;code&gt;ys&lt;/code&gt;; a major benefit of scoped type variables is that it becomes possible to do so.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的类型签名使类型变量 &lt;code&gt;a&lt;/code&gt; 进入范围，这是因为显式的 &lt;code&gt;forall&lt;/code&gt; （&lt;a href=&quot;#decl-type-sigs&quot;&gt;声明类型签名&lt;/a&gt;）。由结合的类型变量 &lt;code&gt;forall&lt;/code&gt; 的范围在所附的值声明的整个定义。在此示例中，类型变量 &lt;code&gt;a&lt;/code&gt; 覆盖 &lt;code&gt;f&lt;/code&gt; 的整个定义，包括 &lt;code&gt;ys&lt;/code&gt; 的类型签名。在Haskell 98中，不可能为 &lt;code&gt;ys&lt;/code&gt; 声明一个类型。作用域类型变量的主要好处是可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7656da70988a168a35816a1e6dfaeeb97ff1256b" translate="yes" xml:space="preserve">
          <source>The type signature for a default method of a type class must take on the same form as the corresponding main method&amp;rsquo;s type signature. Otherwise, the typechecker will reject that class&amp;rsquo;s definition. By &amp;ldquo;take on the same form&amp;rdquo;, we mean that the default type signature should differ from the main type signature only in their contexts. Therefore, if you have a method &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">类型类的默认方法的类型签名必须与相应的主方法的类型签名采用相同的形式。否则，类型检查器将拒绝该类的定义。&amp;ldquo;采用相同的形式&amp;rdquo;是指默认类型签名应仅在其上下文中与主要类型签名不同。因此，如果您有一个方法 &lt;code&gt;bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71f24ac949ca33b38012525ec9dbb7d664ab057c" translate="yes" xml:space="preserve">
          <source>The type signature in the instance declaration must be more polymorphic than (or the same as) the one in the class declaration, instantiated with the instance type. For example, this is fine:</source>
          <target state="translated">实例声明中的类型签名必须比类声明中的类型签名更多态(或相同),用实例类型实例化。例如,这样就可以了。</target>
        </trans-unit>
        <trans-unit id="7f2cb1a90a9b0995252c7b308eee2ab22f083907" translate="yes" xml:space="preserve">
          <source>The type signature may have quantified type variables that do not appear in the result type:</source>
          <target state="translated">类型签名可能有量化的类型变量,但没有出现在结果类型中。</target>
        </trans-unit>
        <trans-unit id="0066bd7c09b1311eefbd05fc74e2a7e0fdcf2cfb" translate="yes" xml:space="preserve">
          <source>The type signature of &lt;code&gt;isPrime&lt;/code&gt; informs users that its correctness depends on an unproven conjecture. If the function is used, the user has to acknowledge the dependence with:</source>
          <target state="translated">&lt;code&gt;isPrime&lt;/code&gt; 的类型签名会通知用户其正确性取决于未经证实的猜想。如果使用该功能，则用户必须通过以下方式确认依赖关系：</target>
        </trans-unit>
        <trans-unit id="6889d9f64b4cea7008114f032c7565a988347b9d" translate="yes" xml:space="preserve">
          <source>The type signature of each constructor is independent, and is implicitly universally quantified as usual. In particular, the type variable(s) in the &amp;ldquo;&lt;code&gt;data T a where&lt;/code&gt;&amp;rdquo; header have no scope, and different constructors may have different universally-quantified type variables:</source>
          <target state="translated">每个构造函数的类型签名都是独立的，并且像往常一样隐式地进行通用量化。特别是，&amp;ldquo; &lt;code&gt;data T a where&lt;/code&gt; &amp;rdquo;标头中的类型变量没有作用域，并且不同的构造函数可能具有不同的通用量化类型变量：</target>
        </trans-unit>
        <trans-unit id="534c19947f6b057574c6c2246010e8ba73a4eab7" translate="yes" xml:space="preserve">
          <source>The type used for sizes and sizeBounds of sizes.</source>
          <target state="translated">用于尺寸和sizeBounds的类型。</target>
        </trans-unit>
        <trans-unit id="43178326dfa4ad1ed29dea64db5e0736803b9188" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;a&lt;/code&gt; appears in no other constraints</source>
          <target state="translated">类型变量 &lt;code&gt;a&lt;/code&gt; 没有其他限制</target>
        </trans-unit>
        <trans-unit id="b4943498fbb77950d71e01bb410d131c2809b43c" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;e&lt;/code&gt; used here represents the element type, while &lt;code&gt;ce&lt;/code&gt; is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</source>
          <target state="translated">此处使用的类型变量 &lt;code&gt;e&lt;/code&gt; 表示元素类型，而 &lt;code&gt;ce&lt;/code&gt; 是容器本身的类型。在此框架内，我们可能想为列表或特征函数（两者都可用于表示任何相等类型的集合），位集（可用于表示字符的集合）或哈希定义此类的实例。表（可用于表示其元素具有哈希功能的任何集合）。省略标准实施细节，这将导致以下声明：</target>
        </trans-unit>
        <trans-unit id="1c38092768f402e22883de13c0c16e8f30763372" translate="yes" xml:space="preserve">
          <source>The type variable is quantified by the single, syntactically visible, outermost &lt;code&gt;forall&lt;/code&gt; of the type signature. For example, GHC will reject all of the following examples:</source>
          <target state="translated">类型变量由单一的，语法上可见，最外面的量化 &lt;code&gt;forall&lt;/code&gt; 的类型签名的。例如，GHC将拒绝以下所有示例：</target>
        </trans-unit>
        <trans-unit id="d1965a58b0782ba3ba393196ffb0b2c45422203a" translate="yes" xml:space="preserve">
          <source>The type variables (if given) may be explicitly kinded, so we could also write the header for &lt;code&gt;Foo&lt;/code&gt; like this:</source>
          <target state="translated">类型变量（如果给定的话）可能是显式的，所以我们也可以这样写 &lt;code&gt;Foo&lt;/code&gt; 的头文件：</target>
        </trans-unit>
        <trans-unit id="635b4f657c280b661bdb956cc7379ca577a5dd9a" translate="yes" xml:space="preserve">
          <source>The type variables &lt;code&gt;vk+1...vn&lt;/code&gt; do not occur in the types &lt;code&gt;t&lt;/code&gt;, &lt;code&gt;s1..sk&lt;/code&gt;, or &lt;code&gt;t1..tj&lt;/code&gt;.</source>
          <target state="translated">类型变量 &lt;code&gt;vk+1...vn&lt;/code&gt; 不在类型 &lt;code&gt;t&lt;/code&gt; ， &lt;code&gt;s1..sk&lt;/code&gt; 或 &lt;code&gt;t1..tj&lt;/code&gt; 中出现。</target>
        </trans-unit>
        <trans-unit id="0367b19eac21df607dd1a0c03766f0d72dc00eb4" translate="yes" xml:space="preserve">
          <source>The type variables in the head of a &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;instance&lt;/code&gt; declaration scope over the methods defined in the &lt;code&gt;where&lt;/code&gt; part. You do not even need an explicit &lt;code&gt;forall&lt;/code&gt; (although you are allowed an explicit &lt;code&gt;forall&lt;/code&gt; in an &lt;code&gt;instance&lt;/code&gt; declaration; see &lt;a href=&quot;#explicit-foralls&quot;&gt;Explicit universal quantification (forall)&lt;/a&gt;). For example:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;instance&lt;/code&gt; 声明的头部中的类型变量作用于 &lt;code&gt;where&lt;/code&gt; 部分中定义的方法。您甚至不需要显式的 &lt;code&gt;forall&lt;/code&gt; （尽管在 &lt;code&gt;instance&lt;/code&gt; 声明中允许显式的 &lt;code&gt;forall&lt;/code&gt; ；请参阅&lt;a href=&quot;#explicit-foralls&quot;&gt;显式通用量化（forall）&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="af20cee98cf274e2f035d875bbac735384b7ac2d" translate="yes" xml:space="preserve">
          <source>The type variables on the right hand side of the type family equation must, as usual, be explicitly bound by the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound. For example, these are legitimate:</source>
          <target state="translated">通常，类型族方程右侧的类型变量必须由左侧明确绑定。对于&lt;em&gt;种类&lt;/em&gt;变量，此限制放宽了，但是，因为允许右侧提到隐式绑定的种类变量。例如，这些是合法的：</target>
        </trans-unit>
        <trans-unit id="84e64daabc652df729898a89399f171ba5fb963f" translate="yes" xml:space="preserve">
          <source>The type variables: &lt;code&gt;a b ..&lt;/code&gt;</source>
          <target state="translated">类型变量： &lt;code&gt;a b ..&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3336a5e221e837a924af361dde3fa8fafd4e883" translate="yes" xml:space="preserve">
          <source>The type-level equivalent of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型级别等效于 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51833098f3f8dc039531765e941df75d867dbd6d" translate="yes" xml:space="preserve">
          <source>The type-safe cast operation</source>
          <target state="translated">类型安全浇注操作</target>
        </trans-unit>
        <trans-unit id="587a72d06270d5ada9648f212a80e7c9f1025cdd" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, the classes &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; and casting between Word32 and Float and Word64 and Double.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，类 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 以及在Word32和Float以及Word64和Double之间进行转换。</target>
        </trans-unit>
        <trans-unit id="41579a31faecdff7eb564e18d1f5224721d9b9c2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; are once again type-level proxies, just used to create several variants of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S&quot;&gt;S&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C&quot;&gt;C&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D&quot;&gt;D&lt;/a&gt;&lt;/code&gt; 再次是类型级别的代理，仅用于创建 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 的多个变体。</target>
        </trans-unit>
        <trans-unit id="6e810d6a26e49cbbb2492c272a8362cc5c02deb2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt;, and the classes &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Ratio&quot;&gt;Ratio&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Rational&quot;&gt;Rational&lt;/a&gt;&lt;/code&gt; ，以及类 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#t:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48ea1d3d0cd4b9a0ed9e5c243628ebffae4d7214" translate="yes" xml:space="preserve">
          <source>The types alone do not enforce these laws, so you'll have to check them yourself.</source>
          <target state="translated">单纯的类型是不会执行这些法律的,所以你要自己去查。</target>
        </trans-unit>
        <trans-unit id="a0cd438c82f2c05948aa7d6cb52d631f7b43ae69" translate="yes" xml:space="preserve">
          <source>The types of the additional holes in refinement hole fits are displayed in the output, e.g. &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; is a refinement for the hole &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt;. If this flag is toggled off, the output will display only &lt;code&gt;foldl1 _&lt;/code&gt;, which can be used as a direct replacement for the hole, without requiring &lt;code&gt;-XScopedTypeVariables&lt;/code&gt;.</source>
          <target state="translated">细孔配合中其他孔的类型显示在输出中，例如 &lt;code&gt;foldl1 (_ :: a -&amp;gt; a -&amp;gt; a)&lt;/code&gt; 是孔 &lt;code&gt;_ :: [a] -&amp;gt; a&lt;/code&gt; 的细化。如果关闭此标志，则输出将仅显示 &lt;code&gt;foldl1 _&lt;/code&gt; ，可以将其直接替换为孔，而无需 &lt;code&gt;-XScopedTypeVariables&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e436a3cd3a5f7288599b9dc44ff4a6cead76bb9b" translate="yes" xml:space="preserve">
          <source>The typical use of unboxed tuples is simply to return multiple values, binding those multiple results with a &lt;code&gt;case&lt;/code&gt; expression, thus:</source>
          <target state="translated">未装箱元组的典型用法是简单地返回多个值，并将这些多个结果与 &lt;code&gt;case&lt;/code&gt; 表达式绑定在一起，因此：</target>
        </trans-unit>
        <trans-unit id="83c5520bf61af07b81095eddaa98572a93badb2f" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation.</source>
          <target state="translated">地图列表的结合,并进行组合操作。</target>
        </trans-unit>
        <trans-unit id="b23e039e05803f1d435b095a3be2c2ad316fc53b" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-lazy#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9719fd151f851952631d41cb987f9951e7aa35cd" translate="yes" xml:space="preserve">
          <source>The union of a list of maps, with a combining operation: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集，并带有合并操作：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionsWith&quot;&gt;unionsWith&lt;/a&gt; f == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; (&lt;a href=&quot;data-map-strict#v:unionWith&quot;&gt;unionWith&lt;/a&gt; f) &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a6d65bd708163831054fd39465f70221e9e5ae24" translate="yes" xml:space="preserve">
          <source>The union of a list of maps.</source>
          <target state="translated">地图列表的结合。</target>
        </trans-unit>
        <trans-unit id="0eef324f1a749e58701da2776b9ed04269a8f3da" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f822cc3b31dd5e47c32c226b0091a2baecc772ee" translate="yes" xml:space="preserve">
          <source>The union of a list of maps: (&lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">地图列表的并集：（ &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/prelude#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="79b141fce6e886ba88eb4e367332c9cfb39cd808" translate="yes" xml:space="preserve">
          <source>The union of a list of sets.</source>
          <target state="translated">一组列表的结合。</target>
        </trans-unit>
        <trans-unit id="a0436ce0333db453178d1bb27860d26164bc30d6" translate="yes" xml:space="preserve">
          <source>The union of the sets in a Foldable structure : (&lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">可折叠结构中集合的并集：（ &lt;code&gt;&lt;a href=&quot;data-set#v:unions&quot;&gt;unions&lt;/a&gt; == &lt;a href=&quot;data-set#v:foldl&quot;&gt;foldl&lt;/a&gt; &lt;a href=&quot;data-set#v:union&quot;&gt;union&lt;/a&gt; &lt;a href=&quot;data-set#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="84d32e19c18412fa13a69a4d3cce159a043b6669" translate="yes" xml:space="preserve">
          <source>The unique numeric ID for this group (gr_gid)</source>
          <target state="translated">该组的唯一数字ID(gr_gid)</target>
        </trans-unit>
        <trans-unit id="212144f380f03e225a7d36c34f05e2ff45aba6e6" translate="yes" xml:space="preserve">
          <source>The unit type &lt;code&gt;()&lt;/code&gt; and the list type &lt;code&gt;[]&lt;/code&gt; are added to the start of the standard list of types which are tried when doing type defaulting.</source>
          <target state="translated">将单元类型 &lt;code&gt;()&lt;/code&gt; 和列表类型 &lt;code&gt;[]&lt;/code&gt; 添加到标准类型列表的开头，这些类型在进行类型默认设置时会尝试使用。</target>
        </trans-unit>
        <trans-unit id="e05fd75092f26b39420e90105c4452458f344690" translate="yes" xml:space="preserve">
          <source>The unpackedness of a field as the user wrote it in the source code. For example, in the following data type:</source>
          <target state="translated">用户在源码中写的字段的解包性。例如,在以下数据类型中:</target>
        </trans-unit>
        <trans-unit id="bf60d2a5c5d09194c3ba4034c0529e6a606e32cc" translate="yes" xml:space="preserve">
          <source>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then &lt;code&gt;hs_exit()&lt;/code&gt; may hang (or possibly busy-wait) until the calls return. Therefore it&amp;rsquo;s a good idea to make sure you don&amp;rsquo;t have any such threads in the system when calling &lt;code&gt;hs_exit()&lt;/code&gt;. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</source>
          <target state="translated">这样的结果是，如果您的Haskell线程在外部调用中被阻塞，则 &lt;code&gt;hs_exit()&lt;/code&gt; 可能会挂起（或可能忙于等待），直到调用返回。因此，最好在调用 &lt;code&gt;hs_exit()&lt;/code&gt; 时确保系统中没有此类线程。这包括执行I / O的任何线程，因为可以使用阻止外部调用来实现I / O（或可以不取决于I / O的类型和平台）。</target>
        </trans-unit>
        <trans-unit id="fd5ed5363995c4cea70a22ac737d595e21dc4544" translate="yes" xml:space="preserve">
          <source>The use of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; to compile &lt;code&gt;Danger&lt;/code&gt; restricts the features of Haskell that can be used to a &lt;a href=&quot;#safe-language&quot;&gt;safe subset&lt;/a&gt;. This includes disallowing &lt;code&gt;unsafePerformIO&lt;/code&gt;, Template Haskell, pure FFI functions, RULES and restricting the operation of Overlapping Instances. The &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag also restricts the modules can be imported by &lt;code&gt;Danger&lt;/code&gt; to only those that are considered trusted. Trusted modules are those compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, where GHC provides a mechanical guarantee that the code is safe. Or those modules compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, where the module author claims that the module is Safe.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译 &lt;code&gt;Danger&lt;/code&gt; 限制了可用于&lt;a href=&quot;#safe-language&quot;&gt;安全子集&lt;/a&gt;的Haskell功能。这包括禁止使用 &lt;code&gt;unsafePerformIO&lt;/code&gt; ，模板Haskell，纯FFI函数，规则和限制重叠实例的操作。该&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志也限制了模块可以通过进口 &lt;code&gt;Danger&lt;/code&gt; ，只有那些被认为是可信的。受信任的模块是使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的模块，其中GHC提供了机械确保代码安全的保证。或那些使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的模块，其中模块作者声称该模块是安全的。</target>
        </trans-unit>
        <trans-unit id="76408d263ea83823caa29289a23caf377016849f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*&lt;/code&gt; to denote the kind of inhabited types relies on the &lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt;&lt;code&gt;StarIsType&lt;/code&gt;&lt;/a&gt; extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC proposal #30&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 表示居住类型的类型取决于&lt;a href=&quot;glasgow_exts#extension-StarIsType&quot;&gt; &lt;code&gt;StarIsType&lt;/code&gt; &lt;/a&gt;扩展名，该扩展名在将来的版本中将默认关闭，然后可能会删除。&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0030-remove-star-kind.rst&quot;&gt;GHC提案＃30中&lt;/a&gt;对此原因和弃用时间表进行了说明。</target>
        </trans-unit>
        <trans-unit id="a443865b645e76d78a948d7d73f2496761df0274" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;?x&lt;/code&gt; in the binding for &lt;code&gt;?y&lt;/code&gt; does not &amp;ldquo;see&amp;rdquo; the binding for &lt;code&gt;?x&lt;/code&gt;, so the type of &lt;code&gt;f&lt;/code&gt; is</source>
          <target state="translated">在 &lt;code&gt;?y&lt;/code&gt; 的绑定中使用 &lt;code&gt;?x&lt;/code&gt; 不会&amp;ldquo;看到&amp;rdquo; &lt;code&gt;?x&lt;/code&gt; 的绑定，因此 &lt;code&gt;f&lt;/code&gt; 的类型为</target>
        </trans-unit>
        <trans-unit id="6962747001f3e463de123d47ef1692d0e218a535" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="2dbc79a4883471be7b0186b057046ae7dfdc1e0b" translate="yes" xml:space="preserve">
          <source>The use of this function is quite stylized - one imports the appropiate language definition and selects the lexical parsers that are needed from the resulting &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数的使用已被风格化了-导入适当的语言定义并从生成的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 中选择所需的词法解析器。</target>
        </trans-unit>
        <trans-unit id="26730cfbec649d68d217865bf13abfb7172eb1ff" translate="yes" xml:space="preserve">
          <source>The usefulness of cost-centre stacks is better demonstrated by modifying the example slightly:</source>
          <target state="translated">稍微修改一下这个例子,就能更好地证明成本中心堆栈的作用。</target>
        </trans-unit>
        <trans-unit id="04516ad04a116cb6b3a9eecd21c1a49b5a9b220f" translate="yes" xml:space="preserve">
          <source>The user can optionally declare the desired &lt;a href=&quot;#deriving-stragies&quot;&gt;deriving strategy&lt;/a&gt;, especially if the compiler chooses the wrong one &lt;a href=&quot;#default-deriving-strategy&quot;&gt;by default&lt;/a&gt;.</source>
          <target state="translated">用户可以选择声明所需的&lt;a href=&quot;#deriving-stragies&quot;&gt;派生策略&lt;/a&gt;，特别是如果编译器&lt;a href=&quot;#default-deriving-strategy&quot;&gt;默认&lt;/a&gt;选择了错误的派生策略。</target>
        </trans-unit>
        <trans-unit id="2b6318421e47e29c50f821a4cb593213b3cf90b5" translate="yes" xml:space="preserve">
          <source>The user database</source>
          <target state="translated">用户数据库</target>
        </trans-unit>
        <trans-unit id="985a9c88151c387783de3c084f48215ba9fd8373" translate="yes" xml:space="preserve">
          <source>The usual output stream is &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;. For Windows GUI applications (that have no stderr) the output is directed to the Windows debug console. Some implementations of these functions may decorate the string that's output to indicate that you're tracing.</source>
          <target state="translated">通常的输出流是 &lt;code&gt;&lt;a href=&quot;system-io#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 。对于Windows GUI应用程序（没有stderr），输出将定向到Windows调试控制台。这些函数的某些实现可能会修饰输出的字符串，以指示您正在跟踪。</target>
        </trans-unit>
        <trans-unit id="5b635ec2e13718c809af8ad02bfe21b9ad380c51" translate="yes" xml:space="preserve">
          <source>The value at the given index in an array.</source>
          <target state="translated">数组中给定索引的值。</target>
        </trans-unit>
        <trans-unit id="46ea80b9df5d3660b22bccd45dcec6dcfc82dba3" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; (see &lt;a href=&quot;phases#c-pre-processor&quot;&gt;Options affecting the C pre-processor&lt;/a&gt;) for a major release &lt;code&gt;x.y.z&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.8.2 of GHC we would have &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt;).</source>
          <target state="translated">主要版本 &lt;code&gt;x.y.z&lt;/code&gt; 的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值（请参阅&lt;a href=&quot;phases#c-pre-processor&quot;&gt;影响C预处理程序的选项&lt;/a&gt;）是整数⟨xyy⟩（如果⟨y⟩是一位数字，则添加前导零，例如在版本6.8.2中）我们将拥有 &lt;code&gt;__GLASGOW_HASKELL__==608&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9f2f912f328420400217d42f0703423875720dd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; for a snapshot release is the integer ⟨xyy⟩. You should never write any conditional code which tests for this value, however: since interfaces change on a day-to-day basis, and we don&amp;rsquo;t have finer granularity in the values of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;, you should only conditionally compile using predicates which test whether &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is equal to, later than, or earlier than a given major release.</source>
          <target state="translated">快照版本的 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值为整数⟨xyy⟩。但是，您永远不应编写任何测试该值的条件代码：由于接口每天都在变化，并且我们在 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值中没有更细的粒度，因此您仅应使用可测试该条件的谓词进行条件编译是否 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 等于，晚于或早于给定的主要版本。</target>
        </trans-unit>
        <trans-unit id="88bc0b8a4e725cfca8629af95b9bfc3789cec929" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;seq a b&lt;/code&gt; is bottom if &lt;code&gt;a&lt;/code&gt; is bottom, and otherwise equal to &lt;code&gt;b&lt;/code&gt;. In other words, it evaluates the first argument &lt;code&gt;a&lt;/code&gt; to weak head normal form (WHNF). &lt;code&gt;seq&lt;/code&gt; is usually introduced to improve performance by avoiding unneeded laziness.</source>
          <target state="translated">的值 &lt;code&gt;seq a b&lt;/code&gt; 是底部，如果 &lt;code&gt;a&lt;/code&gt; 是底部，否则等于 &lt;code&gt;b&lt;/code&gt; 。换句话说，它将第一个参数 &lt;code&gt;a&lt;/code&gt; 评估为弱头范式（WHNF）。通常引入 &lt;code&gt;seq&lt;/code&gt; 来避免不必要的懒惰，从而提高性能。</target>
        </trans-unit>
        <trans-unit id="b9ddf1473b8cefa80d18a48c0a819936c1f6abc1" translate="yes" xml:space="preserve">
          <source>The value of the GHC flag &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; at compile/link time.</source>
          <target state="translated">在编译/链接时，GHC标志 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="16d740d7f1efaee618fc89b84be2bf2b95e0d2bb" translate="yes" xml:space="preserve">
          <source>The variable&amp;rsquo;s type is not polymorphic, is not &lt;code&gt;()&lt;/code&gt;, and is an instance of &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">变量的类型不是多态的，不是 &lt;code&gt;()&lt;/code&gt; ，并且是 &lt;code&gt;Show&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="a0d33e4220ed576dc1b282f848ba5c762001d9e7" translate="yes" xml:space="preserve">
          <source>The variables in the left-hand side of the definition are bound by the pattern on the right-hand side. For bidirectional pattern synonyms, all the variables of the right-hand side must also occur on the left-hand side; also, wildcard patterns and view patterns are not allowed. For unidirectional and explicitly bidirectional pattern synonyms, there is no restriction on the right-hand side pattern.</source>
          <target state="translated">左手边定义中的变量被右手边的模式所约束。对于双向模式同义词,右侧的所有变量也必须出现在左侧;另外,不允许使用通配符模式和视图模式。对于单向和明确的双向模式同义词,对右侧模式没有限制。</target>
        </trans-unit>
        <trans-unit id="44137130cdaca8e0c4502b29129e5daf2347a2a8" translate="yes" xml:space="preserve">
          <source>The variant (&amp;ldquo;way&amp;rdquo;) of the runtime. The most common values are &lt;code&gt;rts_v&lt;/code&gt; (vanilla), &lt;code&gt;rts_thr&lt;/code&gt; (threaded runtime, i.e. linked using the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option) and &lt;code&gt;rts_p&lt;/code&gt; (profiling runtime, i.e. linked using the &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option). Other variants include &lt;code&gt;debug&lt;/code&gt; (linked using &lt;a href=&quot;phases#ghc-flag--debug&quot;&gt;&lt;code&gt;-debug&lt;/code&gt;&lt;/a&gt;), and &lt;code&gt;dyn&lt;/code&gt; (the RTS is linked in dynamically, i.e. a shared library, rather than statically linked into the executable itself). These can be combined, e.g. you might have &lt;code&gt;rts_thr_debug_p&lt;/code&gt;.</source>
          <target state="translated">运行时的变体（&amp;ldquo;方式&amp;rdquo;）。最常见的值是 &lt;code&gt;rts_v&lt;/code&gt; （香草）， &lt;code&gt;rts_thr&lt;/code&gt; （螺纹运行时，即，链接使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;选项）和 &lt;code&gt;rts_p&lt;/code&gt; （仿形运行时，即，链接使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项）。其他变体包括 &lt;code&gt;debug&lt;/code&gt; （使用&lt;a href=&quot;phases#ghc-flag--debug&quot;&gt; &lt;code&gt;-debug&lt;/code&gt; &lt;/a&gt;链接）和 &lt;code&gt;dyn&lt;/code&gt; （RTS是动态链接的，即共享库，而不是静态链接到可执行文件本身）。这些可以组合，例如，您可能具有 &lt;code&gt;rts_thr_debug_p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a8f2c46e457eee624cced1b694975c68f48a5a2" translate="yes" xml:space="preserve">
          <source>The various communicating processes need to aggree on the keys used to refer to the values in the Static Pointer Table, or lookups will fail. Only processes launched from the same program binary are guaranteed to use the same set of keys.</source>
          <target state="translated">不同的通信进程需要在用于引用静态指针表中的值的键上达成一致,否则查找将失败。只有从同一个程序二进制启动的进程才能保证使用同一组键。</target>
        </trans-unit>
        <trans-unit id="5694e81946ac8e88f6e63d9e40df994b86b3e941" translate="yes" xml:space="preserve">
          <source>The version number of your copy of GHC can be found by invoking &lt;code&gt;ghc&lt;/code&gt; with the &lt;code&gt;--version&lt;/code&gt; flag (see &lt;a href=&quot;using#options-help&quot;&gt;Verbosity options&lt;/a&gt;).</source>
          <target state="translated">您可以通过使用 &lt;code&gt;--version&lt;/code&gt; 标志调用 &lt;code&gt;ghc&lt;/code&gt; 来找到GHC副本的版本号（请参见&lt;a href=&quot;using#options-help&quot;&gt;Verbosity选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e8aa9d1f5c524e0cde85db6f3babdf5d9554847" translate="yes" xml:space="preserve">
          <source>The version of &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; with which the program was compiled or is being interpreted.</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;system-info#v:compilerName&quot;&gt;compilerName&lt;/a&gt;&lt;/code&gt; 与该程序被编译或正在解释。</target>
        </trans-unit>
        <trans-unit id="bb35b8767806f1c86c957b959147f402a711b5a1" translate="yes" xml:space="preserve">
          <source>The version of GHC used to compile this program.</source>
          <target state="translated">编译此程序时使用的GHC版本。</target>
        </trans-unit>
        <trans-unit id="93227c16b6d7c528eff0c93942527f094cd10bec" translate="yes" xml:space="preserve">
          <source>The vertices of a list of strongly connected components.</source>
          <target state="translated">强连接组件列表的顶点。</target>
        </trans-unit>
        <trans-unit id="d6e05e606713f53ba7147a93b159172282b0b43c" translate="yes" xml:space="preserve">
          <source>The vertices of a strongly connected component.</source>
          <target state="translated">强连接分量的顶点。</target>
        </trans-unit>
        <trans-unit id="49a2297af6458fc2b5c07ab0b04fc8ce1dcc5198" translate="yes" xml:space="preserve">
          <source>The visibility of class parameters in the right-hand side of associated family instances depends &lt;em&gt;solely&lt;/em&gt; on the parameters of the family. As an example, consider the simple class declaration</source>
          <target state="translated">类参数在相关族实例右侧的可见性&lt;em&gt;仅&lt;/em&gt;取决于族的参数。例如，考虑简单的类声明</target>
        </trans-unit>
        <trans-unit id="7c87aaad206da2e888073ea427b97a0356ce2035" translate="yes" xml:space="preserve">
          <source>The warning &lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt;&lt;code&gt;-Wdodgy-imports&lt;/code&gt;&lt;/a&gt;, which is off by default but included with &lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;, warns if you hide something that the imported module does not export.</source>
          <target state="translated">警告&lt;a href=&quot;using-warnings#ghc-flag--Wdodgy-imports&quot;&gt; &lt;code&gt;-Wdodgy-imports&lt;/code&gt; &lt;/a&gt;，默认情况下处于关闭状态，但包含在&lt;a href=&quot;using-warnings#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 中&lt;/a&gt;，如果您隐藏了导入的模块不导出的内容，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="a03cd870af60a97e6c37efe987b7dd2cccef087d" translate="yes" xml:space="preserve">
          <source>The warning is suppressed for names beginning with an underscore. For example</source>
          <target state="translated">对于以下划线开头的名字,警告会被抑制。例如</target>
        </trans-unit>
        <trans-unit id="aac2dafa10e3a823b7ded12b65eef4e083b63750" translate="yes" xml:space="preserve">
          <source>The warning is suppressed if the field name begins with an underscore.</source>
          <target state="translated">如果字段名以下划线开头,则该警告将被抑制。</target>
        </trans-unit>
        <trans-unit id="09e93405f4f9b2ea4174a8ddd6b288e044b33e0d" translate="yes" xml:space="preserve">
          <source>The warning will indicate the duplicated &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示重复的 &lt;code&gt;Eq a&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="885ab10c1f8ab02131a671457c0e4e4f86d4a471" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: : it is not used by the definition of &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：： &lt;code&gt;f&lt;/code&gt; 的定义未使用它。）</target>
        </trans-unit>
        <trans-unit id="2c9ca978562d45408d7bbf41edbc42ac363df90f" translate="yes" xml:space="preserve">
          <source>The warning will indicate the redundant &lt;code&gt;Eq a&lt;/code&gt; constraint: it is subsumed by the &lt;code&gt;Ord a&lt;/code&gt; constraint.</source>
          <target state="translated">该警告将指示冗余 &lt;code&gt;Eq a&lt;/code&gt; 约束：它被 &lt;code&gt;Ord a&lt;/code&gt; 包含为约束。</target>
        </trans-unit>
        <trans-unit id="cd02bc31ae80ea7b5041549bb5587f8dbaec0da6" translate="yes" xml:space="preserve">
          <source>The way to get predictable behaviour is to use a &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt; pragma, or an INLINE[⟨phase⟩] pragma, on &lt;code&gt;f&lt;/code&gt;, to ensure that it is not inlined until its RULEs have had a chance to fire. The warning flag &lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt;&lt;code&gt;-Winline-rule-shadowing&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;) warns about this situation.</source>
          <target state="translated">获得可预测行为的方法是在 &lt;code&gt;f&lt;/code&gt; 上使用&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;编译指示或INLINE [⟨phase⟩]编译指示，以确保在规则有机会触发之前不会内联。警告标志&lt;a href=&quot;using-warnings#ghc-flag--Winline-rule-shadowing&quot;&gt; &lt;code&gt;-Winline-rule-shadowing&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全性检查&lt;/a&gt;）对这种情况发出警告。</target>
        </trans-unit>
        <trans-unit id="5013e4baa488d5d314aebcbb6b7fda1ed4bf2dad" translate="yes" xml:space="preserve">
          <source>The way to identify such situations is to have &lt;em&gt;roles&lt;/em&gt; assigned to type variables of datatypes, classes, and type synonyms.</source>
          <target state="translated">识别这种情况的方法是将&lt;em&gt;角色&lt;/em&gt;分配给数据类型，类和类型同义词的类型变量。</target>
        </trans-unit>
        <trans-unit id="dbc05c21c4ca12a5bb342be8ff05e5cc7b28ffad" translate="yes" xml:space="preserve">
          <source>The weak pointers in this library support another approach, called &lt;em&gt;finalization&lt;/em&gt;. When the key referred to by a weak pointer dies, the storage manager arranges to run a programmer-specified finalizer. In the case of memo tables, for example, the finalizer could remove the key/value pair from the memo table.</source>
          <target state="translated">该库中的弱指针支持另一种方法，称为&lt;em&gt;finalization&lt;/em&gt;。当弱指针所指的密钥死亡时，存储管理器安排运行程序员指定的终结器。例如，在备忘录表的情况下，终结器可以从备忘录表中删除键/值对。</target>
        </trans-unit>
        <trans-unit id="16b1e41cdb78be221f6e82549ccc55a1f8ad8616" translate="yes" xml:space="preserve">
          <source>The workaround is to split up the .o files that make up your package into two or more .o&amp;rsquo;s, along the lines of how the &lt;code&gt;base&lt;/code&gt; package does it.</source>
          <target state="translated">解决方法是分裂的.o文件，使你的包成两个或两个以上的.o的，沿该怎么行 &lt;code&gt;base&lt;/code&gt; 包做的。</target>
        </trans-unit>
        <trans-unit id="35b72d62819dbbd936ae83f6354b7de7a85577e3" translate="yes" xml:space="preserve">
          <source>The working dirctory</source>
          <target state="translated">工作车间</target>
        </trans-unit>
        <trans-unit id="535995757af62c46c74a8d0a30d4df43208ca8cc" translate="yes" xml:space="preserve">
          <source>The wrapper and generic default</source>
          <target state="translated">包装器和通用默认值</target>
        </trans-unit>
        <trans-unit id="2e4a6cdea1d1f000843aed4753e1ee986034058e" translate="yes" xml:space="preserve">
          <source>The zips: &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">拉链： &lt;code&gt;&lt;a href=&quot;data-sequence#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="0b5f326239415a00dcecafffd81728af7e4f1c01" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ cannot be &amp;ldquo;&lt;code&gt;e&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;d&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;p&lt;/code&gt;&amp;rdquo;, since those overlap with Template Haskell quotations.</source>
          <target state="translated">&amp;ldquo; quoter&amp;rdquo;不能为&amp;ldquo; &lt;code&gt;e&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;t&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;d&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;p&lt;/code&gt; &amp;rdquo;，因为它们与Template Haskell引用重叠。</target>
        </trans-unit>
        <trans-unit id="24a847f4ac69458f27486855ba65ce23bfdba7ee" translate="yes" xml:space="preserve">
          <source>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</source>
          <target state="translated">⟨quoter⟩必须是导入的报价器名称,可以是有条件的,也可以是无条件的,不能是任意表达式。</target>
        </trans-unit>
        <trans-unit id="f3c92987d54a0ea72d8e1dc17f976a0a34f40d8f" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Foo_stub.h&lt;/code&gt; will contain something like this:</source>
          <target state="translated">然后 &lt;code&gt;Foo_stub.h&lt;/code&gt; 将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="287d60a50242eedc6d56387d9c6ce35ff6a4229d" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;Parser&lt;/code&gt; is an instance of &lt;code&gt;MonadPlus&lt;/code&gt;: monadic sequencing implements concatenation of parsers, while &lt;code&gt;mplus&lt;/code&gt; provides choice. To use parsers, we need a primitive to run a constructed parser on an input string:</source>
          <target state="translated">然后， &lt;code&gt;Parser&lt;/code&gt; 是 &lt;code&gt;MonadPlus&lt;/code&gt; 的一个实例：单子排序实现解析器的串联，而 &lt;code&gt;mplus&lt;/code&gt; 提供选择。要使用解析器，我们需要一个基元来在输入字符串上运行构造的解析器：</target>
        </trans-unit>
        <trans-unit id="24214124afc9b467f1e56cb920ef654013822fb3" translate="yes" xml:space="preserve">
          <source>Then a default method for &lt;code&gt;bar&lt;/code&gt; must take on the form:</source>
          <target state="translated">然后， &lt;code&gt;bar&lt;/code&gt; 的默认方法必须采用以下形式：</target>
        </trans-unit>
        <trans-unit id="aabc9095f750cdfdaf214cd60e3076a836e78de7" translate="yes" xml:space="preserve">
          <source>Then although you can use &lt;code&gt;stdout2&lt;/code&gt; to write to standard output, it is not the case that &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt;.</source>
          <target state="translated">然后，尽管可以使用 &lt;code&gt;stdout2&lt;/code&gt; 写入标准输出，但 &lt;code&gt;&lt;a href=&quot;io#v:stdout&quot;&gt;stdout&lt;/a&gt; == stdout2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bb2935faafd4776cf7e351d968573f0d1e31e63" translate="yes" xml:space="preserve">
          <source>Then applicative desugaring will turn it into</source>
          <target state="translated">然后,涂抹式脱胶将使其变成。</target>
        </trans-unit>
        <trans-unit id="0e055a4cc73e0184385ff381492db1ab945dd588" translate="yes" xml:space="preserve">
          <source>Then come variables the user has written, implicitly brought into scope in a type variable&amp;rsquo;s kind.</source>
          <target state="translated">然后是用户编写的变量，以类型变量的类型隐式地带入范围。</target>
        </trans-unit>
        <trans-unit id="9d1a05c562a8777c9badd7fde0dbd017553d2ffa" translate="yes" xml:space="preserve">
          <source>Then compile it again with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;, and additionally use &lt;code&gt;-osuf
p_o&lt;/code&gt; to name the object files differently (you can choose any suffix that isn&amp;rsquo;t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; flag when building with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; and Template Haskell is used, GHC will emit an error message.</source>
          <target state="translated">然后使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;再次对其进行编译，并另外使用 &lt;code&gt;-osuf p_o&lt;/code&gt; 来对目标文件进行不同的命名（您可以在此处选择不是正常对象后缀的任何后缀）。执行拼接表达式时，GHC将自动加载第一步中构建的目标文件。如果在使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;进行构建时省略了 &lt;code&gt;-osuf ⟨suffix⟩&lt;/code&gt; 标志，并且使用了模板Haskell，则GHC将发出错误消息。</target>
        </trans-unit>
        <trans-unit id="267961b11ee1a950806257a4cbf10ba471301448" translate="yes" xml:space="preserve">
          <source>Then in some importing module &lt;code&gt;M&lt;/code&gt;, the constraint &lt;code&gt;(E a Int)&lt;/code&gt; should be &amp;ldquo;improved&amp;rdquo; by setting &lt;code&gt;a = T&lt;/code&gt;, &lt;em&gt;even though there is no explicit mention&lt;/em&gt; of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">然后，在一些进口模块 &lt;code&gt;M&lt;/code&gt; ，约束 &lt;code&gt;(E a Int)&lt;/code&gt; 设置应为&amp;ldquo;提高&amp;rdquo; &lt;code&gt;a = T&lt;/code&gt; ，&lt;em&gt;尽管没有明确提及&lt;/em&gt;的 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235e255d86c977344be94069c97c451ade72cb56" translate="yes" xml:space="preserve">
          <source>Then it becomes possible to derive a &lt;code&gt;HigherEq Option&lt;/code&gt; instance. Note that the only difference is that now the non-default type signature for &lt;code&gt;(==#)&lt;/code&gt; brings in an &lt;code&gt;Eq a&lt;/code&gt; constraint. Constraints from non-default type signatures never appear in the derived instance context itself, but they can be used to discharge obligations that are demanded by the default type signatures. In the example above, the default type signature demanded an &lt;code&gt;Eq a&lt;/code&gt; instance, and the non-default signature was able to satisfy that request, so the derived instance is simply:</source>
          <target state="translated">这样就可以派生 &lt;code&gt;HigherEq Option&lt;/code&gt; 实例。请注意，唯一的区别是现在 &lt;code&gt;(==#)&lt;/code&gt; 的非默认类型签名引入了一个 &lt;code&gt;Eq a&lt;/code&gt; 约束。来自非默认类型签名的约束永远不会出现在派生实例上下文本身中，但是它们可以用于履行默认类型签名所要求的义务。在上面的示例中，默认类型签名需要一个 &lt;code&gt;Eq a&lt;/code&gt; 实例，并且非默认签名能够满足该请求，因此派生的实例很简单：</target>
        </trans-unit>
        <trans-unit id="99798bf68e94e178e7a793054f2701180898cefe" translate="yes" xml:space="preserve">
          <source>Then it will fail with an error to the effect of:</source>
          <target state="translated">那么它就会以错误的方式失败,大意是:。</target>
        </trans-unit>
        <trans-unit id="c8519f9fb12a86b7dec5b48f34503c863da894e0" translate="yes" xml:space="preserve">
          <source>Then the derived &lt;code&gt;Foo&lt;/code&gt; instance will be:</source>
          <target state="translated">然后派生的 &lt;code&gt;Foo&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="2b6a24fbb16a1dd169092c2ab47c619d87caf81a" translate="yes" xml:space="preserve">
          <source>Then the derived instance declaration is of the form</source>
          <target state="translated">那么派生实例声明的形式是</target>
        </trans-unit>
        <trans-unit id="eeb84bcf4430c9ca69c9cb2ed1cfcc1c124a8d55" translate="yes" xml:space="preserve">
          <source>Then the parser will keep track of how many &lt;code&gt;tick&lt;/code&gt;s it executes.</source>
          <target state="translated">然后，解析器将跟踪它执行了多少个 &lt;code&gt;tick&lt;/code&gt; s。</target>
        </trans-unit>
        <trans-unit id="e5a62b711aedfbcb9ffe97913b28dd5b6da0bf6d" translate="yes" xml:space="preserve">
          <source>Then the rest of the program will use the constructed list of flags to determine it's behaviour.</source>
          <target state="translated">然后程序的其余部分将使用构建的标志列表来决定它的行为。</target>
        </trans-unit>
        <trans-unit id="56cf715d11100588d8255f66af58098ca12ef540" translate="yes" xml:space="preserve">
          <source>Then the result of invoking &lt;code&gt;foo&lt;/code&gt; with &lt;code&gt;args.txt&lt;/code&gt; is:</source>
          <target state="translated">然后，使用 &lt;code&gt;args.txt&lt;/code&gt; 调用 &lt;code&gt;foo&lt;/code&gt; 的结果是：</target>
        </trans-unit>
        <trans-unit id="ae14f36ef7ad89be09b154c46ee11ccd94f3dbb9" translate="yes" xml:space="preserve">
          <source>Then we can run the program like this:</source>
          <target state="translated">然后我们可以这样运行程序。</target>
        </trans-unit>
        <trans-unit id="3e41f47121700ac5c2df677839acdf049e3f9e48" translate="yes" xml:space="preserve">
          <source>Then you can implement your own version of &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; on top of the &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; primitive.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 原语之上实现自己的 &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="1a5eeee560256a85b705cade438380ca2718e1e0" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;many&lt;/em&gt; options that affect the quality of code produced by GHC. Most people only have a general goal, something like &amp;ldquo;Compile quickly&amp;rdquo; or &amp;ldquo;Make my program run like greased lightning.&amp;rdquo; The following &amp;ldquo;packages&amp;rdquo; of optimisations (or lack thereof) should suffice.</source>
          <target state="translated">有&lt;em&gt;许多&lt;/em&gt;影响GHC产生代码质量的选项。大多数人只有一个总体目标，例如&amp;ldquo;快速编译&amp;rdquo;或&amp;ldquo;使我的程序像润滑的闪电般运行&amp;rdquo;。下列优化（或缺乏优化）&amp;ldquo;包装&amp;rdquo;就足够了。</target>
        </trans-unit>
        <trans-unit id="a77fd5209f37754aca85e51e88e8331502ef09cb" translate="yes" xml:space="preserve">
          <source>There are a couple of caveats that will hopefully be removed in the future: this option is currently not implemented on Windows (it is a no-op), and the external interpreter does not support the GHCi debugger, so breakpoints and single-stepping don&amp;rsquo;t work with &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有一些警告可能会在将来被删除：此选项当前未在Windows上实现（它是无操作），并且外部解释器不支持GHCi调试器，因此断点和单步执行不&lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt; &lt;code&gt;-fexternal-interpreter&lt;/code&gt; &lt;/a&gt;不起作用。</target>
        </trans-unit>
        <trans-unit id="238a2c3809b79499c01f2138d09c2d1d9feaad16" translate="yes" xml:space="preserve">
          <source>There are a few flags for controlling the amount of context information shown for typed holes:</source>
          <target state="translated">有几个标志用于控制输入孔的上下文信息显示量。</target>
        </trans-unit>
        <trans-unit id="05f73d7b9e81f28e5b08f63baac61b1c0e9fd698" translate="yes" xml:space="preserve">
          <source>There are a few other profiling-related compilation options. Use them &lt;em&gt;in addition to&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;. These do not have to be used consistently for all modules in a program.</source>
          <target state="translated">还有其他一些与分析相关的编译选项。&lt;em&gt;除了&lt;/em&gt;&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;&lt;em&gt;之外，还要&lt;/em&gt;使用它们。这些不必一定要在程序中的所有模块上一致使用。</target>
        </trans-unit>
        <trans-unit id="bfaa1403a2ac25e9e81e0a2422e4318fed05546d" translate="yes" xml:space="preserve">
          <source>There are a few things to note here.</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="65c24a4a0fbb8909b2a9afa60ebb6820a2bea67a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;case&lt;/code&gt; commands, like</source>
          <target state="translated">还有 &lt;code&gt;case&lt;/code&gt; 命令，例如</target>
        </trans-unit>
        <trans-unit id="771e1589e9fa56b87ca43cc9ff1e2b15e3622f3f" translate="yes" xml:space="preserve">
          <source>There are currently two ways to sort valid hole fits. Sorting can be toggled with &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt;</source>
          <target state="translated">当前有两种方法可以对有效的孔配合进行排序。可以使用 &lt;code&gt;-fsort-valid-hole-fits&lt;/code&gt; 切换排序</target>
        </trans-unit>
        <trans-unit id="9dbf7fd538b1582c001293e373fa1358ed1160bc" translate="yes" xml:space="preserve">
          <source>There are disadvantages to compiling to object-code: you can&amp;rsquo;t set breakpoints in object-code modules, for example. Only the exports of an object-code module will be visible in GHCi, rather than all top-level bindings as in interpreted modules.</source>
          <target state="translated">编译为目标代码有一些缺点：例如，您不能在目标代码模块中设置断点。在GHCi中仅可见目标代码模块的导出，而不是解释模块中的所有顶级绑定。</target>
        </trans-unit>
        <trans-unit id="99abc70961c6ddd5c63e8fff24e698349bbae073" translate="yes" xml:space="preserve">
          <source>There are five new forms of comprehension qualifier, all introduced by the (existing) keyword &lt;code&gt;then&lt;/code&gt;:</source>
          <target state="translated">有五种新的理解限定词形式， &lt;code&gt;then&lt;/code&gt; 由（existing）关键字引入：</target>
        </trans-unit>
        <trans-unit id="b5730f07b618c090c0cbf82d3d38f729cdc48001" translate="yes" xml:space="preserve">
          <source>There are four ways to set RTS options:</source>
          <target state="translated">有四种方法可以设置RTS选项。</target>
        </trans-unit>
        <trans-unit id="b2ec965da649e8c81ce5901a31769ddc2d0814b9" translate="yes" xml:space="preserve">
          <source>There are many datatype-generic functions that do not distinguish between positions that are parameters or positions that are recursive calls. There are also many datatype-generic functions that do not care about the names of datatypes and constructors at all. To keep the number of cases to consider in generic functions in such a situation to a minimum, it turns out that many of the type constructors introduced above are actually synonyms, defining them to be variants of a smaller set of constructors.</source>
          <target state="translated">有许多数据类型-通用函数并不区分作为参数的位置和作为递归调用的位置,也有许多数据类型-通用函数根本不关心数据类型和构造函数的名称。还有很多数据类型-泛型函数根本不关心数据类型和构造函数的名称。为了使通用函数在这种情况下要考虑的情况数量降到最低,结果发现上面介绍的很多类型构造函数实际上是同义词,把它们定义为一个较小的构造函数集的变体。</target>
        </trans-unit>
        <trans-unit id="1a9399599d5316c913ed2356bf5f34b740745168" translate="yes" xml:space="preserve">
          <source>There are many different kinds of profile that can be generated, selected by different RTS options. We will be describing the various kinds of profile throughout the rest of this chapter. Some profiles require further processing using additional tools after running the program.</source>
          <target state="translated">有许多不同种类的配置文件可以生成,由不同的 RTS 选项选择。我们将在本章的其余部分描述各种不同类型的配置文件。有些配置文件需要在程序运行后使用额外的工具进行进一步的处理。</target>
        </trans-unit>
        <trans-unit id="cde574e7b85226578f80e50c9f896820c6ba2e16" translate="yes" xml:space="preserve">
          <source>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels&lt;/a&gt;. Unlike &lt;code&gt;IsString&lt;/code&gt;, there are no special defaulting rules for &lt;code&gt;IsLabel&lt;/code&gt;.</source>
          <target state="translated">没有此类的预定义实例。默认情况下，它不在范围内，但是可以通过导入&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-overloadedlabels&quot;&gt;GHC.OverloadedLabels使其&lt;/a&gt;进入范围。不像 &lt;code&gt;IsString&lt;/code&gt; ，没有特殊的默认规则 &lt;code&gt;IsLabel&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="269b2e3e0b62fd25b64a351c5f6a350824ce3dd4" translate="yes" xml:space="preserve">
          <source>There are no runnable threads, so the program is deadlocked. The &lt;code&gt;Deadlock&lt;/code&gt; exception is raised in the main thread only.</source>
          <target state="translated">没有可运行的线程，因此程序处于死锁状态。该 &lt;code&gt;Deadlock&lt;/code&gt; 例外仅在主线程提高。</target>
        </trans-unit>
        <trans-unit id="beb33239136056ec4e0f1d010703bb7704f0b5d8" translate="yes" xml:space="preserve">
          <source>There are no syntactic changes with &lt;a href=&quot;#extension-ApplicativeDo&quot;&gt;&lt;code&gt;ApplicativeDo&lt;/code&gt;&lt;/a&gt;. The only way it shows up at the source level is that you can have a &lt;code&gt;do&lt;/code&gt; expression that doesn&amp;rsquo;t require a &lt;code&gt;Monad&lt;/code&gt; constraint. For example, in GHCi:</source>
          <target state="translated">&lt;a href=&quot;#extension-ApplicativeDo&quot;&gt; &lt;code&gt;ApplicativeDo&lt;/code&gt; &lt;/a&gt;没有语法变化。它在源代码级别显示的唯一方式是您可以拥有一个不需要 &lt;code&gt;Monad&lt;/code&gt; 约束的 &lt;code&gt;do&lt;/code&gt; 表达式。例如，在GHCi中：</target>
        </trans-unit>
        <trans-unit id="fac55f918da621ac3417ac0d5e66c22c7958b174" translate="yes" xml:space="preserve">
          <source>There are no values of type &lt;code&gt;V1 p&lt;/code&gt; to pass (except undefined), so this is actually impossible. One can ask why it is useful to define an instance for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; at all in this case? Well, an empty type can be used as an argument to a non-empty type, and you might still want to encode the resulting type. As a somewhat contrived example, consider &lt;code&gt;[Empty]&lt;/code&gt;, which is not an empty type, but contains just the empty list. The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance ensures that we can call the generic function on such types.</source>
          <target state="translated">没有要传递的 &lt;code&gt;V1 p&lt;/code&gt; 类型的值（未定义的除外），因此实际上是不可能的。有人会问为什么在这种情况下为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 定义一个实例为什么很有用？好的，可以将空类型用作非空类型的参数，并且您可能仍希望对结果类型进行编码。作为一个有些人为的示例，请考虑 &lt;code&gt;[Empty]&lt;/code&gt; ，它不是空类型，而仅包含空列表。该 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 实例，确保我们能够呼吁这些类型的通用功能。</target>
        </trans-unit>
        <trans-unit id="dda49e2845b7918f36228a92c75280c5c35090c6" translate="yes" xml:space="preserve">
          <source>There are occasions when you really do need to catch any sort of exception. However, in most cases this is just so you can do some cleaning up; you aren't actually interested in the exception itself. For example, if you open a file then you want to close it again, whether processing the file executes normally or throws an exception. However, in these cases you can use functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;, which never actually pass you the exception, but just call the cleanup functions at the appropriate points.</source>
          <target state="translated">在某些情况下，您确实确实需要捕获任何异常。但是，在大多数情况下，这只是为了使您可以进行一些清理。您实际上对异常本身不感兴趣。例如，如果您打开一个文件然后要再次关闭它，则处理文件是正常执行还是引发异常。但是，在这些情况下，您可以使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; 之类的函数，它们实际上不会向您传递异常，而只是在适当的位置调用清除函数。</target>
        </trans-unit>
        <trans-unit id="639f40c3a09baf81a098f96274a0d1a94feb6f6d" translate="yes" xml:space="preserve">
          <source>There are several different access points that you can use for defining plugins that access the representations. All these fields receive the list of &lt;code&gt;CommandLineOption&lt;/code&gt; strings that are passed to the compiler using the &lt;code&gt;-fplugin-opt&lt;/code&gt; flags.</source>
          <target state="translated">您可以使用几种不同的访问点来定义用于访问表示形式的插件。所有这些字段都接收使用 &lt;code&gt;-fplugin-opt&lt;/code&gt; 标志传递给编译器的 &lt;code&gt;CommandLineOption&lt;/code&gt; 字符串列表。</target>
        </trans-unit>
        <trans-unit id="d5c2fccb39860e74a196437dc4b29b1d5931960f" translate="yes" xml:space="preserve">
          <source>There are several different kinds of heap profile that can be generated. All the different profile types yield a graph of live heap against time, but they differ in how the live heap is broken down into bands. The following RTS options select which break-down to use:</source>
          <target state="translated">有几种不同类型的堆配置文件可以生成。所有不同的剖面图类型都会产生一个实时堆与时间的对比图,但它们在如何将实时堆分解成带状方面有所不同。下面的RTS选项可以选择使用哪种分解方式。</target>
        </trans-unit>
        <trans-unit id="59dc5a84493de5e0b4fa021edc7dec2cdb87c983" translate="yes" xml:space="preserve">
          <source>There are several functions for catching and examining exceptions; all of them may only be used from within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">捕获和检查异常有几种功能。所有这些都只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 内部使用。</target>
        </trans-unit>
        <trans-unit id="337f85cb08a97f0edab39052ebaa84e5942811b2" translate="yes" xml:space="preserve">
          <source>There are several options to give you precise control over garbage collection. Hopefully, you won&amp;rsquo;t need any of these in normal operation, but there are several things that can be tweaked for maximum performance.</source>
          <target state="translated">有几个选项可让您精确控制垃圾回收。希望您在正常操作中不需要任何这些，但是为了达到最佳性能，可以进行一些调整。</target>
        </trans-unit>
        <trans-unit id="01c5afb51e2571a4a55001c10a6176945f0a6177" translate="yes" xml:space="preserve">
          <source>There are several other Haskell and GHC-related mailing lists served by &lt;code&gt;www.haskell.org&lt;/code&gt;. Go to &lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;http://www.haskell.org/mailman/listinfo/&lt;/a&gt; for the full list.</source>
          <target state="translated">&lt;code&gt;www.haskell.org&lt;/code&gt; 还提供其他一些与Haskell和GHC相关的邮件列表。有关完整列表，&lt;a href=&quot;http://www.haskell.org/mailman/listinfo/&quot;&gt;请访问http://www.haskell.org/mailman/listinfo/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ad7bd779fbd5beae4e736df98cf99e5f6fe7e9c" translate="yes" xml:space="preserve">
          <source>There are several points to note here:</source>
          <target state="translated">这里有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="784aa0353059aa8ea4162b074576148c1af282a0" translate="yes" xml:space="preserve">
          <source>There are several restrictions on the ways in which existentially-quantified constructors can be used.</source>
          <target state="translated">对于存在量化的构造体的使用方式有几个限制。</target>
        </trans-unit>
        <trans-unit id="bd4c52cde7bbf81cc7e9bbd55c1d798440501cfc" translate="yes" xml:space="preserve">
          <source>There are some other differences regarding what data types can have derived &lt;code&gt;Foldable&lt;/code&gt; instances:</source>
          <target state="translated">关于哪些数据类型可以派生 &lt;code&gt;Foldable&lt;/code&gt; 实例还有一些其他区别：</target>
        </trans-unit>
        <trans-unit id="037468f11530bf3546d6d6b4b426b492e5fe132b" translate="yes" xml:space="preserve">
          <source>There are some other scenarios in which a derived &lt;code&gt;Functor&lt;/code&gt; instance will fail to compile:</source>
          <target state="translated">在某些其他情况下，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将无法编译：</target>
        </trans-unit>
        <trans-unit id="322b63636f583080da1a2074c03c06a60190898f" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of primitive types:</source>
          <target state="translated">对基元类型的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="6714ecb3bd613a0859b0e085d69581a99ba78991" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of unboxed tuples:</source>
          <target state="translated">对未装箱的元组的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="f2c8a53e7498d7f11900cb2cae3b497c5f15ea0f" translate="yes" xml:space="preserve">
          <source>There are three more options which relate to heap profiling:</source>
          <target state="translated">还有三个选项与堆剖析有关。</target>
        </trans-unit>
        <trans-unit id="d3c78fa44479aea5bb07f36a79f3018825c1a8bf" translate="yes" xml:space="preserve">
          <source>There are three new keywords: &lt;code&gt;group&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt;, and &lt;code&gt;using&lt;/code&gt;. (The functions &lt;code&gt;sortWith&lt;/code&gt; and &lt;code&gt;groupWith&lt;/code&gt; are not keywords; they are ordinary functions that are exported by &lt;code&gt;GHC.Exts&lt;/code&gt;.)</source>
          <target state="translated">新增了三个关键字： &lt;code&gt;group&lt;/code&gt; ， &lt;code&gt;by&lt;/code&gt; 和 &lt;code&gt;using&lt;/code&gt; 。（ &lt;code&gt;sortWith&lt;/code&gt; 和 &lt;code&gt;groupWith&lt;/code&gt; 函数不是关键字；它们是 &lt;code&gt;GHC.Exts&lt;/code&gt; 导出的普通函数。）</target>
        </trans-unit>
        <trans-unit id="12e1f881320b3ea52d40fd0c1f40b27e82ba9b3c" translate="yes" xml:space="preserve">
          <source>There are three ways to get access to the current call stack.</source>
          <target state="translated">有三种方法可以获得对当前调用栈的访问。</target>
        </trans-unit>
        <trans-unit id="de26986dee76170f6ec07baa5f2f57d4f2f3bd27" translate="yes" xml:space="preserve">
          <source>There are two classes of special syntax:</source>
          <target state="translated">特殊语法有两类。</target>
        </trans-unit>
        <trans-unit id="ec969b2442b8eecc56a5e56e4a38606a9d6c4714" translate="yes" xml:space="preserve">
          <source>There are two distinct ways in which DLLs can be used:</source>
          <target state="translated">DLL的使用有两种不同的方式。</target>
        </trans-unit>
        <trans-unit id="69520fd35811ca565d4a03687080e48476082679" translate="yes" xml:space="preserve">
          <source>There are two exceptions to this rule:</source>
          <target state="translated">这一规则有两个例外。</target>
        </trans-unit>
        <trans-unit id="6daa1632cd3b54f8ed467624d2b1ea21fe282ac2" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 还有两个其他重要属性：</target>
        </trans-unit>
        <trans-unit id="3c01c12b532e489f2e09eda20a43541fbb8e2c20" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f041a590258ae158bc19338ee5f5bd08e96e3ac" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="608b986739cc6bfe64513cdb88f373b5188a6cbd" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7692866ec9e3ed0746b6d2a44bba6c0047fee10a" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6e9eb556d85a345c9f86d9bb55e006140b1fb7fb" translate="yes" xml:space="preserve">
          <source>There are two further important properties of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有两个重要的特性 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fba4531a8b11c8291da983f4d43d0fb17f51f7ee" translate="yes" xml:space="preserve">
          <source>There are two kinds of ways to execute this decoder, the lazy input method and the incremental input method. Here we will use the lazy input method.</source>
          <target state="translated">这个解码器的执行方式有两种,分别是懒惰输入法和增量输入法。这里我们将使用懒惰输入法。</target>
        </trans-unit>
        <trans-unit id="6e774e84479488317f2efb9ffb8c2bacf8c0269f" translate="yes" xml:space="preserve">
          <source>There are two major differences between sequences and lists:</source>
          <target state="translated">序列和列表之间有两大区别。</target>
        </trans-unit>
        <trans-unit id="dc6af36ef821dae775e5ef867b3bd7dcc5981254" translate="yes" xml:space="preserve">
          <source>There are two things that you can do with this counter:</source>
          <target state="translated">这个柜台有两件事可以做。</target>
        </trans-unit>
        <trans-unit id="1ea5fcd10d6a59a0b100463bc4e292062bdcd770" translate="yes" xml:space="preserve">
          <source>There are two variants of the browse command:</source>
          <target state="translated">浏览命令有两种变体。</target>
        </trans-unit>
        <trans-unit id="de327a3762d47ae125858b0ff7b1122a826b2325" translate="yes" xml:space="preserve">
          <source>There are two ways of using these pragmas.</source>
          <target state="translated">有两种方法可以使用这些实用工具。</target>
        </trans-unit>
        <trans-unit id="8e1b9f93dd0dc44d439a143716f8059fe53f2cd0" translate="yes" xml:space="preserve">
          <source>There are two ways to run a program on multiple processors: call &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt; from your program, or use the RTS &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">有两种方法可以在多个处理器上运行程序：从程序中调用&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:setNumCapabilities&quot;&gt;Control.Concurrent.setNumCapabilities&lt;/a&gt;或使用RTS&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="f2f6a5706b25587b231e13caab60243ec8dfb7a0" translate="yes" xml:space="preserve">
          <source>There can be as many file-header pragmas as you please, and they can be preceded or followed by comments.</source>
          <target state="translated">可以有任意多的文件头实用名,而且可以在它们的前面或后面加上注释。</target>
        </trans-unit>
        <trans-unit id="04a5ab37848c92aef36743d412ae5b5c117d1518" translate="yes" xml:space="preserve">
          <source>There can be at most one default declaration for an associated type synonym.</source>
          <target state="translated">关联类型同义词最多只能有一个默认声明。</target>
        </trans-unit>
        <trans-unit id="dffa4d1ea036ae67d9e2bc55fafeaa6f75d96500" translate="yes" xml:space="preserve">
          <source>There can be multiple calls to &lt;code&gt;hs_init()&lt;/code&gt;, but each one should be matched by one (and only one) call to &lt;code&gt;hs_exit()&lt;/code&gt;. The outermost &lt;code&gt;hs_exit()&lt;/code&gt; will actually de-initialise the system. Note that currently GHC&amp;rsquo;s runtime cannot reliably re-initialise after this has happened; see &lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;The Foreign Function Interface&lt;/a&gt;.</source>
          <target state="translated">可以对 &lt;code&gt;hs_init()&lt;/code&gt; 进行多次调用，但每个调用都应与对hs_exit（）的一个（只有一个）调用 &lt;code&gt;hs_exit()&lt;/code&gt; 。最外面的 &lt;code&gt;hs_exit()&lt;/code&gt; 实际上会取消初始化系统。请注意，当前GHC的运行时在发生这种情况后无法可靠地重新初始化。参见&lt;a href=&quot;bugs#infelicities-ffi&quot;&gt;外部功能接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8238a9e8534ce08f318f309173b6e1d9f39f30cc" translate="yes" xml:space="preserve">
          <source>There can only be one &amp;ldquo;break-down&amp;rdquo; option (eg. &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; in the example above), but there is no limit on the number of further restrictions that may be applied. All the options may be combined, with one exception: GHC doesn&amp;rsquo;t currently support mixing the &lt;a href=&quot;#rts-flag--hr&quot;&gt;&lt;code&gt;-hr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rts-flag--hb&quot;&gt;&lt;code&gt;-hb&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">只能有一个&amp;ldquo;细分&amp;rdquo;选项（例如，上例中的&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;），但是可以应用的进一步限制的数量没有限制。所有的选项可以合并，但有一个例外：GHC目前不支持混合&lt;a href=&quot;#rts-flag--hr&quot;&gt; &lt;code&gt;-hr&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#rts-flag--hb&quot;&gt; &lt;code&gt;-hb&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="c485dde3423005740634757de5268432c646f0a8" translate="yes" xml:space="preserve">
          <source>There is a default value &lt;code&gt;defaultRtsConfig&lt;/code&gt; that should be used to initialise variables of type &lt;code&gt;RtsConfig&lt;/code&gt;. More fields will undoubtedly be added to &lt;code&gt;RtsConfig&lt;/code&gt; in the future, so in order to keep your code forwards-compatible it is best to initialise with &lt;code&gt;defaultRtsConfig&lt;/code&gt; and then modify the required fields, as in the code sample above.</source>
          <target state="translated">有一个默认值 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 应该用于初始化 &lt;code&gt;RtsConfig&lt;/code&gt; 类型的变量。毫无疑问，将来会有更多字段添加到 &lt;code&gt;RtsConfig&lt;/code&gt; ，因此，为了使您的代码向前兼容，最好使用 &lt;code&gt;defaultRtsConfig&lt;/code&gt; 进行初始化，然后修改所需的字段，如上面的代码示例中所示。</target>
        </trans-unit>
        <trans-unit id="5b2325f0000268be99bab7c0c4bf9b7b70a365cb" translate="yes" xml:space="preserve">
          <source>There is a more detailed discussion of the issues involved in compilation safety and some potential solutions on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/SafeHaskell/SafeCompilation&quot;&gt;GHC Wiki&lt;/a&gt;上有关于编译安全性和一些潜在解决方案的更详细的讨论。</target>
        </trans-unit>
        <trans-unit id="fce04b326aff61ebe2df9a60af9c38cb1dce575b" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="eb1e4212250bc026f307434003db90efbde2bd64" translate="yes" xml:space="preserve">
          <source>There is a subtle difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt;, analogous to the difference between &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt;. If the lazy value &lt;code&gt;x&lt;/code&gt; throws an exception, &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; will fail to return an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action and will throw an exception instead. &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt;, on the other hand, always produces an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action; that action will throw an exception upon &lt;em&gt;execution&lt;/em&gt; iff &lt;code&gt;x&lt;/code&gt; throws an exception upon &lt;em&gt;evaluation&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 之间有细微的差别！ x，类似于 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 之间的区别。如果惰性值 &lt;code&gt;x&lt;/code&gt; 引发异常，则 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt; &lt;a href=&quot;prelude#v:-36--33-&quot;&gt;$!&lt;/a&gt; x&lt;/code&gt; 将无法返回 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而将引发异常。另一方面， &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt; x&lt;/code&gt; 总是会产生 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 动作；这一行动将在抛出异常&lt;em&gt;的执行&lt;/em&gt;当且仅当 &lt;code&gt;x&lt;/code&gt; 抛出时的异常&lt;em&gt;评价&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2563e2a704bbfcc49ec757ba40163da4dd1fc632" translate="yes" xml:space="preserve">
          <source>There is a subtle interaction between deadlock detection and finalizers (as created by &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; or the functions in &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;): if a thread is blocked waiting for a finalizer to run, then the thread will be considered deadlocked and sent an exception. So preferably don't do this, but if you have no alternative then it is possible to prevent the thread from being considered deadlocked by making a &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; pointing to it. Don't forget to release the &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; later with &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">死锁检测和终结器（由 &lt;code&gt;&lt;a href=&quot;foreign-concurrent#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 或&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak中&lt;/a&gt;的函数创建）之间存在微妙的交互：如果某个线程在等待终结器运行时被阻塞，则该线程将被视为死锁并发送异常。因此最好不要这样做，但是如果没有其他选择，则可以通过使 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 指向该线程来防止该线程被视为死锁。不要忘了释放 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#t:StablePtr&quot;&gt;StablePtr&lt;/a&gt;&lt;/code&gt; 与后来的 &lt;code&gt;&lt;a href=&quot;foreign-stableptr#v:freeStablePtr&quot;&gt;freeStablePtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a138de3ec39dbf7ca00320675627b0016f828fa6" translate="yes" xml:space="preserve">
          <source>There is additional notation (borrowed from GNU iconv) for specifying how illegal characters are handled:</source>
          <target state="translated">这里有额外的符号(借用GNU图标v)来指定如何处理非法字符。</target>
        </trans-unit>
        <trans-unit id="e9d61711326fa0b013bb306b7ecd3dfd1ba853da" translate="yes" xml:space="preserve">
          <source>There is an extensive Haskell folk art of &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;smart constructors&lt;/a&gt;, essentially functions that wrap validation around a constructor, and avoid exposing its representation. The downside is that the underlying constructor can&amp;rsquo;t be used as a matcher. Pattern synonyms can be used as genuinely smart constructors, for both validation and matching.</source>
          <target state="translated">有大量的Haskell民间艺术 &lt;a href=&quot;https://wiki.haskell.org/Smart_constructor&quot;&gt;智能构造&lt;/a&gt;函数，从本质上讲，这些函数将验证包装在构造函数周围，并避免公开其表示形式。缺点是基础构造函数不能用作匹配器。模式同义词可以用作真正的智能构造函数，用于验证和匹配。</target>
        </trans-unit>
        <trans-unit id="3c1c1857aceea948e7d21232acb00e3e546f38d8" translate="yes" xml:space="preserve">
          <source>There is an overhead of profiling itself, which is subtracted from the residency figures by the profiler. This overhead goes away when compiling without profiling support, of course. The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead.</source>
          <target state="translated">剖析本身有一个开销,由剖析器从驻留数据中减去。当然,在没有profiling支持的情况下,这个开销会消失。空间开销目前是每个堆对象多出2个字,大概会造成30%的开销。</target>
        </trans-unit>
        <trans-unit id="d8de98d63557bb552149bc7c1b7c9441d6a8dd4f" translate="yes" xml:space="preserve">
          <source>There is currently no support for obtaining a &amp;ldquo;stack trace&amp;rdquo;, but the tracing and history features provide a useful second-best, which will often be enough to establish the context of an error. For instance, it is possible to break automatically when an exception is thrown, even if it is thrown from within compiled code (see &lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;Debugging exceptions&lt;/a&gt;).</source>
          <target state="translated">当前不支持获取&amp;ldquo;堆栈跟踪&amp;rdquo;，但是跟踪和历史记录功能提供了有用的第二优功能，通常足以确定错误的上下文。例如，即使在编译后的代码中抛出异常，也可能自动中断该异常（请参阅&lt;a href=&quot;#ghci-debugger-exceptions&quot;&gt;调试异常&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="05298a3a39fbf634a0e6edb9d64da77de83036ef" translate="yes" xml:space="preserve">
          <source>There is exactly one value of type &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, so encoding it requires no knowledge, and we can use zero bits:</source>
          <target state="translated">类型只有一个值 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; ，因此对它进行编码不需要任何知识，我们可以使用零位：</target>
        </trans-unit>
        <trans-unit id="a0d17e4c841b3c2b20a6d55cc49a93844fdda33f" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;ZonedTime&lt;/code&gt;. If you want to compare local times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt;. If you want to compare absolute times, use &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有 &lt;code&gt;ZonedTime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 实例。如果要比较本地时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToLocalTime&quot;&gt;zonedTimeToLocalTime&lt;/a&gt;&lt;/code&gt; 。如果要比较绝对时间，请使用 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeToUTC&quot;&gt;zonedTimeToUTC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4d935f491ea262d75f4027e96a025772c84736d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;deRefStableName&lt;/code&gt; operation. You can't get back from a stable name to the original Haskell object. The reason for this is that the existence of a stable name for an object does not guarantee the existence of the object itself; it can still be garbage collected.</source>
          <target state="translated">没有 &lt;code&gt;deRefStableName&lt;/code&gt; 操作。您不能从一个稳定的名称返回到原始的Haskell对象。原因是对象的稳定名称的存在不能保证对象本身的存在。它仍然可以被垃圾收集。</target>
        </trans-unit>
        <trans-unit id="dcb0e28b510aab00d8eb90f67a01a5ce984b4fe5" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;freeStableName&lt;/code&gt; operation, unlike &lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;s. Stable names are reclaimed by the runtime system when they are no longer needed.</source>
          <target state="translated">与&lt;a href=&quot;foreign-stableptr&quot;&gt;Foreign.StablePtr&lt;/a&gt;不同，没有 &lt;code&gt;freeStableName&lt;/code&gt; 操作。当不再需要稳定名称时，运行时系统将对其进行回收。</target>
        </trans-unit>
        <trans-unit id="efff9d8f51d60ed15b8f7397e759321e79cf6a90" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; or &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; annotation in the source, so it is tagged with &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; 或 &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; 注释，因此标记为 &lt;code&gt;'NoSourceUnpackedness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a45e4999f85d7fe32a999bebf9535c3d4c0ff576" translate="yes" xml:space="preserve">
          <source>There is no corresponding operation for read buffers, because before reading the client will always call &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">读取缓冲区没有相应的操作，因为在读取之前，客户端将始终调用 &lt;code&gt;&lt;a href=&quot;ghc-io-bufferedio#v:fillReadBuffer&quot;&gt;fillReadBuffer&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34dd8b71967c29b174452c1a3603b96013167aa4" translate="yes" xml:space="preserve">
          <source>There is no effect on newtypes, which simply rename existing types. For example:</source>
          <target state="translated">对新类型没有影响,只是对现有类型进行重命名。例如:</target>
        </trans-unit>
        <trans-unit id="e61dd8454d5cd40d618f2a4b76daa69735c08b4e" translate="yes" xml:space="preserve">
          <source>There is no guarantee about the ordering of evaluation. The implementation may evaluate the components of the structure in any order or in parallel. To impose an actual order on evaluation, use &lt;code&gt;pseq&lt;/code&gt; from &lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt; in the &lt;code&gt;parallel&lt;/code&gt; package.</source>
          <target state="translated">无法保证评估的顺序。该实现可以按任何顺序或并行评估结构的组件。要在评估征收的实际顺序，使用 &lt;code&gt;pseq&lt;/code&gt; 从&lt;a href=&quot;control-parallel&quot;&gt;Control.Parallel&lt;/a&gt;在 &lt;code&gt;parallel&lt;/code&gt; 包。</target>
        </trans-unit>
        <trans-unit id="174d05733afd5ac16dc7445d7fb3277cc5bdc2d2" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="17ab87d8b15509feea83bfa466783ea6dbfde5ca" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="12996aa618fab21e63df138a73f65dd2c12773a5" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="1a69783f3d3b8ddc10a9ccc302c3a5316e76d653" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the exception will be delivered promptly, although the runtime will endeavour to ensure that arbitrary delays don't occur. In GHC, an exception can only be raised when a thread reaches a &lt;em&gt;safe point&lt;/em&gt;, where a safe point is where memory allocation occurs. Some loops do not perform any memory allocation inside the loop and therefore cannot be interrupted by a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管运行时会尽力确保不会发生任意延迟，但不能保证会立即交付异常。在GHC中，仅当线程到达&lt;em&gt;安全点&lt;/em&gt;时才会引发异常，安全点是发生内存分配的地方。一些循环在循环内部不执行任何内存分配，因此不能被 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 中断。</target>
        </trans-unit>
        <trans-unit id="d130cc9fa616d4b612107014858ea9434d5a0e51" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run &lt;em&gt;earlier&lt;/em&gt; than specified.</source>
          <target state="translated">无法保证延迟到期后将立即重新安排线程的运行时间，但是该线程将永远不会继续运行 &lt;em&gt;时间&lt;/em&gt;比指定的&lt;em&gt;早&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="840213e7969b17914dbe8b15a7755e40f1d9a57c" translate="yes" xml:space="preserve">
          <source>There is no need to list all of the source files as arguments to the &lt;code&gt;ghc -M&lt;/code&gt; command; &lt;code&gt;ghc&lt;/code&gt; traces the dependencies, just like &lt;code&gt;ghc --make&lt;/code&gt; (a new feature in GHC 6.4).</source>
          <target state="translated">无需列出所有源文件作为 &lt;code&gt;ghc -M&lt;/code&gt; 命令的参数。 &lt;code&gt;ghc&lt;/code&gt; 跟踪依赖项，就像 &lt;code&gt;ghc --make&lt;/code&gt; （GHC 6.4中的新功能）一样。</target>
        </trans-unit>
        <trans-unit id="41c9157200b76970f9cebe37b324916f47f53c9e" translate="yes" xml:space="preserve">
          <source>There is no strictness (&lt;code&gt;!&lt;/code&gt;) or laziness (&lt;code&gt;~&lt;/code&gt;) annotation in the source, so it is tagged with &lt;code&gt;'NoSourceStrictness&lt;/code&gt;.</source>
          <target state="translated">源代码中没有严格（ &lt;code&gt;!&lt;/code&gt; ）或惰性（ &lt;code&gt;~&lt;/code&gt; ）注释，因此将其标记为 &lt;code&gt;'NoSourceStrictness&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5d3d572ae2ac9987e9d1633cf25db9cd582d12" translate="yes" xml:space="preserve">
          <source>There is no way to place restrictions on the modules that &lt;code&gt;Danger&lt;/code&gt; can import. This gives the author of &lt;code&gt;Danger&lt;/code&gt; a very large attack surface, essentially any package currently installed on the system. Should any of these packages have a vulnerability, then the &lt;code&gt;Danger&lt;/code&gt; module can exploit it.</source>
          <target state="translated">无法对 &lt;code&gt;Danger&lt;/code&gt; 可以导入的模块施加限制。这使 &lt;code&gt;Danger&lt;/code&gt; 的作者拥有很大的攻击面，基本上是系统上当前安装的任何软件包。如果这些软件包中的任何一个都有漏洞，则 &lt;code&gt;Danger&lt;/code&gt; 模块可以利用它。</target>
        </trans-unit>
        <trans-unit id="c7097b975bff4ec34afcba2f720e5f54ab84dec8" translate="yes" xml:space="preserve">
          <source>There is no way to provide more input other than the initial data. To be able to incrementally give more data, see the incremental input interface.</source>
          <target state="translated">除了初始数据外,没有办法提供更多的输入。要想以增量方式提供更多数据,请参见增量输入界面。</target>
        </trans-unit>
        <trans-unit id="154e0cf4b003872e3bd7a794778721cb530a308b" translate="yes" xml:space="preserve">
          <source>There is now some potential ambiguity in import and export lists; for example if you write &lt;code&gt;import M( (+) )&lt;/code&gt; do you mean the &lt;em&gt;function&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt; or the &lt;em&gt;type constructor&lt;/em&gt;&lt;code&gt;(+)&lt;/code&gt;? The default is the former, but with &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; (which is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt;) GHC allows you to specify the latter by preceding it with the keyword &lt;code&gt;type&lt;/code&gt;, thus:</source>
          <target state="translated">现在进出口清单中可能存在一些歧义；例如，如果您编写 &lt;code&gt;import M( (+) )&lt;/code&gt; ，是指&lt;em&gt;函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; 还是&lt;em&gt;类型构造函数&lt;/em&gt; &lt;code&gt;(+)&lt;/code&gt; ？默认值为前者，但是使用&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;（由&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;隐含）GHC允许您通过在其前面加上关键字来指定后者 &lt;code&gt;type&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="7c604d18d01de136afc7c368a4880b16051b91f7" translate="yes" xml:space="preserve">
          <source>There is one edge case: &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; currently always produces an empty list (no matter what &lt;code&gt;tys&lt;/code&gt; are given).</source>
          <target state="translated">有一个 &lt;code&gt;reifyInstances ''Typeable tys&lt;/code&gt; 情况：reifyInstances''可键入的ty当前总是产生一个空列表（无论给出什么 &lt;code&gt;tys&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bfdf7e43230c9da3e741c2b02c054c33cbab26e7" translate="yes" xml:space="preserve">
          <source>There is one exception to this general rule: when you load a program with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, or specify it when you invoke &lt;code&gt;ghci&lt;/code&gt;, you can give a filename rather than a module name. This filename is loaded if it exists, and it may contain any module you like. This is particularly convenient if you have several &lt;code&gt;Main&lt;/code&gt; modules in the same directory and you can&amp;rsquo;t call them all &lt;code&gt;Main.hs&lt;/code&gt;.</source>
          <target state="translated">此一般规则有一个例外：当使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;加载程序时，或在调用 &lt;code&gt;ghci&lt;/code&gt; 时指定程序时，可以提供文件名而不是模块名。该文件名（如果存在）将被加载，并且可能包含您喜欢的任何模块。如果您在同一目录中有多个 &lt;code&gt;Main&lt;/code&gt; 模块，而又不能全部调用它们 &lt;code&gt;Main.hs&lt;/code&gt; ,则这特别方便。</target>
        </trans-unit>
        <trans-unit id="1a05b5aa7181827ccaae8d49cbc7cd70b222b777" translate="yes" xml:space="preserve">
          <source>There is one particularly tricky case that should be explained:</source>
          <target state="translated">有一个特别棘手的案例,应该解释一下。</target>
        </trans-unit>
        <trans-unit id="2c99c4cb4443d9b5c20eb143da1040b414ad6caa" translate="yes" xml:space="preserve">
          <source>There is one problem with syntactic ambiguity. Consider:</source>
          <target state="translated">句法上的歧义有一个问题。请考虑:</target>
        </trans-unit>
        <trans-unit id="ddd63182fb2553244a804aed12a58a139a850d50" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="9f08ac2b068afd4addda982c60a0e8364828c216" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="a6918723127704307a50ace1e32e77a7f8c5d3be" translate="yes" xml:space="preserve">
          <source>There is really only one way to &quot;perform&quot; an I/O action: bind it to &lt;code&gt;Main.main&lt;/code&gt; in your program. When your program is run, the I/O will be performed. It isn't possible to perform I/O from an arbitrary function, unless that function is itself in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad and called at some point, directly or indirectly, from &lt;code&gt;Main.main&lt;/code&gt;.</source>
          <target state="translated">实际上，只有一种方法可以&amp;ldquo;执行&amp;rdquo; I / O操作：将其绑定到程序中的 &lt;code&gt;Main.main&lt;/code&gt; 。运行程序时，将执行I / O。不可能从任意函数执行I / O，除非该函数本身在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中并在某个时刻从 &lt;code&gt;Main.main&lt;/code&gt; 直接或间接调用。</target>
        </trans-unit>
        <trans-unit id="626791f34e752bd7930c265d6230de29022cc4e4" translate="yes" xml:space="preserve">
          <source>There may be a short pause while GHCi loads the prelude and standard libraries, after which the prompt is shown. As the banner says, you can type &lt;a href=&quot;#ghci-cmd-:?&quot;&gt;&lt;code&gt;:?&lt;/code&gt;&lt;/a&gt; to see the list of commands available, and a half line description of each of them. We&amp;rsquo;ll explain most of these commands as we go along, and there is complete documentation for all the commands in &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;.</source>
          <target state="translated">GHCi加载前奏和标准库时，可能会停顿一会儿，然后显示提示。如横幅所示，您可以输入&lt;a href=&quot;#ghci-cmd-:?&quot;&gt; &lt;code&gt;:?&lt;/code&gt; &lt;/a&gt;查看可用命令列表，以及每个命令的半行描述。我们将逐步解释所有这些命令，并且在&lt;a href=&quot;#ghci-commands&quot;&gt;GHCi命令中&lt;/a&gt;提供了所有命令的完整文档。</target>
        </trans-unit>
        <trans-unit id="9713a5adae5fb837e7a87a5d86c5d3b524809755" translate="yes" xml:space="preserve">
          <source>There may be multiple weak pointers with the same key. In this case, the finalizers for each of these weak pointers will all be run in some arbitrary order, or perhaps concurrently, when the key dies. If the programmer specifies a finalizer that assumes it has the only reference to an object (for example, a file that it wishes to close), then the programmer must ensure that there is only one such finalizer.</source>
          <target state="translated">同一个键可能有多个弱指针。在这种情况下,每一个弱指针的定标器都会以某种任意的顺序运行,或者当键死亡时,可能会同时运行。如果程序员指定的定标器假定它拥有对一个对象的唯一引用(例如,它希望关闭的文件),那么程序员必须确保只有一个这样的定标器。</target>
        </trans-unit>
        <trans-unit id="baba37366d9f9a52b2ae50c41c0fcd79cb92d44f" translate="yes" xml:space="preserve">
          <source>There may be zero or more rules in a &lt;a href=&quot;#pragma-RULES&quot;&gt;&lt;code&gt;RULES&lt;/code&gt;&lt;/a&gt; pragma, separated by semicolons (which may be generated by the layout rule).</source>
          <target state="translated">规则中可能有零个或多个&lt;a href=&quot;#pragma-RULES&quot;&gt; &lt;code&gt;RULES&lt;/code&gt; &lt;/a&gt;，并用分号分隔（可能由布局规则生成）。</target>
        </trans-unit>
        <trans-unit id="80bec96acf35e3263bf84072cb37215ccbdcc675" translate="yes" xml:space="preserve">
          <source>There must be no spaces in the token &lt;code&gt;[quoter|&lt;/code&gt;.</source>
          <target state="translated">令牌 &lt;code&gt;[quoter|&lt;/code&gt; 不能有空格。。</target>
        </trans-unit>
        <trans-unit id="9a36b38bedcf9582a8dcc97581917a08cf4b8e95" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example, we might define the signature:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如,我们可以定义这样的签名:</target>
        </trans-unit>
        <trans-unit id="c81a592e40538f53e4039fb29ed298bfb5184ce7" translate="yes" xml:space="preserve">
          <source>There must be no value declarations, but there can be type signatures for values. For example:</source>
          <target state="translated">必须没有值声明,但可以有值的类型签名。例如:</target>
        </trans-unit>
        <trans-unit id="d28bf64bbbaabed23b3240c076575673b0ed4a5c" translate="yes" xml:space="preserve">
          <source>There must be some restrictions on the equations of type families, lest we define an ambiguous rewrite system. So, equations of open type families are restricted to be compatible. Two type patterns are compatible if</source>
          <target state="translated">必须对类型族的方程进行一些限制,以免我们定义一个模糊的重写系统。所以,开放类型族的方程被限制为兼容。如果两个类型模式是兼容的</target>
        </trans-unit>
        <trans-unit id="9d9581281214ffc3f58141d4c64d4cc52bc8ee9a" translate="yes" xml:space="preserve">
          <source>There used to be another variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; (namely &lt;code&gt;Par0&lt;/code&gt;), but it has since been deprecated.</source>
          <target state="translated">曾经有 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 的另一种变体（即 &lt;code&gt;Par0&lt;/code&gt; ），但此后不推荐使用。</target>
        </trans-unit>
        <trans-unit id="b7acc6a8e49bdd94e38648f0e9b48c1b6c527d3b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a fine distinction between &lt;em&gt;concurrency&lt;/em&gt; and &lt;em&gt;parallelism&lt;/em&gt;: parallelism is all about making your program run &lt;em&gt;faster&lt;/em&gt; by making use of multiple processors simultaneously. Concurrency, on the other hand, is a means of abstraction: it is a convenient way to structure a program that must respond to multiple asynchronous events.</source>
          <target state="translated">&lt;em&gt;并发&lt;/em&gt;和&lt;em&gt;并行&lt;/em&gt;性之间有很好的区别：并行性就是使程序运行&lt;em&gt;得更快&lt;/em&gt;通过同时使用多个处理器来使。另一方面，并​​发是一种抽象手段：这是一种构造必须响应多个异步事件的程序的便捷方法。</target>
        </trans-unit>
        <trans-unit id="510ad80f56b9b3197c81b4ce6586316af939e48c" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special function to create the &lt;code&gt;StablePtr&lt;/code&gt;: &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt;, because the RTS needs a &lt;code&gt;StablePtr&lt;/code&gt; to the primitive &lt;code&gt;MVar#&lt;/code&gt; object, and we can&amp;rsquo;t create that directly. Do &lt;em&gt;not&lt;/em&gt; just use &lt;code&gt;newStablePtr&lt;/code&gt; on the &lt;code&gt;MVar&lt;/code&gt;: your program will crash.</source>
          <target state="translated">有一个创建 &lt;code&gt;StablePtr&lt;/code&gt; 的特殊功能： &lt;code&gt;newStablePtrPrimMVar&lt;/code&gt; ，因为RTS需要一个到原始 &lt;code&gt;MVar#&lt;/code&gt; 对象的 &lt;code&gt;StablePtr&lt;/code&gt; ，而我们不能直接创建它。不要&lt;em&gt;不&lt;/em&gt;只是使用 &lt;code&gt;newStablePtr&lt;/code&gt; 的 &lt;code&gt;MVar&lt;/code&gt; &lt;em&gt;&lt;/em&gt;：你的程序会崩溃。</target>
        </trans-unit>
        <trans-unit id="c6de6fee468bcddecbdfc815d3488f25d03ac030" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an exception: you can use a Cygwin shell if the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable does &lt;em&gt;not&lt;/em&gt; contain &lt;code&gt;tty&lt;/code&gt;. In this mode, the Cygwin shell behaves like a Windows console shell and console events are propagated to child processes. Note that the &lt;code&gt;CYGWIN&lt;/code&gt; environment variable must be set &lt;em&gt;before&lt;/em&gt; starting the Cygwin shell; changing it afterwards has no effect on the shell.</source>
          <target state="translated">这里有一个例外：您可以使用Cygwin的外壳，如果 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量并&lt;em&gt;没有&lt;/em&gt;包含 &lt;code&gt;tty&lt;/code&gt; 。在这种模式下，Cygwin Shell的行为类似于Windows控制台Shell，并且控制台事件传播到子进程。注意，&lt;em&gt;在&lt;/em&gt;启动Cygwin shell &lt;em&gt;之前，&lt;/em&gt;必须先设置 &lt;code&gt;CYGWIN&lt;/code&gt; 环境变量。之后再更改它对外壳没有影响。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58c919b54688060e3273eb452f86f71d39670a13" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one other gotcha to bear in mind when using external libraries: if the library contains a &lt;code&gt;main()&lt;/code&gt; function, then this will be a link conflict with GHC&amp;rsquo;s own &lt;code&gt;main()&lt;/code&gt; function (eg. &lt;code&gt;libf2c&lt;/code&gt; and &lt;code&gt;libl&lt;/code&gt; have their own &lt;code&gt;main()&lt;/code&gt;s).</source>
          <target state="translated">使用外部库时，还需要牢记其他一点：如果该库包含 &lt;code&gt;main()&lt;/code&gt; 函数，则这将与GHC自己的 &lt;code&gt;main()&lt;/code&gt; 函数（例如 &lt;code&gt;libf2c&lt;/code&gt; 和 &lt;code&gt;libl&lt;/code&gt; 有自己 &lt;code&gt;main()&lt;/code&gt; 小号）。</target>
        </trans-unit>
        <trans-unit id="164798370452dfaed74b9a96d15febf241d138cc" translate="yes" xml:space="preserve">
          <source>There's an implied &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; around every exception handler in a call to one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; family of functions. This is because that is what you want most of the time - it eliminates a common race condition in starting an exception handler, because there may be no exception handler on the stack to handle another exception if one arrives immediately. If asynchronous exceptions are masked on entering the handler, though, we have time to install a new exception handler before being interrupted. If this weren't the default, one would have to write something like</source>
          <target state="translated">有一个隐含的 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 系列函数之一的调用中，每个异常处理程序周围都有。这是因为这是您大多数时候想要的-它消除了启动异常处理程序时的常见竞争条件，因为如果一个人立即到达，则堆栈上可能没有异常处理程序来处理另一个异常。但是，如果异步异常在进入处理程序时被屏蔽，我们有时间在被中断之前安装新的异常处理程序。如果不是默认设置，则必须编写类似</target>
        </trans-unit>
        <trans-unit id="609b73a306420ab86396c82ac4d964ed91191e2a" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Names&lt;/code&gt; can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the &lt;code&gt;reify&lt;/code&gt; function.</source>
          <target state="translated">这些 &lt;code&gt;Names&lt;/code&gt; 可用于构造Template Haskell表达式，模式，声明等。它们也可以作为 &lt;code&gt;reify&lt;/code&gt; 函数的参数提供。</target>
        </trans-unit>
        <trans-unit id="4bfa2b8abe1cf06d188efba9def47c2abdf571c7" translate="yes" xml:space="preserve">
          <source>These RTS options might be used (a) to avoid a GHC bug, (b) to see &amp;ldquo;what&amp;rsquo;s really happening&amp;rdquo;, or (c) because you feel like it. Not recommended for everyday use!</source>
          <target state="translated">这些RTS选项可用于（a）避免GHC错误，（b）看到&amp;ldquo;实际情况&amp;rdquo;，或（c）因为您喜欢它。不建议日常使用！</target>
        </trans-unit>
        <trans-unit id="91dc626b2d992ca1c73233bc91d37d37c8eaf57b" translate="yes" xml:space="preserve">
          <source>These and many other examples are given in papers by Hongwei Xi, and Tim Sheard. There is a longer introduction &lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;on the wiki&lt;/a&gt;, and Ralf Hinze&amp;rsquo;s &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;Fun with phantom types&lt;/a&gt; also has a number of examples. Note that papers may use different notation to that implemented in GHC.</source>
          <target state="translated">这些和许多其他示例在Honghong Xi和Tim Sheard的论文中给出。&lt;a href=&quot;http://www.haskell.org/haskellwiki/GADT&quot;&gt;Wiki上&lt;/a&gt;有更长的介绍，以及Ralf Hinze的&amp;ldquo; &lt;a href=&quot;http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf&quot;&gt;幻影类型&lt;/a&gt;的乐趣&amp;rdquo;。也有许多示例。请注意，论文使用的符号可能与GHC中实施的符号不同。</target>
        </trans-unit>
        <trans-unit id="1628b6a8ce1bd48c62947ef018bda935aa9c7989" translate="yes" xml:space="preserve">
          <source>These are available as &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">这些可用作 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bimapDefault&quot;&gt;bimapDefault&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifoldMapDefault&quot;&gt;bifoldMapDefault&lt;/a&gt;&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="5ccfc02746ae8237d14a062ea086c63733700661" translate="yes" xml:space="preserve">
          <source>These are available from the &lt;em&gt;Trustworthy&lt;/em&gt; module &lt;a href=&quot;data-coerce&quot;&gt;Data.Coerce&lt;/a&gt; as well</source>
          <target state="translated">这些可从&lt;em&gt;Trustworthy&lt;/em&gt;模块中获得&lt;a href=&quot;data-coerce&quot;&gt; Data.Coerce&lt;/a&gt;中获得</target>
        </trans-unit>
        <trans-unit id="74d061aa46ef3dc30721ffc21924ea94edea88fa" translate="yes" xml:space="preserve">
          <source>These are examples of &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations whose data constructors have polymorphic argument types:</source>
          <target state="translated">这些是 &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;newtype&lt;/code&gt; 声明的示例，其数据构造函数具有多态参数类型：</target>
        </trans-unit>
        <trans-unit id="4003d97f9fbee1ee32a83c010d7f3dad0e1ce9da" translate="yes" xml:space="preserve">
          <source>These are the platform the program is compiled to run on.</source>
          <target state="translated">这些是程序编译后要运行的平台。</target>
        </trans-unit>
        <trans-unit id="bdf71604f8a74c2998b767206df5ca5f1622a6ed" translate="yes" xml:space="preserve">
          <source>These are the platform where GHC itself was compiled. Again, this would normally be identical to the build and target platforms.</source>
          <target state="translated">这些是GHC本身编译的平台。同样,这通常与构建和目标平台相同。</target>
        </trans-unit>
        <trans-unit id="250e57ac0724bf8197c79a6b2642a8db1471d94b" translate="yes" xml:space="preserve">
          <source>These are the platform where the program was built on. (That is, the target platform of GHC itself.) Ordinarily this is identical to the target platform. (It could potentially be different if cross-compiling.)</source>
          <target state="translated">这些是程序构建的平台。(也就是GHC本身的目标平台。)通常这和目标平台是一样的。(如果是交叉编译的话,有可能是不同的。)</target>
        </trans-unit>
        <trans-unit id="e196ab1e01bdb7196eee4d4b84c75e053f033500" translate="yes" xml:space="preserve">
          <source>These attributes have all properties turned off.</source>
          <target state="translated">这些属性的所有属性都是关闭的。</target>
        </trans-unit>
        <trans-unit id="ffe393cc3b69c6a3b0293f6f3fcd06f44da059fe" translate="yes" xml:space="preserve">
          <source>These can be useful for investigating bugs or performance problems. They should &lt;em&gt;not&lt;/em&gt; be used in production code.</source>
          <target state="translated">这些对于调查错误或性能问题很有用。他们应该&lt;em&gt;不是&lt;/em&gt;在生产代码中使用。</target>
        </trans-unit>
        <trans-unit id="aed0329f308d729cc20188cdcc6a8a99aaffdf45" translate="yes" xml:space="preserve">
          <source>These capabilities correspond directly to &lt;code&gt;cub&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cub1&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, etc.</source>
          <target state="translated">这些功能直接对应于 &lt;code&gt;cub&lt;/code&gt; ， &lt;code&gt;cud&lt;/code&gt; ， &lt;code&gt;cub1&lt;/code&gt; ， &lt;code&gt;cud1&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bd3c163c0be4700d712f2f68f8583051146d63a1" translate="yes" xml:space="preserve">
          <source>These characters are: any whitespace, single quote, double quote, and the backslash character. The backslash character always escapes (i.e., passes through without further consideration) the character which follows. Characters can also be escaped in blocks by quoting (i.e., surrounding the blocks with matching pairs of either single- or double-quotes which are not themselves escaped).</source>
          <target state="translated">这些字符是:任何空格、单引号、双引号和反斜杠字符。反斜杠字符总是转义(即,不加考虑地通过)后面的字符。字符也可以通过引号在块中进行转义(即在块的周围用匹配的单引号或双引号对其进行转义)。</target>
        </trans-unit>
        <trans-unit id="88446671dea618410eaf4183b1120fcd11d3045f" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Letter&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;不是&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c1807a959c36ca6fd9beb8a2794aa09400e74ccf" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Mark&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;商标&amp;rdquo;，什么不是&amp;ldquo;商标&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="36ce8c81a08d5662b80e9c04ed3b305777ff4865" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Number&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;数字&amp;rdquo;，什么不是数字。</target>
        </trans-unit>
        <trans-unit id="1ca887acc4c9422f8d94d31048ed94d01f03a1df" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Punctuation&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;标点符号&amp;rdquo;和什么不是&amp;ldquo;标点符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="97aa5ae0e404885ccbb1f0839fcfc76fda78a6a0" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Separator&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是&amp;ldquo;分隔符&amp;rdquo;，什么不是&amp;ldquo;分隔符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0085c67836b35ed181dc391234356151ff198a63" translate="yes" xml:space="preserve">
          <source>These classes are defined in the &lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode Character Database&lt;/a&gt;, part of the Unicode standard. The same document defines what is and is not a &quot;Symbol&quot;.</source>
          <target state="translated">这些类在Unicode标准的一部分&lt;a href=&quot;http://www.unicode.org/reports/tr44/tr44-14.html#GC_Values_Table&quot;&gt;Unicode字符数据库&lt;/a&gt;中定义。同一文档定义了什么是和不是&amp;ldquo;符号&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d2bbab454e59aff928df94b81f4e1ad9b21ee61e" translate="yes" xml:space="preserve">
          <source>These classes are needed to express the constraints on arguments of transformers in portable Haskell. Thus for a new transformer &lt;code&gt;T&lt;/code&gt;, one might write instances like</source>
          <target state="translated">需要这些类来表达对便携式Haskell中的转换器参数的约束。因此，对于一个新的转换器 &lt;code&gt;T&lt;/code&gt; ，可能会编写如下实例</target>
        </trans-unit>
        <trans-unit id="ecabcfc2f9f8f1c027e2b554e4eeb92b03b4ed7a" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following definition of an orphan module:</source>
          <target state="translated">考虑到这些因素,我们对孤儿模块的定义如下:</target>
        </trans-unit>
        <trans-unit id="69b631231106b6921f1338cd2572fe5af0f2aed2" translate="yes" xml:space="preserve">
          <source>These ensure by parametricity:</source>
          <target state="translated">这些通过参数化确保。</target>
        </trans-unit>
        <trans-unit id="1c94b9ce2b7b8a075e14ec3d210b949731ecf5dd" translate="yes" xml:space="preserve">
          <source>These events are &lt;em&gt;always&lt;/em&gt; bugs in the GHC system&amp;mdash;please report them.</source>
          <target state="translated">这些事件&lt;em&gt;始终&lt;/em&gt;是GHC系统中的错误，请报告。</target>
        </trans-unit>
        <trans-unit id="09f4acb6e8b78da06e81f543939fe79889775b0e" translate="yes" xml:space="preserve">
          <source>These flags cause a warning to be emitted whenever the module contains an &amp;ldquo;orphan&amp;rdquo; instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</source>
          <target state="translated">只要模块包含&amp;ldquo;孤立&amp;rdquo;实例声明或重写规则，这些标志就会发出警告。如果实例声明出现在模块中，而该实例或类都没有在同一模块中声明，则实例声明是孤立的。如果规则是另一个模块中声明的函数的规则，则它是孤立的。包含任何孤立对象的模块称为孤立模块。</target>
        </trans-unit>
        <trans-unit id="f0be1d5ef4d9e5d0305e16236e92919668b3542f" translate="yes" xml:space="preserve">
          <source>These flags dump various bits of information from other backends.</source>
          <target state="translated">这些标志从其他后端转储各种信息位。</target>
        </trans-unit>
        <trans-unit id="75f158b9172ea17ad4d5194db1770cdf0cf93969" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s frontend. This includes the parser and interface file reader.</source>
          <target state="translated">这些标志从GHC的前端转储各种信息。这包括解析器和接口文件读取器。</target>
        </trans-unit>
        <trans-unit id="80527f61b7ffbd366f80d35ee856592a4fb81ac7" translate="yes" xml:space="preserve">
          <source>These flags dump various information from GHC&amp;rsquo;s typechecker and renamer.</source>
          <target state="translated">这些标志从GHC的类型检查器和重命名器中转储各种信息。</target>
        </trans-unit>
        <trans-unit id="737447733be0073bcfb0ebe996cc210f9d81061b" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s C-\- pipeline.</source>
          <target state="translated">这些标志转储GHC的C-\-管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="c31a5070b8b7325f8e684e34ef92ab92bce24202" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s Core-to-Core pipeline. This begins with the desugarer and includes the simplifier, worker-wrapper transformation, the rule engine, the specialiser, the strictness/occurrence analyser, and a common subexpression elimination pass.</source>
          <target state="translated">这些标志转储了GHC核心到核心管道的各个阶段。这从解糖器开始，包括简化程序，工作者包装程序转换，规则引擎，专家，严格性/出现率分析器以及常见的子表达式消除过程。</target>
        </trans-unit>
        <trans-unit id="32dfc551027fdbf9ccfd3e77612e0c59b50c9935" translate="yes" xml:space="preserve">
          <source>These flags dump various phases of GHC&amp;rsquo;s STG pipeline.</source>
          <target state="translated">这些标志转储GHC STG管道的各个阶段。</target>
        </trans-unit>
        <trans-unit id="f8953ce25d58cce161a8b147fdb564f9d26b5f79" translate="yes" xml:space="preserve">
          <source>These flags dump various stages of the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&amp;rsquo;s&lt;/a&gt; pipeline, which starts with C-\- and produces native assembler.</source>
          <target state="translated">这些标志转储本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;管道的各个阶段，该管道以C-\-开头并生成本机汇编程序。</target>
        </trans-unit>
        <trans-unit id="5a9c258270b924908c72940341b1bf3870701ad6" translate="yes" xml:space="preserve">
          <source>These flags turn on and off individual optimisations. Flags marked as on by default are enabled by &lt;code&gt;-O&lt;/code&gt;, and as such you shouldn&amp;rsquo;t need to set any of them explicitly. A flag &lt;code&gt;-fwombat&lt;/code&gt; can be negated by saying &lt;code&gt;-fno-wombat&lt;/code&gt;.</source>
          <target state="translated">这些标志打开和关闭各个优化。默认情况下，标记为on的标志由 &lt;code&gt;-O&lt;/code&gt; 启用，因此您不需要显式设置任何标志。可以通过说 &lt;code&gt;-fno-wombat&lt;/code&gt; &lt;code&gt;-fwombat&lt;/code&gt; 否定标志-fwombat。</target>
        </trans-unit>
        <trans-unit id="ece68321e5560730979acb0e7829aea5fbe330bb" translate="yes" xml:space="preserve">
          <source>These formatters for standard types are provided for convenience in writting new type-specific formatters: a common pattern is to throw to &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; to do most of the format handling for a new type.</source>
          <target state="translated">提供这些用于标准类型的格式化程序是为了方便编写新的特定于类型的格式化程序：一种常见的模式是抛出 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatString&quot;&gt;formatString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatInteger&quot;&gt;formatInteger&lt;/a&gt;&lt;/code&gt; 来对新类型进行大多数格式处理。</target>
        </trans-unit>
        <trans-unit id="fc91b827c083dbd45f008d452eca5cbbc4e33106" translate="yes" xml:space="preserve">
          <source>These four properties guarantee that in the safe language you can trust the types, can trust that module export lists are respected, and can trust that code that successfully compiles has the same meaning as it normally would.</source>
          <target state="translated">这四个属性保证了在安全语言中,你可以相信类型,可以相信模块导出列表会得到尊重,可以相信成功编译的代码与正常情况下的代码具有相同的意义。</target>
        </trans-unit>
        <trans-unit id="35ae2beea0fb02fcbb417bbf0693881c21546df6" translate="yes" xml:space="preserve">
          <source>These functions are also exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;.</source>
          <target state="translated">这些功能也由&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出。</target>
        </trans-unit>
        <trans-unit id="5c604c71a535978679ce64e0e3febc1178933cc0" translate="yes" xml:space="preserve">
          <source>These functions are different from their &lt;code&gt;CAString&lt;/code&gt; counterparts in that they will use an encoding determined by the current locale, rather than always assuming ASCII.</source>
          <target state="translated">这些函数与其对应的 &lt;code&gt;CAString&lt;/code&gt; 不同，它们将使用由当前语言环境确定的编码，而不是始终采用ASCII。</target>
        </trans-unit>
        <trans-unit id="e34dd974b452bf37c7be3a6a7ec33bf5624e1212" translate="yes" xml:space="preserve">
          <source>These functions are overloaded because they need to return a different result, depending on the type at which they are instantiated.</source>
          <target state="translated">这些函数是重载的,因为它们需要返回不同的结果,这取决于它们被实例化的类型。</target>
        </trans-unit>
        <trans-unit id="3fd5d872cb809dc7eab9796c42ba21fcde97b5d0" translate="yes" xml:space="preserve">
          <source>These functions are undefined when the amount being shifted by is greater than the size in bits of a machine Int#.</source>
          <target state="translated">当移位量大于机器Int#的位数大小时,这些函数未被定义。</target>
        </trans-unit>
        <trans-unit id="cd72a3a3a954bf10ebc8f9a2fc149a849293aaa3" translate="yes" xml:space="preserve">
          <source>These functions are used internally to raise various errors, and are exported for use by new type-specific formatters.</source>
          <target state="translated">这些函数在内部用于引发各种错误,并被导出供新的特定类型格式化器使用。</target>
        </trans-unit>
        <trans-unit id="c27bbed0c97953b2719d8da964d4e3a7142b3841" translate="yes" xml:space="preserve">
          <source>These functions can be used to assemble &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instances for new algebraic types. For example, given the definition</source>
          <target state="translated">这些函数可用于组合新代数类型的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例。例如，给定定义</target>
        </trans-unit>
        <trans-unit id="e463371a563c760dcfec2c52c04107908b9de66f" translate="yes" xml:space="preserve">
          <source>These functions do not bind a levity-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</source>
          <target state="translated">这些函数没有绑定一个多态变量,所以被接受。它们的多态性允许用户使用这些函数来方便地剔除那些返回非盒式类型的函数。</target>
        </trans-unit>
        <trans-unit id="ac46513bf01921ab26c4cb23e80d8b1179daf25b" translate="yes" xml:space="preserve">
          <source>These functions generalize their namesakes in the portable &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; module by allowing arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions as finalizers. These finalizers necessarily run in a separate thread, cf. &lt;em&gt;Destructors, Finalizers and Synchronization&lt;/em&gt;, by Hans Boehm, &lt;em&gt;POPL&lt;/em&gt;, 2003.</source>
          <target state="translated">通过允许任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作作为终结器，这些函数在可移植的&lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt;模块中通用了它们的名称。这些终结器必须在单独的线程中运行，请参见。&lt;em&gt;析构&lt;/em&gt;&lt;em&gt;函数&lt;/em&gt;，&lt;em&gt;终结器和同步&lt;/em&gt;，作者：Hans Boehm，&lt;em&gt;POPL&lt;/em&gt;，2003年。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b06b54f2742e82f9cabcd9c259ec3cd116dcc35a" translate="yes" xml:space="preserve">
          <source>These functions perform sequential searches from the left or right ends of the sequence, returning indices of matching elements.</source>
          <target state="translated">这些函数从序列的左端或右端进行顺序搜索,返回匹配元素的索引。</target>
        </trans-unit>
        <trans-unit id="87221aea594a26d1e5e903734013d102fe1beb59" translate="yes" xml:space="preserve">
          <source>These functions pre-date &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; which is much more flexible.</source>
          <target state="translated">这些功能早于 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; ，后者更加灵活。</target>
        </trans-unit>
        <trans-unit id="1eeda2971d19159845b63c113a7cf985d383a44c" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7ede5395fcce38fdb04439abff0ca42b7e07f35" translate="yes" xml:space="preserve">
          <source>These functions treat a list &lt;code&gt;xs&lt;/code&gt; as a indexed collection, with indices ranging from 0 to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt;.</source>
          <target state="translated">这些函数将列表 &lt;code&gt;xs&lt;/code&gt; 视为索引集合，索引范围为0到 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:length&quot;&gt;length&lt;/a&gt; xs - 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6835f6ad62f6fd820ed297487e2ff455f3cd8e7d" translate="yes" xml:space="preserve">
          <source>These instances are compatible because they differ in their implicit kind parameter; the first uses &lt;code&gt;Type&lt;/code&gt; while the second uses &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">这些实例是兼容的，因为它们的隐式种类参数有所不同。第一个使用 &lt;code&gt;Type&lt;/code&gt; ，第二个使用 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc48d2e2d27233c00c2c501c66ece98f84417e79" translate="yes" xml:space="preserve">
          <source>These macros are available starting with GHC 7.10.1.</source>
          <target state="translated">这些宏从GHC 7.10.1开始可用。</target>
        </trans-unit>
        <trans-unit id="ae04819a18b26fdceb2be29551deb7ed3acdae2e" translate="yes" xml:space="preserve">
          <source>These macros are provided for allowing finer granularity than is provided by &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt;. Usually, this should not be necessary as it&amp;rsquo;s expected for most APIs to remain stable between patchlevel releases, but occasionally internal API changes are necessary to fix bugs. Also conditional compilation on the patchlevel can be useful for working around bugs in older releases.</source>
          <target state="translated">提供这些宏是为了比 &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 提供更细的粒度。通常，这不是必需的，因为期望大多数API在补丁程序版本之间保持稳定，但是偶尔需要内部API更改才能修复错误。此外，在补丁程序级别上进行条件编译对于解决较旧版本中的错误也很有用。</target>
        </trans-unit>
        <trans-unit id="51848f2520dc3b8114fc872d0ac65b69f5df9473" translate="yes" xml:space="preserve">
          <source>These macros are set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">在预处理Haskell源和C源（包括从Haskell模块生成的C源（即 &lt;code&gt;.hs&lt;/code&gt; ， &lt;code&gt;.lhs&lt;/code&gt; ， &lt;code&gt;.c&lt;/code&gt; )时，会设置这些宏。和 &lt;code&gt;.hc&lt;/code&gt; 文件）。</target>
        </trans-unit>
        <trans-unit id="11abca0ebcb35da15e9aef05f3cdf6611aa84840" translate="yes" xml:space="preserve">
          <source>These modules are intended to be imported qualified, to avoid name clashes with Prelude functions, e.g.</source>
          <target state="translated">这些模块在导入时要有限定条件,以避免与Prelude函数的名称冲突,例如:。</target>
        </trans-unit>
        <trans-unit id="d535f64275335663d5441026d12ac809514c2eb8" translate="yes" xml:space="preserve">
          <source>These operations return &lt;code&gt;0#&lt;/code&gt; and &lt;code&gt;1#&lt;/code&gt; instead of &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt; respectively. See &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;PrimBool wiki-page&lt;/a&gt; for more details</source>
          <target state="translated">这些操作分别返回 &lt;code&gt;0#&lt;/code&gt; 和 &lt;code&gt;1#&lt;/code&gt; ,而不是 &lt;code&gt;False&lt;/code&gt; 和 &lt;code&gt;True&lt;/code&gt; 。看到&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/PrimBool&quot;&gt;&lt;/a&gt;更多详细信息， PrimBool Wiki页面。</target>
        </trans-unit>
        <trans-unit id="8961645f51f3a1b4a6c3aeed91a6e9fbf3f8051c" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;. If a flag is implied by &lt;code&gt;-O&lt;/code&gt; then it is also implied by &lt;code&gt;-O2&lt;/code&gt; (unless flag description explicitly says otherwise). If a flag is implied by &lt;code&gt;-O0&lt;/code&gt; only then the flag is not implied by &lt;code&gt;-O&lt;/code&gt; and &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">这些选项在&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;中进行了详细描述。如果一个标志由 &lt;code&gt;-O&lt;/code&gt; 隐含，那么它也由 &lt;code&gt;-O2&lt;/code&gt; 隐含（除非标志说明另有明确说明）。如果仅 &lt;code&gt;-O0&lt;/code&gt; 隐含标志，则 &lt;code&gt;-O&lt;/code&gt; 和-O不隐含该标志。 &lt;code&gt;-O2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9993a1a47c7b56cbbe65138c2297b44c73f9916e" translate="yes" xml:space="preserve">
          <source>These options are described in more detail in &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;Optimisation (code improvement)&lt;/a&gt;.</source>
          <target state="translated">这些选项在以下内容中有更详细的描述 &lt;a href=&quot;using-optimisation#options-optimise&quot;&gt;优化（代码改进）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44d239e97dcf0e2e0c134a87fda302f26adf7c6a" translate="yes" xml:space="preserve">
          <source>These options control which warnings are considered fatal and cause compilation to abort.</source>
          <target state="translated">这些选项控制哪些警告被认为是致命的,并导致编译中止。</target>
        </trans-unit>
        <trans-unit id="edb593ad00abb81748bd2751cf62f6efe475d39f" translate="yes" xml:space="preserve">
          <source>These options produce runtime-system statistics, such as the amount of time spent executing the program and in the garbage collector, the amount of memory allocated, the maximum size of the heap, and so on. The three variants give different levels of detail: &lt;code&gt;-T&lt;/code&gt; collects the data but produces no output &lt;code&gt;-t&lt;/code&gt; produces a single line of output in the same format as GHC&amp;rsquo;s &lt;code&gt;-Rghc-timing&lt;/code&gt; option, &lt;code&gt;-s&lt;/code&gt; produces a more detailed summary at the end of the program, and &lt;code&gt;-S&lt;/code&gt; additionally produces information about each and every garbage collection. Passing &lt;code&gt;--internal-counters&lt;/code&gt; to a threaded runtime will cause a detailed summary to include various internal counts accumulated during the run; note that these are unspecified and may change between releases.</source>
          <target state="translated">这些选项产生运行时系统统计信息，例如执行程序和在垃圾回收器中花费的时间，分配的内存量，堆的最大大小等。这三个变体提供不同的详细程度： &lt;code&gt;-T&lt;/code&gt; 收集数据但不产生输出 &lt;code&gt;-t&lt;/code&gt; 产生与GHC的 &lt;code&gt;-Rghc-timing&lt;/code&gt; 选项相同格式的单行输出， &lt;code&gt;-s&lt;/code&gt; 在结束时产生更详细的摘要程序和线程化的运行时将导致详细的摘要包括运行期间累积的各种内部计数；请注意，这些是未指定的，并且可能在发行版之间进行更改。 &lt;code&gt;-S&lt;/code&gt; 还会生成有关每个垃圾收集的信息。通过 &lt;code&gt;--internal-counters&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dba900fff87161f43a1a12316670eef680c82d4e" translate="yes" xml:space="preserve">
          <source>These overheads can all be reduced by 1 word (4 or 8 bytes) when the &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt; is unpacked into another constructor.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;ByteString&lt;/code&gt; 打包到另一个构造函数中后，这些开销都可以减少1个字（4或8个字节）。</target>
        </trans-unit>
        <trans-unit id="77a27181cfeb12715305d9aa476246d068b548fa" translate="yes" xml:space="preserve">
          <source>These papers and more information on arrows can be found at &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;.</source>
          <target state="translated">这些论文和有关箭头的更多信息可以在&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="c5504af0f139900075ad2b30112ac4cea1fe57d9" translate="yes" xml:space="preserve">
          <source>These patterns are only available with GHC version 8.0 or later, and version 8.2 works better with them. When writing for such recent versions of GHC, the patterns can be used in place of &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些模式仅在GHC 8.0或更高版本中可用，而8.2版更适用于它们。当近期这些版本GHC的文字，图案可以代替使用 &lt;code&gt;&lt;a href=&quot;data-sequence#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-60--124-&quot;&gt;&amp;lt;|&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:-124--62-&quot;&gt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewl&quot;&gt;viewl&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:viewr&quot;&gt;viewr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f52ff49b136cf09c728f4803c3178f859a7070f" translate="yes" xml:space="preserve">
          <source>These potentially overlap, but GHC will not complain about the instance declarations themselves, regardless of flag settings. If we later try to solve the constraint &lt;code&gt;(C Int Char)&lt;/code&gt; then only the first instance matches, and all is well. Similarly with &lt;code&gt;(C Bool Bool)&lt;/code&gt;. But if we try to solve &lt;code&gt;(C Int Bool)&lt;/code&gt;, both instances match and an error is reported.</source>
          <target state="translated">这些可能重叠，但是无论标志设置如何，GHC都不会抱怨实例声明本身。如果我们以后尝试解决约束 &lt;code&gt;(C Int Char)&lt;/code&gt; ,则只有第一个实例匹配，并且一切都很好。与 &lt;code&gt;(C Bool Bool)&lt;/code&gt; 相似。但是，如果我们尝试解决 &lt;code&gt;(C Int Bool)&lt;/code&gt; ，则两个实例都匹配，并且会报告错误。</target>
        </trans-unit>
        <trans-unit id="78d456d26025630626ea67fc9dac499928672c61" translate="yes" xml:space="preserve">
          <source>These pragmas control the inlining of function definitions.</source>
          <target state="translated">这些实用名词控制着函数定义的内联。</target>
        </trans-unit>
        <trans-unit id="22fb4604da24a31c3e12ce8e599a649d4ce43f31" translate="yes" xml:space="preserve">
          <source>These restrictions are easily verified and ensure termination of type inference. However, they are not sufficient to guarantee completeness of type inference in the presence of, so called, &amp;lsquo;&amp;rsquo;loopy equalities&amp;rsquo;&amp;lsquo;, such as &lt;code&gt;a ~ [F a]&lt;/code&gt;, where a recursive occurrence of a type variable is underneath a family application and data constructor application - see the above mentioned paper for details.</source>
          <target state="translated">这些限制很容易验证，并确保终止类型推断。但是，在存在所谓的&amp;ldquo;循环等式&amp;rdquo;（例如 &lt;code&gt;a ~ [F a]&lt;/code&gt; 的情况下，它们不足以保证类型推断的完整性，在这种情况下，类型变量的递归出现在族应用程序的下方，并且数据构造器应用程序-有关详细信息，请参见上述文章。</target>
        </trans-unit>
        <trans-unit id="48d1370baaba0621634fda1bb9a7a71066b21b10" translate="yes" xml:space="preserve">
          <source>These restrictions ensure that instance resolution terminates: each reduction step makes the problem smaller by at least one constructor. You can find lots of background material about the reason for these restrictions in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;Understanding functional dependencies via Constraint Handling Rules&lt;/a&gt;.</source>
          <target state="translated">这些限制确保实例解析终止：每个简化步骤至少使一个构造函数使问题变小。您可以在论文中&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/jfp06.pdf&quot;&gt;通过约束处理规则了解功能依赖性&lt;/a&gt;找到许多背景材料，以了解这些限制的原因。。</target>
        </trans-unit>
        <trans-unit id="592370c8132dc473f31cbaadabc6eeb1ffecffbf" translate="yes" xml:space="preserve">
          <source>These rules restrict record wildcards to the situations in which the user could have written the expanded version. For example</source>
          <target state="translated">这些规则将记录通配符限制在用户可以编写扩展版本的情况下。例如</target>
        </trans-unit>
        <trans-unit id="abaf6ec94bf4ef17c830c2d7ac28ed21cea0a752" translate="yes" xml:space="preserve">
          <source>These types are needed for implementing processing variable numbers of arguments to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Their implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of the appropriate class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;. (All &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; instances are &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; instances.)</source>
          <target state="translated">这些类型对于实现处理可变数量的参数 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 是必需的。从模块中看不到它们的实现。如果您尝试将不是该适当类的实例的类型的参数传递给 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; ，则编译器会将其报告为缺少的 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例。 （所有 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例都是 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 实例。）</target>
        </trans-unit>
        <trans-unit id="3469c326f3dbcba25a670f8c1849f69a780e1258" translate="yes" xml:space="preserve">
          <source>These types are needed to accurately represent C function prototypes, in order to access C library interfaces in Haskell. The Haskell system is not required to represent those types exactly as C does, but the following guarantees are provided concerning a Haskell type &lt;code&gt;CT&lt;/code&gt; representing a C type &lt;code&gt;t&lt;/code&gt;:</source>
          <target state="translated">为了访问Haskell中的C库接口，需要使用这些类型来精确表示C函数原型。 Haskell系统不需要完全像C那样表示这些类型，但是对于表示C类型 &lt;code&gt;t&lt;/code&gt; 的Haskell类型 &lt;code&gt;CT&lt;/code&gt; 提供了以下保证：</target>
        </trans-unit>
        <trans-unit id="b652ab9b4675e4c25fc44cf381751d29366f1a60" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt;. That does mean that &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt;'s) instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; are as badly behaved as &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt;'s (respectively &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt;'s).</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 第 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ，和是的情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 。这是否意味着 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CFloat&quot;&gt;CFloat&lt;/a&gt;&lt;/code&gt; 的（分别 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CDouble&quot;&gt;CDouble&lt;/a&gt;&lt;/code&gt; 的的）情况下 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;prelude#v:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 的行为（分别为 &lt;code&gt;&lt;a href=&quot;prelude#v:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; ）一样糟糕。</target>
        </trans-unit>
        <trans-unit id="295b080f792318eefb2add5c8eb45291f13a7e87" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of basic foreign types, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 基本外交类型的S，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f054008a97c12316c3d9d18cd331b115ccbe12b8" translate="yes" xml:space="preserve">
          <source>These types are represented as &lt;code&gt;newtype&lt;/code&gt;s of types in &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;, and are instances of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些类型被表示为 &lt;code&gt;newtype&lt;/code&gt; 的种S &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;和&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;，并且是实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-typeable#v:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b7b616a2441a5d70ac85ff090a7d0d4463488a1" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that are ignorant of Unicode. These functions should be used with care, as a loss of information can occur.</source>
          <target state="translated">上述函数的这些变体用于不懂Unicode的C库。这些函数的使用应谨慎,因为可能会造成信息丢失。</target>
        </trans-unit>
        <trans-unit id="aa092d86f68a166e6d23f0ee7479403178f2a4af" translate="yes" xml:space="preserve">
          <source>These variants of the above functions are for use with C libraries that encode Unicode using the C &lt;code&gt;wchar_t&lt;/code&gt; type in a system-dependent way. The only encodings supported are</source>
          <target state="translated">以上函数的这些变体用于与C语言库有关的C库，这些C库使用C &lt;code&gt;wchar_t&lt;/code&gt; 类型以依赖于系统的方式对Unicode进行编码。支持的唯一编码是</target>
        </trans-unit>
        <trans-unit id="cf17f1abe56035fa55a6c2c80d745a4d6a39b4ee" translate="yes" xml:space="preserve">
          <source>They tell &lt;code&gt;make&lt;/code&gt; that if any of &lt;code&gt;Foo.o&lt;/code&gt;, &lt;code&gt;Foo.hc&lt;/code&gt; or &lt;code&gt;Foo.s&lt;/code&gt; have an earlier modification date than &lt;code&gt;Baz.hi&lt;/code&gt;, then the out-of-date file must be brought up to date. To bring it up to date, &lt;code&gt;make&lt;/code&gt; looks for a rule to do so; one of the preceding suffix rules does the job nicely. These dependencies can be generated automatically by &lt;code&gt;ghc&lt;/code&gt;; see &lt;a href=&quot;#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;</source>
          <target state="translated">他们告诉 &lt;code&gt;make&lt;/code&gt; ，如果有任何的 &lt;code&gt;Foo.o&lt;/code&gt; ， &lt;code&gt;Foo.hc&lt;/code&gt; 或 &lt;code&gt;Foo.s&lt;/code&gt; 有较早的修改日期比 &lt;code&gt;Baz.hi&lt;/code&gt; ，再出过期的文件必须予以更新。为了把它最新的， &lt;code&gt;make&lt;/code&gt; 寻找一个规则来做到这一点; 前面的后缀规则之一可以很好地完成这项工作。这些依赖可以由 &lt;code&gt;ghc&lt;/code&gt; 自动生成；请参阅&lt;a href=&quot;#makefile-dependencies&quot;&gt;依赖项生成&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b503ef61ed50540af2f4fe9c35e29285e4503b69" translate="yes" xml:space="preserve">
          <source>They were introduced in the paper &lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&quot;Concurrent Haskell&quot;&lt;/a&gt; by Simon Peyton Jones, Andrew Gordon and Sigbjorn Finne, though some details of their implementation have since then changed (in particular, a put on a full &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; used to error, but now merely blocks.)</source>
          <target state="translated">它们在Simon Peyton Jones，Andrew Gordon和Sigbjorn Finne 的论文&lt;a href=&quot;https://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;&amp;ldquo; Concurrent Haskell&amp;rdquo;中&lt;/a&gt;进行了介绍，尽管此后其实现的某些细节已发生了变化（特别是用于错误的完整 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的外观，但现在仅是块状）。 ）</target>
        </trans-unit>
        <trans-unit id="a212ed0a68d3d89040f3257b134393f9ede21b72" translate="yes" xml:space="preserve">
          <source>Things to be aware of:</source>
          <target state="translated">需要注意的事项:</target>
        </trans-unit>
        <trans-unit id="51a09d230b46ace5589e6c42048887aed8066c2f" translate="yes" xml:space="preserve">
          <source>This &quot;function&quot; has a superficial similarity to &lt;code&gt;unsafePerformIO&lt;/code&gt; but it is in fact a malevolent agent of chaos. It unpicks the seams of reality (and the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad) so that the normal rules no longer apply. It lulls you into thinking it is reasonable, but when you are not looking it stabs you in the back and aliases all of your mutable buffers. The carcass of many a seasoned Haskell programmer lie strewn at its feet.</source>
          <target state="translated">这个&amp;ldquo;功能&amp;rdquo;与 &lt;code&gt;unsafePerformIO&lt;/code&gt; 有表面上的相似之处，但实际上它是混乱的恶毒代理。它揭开了现实的接缝（以及 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad），使常规规则不再适用。它使您认为它是合理的，但是当您不看它时，它会刺伤您的背部，并为所有可变缓冲区起别名。许多经验丰富的Haskell程序员的尸体散落在其脚下。</target>
        </trans-unit>
        <trans-unit id="a3b104d1663bc84a172a1db33ed85dad6c3f818f" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;feature&amp;rdquo; can be counterintuitive: &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; will put the intermediate C code in the file &lt;code&gt;foo.o&lt;/code&gt;, name notwithstanding!</source>
          <target state="translated">此&amp;ldquo;功能&amp;rdquo;可能违反直觉： &lt;code&gt;ghc -C -o foo.o foo.hs&lt;/code&gt; 将把中间C代码放入文件 &lt;code&gt;foo.o&lt;/code&gt; 中。，尽管名称！</target>
        </trans-unit>
        <trans-unit id="88c2cc5c70d23600b5ecc8b34beba93891daa625" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; equality predicate is used when desugaring pattern-matches against strings.</source>
          <target state="translated">这个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 在对字符串进行模式匹配时，使用相等谓词。</target>
        </trans-unit>
        <trans-unit id="2a20dfa3119742b981763464b6142a5a6307df21" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="85350ad73428364818dabe9da2493156b00515d0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is used to decode and encode command line arguments and environment variables on non-Windows platforms.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/GHC-IO-Encoding-Types.html#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 用于在非Windows平台上对命令行参数和环境变量进行解码和编码。</target>
        </trans-unit>
        <trans-unit id="90972741151c3e380f6a4e1b7843a38442017cba" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; can be extended to format types other than those provided for by default. This is done by instantiating &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; and providing a &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; for the type. It is possible to provide a &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; to process type-specific modifiers, but the default instance is usually the best choice.</source>
          <target state="translated">可以将此 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 扩展为默认提供的格式类型以外的其他格式。这是通过实例化 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 并为该类型提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:formatArg&quot;&gt;formatArg&lt;/a&gt;&lt;/code&gt; 来完成的。可以提供 &lt;code&gt;&lt;a href=&quot;text-printf#v:parseFormat&quot;&gt;parseFormat&lt;/a&gt;&lt;/code&gt; 来处理特定于类型的修饰符，但是默认实例通常是最佳选择。</target>
        </trans-unit>
        <trans-unit id="235914be792722663cf0e67d05a491027df38a5c" translate="yes" xml:space="preserve">
          <source>This abbreviation makes top-level declaration slices quieter and less intimidating.</source>
          <target state="translated">这种缩写使顶层申报片更安静、更不吓人。</target>
        </trans-unit>
        <trans-unit id="798b63450aaded668eb204ce38b4ea09a77050c7" translate="yes" xml:space="preserve">
          <source>This abstract data type represents parse error messages. There are four kinds of messages:</source>
          <target state="translated">这个抽象的数据类型表示解析错误消息。有四种消息。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
