<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="03411ce0e13fe57751c2f82253b492cc9d47c8f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;： &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 是一个超类 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ，因为&lt;em&gt;基础4.11.0.0&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="166aed14653edc6f46dcff3c1dae86631ba0a891" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当前，当 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 应用于不消耗任何输入的解析器 &lt;code&gt;p&lt;/code&gt; 时，会表现出令人惊讶的行为。特别</target>
        </trans-unit>
        <trans-unit id="ec9986bf04287187f171a448a6e427d2d4d16d6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当前，当 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 应用于不消耗任何输入的解析器 &lt;code&gt;p&lt;/code&gt; 时，会表现出令人惊讶的行为。特别</target>
        </trans-unit>
        <trans-unit id="5d16f3693057b662396f898cac3b01fe76debdb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Currently, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; exhibits surprising behaviour when applied to a parser &lt;code&gt;p&lt;/code&gt; that doesn't consume any input; specifically</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：当前，当 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 应用于不消耗任何输入的解析器 &lt;code&gt;p&lt;/code&gt; 时，会表现出令人惊讶的行为。特别</target>
        </trans-unit>
        <trans-unit id="6818107750bfc6c118df69013440ac82805bba52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Only strict in the reference and not the referenced value.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：仅严格参考而不是参考值。</target>
        </trans-unit>
        <trans-unit id="dc20d237e47fdcc6a1702edaefb72cd73590b46d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Prior to &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; this instance was only defined for &lt;code&gt;base-4.8.0.0&lt;/code&gt; and later.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：在 &lt;code&gt;deepseq-1.4.4.0&lt;/code&gt; 之前，此实例仅针对 &lt;code&gt;base-4.8.0.0&lt;/code&gt; 和更高版本定义。</target>
        </trans-unit>
        <trans-unit id="7a7733fa013d8d35cc1c5581dc3eef96e5dfd0cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The functions in &lt;code&gt;base-4.12&lt;/code&gt; changed the serialisation in case of a &lt;code&gt;Just 0&lt;/code&gt; precision; this version of &lt;code&gt;text&lt;/code&gt; still provides the serialisation as implemented in &lt;code&gt;base-4.11&lt;/code&gt;. The next major version of &lt;code&gt;text&lt;/code&gt; will switch to the more correct &lt;code&gt;base-4.12&lt;/code&gt; serialisation.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;： &lt;code&gt;base-4.12&lt;/code&gt; 中的函数在 &lt;code&gt;Just 0&lt;/code&gt; 精度为0的情况下更改了序列化。此版本的 &lt;code&gt;text&lt;/code&gt; 仍提供 &lt;code&gt;base-4.11&lt;/code&gt; 中实现的序列化。 &lt;code&gt;text&lt;/code&gt; 的下一个主要版本将切换到更正确的 &lt;code&gt;base-4.12&lt;/code&gt; 序列化。</target>
        </trans-unit>
        <trans-unit id="77693d6f146c132591a587e160c8af245f51c0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The intrepid user may notice that &lt;code&gt;HasCallStack&lt;/code&gt; is just an alias for an implicit parameter &lt;code&gt;?callStack :: CallStack&lt;/code&gt;. This is an implementation detail and &lt;strong&gt;should not&lt;/strong&gt; be considered part of the &lt;code&gt;CallStack&lt;/code&gt; API, we may decide to change the implementation in the future.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：勇敢的用户可能会注意到 &lt;code&gt;HasCallStack&lt;/code&gt; 只是隐式参数 &lt;code&gt;?callStack :: CallStack&lt;/code&gt; 的别名。这是实现的详细信息，&lt;strong&gt;不应&lt;/strong&gt;视为 &lt;code&gt;CallStack&lt;/code&gt; API的一部分，我们可能会决定将来更改实现。</target>
        </trans-unit>
        <trans-unit id="2533d0f8b23d21f162cecf82e012550c323eb127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: The replacement character returned by &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; MUST be within the BMP plane; surrogate code points will automatically be remapped to the replacement char &lt;code&gt;U+FFFD&lt;/code&gt; (&lt;em&gt;since 0.11.3.0&lt;/em&gt;), whereas code points beyond the BMP will throw an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since 1.2.3.1&lt;/em&gt;); For earlier versions of &lt;code&gt;text&lt;/code&gt; using those unsupported code points would result in undefined behavior.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：由 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:OnDecodeError&quot;&gt;OnDecodeError&lt;/a&gt;&lt;/code&gt; 返回的替换字符必须在BMP平面内；否则，不能使用。替代代码点将自动重新映射到替换字符 &lt;code&gt;U+FFFD&lt;/code&gt; （&lt;em&gt;从0.11.3.0开始&lt;/em&gt;），而超出BMP的代码点将引发 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; （&lt;em&gt;从1.2.3.1开始&lt;/em&gt;）；对于较早版本的 &lt;code&gt;text&lt;/code&gt; 使用那些不受支持的代码点将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6af85fbdeb1c1548ecdc703b5c39806483adbef4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This instance is only defined for &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此实例仅针对 &lt;code&gt;base &amp;gt;= 4.9.0&lt;/code&gt; 定义。</target>
        </trans-unit>
        <trans-unit id="7d4e26172ba9fac2189c2280c424438f132a68b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is not needed anymore since &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; became a superclass of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; in &lt;em&gt;base-4.11&lt;/em&gt; and this newtype be deprecated at some point in the future.</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt;：这是没有必要了，因为 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 成为一个超类 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 中&lt;em&gt;基4.11&lt;/em&gt;，这NEWTYPE在未来的某一时刻被弃用。</target>
        </trans-unit>
        <trans-unit id="09bbdeeb23f25384d247711b42a27b30cfbb93e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法是多余的，并且自&lt;em&gt;base-4.11.0.0&lt;/em&gt;起具有默认实现 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b7bee89a50523b2b7f4298406f2f560b7f97e3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法是多余的，并且自&lt;em&gt;base-4.11.0.0&lt;/em&gt;起具有默认实现 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;ghc-base#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53250bceefb8edf3079bcff5effdeb91a06684e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法是多余的，并且自&lt;em&gt;base-4.11.0.0&lt;/em&gt;起具有默认实现 &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;prelude#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e5e33ea116bb722425b17e443f5a6fd673821d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此方法是多余的，并且自&lt;em&gt;base-4.11.0.0&lt;/em&gt;起具有默认实现 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b182cab3c093432cfb21fa9dafb0c11115dbd3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This method is redundant and has the default implementation &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt; = (&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; since &lt;em&gt;base-4.11.0.0&lt;/em&gt;. Should it be implemented manually, since &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; is a synonym for (&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;), it is expected that the two functions are defined the same way. In a future GHC release &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; will be removed from &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b87531c422bb43abf588cd19cfb145b4b1af212" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Negation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Negation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35fdc70491666deaadbc15762d73d32a5836699b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested patterns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;嵌套模式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39c28848aeb5cab86ac6b199bccbac9933f1e95b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Newtypes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Newtypes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0d40e5bd81d1d6957246a1ec75c38216c4704c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No ``-O*``-type option specified:&lt;/strong&gt; This is taken to mean &amp;ldquo;Please compile quickly; I&amp;rsquo;m not over-bothered about compiled-code quality.&amp;rdquo; So, for example, &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;未指定&amp;ldquo; -O *&amp;rdquo;类型的选项：&lt;/strong&gt;这表示&amp;ldquo;请快速编译；我对编译代码的质量并不过分。&amp;rdquo; 因此，例如 &lt;code&gt;ghc -c Foo.hs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15fc39334b9319bc0d7d967925cee84740f69bc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This module exports internal implementation details that may change anytime. If you want a more stable API, use &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;此模块导出可能随时更改的内部实现详细信息。如果您想要更稳定的API，请改用&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2350c93205902e1c98253ef2f7d2621dcc8098cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：上面的示例应该用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 以确保及时发布文件描述符（有关示例，请参见 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; 的说明）。</target>
        </trans-unit>
        <trans-unit id="47f5cf616517b6eba6447338e761bc574ca481fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The example above should rather be written in terms of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; to ensure releasing file-descriptors in a timely matter (see the description of &lt;code&gt;&lt;a href=&quot;control-deepseq#v:force&quot;&gt;force&lt;/a&gt;&lt;/code&gt; for an example).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41c2eafe5091226c38a0690d82eb9525b65f556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This function is a very big hammer. If you only need an absolute path, &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; is sufficient for removing dependence on the current working directory.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：此功能是非常大的锤子。如果只需要绝对路径， &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; 足以消除对当前工作目录的依赖。</target>
        </trans-unit>
        <trans-unit id="615eff90afa4cc9668282159ebd5fba86b0a2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This is an internal GHC module with an API subject to change. It's recommended use the &lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt; module to import the &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：这是一个内部GHC模块，其API可能会更改。建议使用&lt;a href=&quot;numeric-natural&quot;&gt;Numeric.Natural&lt;/a&gt;模块导入 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="60f2ee22884b6646412af01b670fedfd33ce75d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Unlike for the unary &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt;, there is currently no support for generically deriving &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt;：与一元 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf&quot;&gt;liftRnf&lt;/a&gt;&lt;/code&gt; 不同，当前不支持通用派生 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:liftRnf2&quot;&gt;liftRnf2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5608392e60fb88bd92846a796785eb6d245173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pattern matching in case expressions, lambdas, do-notation, etc&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大小写表达式，lambda，do-notation等的模式匹配&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba63c80e3e98efdf17dda0cdece96c022afb21de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pick first&lt;/strong&gt;. We can simply select the &lt;strong&gt;first matching axiom&lt;/strong&gt; we encounter. In the above example, this would be &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt;. We&amp;rsquo;d then need to entail &lt;code&gt;A a&lt;/code&gt;, for which we have no matching axioms available, causing the above program to be rejected.</source>
          <target state="translated">&lt;strong&gt;首先选择&lt;/strong&gt;。我们可以简单地选择遇到的&lt;strong&gt;第一个匹配公理&lt;/strong&gt;。在上面的示例中，这将是 &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 。然后，我们需要 &lt;code&gt;A a&lt;/code&gt; ，因为我们没有可用的匹配公理，导致上述程序被拒绝。</target>
        </trans-unit>
        <trans-unit id="a9db9b2d82045af0ef687f46fd582968b70dfaa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reflexivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reflexivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b82302cd8a8e37a6d42b327c237c78b4a98d4a8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reject if in doubt&lt;/strong&gt;. An alternative approach would be to check for overlapping axioms, when solving a constraint. When multiple matching axioms are discovered, we &lt;strong&gt;reject the program&lt;/strong&gt;. This approach is a bit conservative, in that it may reject working programs. But it seem much more transparent towards the developer, who can be presented with a clear message, explaining why the program is rejected.</source>
          <target state="translated">&lt;strong&gt;如有疑问，请拒绝&lt;/strong&gt;。另一种方法是在求解约束时检查重叠的公理。当发现多个匹配公理时，我们&lt;strong&gt;拒绝该程序&lt;/strong&gt;。这种方法有点保守，因为它可能会拒绝工作程序。但是对开发人员来说似乎更加透明，可以向开发人员显示明确的信息，解释为什么拒绝该程序。</target>
        </trans-unit>
        <trans-unit id="f0f25f822df506cef863bb9a00c96e4fcc1e4bad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Substitutivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Substitutivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e45f773e26962ea2903c38d6204599890b0de4a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Symmetry&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Symmetry&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="174acfc98226e3aa5c79a549f805f6cffd2f76aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Top level bindings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;顶级绑定&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75903953dc91115d2e5cd9a4146a4781631d6cb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitivity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitivity&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbc186f13791531aa2d22dbaf862de224a352ddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: It's advised to avoid calling this primitive with negative exponents unless it is guaranteed the inverse exists, as failure to do so will likely cause program abortion due to a divide-by-zero fault. See also &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：建议避免使用负指数调用此原语，除非可以确保它存在逆数，否则这样做可能会由于除零错误而导致程序中止。另请参见 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="992f7e50f9c1364f8bae8fe4988cebb6afeb5ae8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: The internal implementation of &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; (i.e. which constructors are available) depends on the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; backend used!</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;： &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 的内部实现（即可用的构造函数）取决于使用的 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 后端！</target>
        </trans-unit>
        <trans-unit id="083d34b27586c0efd3bb96a02d93d956f6452f30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: result may become negative if (at least) one argument is &lt;code&gt;minBound&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt;：如果（至少）一个参数为 &lt;code&gt;minBound&lt;/code&gt; ,则结果可能变为负数</target>
        </trans-unit>
        <trans-unit id="58416cb35befd57e074b001d9d43848b0e5f2ef5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;hp2ps&lt;/strong&gt; is distributed in &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; in a GHC source distribution. It was originally developed by Dave Wakeling as part of the HBC/LML heap profiler.</source>
          <target state="translated">&lt;strong&gt;hp2ps&lt;/strong&gt;在GHC源分发中的 &lt;code&gt;ghc/utils/hp2ps&lt;/code&gt; 中分发。它最初是由Dave Wakeling作为HBC / LML堆分析器的一部分开发的。</target>
        </trans-unit>
        <trans-unit id="a2a10c48ea0cdf0ca5edaab63d2e386e55d8c83d" translate="yes" xml:space="preserve">
          <source>= (&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;, &lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;)</source>
          <target state="translated">=（&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;整数&lt;/a&gt;，&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;整数&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4b9374aa68561e358ba9277ebf67e9a0b2cac65c" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th#t:Pred&quot;&gt;Pred&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="6a4a112b1856c707441c9370242edae658a769d2" translate="yes" xml:space="preserve">
          <source>= [&lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Pred&lt;/a&gt;]</source>
          <target state="translated">= [ &lt;a href=&quot;language-haskell-th-syntax#t:Pred&quot;&gt;Pred&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="f3e53936f3c79bf9c4206c8b91a0a0c917161364" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt;（&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b）</target>
        </trans-unit>
        <trans-unit id="22500a4bcb96fc197f5175e32ffc6ecdc6564339" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt;（&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b）</target>
        </trans-unit>
        <trans-unit id="98254af121448be337d889b7151e3095f29dfd2e" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt; -&amp;gt; b)</source>
          <target state="translated">=&amp;gt;（&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;HTML-&lt;/a&gt; &amp;gt; b）</target>
        </trans-unit>
        <trans-unit id="87b9b2b6b45827b7ebbf823fd4e6fa2e656b9896" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (a -&amp;gt; &lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt;（一个-&amp;gt; &lt;a href=&quot;text-show#t:ShowS&quot;&gt;ShowS&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7e543fa87f892cd0310b1be2e1183e668e09b4b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (ann -&amp;gt; m r)</source>
          <target state="translated">=&amp;gt;（Ann-&amp;gt; Mr）</target>
        </trans-unit>
        <trans-unit id="3f837c598bd2a2ea0c21ac7ef916a3ba8c291114" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b)</source>
          <target state="translated">=&amp;gt;（e-&amp;gt; &lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;也许&lt;/a&gt; b）</target>
        </trans-unit>
        <trans-unit id="146ec650c89d3406783a47923e5bcd00b024cf1a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; a -&amp;gt; e)</source>
          <target state="translated">=&amp;gt;（e-&amp;gt; a-&amp;gt; e）</target>
        </trans-unit>
        <trans-unit id="28b8a020a4a70d67b201ecca5ebfe9b3decfac94" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (e -&amp;gt; e' -&amp;gt; e)</source>
          <target state="translated">=&amp;gt;（e-&amp;gt; e'-&amp;gt; e）</target>
        </trans-unit>
        <trans-unit id="d1cff79143a6b98192e6f5c93021392b3bb26523" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (i, i)</source>
          <target state="translated">=&amp;gt;（i，i）</target>
        </trans-unit>
        <trans-unit id="273c01aab4f2aada746f406147099fc43c561169" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (r -&amp;gt; a)</source>
          <target state="translated">=&amp;gt;（r-&amp;gt; a）</target>
        </trans-unit>
        <trans-unit id="98cb27f97fefd7391598e198b2314a4052bd3f10" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (s -&amp;gt; (a, s))</source>
          <target state="translated">=&amp;gt;（s-&amp;gt;（a，s））</target>
        </trans-unit>
        <trans-unit id="40a084ccf2eb50cdea0902780e3641bbeeb218a0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="translated">=&amp;gt;（t-&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;字符串&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a913d2dfb1e9cb8a3706aeccb247062382be5958" translate="yes" xml:space="preserve">
          <source>=&amp;gt; (t -&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f7f76239cb27ca373456dbde8bc8bedbe3e3f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-bool#t:Bool&quot;&gt;布尔&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="631db25a13c5bd3f3a27fb66e2b126a624973fe7" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;可能是&lt;/a&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3b4666c0db847e1f4ef59969ccc1e08d98e0fb5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;字符串&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83f228b1575a69db7fa34e7e1f31ba1fcc909002" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="9b29c2ad51aea488dc493c38480ca6f86fb32ef5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eea19132ccdb3f07c5c85871217ec3b42357147" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a090ffafec70ef99fa90de5566cfbed70873913" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c85809d4a3a2bbe15915426aa3ae9d49b837b4" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="881da90599e1b286facbeb80f0b5665a56f022f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="c0ed1cf1dee5f53006a4c0bd4c39fd64413da332" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-error#t:ErrorT&quot;&gt;ErrorT&lt;/a&gt; EMA</target>
        </trans-unit>
        <trans-unit id="43faa2c3584d57723d2b7894cdd8de390f7d6ff3" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;ExceptT&lt;/a&gt; e m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-except#t:ExceptT&quot;&gt;除外&lt;/a&gt; ema</target>
        </trans-unit>
        <trans-unit id="ed1c848733ee83ef5cfd6f49ba6a222cc681fb5b" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; r w s a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWS&quot;&gt;RWS&lt;/a&gt; rwsa</target>
        </trans-unit>
        <trans-unit id="0d59b61a3690bc45a5667c7d9d686fd7aae890a6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-cps#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="e04a43f264efe742e62b7c872cf3243a4e74e724" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-lazy#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="46a15491d5a54f8e9623cc81bd3b40c08cc35bc5" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; r w s m a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;control-monad-trans-rws-strict#t:RWST&quot;&gt;RWST&lt;/a&gt; rwsma</target>
        </trans-unit>
        <trans-unit id="1decabf293013a44ad8fb38d770351c0b3d3eff0" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;动态&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c49f72d1d47fd85210f06fe46bd2fbdba18a7f1" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt;当&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;缺少&lt;/a&gt;外交事务委员会</target>
        </trans-unit>
        <trans-unit id="c6dd57371651023369288a8ddebf01f317b257ab" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f a c</source>
          <target state="translated">=&amp;gt;当&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;缺少&lt;/a&gt;外交事务委员会</target>
        </trans-unit>
        <trans-unit id="01807040766915893b46814bd7bc992c2c731d87" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="f3e23cdc0abf474625d6acfcfc952ed151e46c12" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; fkac</target>
        </trans-unit>
        <trans-unit id="e4ec523b9e7b9c9afd657cd3f09a05fbaa7be373" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:SimpleWhenMissing&quot;&gt;SimpleWhenMissing&lt;/a&gt; kac</target>
        </trans-unit>
        <trans-unit id="5b3d889a0b4ee8e84ff7b2d421af97fb78b317dd" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; f k a c</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt; fkac</target>
        </trans-unit>
        <trans-unit id="998942da66b438367a1103e796eb6fe2d1d3b071" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-text-lazy-builder-realfloat#t:FPFormat&quot;&gt;FPFormat&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d97087128e0e8d5868c008414eb04d89f5c495f9" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;data-time-format#t:TimeLocale&quot;&gt;TimeLocale&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16402fa4cd4c09cc613611f7301a7d80b85c6647" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="64674fd23e15a8758e1e185aedc3564f71140d67" translate="yes" xml:space="preserve">
          <source>=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</source>
          <target state="translated">=&amp;gt; &lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a</target>
        </trans-unit>
        <trans-unit id="7cc439ff40c5b4dedd82f1f56048dc9dea26eb6f" translate="yes" xml:space="preserve">
          <source>=&amp;gt; [(node, key, [key])]</source>
          <target state="translated">=&amp;gt; [（（node，key，[key]））]</target>
        </trans-unit>
        <trans-unit id="43c78599b734a8beb8eaf6cf4e3c3a77e20137fe" translate="yes" xml:space="preserve">
          <source>=&amp;gt; a</source>
          <target state="translated">=&amp;gt;一个</target>
        </trans-unit>
        <trans-unit id="9ed6660105e653b094e0abb01e8f35fac4855dca" translate="yes" xml:space="preserve">
          <source>=&amp;gt; dev</source>
          <target state="translated">=&amp;gt;开发</target>
        </trans-unit>
        <trans-unit id="6947818ac409551f11fbaa78f0ea6391960aa5b8" translate="yes" xml:space="preserve">
          <source>==</source>
          <target state="translated">==</target>
        </trans-unit>
        <trans-unit id="6bb984861a61b745289ffc16ea1e0057086b9c13" translate="yes" xml:space="preserve">
          <source>@&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; bs) = &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [&lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; bs]</source>
          <target state="translated">@ &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;&lt;a href=&quot;data-binary-builder#v:fromShortByteString&quot;&gt;fromShortByteString&lt;/a&gt;&lt;/code&gt; bs）= &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:fromChunks&quot;&gt;fromChunks&lt;/a&gt;&lt;/code&gt; [ &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#v:fromShort&quot;&gt;fromShort&lt;/a&gt;&lt;/code&gt; bs]</target>
        </trans-unit>
        <trans-unit id="a3f4dc36787602cc5de507d13c594861d488c7eb" translate="yes" xml:space="preserve">
          <source>A &quot;-&amp;gt;&quot; string</source>
          <target state="translated">一个&amp;ldquo;-&amp;gt;&amp;rdquo;字符串</target>
        </trans-unit>
        <trans-unit id="3dbf51df963b10779a311937a8f60e762c73a212" translate="yes" xml:space="preserve">
          <source>A &quot;::&quot; string</source>
          <target state="translated">一个&quot;::&quot;字符串</target>
        </trans-unit>
        <trans-unit id="300f220bfe895126a57222e655e8c3d3cabdf03a" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&amp;ldquo;普通&amp;rdquo;类型构造函数。根据需要使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; 返回&amp;ldquo; Fancier&amp;rdquo;类型的构造函数。目前，此规范化声明将永远不会附加派生实例（如果您希望检查实例，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10a841c387fe820bc69427b7c8889b542a6b0766" translate="yes" xml:space="preserve">
          <source>A &quot;plain&quot; type constructor. &quot;Fancier&quot; type constructors are returned using &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; as appropriate. At present, this reified declaration will never have derived instances attached to it (if you wish to check for an instance, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&amp;ldquo;普通&amp;rdquo;类型构造函数。根据需要使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:FamilyI&quot;&gt;FamilyI&lt;/a&gt;&lt;/code&gt; 返回&amp;ldquo; Fancier&amp;rdquo;类型的构造函数。目前，此规范化声明将永远不会附加派生实例（如果您希望检查实例，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reifyInstances&quot;&gt;reifyInstances&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="32c1213ff43ed2016bf02de4b047ebc7b374b44b" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">一个&amp;ldquo;原始&amp;rdquo;类型构造函数，不能用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; 表示。示例： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ， &lt;code&gt;Int#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8cadfacc5513088f5ce5adc653861e33911e323" translate="yes" xml:space="preserve">
          <source>A &quot;primitive&quot; type constructor, which can't be expressed with a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt;. Examples: &lt;code&gt;(-&amp;gt;)&lt;/code&gt;, &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">一个&amp;ldquo;原始&amp;rdquo;类型构造函数，不能用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Dec&quot;&gt;Dec&lt;/a&gt;&lt;/code&gt; 表示。示例： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; ， &lt;code&gt;Int#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b95014d55a1a5c44f3c7bc23c6504bed812af75" translate="yes" xml:space="preserve">
          <source>A &quot;raw&quot; (disk) device which supports block binary read and write operations and may be seekable only to positions of certain granularity (block- aligned).</source>
          <target state="translated">一个 &quot;原始&quot;(磁盘)设备,它支持块二进制读写操作,并且可以只寻找到一定粒度的位置(块对齐)。</target>
        </trans-unit>
        <trans-unit id="40dadc0fe1ae92b18009dce1f8fd8927976b9479" translate="yes" xml:space="preserve">
          <source>A &quot;standard&quot; derived instance</source>
          <target state="translated">一个 &quot;标准 &quot;派生实例</target>
        </trans-unit>
        <trans-unit id="a9c3609906f2647fca409f7da980e584e3ef11e0" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">一个&amp;ldquo;值&amp;rdquo;变量（与类型变量相反，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d2fa3eeda719de99d1617880e4ee077e0acc83a6" translate="yes" xml:space="preserve">
          <source>A &quot;value&quot; variable (as opposed to a type variable, see &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">一个&amp;ldquo;值&amp;rdquo;变量（与类型变量相反，请参见 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TyVarI&quot;&gt;TyVarI&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d099ba358135489de4b98f8bef8e1700327509fb" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;code&gt;Found hole&lt;/code&gt;&amp;rdquo; error usually terminates compilation, like any other type error. After all, you have omitted some code from your program. Nevertheless, you can run and test a piece of code containing holes, by using the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; flag. This flag defers errors produced by typed holes until runtime, and converts them into compile-time warnings. These warnings can in turn be suppressed entirely by &lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wno-typed-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与其他任何类型的错误一样，&amp;ldquo; &lt;code&gt;Found hole&lt;/code&gt; &amp;rdquo;错误通常会终止编译。毕竟，您已经从程序中省略了一些代码。不过，您可以使用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;标志来运行和测试一段包含孔的代码。该标志将键入的空洞产生的错误推迟到运行时，然后将它们转换为编译时警告。反过来，这些警告可以完全被&lt;a href=&quot;using-warnings#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wno-typed-holes&lt;/code&gt; &lt;/a&gt;抑制。</target>
        </trans-unit>
        <trans-unit id="03ff9cc92a1ea810e41d8095971be93bdf74f086" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;literate Haskell&amp;rdquo; module.</source>
          <target state="translated">&amp;ldquo;识字的Haskell&amp;rdquo;模块。</target>
        </trans-unit>
        <trans-unit id="8fe0e5fa44b3983941075b4a786a25d59bed2413" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable topological sort&amp;rdquo; here, we mean that we perform this algorithm (which we call &lt;em&gt;ScopedSort&lt;/em&gt;):</source>
          <target state="translated">这里的&amp;ldquo;稳定拓扑排序&amp;rdquo;是指我们执行此算法（我们称为&lt;em&gt;ScopedSort&lt;/em&gt;）：</target>
        </trans-unit>
        <trans-unit id="65e8bde33d0926b669005135d74a4a27a9f4e93e" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;strict pattern match&amp;rdquo; is any pattern match that can fail. For example, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;(x:xs)&lt;/code&gt;, &lt;code&gt;!z&lt;/code&gt;, and &lt;code&gt;C x&lt;/code&gt; are strict patterns, but &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;~(1,2)&lt;/code&gt; are not. For the purposes of &lt;code&gt;ApplicativeDo&lt;/code&gt;, a pattern match against a &lt;code&gt;newtype&lt;/code&gt; constructor is considered strict.</source>
          <target state="translated">&amp;ldquo;严格模式匹配&amp;rdquo;是任何可能失败的模式匹配。例如， &lt;code&gt;()&lt;/code&gt; ， &lt;code&gt;(x:xs)&lt;/code&gt; ， &lt;code&gt;!z&lt;/code&gt; ，和 &lt;code&gt;C x&lt;/code&gt; 是严格的模式，但 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;~(1,2)&lt;/code&gt; 都没有。为宗旨 &lt;code&gt;ApplicativeDo&lt;/code&gt; ，针对模式匹配 &lt;code&gt;newtype&lt;/code&gt; 构造被认为是严格的。</target>
        </trans-unit>
        <trans-unit id="f547f0739b0d3ec8b58b70d55fe4382a3dcaab7d" translate="yes" xml:space="preserve">
          <source>A '(' character</source>
          <target state="translated">一个'('字符</target>
        </trans-unit>
        <trans-unit id="70d5a19191116accb71ec443cd4b4fc4796865be" translate="yes" xml:space="preserve">
          <source>A ')' character</source>
          <target state="translated">一个')'字符</target>
        </trans-unit>
        <trans-unit id="5c59fc97f8f16f9e84989be6184e3be3c12f4c4d" translate="yes" xml:space="preserve">
          <source>A ',' character</source>
          <target state="translated">一个','字</target>
        </trans-unit>
        <trans-unit id="8cea7bc9d7fd5c53754fe5fa302c98ab7ebba9d0" translate="yes" xml:space="preserve">
          <source>A ';' character</source>
          <target state="translated">一个';'字符</target>
        </trans-unit>
        <trans-unit id="24a06b0596e6f9b715b619a7c1e59cb58205d143" translate="yes" xml:space="preserve">
          <source>A '=' character</source>
          <target state="translated">一个'='字符</target>
        </trans-unit>
        <trans-unit id="f781f6726d451e5c82ca330b01816e92ba6ee9b1" translate="yes" xml:space="preserve">
          <source>A '[' character</source>
          <target state="translated">一个'['字符</target>
        </trans-unit>
        <trans-unit id="f989a4679028d9554fb0771f1f50eeed8579ba0d" translate="yes" xml:space="preserve">
          <source>A ']' character</source>
          <target state="translated">一个']'字符</target>
        </trans-unit>
        <trans-unit id="fa5fc1c81727f1321da12121ae03096bcaacada5" translate="yes" xml:space="preserve">
          <source>A '{' character</source>
          <target state="translated">一个'{'字符</target>
        </trans-unit>
        <trans-unit id="f0864bd7f5f8f23f2a725f53240aa607578e2ea5" translate="yes" xml:space="preserve">
          <source>A '}' character</source>
          <target state="translated">一个'}'字符</target>
        </trans-unit>
        <trans-unit id="0d686b1feab210fa1d571b1cf64d0dc555ea4552" translate="yes" xml:space="preserve">
          <source>A (partial) type signature has the following form: &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt;. It consists of three parts:</source>
          <target state="translated">（部分）类型签名具有以下形式： &lt;code&gt;forall a b .. . (C1, C2, ..) =&amp;gt; tau&lt;/code&gt; 。它包括三个部分：</target>
        </trans-unit>
        <trans-unit id="f80c2a8ab20b3b616d4d4b2f353d1a0756e8af37" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#safe-language&quot;&gt;safe language&lt;/a&gt; dialect of Haskell that provides stricter guarantees about the code. It allows types and module boundaries to be trusted.</source>
          <target state="translated">一个&lt;a href=&quot;#safe-language&quot;&gt;安全的语言&lt;/a&gt;哈斯克尔的方言提供了有关代码更严格的保证。它允许类型和模块边界被信任。</target>
        </trans-unit>
        <trans-unit id="240604f168c64bbbbd9cc3f79b1c96c50e4da4c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;#&lt;/code&gt; is followed by optional spaces and tabs, an alphanumeric keyword that describes the kind of processing, and its arguments. Arguments look like C expressions separated by commas (they are not written inside parens). They extend up to the nearest unmatched &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt;, or to the end of line if it occurs outside any &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; and is not preceded by a backslash. Backslash-newline pairs are stripped.</source>
          <target state="translated">一个 &lt;code&gt;#&lt;/code&gt; 后面是可选的空格和制表符，它描述的那种处理的字母数字关键字，它的参数。参数看起来像用逗号分隔的C表达式（它们不是写在括号内）。它们扩展到最接近的不匹配 &lt;code&gt;)&lt;/code&gt; ， &lt;code&gt;]&lt;/code&gt; 或 &lt;code&gt;}&lt;/code&gt; ，或者扩展到行的末尾（如果它出现在任何 &lt;code&gt;() [] {} '' &quot;&quot; /**/&lt;/code&gt; 并且前面没有反斜杠）。反斜杠-换行符对被去除。</target>
        </trans-unit>
        <trans-unit id="ec7d45efe24e17a78b3531b77507cc5b414969c3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:&lt;/code&gt; character</source>
          <target state="translated">A &lt;code&gt;:&lt;/code&gt; 字符</target>
        </trans-unit>
        <trans-unit id="4d77aa84dcc8476d8b0a59a06fc9910da40d4c94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 样功能，专用于该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 幺半，它利用了内部结构的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 以避免缠绕在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 在某些点处。</target>
        </trans-unit>
        <trans-unit id="79c191e27824000624b968ce755ce2407b5fc3a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; that describes the error.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 描述错误。</target>
        </trans-unit>
        <trans-unit id="c8af9e26c7ea200796fafc8da4bdbcb725df4cd0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58fb0b6ff8af11490e6db18e3159b3eb14567f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是表示处理一个线程的抽象类型。 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例在 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 上实现任意的总排序。该 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例可以让你转换任意值 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 字符串形式; 在调试或诊断并发程序的行为时，偶尔显示 &lt;code&gt;&lt;a href=&quot;control-concurrent#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 值很有用。</target>
        </trans-unit>
        <trans-unit id="ce7ce3c377d39b823d763d8b4302a42e6c97ffce" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is a synchronising variable, used for communication between concurrent threads. It can be thought of as a box, which may be empty or full.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 是同步的变量，用于并发线程之间的通信。可以将其视为一个盒子，可以是空的或满的。</target>
        </trans-unit>
        <trans-unit id="af4f02e01c3ad2f55652fc8918f170a9b5f03f08" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; is like a &lt;code&gt;TChan&lt;/code&gt;, with two important differences:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 就像一个 &lt;code&gt;TChan&lt;/code&gt; ，有两个重要的区别：</target>
        </trans-unit>
        <trans-unit id="db398cefd7bed902dc3f0468dccbf2a712235464" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 没有 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 实例可以仅在结合使用图案总是匹配，如newtypes，元组，数据类型仅与单个数据构造，和无可辩驳图案（ &lt;code&gt;~pat&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d52facfcc17560b0b9fcad065ab617e3ee01a7a6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 没有 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 实例可以仅在结合使用图案总是匹配，如newtypes，元组，数据类型仅与单个数据构造，和无可辩驳图案（ &lt;code&gt;~pat&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c2ad78e77b876113c12279bae00129914cb00534" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; will generally be more efficient (in terms of both time and space) than the equivalent &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; with the same element type. However, &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; is strict in its elements - so don't use &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; if you require the non-strictness that &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; provides.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 通常将是更有效的（在时间和空间方面）比等效 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 具有相同的元素类型。但是， &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 的元素很严格-因此，如果您需要 &lt;code&gt;&lt;a href=&quot;data-array#v:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 提供的非严格性，请不要使用 &lt;code&gt;&lt;a href=&quot;data-array-unboxed#t:UArray&quot;&gt;UArray&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1d5b0a46bf9ac13012695d647011268c6839438" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或通过使用从操作&lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt;它可以被解释为包含8位的字符。</target>
        </trans-unit>
        <trans-unit id="f0361d0a51c1f43d10a9cb740bc7c3263eaf2423" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; represents the result of running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. It unfolds as a sequence of chunks of data. These chunks come in two forms:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 代表运行的结果 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。它以数据块序列的形式展开。这些块有两种形式：</target>
        </trans-unit>
        <trans-unit id="a2a67d6507558e86947578e9d9e53ccc77b5315b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; together with the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; of free bytes. The filled space starts at offset 0 and ends at the first free byte.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Buffer&quot;&gt;Buffer&lt;/a&gt;&lt;/code&gt; 与一起 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 的自由字节。填充的空间从偏移量0开始，到第一个空闲字节结束。</target>
        </trans-unit>
        <trans-unit id="811beb8fb95b58583e6d93fef1cf1359e8bd2557" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; action denotes a computation of a value that writes a stream of bytes as a side-effect. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are strict in their side-effect; i.e., the stream of bytes will always be written before the computed value is returned.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 动作表示将字节流作为副作用的值的计算。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 的副作用很严格；即，字节流将始终在返回计算值之前写入。</target>
        </trans-unit>
        <trans-unit id="77ba64f4eea7ca7040ede60a91c0479a0256585a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或通过使用从操作&lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt;它可以被解释为包含8位的字符。</target>
        </trans-unit>
        <trans-unit id="3742f257dac22eaeb1f72c5a59a402dd9caed9a3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或通过使用从操作&lt;a href=&quot;data-bytestring-char8&quot;&gt;Data.ByteString.Char8&lt;/a&gt;它可以被解释为包含8位的字符。</target>
        </trans-unit>
        <trans-unit id="87acc03140b6a38efd5eb569210acf530d577e77" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; may only represent a monomorphic value; an attempt to create a value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; from a polymorphically-typed expression will result in an ambiguity error (see &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 可仅表示单态值; 尝试从多态类型的表达式创建 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 类型的值的尝试将导致歧义错误（请参见 &lt;code&gt;&lt;a href=&quot;data-dynamic#v:toDyn&quot;&gt;toDyn&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7559ec7e510228d1d09527f56d2e4f26a8324238" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to each input of the comparison function.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Comparison&quot;&gt;Comparison&lt;/a&gt;&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 可以应用它的功能参数的比较功能的每个输入。</target>
        </trans-unit>
        <trans-unit id="dfe92df845c7b9c6045ec318c8250ac09ae3d416" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; can apply its function argument to the input of the predicate.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Predicate&quot;&gt;Predicate&lt;/a&gt;&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 可以将其功能参数谓词的输入。</target>
        </trans-unit>
        <trans-unit id="89f60209ccece04c7a022e1e1c35644383139a1b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; list is one which always has at least one element, but is otherwise identical to the traditional list type in complexity and in terms of API. You will almost certainly want to import this module &lt;code&gt;qualified&lt;/code&gt;.</source>
          <target state="translated">非 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#t:NonEmpty&quot;&gt;NonEmpty&lt;/a&gt;&lt;/code&gt; 列表是始终具有至少一个元素的列表，但在复杂性和API方面与传统列表类型相同。您几乎肯定会想要导入此 &lt;code&gt;qualified&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="344c6ff8d7a2bcd44da8bfd8dc8df57dba6e7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; with the added requirement of a neutral element. Thus any &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, but not the other way around.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 与中性元素的添加要求。因此，任何 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 都是 &lt;code&gt;&lt;a href=&quot;prelude#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ，但并非相反。</target>
        </trans-unit>
        <trans-unit id="e35d89b46351c9630145c0b8bbf882d79457fee2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; is a generalization of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;. Yet unlike the &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; requires the presence of a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) in addition to the associative operator. The requirement for a neutral element prevents many types from being a full Monoid, like &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 是一个概括 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。然而不像 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 中， &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 需要中性元素（的存在 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; 除了结合运算符）。对中性元素的要求可防止许多类型成为完整的Monoid，例如&lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="276d119a24c0525aa19868a36000fbee697e666e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; 样功能，专用于该 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 幺半，它利用了内部结构的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 以避免缠绕在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 在某些点处。</target>
        </trans-unit>
        <trans-unit id="8fd75af820d1f54d527c5ea90ed335e09bb6599b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;-like function, specialized to the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-semigroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; monoid, which takes advantage of the internal structure of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; to avoid wrapping in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; at certain points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031626d15f769e94dae06fe92bad6c13a12414d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是字符的列表。Haskell中的字符串常量是 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="0d557b82ce614c78066224f253d24d1e9e55d7e4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值是Unicode标值的序列，如在定义&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9，Unicode的5.2标准的定义D76&lt;/a&gt;。因此，&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 不能包含U + D800到U + DFFF（含）范围内的值。Haskell实现将所有Unicode代码点（&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4，定义D10&lt;/a&gt;）接受为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值，包括该无效范围内的代码点。这意味着有些 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值不是有效的Unicode标量值，并且此模块中的函数必须处理这些情况。</target>
        </trans-unit>
        <trans-unit id="493151274c14fd9063bbd993eabc297404d04a97" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value is a sequence of Unicode scalar values, as defined in &lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9, definition D76 of the Unicode 5.2 standard&lt;/a&gt;. As such, a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; cannot contain values in the range U+D800 to U+DFFF inclusive. Haskell implementations admit all Unicode code points (&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4, definition D10&lt;/a&gt;) as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values, including code points from this invalid range. This means that there are some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values, and the functions in this module must handle those cases.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值是Unicode标值的序列，如在定义&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=35&quot;&gt;&amp;sect;3.9，Unicode的5.2标准的定义D76&lt;/a&gt;。因此，&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 不能包含U + D800到U + DFFF（含）范围内的值。Haskell实现将所有Unicode代码点（&lt;a href=&quot;http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#page=13&quot;&gt;&amp;sect;3.4，定义D10&lt;/a&gt;）接受为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值，包括该无效范围内的代码点。这意味着有些 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值不是有效的Unicode标量值，并且此模块中的函数必须处理这些情况。</target>
        </trans-unit>
        <trans-unit id="a2ab4f0a1420ff27eb07a2afba8acbdae44df567" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; represents the version of a software entity.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;data-version#t:Version&quot;&gt;Version&lt;/a&gt;&lt;/code&gt; 表示软件实体的版本。</target>
        </trans-unit>
        <trans-unit id="5972d36864fed9ff33b5afd14a95cb4b9c27b6e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 是一个无符号整数类型，具有相同的尺寸 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3aa7b36dc316c60d893b5f124b1ba5988ceb7f6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是字符的列表。Haskell中的字符串常量是 &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="39546383234ce70932952659423f3ad369b9dc5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是表示处理一个线程的抽象类型。 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例在 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 上实现任意的总排序。该 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例可以让你转换任意值 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 字符串形式; 在调试或诊断并发程序的行为时，偶尔显示 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 值很有用。</target>
        </trans-unit>
        <trans-unit id="6daf9cc92f22cab1cda41ec56fc33fa5bcb5c1b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an abstract type representing a handle to a thread. &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance implements an arbitrary total ordering over &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt;s. The &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; instance lets you convert an arbitrary-valued &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; to string form; showing a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; value is occasionally useful when debugging or diagnosing the behaviour of a concurrent program.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是表示处理一个线程的抽象类型。 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 的实例，其中 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 上实现任意的总排序。该 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 实例可以让你转换任意值 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 字符串形式; 在调试或诊断并发程序的行为时，偶尔显示 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:ThreadId&quot;&gt;ThreadId&lt;/a&gt;&lt;/code&gt; 值很有用。</target>
        </trans-unit>
        <trans-unit id="c433ed52817c69814ef408474d7e7f0f19916c6d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; 。该 &lt;code&gt;String&lt;/code&gt; 是被称为函数的名称， &lt;code&gt;&lt;a href=&quot;ghc-exception#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 是调用点。该列表的顶部是最近调用的功能。</target>
        </trans-unit>
        <trans-unit id="e99764c1391b456842912477a01318962af2d4bc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 是一个无符号整数类型，具有相同的尺寸 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c448caa1f3bf73a5f3c86998ff8b234d23f5d613" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 实例必须满足以下规律：</target>
        </trans-unit>
        <trans-unit id="f058fc8709c912eeb2b787983729f79e927817fe" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance must satisfy the following laws:</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 实例必须满足以下规律：</target>
        </trans-unit>
        <trans-unit id="37bca98687b6539690c105875b7d36949eaf0920" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是字节和Unicode字符序列的序列之间的转换方案的规范。</target>
        </trans-unit>
        <trans-unit id="9ccfc506522947e455012faccd5c0641a69d1d0d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; 。该 &lt;code&gt;String&lt;/code&gt; 是被称为函数的名称， &lt;code&gt;&lt;a href=&quot;ghc-stack#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 是调用点。该列表的顶部是最近调用的功能。</target>
        </trans-unit>
        <trans-unit id="95958acad6af1408745c1c860b5d733b2d323753" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; is a &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt;. The &lt;code&gt;String&lt;/code&gt; is the name of function that was called, the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; is the call-site. The list is ordered with the most recently called function at the head.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;[(String, SrcLoc)]&lt;/code&gt; 。该 &lt;code&gt;String&lt;/code&gt; 是被称为函数的名称， &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:SrcLoc&quot;&gt;SrcLoc&lt;/a&gt;&lt;/code&gt; 是调用点。该列表的顶部是最近调用的功能。</target>
        </trans-unit>
        <trans-unit id="8456cabb368794e2df99a2d1a5a798a5a772942a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;ghc-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 是一个无符号整数类型，具有相同的尺寸 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e97ac17514823d55db637532fc8cca228a55594" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; is one in which all the &lt;code&gt;Name&lt;/code&gt; references have been resolved to actual addresses or &lt;code&gt;RemoteHValues&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;ghci-resolvedbco#t:ResolvedBCO&quot;&gt;ResolvedBCO&lt;/a&gt;&lt;/code&gt; 是一个在所有 &lt;code&gt;Name&lt;/code&gt; 引用都被解析为实际地址或 &lt;code&gt;RemoteHValues&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e9ca692d8226adf018ac8ce128aabc55c560244" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;-style resource handler for &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的风格的资源处理程序 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e20537f017b881ed432aeb6d8c3c69764ad12389" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance can have any of its values turned into a Template Haskell expression. This is needed when a value used within a Template Haskell quotation is bound outside the Oxford brackets (&lt;code&gt;[| ... |]&lt;/code&gt;) but not at the top level. As an example:</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; 实例可以有任何变成一个模板的Haskell表达其值的。当模板Haskell引号中使用的值绑定在牛津方括号（ &lt;code&gt;[| ... |]&lt;/code&gt; ）之外而不是顶层时，需要使用此值。举个例子：</target>
        </trans-unit>
        <trans-unit id="8baf8997f83651b56856d51ed22119ab60baf8c6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; instance must satisfy &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; for all &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;$(...)&lt;/code&gt; is a Template Haskell splice.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Lift&quot;&gt;Lift&lt;/a&gt;&lt;/code&gt; 实例必须对所有 &lt;code&gt;x&lt;/code&gt; 都满足 &lt;code&gt;$(lift x) &amp;equiv; x&lt;/code&gt; ，其中 &lt;code&gt;$(...)&lt;/code&gt; 是模板Haskell拼接。</target>
        </trans-unit>
        <trans-unit id="dc2e529d77216b7e230e75736a12096341b81566" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; without a &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instance may only be used in conjunction with pattern that always match, such as newtypes, tuples, data types with only a single data constructor, and irrefutable patterns (&lt;code&gt;~pat&lt;/code&gt;).</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 没有 &lt;code&gt;&lt;a href=&quot;prelude#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 实例可以仅在结合使用图案总是匹配，如newtypes，元组，数据类型仅与单个数据构造，和无可辩驳图案（ &lt;code&gt;~pat&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="01cb4e7f2872a463ecfc84cecc5fd37176ad2686" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; is a list of characters. String constants in Haskell are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 是字符的列表。Haskell中的字符串常量是 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="16c73c4644db1dd430eecd595b2935abcbd70f5e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; is an unsigned integral type, with the same size as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;prelude#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 是一个无符号整数类型，具有相同的尺寸 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5384336a86ebc421cc3fe658790659229a2e63f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; is a method for deciding at run-time which type of interaction to use.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Behavior&quot;&gt;Behavior&lt;/a&gt;&lt;/code&gt; 是用于在运行时要使用的相互作用的类型决定的方法。</target>
        </trans-unit>
        <trans-unit id="45d218cdb4af63fb065f7347943499e7d49ef9be" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; function takes a monadic action &lt;code&gt;m&lt;/code&gt; as input, and outputs an IO action which performs the underlying impure part of &lt;code&gt;m&lt;/code&gt; and returns the '&lt;code&gt;pure'&lt;/code&gt; part of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#t:RunIO&quot;&gt;RunIO&lt;/a&gt;&lt;/code&gt; 函数采用一个monadic动作 &lt;code&gt;m&lt;/code&gt; 作为输入，并输出其执行的基本部分不纯的IO动作 &lt;code&gt;m&lt;/code&gt; ，并返回&amp;ldquo; &lt;code&gt;pure'&lt;/code&gt; 的一部分 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3139966130ea6dafab5ae56d42fa83f1c983bce8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is a specification of a conversion scheme between sequences of bytes and sequences of Unicode characters.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是字节和Unicode字符序列的序列之间的转换方案的规范。</target>
        </trans-unit>
        <trans-unit id="1a15ba8c0101a0b559f5881de53f7fa0649c9e6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 组合器生成一条 &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 消息。该参数是一些常规解析器消息。</target>
        </trans-unit>
        <trans-unit id="d7c33b518e905e06246fdc3442ce5bfca419239f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ef7fe44084ddf44d2e8bb742356ef4d58d6b59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; 由所生成的消息 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; 组合子。该参数描述了预期的项目。</target>
        </trans-unit>
        <trans-unit id="2f54fff1c216809b3a5e0dbc637601d50f8c6c28" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; 自动地被生成的消息 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 组合子。参数是意外输入。</target>
        </trans-unit>
        <trans-unit id="cd574240b0c567cd017058a316ed035f46f6524e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; 组合器生成了一条 &lt;code&gt;&lt;a href=&quot;text-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; 消息。该参数描述意外项目。</target>
        </trans-unit>
        <trans-unit id="c19aa3725eed1ff35ec390fbcd0c985fd5b931ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 组合器生成一条 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; 消息。该参数是一些常规解析器消息。</target>
        </trans-unit>
        <trans-unit id="c65c2017bc5e0477e9c2b63e9054f9b8989ca0a8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; combinator. The argument is some general parser message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbea807bde10982fba750640fdd252b73cdd256c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the expected item.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:Expect&quot;&gt;Expect&lt;/a&gt;&lt;/code&gt; 由所生成的消息 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--63--62-&quot;&gt;&amp;lt;?&amp;gt;&lt;/a&gt;&lt;/code&gt; 组合子。该参数描述了预期的项目。</target>
        </trans-unit>
        <trans-unit id="a0592092bb04d822c205343ec720a927bd033f59" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; message is automatically generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; combinator. The argument is the unexpected input.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:SysUnExpect&quot;&gt;SysUnExpect&lt;/a&gt;&lt;/code&gt; 自动地被生成的消息 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:satisfy&quot;&gt;satisfy&lt;/a&gt;&lt;/code&gt; 组合子。参数是意外输入。</target>
        </trans-unit>
        <trans-unit id="043b63a3a919975f6460c5dd3c3a8b5b0fcacbb9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; message is generated by the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; combinator. The argument describes the unexpected item.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:unexpected&quot;&gt;unexpected&lt;/a&gt;&lt;/code&gt; 组合器生成了一条 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#v:UnExpect&quot;&gt;UnExpect&lt;/a&gt;&lt;/code&gt; 消息。该参数描述意外项目。</target>
        </trans-unit>
        <trans-unit id="97982bdf22f3c28d9d65ec6b0247f3758c15fa0c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Builder&lt;/code&gt; is an efficient way to build lazy &lt;code&gt;Text&lt;/code&gt; values. There are several functions for constructing builders, but only one to inspect them: to extract any data, you have to turn them into lazy &lt;code&gt;Text&lt;/code&gt; values using &lt;code&gt;toLazyText&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;Builder&lt;/code&gt; 是建立懒惰的有效途径 &lt;code&gt;Text&lt;/code&gt; 值。构造构建器有几种功能，但只有一种功能可以检查它们：要提取任何数据，您必须使用 &lt;code&gt;toLazyText&lt;/code&gt; 将它们转换为惰性 &lt;code&gt;Text&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="994c45c3efba13b92d41911d6419360be708120c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DEPRECATED&lt;/code&gt; pragma lets you specify that a particular function, class, or type is deprecated.</source>
          <target state="translated">使用 &lt;code&gt;DEPRECATED&lt;/code&gt; 编译指示可以指定不赞成使用特定的函数，类或类型。</target>
        </trans-unit>
        <trans-unit id="202df593255e09bcdac86158dc3e1eaaeacee3f8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HasField x r a&lt;/code&gt; constraint represents the fact that &lt;code&gt;x&lt;/code&gt; is a field of type &lt;code&gt;a&lt;/code&gt; belonging to a record type &lt;code&gt;r&lt;/code&gt;. The &lt;code&gt;getField&lt;/code&gt; method gives the record selector function.</source>
          <target state="translated">甲 &lt;code&gt;HasField x r a&lt;/code&gt; 约束表示一个事实，即 &lt;code&gt;x&lt;/code&gt; 是类型的字段 &lt;code&gt;a&lt;/code&gt; 属于记录类型 &lt;code&gt;r&lt;/code&gt; 。该 &lt;code&gt;getField&lt;/code&gt; 的方法给出了记录选择功能。</target>
        </trans-unit>
        <trans-unit id="48ba20858c6e487ee442bbf0e918d296f38bac12" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Message a&lt;/code&gt; is a message that returns a value of type &lt;code&gt;a&lt;/code&gt;. These are requests sent from GHC to the server.</source>
          <target state="translated">甲 &lt;code&gt;Message a&lt;/code&gt; 是一条消息，返回类型的值 &lt;code&gt;a&lt;/code&gt; 。这些是从GHC发送到服务器的请求。</target>
        </trans-unit>
        <trans-unit id="4cb20e68d9cba85e4c2de51bcc3a4286e1b2b4ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ModGuts&lt;/code&gt; holds all of the module&amp;rsquo;s top level bindings which we can examine. These bindings are of type &lt;code&gt;CoreBind&lt;/code&gt; and effectively represent the binding of a name to body of code. Top-level module bindings are part of a &lt;code&gt;ModGuts&lt;/code&gt; in the field &lt;code&gt;mg_binds&lt;/code&gt;. Implementing a pass that manipulates the top level bindings merely needs to iterate over this field, and return a new &lt;code&gt;ModGuts&lt;/code&gt; with an updated &lt;code&gt;mg_binds&lt;/code&gt; field. Because this is such a common case, there is a function provided named &lt;code&gt;bindsOnlyPass&lt;/code&gt; which lifts a function of type &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; to type &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;ModGuts&lt;/code&gt; 保存所有模块的顶层绑定，我们可以检验的。这些绑定的类型为 &lt;code&gt;CoreBind&lt;/code&gt; ，有效地表示名称与代码主体的绑定。顶级模块绑定是 &lt;code&gt;ModGuts&lt;/code&gt; 字段中 &lt;code&gt;mg_binds&lt;/code&gt; 。实现操作顶级绑定的传递只需要遍历此字段，并返回具有更新的 &lt;code&gt;mg_binds&lt;/code&gt; 字段的新 &lt;code&gt;ModGuts&lt;/code&gt; 。因为这种情况很常见，所以提供了一个名为 &lt;code&gt;bindsOnlyPass&lt;/code&gt; 的函数，该函数将类型 &lt;code&gt;([CoreBind] -&amp;gt; CoreM [CoreBind])&lt;/code&gt; 的函数提升为类型 &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a70f83cdade171d92c14ec57aaab7b2cf6914937" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MutVar#&lt;/code&gt; behaves like a single-element mutable array.</source>
          <target state="translated">甲 &lt;code&gt;MutVar#&lt;/code&gt; 表现得像一个单元素可变数组。</target>
        </trans-unit>
        <trans-unit id="c6337414644ea4c6c26609fea40acca352b7ea57" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Plugin&lt;/code&gt; effectively holds a function which installs a compilation pass into the compiler pipeline. By default there is the empty plugin which does nothing, &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt;, which you should override with record syntax to specify your installation function. Since the exact fields of the &lt;code&gt;Plugin&lt;/code&gt; type are open to change, this is the best way to ensure your plugins will continue to work in the future with minimal interface impact.</source>
          <target state="translated">一个 &lt;code&gt;Plugin&lt;/code&gt; 实际持有其安装一个编译传递到编译器管道的功能。默认情况下，有一个不执行任何操作的空插件 &lt;code&gt;GhcPlugins.defaultPlugin&lt;/code&gt; ，您应该使用记录语法覆盖该插件以指定安装功能。由于&amp;ldquo; &lt;code&gt;Plugin&lt;/code&gt; 类型的确切字段可以更改，因此这是确保您的插件在将来以最小的界面影响继续工作的最佳方法。</target>
        </trans-unit>
        <trans-unit id="c79966287c7a0289106cbf652df27cd92d1d3c79" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Reader&lt;/code&gt; to run.</source>
          <target state="translated">要运行的 &lt;code&gt;Reader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42d146b8c1428a840a06c263b2ea3c6508ddd7d5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; has the effect of generating (a) a specialised version of the function and (b) a rewrite rule (see &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that rewrites a call to the un-specialised function into a call to the specialised one. Moreover, given a &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function &lt;code&gt;f&lt;/code&gt;, GHC will automatically create specialisations for any type-class-overloaded functions called by &lt;code&gt;f&lt;/code&gt;, if they are in the same module as the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma, or if they are &lt;code&gt;INLINABLE&lt;/code&gt;; and so on, transitively.</source>
          <target state="translated">一个 &lt;code&gt;SPECIALIZE&lt;/code&gt; 有发生的（一）功能和（b）重写规则（见的专用版本的效果&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;是重写的非专业函数的调用进入到一个呼叫）的专业之一。而且，给定函数 &lt;code&gt;f&lt;/code&gt; 的 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示，GHC将自动为 &lt;code&gt;f&lt;/code&gt; 调用的任何类型类重载函数创建专用化，如果它们与 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示位于同一模块中，或者它们是 &lt;code&gt;INLINABLE&lt;/code&gt; ；等等。</target>
        </trans-unit>
        <trans-unit id="8b980d520829db47b0e6b9e92a84de862c7cc8a1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma can optionally be followed with a &lt;code&gt;INLINE&lt;/code&gt; or &lt;code&gt;NOINLINE&lt;/code&gt; pragma, optionally followed by a phase, as described in &lt;a href=&quot;#inline-noinline-pragma&quot;&gt;INLINE and NOINLINE pragmas&lt;/a&gt;. The &lt;code&gt;INLINE&lt;/code&gt; pragma affects the specialised version of the function (only), and applies even if the function is recursive. The motivating example is this:</source>
          <target state="translated">如&lt;a href=&quot;#inline-noinline-pragma&quot;&gt;INLINE和NOINLINE编译指示中&lt;/a&gt;所述，可以在 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示后面加上 &lt;code&gt;INLINE&lt;/code&gt; 或 &lt;code&gt;NOINLINE&lt;/code&gt; 编译指示，然后可选地后面加上一个阶段。该 &lt;code&gt;INLINE&lt;/code&gt; 编译影响功能（只）的特殊版本，而纵使功能是递归的。激励的例子是这样的：</target>
        </trans-unit>
        <trans-unit id="7b82be1262e45e02f43857ca0ff6515f9db20126" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SPECIALIZE&lt;/code&gt; pragma for a function can be put anywhere its type signature could be put. Moreover, you can also &lt;code&gt;SPECIALIZE&lt;/code&gt; an &lt;em&gt;imported&lt;/em&gt; function provided it was given an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition site (&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;).</source>
          <target state="translated">一个 &lt;code&gt;SPECIALIZE&lt;/code&gt; 的编译功能，可以随时随地把它的类型签名可以放。此外，你还可以 &lt;code&gt;SPECIALIZE&lt;/code&gt; 的&lt;em&gt;导入&lt;/em&gt;功能，它提供了给予 &lt;code&gt;INLINABLE&lt;/code&gt; 在其定义的网站（编译&lt;a href=&quot;#inlinable-pragma&quot;&gt;可以内联编译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a25c001444e85ab6f7b0766980538a555f7440b7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Span&lt;/code&gt; represents the result of an annotation after a &lt;code&gt;Doc&lt;/code&gt; has been rendered, capturing where the annotation now starts and ends in the rendered output.</source>
          <target state="translated">甲 &lt;code&gt;Span&lt;/code&gt; 表示后一个注释的结果 &lt;code&gt;Doc&lt;/code&gt; 已经呈现，捕获其中注解现在开始，并在呈现输出端。</target>
        </trans-unit>
        <trans-unit id="9ed158fbad702e89568f4c1dbb871930a8429284" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Stream&lt;/code&gt; instance is responsible for maintaining the &quot;position within the stream&quot; in the stream state &lt;code&gt;s&lt;/code&gt;. This is trivial unless you are using the monad in a non-trivial way.</source>
          <target state="translated">一个 &lt;code&gt;Stream&lt;/code&gt; 实例负责维护流状态的&amp;ldquo;流中的位置&amp;rdquo; &lt;code&gt;s&lt;/code&gt; 。除非您以非平凡的方式使用monad，否则这是微不足道的。</target>
        </trans-unit>
        <trans-unit id="6768d45124fc6209d1d55206e3becea75d2017a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;data instance&lt;/code&gt; can use GADT syntax for the data constructors, and indeed can define a GADT. For example:</source>
          <target state="translated">一个 &lt;code&gt;data instance&lt;/code&gt; 可以使用GADT语法的数据构造，确实可以定义GADT。例如：</target>
        </trans-unit>
        <trans-unit id="daba80bb3a6be48bbea57e35e9db17367b1d0d13" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;deriving instance&lt;/code&gt; declaration must obey the same rules concerning form and termination as ordinary instance declarations, controlled by the same flags; see &lt;a href=&quot;#instance-decls&quot;&gt;Instance declarations&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;deriving instance&lt;/code&gt; 声明必须遵守有关表格，并终止作为普通实例声明，由相同的标志控制的相同规则; 请参阅&lt;a href=&quot;#instance-decls&quot;&gt;实例声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="59db072390d4948ccdd767966bcedd58bf2bcf38" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;hs-boot&lt;/code&gt; file is compiled by GHC, just like a &lt;code&gt;hs&lt;/code&gt; file:</source>
          <target state="translated">一个 &lt;code&gt;hs-boot&lt;/code&gt; 文件被GHC编译，就像一个 &lt;code&gt;hs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="0ee8809aa12d51318c13f6f45ee2d8d36268a40a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;rec&lt;/code&gt;-block tells the compiler where precisely the recursive knot should be tied. It turns out that the placement of the recursive knots can be rather delicate: in particular, we would like the knots to be wrapped around as minimal groups as possible. This process is known as &lt;em&gt;segmentation&lt;/em&gt;, and is described in detail in Section 3.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;. Segmentation improves polymorphism and reduces the size of the recursive knot. Most importantly, it avoids unnecessary interference caused by a fundamental issue with the so-called &lt;em&gt;right-shrinking&lt;/em&gt; axiom for monadic recursion. In brief, most monads of interest (IO, strict state, etc.) do &lt;em&gt;not&lt;/em&gt; have recursion operators that satisfy this axiom, and thus not performing segmentation can cause unnecessary interference, changing the termination behavior of the resulting translation. (Details can be found in Sections 3.1 and 7.2.2 of &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;.)</source>
          <target state="translated">一个 &lt;code&gt;rec&lt;/code&gt; 嵌段告诉编译器在哪里恰恰是递归的结应接。事实证明，递归结的位置可能非常微妙：特别是，我们希望将结尽可能地包住。这个过程称为&lt;em&gt;分割&lt;/em&gt;，在&lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell的递归do的&lt;/a&gt; 3.2节中有详细描述。分割改善了多态性并减小了递归结的大小。最重要的是，它避免了所谓的用于单子递归的&lt;em&gt;右缩&lt;/em&gt;公理的根本问题所引起的不必要的干扰。简而言之，大多数感兴趣的单子（IO，严格状态等）&lt;em&gt;不&lt;/em&gt;具有满足此公理的递归运算符，因此不执行分段会导致不必要的干扰，从而更改结果转换的终止行为。（有关详细信息，请参见&lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;单子计算中&lt;/a&gt;的值递归的第3.1和7.2.2节。）</target>
        </trans-unit>
        <trans-unit id="0bdbd6d30e59c1faa209edf1aa68a5deb84cd963" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;lexically scoped type variable&lt;/em&gt; can be bound by:</source>
          <target state="translated">甲&lt;em&gt;词法作用域类型变量&lt;/em&gt;可通过约束：</target>
        </trans-unit>
        <trans-unit id="109054251366535f7af799fd6243e0d372229344" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;package environment file&lt;/em&gt; is a file that tells &lt;code&gt;ghc&lt;/code&gt; precisely which packages should be visible. It can be used to create environments for &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; that are local to a shell session or to some file system location. They are intended to be managed by build/package tools, to enable &lt;code&gt;ghc&lt;/code&gt; and &lt;code&gt;ghci&lt;/code&gt; to automatically use an environment created by the tool.</source>
          <target state="translated">一个&lt;em&gt;包环境文件&lt;/em&gt;是讲述了一个文件 &lt;code&gt;ghc&lt;/code&gt; 正是这包应该是可见的。它可用于为shell会话或某些文件系统位置本地的 &lt;code&gt;ghc&lt;/code&gt; 或 &lt;code&gt;ghci&lt;/code&gt; 创建环境。它们旨在由构建/打包工具进行管理，以使 &lt;code&gt;ghc&lt;/code&gt; 和 &lt;code&gt;ghci&lt;/code&gt; 能够自动使用该工具创建的环境。</target>
        </trans-unit>
        <trans-unit id="c8382233c25160218d5faa2b0244da9d3072c08a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;safe import&lt;/em&gt; extension that specifies that the module being imported must be trusted.</source>
          <target state="translated">一个&lt;em&gt;安全的导入&lt;/em&gt;扩展，它指定必须信任要导入的模块。</target>
        </trans-unit>
        <trans-unit id="a2030af640ee35ae911effa3c859071e394be43d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;segment&lt;/em&gt; of a given &lt;code&gt;mdo&lt;/code&gt;-expression is a minimal sequence of generators such that no generator of the sequence depends on an outside generator. As a special case, although it is not a generator, the final expression in an &lt;code&gt;mdo&lt;/code&gt;-expression is considered to form a segment by itself.</source>
          <target state="translated">甲&lt;em&gt;段&lt;/em&gt;给定的 &lt;code&gt;mdo&lt;/code&gt; -expression是发电机的最小序列，使得没有序列发生器取决于外部发电机。作为一种特殊情况，尽管它不是生成器，但 &lt;code&gt;mdo&lt;/code&gt; -expression中的最终表达式本身被认为形成了一个段。</target>
        </trans-unit>
        <trans-unit id="19ca4e3b6cf814de306149f6c08ac93ed06475ee" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;stable pointer&lt;/em&gt; is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection, i.e., it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection (ordinary references may be relocated during garbage collection). Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value.</source>
          <target state="translated">甲&lt;em&gt;稳定指针&lt;/em&gt;是到不能保证垃圾回收的影响，即，它既不被释放，也不会稳定指针垃圾回收过程本身改变的值（普通的引用可以被垃圾收集期间重新定位一个Haskell表达一个参考）。因此，可以将稳定的指针传递给外来代码，该代码可以将其视为对Haskell值的不透明引用。</target>
        </trans-unit>
        <trans-unit id="9598916c07779e260b1bef0d4810f6ea9d7267b5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an expression; if the &amp;ldquo;&amp;hellip;&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03966a369ab9f12abf8e596ab2fa4aeb07d6727e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression quotation is written as &lt;code&gt;[|| ... ||]&lt;/code&gt;, or &lt;code&gt;[e|| ... ||]&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an expression; if the &amp;rdquo;...&amp;rdquo; expression has type &lt;code&gt;a&lt;/code&gt;, then the quotation has type &lt;code&gt;Q (TExp a)&lt;/code&gt;.</source>
          <target state="translated">带&lt;em&gt;类型的&lt;/em&gt;表达式引号写为 &lt;code&gt;[|| ... ||]&lt;/code&gt; 或 &lt;code&gt;[e|| ... ||]&lt;/code&gt; ，其中&amp;ldquo; ...&amp;rdquo;是一个表达式；如果&amp;ldquo; ...&amp;rdquo;表达式的类型为 &lt;code&gt;a&lt;/code&gt; ，则引号的类型为 &lt;code&gt;Q (TExp a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bd2d6413fa23bbe46409864d68196768ad43eda" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04024bbf6ad0e93c59da416e846a98466aa2e965" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;typed&lt;/em&gt; expression splice is written &lt;code&gt;$$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression.</source>
          <target state="translated">一个&lt;em&gt;类型化的&lt;/em&gt;表达式剪接记为 &lt;code&gt;$$x&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是标识符，或 &lt;code&gt;$$(...)&lt;/code&gt; ，其中&amp;ldquo; ...&amp;rdquo;是任意表达式。</target>
        </trans-unit>
        <trans-unit id="e77214962b033f462a16c20eb7078d49bb12efbd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;wrapper&lt;/em&gt; that for any datatype that is in &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt;, performs the conversion between the original value and its &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt;-based representation and then invokes the generic instances.</source>
          <target state="translated">一个针对 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic&quot;&gt;Generic&lt;/a&gt;&lt;/code&gt; 中任何数据类型的&lt;em&gt;包装器&lt;/em&gt;，将在原始值与其基于 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rep&quot;&gt;Rep&lt;/a&gt;&lt;/code&gt; 的表示形式之间进行转换，然后调用通用实例。</target>
        </trans-unit>
        <trans-unit id="b326e9656587b1adc32b0826a631549e0850098e" translate="yes" xml:space="preserve">
          <source>A C &lt;code&gt;printf(3)&lt;/code&gt;-like formatter. This version has been extended by Bart Massey as per the recommendations of John Meacham and Simon Marlow &lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&lt;/a&gt; to support extensible formatting for new datatypes. It has also been extended to support almost all C &lt;code&gt;printf(3)&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;printf(3)&lt;/code&gt; AC printf（3）的格式化程序。根据John Meacham和Simon Marlow的建议，Bart Massey已对该版本进行了扩展，&lt;a href=&quot;http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726&quot;&gt;网址&lt;/a&gt;为http://comments.gmane.org/gmane.comp.lang.haskell.libraries/4726，以支持新数据类型的可扩展格式。它也已扩展为支持几乎所有的C &lt;code&gt;printf(3)&lt;/code&gt; 语法。</target>
        </trans-unit>
        <trans-unit id="7e0f8ee9d576152373e38d95b4048e53733a3d06" translate="yes" xml:space="preserve">
          <source>A C file not produced by the Haskell compiler.</source>
          <target state="translated">一个不是由Haskell编译器产生的C文件。</target>
        </trans-unit>
        <trans-unit id="0aad97c64c03d205c1227f534babfb0125731f8e" translate="yes" xml:space="preserve">
          <source>A C string is a reference to an array of C characters terminated by NUL.</source>
          <target state="translated">C字符串是对以NUL结束的C字符数组的引用。</target>
        </trans-unit>
        <trans-unit id="73ba7d14948cc5309d53b24f871c08ff3a2fc5ec" translate="yes" xml:space="preserve">
          <source>A C template should define a macro or function with name prefixed by &lt;code&gt;hsc_&lt;/code&gt; that handles the construct by emitting the expansion to stdout. See &lt;code&gt;template-hsc.h&lt;/code&gt; for examples.</source>
          <target state="translated">AC模板应定义一个以 &lt;code&gt;hsc_&lt;/code&gt; 为前缀的宏或函数，该宏或函数通过将扩展发送到stdout来处理构造。有关示例，请参见 &lt;code&gt;template-hsc.h&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6886031497104d24437d52b2978fb1d3195d1677" translate="yes" xml:space="preserve">
          <source>A C wide string is a reference to an array of C wide characters terminated by NUL.</source>
          <target state="translated">C宽字符串是对一个以NUL结束的C宽字符数组的引用。</target>
        </trans-unit>
        <trans-unit id="fff4ba731434913625d1042847648e899bcdc46f" translate="yes" xml:space="preserve">
          <source>A DynFlags plugin allows you to modify the &lt;code&gt;DynFlags&lt;/code&gt; that GHC is going to use when processing a given (set of) file(s). &lt;code&gt;DynFlags&lt;/code&gt; is a record containing all sorts of configuration and command line data, from verbosity level to the integer library to use, including compiler hooks, plugins and pretty-printing options. DynFlags plugins allow plugin authors to update any of those values before GHC starts doing any actual work, effectively meaning that the updates specified by the plugin will be taken into account and influence GHC&amp;rsquo;s behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e325f82925ec97e39b08ddc2fdbd0f77145b84c" translate="yes" xml:space="preserve">
          <source>A GADT can only be declared using GADT-style syntax (&lt;a href=&quot;#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;); the old Haskell 98 syntax for data declarations always declares an ordinary data type. The result type of each constructor must begin with the type constructor being defined, but for a GADT the arguments to the type constructor can be arbitrary monotypes. For example, in the &lt;code&gt;Term&lt;/code&gt; data type above, the type of each constructor must end with &lt;code&gt;Term ty&lt;/code&gt;, but the &lt;code&gt;ty&lt;/code&gt; need not be a type variable (e.g. the &lt;code&gt;Lit&lt;/code&gt; constructor).</source>
          <target state="translated">只能使用GADT样式的语法&lt;a href=&quot;#gadt-style&quot;&gt;声明&lt;/a&gt; GADT（使用显式构造函数签名声明数据类型）；用于数据声明的旧Haskell 98语法始终声明一个普通的数据类型。每个构造函数的结果类型必须从定义的类型构造函数开始，但是对于GADT，类型构造函数的参数可以是任意单型。例如，在上述 &lt;code&gt;Term&lt;/code&gt; 数据类型中，每个构造函数的类型必须以 &lt;code&gt;Term ty&lt;/code&gt; 结尾，但是 &lt;code&gt;ty&lt;/code&gt; 不必是类型变量（例如 &lt;code&gt;Lit&lt;/code&gt; 构造函数）。</target>
        </trans-unit>
        <trans-unit id="b1c115ed6390536f96008338c3a76d6dc97d17be" translate="yes" xml:space="preserve">
          <source>A Haskell equivalent of the C numeric type will be output. It will be one of &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;LDouble&lt;/code&gt;.</source>
          <target state="translated">将输出等效于C数值类型的Haskell。它将是 &lt;code&gt;{Int,Word}{8,16,32,64}&lt;/code&gt; ， &lt;code&gt;Float&lt;/code&gt; ， &lt;code&gt;Double&lt;/code&gt; 和 &lt;code&gt;LDouble&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="411cbf3d599620cacbd5cc015731fcfe3b92f459" translate="yes" xml:space="preserve">
          <source>A Haskell interface file, probably compiler-generated.</source>
          <target state="translated">一个Haskell接口文件,可能是编译器生成的。</target>
        </trans-unit>
        <trans-unit id="bea884a4fa9bc97a6459261f9e280deaec7399ff" translate="yes" xml:space="preserve">
          <source>A Haskell module.</source>
          <target state="translated">一个Haskell模块。</target>
        </trans-unit>
        <trans-unit id="e5aff74609ec235803608003865846be7a8bd1bc" translate="yes" xml:space="preserve">
          <source>A Map from keys &lt;code&gt;k&lt;/code&gt; to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">从键 &lt;code&gt;k&lt;/code&gt; 到值 &lt;code&gt;a&lt;/code&gt; 的映射。</target>
        </trans-unit>
        <trans-unit id="cea3593e9e6a31d8bb148597b7e5fd17de4ea82d" translate="yes" xml:space="preserve">
          <source>A TextDetails represents a fragment of text that will be output at some point in a &lt;code&gt;Doc&lt;/code&gt;.</source>
          <target state="translated">TextDetails表示将在 &lt;code&gt;Doc&lt;/code&gt; 中的某个点输出的文本片段。</target>
        </trans-unit>
        <trans-unit id="fc9ca598a7522d4ced721535fa37974946883f88" translate="yes" xml:space="preserve">
          <source>A TimeZone is a whole number of minutes offset from UTC, together with a name and a &quot;just for summer&quot; flag.</source>
          <target state="translated">时区是指与UTC偏移的整数分钟,加上名称和 &quot;只为夏天 &quot;的标志。</target>
        </trans-unit>
        <trans-unit id="c5ce154a6a02d4026db50fe3f1a5c49edc516fc7" translate="yes" xml:space="preserve">
          <source>A bang only really has an effect if it precedes a variable or wild-card pattern:</source>
          <target state="translated">只有在变量或通配符模式之前,bang才真正有效果。</target>
        </trans-unit>
        <trans-unit id="bdd93c38550cc32cf4aa813352ba8371915da4f4" translate="yes" xml:space="preserve">
          <source>A bang pattern is allowed in a let or where clause, and makes the binding strict. For example:</source>
          <target state="translated">在let或where子句中允许使用bang模式,并使绑定严格。例如:</target>
        </trans-unit>
        <trans-unit id="dbe85709a7348f901616c420f38c5dde9ca96cf4" translate="yes" xml:space="preserve">
          <source>A bare kind variable (with &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; enabled). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8b165584d313eb61a9a907807491cb2de49845" translate="yes" xml:space="preserve">
          <source>A better method is to keep a global list of all child threads which we should wait for at the end of the program:</source>
          <target state="translated">一个更好的方法是保留一个全局的所有子线程列表,我们应该在程序结束时等待。</target>
        </trans-unit>
        <trans-unit id="6005fc493cfa098670cf6142c7e4205f8cdf474b" translate="yes" xml:space="preserve">
          <source>A better monoid for Maybe</source>
          <target state="translated">一个更好的单体为Maybe</target>
        </trans-unit>
        <trans-unit id="d6fedf65a2cdf1eec5e505a6812db33c8b5b82ec" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym matching an empty sequence.</source>
          <target state="translated">匹配空序列的双向模式同义词。</target>
        </trans-unit>
        <trans-unit id="4177af688c85d2078a0a8ce62a0441115616a0c4" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the front of a non-empty sequence.</source>
          <target state="translated">双向模式同义词查看非空序列的前面。</target>
        </trans-unit>
        <trans-unit id="81df1a482fca8b73fcc642c85849297fd446593b" translate="yes" xml:space="preserve">
          <source>A bidirectional pattern synonym viewing the rear of a non-empty sequence.</source>
          <target state="translated">双向图案同义词查看非空序列的后方。</target>
        </trans-unit>
        <trans-unit id="9d4dd551ba4445c410acc2d23a963ba185817d09" translate="yes" xml:space="preserve">
          <source>A bifunctor is a type constructor that takes two type arguments and is a functor in &lt;em&gt;both&lt;/em&gt; arguments. That is, unlike with &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, a type constructor such as &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; does not need to be partially applied for a &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, and the methods in this class permit mapping functions over the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; value or the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; value, or both at the same time.</source>
          <target state="translated">一个bifunctor是一种构造带两个类型参数，是一个仿函数&lt;em&gt;两个&lt;/em&gt;参数。也就是说，与 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 不同，不需要将诸如 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 之类的类型构造函数部分应用于 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 实例，并且此类中的方法允许同时在 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值或 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 值或两者上映射函数。</target>
        </trans-unit>
        <trans-unit id="de0591af67d2bf9b3b0301e6aff8ce08884f0195" translate="yes" xml:space="preserve">
          <source>A big difference with higher-rank kinds as compared with higher-rank types is that &lt;code&gt;forall&lt;/code&gt;s in kinds &lt;em&gt;cannot&lt;/em&gt; be moved. This is best illustrated by example. Suppose we want to have an instance of &lt;code&gt;HTestEquality&lt;/code&gt; for &lt;code&gt;(:~~:)&lt;/code&gt;.</source>
          <target state="translated">与上位种一大区别与上位类型相比是 &lt;code&gt;forall&lt;/code&gt; 在各种小号&lt;em&gt;不能&lt;/em&gt;移动。最好通过示例说明。假设我们要为 &lt;code&gt;(:~~:)&lt;/code&gt; 拥有一个 &lt;code&gt;HTestEquality&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="018f1834f8f4ba2f827cc9e9d66782e066f8b4db" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使堆快速运行的很大一部分是它们不是空的，因此合并功能可以避免额外的大小写匹配。但是，要利用此优势，我们需要特殊版本的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt; ，它们可以在折叠非空结构（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt; ）时调用更快的半组类合并，以及在折叠时调用类似 &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 的mappend之间进行切换可以为空的结构（例如 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="47779d8a6c1ed5651ad2278a9f8963fba26cb6a4" translate="yes" xml:space="preserve">
          <source>A big part of what makes the heaps fast is that they're non empty, so the merge function can avoid an extra case match. To take advantage of this, though, we need specialized versions of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-sequence#v:foldMapWithIndex&quot;&gt;foldMapWithIndex&lt;/a&gt;&lt;/code&gt;, which can alternate between calling the faster semigroup-like merge when folding over non empty structures (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Node&quot;&gt;Node&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:Digit&quot;&gt;Digit&lt;/a&gt;&lt;/code&gt;), and the &lt;code&gt;&lt;a href=&quot;data-semirgroup#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt;-like mappend, when folding over structures which can be empty (like &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/containers-0.6.2.1/Data-Sequence-Internal.html#t:FingerTree&quot;&gt;FingerTree&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59eaf213264b07a33c9b86cc594f16cfebf034b" translate="yes" xml:space="preserve">
          <source>A binding group is &lt;em&gt;fully generalised&lt;/em&gt; if and only if</source>
          <target state="translated">当且仅当一个绑定组被&lt;em&gt;完全概括&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ac98b71fc651c5cb7838fb8ecc4183a85e5c4f" translate="yes" xml:space="preserve">
          <source>A biographical heap profile displays the portion of the live heap in each of the four states listed above. Usually the most interesting states are the void and drag states: live heap in these states is more likely to be wasted space than heap in the lag or use states.</source>
          <target state="translated">传记式堆配置文件显示了上述四种状态中每一种状态下的活堆部分。通常最有趣的状态是void和drag状态:这些状态下的实时堆比滞后或使用状态下的堆更有可能被浪费空间。</target>
        </trans-unit>
        <trans-unit id="798384519287140522d002a35024512e2c520012" translate="yes" xml:space="preserve">
          <source>A bound thread is a haskell thread that is &lt;em&gt;bound&lt;/em&gt; to an operating system thread. While the bound thread is still scheduled by the Haskell run-time system, the operating system thread takes care of all the foreign calls made by the bound thread.</source>
          <target state="translated">绑定线程是&lt;em&gt;绑定&lt;/em&gt;到操作系统线程的haskell 线程。尽管绑定线程仍由Haskell运行时系统调度，但操作系统线程会处理绑定线程进行的所有外部调用。</target>
        </trans-unit>
        <trans-unit id="3f4f07c153a23dab6881d6b97859240ea5495b6b" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">用于执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的缓冲区分配策略。</target>
        </trans-unit>
        <trans-unit id="3acbb589dc6847927b75f04416af1f081adc5cfc" translate="yes" xml:space="preserve">
          <source>A buffer allocation strategy for executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">用于执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的缓冲区分配策略。</target>
        </trans-unit>
        <trans-unit id="b00aec03f8bf511485eb07886b22c54f4f193a13" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in a sequence of bytes of a pre-determined, fixed size.</source>
          <target state="translated">一个构建器基元,总是产生一个预先确定的固定大小的字节序列。</target>
        </trans-unit>
        <trans-unit id="218c8868a68984ef2191051e647e5ad44495f1c2" translate="yes" xml:space="preserve">
          <source>A builder primitive that always results in sequence of bytes that is no longer than a pre-determined bound.</source>
          <target state="translated">一个构建器基元,它的结果总是不长于一个预先确定的约束的字节序列。</target>
        </trans-unit>
        <trans-unit id="cee5a68b267e0b9eedc95f3e5e46dbbcbd9d7c7d" translate="yes" xml:space="preserve">
          <source>A canonical proxy type</source>
          <target state="translated">一个规范的代理类型</target>
        </trans-unit>
        <trans-unit id="f9785a9266197868d744526bac75698ed903dbc4" translate="yes" xml:space="preserve">
          <source>A capability has been deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e42267c559ef0543a396aeedf38ba2368048b9" translate="yes" xml:space="preserve">
          <source>A capability has been disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86896e42132938a37e212fd5cef10f4151fc9477" translate="yes" xml:space="preserve">
          <source>A capability has been enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58d21d44a4d30e0c00f0ffb699c3dbb7518536" translate="yes" xml:space="preserve">
          <source>A capability has been started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646cfd44f97fd578432c1d7e4ee9f594332ba27b" translate="yes" xml:space="preserve">
          <source>A careful reading of the Haskell 98 Report reveals that fixity declarations (&lt;code&gt;infix&lt;/code&gt;, &lt;code&gt;infixl&lt;/code&gt;, and &lt;code&gt;infixr&lt;/code&gt;) are permitted to appear inside local bindings such those introduced by &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt;. However, the Haskell Report does not specify the semantics of such bindings very precisely.</source>
          <target state="translated">仔细阅读《 Haskell 98报告》后发现，可以将固定性声明（ &lt;code&gt;infix&lt;/code&gt; ， &lt;code&gt;infixl&lt;/code&gt; 和 &lt;code&gt;infixr&lt;/code&gt; ）出现在本地绑定中，例如 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;where&lt;/code&gt; 所引入的绑定。但是，Haskell报告并未非常精确地指定此类绑定的语义。</target>
        </trans-unit>
        <trans-unit id="6cad22f831909a841240c57158600100ecb21412" translate="yes" xml:space="preserve">
          <source>A caveat: this encoding strategy may not be reliable across different versions of GHC. When deriving a &lt;code&gt;Generic&lt;/code&gt; instance is free to choose any nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; it chooses, so if GHC chooses &lt;code&gt;(a :+: b) :+: c&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O, O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[O, I]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I]&lt;/code&gt;. However, if GHC chooses &lt;code&gt;a :+: (b :+: c)&lt;/code&gt;, then the encoding for &lt;code&gt;a&lt;/code&gt; would be &lt;code&gt;[O]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; would be &lt;code&gt;[I, O]&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; would be &lt;code&gt;[I, I]&lt;/code&gt;. (In practice, the current implementation tries to produce a more-or-less balanced nesting of &lt;code&gt;:+:&lt;/code&gt; and &lt;code&gt;:*:&lt;/code&gt; so that the traversal of the structure of the datatype from the root to a particular component can be performed in logarithmic rather than linear time.)</source>
          <target state="translated">注意：这种编码策略在GHC的不同版本之间可能并不可靠。当导出 &lt;code&gt;Generic&lt;/code&gt; 实例是自由选择的任何嵌套 &lt;code&gt;:+:&lt;/code&gt; 和 &lt;code&gt;:*:&lt;/code&gt; 它选择，所以，如果GHC选 &lt;code&gt;(a :+: b) :+: c&lt;/code&gt; ，则编码为 &lt;code&gt;a&lt;/code&gt; 将是 &lt;code&gt;[O, O]&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 将为 &lt;code&gt;[O, I]&lt;/code&gt; ，而 &lt;code&gt;c&lt;/code&gt; 将为 &lt;code&gt;[I]&lt;/code&gt; 。然而，如果GHC选择 &lt;code&gt;a :+: (b :+: c)&lt;/code&gt; ，则对于编码 &lt;code&gt;a&lt;/code&gt; 将是 &lt;code&gt;[O]&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; 。将 &lt;code&gt;[I, O]&lt;/code&gt; ，和 &lt;code&gt;c&lt;/code&gt; 将 &lt;code&gt;[I, I]&lt;/code&gt; 。（实际上，当前实现尝试产生 &lt;code&gt;:+:&lt;/code&gt; 和 &lt;code&gt;:*:&lt;/code&gt; 或多或少的平衡嵌套，以便可以从对数到根的特定形式遍历数据类型的结构，而不是对数地进行遍历。线性时间。）</target>
        </trans-unit>
        <trans-unit id="22d4b5245916ddee4003e31bf87953ef290e9b20" translate="yes" xml:space="preserve">
          <source>A class cannot generally have itself as a superclass. So this is illegal</source>
          <target state="translated">一个类一般不能把自己作为一个超类。所以这是不合法的</target>
        </trans-unit>
        <trans-unit id="f056b7a04761436a087354198406063da33c9730" translate="yes" xml:space="preserve">
          <source>A class declarations can either be abstract or concrete. An abstract class is one with no superclasses or class methods:</source>
          <target state="translated">一个类的声明可以是抽象的,也可以是具体的。一个抽象的类是没有超类或类方法的类。</target>
        </trans-unit>
        <trans-unit id="1b36f377a6bd2fac28e2b563337bb9c2dc25741e" translate="yes" xml:space="preserve">
          <source>A class for categories. Instances should satisfy the laws</source>
          <target state="translated">类的一类。实例应满足以下规律</target>
        </trans-unit>
        <trans-unit id="6fec2d7334def5a7f37888bee18c8bb561acd718" translate="yes" xml:space="preserve">
          <source>A class for things buildable from static pointers.</source>
          <target state="translated">一个可由静态指针构建的事物类。</target>
        </trans-unit>
        <trans-unit id="16f65e9b0b64e45d51e0bcdd76ca8407c6f3cc52" translate="yes" xml:space="preserve">
          <source>A class method</source>
          <target state="translated">一个类方法</target>
        </trans-unit>
        <trans-unit id="6f3ca3b97f5cb6f003ec47445c70a8cb5a13ebc9" translate="yes" xml:space="preserve">
          <source>A class method without a definition (neither a default definition, nor a definition in the appropriate instance) was called. The &lt;code&gt;String&lt;/code&gt; gives information about which method it was.</source>
          <target state="translated">没有定义（没有默认定义，也没有相应实例中的定义）的类方法被调用。该 &lt;code&gt;String&lt;/code&gt; 给出了关于它是哪种方法的信息。</target>
        </trans-unit>
        <trans-unit id="820008a62ac203372438ae344a8da118e60912d3" translate="yes" xml:space="preserve">
          <source>A class of bifunctors that can be fully evaluated.</source>
          <target state="translated">一类可以完全评价的双叉函数。</target>
        </trans-unit>
        <trans-unit id="5f62d094b52f200eb67c73fe054a072916deee3f" translate="yes" xml:space="preserve">
          <source>A class of functors that can be fully evaluated.</source>
          <target state="translated">一类可以被完全评估的漏子。</target>
        </trans-unit>
        <trans-unit id="03b36f13be1922d1c74d9e6e0b4b212a81502e1b" translate="yes" xml:space="preserve">
          <source>A class of types that can be fully evaluated.</source>
          <target state="translated">一类可以完全评估的类型。</target>
        </trans-unit>
        <trans-unit id="18974c638151613690d5d785bcc282ea54126e16" translate="yes" xml:space="preserve">
          <source>A class, with a list of its visible instances</source>
          <target state="translated">一个类,有其可见实例的列表。</target>
        </trans-unit>
        <trans-unit id="cf9b4ce512562f9b4a68069022cc221d559c7dde" translate="yes" xml:space="preserve">
          <source>A closed type family has a complete signature when all of its type variables are annotated and a return kind (with a top-level &lt;code&gt;::&lt;/code&gt;) is supplied.</source>
          <target state="translated">当封闭类型家族的所有类型变量都带有注释并提供了返回类型（带有顶级 &lt;code&gt;::&lt;/code&gt; :）时，它具有完整的签名。</target>
        </trans-unit>
        <trans-unit id="5dfadf25c80308dd41216413c27a3be8dce8cf23" translate="yes" xml:space="preserve">
          <source>A closed type family may be declared with no equations. Such closed type families are opaque type-level definitions that will never reduce, are not necessarily injective (unlike empty data types), and cannot be given any instances. This is different from omitting the equations of a closed type family in a &lt;code&gt;hs-boot&lt;/code&gt; file, which uses the syntax &lt;code&gt;where ..&lt;/code&gt;, as in that case there may or may not be equations given in the &lt;code&gt;hs&lt;/code&gt; file.</source>
          <target state="translated">封闭型族可以不用任何方程式声明。这样的封闭类型族是不透明的类型级别定义，它们永远不会减少，不一定是内射性的（不同于空数据类型），并且不能被赋予任何实例。这与在 &lt;code&gt;hs-boot&lt;/code&gt; 文件中省略封闭类型族的方程式不同，后者使用了语法 &lt;code&gt;where ..&lt;/code&gt; ，因为在这种情况下，在 &lt;code&gt;hs&lt;/code&gt; 文件中可能有也可能没有方程式。</target>
        </trans-unit>
        <trans-unit id="5bc12f9a6f357ec15b737234f9f657aacb094303" translate="yes" xml:space="preserve">
          <source>A closed type family may optionally omit its equations, as in the following example:</source>
          <target state="translated">一个封闭类型族可以选择省略它的方程,如下面的例子。</target>
        </trans-unit>
        <trans-unit id="560667c66049aeef765aec3cd394fe9074dbfde4" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations are tried in order, from top to bottom, when simplifying a type family application. In this example, we declare an instance for &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;F Int&lt;/code&gt; simplifies to &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;F Bool&lt;/code&gt; simplifies to &lt;code&gt;Char&lt;/code&gt;, and for any other type &lt;code&gt;a&lt;/code&gt; that is known not to be &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;F a&lt;/code&gt; simplifies to &lt;code&gt;String&lt;/code&gt;. Note that GHC must be sure that &lt;code&gt;a&lt;/code&gt; cannot unify with &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt; in that last case; if a programmer specifies just &lt;code&gt;F a&lt;/code&gt; in their code, GHC will not be able to simplify the type. After all, &lt;code&gt;a&lt;/code&gt; might later be instantiated with &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">在简化类型族应用程序时，从上到下按顺序尝试封闭型族的方程式。在此示例中，我们为 &lt;code&gt;F&lt;/code&gt; 声明一个实例，这样 &lt;code&gt;F Int&lt;/code&gt; 简化为 &lt;code&gt;Double&lt;/code&gt; ， &lt;code&gt;F Bool&lt;/code&gt; 简化为 &lt;code&gt;Char&lt;/code&gt; ，对于其他任何不是 &lt;code&gt;Int&lt;/code&gt; 或 &lt;code&gt;Bool&lt;/code&gt; 的类型 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;F a&lt;/code&gt; 简化为 &lt;code&gt;String&lt;/code&gt; 。请注意，GHC必须确保在后 &lt;code&gt;a&lt;/code&gt; 情况下a不能与 &lt;code&gt;Int&lt;/code&gt; 或 &lt;code&gt;Bool&lt;/code&gt; 结合；如果程序员仅指定 &lt;code&gt;F a&lt;/code&gt; 在他们的代码中，GHC将无法简化类型。毕竟，稍后可能会使用 &lt;code&gt;Int&lt;/code&gt; 实例化 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8038c2136e5194f458ce16e855b310af6be8edf" translate="yes" xml:space="preserve">
          <source>A closed type family&amp;rsquo;s equations have the same restrictions and extensions as the equations for open type family instances. For instance, when &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side of an equation can be explicitly bound, such as in:</source>
          <target state="translated">封闭型族的方程与开放型族实例的方程具有相同的限制和扩展。例如，启用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;时，可以显式绑定方程式左侧使用的类型或种类变量，例如：</target>
        </trans-unit>
        <trans-unit id="55db83fdd426c323b8ba055ddebf0f4927065c0d" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 Console API</source>
          <target state="translated">用于与Win32 Console API接口的FFI声明的集合。</target>
        </trans-unit>
        <trans-unit id="97dfd9521aba56f50c67376cea085b8e6e134f90" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32 mapped files.</source>
          <target state="translated">用于与Win32映射文件接口的FFI声明的集合。</target>
        </trans-unit>
        <trans-unit id="0e9e3c664eeffb3c7374565940d3d04f59d623a4" translate="yes" xml:space="preserve">
          <source>A collection of FFI declarations for interfacing with Win32.</source>
          <target state="translated">用于与Win32接口的FFI声明的集合。</target>
        </trans-unit>
        <trans-unit id="15a4c2ec78aa243e78e786440542fa86a3f898c2" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only either part is.</source>
          <target state="translated">组合是 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; 只有一部分是纯净的。</target>
        </trans-unit>
        <trans-unit id="0e6111313c9398a428339ebfc1488b4234c0e6df" translate="yes" xml:space="preserve">
          <source>A combination is &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; only if both parts are.</source>
          <target state="translated">仅当两个部分都相同时，组合才是 &lt;code&gt;&lt;a href=&quot;control-applicative-lift#v:Pure&quot;&gt;Pure&lt;/a&gt;&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="1cf4024f647ac4b5f1014ad62fdb4551663a3cfd" translate="yes" xml:space="preserve">
          <source>A command line to execute using the shell</source>
          <target state="translated">使用shell执行的命令行</target>
        </trans-unit>
        <trans-unit id="2b42afbfaea58252904aedc72c342409dc5217ec" translate="yes" xml:space="preserve">
          <source>A common example is opening a file:</source>
          <target state="translated">一个常见的例子是打开一个文件。</target>
        </trans-unit>
        <trans-unit id="e611ccbbca22d800c83d8e50686983d00ac930b7" translate="yes" xml:space="preserve">
          <source>A common interface to a collection of useful concurrency abstractions.</source>
          <target state="translated">一个有用的并发抽象集合的通用接口。</target>
        </trans-unit>
        <trans-unit id="158d48aa333ea6c2ec16fe37bdb3bd252bd76bb9" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; is to process input from network sockets, &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, and channels (e.g. &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 的常见用法是处理来自网络套接字， &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 和通道（例如 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; ）的输入。</target>
        </trans-unit>
        <trans-unit id="de5703326cbd6c93faef0a72782d20b8fe31e5ee" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 事务无法直接执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ，所以 &lt;code&gt;&lt;a href=&quot;control-monad#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的常见用法是运行从 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 事务返回的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。回想起那个</target>
        </trans-unit>
        <trans-unit id="d6b9bff21670bd6e1dbddd535cfab7c10fd33d82" translate="yes" xml:space="preserve">
          <source>A common use of &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; is to run an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation returned from an &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transaction, since &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; transactions can't perform &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; directly. Recall that</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 事务无法直接执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ，所以 &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的常见用法是运行从 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 事务返回的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。回想起那个</target>
        </trans-unit>
        <trans-unit id="923f01eefd2602576139719f5c7af323619c5a66" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 向量的紧凑表示形式。</target>
        </trans-unit>
        <trans-unit id="c5b6f1851ba64e7fbc006018f91e89cc899a277e" translate="yes" xml:space="preserve">
          <source>A compact representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc43ee46b5b21f3e78943bd2860ac98eafb0926" translate="yes" xml:space="preserve">
          <source>A compact representation suitable for storing short byte strings in memory.</source>
          <target state="translated">适合于在内存中存储短字节字符串的紧凑表示法。</target>
        </trans-unit>
        <trans-unit id="4dee1b6583088672899330bd95413844639d24f0" translate="yes" xml:space="preserve">
          <source>A concrete class specifies its superclasses, methods, default method signatures (but not their implementations) and a &lt;code&gt;MINIMAL&lt;/code&gt; pragma. Unlike regular Haskell classes, you don&amp;rsquo;t have to explicitly declare a default for a method to make it optional vis-a-vis the &lt;code&gt;MINIMAL&lt;/code&gt; pragma.</source>
          <target state="translated">具体的类指定其超类，方法，默认方法签名（但不指定其实现）和 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示。与常规的Haskell类不同，您不必显式声明方法的默认值，以使其相对于 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示是可选的。</target>
        </trans-unit>
        <trans-unit id="48e06f28fdc9e894b60b4a1b8a5f1e5767f7a49e" translate="yes" xml:space="preserve">
          <source>A concrete representation of &lt;code&gt;Version&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Version&lt;/code&gt; 的具体表示</target>
        </trans-unit>
        <trans-unit id="2cb20f59e5f2e9ba3dec010b3eb3028f911a9a31" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">（单态）类型的具体表示。 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 支持合理有效的相等性。</target>
        </trans-unit>
        <trans-unit id="11422484bfa14bcef95a9aa3860b69ba994b65fb" translate="yes" xml:space="preserve">
          <source>A concrete representation of a (monomorphic) type. &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; supports reasonably efficient equality.</source>
          <target state="translated">（单态）类型的具体表示。 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 支持合理有效的相等性。</target>
        </trans-unit>
        <trans-unit id="0e1fa2e1fdd32663fb32988ae8b548b810674d4a" translate="yes" xml:space="preserve">
          <source>A concrete type constructor applied to some types.</source>
          <target state="translated">适用于某些类型的具体类型构造函数。</target>
        </trans-unit>
        <trans-unit id="8bad079c8885ff9572beaf6828f7450891b38608" translate="yes" xml:space="preserve">
          <source>A concrete type literal.:</source>
          <target state="translated">一个具体类型的文字..:</target>
        </trans-unit>
        <trans-unit id="5d4c61340ac65e2aef91e6fee099cfe89ce3d06e" translate="yes" xml:space="preserve">
          <source>A concrete, promotable proxy type, for use at the kind level. There are no instances for this because it is intended at the kind level only</source>
          <target state="translated">一个具体的、可推广的代理类型,用于kind级别。没有实例,因为它只用于种类级别。</target>
        </trans-unit>
        <trans-unit id="63ae3dab5a2e143c3ea2383adfe2778d5d710d0b" translate="yes" xml:space="preserve">
          <source>A constraint in the type signature is not used in the code it covers:</source>
          <target state="translated">类型签名中的约束条件在其涵盖的代码中没有使用。</target>
        </trans-unit>
        <trans-unit id="84193f4f755d1c0b1057183b2a0adc6bf73de7fb" translate="yes" xml:space="preserve">
          <source>A constructor signature may mention type class constraints, which can differ for different constructors. For example, this is fine:</source>
          <target state="translated">构造函数签名可以提到类型类约束,不同的构造函数可以有不同的约束。例如,这就可以。</target>
        </trans-unit>
        <trans-unit id="1fe5ae7286a52f71d84c6187f3fe447df9c9228a" translate="yes" xml:space="preserve">
          <source>A contrived addition example. Works only with positive numbers:</source>
          <target state="translated">一个人为的加法例子。只适用于正数。</target>
        </trans-unit>
        <trans-unit id="0df890da0fb3e9db7fe956f05674d4d8aa062f47" translate="yes" xml:space="preserve">
          <source>A conversion specification begins with the character &lt;code&gt;%&lt;/code&gt;, followed by zero or more of the following flags:</source>
          <target state="translated">转换规范以字符 &lt;code&gt;%&lt;/code&gt; 开头，后跟零个或多个以下标志：</target>
        </trans-unit>
        <trans-unit id="dd84caa4cb664b8bd50303514ba4d2b0f6763dd8" translate="yes" xml:space="preserve">
          <source>A corresponding Haskell value looks like this:</source>
          <target state="translated">相应的Haskell值是这样的。</target>
        </trans-unit>
        <trans-unit id="2f782e63a1f3f05e6a16c8d7b64076664f462677" translate="yes" xml:space="preserve">
          <source>A cost-centre from GHC's cost-center profiler.</source>
          <target state="translated">来自GHC成本中心剖析师的成本中心。</target>
        </trans-unit>
        <trans-unit id="ba083c36a70a7120687138d63b14bdaf702d8dac" translate="yes" xml:space="preserve">
          <source>A cost-centre stack from GHC's cost-center profiler.</source>
          <target state="translated">GHC成本中心剖析师的成本中心堆栈。</target>
        </trans-unit>
        <trans-unit id="50ea9d5bdb5ec17d018609e47a9ec22b64ecd54e" translate="yes" xml:space="preserve">
          <source>A couple of things to notice:</source>
          <target state="translated">有几件事要注意。</target>
        </trans-unit>
        <trans-unit id="3dc945323c54ee396119be0717674ee79090c303" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor, and takes into account the line contents to the left of the word.</source>
          <target state="translated">一个自定义的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; ，它可以在光标左侧立即补全单词，并考虑单词左侧的行内容。</target>
        </trans-unit>
        <trans-unit id="8c0d52f3762ec276383b7f73f082f54d2df5f0bc" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; which completes the word immediately to the left of the cursor.</source>
          <target state="translated">一个自定义的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-completion#t:CompletionFunc&quot;&gt;CompletionFunc&lt;/a&gt;&lt;/code&gt; ，可在光标左侧立即补全单词。</target>
        </trans-unit>
        <trans-unit id="5862453396404797aa7de7142dce28109cb9b288" translate="yes" xml:space="preserve">
          <source>A custom pre-processor is run over your Haskell source file only if the &lt;code&gt;-F&lt;/code&gt; option is given.</source>
          <target state="translated">仅在给出 &lt;code&gt;-F&lt;/code&gt; 选项的情况下，自定义预处理程序才会在Haskell源文件上运行。</target>
        </trans-unit>
        <trans-unit id="1599a4a0a331f022d3d429faece9bf7cf541b2b9" translate="yes" xml:space="preserve">
          <source>A custom pretty printing function can be used, for example, to format tree-like and nested structures in a more readable way.</source>
          <target state="translated">例如,可以使用自定义的漂亮打印功能,以更可读的方式来格式化树状结构和嵌套结构。</target>
        </trans-unit>
        <trans-unit id="f8eb6d3c983aaf3cde12f740cd4904b0498bd294" translate="yes" xml:space="preserve">
          <source>A data constructor</source>
          <target state="translated">一个数据构造器</target>
        </trans-unit>
        <trans-unit id="b5d4cb00190598ddeec4823830bc239b1485a236" translate="yes" xml:space="preserve">
          <source>A data family instance declaration can use the full expressiveness of ordinary &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; declarations:</source>
          <target state="translated">数据家庭实例声明可以使用普通的完整表现 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="f190b4f01195b249d3555778e7d04af0949a28aa" translate="yes" xml:space="preserve">
          <source>A data or type synonym family can be declared as part of a type class, thus:</source>
          <target state="translated">一个数据或类型同义词族可以被声明为类型类的一部分,因此。</target>
        </trans-unit>
        <trans-unit id="4fab55b5200474635e47e3680a86e7055016af5b" translate="yes" xml:space="preserve">
          <source>A data type declaration can either be given in full, exactly as in Haskell, or it can be given abstractly, by omitting the &amp;lsquo;=&amp;rsquo; sign and everything that follows. For example:</source>
          <target state="translated">可以像在Haskell中一样完全给出数据类型声明，也可以通过省略'='符号及其后面的所有内容来抽象地给出数据类型声明。例如：</target>
        </trans-unit>
        <trans-unit id="3df736aafe2d3db3e69d9a2a8f83fab7d3cd7998" translate="yes" xml:space="preserve">
          <source>A data type has no type parameters (e.g., &lt;code&gt;data Nothing = Nothing&lt;/code&gt;).</source>
          <target state="translated">数据类型没有类型参数（例如， &lt;code&gt;data Nothing = Nothing&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="586827d4266b3d644377c42c18624801ae4ad40a" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in a &lt;a href=&quot;#extension-DatatypeContexts&quot;&gt;&lt;code&gt;DatatypeContexts&lt;/code&gt;&lt;/a&gt; constraint (e.g., &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt;).</source>
          <target state="translated">数据类型的最后一个类型变量用于&lt;a href=&quot;#extension-DatatypeContexts&quot;&gt; &lt;code&gt;DatatypeContexts&lt;/code&gt; &lt;/a&gt;约束中（例如， &lt;code&gt;data Ord a =&amp;gt; O a = O a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="541952865f0bce99dfba54b59c18bf4d90b79e63" translate="yes" xml:space="preserve">
          <source>A data type&amp;rsquo;s last type variable is used in an &lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt;&lt;code&gt;ExistentialQuantification&lt;/code&gt;&lt;/a&gt; constraint, or is refined in a GADT. For example,</source>
          <target state="translated">数据类型的最后一个类型变量用于&lt;a href=&quot;#extension-ExistentialQuantification&quot;&gt; &lt;code&gt;ExistentialQuantification&lt;/code&gt; &lt;/a&gt;约束中，或在GADT中进行优化。例如，</target>
        </trans-unit>
        <trans-unit id="21d82223d3ac86e9e0f5a1e86033ba159dc2adca" translate="yes" xml:space="preserve">
          <source>A datatype-generic function comprises two parts:</source>
          <target state="translated">一个数据类型-通用函数包括两部分。</target>
        </trans-unit>
        <trans-unit id="6264b318464960e93f9c184b690473f5a5728225" translate="yes" xml:space="preserve">
          <source>A declaration type signature (&lt;a href=&quot;#decl-type-sigs&quot;&gt;Declaration type signatures&lt;/a&gt;)</source>
          <target state="translated">声明类型签名（&lt;a href=&quot;#decl-type-sigs&quot;&gt;声明类型签名&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="ee69366de998246ce67952ee9a1a1b3b6c96d4af" translate="yes" xml:space="preserve">
          <source>A declaration type signature that has &lt;em&gt;explicit&lt;/em&gt; quantification (using &lt;code&gt;forall&lt;/code&gt;) brings into scope the explicitly-quantified type variables, in the definition of the named function. For example:</source>
          <target state="translated">具有&lt;em&gt;显式&lt;/em&gt;量化（使用 &lt;code&gt;forall&lt;/code&gt; ）的声明类型签名将显式量化的类型变量纳入命名函数的定义范围。例如：</target>
        </trans-unit>
        <trans-unit id="7a000f3b48bd252b4ec5f85b4c427ccb663838bd" translate="yes" xml:space="preserve">
          <source>A decoder procuced by running a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">通过运行 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; monad进行操作的解码器。</target>
        </trans-unit>
        <trans-unit id="5d17b00ef4a90f5cabfdbf829a677b6db008e640" translate="yes" xml:space="preserve">
          <source>A default declaration is not permitted for an associated &lt;em&gt;data&lt;/em&gt; type.</source>
          <target state="translated">关联&lt;em&gt;数据&lt;/em&gt;类型不允许使用默认声明。</target>
        </trans-unit>
        <trans-unit id="13508033e2c27b5de3214a6e0b6e522b009a007b" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">的默认定义 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; 的方面 &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="a5b5443d78a52a0405c2f0d6239820bf3007f82e" translate="yes" xml:space="preserve">
          <source>A default definition of &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; in terms of the &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">关于 &lt;code&gt;&lt;a href=&quot;data-bitraversable#t:Bitraversable&quot;&gt;Bitraversable&lt;/a&gt;&lt;/code&gt; 可操作的 &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; 的默认定义。</target>
        </trans-unit>
        <trans-unit id="8979aa9d1894c898d3c726fca41fdca65c4a33d5" translate="yes" xml:space="preserve">
          <source>A default element</source>
          <target state="translated">一个默认元素</target>
        </trans-unit>
        <trans-unit id="6b0ba2dc21c07d694dd7ceb37775a8c3eee889d5" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">的定义 &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 必须满足以下规律：</target>
        </trans-unit>
        <trans-unit id="a180dbe254c504564dcc326aee311c425f63e9ec" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 的定义必须满足以下定律：</target>
        </trans-unit>
        <trans-unit id="16de260f1c6cac6529ed6b018b65c836efe37f81" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 的定义必须满足以下定律：</target>
        </trans-unit>
        <trans-unit id="47d9196fc9df3f1fb6cf5bd564f834d9d06f81f1" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 的定义必须满足以下定律：</target>
        </trans-unit>
        <trans-unit id="dc3862240a73ca7ad48aba38069f60afa153c34d" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; must satisfy the following laws:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 的定义必须满足以下定律：</target>
        </trans-unit>
        <trans-unit id="06c816889d8c0a0e486735490b0238ade51de818" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;&lt;code&gt;do&lt;/code&gt;-notation:</source>
          <target state="translated">的定义 &lt;code&gt;safeDiv&lt;/code&gt; 利用 &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; &lt;code&gt;do&lt;/code&gt; -notation：</target>
        </trans-unit>
        <trans-unit id="c1670eef1322c0d7b707d0ae468ed9e809e67e91" translate="yes" xml:space="preserve">
          <source>A definition of &lt;code&gt;safeDiv&lt;/code&gt; using guards, but not &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">A的定义 &lt;code&gt;safeDiv&lt;/code&gt; 使用守卫，但不是 &lt;code&gt;&lt;a href=&quot;control-monad#v:guard&quot;&gt;guard&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="006a6845e3a856bbfba4df0255e3848a4a860831" translate="yes" xml:space="preserve">
          <source>A definition of &lt;em&gt;trust&lt;/em&gt; (or safety) and how it operates, along with ways of defining and changing the trust of modules and packages.</source>
          <target state="translated">的定义&lt;em&gt;信任&lt;/em&gt;（或安全性）以及它如何工作，定义和改变模块和包的信赖的方式一起。</target>
        </trans-unit>
        <trans-unit id="1fb7cf11f58e4e4a3003926053464a1496f9bd2f" translate="yes" xml:space="preserve">
          <source>A deprecated alias of &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不推荐使用的&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;别名。</target>
        </trans-unit>
        <trans-unit id="c13f98be7b9473c582b30f2dd1c5005c007bdc07" translate="yes" xml:space="preserve">
          <source>A derived instance is derived only for declarations of these forms (after expansion of any type synonyms)</source>
          <target state="translated">派生实例只对这些形式的声明进行派生(在扩展任何类型同义词之后)。</target>
        </trans-unit>
        <trans-unit id="fd8f6757bd0323a7730e959138361a06c176f799" translate="yes" xml:space="preserve">
          <source>A description of a custom type error.</source>
          <target state="translated">对自定义类型错误的描述。</target>
        </trans-unit>
        <trans-unit id="97496eb0e26835b32d2dfe1ae69ecf8a627e29cb" translate="yes" xml:space="preserve">
          <source>A descriptive string roughly identifying the cost-centre.</source>
          <target state="translated">大致确定成本中心的描述性字符串。</target>
        </trans-unit>
        <trans-unit id="1814a528e490de53f22aa61afcafb8d5feeb8d24" translate="yes" xml:space="preserve">
          <source>A different approach is to group the option values in a record of type &lt;code&gt;Options&lt;/code&gt;, and have each flag yield a function of type &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; transforming this record.</source>
          <target state="translated">另一种方法是将选项值分组在类型为 &lt;code&gt;Options&lt;/code&gt; 的记录中，并使每个标志产生类型为 &lt;code&gt;Options -&amp;gt; Options&lt;/code&gt; 的函数，以转换该记录。</target>
        </trans-unit>
        <trans-unit id="bbb68a110439919741a19755964df2e6fa3244b4" translate="yes" xml:space="preserve">
          <source>A directory contains a series of entries, each of which is a named reference to a file system object (file, directory etc.). Some entries may be hidden, inaccessible, or have some administrative function (e.g. &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt; under &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt;), but in this standard all such entries are considered to form part of the directory contents. Entries in sub-directories are not, however, considered to form part of the directory contents.</source>
          <target state="translated">目录包含一系列条目，每个条目都是对文件系统对象（文件，目录等）的命名引用。一些条目可能是隐藏的，不可访问的或具有某些管理功能（例如&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399&quot;&gt;POSIX&lt;/a&gt;下的 &lt;code&gt;.&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; ），但是在此标准中，所有此类条目均被视为构成目录内容的一部分。但是，不认为子目录中的条目构成目录内容的一部分。</target>
        </trans-unit>
        <trans-unit id="7cea28c5c17737eb22d5290576e72180db68e967" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">高度为1的文档，包含文字字符串。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 满足以下法律：</target>
        </trans-unit>
        <trans-unit id="a7c0af88c561dd3e381e4c0c9eb468d9f9adda7d" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">高度为1的文档，包含文字字符串。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 满足以下法律：</target>
        </trans-unit>
        <trans-unit id="b60445ccdc10943dbfcb65b6302d60eef3c3dd3b" translate="yes" xml:space="preserve">
          <source>A document of height 1 containing a literal string. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; satisfies the following laws:</source>
          <target state="translated">高度为1的文档，包含文字字符串。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:text&quot;&gt;text&lt;/a&gt;&lt;/code&gt; 满足以下法律：</target>
        </trans-unit>
        <trans-unit id="688bfb4bbd29b21c2ae8d691c138d77983de8115" translate="yes" xml:space="preserve">
          <source>A document of height and width 1, containing a literal character.</source>
          <target state="translated">一个高度和宽度为1的文件,包含一个文字字符。</target>
        </trans-unit>
        <trans-unit id="6b6ebd185f2a3b55592691251680ab65322061fe" translate="yes" xml:space="preserve">
          <source>A duplex communications channel (results in creation of a duplex &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;). The standard libraries use this device type when creating &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s for open sockets.</source>
          <target state="translated">一个双工通信通道（导致创建一个双工 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ）。在为开放套接字创建 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 时，标准库使用此设备类型。</target>
        </trans-unit>
        <trans-unit id="86a3012ad906142a305a738b9de653227862c657" translate="yes" xml:space="preserve">
          <source>A expression quotation is written in Oxford brackets, thus:</source>
          <target state="translated">表达式引语写在牛津括号里,这样。</target>
        </trans-unit>
        <trans-unit id="5e47ffa147be43069d678d8783f87f9374b92f8d" translate="yes" xml:space="preserve">
          <source>A feature or operation which a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; may define.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:Terminal&quot;&gt;Terminal&lt;/a&gt;&lt;/code&gt; 可以定义的功能或操作。</target>
        </trans-unit>
        <trans-unit id="14e098e337088120cd46a6eee334387a102be1a6" translate="yes" xml:space="preserve">
          <source>A few caveats apply here. First, it is illegal to export an entity which refers to a locally defined type which itself is not exported (GHC will report an error in this case). Second, signatures which come from dependencies which expose modules cannot be thinned in this way (after all, the dependency itself may need the entity); these requirements are unconditionally exported. Finally, any module reexports must refer to modules imported by the local signature (even if an inherited signature exported the module).</source>
          <target state="translated">这里有几个注意事项。首先,导出一个指向本地定义类型的实体是非法的,而这个类型本身并没有被导出(在这种情况下,GHC会报告一个错误)。其次,来自于暴露模块的依赖的签名不能以这种方式被稀释(毕竟,依赖本身可能需要实体);这些需求是无条件导出的。最后,任何模块的再导出必须引用本地签名导入的模块(即使是继承的签名导出了模块)。</target>
        </trans-unit>
        <trans-unit id="ebd630669cc76942437803b1fb8107b3e2063e84" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">一些函子支持 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的实现，该实现比默认函数更有效。</target>
        </trans-unit>
        <trans-unit id="4e9bb325d8e94370ab23120a7426d9ee7ea2c654" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">一些函子支持 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的实现，该实现比默认函数更有效。</target>
        </trans-unit>
        <trans-unit id="feddbc495dd6f9bc1a1874e911421fb2030f4453" translate="yes" xml:space="preserve">
          <source>A few functors support an implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; that is more efficient than the default one.</source>
          <target state="translated">一些函子支持 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的实现，该实现比默认函数更有效。</target>
        </trans-unit>
        <trans-unit id="412108fee011dff2957aa26fc118a779db7cb3e1" translate="yes" xml:space="preserve">
          <source>A field must be in scope for the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint to be solved. This retains the existing representation hiding mechanism, whereby a module may choose not to export a field, preventing client modules from accessing or updating it directly.</source>
          <target state="translated">一个字段必须在范围内才能解决相应的 &lt;code&gt;HasField&lt;/code&gt; 约束。这保留了现有的表示隐藏机制，由此模块可以选择不导出字段，从而阻止客户端模块直接访问或更新它。</target>
        </trans-unit>
        <trans-unit id="647667c77d993eaf0e249337caf2de0283b2f13c" translate="yes" xml:space="preserve">
          <source>A file created by the preprocessor.</source>
          <target state="translated">由预处理机创建的文件。</target>
        </trans-unit>
        <trans-unit id="10a6f21acebb16166b923fe8816f24879cac7dc7" translate="yes" xml:space="preserve">
          <source>A file descriptor registration cookie.</source>
          <target state="translated">一个文件描述符注册cookie。</target>
        </trans-unit>
        <trans-unit id="b7ff63f15803ad313bc70e86c0b9af3bd034d57c" translate="yes" xml:space="preserve">
          <source>A file that may be read or written, and also may be seekable.</source>
          <target state="translated">可读或可写的文件,也可寻找。</target>
        </trans-unit>
        <trans-unit id="3fc8729fc9cba21c227493e06ca57c42259f5fbc" translate="yes" xml:space="preserve">
          <source>A file-header pragma must precede the &lt;code&gt;module&lt;/code&gt; keyword in the file.</source>
          <target state="translated">文件头编译指示必须在文件中的 &lt;code&gt;module&lt;/code&gt; 关键字之前。</target>
        </trans-unit>
        <trans-unit id="ee69f3557f209a70b6dbd3e30733ef3266ad45c4" translate="yes" xml:space="preserve">
          <source>A finalizer is not always called after its weak pointer's object becomes unreachable. There are two situations that can cause this:</source>
          <target state="translated">一个终结器并不总是在其弱指针的对象变得不可及之后被调用。有两种情况会导致这种情况。</target>
        </trans-unit>
        <trans-unit id="c83751e185497b34efc04696de873a6948bad996" translate="yes" xml:space="preserve">
          <source>A finalizer is represented as a pointer to a foreign function that, at finalisation time, gets as an argument a plain pointer variant of the foreign pointer that the finalizer is associated with.</source>
          <target state="translated">定标器表示为一个指向外部函数的指针,在定标时,该函数会得到一个定标器所关联的外部指针的普通指针变体作为参数。</target>
        </trans-unit>
        <trans-unit id="1df6acc2d101561b7dc4207a365d517cbb075848" translate="yes" xml:space="preserve">
          <source>A fixed-precision integer type with at least the range &lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt;. The exact range for a given implementation can be determined by using &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">至少在 &lt;code&gt;[-2^29 .. 2^29-1]&lt;/code&gt; 范围内的固定精度整数类型。对于给定实现的确切范围可以通过使用被确定 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="c5c0b209d881b38e76f482af23564dfb8494b98b" translate="yes" xml:space="preserve">
          <source>A flag to disable Safe Haskell checks:</source>
          <target state="translated">一个禁用安全Haskell检查的标志。</target>
        </trans-unit>
        <trans-unit id="5e83789a4d462ba5ff17578c25dbd53a56499d15" translate="yes" xml:space="preserve">
          <source>A flexible variation parameterised in a type constructor</source>
          <target state="translated">在类型构造函数中参数化的灵活变化。</target>
        </trans-unit>
        <trans-unit id="ae7acb61d64b5e1b08a76042f669d06cf246bf79" translate="yes" xml:space="preserve">
          <source>A fmap-like operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">适用于构建器基元的类似于fmap的操作符,包括有界和固定大小。</target>
        </trans-unit>
        <trans-unit id="3156de946a16b219e4da74bb691b1f317bcde8a4" translate="yes" xml:space="preserve">
          <source>A frontend plugin allows you to add new major modes to GHC. You may prefer this over a traditional program which calls the GHC API, as GHC manages a lot of parsing flags and administrative nonsense which can be difficult to manage manually. To load a frontend plugin exported by &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt;, we just invoke GHC with the &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; flag as follows:</source>
          <target state="translated">前端插件可让您向GHC添加新的主要模式。与GHC API的传统程序相比，您可能更喜欢这样做，因为GHC管理大量的解析标志和管理上的废话，这可能很难手动管理。要加载 &lt;code&gt;Foo.FrontendPlugin&lt;/code&gt; 导出的前端插件，我们只需使用 &lt;code&gt;--frontend ⟨module⟩&lt;/code&gt; 标志调用GHC 即可，如下所示：</target>
        </trans-unit>
        <trans-unit id="a6ca1012af98c96815c71a4e1c588fc523445abe" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">函数可以使用 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束来请求其调用位置。例如，我们可以定义</target>
        </trans-unit>
        <trans-unit id="85ce5ed93025fc855be629c4ba88fa8a1670bc1d" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint. For example, we can define</source>
          <target state="translated">函数可以使用 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束来请求其调用位置。例如，我们可以定义</target>
        </trans-unit>
        <trans-unit id="b827823da9db0cd7f4da87d2bab81acb959e4419" translate="yes" xml:space="preserve">
          <source>A function can request its call-site with the &lt;code&gt;HasCallStack&lt;/code&gt; constraint and access it as a Haskell value by using &lt;code&gt;callStack&lt;/code&gt;.</source>
          <target state="translated">函数可以使用 &lt;code&gt;HasCallStack&lt;/code&gt; 约束请求其调用位置，并通过使用 &lt;code&gt;callStack&lt;/code&gt; 将其作为Haskell值进行访问。</target>
        </trans-unit>
        <trans-unit id="959c41ee1afd55fc73fec6ad553ce55c337100e6" translate="yes" xml:space="preserve">
          <source>A function that accepts another &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. That string will be assumed to directly follow the string that was passed as input to the original function, and it will in turn be decoded.</source>
          <target state="translated">接受另一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的函数。假定该字符串直接跟随作为输入传递给原始函数的字符串，然后依次对其进行解码。</target>
        </trans-unit>
        <trans-unit id="146f819aeac6eebc6c002e437bb527a05441309a" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; and its computed value once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signals.</source>
          <target state="translated">填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 的函数，一旦完成，就使用更新的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 及其计算值调用继续，并使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; ，信号 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 信号向其调用者发出信号以继续进行操作。</target>
        </trans-unit>
        <trans-unit id="f9fe9550377f39c1dda07402c3e5dd3c52deb055" translate="yes" xml:space="preserve">
          <source>A function that fills a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;, calls the continuation with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; once its done, and signals its caller how to proceed using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 的函数，一旦完成，就调用更新的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 的延续，并向其调用者发出信号，说明如何使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 继续进行。</target>
        </trans-unit>
        <trans-unit id="9a1cfa6ac431e810bfaf7276b3ed3786ed71fd59" translate="yes" xml:space="preserve">
          <source>A function that peeks a field of a C struct will be output. It will have the type &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt;. The intention is that &lt;code&gt;#peek&lt;/code&gt; and &lt;code&gt;#poke&lt;/code&gt; can be used for implementing the operations of class &lt;code&gt;Storable&lt;/code&gt; for a given C struct (see the &lt;code&gt;Foreign.Storable&lt;/code&gt; module in the library documentation).</source>
          <target state="translated">将输出窥视C结构的字段的函数。它将具有类型 &lt;code&gt;Storable b =&amp;gt; Ptr a -&amp;gt; IO b&lt;/code&gt; 。目的是针对给定的C结构，可以使用 &lt;code&gt;#peek&lt;/code&gt; 和 &lt;code&gt;#poke&lt;/code&gt; 来实现 &lt;code&gt;Storable&lt;/code&gt; 类的操作（请参见库文档中的 &lt;code&gt;Foreign.Storable&lt;/code&gt; 模块）。</target>
        </trans-unit>
        <trans-unit id="d2ef8a015f90280c78a9e52d4eaee96c355e724d" translate="yes" xml:space="preserve">
          <source>A function to check if the current terminal uses MinTTY. Much of this code was originally authored by Phil Ruffwind and the git-for-windows project.</source>
          <target state="translated">一个用于检查当前终端是否使用 MinTTY 的函数。这段代码的大部分内容最初是由 Phil Ruffwind 和 git-for-windows 项目编写的。</target>
        </trans-unit>
        <trans-unit id="31ba468a5f0c3b9552cf7091416e0dd2026254a0" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &quot;Generalising Monads to Arrows&quot;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">递增计数器的功能。摘自约翰&amp;middot;休斯（John Hughes）（&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/&quot;&gt;http://www.cse.chalmers.se/~rjmh/&lt;/a&gt;）的论文《将Monads推广到箭头》中，1998年11月：</target>
        </trans-unit>
        <trans-unit id="05dac60b6df39a2cc430ba2715bb82eb9d50346b" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt;), November 1998:</source>
          <target state="translated">递增计数器的功能。摘自1998年11月John Hughes（&lt;a href=&quot;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&quot;&gt;http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf&lt;/a&gt;）的论文《将&lt;em&gt;Monads推广到Arrows中》&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="cba486e1fb914bff3d0a304947268224d9af2b9a" translate="yes" xml:space="preserve">
          <source>A function to increment a counter. Taken from the paper &lt;em&gt;Generalising Monads to Arrows&lt;/em&gt;, John Hughes (&lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt;), November 1998:</source>
          <target state="translated">递增计数器的功能。摘自1998年11月John Hughes（&lt;a href=&quot;http://www.math.chalmers.se/~rjmh/&quot;&gt;http://www.math.chalmers.se/~rjmh/&lt;/a&gt;）的论文《将&lt;em&gt;Monads推广到Arrows》中&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="407bdfca3acdcf3e83644e05bb20353353df0c81" translate="yes" xml:space="preserve">
          <source>A functor with application, providing operations to</source>
          <target state="translated">一个应用型的漏斗器,提供对</target>
        </trans-unit>
        <trans-unit id="672c26b34e9f1b6a9e0ef2bedd270f00f9598669" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74eb92ae3094b3fdb42750a32df490044fa7fa7c" translate="yes" xml:space="preserve">
          <source>A garbage collection pass has been started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b56072e77298e15569c00276b7c0299340640ae" translate="yes" xml:space="preserve">
          <source>A general library for representation and manipulation of versions.</source>
          <target state="translated">一个用于表示和操作版本的通用库。</target>
        </trans-unit>
        <trans-unit id="3bc20610754970931bb56e207d89ee27df2c440a" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的概括， &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; 采用了也依赖于元素索引的映射函数，并将其应用于序列中的每个元素。</target>
        </trans-unit>
        <trans-unit id="4ed89134d2ae1ba346467054c2cbd0888a87f736" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:mapWithIndex&quot;&gt;mapWithIndex&lt;/a&gt;&lt;/code&gt; takes a mapping function that also depends on the element's index, and applies it to every element in the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b0bb9b6108641f8e5517af378b5cb49562a948" translate="yes" xml:space="preserve">
          <source>A generalization of &lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; to an arbitrary &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;. May fail to terminate for some values in some semigroups.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:cycle&quot;&gt;cycle&lt;/a&gt;&lt;/code&gt; 到任意 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 推广。对于某些半组中的某些值，可能无法终止。</target>
        </trans-unit>
        <trans-unit id="26ff4b7505fb166fcbe7f642bd27c36a8063bf48" translate="yes" xml:space="preserve">
          <source>A generator with side-effects.</source>
          <target state="translated">一个有副作用的发电机。</target>
        </trans-unit>
        <trans-unit id="862450f7f65fc829d17b888581dcf9423b4a7480" translate="yes" xml:space="preserve">
          <source>A generator ⟨g⟩ &lt;em&gt;depends&lt;/em&gt; on a textually following generator ⟨g&amp;rsquo;⟩, if</source>
          <target state="translated">生成器⟨g⟩ &lt;em&gt;依赖&lt;/em&gt;于文本后面的生成器⟨g'⟩，如果</target>
        </trans-unit>
        <trans-unit id="62ae38d3598e1153af86caff741ce7f45b481a95" translate="yes" xml:space="preserve">
          <source>A generic function is defined by creating a class and giving instances for each of the representation types of &lt;code&gt;GHC.Generics&lt;/code&gt;. As an example we show generic serialization:</source>
          <target state="translated">通过创建类并为 &lt;code&gt;GHC.Generics&lt;/code&gt; 的每种表示类型提供实例来定义泛型函数。作为示例，我们显示通用序列化：</target>
        </trans-unit>
        <trans-unit id="1c195a4fb48a9a5e0bec2f551debfe0bebac3b3f" translate="yes" xml:space="preserve">
          <source>A generic monadic transformation that maps over the immediate subterms</source>
          <target state="translated">一个通用的单项变换,映射在直接的子项上。</target>
        </trans-unit>
        <trans-unit id="2371a81d45c2bb3b8a13c0d110026806d7062e4b" translate="yes" xml:space="preserve">
          <source>A generic query that processes one child by index (zero-based)</source>
          <target state="translated">通过索引(基于零的)处理一个子代的通用查询。</target>
        </trans-unit>
        <trans-unit id="b30dda47587e5c218c84c8765cbfb57d7c32ee07" translate="yes" xml:space="preserve">
          <source>A generic query that processes the immediate subterms and returns a list of results. The list is given in the same order as originally specified in the declaration of the data constructors.</source>
          <target state="translated">一个通用查询,它处理即时子项并返回结果列表。该列表按照数据构造函数声明中最初指定的顺序给出。</target>
        </trans-unit>
        <trans-unit id="51d2a5deead9d5e63a49652af5db4d773df15f2a" translate="yes" xml:space="preserve">
          <source>A generic query with a left-associative binary operator</source>
          <target state="translated">一个带有左联二进制运算符的通用查询。</target>
        </trans-unit>
        <trans-unit id="f172406f53434c2c85e3e88b3b734c76fe4cbf1f" translate="yes" xml:space="preserve">
          <source>A generic query with a right-associative binary operator</source>
          <target state="translated">一个带有右联二进制运算符的通用查询。</target>
        </trans-unit>
        <trans-unit id="aa8f907ef342f61225b3aaaca537bb6131e08eed" translate="yes" xml:space="preserve">
          <source>A generic transformation that maps over the immediate subterms</source>
          <target state="translated">在直接子项上进行映射的通用变换。</target>
        </trans-unit>
        <trans-unit id="263bda9728b8670fff6c73f321e0c1114a53a098" translate="yes" xml:space="preserve">
          <source>A graph where the out-list references unspecified nodes (&lt;code&gt;'c'&lt;/code&gt;), these are ignored.</source>
          <target state="translated">外部列表引用未指定节点（ &lt;code&gt;'c'&lt;/code&gt; ）的图形，这些将被忽略。</target>
        </trans-unit>
        <trans-unit id="547e608af651f4f8ae6ad4968c6a78fb1a5f9911" translate="yes" xml:space="preserve">
          <source>A graph with 3 vertices: (&quot;a&quot;) -&amp;gt; (&quot;b&quot;) -&amp;gt; (&quot;c&quot;)</source>
          <target state="translated">具有3个顶点的图形：（&amp;ldquo; a&amp;rdquo;）-&amp;gt;（&amp;ldquo; b&amp;rdquo;）-&amp;gt;（&amp;ldquo; c&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="12b3806c7a4a6d3f01bcf0d2c455af966755af91" translate="yes" xml:space="preserve">
          <source>A group of implicit-parameter bindings may occur anywhere a normal group of Haskell bindings can occur, except at top level. That is, they can occur in a &lt;code&gt;let&lt;/code&gt; (including in a list comprehension, or do-notation, or pattern guards), or a &lt;code&gt;where&lt;/code&gt; clause. Note the following points:</source>
          <target state="translated">一组隐式参数绑定可能会发生在除Hassell绑定以外的正常组之外的任何顶级位置。也就是说，它们可以出现在 &lt;code&gt;let&lt;/code&gt; （包括列表理解，do-notation或模式卫士）或 &lt;code&gt;where&lt;/code&gt; 子句中。请注意以下几点：</target>
        </trans-unit>
        <trans-unit id="65051f92e572963e4acdb9bb33b4d2b90e5a8b97" translate="yes" xml:space="preserve">
          <source>A handle managing input from the Haskell program's standard input channel.</source>
          <target state="translated">一个管理Haskell程序标准输入通道输入的句柄。</target>
        </trans-unit>
        <trans-unit id="e751926f8fa8be7abe2938c68d0bde4c6028d510" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard error channel.</source>
          <target state="translated">一个管理输出到Haskell程序标准错误通道的句柄。</target>
        </trans-unit>
        <trans-unit id="2d2d9310b94785cb31fe1e4c863bde58a3090d7e" translate="yes" xml:space="preserve">
          <source>A handle managing output to the Haskell program's standard output channel.</source>
          <target state="translated">一个管理输出到Haskell程序的标准输出通道的句柄。</target>
        </trans-unit>
        <trans-unit id="d7a3e5b5484f784fade78cfdf6ff6413b1996492" translate="yes" xml:space="preserve">
          <source>A handle to a process, which can be used to wait for termination of the process using &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">进程的句柄，可使用 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 来等待进程终止。</target>
        </trans-unit>
        <trans-unit id="703580b3dc907bb3f23c64f76055da6a35b3d742" translate="yes" xml:space="preserve">
          <source>A handler for a decoding error.</source>
          <target state="translated">一个解码错误处理程序。</target>
        </trans-unit>
        <trans-unit id="e5858ba1a84179526a85d088788e5ed04cd3ca67" translate="yes" xml:space="preserve">
          <source>A handler for an encoding error.</source>
          <target state="translated">编码错误处理程序。</target>
        </trans-unit>
        <trans-unit id="a61fb6766aecc9004ee1afd5c6ce82d376d98ad4" translate="yes" xml:space="preserve">
          <source>A handler function to handle previous errors and return to normal execution. A common idiom is:</source>
          <target state="translated">处理函数,用于处理之前的错误并返回正常执行。一个常见的成语是:</target>
        </trans-unit>
        <trans-unit id="be659a8b5b88eca4628da85b8cd673c423ac389e" translate="yes" xml:space="preserve">
          <source>A heap object is &lt;em&gt;reachable&lt;/em&gt; if:</source>
          <target state="translated">如果满足以下条件，则&lt;em&gt;可以访问&lt;/em&gt;堆对象：</target>
        </trans-unit>
        <trans-unit id="ea694877df8a08ed123b92ef6005435d0a5c6bc8" translate="yes" xml:space="preserve">
          <source>A heap residency census will follow. Since events may only be up to 2^16^ bytes in length a single sample may need to be split among multiple &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; events. The precise format of the census entries is determined by the break-down type.</source>
          <target state="translated">随后将进行堆居住人口普查。由于事件的长度最多只能达到2 ^ 16 ^个字节，因此可能需要在多个 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE&lt;/code&gt; 事件之间分配单个样本。普查条目的准确格式由细分类型决定。</target>
        </trans-unit>
        <trans-unit id="f721eb8b4b3c875c9b3039562674d9428b85321c" translate="yes" xml:space="preserve">
          <source>A helper module that defines some language definitions that can be used to instantiate a token parser (see &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;).</source>
          <target state="translated">一个帮助程序模块，它定义一些可用于实例化令牌解析器的语言定义（请参见&lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="020709edaa36d2287275fd9547b133a13203df95" translate="yes" xml:space="preserve">
          <source>A helper module to parse &quot;expressions&quot;. Builds a parser given a table of operators and associativities.</source>
          <target state="translated">一个解析 &quot;表达式 &quot;的辅助模块。建立一个给定运算符和关联性表的解析器。</target>
        </trans-unit>
        <trans-unit id="150ba12f35ac6072514bd31b5f915a96dc42b4c6" translate="yes" xml:space="preserve">
          <source>A helper module to parse lexical elements (tokens). See &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; for a description of how to use it.</source>
          <target state="translated">解析词法元素（令牌）的帮助器模块。有关如何使用它的说明，请参见 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0383b225a4de83038268fe176e36b5324f8b57bd" translate="yes" xml:space="preserve">
          <source>A hs-boot file is written in a subset of Haskell:</source>
          <target state="translated">hs-boot文件是用Haskell的子集编写的。</target>
        </trans-unit>
        <trans-unit id="beb39b13efdd6752b158de82a3a13e416589e21f" translate="yes" xml:space="preserve">
          <source>A hs-boot file need only contain the bare minimum of information needed to get the bootstrapping process started. For example, it doesn&amp;rsquo;t need to contain declarations for &lt;em&gt;everything&lt;/em&gt; that module &lt;code&gt;A&lt;/code&gt; exports, only the things required by the module(s) that import &lt;code&gt;A&lt;/code&gt; recursively.</source>
          <target state="translated">hs-boot文件仅需要包含启动引导过程所需的最少信息。例如，它不需要包含模块 &lt;code&gt;A&lt;/code&gt; 导出的&lt;em&gt;所有内容的&lt;/em&gt;声明，只需包含递归导入 &lt;code&gt;A&lt;/code&gt; 的模块所需的内容即可。</target>
        </trans-unit>
        <trans-unit id="4c6d3cf5164d3e0790c51b498cf4792069b594e1" translate="yes" xml:space="preserve">
          <source>A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory. To take advantage of this you have to write your functions in a lazy streaming style, e.g. classic pipeline composition. The default I/O chunk size is 32k, which should be good in most circumstances.</source>
          <target state="translated">懒惰的ByteStrings的一个关键特征是处理大的或无边界的数据流的方法,而不要求整个序列驻留在内存中。为了利用这个优势,你必须以懒惰流的风格来编写你的函数,例如经典的流水线组成。默认的I/O分块大小是32k,这在大多数情况下应该是不错的。</target>
        </trans-unit>
        <trans-unit id="325a2bf823d17d06d93a99292962d2fd916a91fe" translate="yes" xml:space="preserve">
          <source>A key for &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;s that can be serialized and used with &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种关键 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; s表示可以被序列化，并使用 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#v:unsafeLookupStaticPtr&quot;&gt;unsafeLookupStaticPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036affe5e2067ef8e5a7e25cb46bbfbf0c7d82cb" translate="yes" xml:space="preserve">
          <source>A kind signature is considered to be outermost regardless of redundant parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b381dc7ee35453cc6200cb73ab6f7a29da015f" translate="yes" xml:space="preserve">
          <source>A kind variable can also be bound implicitly in a LHS type pattern, as in this example:</source>
          <target state="translated">kind变量也可以在LHS类型模式中隐式绑定,如本例。</target>
        </trans-unit>
        <trans-unit id="fed1bf023551f5e183a777d4ad8f17c745a4596e" translate="yes" xml:space="preserve">
          <source>A lazier version of Data.List.intersperse. The other version causes space leaks!</source>
          <target state="translated">Data.List.intersperse的一个较懒的版本。另一个版本会导致空间泄漏!</target>
        </trans-unit>
        <trans-unit id="54d1e3a19df5bd11488b091ae905ebe5fef9f311" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或者通过使用&lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8中&lt;/a&gt;的操作，可以将其解释为包含8位字符。</target>
        </trans-unit>
        <trans-unit id="5a2fd64b80af2ff85d7158cad974f3b8d6d3fa1e" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或者通过使用&lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8中&lt;/a&gt;的操作，可以将其解释为包含8位字符。</target>
        </trans-unit>
        <trans-unit id="4f64b98de52b0b6fa53b16083b06816797fde862" translate="yes" xml:space="preserve">
          <source>A lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; contains 8-bit bytes, or by using the operations from &lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8&lt;/a&gt; it can be interpreted as containing 8-bit characters.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 包含8位字节，或者通过使用&lt;a href=&quot;data-bytestring-lazy-char8&quot;&gt;Data.ByteString.Lazy.Char8中&lt;/a&gt;的操作，可以将其解释为包含8位字符。</target>
        </trans-unit>
        <trans-unit id="15d0c3d1a9e330b475d899c85089d3a45d5191af" translate="yes" xml:space="preserve">
          <source>A leading (or &quot;high&quot;) surrogate code unit (0xD800&amp;ndash;0xDBFF) must always be followed by a trailing (or &quot;low&quot;) surrogate code unit (0xDC00-0xDFFF). A trailing surrogate code unit must always be preceded by a leading surrogate code unit.</source>
          <target state="translated">前导（或&amp;ldquo;高&amp;rdquo;）代理代码单元（0xD800-0xDBFF）必须始终跟随尾随（或&amp;ldquo;低&amp;rdquo;）代理代码单元（0xDC00-0xDFFF）。尾随代理代码单元必须始终在前导代理代码单元之后。</target>
        </trans-unit>
        <trans-unit id="49f7c0bc99a71677d388689dcc2d6ba4d8f6ecf2" translate="yes" xml:space="preserve">
          <source>A left fold over the elements</source>
          <target state="translated">元素上的左折</target>
        </trans-unit>
        <trans-unit id="875903e7616532ab0681456be555fa6ab6806498" translate="yes" xml:space="preserve">
          <source>A left fold over the elements with no starting value</source>
          <target state="translated">在没有起始值的元素上进行左折。</target>
        </trans-unit>
        <trans-unit id="13379849e3da0988f874c759315290aea7600c73" translate="yes" xml:space="preserve">
          <source>A less contrived example shows the use of &lt;code&gt;cases&lt;/code&gt; instead of &lt;code&gt;lets&lt;/code&gt; to get stricter code (a good thing):</source>
          <target state="translated">一个不太人为的示例显示了使用 &lt;code&gt;cases&lt;/code&gt; 而不是 &lt;code&gt;lets&lt;/code&gt; 我们获得更严格的代码（一件好事）：</target>
        </trans-unit>
        <trans-unit id="fd8adda1f5cdce432835cce105d7c84fdbd2dac1" translate="yes" xml:space="preserve">
          <source>A lexer for the haskell language.</source>
          <target state="translated">一个哈斯克尔语言的词典。</target>
        </trans-unit>
        <trans-unit id="6b7e5a3a0abc0bd6645cddccc0976a9582cc8903" translate="yes" xml:space="preserve">
          <source>A lexer for the mondrian language.</source>
          <target state="translated">蒙特里安语的词典。</target>
        </trans-unit>
        <trans-unit id="1726ba2f885b524251e70e59cf6b4178dcd2f11f" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Posix style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">在所有平台上都使用Posix样式路径的 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 操作库。导入&lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt;通常更好。</target>
        </trans-unit>
        <trans-unit id="d22f4e61fa94ecb3258b9cf1c0bad6a5edb3b1fc" translate="yes" xml:space="preserve">
          <source>A library for &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; manipulations, using Windows style paths on all platforms. Importing &lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt; is usually better.</source>
          <target state="translated">在所有平台上使用Windows样式路径的 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 操作库。导入&lt;a href=&quot;system-filepath&quot;&gt;System.FilePath&lt;/a&gt;通常更好。</target>
        </trans-unit>
        <trans-unit id="b736f738e6fcd73b3f446e3ef506bfbfaf5591f3" translate="yes" xml:space="preserve">
          <source>A line recording the dependence of the object file on the source file.</source>
          <target state="translated">一行记录对象文件对源文件的依赖性。</target>
        </trans-unit>
        <trans-unit id="dc910a705047942aa6596ecdf81615bb378b5bf0" translate="yes" xml:space="preserve">
          <source>A list containing child cost-centre stacks.</source>
          <target state="translated">包含儿童费用中心堆栈的清单;</target>
        </trans-unit>
        <trans-unit id="a5dad55926d22c2d61986b7de9e0d931acff5efa" translate="yes" xml:space="preserve">
          <source>A list of all known keys.</source>
          <target state="translated">所有已知钥匙的清单;</target>
        </trans-unit>
        <trans-unit id="a068c69873917f77c92591cc3eed569ea30b4268" translate="yes" xml:space="preserve">
          <source>A list of all supported language extensions can be obtained by invoking &lt;code&gt;ghc --supported-extensions&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt;&lt;code&gt;--supported-extensions&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">可以通过调用 &lt;code&gt;ghc --supported-extensions&lt;/code&gt; 获得所有受支持的语言扩展的列表（请参阅&lt;a href=&quot;using#ghc-flag---supported-extensions&quot;&gt; &lt;code&gt;--supported-extensions&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9020f71c1c4e09df1fb37e8eb8a85e9c837975c2" translate="yes" xml:space="preserve">
          <source>A list of separate command line arguments to the program</source>
          <target state="translated">程序的单独的命令行参数列表。</target>
        </trans-unit>
        <trans-unit id="5f31632c64a2a83d396013e71426f91b56565679" translate="yes" xml:space="preserve">
          <source>A list of the program&amp;rsquo;s cost centres</source>
          <target state="translated">该计划的成本中心清单</target>
        </trans-unit>
        <trans-unit id="73940efd2676f199ed1ac86bfd84a3386d46652a" translate="yes" xml:space="preserve">
          <source>A list of zero or more usernames that are members (gr_mem)</source>
          <target state="translated">零个或多个用户名的成员列表(gr_mem)</target>
        </trans-unit>
        <trans-unit id="bb14c26279814204dd8eba9acbc9f2cc037cda91" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">可以与 &lt;code&gt;&lt;a href=&quot;ghc-base#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 融合的列表生成器。这个功能仅仅是</target>
        </trans-unit>
        <trans-unit id="7609384306d65c392d73d1f946dd577e1543b1ed" translate="yes" xml:space="preserve">
          <source>A list producer that can be fused with &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;. This function is merely</source>
          <target state="translated">可以与 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 融合的列表生成器。这个功能仅仅是</target>
        </trans-unit>
        <trans-unit id="3157123a0be7934993229fbac35bb2de4bfc150e" translate="yes" xml:space="preserve">
          <source>A literal POSIX file path</source>
          <target state="translated">一个POSIX文件路径</target>
        </trans-unit>
        <trans-unit id="616e39ecf2bde53027e5f642d48b139e07322230" translate="yes" xml:space="preserve">
          <source>A local time together with a time zone.</source>
          <target state="translated">当地时间和一个时区。</target>
        </trans-unit>
        <trans-unit id="edcfe1b56e989ad66407f462968b76cf02bda336" translate="yes" xml:space="preserve">
          <source>A location in the original program source.</source>
          <target state="translated">原始程序源中的一个位置。</target>
        </trans-unit>
        <trans-unit id="8d5a785c724a8eba79d22f8cfdbe656e03ea3ef1" translate="yes" xml:space="preserve">
          <source>A log message from the runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb40e6b7e0ea76eae404b014920691442447d08" translate="yes" xml:space="preserve">
          <source>A logically uninhabited data type, used to indicate that a given term should not exist.</source>
          <target state="translated">一个逻辑上无人居住的数据类型,用于表示某个术语不应存在。</target>
        </trans-unit>
        <trans-unit id="4fae0237e62dbac5cce6d600545ee02ceb780eef" translate="yes" xml:space="preserve">
          <source>A long GC sync can be caused by a mutator thread that is inside an &lt;code&gt;unsafe&lt;/code&gt; FFI call, or running in a loop that doesn&amp;rsquo;t allocate memory and so doesn&amp;rsquo;t yield. To fix the former, make the call &lt;code&gt;safe&lt;/code&gt;, and to fix the latter, either avoid calling the code in question or compile it with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fomit-yields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">长时间的GC同步可能是由 &lt;code&gt;unsafe&lt;/code&gt; FFI调用内的增变器线程引起的，或者是在不分配内存且因此不产生结果的循环中运行。要修复前者，请确保调用 &lt;code&gt;safe&lt;/code&gt; ，然后要修复后者，请避免调用有问题的代码或使用&lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fomit-yields&lt;/code&gt; 进行&lt;/a&gt;编译。</target>
        </trans-unit>
        <trans-unit id="05cad06e7cb8bda737ea7d67ec36667703119c82" translate="yes" xml:space="preserve">
          <source>A low-level I/O provider where the data is bytes in memory.</source>
          <target state="translated">一个低级I/O提供者,数据是内存中的字节。</target>
        </trans-unit>
        <trans-unit id="2c87eeefae8a2c24218a0a414358507070126796" translate="yes" xml:space="preserve">
          <source>A low-tech way: grep (search) your interface files for overloaded type signatures. You can view interface files using the &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; option (see &lt;a href=&quot;separate_compilation#hi-options&quot;&gt;Other options related to interface files&lt;/a&gt;).</source>
          <target state="translated">一种低技术的方法：grep（搜索）您的接口文件以获取重载的类型签名。您可以使用 &lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt; 选项查看界面文件（请参阅&lt;a href=&quot;separate_compilation#hi-options&quot;&gt;与界面文件有关的其他选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f6dadb395de3d2b9d69bc143f67ef70d410699b4" translate="yes" xml:space="preserve">
          <source>A lower-case identifier &lt;code&gt;foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;Main.foo&lt;/code&gt;.</source>
          <target state="translated">小写的标识符 &lt;code&gt;foo&lt;/code&gt; 。GHC假定主要功能是 &lt;code&gt;Main.foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68062c83cacf82d9a90ab7e0cc7ea387cf2a996a" translate="yes" xml:space="preserve">
          <source>A map of integers to values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">整数到值 &lt;code&gt;a&lt;/code&gt; 的映射。</target>
        </trans-unit>
        <trans-unit id="65d761f61d1d8b61018c0927736bc1f2164bec10" translate="yes" xml:space="preserve">
          <source>A masking character; e.g., &lt;code&gt;Just '*'&lt;/code&gt;</source>
          <target state="translated">掩盖字符；例如， &lt;code&gt;Just '*'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec043ff4717214a6d38bc8fbb175d1fdb2e2c0b5" translate="yes" xml:space="preserve">
          <source>A maximal set of mutually reachable vertices.</source>
          <target state="translated">相互可到达的顶点的最大集合。</target>
        </trans-unit>
        <trans-unit id="11966b51fe1d27560b215138baa79271c17219dd" translate="yes" xml:space="preserve">
          <source>A memory pool.</source>
          <target state="translated">一个内存池。</target>
        </trans-unit>
        <trans-unit id="068781bc49acfb4cc274e15ab83d09598ea7b38a" translate="yes" xml:space="preserve">
          <source>A minimal &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; definition consists of either &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt;. When defining more than this minimal set, one should ensure that the following identities hold:</source>
          <target state="translated">最小的 &lt;code&gt;&lt;a href=&quot;data-bifoldable#t:Bifoldable&quot;&gt;Bifoldable&lt;/a&gt;&lt;/code&gt; 定义由 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldMap&quot;&gt;bifoldMap&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 组成。当定义的不只此最小集合时，应确保以下身份成立：</target>
        </trans-unit>
        <trans-unit id="3ca5616e71a7726aa5bd2663b7f524e751a256d8" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">最小的完整定义必须包括 &lt;code&gt;&lt;a href=&quot;control-applicative#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 的实现。如果同时定义了两者，则它们的行为必须与它们的默认定义相同：</target>
        </trans-unit>
        <trans-unit id="c69118482cffeb2b76367b869803b6611f4079d3" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">最小的完整定义必须包括 &lt;code&gt;&lt;a href=&quot;ghc-base#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 的实现。如果同时定义了两者，则它们的行为必须与它们的默认定义相同：</target>
        </trans-unit>
        <trans-unit id="a11f1b1fc9f85e87f7328e93a0fe87efd1a62782" translate="yes" xml:space="preserve">
          <source>A minimal complete definition must include implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; and of either &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt;. If it defines both, then they must behave the same as their default definitions:</source>
          <target state="translated">最小的完整定义必须包括 &lt;code&gt;&lt;a href=&quot;prelude#v:pure&quot;&gt;pure&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt;&lt;/code&gt; 的实现。如果同时定义了两者，则它们的行为必须与它们的默认定义相同：</target>
        </trans-unit>
        <trans-unit id="b8c72a19154aaf8d59b6b3ec9d5c79b6d054c147" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 的镜像。</target>
        </trans-unit>
        <trans-unit id="d9728f4924a2cece6cd9f3bd1f1fb2a3d7d63e51" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2014f989a9d241989c62fe055f679a0c74c7b1b5" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; 的镜像。</target>
        </trans-unit>
        <trans-unit id="11fd433555f19114cd7accfaf208363211897740" translate="yes" xml:space="preserve">
          <source>A mirror image of &lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-arrow#v:left&quot;&gt;left&lt;/a&gt;&lt;/code&gt; 的镜像。</target>
        </trans-unit>
        <trans-unit id="b38d2272521d203ef9738b678b691090ceb2c2a7" translate="yes" xml:space="preserve">
          <source>A mode that determines the effect of &lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl mode i&lt;/code&gt;.</source>
          <target state="translated">一种确定 &lt;code&gt;&lt;a href=&quot;system-io#v:hSeek&quot;&gt;hSeek&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl mode i&lt;/code&gt; 效果的模式。</target>
        </trans-unit>
        <trans-unit id="5f6374097118c76813d909ba13b814c9cd41e81e" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; in a package &lt;code&gt;P&lt;/code&gt; is trusted by a client C if and only if:</source>
          <target state="translated">且仅在以下情况下，客户端C信任包 &lt;code&gt;P&lt;/code&gt; 中的模块 &lt;code&gt;M&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="79f16cbaafdc9bfd2ba1ca22d71d2c674b761102" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;lsquo;s implementation is included in the final program.</source>
          <target state="translated">一个模块 &lt;code&gt;M&lt;/code&gt; 是 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 在一个程序-imported通常也将通常别处导入。否则， &lt;code&gt;ghc --make&lt;/code&gt; 会自动将 &lt;code&gt;M&lt;/code&gt; 添加到它尝试编译和链接的模块集中，以确保 &lt;code&gt;M&lt;/code&gt; 的实现包含在最终程序中。</target>
        </trans-unit>
        <trans-unit id="987f7b14a3141b967b7850d7f7657d68e62459f9" translate="yes" xml:space="preserve">
          <source>A module &lt;code&gt;M&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in a program will usually also be ordinarily imported elsewhere. If not, &lt;code&gt;ghc --make&lt;/code&gt; automatically adds &lt;code&gt;M&lt;/code&gt; to the set of modules it tries to compile and link, to ensure that &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s implementation is included in the final program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519fe32d3643ce1e03ac2bab30bb1bdcc52d189b" translate="yes" xml:space="preserve">
          <source>A module containing &lt;em&gt;unsafe&lt;/em&gt; operations, for &lt;em&gt;very very careful&lt;/em&gt; use in &lt;em&gt;heavily tested&lt;/em&gt; code.</source>
          <target state="translated">包含&lt;em&gt;不安全&lt;/em&gt;操作的模块，用于在&lt;em&gt;经过严格测试的&lt;/em&gt;代码中&lt;em&gt;非常非常小心地&lt;/em&gt;使用。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="461ba4ff0cf5d9d0e690d1653b0296554ff09c30" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">包含私有 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 内部构件的模块。这将显示 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 表示形式和低级构造功能。扩展 &lt;code&gt;&lt;a href=&quot;data-text-internal#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 系统的模块可能需要使用此模块。</target>
        </trans-unit>
        <trans-unit id="9355e89a95e098cf87e4b9b4d4b0c731bdb2c1ad" translate="yes" xml:space="preserve">
          <source>A module containing private &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; system may need to use this module.</source>
          <target state="translated">包含私有 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 内部构件的模块。这将显示 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 表示形式和低级构造功能。扩展 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 系统的模块可能需要使用此模块。</target>
        </trans-unit>
        <trans-unit id="d6002f28ce7de42f2068e2f04b1e0c26f91c712e" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. As such all the functions in this module are unsafe. The API is also not stable.</source>
          <target state="translated">包含半公共 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 内部的模块。这公开了 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示形式和低级构造函数。因此，此模块中的所有功能都不安全。API也不稳定。</target>
        </trans-unit>
        <trans-unit id="1bd1a012965931778304a7fe9b5fbe73d7d293aa" translate="yes" xml:space="preserve">
          <source>A module containing semi-public &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; internals. This exposes the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; representation and low level construction functions. Modules which extend the &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; system will need to use this module while ideally most users will be able to make do with the public interface modules.</source>
          <target state="translated">包含半公共 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 内部的模块。这公开了 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示形式和低级构造函数。扩展 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 系统的模块将需要使用此模块，而理想情况下，大多数用户将可以使用公共接口模块。</target>
        </trans-unit>
        <trans-unit id="23bf84d5c3edc452896e02cf0360a0e8d1e320af" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; operations.</source>
          <target state="translated">包含不安全的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 操作的模块。</target>
        </trans-unit>
        <trans-unit id="6d9f0c8a370cea074b5aff281e49729218f6c1e7" translate="yes" xml:space="preserve">
          <source>A module containing unsafe &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; operations, for very very careful use in heavily tested code.</source>
          <target state="translated">包含不安全的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 操作的模块，在经过严格测试的代码中非常谨慎地使用。</target>
        </trans-unit>
        <trans-unit id="af7a45c55bc3dff94ebe92e041da9cd2e519eb81" translate="yes" xml:space="preserve">
          <source>A module implementing &lt;code&gt;A&lt;/code&gt; would have to export the function &lt;code&gt;double&lt;/code&gt; with a type definitionally equal to the signature. Note that this means you can&amp;rsquo;t implement &lt;code&gt;double&lt;/code&gt; using a polymorphic function &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;A&lt;/code&gt; 的模块必须使用定义上等于签名的类型来导出功能 &lt;code&gt;double&lt;/code&gt; 。请注意，这意味着您无法使用多态函数 &lt;code&gt;double :: Num a =&amp;gt; a -&amp;gt; a&lt;/code&gt; 来实现 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab6705ee3245e4112a8338653bc894373bc0218c" translate="yes" xml:space="preserve">
          <source>A module name &lt;code&gt;A&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.main&lt;/code&gt;.</source>
          <target state="translated">模块名称 &lt;code&gt;A&lt;/code&gt; 。GHC假定主要功能是 &lt;code&gt;A.main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa8da0aa9a3feddea78d0a337a370d07af5012b" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="translated">从 &lt;code&gt;Example&lt;/code&gt; 导入 &lt;code&gt;MyNum(..)&lt;/code&gt; ，然后重新导出 &lt;code&gt;MyNum(..)&lt;/code&gt; 的模块还将导出在 &lt;code&gt;Example&lt;/code&gt; 中与 &lt;code&gt;MyNum&lt;/code&gt; 捆绑在一起的任何模式同义词。可以在&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/PatternSynonyms/AssociatingSynonyms&quot;&gt;Wiki&lt;/a&gt;上找到更完整的规范。</target>
        </trans-unit>
        <trans-unit id="46205c3964ea4b2def4e3d5de0a91193b170cf06" translate="yes" xml:space="preserve">
          <source>A module which imports &lt;code&gt;MyNum(..)&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt; and then re-exports &lt;code&gt;MyNum(..)&lt;/code&gt; will also export any pattern synonyms bundled with &lt;code&gt;MyNum&lt;/code&gt; in &lt;code&gt;Example&lt;/code&gt;. A more complete specification can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/pattern-synonyms/associating-synonyms&quot;&gt;wiki.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11caca4dfe7a2e6647b187af096af9ce16cdb9c3" translate="yes" xml:space="preserve">
          <source>A monad containing an environment of type &lt;code&gt;r&lt;/code&gt;, output of type &lt;code&gt;w&lt;/code&gt; and an updatable state of type &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">一个monad，包含一个环境 &lt;code&gt;r&lt;/code&gt; 类型，一个输出 &lt;code&gt;w&lt;/code&gt; 类型和一个可更新状态 &lt;code&gt;s&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="44b463ce5ac795e0357256636d6bb8abafd3b888" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="translated">如果monad 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 操作在其第一个参数中是严格的，则表示monad是&lt;em&gt;严格的&lt;/em&gt;。基本单子 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 是严格的：</target>
        </trans-unit>
        <trans-unit id="880b41c9b53dfefef049250c9c1a2e53c78a0d3b" translate="yes" xml:space="preserve">
          <source>A monad is said to be &lt;em&gt;strict&lt;/em&gt; if its &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; operation is strict in its first argument. The base monads &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; are strict:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a2e0dd83579c01e51b5cfcae453a98e588af94" translate="yes" xml:space="preserve">
          <source>A monad supporting atomic memory transactions.</source>
          <target state="translated">一个支持原子内存事务的单体。</target>
        </trans-unit>
        <trans-unit id="84ed5327cac92c7ef6e8588da5238de45965557c" translate="yes" xml:space="preserve">
          <source>A monad that can execute GHCi statements by lifting them out of m into the IO monad. (e.g state monads)</source>
          <target state="translated">一个单体,可以通过将GHCi语句从m中提升到IO单体中来执行。(如状态单体)</target>
        </trans-unit>
        <trans-unit id="2d83f98faa29021325e93148f624ac116d49fdd7" translate="yes" xml:space="preserve">
          <source>A monad that doesn't allow any IO.</source>
          <target state="translated">一个不允许任何IO的单体。</target>
        </trans-unit>
        <trans-unit id="475de8d1c4ced9051885211b80d0128a644d0a1b" translate="yes" xml:space="preserve">
          <source>A monad transformer adding reading an environment of type &lt;code&gt;r&lt;/code&gt;, collecting an output of type &lt;code&gt;w&lt;/code&gt; and updating a state of type &lt;code&gt;s&lt;/code&gt; to an inner monad &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">一个monad变换器添加了读取类型 &lt;code&gt;r&lt;/code&gt; 的环境，收集类型 &lt;code&gt;w&lt;/code&gt; 的输出并将状态 &lt;code&gt;s&lt;/code&gt; 更新为内部monad &lt;code&gt;m&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="ec0442bcbea355903251a46fae40d37d907ac64e" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">单子变压器嵌入懒 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子。所述 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 参数表示由所使用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算是一个特殊的一个由提供的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，从而从那些通过调用使用不同 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21a5486c71e41350dc1ca87d78fb4f0bce729afa" translate="yes" xml:space="preserve">
          <source>A monad transformer embedding lazy &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; parameter indicates that the internal state used by the &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; computation is a special one supplied by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, and thus distinct from those used by invocations of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">单子变压器嵌入懒 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子。所述 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:RealWorld&quot;&gt;RealWorld&lt;/a&gt;&lt;/code&gt; 参数表示由所使用的内部状态 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 计算是一个特殊的一个由提供的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，从而从那些通过调用使用不同 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#v:runST&quot;&gt;runST&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="601b40dc8531d619de3d6e429600341c4287841e" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="translated">一个monad转换器可以从现有monad中创建一个新monad，从而可以将旧monad的计算嵌入到新monad中。为了构建具有所需功能集的monad，通常以基本monad（例如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; )开始，并应用一系列monad变换器。</target>
        </trans-unit>
        <trans-unit id="b365f46b9cfdefb11fdd9add50d3c78cbda728a5" translate="yes" xml:space="preserve">
          <source>A monad transformer makes a new monad out of an existing monad, such that computations of the old monad may be embedded in the new one. To construct a monad with a desired set of features, one typically starts with a base monad, such as &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;, and applies a sequence of monad transformers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7cb8e57886d5e86aabfd267501ad0211c3d9f3" translate="yes" xml:space="preserve">
          <source>A monad transformer that adds exceptions to other monads.</source>
          <target state="translated">一个单项式变换器,可以给其他单项式增加例外。</target>
        </trans-unit>
        <trans-unit id="6426c40e7452ced39d0234fd45fc21a33bd3cc41" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is lazy; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt;.</source>
          <target state="translated">一个结合了 &lt;code&gt;ReaderT&lt;/code&gt; ， &lt;code&gt;WriterT&lt;/code&gt; 和 &lt;code&gt;StateT&lt;/code&gt; 的 monad转换器。这个版本很懒。有关具有几乎相同接口的恒定空间版本，请参见&lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2547fe70b78fa47777714df77c0add427abe3628" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version is strict; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt; instead.</source>
          <target state="translated">一个结合了 &lt;code&gt;ReaderT&lt;/code&gt; ， &lt;code&gt;WriterT&lt;/code&gt; 和 &lt;code&gt;StateT&lt;/code&gt; 的 monad转换器。这个版本是严格的。有关具有相同接口的惰性版本，请参见&lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;。尽管输出是严格构建的，但是使用此转换器无法实现恒定的空间行为：为此，请使用&lt;a href=&quot;control-monad-trans-rws-cps&quot;&gt;Control.Monad.Trans.RWS.CPS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e9a2ee9baf8f5856a19298f4db328fc74a1d39bd" translate="yes" xml:space="preserve">
          <source>A monad transformer that combines &lt;code&gt;ReaderT&lt;/code&gt;, &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;StateT&lt;/code&gt;. This version uses continuation-passing-style for the writer part to achieve constant space usage. For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;.</source>
          <target state="translated">一个结合了 &lt;code&gt;ReaderT&lt;/code&gt; ， &lt;code&gt;WriterT&lt;/code&gt; 和 &lt;code&gt;StateT&lt;/code&gt; 的 monad转换器。此版本对编写器部分使用连续传递样式，以实现恒定的空间使用率。有关具有相同接口的惰性版本，请参见&lt;a href=&quot;control-monad-trans-rws-lazy&quot;&gt;Control.Monad.Trans.RWS.Lazy&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="500a320bcd121d2c8283ae8852b2515080dcee31" translate="yes" xml:space="preserve">
          <source>A monad transformer which carries all of the state and settings relevant to a line-reading application.</source>
          <target state="translated">一个单元变压器,它承载了与读线应用相关的所有状态和设置。</target>
        </trans-unit>
        <trans-unit id="f7f92818234c049ae409685d4444b37152111dc8" translate="yes" xml:space="preserve">
          <source>A monoid on applicative functors.</source>
          <target state="translated">适用性漏斗的单体。</target>
        </trans-unit>
        <trans-unit id="fe60158aa8a2b3958c4da9fb0fee916548d774b6" translate="yes" xml:space="preserve">
          <source>A monoid on arrows.</source>
          <target state="translated">箭头上的单体。</target>
        </trans-unit>
        <trans-unit id="5845b618bce8288ed7fd6ae679531f4a7a5b077f" translate="yes" xml:space="preserve">
          <source>A more precise specification is as follows. The willingness to be overlapped or incoherent is a property of the &lt;em&gt;instance declaration&lt;/em&gt; itself, controlled as follows:</source>
          <target state="translated">更加精确的规格如下。重叠或不一致的意愿是&lt;em&gt;实例声明&lt;/em&gt;本身的属性，其控制如下：</target>
        </trans-unit>
        <trans-unit id="f0e63911e5dfc97bc3c592219078a690d8ed2ff3" translate="yes" xml:space="preserve">
          <source>A mutable array of bytes that can be passed to foreign functions.</source>
          <target state="translated">一个可传递给外部函数的字节数组。</target>
        </trans-unit>
        <trans-unit id="aaaa00796670cca26a60ac72f4e07d8b337ab183" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="translated">具有未装箱元素的可变数组，可以在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad中对其进行操作。类型参数如下：</target>
        </trans-unit>
        <trans-unit id="3387c300ae3f8914517cc0cd6aa9b1be1561eb1a" translate="yes" xml:space="preserve">
          <source>A mutable array with unboxed elements, that can be manipulated in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-st-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; monad. The type arguments are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6994baa9908c386c8aa2378b6690cc491d3b838a" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 中的可变变量</target>
        </trans-unit>
        <trans-unit id="86d8cb4c41428c71956a58b3affc3d3a67e5a624" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985e8387b10ebbbd6e5ab332eab6588b350aa36d" translate="yes" xml:space="preserve">
          <source>A mutable variable in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 中的可变变量</target>
        </trans-unit>
        <trans-unit id="a954d6c35420d409169ad1a91fbdf2cc6fa8fd09" translate="yes" xml:space="preserve">
          <source>A name can be quoted with either one or two prefix single quotes:</source>
          <target state="translated">一个名字可以用一个或两个前缀单引号来引用。</target>
        </trans-unit>
        <trans-unit id="6eac8d924312d7747867fd052a0984825adb6ab0" translate="yes" xml:space="preserve">
          <source>A name whose second character is a single quote (sadly) cannot be quoted in this way, because it will be parsed instead as a quoted character. For example, if the function is called &lt;code&gt;f'7&lt;/code&gt; (which is a legal Haskell identifier), an attempt to quote it as &lt;code&gt;'f'7&lt;/code&gt; would be parsed as the character literal &lt;code&gt;'f'&lt;/code&gt; followed by the numeric literal &lt;code&gt;7&lt;/code&gt;. There is no current escape mechanism in this (unusual) situation.</source>
          <target state="translated">第二个字符（单引号）（很难）的名称不能用这种方式引用，因为它将被解析为带引号的字符。例如，如果函数名为 &lt;code&gt;f'7&lt;/code&gt; （这是合法的Haskell标识符），则将其引用为 &lt;code&gt;'f'7&lt;/code&gt; 将解析为字符文字 &lt;code&gt;'f'&lt;/code&gt; 后跟数字文字 &lt;code&gt;7&lt;/code&gt; 。在这种（异常）情况下，目前没有逃逸机制。</target>
        </trans-unit>
        <trans-unit id="7f16e7f677a6d8e62b9e97a39d3de36debfc79cc" translate="yes" xml:space="preserve">
          <source>A name's package, if it exists.</source>
          <target state="translated">一个名字的包,如果它存在的话。</target>
        </trans-unit>
        <trans-unit id="7598a3dc426907ef37ba1a8eb3a99bc5a30b0e87" translate="yes" xml:space="preserve">
          <source>A new chunk of heap has been allocated by the indicated capability set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6919dce57a8f508bed2b02c9c8ad2d961f4e47dd" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; 功能企图把价值 &lt;code&gt;a&lt;/code&gt; 成 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; ，返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果它是成功的，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="1adb02601e1d9275c9a9312a596d444889d03e7a" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; 立即函数返回时，与 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是充满内容的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ccd9ca2458eb3a684692c3f8141733d7490bf75" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 立即函数返回时，与 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是充满内容的 &lt;code&gt;a&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 之后， &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 保留为空。</target>
        </trans-unit>
        <trans-unit id="e55cff29c2c9733e10c5a0b338cfcec2b5ad75a2" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryPutMVar&quot;&gt;tryPutMVar&lt;/a&gt;&lt;/code&gt; 功能企图把价值 &lt;code&gt;a&lt;/code&gt; 成 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; ，返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果它是成功的，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="206f440a2076bebff809698fc93d8fc54da5d7ab" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:readMVar&quot;&gt;readMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryReadMVar&quot;&gt;tryReadMVar&lt;/a&gt;&lt;/code&gt; 立即函数返回时，与 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是充满内容的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c36e2f146526d2510dab34b468a2981631693ee" translate="yes" xml:space="preserve">
          <source>A non-blocking version of &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; function returns immediately, with &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。该 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 立即函数返回时，与 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是充满内容的 &lt;code&gt;a&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;ghc-mvar#v:tryTakeMVar&quot;&gt;tryTakeMVar&lt;/a&gt;&lt;/code&gt; 之后， &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 保留为空。</target>
        </trans-unit>
        <trans-unit id="2569960f87e4b3b548288102fd577f9229d2fab8" translate="yes" xml:space="preserve">
          <source>A non-indexed type representation.</source>
          <target state="translated">一个非索引的类型表示。</target>
        </trans-unit>
        <trans-unit id="e9d1290f4bd898d7ad62e94e9d30ceb6655bd011" translate="yes" xml:space="preserve">
          <source>A non-inlined version of &lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-text-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 非内联版本。</target>
        </trans-unit>
        <trans-unit id="7f03b8899bb7d9e29bd30f804a030dd4fd076a1a" translate="yes" xml:space="preserve">
          <source>A note on evaluation order: the expression &lt;code&gt;seq a b&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; guarantee that &lt;code&gt;a&lt;/code&gt; will be evaluated before &lt;code&gt;b&lt;/code&gt;. The only guarantee given by &lt;code&gt;seq&lt;/code&gt; is that the both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be evaluated before &lt;code&gt;seq&lt;/code&gt; returns a value. In particular, this means that &lt;code&gt;b&lt;/code&gt; may be evaluated before &lt;code&gt;a&lt;/code&gt;. If you need to guarantee a specific order of evaluation, you must use the function &lt;code&gt;pseq&lt;/code&gt; from the &quot;parallel&quot; package.</source>
          <target state="translated">在评估顺序的说明：表达 &lt;code&gt;seq a b&lt;/code&gt; 并&lt;em&gt;不能&lt;/em&gt;保证 &lt;code&gt;a&lt;/code&gt; 将之前评估 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;seq&lt;/code&gt; 唯一保证的是 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都将在 &lt;code&gt;seq&lt;/code&gt; 返回值之前进行求值。特别是，这意味着 &lt;code&gt;b&lt;/code&gt; 可以在 &lt;code&gt;a&lt;/code&gt; 之前求值。如果需要保证评估的特定顺序，则必须使用&amp;ldquo; parallel&amp;rdquo;包中的 &lt;code&gt;pseq&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="3c16b58b80137c1a8cc002192b71e052aeb6a9ce" translate="yes" xml:space="preserve">
          <source>A number of restrictions apply to use of annotations:</source>
          <target state="translated">注释的使用有一些限制。</target>
        </trans-unit>
        <trans-unit id="711bb74ca36d3d4c1868e4f33ea8af8c9700a708" translate="yes" xml:space="preserve">
          <source>A package database is where the details about installed packages are stored. It is a directory, usually called &lt;code&gt;package.conf.d&lt;/code&gt;, that contains a file for each package, together with a binary cache of the package data in the file &lt;code&gt;package.cache&lt;/code&gt;. Normally you won&amp;rsquo;t need to look at or modify the contents of a package database directly; all management of package databases can be done through the &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">软件包数据库是存储有关已安装软件包的详细信息的位置。它是一个目录，通常称为 &lt;code&gt;package.conf.d&lt;/code&gt; ，其中包含每个软件包的文件以及文件 &lt;code&gt;package.cache&lt;/code&gt; 中软件包数据的二进制缓存。通常，您无需直接查看或修改包数据库的内容；软件包数据库的所有管理都可以通过&lt;strong&gt;ghc-pkg&lt;/strong&gt;工具完成（请参阅&lt;a href=&quot;#package-management&quot;&gt;软件包管理（ghc-pkg命令）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e6482c111ff88fbc29ede2ddeea4102525681832" translate="yes" xml:space="preserve">
          <source>A package description consists of a number of field/value pairs. A field starts with the field name in the left-hand column followed by a &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo;, and the value continues until the next line that begins in the left-hand column, or the end of file.</source>
          <target state="translated">包描述由许多字段/值对组成。字段以左栏中的字段名开头，后跟&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo;，该值一直持续到从左栏中开始的下一行或文件末尾为止。</target>
        </trans-unit>
        <trans-unit id="f0d41efbca1f6d8a23338adade26a83c1583e8be" translate="yes" xml:space="preserve">
          <source>A package is a library of Haskell modules known to the compiler. GHC comes with several packages: see the accompanying &lt;a href=&quot;../libraries/index&quot;&gt;library documentation&lt;/a&gt;. More packages to install can be obtained from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;.</source>
          <target state="translated">软件包是编译器已知的Haskell模块库。GHC附带了几个软件包：请参阅随附的&lt;a href=&quot;../libraries/index&quot;&gt;库文档&lt;/a&gt;。可以从&lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;获得更多要安装的软件包。</target>
        </trans-unit>
        <trans-unit id="a3dbde045ae446b9fd85968f7cfc7dbefc9f7710" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/Cabal-3.2.0.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c877a3844ef3dc7d9601200a6497a731da7b2b16" translate="yes" xml:space="preserve">
          <source>A package specification is a Haskell record; in particular, it is the record &lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo.InstalledPackageInfo&lt;/a&gt; in the module Distribution.InstalledPackageInfo, which is part of the Cabal package distributed with GHC.</source>
          <target state="translated">包规范是Haskell记录；特别是，它是模块&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/Cabal-3.0.1.0/Distribution-InstalledPackageInfo.html#t:InstalledPackageInfo&quot;&gt;Distribution.InstalledPackageInfo&lt;/a&gt;中的Distribution.InstalledPackageInfo.InstalledPackageInfo 记录，该记录是与GHC一起分发的Cabal软件包的一部分。</target>
        </trans-unit>
        <trans-unit id="8d7ab63973f7143650edb4489cbabd9755f0dae2" translate="yes" xml:space="preserve">
          <source>A pair of an open type family equations is checked by attempting to unify their RHSs. If the RHSs don&amp;rsquo;t unify this pair does not violate injectivity annotation. If unification succeeds with a substitution then LHSs of unified equations must be identical under that substitution. If they are not identical then GHC reports that the type family is not injective.</source>
          <target state="translated">通过尝试统一一对RHS来检查一对开放式族方程。如果RHS不统一，那么这对将不会违反注入性注释。如果统一替换成功，则在该替换下统一方程式的LHS必须相同。如果它们不相同，则GHC报告类型族不是内射的。</target>
        </trans-unit>
        <trans-unit id="84d2773400375ccf44e88b72599837fd03633672" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with both a key and the original position of its elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标记为键和元素原始位置的配对堆，用于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dd62e14bc9431464958571d2b435d03d28b2f82" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with some key for sorting elements, for use in &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">带有一些用于对元素进行排序的键标记的配对堆，用于 &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08959b3dc19b34612dd713a20c89a35536c5c8b1" translate="yes" xml:space="preserve">
          <source>A pairing heap tagged with the original position of elements, to allow for stable sorting.</source>
          <target state="translated">用元素的原始位置标记的配对堆,以便进行稳定的排序。</target>
        </trans-unit>
        <trans-unit id="179683aea0f779b8d62f71ce768d02e25c23258e" translate="yes" xml:space="preserve">
          <source>A pairing/concatenation operator for builder primitives, both bounded and fixed size.</source>
          <target state="translated">用于构建器基元的配对/连接操作符,包括有界和固定大小的基元。</target>
        </trans-unit>
        <trans-unit id="a9abb3b7589ecd20d1d2b93e90cc7db6542915ba" translate="yes" xml:space="preserve">
          <source>A parallel garbage collection has been requested by a capability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b720794f2dd0a7c18f79f3dbbf604879cd4d39c" translate="yes" xml:space="preserve">
          <source>A parallel list comprehension has multiple independent branches of qualifier lists, each separated by a &lt;code&gt;|&lt;/code&gt; symbol. For example, the following zips together two lists:</source>
          <target state="translated">并行列表推导具有多个独立的限定符列表分支，每个分支由 &lt;code&gt;|&lt;/code&gt; 分隔。符号。例如，以下将两个列表压缩在一起：</target>
        </trans-unit>
        <trans-unit id="3fb86b841f661b45cc569b86782f61f203ff3263" translate="yes" xml:space="preserve">
          <source>A parameter to specify the number of lines affected. Some capabilities (e.g., &lt;code&gt;clear&lt;/code&gt; and &lt;code&gt;dch1&lt;/code&gt;) use this parameter on some terminals to compute variable-length padding.</source>
          <target state="translated">用于指定受影响的行数的参数。一些功能（例如 &lt;code&gt;clear&lt;/code&gt; 和 &lt;code&gt;dch1&lt;/code&gt; ）在某些终端上使用此参数来计算可变长度的填充。</target>
        </trans-unit>
        <trans-unit id="3c7816b5381405514fd134ab41157f7a1b19dbb1" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">一种用于类型解析器 &lt;code&gt;a&lt;/code&gt; ，表示为需要的函数 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 并返回可能解析的列表作为 &lt;code&gt;(a,&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="8ef40a705741b0fa0c05e60da025feb810b08af8" translate="yes" xml:space="preserve">
          <source>A parser for a type &lt;code&gt;a&lt;/code&gt;, represented as a function that takes a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; and returns a list of possible parses as &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; pairs.</source>
          <target state="translated">一种用于类型解析器 &lt;code&gt;a&lt;/code&gt; ，表示为需要的函数 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 并返回可能解析的列表作为 &lt;code&gt;(a,&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;)&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="77e31a3f5862591f06987b3fcab3d8cc7ae35a42" translate="yes" xml:space="preserve">
          <source>A parser for versions in the format produced by &lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">用于解析版本的格式解析器，该格式由 &lt;code&gt;&lt;a href=&quot;data-version#v:showVersion&quot;&gt;showVersion&lt;/a&gt;&lt;/code&gt; 生成。</target>
        </trans-unit>
        <trans-unit id="00189f74465df92aa0eb7c3be6fb9e5d018cbddf" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders called &lt;em&gt;wildcards&lt;/em&gt;. A wildcard is written as an underscore (e.g. &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;) or, if &lt;a href=&quot;#extension-NamedWildCards&quot;&gt;&lt;code&gt;NamedWildCards&lt;/code&gt;&lt;/a&gt; is enabled, any identifier with a leading underscore (e.g. &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;). Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d03f9fe4fb54a82d09df64d310f7a60062a82" translate="yes" xml:space="preserve">
          <source>A partial type signature is a type signature containing special placeholders written with a leading underscore (e.g., &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_foo&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;_bar&lt;/code&gt;&amp;rdquo;) called &lt;em&gt;wildcards&lt;/em&gt;. Partial type signatures are to type signatures what &lt;a href=&quot;#typed-holes&quot;&gt;Typed Holes&lt;/a&gt; are to expressions. During compilation these wildcards or holes will generate an error message that describes which type was inferred at the hole&amp;rsquo;s location, and information about the origin of any free type variables. GHC reports such error messages by default.</source>
          <target state="translated">部分类型签名是一种类型签名，其中包含特殊的占位符，这些占位符前导下划线（例如&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;_foo&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;_bar&lt;/code&gt; &amp;rdquo;）称为&lt;em&gt;通配符&lt;/em&gt;。部分类型签名用于键入签名，而&amp;ldquo;表达式&lt;a href=&quot;#typed-holes&quot;&gt;孔&amp;rdquo;&lt;/a&gt;则用于表达。在编译期间，这些通配符或漏洞将生成一条错误消息，该错误消息描述了在漏洞位置推断出的类型，以及有关任何自由类型变量的起源的信息。默认情况下，GHC报告此类错误消息。</target>
        </trans-unit>
        <trans-unit id="0ce90625442120850b40e55bce20778556220c5e" translate="yes" xml:space="preserve">
          <source>A pattern</source>
          <target state="translated">一种模式</target>
        </trans-unit>
        <trans-unit id="433fae1ea61aa93f2a83f57ff1684a275dd099f0" translate="yes" xml:space="preserve">
          <source>A pattern match failed. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the pattern.</source>
          <target state="translated">模式匹配失败。的 &lt;code&gt;String&lt;/code&gt; 给出了关于图案的源位置信息。</target>
        </trans-unit>
        <trans-unit id="252b18a2db7ed609ee5f049df36aa764455492be" translate="yes" xml:space="preserve">
          <source>A pattern quasiquoter &lt;em&gt;may&lt;/em&gt; generate binders that scope over the right-hand side of a definition because these binders are in scope lexically. For example, given a quasiquoter &lt;code&gt;haskell&lt;/code&gt; that parses Haskell, in the following code, the &lt;code&gt;y&lt;/code&gt; in the right-hand side of &lt;code&gt;f&lt;/code&gt; refers to the &lt;code&gt;y&lt;/code&gt; bound by the &lt;code&gt;haskell&lt;/code&gt; pattern quasiquoter, &lt;em&gt;not&lt;/em&gt; the top-level &lt;code&gt;y = 7&lt;/code&gt;.</source>
          <target state="translated">模式准引号&lt;em&gt;可能会&lt;/em&gt;生成在定义的右侧范围内的活页夹，因为这些活页夹在词法上是范围内的。例如，给定一个quasiquoter &lt;code&gt;haskell&lt;/code&gt; ，将分析Haskell中，在下面的代码，所述 &lt;code&gt;y&lt;/code&gt; 中的右手侧 &lt;code&gt;f&lt;/code&gt; 指 &lt;code&gt;y&lt;/code&gt; 由结合 &lt;code&gt;haskell&lt;/code&gt; 图案quasiquoter，&lt;em&gt;不&lt;/em&gt;顶层 &lt;code&gt;y = 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac55497c2a5f3f9d1f6ff0844f5381d5d90653d" translate="yes" xml:space="preserve">
          <source>A pattern synonym</source>
          <target state="translated">一种模式的同义词</target>
        </trans-unit>
        <trans-unit id="b17af7c644158ae7e89b62cef1f1583e8c015c62" translate="yes" xml:space="preserve">
          <source>A pattern synonym declaration can be either unidirectional, bidirectional or explicitly bidirectional. The syntax for unidirectional pattern synonyms is:</source>
          <target state="translated">模式同义词声明可以是单向、双向或显式双向的。单向模式同义词的语法是。</target>
        </trans-unit>
        <trans-unit id="55cb5ca64df4e9f9ca70699a5130d9563eece58c" translate="yes" xml:space="preserve">
          <source>A pattern synonym occurrence in a pattern is evaluated by first matching against the pattern synonym itself, and then on the argument patterns.</source>
          <target state="translated">在模式中出现的模式同义词,首先要与模式同义词本身进行匹配,然后对参数模式进行评估。</target>
        </trans-unit>
        <trans-unit id="6a294e72d5a00c5790ab20aeadfe0fb6770ada67" translate="yes" xml:space="preserve">
          <source>A pattern synonym's argument type.</source>
          <target state="translated">一个模式同义词的参数类型。</target>
        </trans-unit>
        <trans-unit id="cc5e6ef416da30039d54dd764052a16e266e5fba" translate="yes" xml:space="preserve">
          <source>A pattern synonym's directionality.</source>
          <target state="translated">一种模式同义词的方向性。</target>
        </trans-unit>
        <trans-unit id="dbbd0987654018a69ab48de461e219d56cbd0973" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type signature.</source>
          <target state="translated">一个模式同义词的类型签名。</target>
        </trans-unit>
        <trans-unit id="57cf5046220efabc22f8328901a49323d7f92001" translate="yes" xml:space="preserve">
          <source>A pattern synonym's type. Note that a pattern synonym's &lt;em&gt;fully&lt;/em&gt; specified type has a peculiar shape coming with two forall quantifiers and two constraint contexts. For example, consider the pattern synonym</source>
          <target state="translated">模式同义词的类型。请注意，模式同义词的&lt;em&gt;完全&lt;/em&gt;指定类型具有奇特的形状，带有两个forall量词和两个约束上下文。例如，考虑模式同义词</target>
        </trans-unit>
        <trans-unit id="eb6f155dcdcf6384b306398b26156bf38f28d6e1" translate="yes" xml:space="preserve">
          <source>A pattern type signature (&lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;)</source>
          <target state="translated">模式类型签名（&lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="a7c69d52227bddae63e60e9734e227c6257070e0" translate="yes" xml:space="preserve">
          <source>A pattern variable may optionally have a type signature. If the type of the pattern variable is polymorphic, it &lt;em&gt;must&lt;/em&gt; have a type signature. For example, here is the &lt;code&gt;foldr/build&lt;/code&gt; rule:</source>
          <target state="translated">模式变量可以选择具有类型签名。如果模式变量的类型是多态的，则它&lt;em&gt;必须&lt;/em&gt;具有类型签名。例如，这是文件 &lt;code&gt;foldr/build&lt;/code&gt; 规则：</target>
        </trans-unit>
        <trans-unit id="0a9bf5dd0f5b938cd3b48a5e6e85a85c3767d1a0" translate="yes" xml:space="preserve">
          <source>A pattern with a bang at the outermost level is not allowed at the top level of a module.</source>
          <target state="translated">一个模块的最外层有砰砰声的图案是不允许在模块的顶层出现的。</target>
        </trans-unit>
        <trans-unit id="a45544682b3f8a207a4592a867670905952dce9d" translate="yes" xml:space="preserve">
          <source>A periodic reporting of various statistics of spark evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9808c24500197f32f662437a4166807e09da1b17" translate="yes" xml:space="preserve">
          <source>A permutation phrase is a sequence of elements (possibly of different types) in which each element occurs exactly once and the order is irrelevant. Some of the permutable elements may be optional.</source>
          <target state="translated">一个置换短语是一个元素序列(可能是不同类型的元素),其中每个元素只出现一次,顺序无关紧要。有些可换元素可以是可选的。</target>
        </trans-unit>
        <trans-unit id="5dbcb4942ca58cf7831c96fb91a0838412cc4bba" translate="yes" xml:space="preserve">
          <source>A pinned byte array is one that the garbage collector is not allowed to move. Consequently, it has a stable address that can be safely requested with &lt;code&gt;byteArrayContents#&lt;/code&gt;. There are a handful of primitive functions in GHC.Prim &amp;lt;GHC-Prim.html&amp;gt; used to enforce or check for pinnedness: &lt;code&gt;isByteArrayPinned#&lt;/code&gt;, &lt;code&gt;isMutableByteArrayPinned#&lt;/code&gt;, and &lt;code&gt;newPinnedByteArray#&lt;/code&gt;. A byte array can be pinned as a result of three possible causes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d2f58da1fb581a9ce7c0820def592bde3a97f6" translate="yes" xml:space="preserve">
          <source>A plugin which declares itself impure using &lt;code&gt;ForceRecompile&lt;/code&gt; will always trigger a recompilation of the current module. &lt;code&gt;NoForceRecompile&lt;/code&gt; is used for &amp;ldquo;pure&amp;rdquo; plugins which don&amp;rsquo;t need to be rerun unless a module would ordinarily be recompiled. &lt;code&gt;MaybeRecompile&lt;/code&gt; computes a &lt;code&gt;Fingerprint&lt;/code&gt; and if this &lt;code&gt;Fingerprint&lt;/code&gt; is different to a previously computed &lt;code&gt;Fingerprint&lt;/code&gt; for the plugin, then we recompile the module.</source>
          <target state="translated">使用 &lt;code&gt;ForceRecompile&lt;/code&gt; 声明自身不正确的插件将始终触发当前模块的重新编译。 &lt;code&gt;NoForceRecompile&lt;/code&gt; 用于&amp;ldquo;纯&amp;rdquo;插件，除非通常会重新编译模块，否则它们无需重新运行。 &lt;code&gt;MaybeRecompile&lt;/code&gt; 将计算一个 &lt;code&gt;Fingerprint&lt;/code&gt; ，如果该 &lt;code&gt;Fingerprint&lt;/code&gt; 与该插件先前计算的 &lt;code&gt;Fingerprint&lt;/code&gt; 不同，则我们将重新编译该模块。</target>
        </trans-unit>
        <trans-unit id="a3bc90dc2dc45d7f4fd4afcd9ae1bd1af634697a" translate="yes" xml:space="preserve">
          <source>A plugin&amp;rsquo;s installation function (&lt;code&gt;install&lt;/code&gt; in the above example) takes a list of &lt;code&gt;CoreToDo&lt;/code&gt;s and returns a list of &lt;code&gt;CoreToDo&lt;/code&gt;. Before GHC begins compiling modules, it enumerates all the needed plugins you tell it to load, and runs all of their installation functions, initially on a list of passes that GHC specifies itself. After doing this for every plugin, the final list of passes is given to the optimizer, and are run by simply going over the list in order.</source>
          <target state="translated">一个插件的安装功能（ &lt;code&gt;install&lt;/code&gt; 在上面的例子）取的列表 &lt;code&gt;CoreToDo&lt;/code&gt; S和返回的列表 &lt;code&gt;CoreToDo&lt;/code&gt; 。在GHC开始编译模块之前，它会枚举您告诉它加载的所有必需插件，并运行它们的所有安装功能，最初是在GHC指定自身的传递列表上进行的。在对每个插件执行此操作之后，将通过的最终列表提供给优化器，并只需按顺序遍历列表即可运行。</target>
        </trans-unit>
        <trans-unit id="c3c0c15abdc47e8b410d77eeddeb4ff60204efc9" translate="yes" xml:space="preserve">
          <source>A pointer to a foreign function equivalent to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;, which may be used as a finalizer (cf &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;) for storage allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">指向一个外部函数相当于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; ，其可以被用作一个终结（CF &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 用于与分配的存储） &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; 的或 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed62f36de9a3053add8b5f383c46d4ea22035d53" translate="yes" xml:space="preserve">
          <source>A pointer, but &lt;em&gt;not&lt;/em&gt; to a Haskell value</source>
          <target state="translated">指针，但&lt;em&gt;不&lt;/em&gt;指向Haskell值</target>
        </trans-unit>
        <trans-unit id="12c3c6eef2eab225b82c10e7756d7d1120735999" translate="yes" xml:space="preserve">
          <source>A positive initial counter value denotes availability of units &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; can acquire.</source>
          <target state="translated">初始计数器值为正数表示 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#v:waitTSem&quot;&gt;waitTSem&lt;/a&gt;&lt;/code&gt; 可以获取的单位可用性。</target>
        </trans-unit>
        <trans-unit id="4607e3c8d43d975a9d5043b9fe5325adef419139" translate="yes" xml:space="preserve">
          <source>A possible reason for this is that &lt;code&gt;readLitChar&lt;/code&gt; accepts hex and octal escapes, so it seems inconsistent not to do so for integers too.</source>
          <target state="translated">可能的原因是 &lt;code&gt;readLitChar&lt;/code&gt; 接受十六进制和八进制转义，因此对于整数也不这样做也似乎不一致。</target>
        </trans-unit>
        <trans-unit id="ee0df3315cf15090b8170db19c00adae9d086669" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; 方法的可能的替换定义。这仅需要 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read1&quot;&gt;Read1&lt;/a&gt;&lt;/code&gt; 其中为实例 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 没有被定义为 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d38c3479f89f023338692e638f45fe5ac188bd2d" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; method. This is only needed for &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; 方法的可能的替换定义。这仅需要 &lt;code&gt;&lt;a href=&quot;data-functor-classes#t:Read2&quot;&gt;Read2&lt;/a&gt;&lt;/code&gt; 则其中为实例 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; 没有被定义为 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1d027bf72f3911128c132d8c54e0a8ef6c5c888" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 方法的可能替代定义。</target>
        </trans-unit>
        <trans-unit id="5d373fa8bb2d277c322dacc2f2dcc3f3d824b4e2" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; 方法的可能替代定义。</target>
        </trans-unit>
        <trans-unit id="29364a8e8891d9c56243d372544806d4d546619b" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 方法的可能替换定义（仅适用于GHC）。这仅需要GHC，而且当时只用于 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 其中为实例 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 没有被定义为 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68ae1239307d70eba9e18971c894baa48ad11cf4" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 方法的可能替换定义，使用 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 定义（仅GHC）。</target>
        </trans-unit>
        <trans-unit id="f80e2bb9e234ed027f7e8ba6d593f983b80c8933" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; method (GHC only). This is only needed for GHC, and even then only for &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances where &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; isn't defined as &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readList&quot;&gt;readList&lt;/a&gt;&lt;/code&gt; 方法的可能替换定义（仅适用于GHC）。这仅需要GHC，而且当时只用于 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 其中为实例 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 没有被定义为 &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrecDefault&quot;&gt;readListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f98f636cd56d17e711ba559f0f71c4bdebdffa1" translate="yes" xml:space="preserve">
          <source>A possible replacement definition for the &lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; method, defined using &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-read#v:readListPrec&quot;&gt;readListPrec&lt;/a&gt;&lt;/code&gt; 方法的可能替换定义，使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 定义（仅GHC）。</target>
        </trans-unit>
        <trans-unit id="b157127674bef09a54a1bf4952fda41dd1808377" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;M&lt;/code&gt;' always stands for a function in the Kleisli category: The monad type constructor &lt;code&gt;m&lt;/code&gt; is added to function results (modulo currying) and nowhere else. So, for example,</source>
          <target state="translated">后缀' &lt;code&gt;M&lt;/code&gt; '始终代表Kleisli类别中的函数：monad类型的构造函数 &lt;code&gt;m&lt;/code&gt; 被添加到函数结果（模运算）中，除此之外没有其他地方。因此，例如</target>
        </trans-unit>
        <trans-unit id="4f57aca0d9a4c899e484cd901e67bacaa13d70b9" translate="yes" xml:space="preserve">
          <source>A postfix '&lt;code&gt;_&lt;/code&gt;' changes the result type from &lt;code&gt;(m a)&lt;/code&gt; to &lt;code&gt;(m ())&lt;/code&gt;. Thus, for example:</source>
          <target state="translated">后缀 &lt;code&gt;_&lt;/code&gt; 会将结果类型从 &lt;code&gt;(m a)&lt;/code&gt; 更改为 &lt;code&gt;(m ())&lt;/code&gt; 。因此，例如：</target>
        </trans-unit>
        <trans-unit id="46921428c3bbaa58265d19bfda0ee3268636763a" translate="yes" xml:space="preserve">
          <source>A precise semantics</source>
          <target state="translated">准确的语义</target>
        </trans-unit>
        <trans-unit id="47f994aa80408a0bd45b4587fcafe17e6fd888ec" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="translated">如果在返回缓冲区之前应该修剪缓冲区，则 &lt;code&gt;trim used allocated&lt;/code&gt; 谓词修剪来分配返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d580afd63f73de0a796d71c734098f93fa407b93" translate="yes" xml:space="preserve">
          <source>A predicate &lt;code&gt;trim used allocated&lt;/code&gt; returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, if the buffer should be trimmed before it is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7be90e7ccc0906e803e54dbfc057396ec04901" translate="yes" xml:space="preserve">
          <source>A prefix '&lt;code&gt;m&lt;/code&gt;' generalizes an existing function to a monadic form. Thus, for example:</source>
          <target state="translated">前缀&amp;ldquo; &lt;code&gt;m&lt;/code&gt; &amp;rdquo;将现有功能概括为单子形式。因此，例如：</target>
        </trans-unit>
        <trans-unit id="89ba2753b7a938dad018da0fd6997dc0b76bb953" translate="yes" xml:space="preserve">
          <source>A primitive C-style string, type Addr#</source>
          <target state="translated">一个原始的C型字符串,类型为Addr#。</target>
        </trans-unit>
        <trans-unit id="47d0a23e976121bc1cfab9f6f18718ab2b9d2383" translate="yes" xml:space="preserve">
          <source>A process in the process group</source>
          <target state="translated">流程组中的一个流程</target>
        </trans-unit>
        <trans-unit id="e2978f6c6d0c2493478216f46bf15eb08160b4e7" translate="yes" xml:space="preserve">
          <source>A program that fails in any other way is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;. A program that terminates successfully without calling &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; explicitly is treated as if it had called &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以任何其他方式失败的程序都被视为已调用 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 。成功终止 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; 显式调用exitWith的程序将被视为已调用 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="106e5d7fb17753020184a4433ee767b6d5411226" translate="yes" xml:space="preserve">
          <source>A programmer may use &lt;code&gt;forall&lt;/code&gt; in a type to introduce new quantified type variables. These variables may depend on each other, even in the same &lt;code&gt;forall&lt;/code&gt;. However, GHC requires that the dependency be inferrable from the body of the &lt;code&gt;forall&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">程序员可以在类型中使用 &lt;code&gt;forall&lt;/code&gt; 来引入新的量化类型变量。这些变量可以互相依赖，甚至在同一个 &lt;code&gt;forall&lt;/code&gt; 。但是，GHC要求从 &lt;code&gt;forall&lt;/code&gt; 的主体中可以推断出依赖性。这里有些例子：</target>
        </trans-unit>
        <trans-unit id="71ba773b3259e537cc66acd4ec6d24f2384a5425" translate="yes" xml:space="preserve">
          <source>A programmer-defined error value constructed using &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; 构造的程序员定义的错误值。</target>
        </trans-unit>
        <trans-unit id="7217616c7698f7547fd2c1e5c701e62f18577563" translate="yes" xml:space="preserve">
          <source>A pun on a qualified field name is expanded by stripping off the module qualifier. For example:</source>
          <target state="translated">对限定字段名的双关语,通过去掉模块修饰词来扩展。例如:</target>
        </trans-unit>
        <trans-unit id="c36208f7850763edf61643d27d80bde39732dac8" translate="yes" xml:space="preserve">
          <source>A qualified name &lt;code&gt;A.foo&lt;/code&gt;. GHC assumes that the main function is &lt;code&gt;A.foo&lt;/code&gt;.</source>
          <target state="translated">限定名称 &lt;code&gt;A.foo&lt;/code&gt; 。GHC假定主要功能是 &lt;code&gt;A.foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1f854f70933a723bf95a735c3aa4de5afabd5c6" translate="yes" xml:space="preserve">
          <source>A qualified name; dynamically bound</source>
          <target state="translated">一个限定名称;动态绑定</target>
        </trans-unit>
        <trans-unit id="a8f9eb9db19a1818e7c75d1fe1ee9a6205220c54" translate="yes" xml:space="preserve">
          <source>A quantified type representation.</source>
          <target state="translated">一种量化的类型表示。</target>
        </trans-unit>
        <trans-unit id="e82bbf975220aa7ab5228dfdba9164c275fc91d4" translate="yes" xml:space="preserve">
          <source>A quasi-quotation can appear in a pattern, type, expression, or declaration context and is also written in Oxford brackets:</source>
          <target state="translated">准引号可以出现在模式、类型、表达式或声明上下文中,也可以用牛津括号书写。</target>
        </trans-unit>
        <trans-unit id="9598087296773252828f5341b4828654c30bd8a1" translate="yes" xml:space="preserve">
          <source>A quasi-quote has the form &lt;code&gt;[quoter| string |]&lt;/code&gt;.</source>
          <target state="translated">准引用的形式为 &lt;code&gt;[quoter| string |]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1cb587055071e4fb0d1b0454a870959e6f9fa49" translate="yes" xml:space="preserve">
          <source>A quasi-quote is expanded by applying the appropriate parser to the string enclosed by the Oxford brackets. The context of the quasi-quote (expression, pattern, type, declaration) determines which of the parsers is called.</source>
          <target state="translated">准引号是通过对牛津括号中的字符串应用适当的解析器来扩展的。准引号的上下文(表达式、模式、类型、声明)决定调用哪个解析器。</target>
        </trans-unit>
        <trans-unit id="cdcde5d2df86936b559e312ff74aff26f8e4d03f" translate="yes" xml:space="preserve">
          <source>A quasiquote may appear in place of</source>
          <target state="translated">可以用准引号来代替</target>
        </trans-unit>
        <trans-unit id="a001d4fd181336f68b683e872533d57d619d5b7e" translate="yes" xml:space="preserve">
          <source>A question that we often want to ask when debugging a program is &amp;ldquo;how did I get here?&amp;rdquo;. Traditional imperative debuggers usually provide some kind of stack-tracing feature that lets you see the stack of active function calls (sometimes called the &amp;ldquo;lexical call stack&amp;rdquo;), describing a path through the code to the current location. Unfortunately this is hard to provide in Haskell, because execution proceeds on a demand-driven basis, rather than a depth-first basis as in strict languages. The &amp;ldquo;stack&amp;ldquo; in GHC&amp;rsquo;s execution engine bears little resemblance to the lexical call stack. Ideally GHCi would maintain a separate lexical call stack in addition to the dynamic call stack, and in fact this is exactly what our profiling system does (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;), and what some other Haskell debuggers do. For the time being, however, GHCi doesn&amp;rsquo;t maintain a lexical call stack (there are some technical challenges to be overcome). Instead, we provide a way to backtrack from a breakpoint to previous evaluation steps: essentially this is like single-stepping backwards, and should in many cases provide enough information to answer the &amp;ldquo;how did I get here?&amp;rdquo; question.</source>
          <target state="translated">我们在调试程序时经常要问的一个问题是&amp;ldquo;我是怎么到这里来的？&amp;rdquo;。传统的命令式调试器通常提供某种堆栈跟踪功能，使您可以看到活动函数调用的堆栈（有时称为&amp;ldquo;词法调用堆栈&amp;rdquo;），它描述了从代码到当前位置的路径。不幸的是，这在Haskell中很难提供，因为执行是在需求驱动的基础上进行的，而不是像严格的语言那样以深度优先为基础。 GHC执行引擎中的&amp;ldquo;堆栈&amp;rdquo;与词汇调用堆栈几乎没有相似之处。理想情况下，GHCi除了动态调用堆栈外，还应维护一个单独的词法调用堆栈，实际上，这正是我们的性能分析系统所做的工作（性能&lt;a href=&quot;profiling#profiling&quot;&gt;分析&lt;/a&gt;），以及其他一些Haskell调试器的工作。但是，目前，GHCi并不维护词汇调用堆栈（有一些技术难题需要克服）。相反，我们提供了一种从断点回溯到先前评估步骤的方法：本质上，这就像单步后退，并且在许多情况下，应该提供足够的信息来回答&amp;ldquo;我如何到达这里？&amp;rdquo; 题。</target>
        </trans-unit>
        <trans-unit id="ad0242b7d03d75d9ad4b17787a60e3e615d37d16" translate="yes" xml:space="preserve">
          <source>A quoter is a value of type &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt;, which is defined thus:</source>
          <target state="translated">引号是 &lt;code&gt;Language.Haskell.TH.Quote.QuasiQuoter&lt;/code&gt; 类型的值，其定义如下：</target>
        </trans-unit>
        <trans-unit id="a48ce4817f3e54a0532248a31d1f099d88b1351f" translate="yes" xml:space="preserve">
          <source>A range of bytes in a buffer represented by the pointer to the first byte of the range and the pointer to the first byte &lt;em&gt;after&lt;/em&gt; the range.</source>
          <target state="translated">缓冲区中的字节范围，由指向该范围的第一个字节的指针和指向该范围&lt;em&gt;之后&lt;/em&gt;的第一个字节的指针表示。</target>
        </trans-unit>
        <trans-unit id="b28c56da049e38013f1fcf4d02dcb6b1f0080a5c" translate="yes" xml:space="preserve">
          <source>A record GADT may have a restricted type for a selector function, which may lead to additional unification when solving &lt;code&gt;HasField&lt;/code&gt; constraints. For example,</source>
          <target state="translated">记录GADT对于选择器函数可能具有受限类型，这在解决 &lt;code&gt;HasField&lt;/code&gt; 约束时可能导致附加的统一。例如，</target>
        </trans-unit>
        <trans-unit id="b338877827c7ed29adfee9e9d6b0b8e5a63641d8" translate="yes" xml:space="preserve">
          <source>A record selector was applied to a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record selector.</source>
          <target state="translated">记录选择器应用于没有适当字段的构造函数。只有具有多个构造函数的数据类型才会发生这种情况，其中某些字段位于一个构造函数中，而其他字段不在另一个构造函数中。该 &lt;code&gt;String&lt;/code&gt; 提供有关记录选择的源位置信息。</target>
        </trans-unit>
        <trans-unit id="c21fec8a784a0df6d796742b5beccbbdfb0d37ed" translate="yes" xml:space="preserve">
          <source>A record update was performed on a constructor without the appropriate field. This can only happen with a datatype with multiple constructors, where some fields are in one constructor but not another. The &lt;code&gt;String&lt;/code&gt; gives information about the source location of the record update.</source>
          <target state="translated">在没有适当字段的构造函数上执行了记录更新。只有具有多个构造函数的数据类型才会发生这种情况，其中某些字段位于一个构造函数中，而其他字段不在另一个构造函数中。该 &lt;code&gt;String&lt;/code&gt; 给出了关于记录更新的源位置信息。</target>
        </trans-unit>
        <trans-unit id="92fb5684ae95209348bfee7f9aea2ce376b9a4d4" translate="yes" xml:space="preserve">
          <source>A redundant constraint within the type signature itself:</source>
          <target state="translated">类型签名本身的一个多余的约束。</target>
        </trans-unit>
        <trans-unit id="54a410c09496ec54abde3e9710dcb3fcce5da06f" translate="yes" xml:space="preserve">
          <source>A reference to a remote value. These are allocated and freed explicitly.</source>
          <target state="translated">对一个远程值的引用。这些值是显式分配和释放的。</target>
        </trans-unit>
        <trans-unit id="fb2a2acd6cd218a5be6c4d95fa1ad4daf16624a7" translate="yes" xml:space="preserve">
          <source>A reference to a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">对类型 &lt;code&gt;a&lt;/code&gt; 的值的引用。</target>
        </trans-unit>
        <trans-unit id="0361e89442d5407a746896c1f1424c0385608b9b" translate="yes" xml:space="preserve">
          <source>A rendering style. Allows us to specify constraints to choose among the many different rendering options.</source>
          <target state="translated">一种渲染风格。允许我们指定约束条件,在许多不同的渲染选项中进行选择。</target>
        </trans-unit>
        <trans-unit id="9a7715c19cf7faa5dc45883c88b4e480b883a9aa" translate="yes" xml:space="preserve">
          <source>A retainer is either the system stack, an unevaluated closure (thunk), or an explicitly mutable object.</source>
          <target state="translated">保留器是系统栈、未评估的闭包(thunk)或显式可突变对象。</target>
        </trans-unit>
        <trans-unit id="c17ab32a3bf231aeb0c4cd50ac9f91c26d98d0f8" translate="yes" xml:space="preserve">
          <source>A rewrite rule in a module &lt;code&gt;M&lt;/code&gt; is an &lt;em&gt;orphan rule&lt;/em&gt; orphan rule if none of the variables, type constructors, or classes that are free in the left hand side of the rule are declared in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">在模块A重写规则 &lt;code&gt;M&lt;/code&gt; 为&lt;em&gt;孤儿规则&lt;/em&gt;孤儿规则如果没有一个变量，类型构造，或者，在规则的左手侧是自由的类中被声明 &lt;code&gt;M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7576507e849494c245f578b7b08c722c72b9e4b" translate="yes" xml:space="preserve">
          <source>A rich user interface for line input in command-line programs. Haskeline is Unicode-aware and runs both on POSIX-compatible systems and on Windows.</source>
          <target state="translated">一个丰富的用户界面,用于命令行程序中的行输入。Haskeline具有Unicode意识,可以在POSIX兼容系统和Windows上运行。</target>
        </trans-unit>
        <trans-unit id="5fe62b863adf6df34977b49f0095efaac4aba5e7" translate="yes" xml:space="preserve">
          <source>A right fold over the elements</source>
          <target state="translated">元素上的右折</target>
        </trans-unit>
        <trans-unit id="468cdfbdf06effe43a3aa0fc4e881403e078094b" translate="yes" xml:space="preserve">
          <source>A right fold over the elements with no starting value</source>
          <target state="translated">在没有起始值的元素上进行右折。</target>
        </trans-unit>
        <trans-unit id="1bd8cdef3742749b47082f965a23008abf9bc15b" translate="yes" xml:space="preserve">
          <source>A rule does not need to be in the same module as (any of) the variables it mentions, though of course they need to be in scope.</source>
          <target state="translated">一个规则不需要和它提到的(任何)变量在同一个模块中,当然它们需要在范围内。</target>
        </trans-unit>
        <trans-unit id="4dda8ffe8bacae7a3d13b78da8fc37161b54e971" translate="yes" xml:space="preserve">
          <source>A rule may optionally have a phase-control number (see &lt;a href=&quot;#phase-control&quot;&gt;Phase control&lt;/a&gt;), immediately after the name of the rule. Thus:</source>
          <target state="translated">规则可以在规则名称后紧随其后具有一个相控编号（请参阅&amp;ldquo; &lt;a href=&quot;#phase-control&quot;&gt;相控&amp;rdquo;&lt;/a&gt;）。从而：</target>
        </trans-unit>
        <trans-unit id="ba8873804ea20a68777a6a79acc2a5e0d1a22d48" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with a mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">在返回不可变数组以供以后细读之前，创建和使用可变数组的安全方法。此函数避免在返回之前复制数组- 内部使用 &lt;code&gt;unsafeFreeze&lt;/code&gt; ，但是此包装器是该函数的安全接口。</target>
        </trans-unit>
        <trans-unit id="8ed6207609d767c14b5aa06f9aa68c12587a18b1" translate="yes" xml:space="preserve">
          <source>A safe way to create and work with an unboxed mutable array before returning an immutable array for later perusal. This function avoids copying the array before returning it - it uses &lt;code&gt;unsafeFreeze&lt;/code&gt; internally, but this wrapper is a safe interface to that function.</source>
          <target state="translated">在返回不可变数组以供以后细读之前，创建和使用未装箱的可变数组的安全方法。此函数避免在返回之前复制数组- 内部使用 &lt;code&gt;unsafeFreeze&lt;/code&gt; ，但是此包装器是该函数的安全接口。</target>
        </trans-unit>
        <trans-unit id="b9df3dc079f00f9a8e0de830c01848206acb9ca5" translate="yes" xml:space="preserve">
          <source>A sample (consisting of a list of break-down classes, e.g. cost centres, and heap residency sizes), is to be encoded in the body of one or more events.</source>
          <target state="translated">在一个或多个事件的主体中,要对一个样本(由分解类的列表组成,如成本中心和堆的驻留规模)进行编码。</target>
        </trans-unit>
        <trans-unit id="75c24f2265f3d8c4ccd393f15ae237ff3f6f2a33" translate="yes" xml:space="preserve">
          <source>A scoped type variable stands for a type &lt;em&gt;variable&lt;/em&gt;, and not for a &lt;em&gt;type&lt;/em&gt;. (This is a change from GHC&amp;rsquo;s earlier design.)</source>
          <target state="translated">作用域类型变量代表类型&lt;em&gt;变量&lt;/em&gt;，而不是&lt;em&gt;类型&lt;/em&gt;。（这是对GHC早期设计的更改。）</target>
        </trans-unit>
        <trans-unit id="f9e8504d9f7ca56788ad83a6712e3deabb56b1fb" translate="yes" xml:space="preserve">
          <source>A sequence of actions produces a value only if all the actions in the sequence do. If one exits, the rest of the sequence is skipped and the composite action exits.</source>
          <target state="translated">一个动作序列只有在序列中的所有动作都这样做时才会产生一个值。如果有一个动作退出,则序列中的其余动作被跳过,复合动作退出。</target>
        </trans-unit>
        <trans-unit id="627ab33bc11dc284fde08d4bb2c60e4ca6633e05" translate="yes" xml:space="preserve">
          <source>A sequence of actions succeeds, producing a value, only if all the actions in the sequence are successful. If one fails with an error, the rest of the sequence is skipped and the composite action fails with that error.</source>
          <target state="translated">只有当序列中的所有动作都成功时,一个动作序列才会成功,产生一个值。如果有一个动作出错而失败,则跳过序列中的其他动作,综合动作因该错误而失败。</target>
        </trans-unit>
        <trans-unit id="2df1f1dd397310b516738a6b735261200af88e24" translate="yes" xml:space="preserve">
          <source>A sequence of actions terminates normally, producing a value, only if none of the actions in the sequence throws an exception. If one throws an exception, the rest of the sequence is skipped and the composite action exits with that exception.</source>
          <target state="translated">只有当序列中没有任何一个动作引发异常时,动作序列才会正常终止,产生一个值。如果有一个动作发生异常,序列的其余部分就会被跳过,综合动作也会随着异常退出。</target>
        </trans-unit>
        <trans-unit id="86877c5118e45e245e3a082f5d36380aaa868a97" translate="yes" xml:space="preserve">
          <source>A sequence of non-space characters, or a sequence of arbitrary characters surrounded by quotes &lt;code&gt;&quot;....&quot;&lt;/code&gt;.</source>
          <target state="translated">一个非空格字符序列，或由引号 &lt;code&gt;&quot;....&quot;&lt;/code&gt; 包围的任意字符序列。</target>
        </trans-unit>
        <trans-unit id="76595a701ee44ea1c9f930a9c60dd85fa6bdaa4c" translate="yes" xml:space="preserve">
          <source>A sequence of strings, separated by commas. The sequence may be empty.</source>
          <target state="translated">由逗号分隔的字符串序列。该序列可以是空的。</target>
        </trans-unit>
        <trans-unit id="94dd7b6a2c0e4fe592c072a99a09ce1205c850da" translate="yes" xml:space="preserve">
          <source>A sequential garbage collection has been requested by a capability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9195a974dd24c0ef39d75bed4d1efb9a1d3015e" translate="yes" xml:space="preserve">
          <source>A set of integers.</source>
          <target state="translated">一组整数。</target>
        </trans-unit>
        <trans-unit id="bb204bd8db13fe7816a94a82e9d47e0712050306" translate="yes" xml:space="preserve">
          <source>A set of signals reserved for use by the implementation. In GHC, this will normally include either &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">保留供实现使用的一组信号。在GHC中，这通常包括 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigVTALRM&quot;&gt;sigVTALRM&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-posix-signals#v:sigALRM&quot;&gt;sigALRM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a966b0c2cbc724a4e1636286c1f35ede7a08d8c" translate="yes" xml:space="preserve">
          <source>A set of values &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">一组值 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a84ea57aa89435041641005d90f97cd8afe4994e" translate="yes" xml:space="preserve">
          <source>A setEnv implementation that allows blank environment variables. Mimics the &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; module from the &lt;code&gt;unix&lt;/code&gt; package, but with support for Windows too.</source>
          <target state="translated">setEnv实现，允许空白环境变量。模拟 &lt;code&gt;unix&lt;/code&gt; 包中的 &lt;code&gt;&lt;a href=&quot;system-posix#v:Env&quot;&gt;Env&lt;/a&gt;&lt;/code&gt; 模块，但也支持Windows。</target>
        </trans-unit>
        <trans-unit id="f4ca239f09f9ab5cacd4dc55290c45509ce3c667" translate="yes" xml:space="preserve">
          <source>A shared mutable variable (&lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;MutVar#&lt;/code&gt;!). (Note: in a non-concurrent implementation, &lt;code&gt;(MVar# a)&lt;/code&gt; can be represented by &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt;.)</source>
          <target state="translated">共享可变变量（&lt;em&gt;不&lt;/em&gt;一样的一个 &lt;code&gt;MutVar#&lt;/code&gt; ！）。（注意：在非并行实现中， &lt;code&gt;(MVar# a)&lt;/code&gt; 可以由 &lt;code&gt;(MutVar# (Maybe a))&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a82158df9a5688ce51d763088d1b6426e23f9a62" translate="yes" xml:space="preserve">
          <source>A shortcut for multiple definitions which use &lt;code&gt;#const&lt;/code&gt;. Each &lt;code&gt;value&lt;/code&gt; is a name of a C integer constant, e.g. enumeration value. The name will be translated to Haskell by making each letter following an underscore uppercase, making all the rest lowercase, and removing underscores. You can supply a different translation by writing &lt;code&gt;hs_name = c_value&lt;/code&gt; instead of a &lt;code&gt;value&lt;/code&gt;, in which case &lt;code&gt;c_value&lt;/code&gt; may be an arbitrary expression. The &lt;code&gt;hs_name&lt;/code&gt; will be defined as having the specified &lt;code&gt;type&lt;/code&gt;. Its definition is the specified &lt;code&gt;constructor&lt;/code&gt; (which in fact may be an expression or be empty) applied to the appropriate integer value. You can have multiple &lt;code&gt;#enum&lt;/code&gt; definitions with the same &lt;code&gt;type&lt;/code&gt;; this construct does not emit the type definition itself.</source>
          <target state="translated">使用 &lt;code&gt;#const&lt;/code&gt; 的多个定义的快捷方式。每个 &lt;code&gt;value&lt;/code&gt; 都是C整数常量的名称，例如枚举值。通过将每个字母后跟一个下划线大写，将所有其余字母都变成小写，并删除下划线，将名称翻译为Haskell。您可以通过编写 &lt;code&gt;hs_name = c_value&lt;/code&gt; 而不是 &lt;code&gt;value&lt;/code&gt; 来提供不同的转换，在这种情况下， &lt;code&gt;c_value&lt;/code&gt; 可以是任意表达式。的 &lt;code&gt;hs_name&lt;/code&gt; 将被定义为具有特定 &lt;code&gt;type&lt;/code&gt; 。它的定义是应用于适当整数值的指定 &lt;code&gt;constructor&lt;/code&gt; （实际上可能是表达式或为空）。你可以有多个 &lt;code&gt;#enum&lt;/code&gt; 定义具有相同的 &lt;code&gt;type&lt;/code&gt; ；该构造本身不会发出类型定义。</target>
        </trans-unit>
        <trans-unit id="00e25301890375feab76786821b7d4508efb82ce" translate="yes" xml:space="preserve">
          <source>A signature file is denoted by an &lt;code&gt;hsig&lt;/code&gt; file; every required signature must have an &lt;code&gt;hsig&lt;/code&gt; file (even if it is an empty one), including required signatures inherited from dependencies. Signatures can be imported using an ordinary &lt;code&gt;import Sig&lt;/code&gt; declaration.</source>
          <target state="translated">签名文件由 &lt;code&gt;hsig&lt;/code&gt; 文件表示；每个必需的签名都必须有一个 &lt;code&gt;hsig&lt;/code&gt; 文件（即使它是一个空文件），包括从依赖项继承的必需的签名。可以使用普通的 &lt;code&gt;import Sig&lt;/code&gt; 声明来导入签名。</target>
        </trans-unit>
        <trans-unit id="92355b0e296eb8f9e53318fcbdb4d680dbc31d1d" translate="yes" xml:space="preserve">
          <source>A signed integral type that can be losslessly converted to and from &lt;code&gt;Ptr&lt;/code&gt;. This type is also compatible with the C99 type &lt;code&gt;intptr_t&lt;/code&gt;, and can be marshalled to and from that type safely.</source>
          <target state="translated">可以无损地与 &lt;code&gt;Ptr&lt;/code&gt; 相互转换的有符号整数类型。此类型也与C99类型 &lt;code&gt;intptr_t&lt;/code&gt; 兼容，并且可以安全地与该类型进出编组。</target>
        </trans-unit>
        <trans-unit id="948520b277e60dcee21361dd65adb915f2606d36" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 类的 &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 实例中的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 可以实现数组值的类似转换。</target>
        </trans-unit>
        <trans-unit id="99bde5053270918eb2f3d7c1e964f644e4ce138b" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;data-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbe5e3287fe101eaac49bce2bfcb028d8f2b308" translate="yes" xml:space="preserve">
          <source>A similar transformation of array values may be achieved using &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; instance of the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 类的 &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 实例中的 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 可以实现数组值的类似转换。</target>
        </trans-unit>
        <trans-unit id="f6c85786bd39c1497a36a8cbe06706b97c38a416" translate="yes" xml:space="preserve">
          <source>A simple choice for the type associated with flags is to define a type &lt;code&gt;Flag&lt;/code&gt; as an algebraic type representing the possible flags and their arguments:</source>
          <target state="translated">与标记关联的类型的一个简单选择是将类型 &lt;code&gt;Flag&lt;/code&gt; 定义为表示可能的标记及其参数的代数类型：</target>
        </trans-unit>
        <trans-unit id="385ee26bb3c563691e99d165abb3ca38a355c178" translate="yes" xml:space="preserve">
          <source>A simple day and time aggregate, where the day is of the specified parameter, and the time is a TimeOfDay. Conversion of this (as local civil time) to UTC depends on the time zone. Conversion of this (as local mean time) to UT1 depends on the longitude.</source>
          <target state="translated">一个简单的日期和时间集合,其中日期是指定参数,时间是TimeOfDay。将其(作为当地的民用时间)转换为UTC取决于时区。将其(作为当地平均时间)转换为UT1取决于经度。</target>
        </trans-unit>
        <trans-unit id="5071edc607af851a249c97dfb4d0c57e03432a4d" translate="yes" xml:space="preserve">
          <source>A simple example of the new notation is the expression</source>
          <target state="translated">新符号的一个简单例子是这样的表达式</target>
        </trans-unit>
        <trans-unit id="32cefd4bea4e7110a3dca7239bc47887ca83ce67" translate="yes" xml:space="preserve">
          <source>A simple pairing heap.</source>
          <target state="translated">一个简单的配对堆。</target>
        </trans-unit>
        <trans-unit id="8ad0b83378258a314fc0adf90a8e10c9bc3f1588" translate="yes" xml:space="preserve">
          <source>A simple use of unfoldr:</source>
          <target state="translated">一个简单的使用unfoldr。</target>
        </trans-unit>
        <trans-unit id="a1f654f7060b7d2d650700b6c757eab119833574" translate="yes" xml:space="preserve">
          <source>A simpler version of this function is:</source>
          <target state="translated">这个函数的一个更简单的版本是:</target>
        </trans-unit>
        <trans-unit id="109ec8484c225e4b238b8dbafe102ddb90cbe663" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;deriving&lt;/code&gt; clause at the end of a datatype.</source>
          <target state="translated">数据类型末尾的单个 &lt;code&gt;deriving&lt;/code&gt; 子句。</target>
        </trans-unit>
        <trans-unit id="07552ccc8f83d8da8c2ff1373fe5871fc375aea0" translate="yes" xml:space="preserve">
          <source>A single Char fragment</source>
          <target state="translated">一个单一的查尔片段</target>
        </trans-unit>
        <trans-unit id="c8a470d3f21b5f8bd88b72ca5e212009e6a9ba92" translate="yes" xml:space="preserve">
          <source>A single data constructor.</source>
          <target state="translated">一个单一的数据构造函数。</target>
        </trans-unit>
        <trans-unit id="8b90ffe9d4585beccabc5b42a63afc7e90a28d58" translate="yes" xml:space="preserve">
          <source>A single fixed-width event emitted during program start-up describing the samples that follow.</source>
          <target state="translated">在程序启动时发出的一个固定宽度的事件,描述接下来的样本。</target>
        </trans-unit>
        <trans-unit id="dce34a123f3c9357183ae1491a545fbaf2ea2561" translate="yes" xml:space="preserve">
          <source>A single location in the source code.</source>
          <target state="translated">源代码中的一个单一位置。</target>
        </trans-unit>
        <trans-unit id="50f411ba135dec27d6a3801b72dc1838706dca5a" translate="yes" xml:space="preserve">
          <source>A single vertex that is not in any cycle.</source>
          <target state="translated">一个不在任何循环中的单一顶点。</target>
        </trans-unit>
        <trans-unit id="97bd9aab1d447685b69723475ad0a956cc38e08e" translate="yes" xml:space="preserve">
          <source>A sink of event-log data.</source>
          <target state="translated">事件日志数据的汇。</target>
        </trans-unit>
        <trans-unit id="80976804b592e9e2e94c0bbcedb3e158f3a504b2" translate="yes" xml:space="preserve">
          <source>A size in UTF-16 code units.</source>
          <target state="translated">以UTF-16编码为单位的尺寸。</target>
        </trans-unit>
        <trans-unit id="909e2a440c7053acbcd40d2af23d2760c9d12442" translate="yes" xml:space="preserve">
          <source>A skip channel is a pair of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s. The first &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; contains the current value, and a list of semaphores that need to be notified when it changes. The second &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; is a semaphore for this particular reader: it is full if there is a value in the channel that this reader has not read yet, and empty otherwise.</source>
          <target state="translated">跳过频道是一对 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 。第一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 包含当前值，以及在更改时需要通知的信号量列表。第二个 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 是此特定读取器的信号灯：如果该读取器尚未读取的通道中的值，则该MVar已满，否则为空。</target>
        </trans-unit>
        <trans-unit id="75b2421aa3377ed4749c4916a0cb0dcfc04c0013" translate="yes" xml:space="preserve">
          <source>A slight variation on &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; that allows a value to be returned (&lt;code&gt;b&lt;/code&gt;) in addition to the modified value of the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; 的细微变化，除了 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的修改值之外，还允许返回值（ &lt;code&gt;b&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f69c10ed60508f59cb5a529f1b359642cbe6b858" translate="yes" xml:space="preserve">
          <source>A slightly faster version of &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; that may not be safe to use with multiple threads. The unsafety arises when used like this:</source>
          <target state="translated">较快的 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 版本，可能无法与多个线程一起安全使用。像这样使用时会出现不安全：</target>
        </trans-unit>
        <trans-unit id="1a46cd68f2f2846ae726246b12281b2435629226" translate="yes" xml:space="preserve">
          <source>A small example:</source>
          <target state="translated">一个小例子。</target>
        </trans-unit>
        <trans-unit id="f3fa3447a8afd4949b9c12f9f8e9147cd390aae9" translate="yes" xml:space="preserve">
          <source>A small word of warning: &lt;a href=&quot;#ghc-flag--cpp&quot;&gt;&lt;code&gt;-cpp&lt;/code&gt;&lt;/a&gt; is not friendly to &amp;ldquo;string gaps&amp;rdquo;. In other words, strings such as the following:</source>
          <target state="translated">一个小小的警告：&lt;a href=&quot;#ghc-flag--cpp&quot;&gt; &lt;code&gt;-cpp&lt;/code&gt; &lt;/a&gt;对&amp;ldquo;字符串间隔&amp;rdquo;不友好。换句话说，字符串如下：</target>
        </trans-unit>
        <trans-unit id="b896df9db0191f80e6db640a0983ae75b9330707" translate="yes" xml:space="preserve">
          <source>A space character</source>
          <target state="translated">一个空格字符</target>
        </trans-unit>
        <trans-unit id="2cf7bf5a17da5fc043fc8f14a663aecfa5439dbc" translate="yes" xml:space="preserve">
          <source>A space efficient, packed, unboxed Unicode text type.</source>
          <target state="translated">一个空间效率高的、打包的、未装箱的Unicode文本类型。</target>
        </trans-unit>
        <trans-unit id="b320aab997efd2d7ca1e00ac225c124b5d920ec5" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 向量的节省空间的表示形式，支持许多有效的操作。</target>
        </trans-unit>
        <trans-unit id="edd5ed41a7ad61d8ccb7e1f320dd68310fe46295" translate="yes" xml:space="preserve">
          <source>A space-efficient representation of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; vector, supporting many efficient operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c30bb293046f1353d1b4c1fb7e4c15767c64f" translate="yes" xml:space="preserve">
          <source>A spanning forest of the graph, obtained from a depth-first search of the graph starting from each vertex in an unspecified order.</source>
          <target state="translated">图的跨度林,从图的每个顶点开始按未指定的顺序进行深度优先搜索得到。</target>
        </trans-unit>
        <trans-unit id="4794ea6b46c0b3e368866c3f6657148757943020" translate="yes" xml:space="preserve">
          <source>A spanning forest of the part of the graph reachable from the listed vertices, obtained from a depth-first search of the graph starting at each of the listed vertices in order.</source>
          <target state="translated">从列出的顶点开始对图进行深度优先搜索得到的图的可到达部分的跨度森林。</target>
        </trans-unit>
        <trans-unit id="17409cdf1a726a6b210a04d4446854b3d6bf4233" translate="yes" xml:space="preserve">
          <source>A spark has been GC&amp;rsquo;d before being evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7a9f3b3b4de7ca05232bf75a6a63a5d4979fe6" translate="yes" xml:space="preserve">
          <source>A spark has been added to the spark pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ef42be18896ca33cf39edd26afbfce8fc5c5ae" translate="yes" xml:space="preserve">
          <source>A spark has been stolen from another capability for evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000576d9dd7d866ebbbaf02ec2da581917b4c07a" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种特殊情况。预计编译器将识别出此错误并插入错误消息，这些消息更适合于出现 &lt;code&gt;&lt;a href=&quot;ghc-err#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 的上下文。</target>
        </trans-unit>
        <trans-unit id="73c8066b78af5a513799e5e6e43841a928951845" translate="yes" xml:space="preserve">
          <source>A special case of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; appears.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种特殊情况。预计编译器将识别出此错误并插入错误消息，这些消息更适合于出现 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt;&lt;/code&gt; 的上下文。</target>
        </trans-unit>
        <trans-unit id="b61fe333d2ebb606e68ef9534fb8ee51a3dcbe6f" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的特殊变体，仅需计算即可随后运行。</target>
        </trans-unit>
        <trans-unit id="d381bfcecd222a40938da33628701d9caa7e0fc9" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 的特殊变体，使用优先级上下文零，并返回普通的 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3551127e07d1074127cf665da3dc3de8f74d78ac" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 的特殊变体，使用优先级上下文零，并返回普通的 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f3343104c8933573bbaff2361f546628d45e8d8" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; with just a computation to run afterward.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的特殊变体，仅需计算即可随后运行。</target>
        </trans-unit>
        <trans-unit id="addf8bf904a9b53d42ba0004dc6e0c96e5f166b4" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt;, using precedence context zero, and returning an ordinary &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; 的特殊变体，使用优先级上下文零，并返回普通的 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a0c5e6176b1b7f34e452cb42488bc078090478d" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; where the value is actually a pair of the key and value passed to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 的专用版本，其中的值实际上是传递给 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPair&quot;&gt;mkWeakPair&lt;/a&gt;&lt;/code&gt; 的一对键和值：</target>
        </trans-unit>
        <trans-unit id="ed256b1475f3db11a1e053e7393f2e62ac0741a5" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt;, where the key and the value are the same object:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeak&quot;&gt;mkWeak&lt;/a&gt;&lt;/code&gt; 的专用版本，其中键和值是同一对象：</target>
        </trans-unit>
        <trans-unit id="88cbeb4d1e4332278f7efaec95990a7cd06ab5a6" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt;, where the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object returned is simply thrown away (however the finalizer will be remembered by the garbage collector, and will still be run when the key becomes unreachable).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-mem-weak#v:mkWeakPtr&quot;&gt;mkWeakPtr&lt;/a&gt;&lt;/code&gt; 的专门版本，将简单地丢弃返回的 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 对象（但是终结器将被垃圾收集器记住，并且在密钥变得不可访问时仍将运行）。</target>
        </trans-unit>
        <trans-unit id="c000f76b0d515b8c303304c303dc38592d07556a" translate="yes" xml:space="preserve">
          <source>A splice can occur in place of</source>
          <target state="translated">拼接可以发生在</target>
        </trans-unit>
        <trans-unit id="cd4cb3a4aa37b46f04784c0f6f0060998bc7f64a" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;ldquo;&amp;hellip;&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;ldquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc7d08e30e7130abc877e7e166eb7f0bb2f0e91" translate="yes" xml:space="preserve">
          <source>A splice is written &lt;code&gt;$x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is an identifier, or &lt;code&gt;$(...)&lt;/code&gt;, where the &amp;rdquo;...&amp;rdquo; is an arbitrary expression. There must be no space between the &amp;ldquo;$&amp;rdquo; and the identifier or parenthesis. This use of &amp;ldquo;$&amp;rdquo; overrides its meaning as an infix operator, just as &amp;ldquo;M.x&amp;rdquo; overrides the meaning of &amp;rdquo;.&amp;rdquo; as an infix operator. If you want the infix operator, put spaces around it.</source>
          <target state="translated">接头写 &lt;code&gt;$x&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是标识符，或 &lt;code&gt;$(...)&lt;/code&gt; ，其中&amp;ldquo; ...&amp;rdquo;是任意表达式。&amp;ldquo; $&amp;rdquo;和标识符或括号之间不能有空格。&amp;ldquo; $&amp;rdquo;的使用会覆盖其作为中缀运算符的含义，就像&amp;ldquo; Mx&amp;rdquo;会覆盖&amp;ldquo;&amp;rdquo;的含义一样。&amp;rdquo; 作为中缀运算符。如果要使用infix运算符，请在其周围放置空格。</target>
        </trans-unit>
        <trans-unit id="029020ae6b32756dd16466eb423a1a26ab4457d6" translate="yes" xml:space="preserve">
          <source>A state monad parameterized by the type &lt;code&gt;s&lt;/code&gt; of the state to carry.</source>
          <target state="translated">由要携带的状态类型 &lt;code&gt;s&lt;/code&gt; 参数化的状态monad 。</target>
        </trans-unit>
        <trans-unit id="dc96818c8486fd2f0989d60f3799e6dcb782b7f0" translate="yes" xml:space="preserve">
          <source>A state transformer monad parameterized by:</source>
          <target state="translated">状态变换器单项参数化:</target>
        </trans-unit>
        <trans-unit id="584d223e5ba9554539274f317131b078dc9f657c" translate="yes" xml:space="preserve">
          <source>A static form determines a value of type &lt;code&gt;StaticPtr t&lt;/code&gt;, but just like &lt;code&gt;OverloadedLists&lt;/code&gt; and &lt;code&gt;OverloadedStrings&lt;/code&gt;, this literal expression is overloaded to allow lifting a &lt;code&gt;StaticPtr&lt;/code&gt; into another type implicitly, via the &lt;code&gt;IsStatic&lt;/code&gt; class:</source>
          <target state="translated">静态形式确定的类型的值 &lt;code&gt;StaticPtr t&lt;/code&gt; ，但就像 &lt;code&gt;OverloadedLists&lt;/code&gt; 和 &lt;code&gt;OverloadedStrings&lt;/code&gt; ，该文字表达被重载以允许起重 &lt;code&gt;StaticPtr&lt;/code&gt; 成另一种类型隐含地，通过所述 &lt;code&gt;IsStatic&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="29153c897e531a67acff58cc6b01500af3000f33" translate="yes" xml:space="preserve">
          <source>A storable array is an IO-mutable array which stores its contents in a contiguous memory block living in the C heap. Elements are stored according to the class &lt;code&gt;Storable&lt;/code&gt;. You can obtain the pointer to the array contents to manipulate elements from languages like C.</source>
          <target state="translated">可存储数组是一个IO可变数组，它将其内容存储在C堆中的连续内存块中。元素根据 &lt;code&gt;Storable&lt;/code&gt; 类存储。您可以获取指向数组内容的指针，以操纵来自诸如C之类的语言的元素。</target>
        </trans-unit>
        <trans-unit id="4f5037287f3893bff45330861345a86eebed76c2" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 中构造的块流。</target>
        </trans-unit>
        <trans-unit id="43919f0b621bd7f60ea00562492dbc3adfa8a6aa" translate="yes" xml:space="preserve">
          <source>A stream of chunks that are constructed in the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b113394401941b6890516fb8e3af8a462d1fd40" translate="yes" xml:space="preserve">
          <source>A stream oriented decoding result.</source>
          <target state="translated">面向流的解码结果。</target>
        </trans-unit>
        <trans-unit id="d911f61b4fa0d9284a8e1a6f69a0f61b1e73b5e6" translate="yes" xml:space="preserve">
          <source>A strict left fold over the elements</source>
          <target state="translated">严格的左折元素</target>
        </trans-unit>
        <trans-unit id="98cd4454f56f48afeffc70d90f58b5920ca58301" translate="yes" xml:space="preserve">
          <source>A strict pair</source>
          <target state="translated">严格的对</target>
        </trans-unit>
        <trans-unit id="6eccc911da51c833236284b3d32b3123513710ad" translate="yes" xml:space="preserve">
          <source>A strict pattern match in a bind statement prevents &lt;code&gt;ApplicativeDo&lt;/code&gt; from transforming that statement to use &lt;code&gt;Applicative&lt;/code&gt;. This is because the transformation would change the semantics by making the expression lazier.</source>
          <target state="translated">bind语句中的严格模式匹配可防止 &lt;code&gt;ApplicativeDo&lt;/code&gt; 将该语句转换为使用 &lt;code&gt;Applicative&lt;/code&gt; 。这是因为转换将使表达式变得更懒惰，从而改变了语义。</target>
        </trans-unit>
        <trans-unit id="0814095da0f374f363b2744acbf7641a2610efcb" translate="yes" xml:space="preserve">
          <source>A strict right fold over the elements</source>
          <target state="translated">严格的右折元素</target>
        </trans-unit>
        <trans-unit id="0ec086694cd0bcf9cc7eaaf131dce1a8c3f470d3" translate="yes" xml:space="preserve">
          <source>A strict variant of foldr1</source>
          <target state="translated">foldr1的严格变体</target>
        </trans-unit>
        <trans-unit id="37c2878fde673453465a3e32200c82b9e97c2b4d" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 的严格版本</target>
        </trans-unit>
        <trans-unit id="00787a530c1e072ddb6f8e17b643611bd5348b98" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。</target>
        </trans-unit>
        <trans-unit id="00a8b3473a1ebcbcb0938b14d80dd5227345445f" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-list#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 的严格版本</target>
        </trans-unit>
        <trans-unit id="5320390dc6f10cc24227a72c79ba582ebcc655a1" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的严格版本。</target>
        </trans-unit>
        <trans-unit id="493154631c22520a575e67380475a32d6bd2b085" translate="yes" xml:space="preserve">
          <source>A strict version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl1&quot;&gt;foldl1&lt;/a&gt;&lt;/code&gt; 的严格版本</target>
        </trans-unit>
        <trans-unit id="fb8a26929f2fded3b180d5708141aba0e7729a4d" translate="yes" xml:space="preserve">
          <source>A strict version of foldl.</source>
          <target state="translated">严格版的foldl。</target>
        </trans-unit>
        <trans-unit id="38c487e511f9d1d69315932a619005a1ef13ecae" translate="yes" xml:space="preserve">
          <source>A strict version of foldl1.</source>
          <target state="translated">严格版本的foldl1。</target>
        </trans-unit>
        <trans-unit id="3a7a0698bbaa3cecd2768e6bf682a107a5760347" translate="yes" xml:space="preserve">
          <source>A string &lt;code&gt;x&lt;/code&gt; is a caseless match for a string &lt;code&gt;y&lt;/code&gt; if and only if:</source>
          <target state="translated">一个字符串 &lt;code&gt;x&lt;/code&gt; 是一个字符串匹配的无壳 &lt;code&gt;y&lt;/code&gt; 当且仅当：</target>
        </trans-unit>
        <trans-unit id="0a89823ddb2e0acf1e32d6f1968848a1d41921ad" translate="yes" xml:space="preserve">
          <source>A string can be thrown as an error.</source>
          <target state="translated">一个字符串可以作为一个错误抛出。</target>
        </trans-unit>
        <trans-unit id="a6ae9c82c7d68fe5d1dffcf904a8de12b9166247" translate="yes" xml:space="preserve">
          <source>A string describing the source span enclosing the cost-centre.</source>
          <target state="translated">描述成本中心的源跨度的字符串。</target>
        </trans-unit>
        <trans-unit id="1236c4b5dbb424adbd898df93abf13e38ab1cf45" translate="yes" xml:space="preserve">
          <source>A string to pass on standard input to the forked process.</source>
          <target state="translated">传递给分叉进程的标准输入的字符串。</target>
        </trans-unit>
        <trans-unit id="624066030a645e943a5b155270eb593c7b3b17d0" translate="yes" xml:space="preserve">
          <source>A string with explicit length information in bytes instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">字符串的长度信息以字节为单位,而不是以NUL为结束符(允许在字符串中间出现NUL字符)。</target>
        </trans-unit>
        <trans-unit id="2356ccf00398e74e586e317a2fe01305d7bf8c72" translate="yes" xml:space="preserve">
          <source>A superclass context for a class &lt;code&gt;C&lt;/code&gt; is allowed if, after expanding type synonyms to their right-hand-sides, and uses of classes (other than &lt;code&gt;C&lt;/code&gt;) to their superclasses, &lt;code&gt;C&lt;/code&gt; does not occur syntactically in the context.</source>
          <target state="translated">对于A类的超类上下文 &lt;code&gt;C&lt;/code&gt; 允许如果，扩大类型同义词到其右手侧之后，和类别（除其他用途 &lt;code&gt;C&lt;/code&gt; ）至其超类， &lt;code&gt;C&lt;/code&gt; 不语法在上下文发生。</target>
        </trans-unit>
        <trans-unit id="a8df258a3806dcb111bd7b1772adfed8e5b1b40a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;, but as a function instead of an operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt; 的同义词，但作为函数而不是运算符。</target>
        </trans-unit>
        <trans-unit id="b99600f4f94d4a88ef68809095d330e12de5939a" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;hPut&lt;/code&gt;, for compatibility</source>
          <target state="translated">&lt;code&gt;hPut&lt;/code&gt; 的同义词，出于兼容性考虑</target>
        </trans-unit>
        <trans-unit id="f7bdd4682beedebc0801ab80535b56959469b2ec" translate="yes" xml:space="preserve">
          <source>A system-dependent mode. This is also the default mode. On Unix ELF systems this embeds &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt;/&lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; entries into the shared library or executable. In particular it uses absolute paths to where the shared libraries for the rts and each package can be found. This means the program can immediately be run and it will be able to find the libraries it needs. However it may not be suitable for deployment if the libraries are installed in a different location on another machine.</source>
          <target state="translated">与系统有关的模式。这也是默认模式。在Unix ELF系统上，这 &lt;code id=&quot;index-1&quot;&gt;RPATH&lt;/code&gt; &lt;code id=&quot;index-2&quot;&gt;RUNPATH&lt;/code&gt; / RUNPATH条目嵌入到共享库或可执行文件中。特别是，它使用绝对路径，可以找到rts和每个程序包的共享库。这意味着该程序可以立即运行，并且能够找到所需的库。但是，如果库安装在另一台计算机上的其他位置，则可能不适合部署。</target>
        </trans-unit>
        <trans-unit id="e155fb42dd454dac03073c4506c36df94ce050b3" translate="yes" xml:space="preserve">
          <source>A table of the count of edges from each node.</source>
          <target state="translated">每个节点的边数表。</target>
        </trans-unit>
        <trans-unit id="e0214aac47583666947c6b02d5dbd5d0f74c69cb" translate="yes" xml:space="preserve">
          <source>A table of the count of edges into each node.</source>
          <target state="translated">进入每个节点的边数表。</target>
        </trans-unit>
        <trans-unit id="9e56547706c1d22e7563bc02015e6d5ea9059fce" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中处理两个映射中都存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="c5b40ab4ad40ca71821f774d179180ff9dbb3299" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 处理两个映射中存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="68563c20275c3937fe80971256761864f36ba257" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中处理两个映射中都存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="d861ca0e3d900bc21406b6b1807bc2b2cf18dc29" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 处理两个映射中存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="8ae51b27a95cdff285456cfd64fc7198ed349ffd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中处理两个映射中都存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="0f49a606d06085ba26fc41ac70ef7f11a81b40cb" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 处理两个映射中存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="f35d2589fef4b7d60b15566c52bfd61bb4b033fd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中处理两个映射中都存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="35605a33cfca77541ce0f7a28d4adaaa7f211e60" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in both maps in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 处理两个映射中存在的键的策略。</target>
        </trans-unit>
        <trans-unit id="22ba35b272e3222b9000490c23cd7a38c265aa2c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="724f196ee83cb8f7d04ef2bfd02c2a5fc6e8942c" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="68f6f41d93467c8eca9791eed5e9e6b94541a4bf" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="3768165dc6a607a11a4e4e49c5b342c117fa0f2f" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="9c0f20d68941a262026f0633a3098ddef91196da" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="e901e7cd9f4ef00918e6cc4628a80d9109d39ab6" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="d93c5772a7eda6b6b5cb9d8ee695cda722b263bd" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 中不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="e438d5b20c4d0ae49dae9e96e6eb2bd92c80240d" translate="yes" xml:space="preserve">
          <source>A tactic for dealing with keys present in one map but not the other in &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一种策略，用于处理一个映射中存在的键，但在 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 不处理另一个映射中的键。</target>
        </trans-unit>
        <trans-unit id="c03aaf5092b4ace221cdda40d0db350523640c20" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt; SimpleWhenMatched k x y z &lt;/code&gt; 类型的策略是 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z &lt;/code&gt; 类型的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="a13beca0501a32224295f634b47d23e06f1ddb66" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt; SimpleWhenMissing k x z &lt;/code&gt; 策略是类型 &lt;code&gt; k -&amp;gt; x -&amp;gt; Maybe z &lt;/code&gt; 的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="8ba8a10e8973c7adb58835a435c234b5058a0a41" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt; WhenMatched f k x y z &lt;/code&gt; 策略是类型为 &lt;code&gt; k -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z) &lt;/code&gt; 的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="e2a9c18a71365b1b648cf16681fd8c36a0f1c2b1" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt; WhenMissing f k x z &lt;/code&gt; is an abstract representation of a function of type &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt; WhenMissing f k x z &lt;/code&gt; 策略是类型 &lt;code&gt; k -&amp;gt; x -&amp;gt; f (Maybe z) &lt;/code&gt; 的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="fa71c38b94fc6a846cbe5d938f6e3e23141ac8bc" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMatched x y z&lt;/code&gt; 类型的策略是Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; Maybe z&lt;/code&gt; 类型的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="4e05a0a550e141ac884df50db0a9d4c7b208813b" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SimpleWhenMissing x z&lt;/code&gt; 类型的策略是Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; Maybe z&lt;/code&gt; 类型的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="788c7aaeca2fa9237bef6f30f44eda24345655ff" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMatched f x y z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;WhenMatched f x y z&lt;/code&gt; 策略是类型为Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; y -&amp;gt; f (Maybe z)&lt;/code&gt; 的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="8d8ff0b141b2eb58a8bb144bfb707f725b7e036c" translate="yes" xml:space="preserve">
          <source>A tactic of type &lt;code&gt;WhenMissing f k x z&lt;/code&gt; is an abstract representation of a function of type &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;WhenMissing f k x z&lt;/code&gt; 策略是类型为Key- &lt;code&gt;Key -&amp;gt; x -&amp;gt; f (Maybe z)&lt;/code&gt; 的函数的抽象表示。</target>
        </trans-unit>
        <trans-unit id="ac94aa09dce6e03f7dc40cf67060871ccd2030ef" translate="yes" xml:space="preserve">
          <source>A text format for a type</source>
          <target state="translated">一种类型的文本格式</target>
        </trans-unit>
        <trans-unit id="5d64a70b084ed3d99633afca034baca94024378e" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; that specifies how to transate newline characters. The &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; specifies the input and output translation separately, so that for instance you can translate &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; on input, but leave newlines as &lt;code&gt;'\n'&lt;/code&gt; on output.</source>
          <target state="translated">文本模式的 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 具有关联的 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; ，它指定如何转换换行符。该 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 分别指定输入和输出的翻译，让比如，你可以翻译 &lt;code&gt;'\r\n'&lt;/code&gt; 到 &lt;code&gt;'\n'&lt;/code&gt; 输入，但留下换行符 &lt;code&gt;'\n'&lt;/code&gt; 输出。</target>
        </trans-unit>
        <trans-unit id="e920ef23a8f0e5c9a461f6e5c3a3ecaedd1aa8f0" translate="yes" xml:space="preserve">
          <source>A text-mode &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; has an associated &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;, which is used to decode bytes into Unicode characters when reading, and encode Unicode characters into bytes when writing.</source>
          <target state="translated">文本模式 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 具有关联的 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; ，用于在读取时将字节解码为Unicode字符，并在写入时将Unicode字符编码为字节。</target>
        </trans-unit>
        <trans-unit id="afd27d79af07b06b6dd2c8c51dd15b84360a87c3" translate="yes" xml:space="preserve">
          <source>A thread has been created to perform spark evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513f9205785871fd0e6a34a5a8b00e27eaabc144" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text using lists of packed arrays.</source>
          <target state="translated">使用打包数组列表实现Unicode文本的省时省力。</target>
        </trans-unit>
        <trans-unit id="871d33c09316ac87a1774045ce6be43e65d6fbbd" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of Unicode text. Suitable for performance critical use, both in terms of large data quantities and high speed.</source>
          <target state="translated">一个节省时间和空间的Unicode文本实现。适用于对性能要求较高的用途,包括大数据量和高速度。</target>
        </trans-unit>
        <trans-unit id="cb913ed9248b4b73bbb05825979d544eb2127ebb" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="translated">使用打包的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数组列表的懒惰字节向量的时间和空间高效实现，无论是在大数据量还是在高速需求方面，都适合于高性能使用。惰性ByteString被编码为严格字节块的惰性列表。</target>
        </trans-unit>
        <trans-unit id="87548884e6950ce7611c58d0e6aa6d111ae018da" translate="yes" xml:space="preserve">
          <source>A time and space-efficient implementation of lazy byte vectors using lists of packed &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays, suitable for high performance use, both in terms of large data quantities, or high speed requirements. Lazy ByteStrings are encoded as lazy lists of strict chunks of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51040e6bbff0d1db2681967125dbcf0660a785a" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="translated">使用打包的Word8数组在字节向量上节省时间和空间，适用于高性能应用，无论是大数据量还是高速需求。字节矢量被编码为严格 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 字节数组，在保持 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; ，并且可以在c和Haskell之间传递很少的努力。</target>
        </trans-unit>
        <trans-unit id="bd5048b9a802cb3ce698b367ba1957e1c7c15edd" translate="yes" xml:space="preserve">
          <source>A time- and space-efficient implementation of byte vectors using packed Word8 arrays, suitable for high performance use, both in terms of large data quantities and high speed requirements. Byte vectors are encoded as strict &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; arrays of bytes, held in a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, and can be passed between C and Haskell with little effort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe6c6fa0b66fdbc97157d1012689fd665f63f77" translate="yes" xml:space="preserve">
          <source>A timeout registration cookie.</source>
          <target state="translated">超时注册cookie。</target>
        </trans-unit>
        <trans-unit id="9e5d778e506d2310054d3157a8637a07f1af1107" translate="yes" xml:space="preserve">
          <source>A top-level declaration</source>
          <target state="translated">顶层宣言</target>
        </trans-unit>
        <trans-unit id="c16187723ff5e241fc07ce9bf83e42940dac6da5" translate="yes" xml:space="preserve">
          <source>A topological sort of the graph. The order is partially specified by the condition that a vertex &lt;em&gt;i&lt;/em&gt; precedes &lt;em&gt;j&lt;/em&gt; whenever &lt;em&gt;j&lt;/em&gt; is reachable from &lt;em&gt;i&lt;/em&gt; but not vice versa.</source>
          <target state="translated">图的拓扑排序。的顺序部分地由一个顶点条件中指定&lt;em&gt;我&lt;/em&gt;之前&lt;em&gt;Ĵ&lt;/em&gt;每当&lt;em&gt;Ĵ&lt;/em&gt;是从可到达的&lt;em&gt;我&lt;/em&gt;但是反之则不行。</target>
        </trans-unit>
        <trans-unit id="4693f1c5c0fbb57b8d5c4df19d87586bf13001db" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally (namely throwing the computation the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-timeout#t:Timeout&quot;&gt;Timeout&lt;/a&gt;&lt;/code&gt; exception). The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efe802c821d7daf17899a761feb1bf7a82692b9" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">一个棘手的实现细节是如何中止 &lt;code&gt;IO&lt;/code&gt; 计算的问题。该组合器在内部依赖异步异常。该技术对于在Haskell运行时系统内部执行的计算非常有效，但对于非Haskell代码则根本不起作用。例如，仅由于任意C函数无法接收异步异常，就无法使用此组合器使外部函数调用超时。当使用 &lt;code&gt;timeout&lt;/code&gt; 来包装阻塞的FFI调用时，在FFI调用返回之前无法传递任何超时事件，这在很大程度上抵消了组合器的作用。但是，实际上，这种限制并不像听起来那样严重。标准I / O功能，例如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; ，Network.Socket.accept或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 似乎正在阻塞，但实际上并不是因为运行时系统使用诸如 &lt;code&gt;select(2)&lt;/code&gt; 之类的调度机制来执行异步I / O，因此可以中断标准套接字I / O或使用此组合器的文件I / O。</target>
        </trans-unit>
        <trans-unit id="41f5a544b2c86e8b88cd4fa644eb1707b05f6a06" translate="yes" xml:space="preserve">
          <source>A tricky implementation detail is the question of how to abort an &lt;code&gt;IO&lt;/code&gt; computation. This combinator relies on asynchronous exceptions internally. The technique works very well for computations executing inside of the Haskell runtime system, but it doesn't work at all for non-Haskell code. Foreign function calls, for example, cannot be timed out with this combinator simply because an arbitrary C function cannot receive asynchronous exceptions. When &lt;code&gt;timeout&lt;/code&gt; is used to wrap an FFI call that blocks, no timeout event can be delivered until the FFI call returns, which pretty much negates the purpose of the combinator. In practice, however, this limitation is less severe than it may sound. Standard I/O functions like &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt;, Network.Socket.accept, or &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; appear to be blocking, but they really don't because the runtime system uses scheduling mechanisms like &lt;code&gt;select(2)&lt;/code&gt; to perform asynchronous I/O, so it is possible to interrupt standard socket I/O or file I/O using this combinator.</source>
          <target state="translated">一个棘手的实现细节是如何中止 &lt;code&gt;IO&lt;/code&gt; 计算的问题。该组合器在内部依赖异步异常。该技术对于在Haskell运行时系统内部执行的计算非常有效，但对于非Haskell代码则根本不起作用。例如，仅由于任意C函数无法接收异步异常，就无法使用此组合器使外部函数调用超时。当使用 &lt;code&gt;timeout&lt;/code&gt; 来包装阻塞的FFI调用时，在FFI调用返回之前无法传递任何超时事件，这在很大程度上抵消了组合器的作用。但是，实际上，这种限制并不像听起来那样严重。标准I / O功能，例如 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-io#v:hPutBuf&quot;&gt;hPutBuf&lt;/a&gt;&lt;/code&gt; ，Network.Socket.accept或 &lt;code&gt;&lt;a href=&quot;system-io#v:hWaitForInput&quot;&gt;hWaitForInput&lt;/a&gt;&lt;/code&gt; 似乎正在阻塞，但实际上并不是因为运行时系统使用诸如 &lt;code&gt;select(2)&lt;/code&gt; 之类的调度机制来执行异步I / O，因此可以中断标准套接字I / O或使用此组合器的文件I / O。</target>
        </trans-unit>
        <trans-unit id="966e03642cf0118fe092db70abdc7d1b27e6b71d" translate="yes" xml:space="preserve">
          <source>A type</source>
          <target state="translated">A型</target>
        </trans-unit>
        <trans-unit id="b12eefa8f8a22f3c9c1c70d44c19389c8c5386e5" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one, and a neutral element (&lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;) such that</source>
          <target state="translated">如果类型 &lt;code&gt;a&lt;/code&gt; 提供了关联函数（ &lt;code&gt;&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ），该函数使您可以将类型 &lt;code&gt;a&lt;/code&gt; 的任意两个值组合为一个，并且是中性元素（ &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; ），则它是 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="900bea671831ed1ce8158cdebd74c597c210974a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; if it provides an associative function (&lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;) that lets you combine any two values of type &lt;code&gt;a&lt;/code&gt; into one. Where being associative means that the following must always hold:</source>
          <target state="translated">一种 &lt;code&gt;a&lt;/code&gt; 提供了关联函数（ &lt;code&gt;&lt;a href=&quot;data-semigroup#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ），该函数可让您将类型 &lt;code&gt;a&lt;/code&gt; 的任意两个值组合为一个，则它就是 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 。具有关联性意味着必须始终满足以下条件：</target>
        </trans-unit>
        <trans-unit id="5c36da43acccbf65c4959f463c0fb381ab69f5fb" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; lets you apply any function from &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;. Furthermore &lt;code&gt;f&lt;/code&gt; needs to adhere to the following:</source>
          <target state="translated">如果类型 &lt;code&gt;f&lt;/code&gt; 提供函数 &lt;code&gt;fmap&lt;/code&gt; ，则该函数f是函子，给定类型 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，该函数fmap允许您应用 &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; a- &amp;gt; b）中的任何函数将 &lt;code&gt;f a&lt;/code&gt; 转换为 &lt;code&gt;f b&lt;/code&gt; ，并保留 &lt;code&gt;f&lt;/code&gt; 的结构。此外， &lt;code&gt;f&lt;/code&gt; 需要遵守以下条件：</target>
        </trans-unit>
        <trans-unit id="e8dc677defa7be455d6125e7b6e0f1fcd1c4b205" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;f&lt;/code&gt; is a Functor if it provides a function &lt;code&gt;fmap&lt;/code&gt; which, given any types &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, lets you apply any function of type &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to turn an &lt;code&gt;f a&lt;/code&gt; into an &lt;code&gt;f b&lt;/code&gt;, preserving the structure of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">如果类型 &lt;code&gt;f&lt;/code&gt; 提供函数 &lt;code&gt;fmap&lt;/code&gt; ，则给定类型 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，它是函子，可以使您应用类型 &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 任何函数将 &lt;code&gt;f a&lt;/code&gt; 变成 &lt;code&gt;f b&lt;/code&gt; ，从而保留 &lt;code&gt;f&lt;/code&gt; 的结构。</target>
        </trans-unit>
        <trans-unit id="f5b73b56591ee75fd4320cdb138584a6631c70e7" translate="yes" xml:space="preserve">
          <source>A type application.</source>
          <target state="translated">A型应用。</target>
        </trans-unit>
        <trans-unit id="4843d11f8e6edd0b1d5c045f927fdb0d7d055f98" translate="yes" xml:space="preserve">
          <source>A type constructor or class can be any non-reserved operator. Symbols used in types are always like capitalized identifiers; they are never variables. Note that this is different from the lexical syntax of data constructors, which are required to begin with a &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">类型构造函数或类可以是任何非保留的运算符。类型中使用的符号始终像大写标识符一样；他们从来都不是变量。请注意，这是从数据构造，这些都要求开始用的词汇语法不同 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2957975b2e2a0d72a85cca6ba60d8dc7b412130f" translate="yes" xml:space="preserve">
          <source>A type context can include equality constraints of the form &lt;code&gt;t1 ~ t2&lt;/code&gt;, which denote that the types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; need to be the same. In the presence of type families, whether two types are equal cannot generally be decided locally. Hence, the contexts of function signatures may include equality constraints, as in the following example:</source>
          <target state="translated">类型上下文可以包括形式的等式约束 &lt;code&gt;t1 ~ t2&lt;/code&gt; ，这表示类型 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; 必须相同。在存在类型族的情况下，通常不能本地确定两种类型是否相等。因此，功能签名的上下文可能包括相等约束，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="dbb43eef001aa96d23cb8f2b1045baf5a1fc027f" translate="yes" xml:space="preserve">
          <source>A type family can also be declared with a &lt;code&gt;where&lt;/code&gt; clause, defining the full set of equations for that family. For example:</source>
          <target state="translated">类型族也可以使用 &lt;code&gt;where&lt;/code&gt; 子句声明，该子句定义该族的整套方程式。例如：</target>
        </trans-unit>
        <trans-unit id="3ca042aa66fa2759abc533fbf4e600be254b35ae" translate="yes" xml:space="preserve">
          <source>A type family to compute Boolean equality.</source>
          <target state="translated">一个计算布尔平等的类型族。</target>
        </trans-unit>
        <trans-unit id="8eff1fa8083a3c76f23688ec0faf2770e8f9b619" translate="yes" xml:space="preserve">
          <source>A type is &amp;ldquo;rigid&amp;rdquo; if it is completely known to the compiler at its binding site. The easiest way to ensure that a variable a rigid type is to give it a type signature. For more precise details see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;Simple unification-based type inference for GADTs&lt;/a&gt;. The criteria implemented by GHC are given in the Appendix.</source>
          <target state="translated">如果编译器在绑定位置完全知道类型，则该类型为&amp;ldquo;刚性&amp;rdquo;。确保变量为刚性类型的最简单方法是为其赋予类型签名。有关更精确的详细信息，请参阅&lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/papers/gadt/&quot;&gt;GADT的基于简单统一的类型推断&lt;/a&gt;。GHC实施的标准在附录中给出。</target>
        </trans-unit>
        <trans-unit id="6b6dc84a99a51911e396803e6f137d1ec9e7ecb5" translate="yes" xml:space="preserve">
          <source>A type or data family, with a list of its visible instances. A closed type family is returned with 0 instances.</source>
          <target state="translated">一个类型或数据族,有一个可见实例的列表。一个封闭的类型族返回0个实例。</target>
        </trans-unit>
        <trans-unit id="0a858ee617d52cf82c99429cf69589bf7daf3b44" translate="yes" xml:space="preserve">
          <source>A type or kind variable explicitly bound using &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; but not used on the left hand side will generate an error, not a warning.</source>
          <target state="translated">使用明确绑定的类型或种类变量 &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 显&lt;/a&gt;但未在左侧将生成错误，而不是警告。</target>
        </trans-unit>
        <trans-unit id="13dc503b524051e73bf1854416495a7c476690ef" translate="yes" xml:space="preserve">
          <source>A type representing a number of UTF-16 code units.</source>
          <target state="translated">一个代表UTF-16编码单位数量的类型。</target>
        </trans-unit>
        <trans-unit id="fac7b1b31387a5dce83f6207988f33acc423d8c4" translate="yes" xml:space="preserve">
          <source>A type signature may occur in any pattern; this is a &lt;em&gt;pattern type signature&lt;/em&gt;. For example:</source>
          <target state="translated">类型签名可以以任何模式出现。这是一个&lt;em&gt;模式类型签名&lt;/em&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="8682a8a15f37e1952f2bed70e4a76505ad01ea0d" translate="yes" xml:space="preserve">
          <source>A type variable applied to some types:</source>
          <target state="translated">应用于某些类型的类型变量。</target>
        </trans-unit>
        <trans-unit id="9bfcbaf65cc2630df1737c174af7d766948febae" translate="yes" xml:space="preserve">
          <source>A type variable beginning with an underscore is not treated specially in a type or data instance declaration. For example:</source>
          <target state="translated">在类型或数据实例声明中,以下划线开头的类型变量不会被特殊处理。例如:</target>
        </trans-unit>
        <trans-unit id="6ca958f1089d3d1582d1c30aba329c8223832dd9" translate="yes" xml:space="preserve">
          <source>A type variable.</source>
          <target state="translated">一个类型变量。</target>
        </trans-unit>
        <trans-unit id="297b034e775e243ef7a125f9be96bd9336678f08" translate="yes" xml:space="preserve">
          <source>A typed expression splice can occur in place of an expression; the spliced expression must have type &lt;code&gt;Q (TExp a)&lt;/code&gt;</source>
          <target state="translated">有类型的表达式剪接可以代替表达式出现。拼接表达式必须具有类型 &lt;code&gt;Q (TExp a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fff5bdf005b35f179294ba275419d126af32c8a0" translate="yes" xml:space="preserve">
          <source>A typical heap object may be in one of the following four states at each point in its lifetime:</source>
          <target state="translated">一个典型的堆对象在其生命周期中的每一点都可能处于以下四种状态之一。</target>
        </trans-unit>
        <trans-unit id="6e00c4c8e7f8a62193a99b6e6434c24bc66d1ce8" translate="yes" xml:space="preserve">
          <source>A typical use is to prevent resource leaks in lazy IO programs, by forcing all characters from a file to be read. For example:</source>
          <target state="translated">一个典型的用途是防止懒惰IO程序的资源泄漏,通过强制读取文件中的所有字符。比如说</target>
        </trans-unit>
        <trans-unit id="fb52c77586fd9d5d1d5e06c0781fa29b45252709" translate="yes" xml:space="preserve">
          <source>A typical use of &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; for recovery looks like this:</source>
          <target state="translated">典型用途 &lt;code&gt;&lt;a href=&quot;control-exception#v:tryJust&quot;&gt;tryJust&lt;/a&gt;&lt;/code&gt; 用于恢复的如下所示：</target>
        </trans-unit>
        <trans-unit id="f5fa8bc47ca59ba407ee77bfa4f457f11af6f63d" translate="yes" xml:space="preserve">
          <source>A unique &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; object Used when the strings are dynamically allocated, eg from binary deserialisation</source>
          <target state="translated">独特的 &lt;code&gt;&lt;a href=&quot;type-reflection-unsafe#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 对象，当动态分配字符串（例如，通过二进制反序列化）时使用</target>
        </trans-unit>
        <trans-unit id="6e0b23e86250bf5ded8e24685820d0cba5c52892" translate="yes" xml:space="preserve">
          <source>A unique identifier used to refer to the cost-centre</source>
          <target state="translated">用于指称成本中心的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="e2b058205e0073a16e899cb4a51295d96e6d2af1" translate="yes" xml:space="preserve">
          <source>A unique local name</source>
          <target state="translated">一个独特的地方名称</target>
        </trans-unit>
        <trans-unit id="1f67274a4c72a292a8769f67401cc21d34e5f22d" translate="yes" xml:space="preserve">
          <source>A use of &lt;code&gt;MkSet&lt;/code&gt; as a constructor (e.g. in the definition of &lt;code&gt;makeSet&lt;/code&gt;) gives rise to a &lt;code&gt;(Eq a)&lt;/code&gt; constraint, as you would expect. The new feature is that pattern-matching on &lt;code&gt;MkSet&lt;/code&gt; (as in the definition of &lt;code&gt;insert&lt;/code&gt;) makes &lt;em&gt;available&lt;/em&gt; an &lt;code&gt;(Eq a)&lt;/code&gt; context. In implementation terms, the &lt;code&gt;MkSet&lt;/code&gt; constructor has a hidden field that stores the &lt;code&gt;(Eq a)&lt;/code&gt; dictionary that is passed to &lt;code&gt;MkSet&lt;/code&gt;; so when pattern-matching that dictionary becomes available for the right-hand side of the match. In the example, the equality dictionary is used to satisfy the equality constraint generated by the call to &lt;code&gt;elem&lt;/code&gt;, so that the type of &lt;code&gt;insert&lt;/code&gt; itself has no &lt;code&gt;Eq&lt;/code&gt; constraint.</source>
          <target state="translated">如您所 &lt;code&gt;MkSet&lt;/code&gt; ，将MkSet用作构造函数（例如，在 &lt;code&gt;makeSet&lt;/code&gt; 的定义中）会产生 &lt;code&gt;(Eq a)&lt;/code&gt; 约束。新的功能是对模式匹配 &lt;code&gt;MkSet&lt;/code&gt; （如在定义 &lt;code&gt;insert&lt;/code&gt; ）使得&lt;em&gt;可用&lt;/em&gt;的 &lt;code&gt;(Eq a)&lt;/code&gt; 上下文。在实现方面， &lt;code&gt;MkSet&lt;/code&gt; 构造函数具有一个隐藏字段，用于存储 &lt;code&gt;(Eq a)&lt;/code&gt; 传递给 &lt;code&gt;MkSet&lt;/code&gt; 字典；因此，在进行模式匹配时，该字典可用于匹配的右侧。在该示例中，相等字典用于满足对的调用所产生的相等约束。 &lt;code&gt;elem&lt;/code&gt; ，因此 &lt;code&gt;insert&lt;/code&gt; 类型本身没有 &lt;code&gt;Eq&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="c1353efcd4777e1aa99c83066c3c4fd8238bee7d" translate="yes" xml:space="preserve">
          <source>A useful &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt;-like function for debugging purposes.</source>
          <target state="translated">一个有用的类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 的函数，用于调试。</target>
        </trans-unit>
        <trans-unit id="86295d409cfd9cf7cbef34ae7b547dcc96dc0f25" translate="yes" xml:space="preserve">
          <source>A useful default. In particular:</source>
          <target state="translated">一个有用的缺省。特别是:</target>
        </trans-unit>
        <trans-unit id="f8c74a72bfde3e2ebcf4f91dbf953debbfc38d10" translate="yes" xml:space="preserve">
          <source>A useful idiom permitted by the above rules is as follows. If one allows overlapping instance declarations then it&amp;rsquo;s quite convenient to have a &amp;ldquo;default instance&amp;rdquo; declaration that applies if something more specific does not:</source>
          <target state="translated">上述规则允许的有用用法如下。如果允许重叠的实例声明，那么使用&amp;ldquo;默认实例&amp;rdquo;声明非常方便，如果某些更具体的事情不适用，则使用：</target>
        </trans-unit>
        <trans-unit id="a0a8e93d7731f26de07f8a99cabb013a2ca2c78f" translate="yes" xml:space="preserve">
          <source>A useful option to alert you when interfaces change is &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; option. It will run &lt;code&gt;diff&lt;/code&gt; on the changed interface file, before and after, when applicable.</source>
          <target state="translated">&lt;code&gt;-ddump-hi-diffs&lt;/code&gt; 选项是在接口更改时提醒您的有用选项。如果适用，它将在更改后的接口文件之前和之后运行 &lt;code&gt;diff&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48bece416cc59f93fda6101dbf5899713474b8a5" translate="yes" xml:space="preserve">
          <source>A user could provide, for example, a &lt;code&gt;GSerialize UInt&lt;/code&gt; instance so that a &lt;code&gt;Serialize IntHash&lt;/code&gt; instance could be easily defined in terms of &lt;code&gt;GSerialize&lt;/code&gt;.</source>
          <target state="translated">用户可以提供，例如，一 &lt;code&gt;GSerialize UInt&lt;/code&gt; 实例，以便一个 &lt;code&gt;Serialize IntHash&lt;/code&gt; 实例可以很容易地在来定义 &lt;code&gt;GSerialize&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5dd220d0ff116d56be2881c3c2eda319a7be24bc" translate="yes" xml:space="preserve">
          <source>A user log message (from, e.g., &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent#v:traceEvent&quot;&gt;Control.Concurrent.traceEvent&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5483fab05ffacd5a3f560ae7afd7921c21d6c2" translate="yes" xml:space="preserve">
          <source>A user marker (from &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceMarker&quot;&gt;Debug.Trace.traceMarker&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf4989d597f060b1f221f4d9b40f8cbdd26cf10" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; is an object encapsulated together with its type.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Dynamic&quot;&gt;Dynamic&lt;/a&gt;&lt;/code&gt; 的值是与类型一起封装的对象。</target>
        </trans-unit>
        <trans-unit id="5e578226b20de3d07741dafad66454d118f3458d" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 类型的值是指向可从外部代码调用的函数的指针。类型 &lt;code&gt;a&lt;/code&gt; 通常是&lt;em&gt;外来类型&lt;/em&gt;，即具有零个或多个参数的函数类型，其中</target>
        </trans-unit>
        <trans-unit id="5e81410f386c89f452d754e65a825472786597c7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 的值可以是指向外部函数的指针，可以由另一个外部函数返回，也可以通过静态地址导入（例如</target>
        </trans-unit>
        <trans-unit id="7f136bc98f2d8137b486a143123edbe9b3241275" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 类型的值表示指向一个对象或对象数组的指针，该指针或对象数组可以编组到类型 &lt;code&gt;a&lt;/code&gt; 的 Haskell值或从其中进行编组。</target>
        </trans-unit>
        <trans-unit id="3cd6a3283ff99f274500f801cf1370f639df9d9c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 类型的值是指向可从外部代码调用的函数的指针。类型 &lt;code&gt;a&lt;/code&gt; 通常是&lt;em&gt;外来类型&lt;/em&gt;，即具有零个或多个参数的函数类型，其中</target>
        </trans-unit>
        <trans-unit id="afb41f27d10d971b0c644adebd15549eb369a006" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 的值可以是指向外部函数的指针，可以由另一个外部函数返回，也可以通过静态地址导入（例如</target>
        </trans-unit>
        <trans-unit id="239d8e1787a28722de24cac0f475ff48393d312a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 的值表示指向对象或对象数组的指针，这些指针或对象数组可以编组为类型 &lt;code&gt;a&lt;/code&gt; 的 Haskell值或从中提取。</target>
        </trans-unit>
        <trans-unit id="65cdd07d411abaf19b949230fd787b91d7248467" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型的值 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 是一个运算哪些，执行时执行一些I / O返回类型的值之前 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a20081f01fcf352f0cfcb6c5a5c6d192ad5b3810" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; is a pointer to a function callable from foreign code. The type &lt;code&gt;a&lt;/code&gt; will normally be a &lt;em&gt;foreign type&lt;/em&gt;, a function type with zero or more arguments where</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 类型的值是指向可从外部代码调用的函数的指针。类型 &lt;code&gt;a&lt;/code&gt; 通常是&lt;em&gt;外来类型&lt;/em&gt;，即具有零个或多个参数的函数类型，其中</target>
        </trans-unit>
        <trans-unit id="6305ddbae16f3512160787cb992d3e58bee68afe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; may be a pointer to a foreign function, either returned by another foreign function or imported with a a static address import like</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt; a&lt;/code&gt; 的值可以是指向外部函数的指针，可以由另一个外部函数返回，也可以通过静态地址导入（例如</target>
        </trans-unit>
        <trans-unit id="9be954ea62342aa30dc2f597f01c234102f416fd" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 的值表示指向对象或对象数组的指针，这些指针或对象数组可以编组为类型 &lt;code&gt;a&lt;/code&gt; 的 Haskell值或从中提取。</target>
        </trans-unit>
        <trans-unit id="90894fbb07b5d90eacb70ed7f8519e1d7af5b5d4" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型的值 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 是一个运算哪些，执行时执行一些I / O返回类型的值之前 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f741bc04d3ebabbc8052c3e8ced2a6bbb1b0a05" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt; a&lt;/code&gt; 的值表示指向对象或对象数组的指针，这些指针或对象数组可以编组为类型 &lt;code&gt;a&lt;/code&gt; 的 Haskell值或从中提取。</target>
        </trans-unit>
        <trans-unit id="9e06d2b58f261c19e13fe9c8981e6d1218570c7c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; is a computation which, when performed, does some I/O before returning a value of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型的值 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt; a&lt;/code&gt; 是一个运算哪些，执行时执行一些I / O返回类型的值之前 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65e2250aafb04e86e024b91238925a6bb2963b39" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;StablePtr a&lt;/code&gt; is a stable pointer to a Haskell expression of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;StablePtr a&lt;/code&gt; 的值是指向类型 &lt;code&gt;a&lt;/code&gt; 的Haskell表达式的稳定指针。</target>
        </trans-unit>
        <trans-unit id="013a61726b4b56a72c4ddab274465f1e28f21c9f" translate="yes" xml:space="preserve">
          <source>A variable is &lt;em&gt;closed&lt;/em&gt; if and only if</source>
          <target state="translated">仅当且仅当变量&lt;em&gt;关闭&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0624bb33a678b07c2a300b904ae61401b2b3e3" translate="yes" xml:space="preserve">
          <source>A variable is called &lt;em&gt;dynamically bound&lt;/em&gt; when it is bound by the calling context of a function and &lt;em&gt;statically bound&lt;/em&gt; when bound by the callee&amp;rsquo;s context. In Haskell, all variables are statically bound. Dynamic binding of variables is a notion that goes back to Lisp, but was later discarded in more modern incarnations, such as Scheme. Dynamic binding can be very confusing in an untyped language, and unfortunately, typed languages, in particular Hindley-Milner typed languages like Haskell, only support static scoping of variables.</source>
          <target state="translated">当变量被函数的调用上下文&lt;em&gt;绑定&lt;/em&gt;时，该变量称为&lt;em&gt;动态绑定；&lt;/em&gt;当被调用者上下文&lt;em&gt;绑定&lt;/em&gt;时，则称为&lt;em&gt;静态绑定&lt;/em&gt;。在Haskell中，所有变量都是静态绑定的。动态绑定变量是一个可以追溯到Lisp的概念，但后来在更现代的版本（例如Scheme）中被丢弃。动态绑定在非类型化语言中可能会造成混乱，不幸的是，类型化语言（尤其是像Haskell这样的Hindley-Milner类型化语言）仅支持变量的静态作用域。</target>
        </trans-unit>
        <trans-unit id="e557c6a254bde2fa9fce694bac49fbabbe6203a2" translate="yes" xml:space="preserve">
          <source>A variable is regarded as &amp;ldquo;used&amp;rdquo; if</source>
          <target state="translated">如果一个变量被认为是&amp;ldquo;已使用&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ef00f1720266eda76457e7e8274afd0d351d58ec" translate="yes" xml:space="preserve">
          <source>A variable-length event encoding a heap sample broken down by,</source>
          <target state="translated">一个可变长度的事件,编码一个按以下方式分解的堆样本。</target>
        </trans-unit>
        <trans-unit id="b96521844e19dff99bc29450ed4b5c3e48d9657d" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a heap profile sample broken down by,</source>
          <target state="translated">一个可变长度的数据包,编码一个按以下方式分解的堆配置文件样本。</target>
        </trans-unit>
        <trans-unit id="d2629ff819bfa2b3bc89a988e7b72caf2ad22ebf" translate="yes" xml:space="preserve">
          <source>A variable-length packet encoding a profile sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a750d420cf956ff31ac1cd27a77853ed3578e" translate="yes" xml:space="preserve">
          <source>A variable-length packet produced once for each cost centre,</source>
          <target state="translated">为每个成本中心制作一次可变长度的数据包。</target>
        </trans-unit>
        <trans-unit id="5d1f67f8c131ae27aed80d2e73f0a9a08edfca88" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的变体，其参数相反。</target>
        </trans-unit>
        <trans-unit id="bdb2d179c96dfc9014b723ecd18ad20eb9df0287" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 一种变体，其中不需要第一次计算的返回值。</target>
        </trans-unit>
        <trans-unit id="f484ec182618f59bc6a03fa556e1dfe4602922b2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="1a806f7ef066f93f4459cf71c970f146b042ce14" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; that takes an exception predicate to select which exceptions are caught (c.f. &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;). If the exception does not match the predicate, it is re-thrown.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 的一种变体，它使用异常谓词来选择要捕获的异常（参见 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; ）。如果异常与谓词不匹配，则将其重新抛出。</target>
        </trans-unit>
        <trans-unit id="980dc5b1188b883f4b0698253298fdcc03f22555" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-state-class#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 一种变体，其中在新状态下计算严格。</target>
        </trans-unit>
        <trans-unit id="4ec6ceddfeaaf45a25f723cacb495b1ccc3c2250" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 一种变体，其中在新状态下计算严格。</target>
        </trans-unit>
        <trans-unit id="d552c9d4da515c75912002c65ae5ebd55983c353" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 一种变体，其中在新状态下计算严格。</target>
        </trans-unit>
        <trans-unit id="2be03be1f4f972f3e16388053b30f3f14523b03b" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 一种变体，其中在新状态下计算严格。</target>
        </trans-unit>
        <trans-unit id="3d7eba7d8d00a5efd27077394673889a22d85d24" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; in which the computation is strict in the new state.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-monad-trans-state-strict#v:modify&quot;&gt;modify&lt;/a&gt;&lt;/code&gt; 一种变体，其中在新状态下计算严格。</target>
        </trans-unit>
        <trans-unit id="f8879cc31acc8932b5c49885c6d29e918117f2f5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldl&quot;&gt;bifoldl&lt;/a&gt;&lt;/code&gt; 的一种变体，不具有基本情况，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="d3d4bfbfcd281f231983e2d29e27a74b95a66a32" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifoldr&quot;&gt;bifoldr&lt;/a&gt;&lt;/code&gt; 的变体没有基例，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="50c2bc37d962248156836e2639fc6b4dadc3fba3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; that is strict in the accumulator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 的变体，在累加器中严格。</target>
        </trans-unit>
        <trans-unit id="18749169ab66a243e5d3ff1e282a5a0fa0dd77c7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的一种变体，没有基本情况，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="c779c916890acc8970f5fe31251b940c218fccc0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">文件 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 一种变体，不具有基本大小写，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="8ddfd37c7061963e7b77b06bdb4fbd084e4a8097" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的一种变体，没有基本情况，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="7defbd1e72da7e4dd78ff7b670071a5b458cf24a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">文件 &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 一种变体，不具有基本大小写，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="e9ee1d48660b932b3bb180c1aaef20eee11c73c0" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; with the arguments reversed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的变体，其参数相反。</target>
        </trans-unit>
        <trans-unit id="d32ebdebb4f9a3837e2e7d4648c8bd7eceb6c9f2" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-err#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种变体，不会产生堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="f23407f9c31b9d9550363e44222113e312af065d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228eb2d34fa954a72d817265f3ac30a2c4d0f77c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0680130bb0f4b8f4cbc7c8b028930fd44a3af9ce" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="0ec4492419779cfaef51be94d2b8f28e80c4545f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="491efa58eb1f11c0cb3815ae8f348ca0c034ce84" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="47d036c06686a27eae150f0188962179aa6b3b53" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="da53c6399c31d81bfdb2f650d84ca62634038b07" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; that can only be used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">只能在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 的变体。</target>
        </trans-unit>
        <trans-unit id="73f171fdb5237d901b1c481374b6861edf14fa56" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; that does not produce a stack trace.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 一种变体，不会产生堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="47f3f2679bc0ad75bdf30646c6761ef6c4b68243" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; 的一种变体，没有基本情况，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="477f918f68cdb05044cf99fdb58a555808faeff3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; that has no base case, and thus may only be applied to non-empty structures.</source>
          <target state="translated">文件 &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 一种变体，不具有基本大小写，因此只能应用于非空结构。</target>
        </trans-unit>
        <trans-unit id="6911589d252df6b0d320b35e4685df9e30028055" translate="yes" xml:space="preserve">
          <source>A variant of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; where the return value from the first computation is not required.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 一种变体，其中不需要第一次计算的返回值。</target>
        </trans-unit>
        <trans-unit id="add459265a4128073f2963ebb449fbb05ec6cb08" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">各种各样的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 都忽略了对 &lt;code&gt;n&lt;/code&gt; 的检查，因此程序员有义务提供证明 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="022677c1577a85e404387475e8f412822a05da7e" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 省略了对空情况的检查，因此程序员有义务提供证明ByteString为非空。</target>
        </trans-unit>
        <trans-unit id="8b4ffb4fe31d0195b8acddfad454298b4604216b" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; 省略对空情况的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="1d777dc5f4859f53e852d78b2a883751d3a5e477" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">非空ByteString的各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一种。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; 省略了对空箱的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="d0e791ecae2adcb55aa4c85c7e30c588765957cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="translated">各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; 用于非空字节串。 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; 省略了对空情况的检查。与 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; 一样，程序员必须提供一个单独的证明ByteString非空。</target>
        </trans-unit>
        <trans-unit id="cd0eca831b19e2193bae89b92f0b4e215f8baf4c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="translated">各种 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 其省略了对支票 &lt;code&gt;n&lt;/code&gt; 所以对程序员有义务提供一个证明 &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d61fdfe5cc2564d603aac91be2fa83ba8aa2a7c" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06fb91e894a0b25610b75a5af5b9808209630d25" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:head&quot;&gt;head&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt; omits the check for the empty case, so there is an obligation on the programmer to provide a proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdce50acace32ba6eb0fe5af8f10f59503ea5260" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:init&quot;&gt;init&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeInit&quot;&gt;unsafeInit&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416bf67712d94a4092fa1366ed0a1243511ca321" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeLast&quot;&gt;unsafeLast&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73173fcba7dc4f1755bea5939f3721c98a85b2cb" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:tail&quot;&gt;tail&lt;/a&gt;&lt;/code&gt; for non-empty ByteStrings. &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeTail&quot;&gt;unsafeTail&lt;/a&gt;&lt;/code&gt; omits the check for the empty case. As with &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafeHead&quot;&gt;unsafeHead&lt;/a&gt;&lt;/code&gt;, the programmer must provide a separate proof that the ByteString is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ba6eac709468119bb502dc4a786ac25beaa443" translate="yes" xml:space="preserve">
          <source>A variety of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; which omits the checks on &lt;code&gt;n&lt;/code&gt; so there is an obligation on the programmer to provide a proof that &lt;code&gt;0 &amp;lt;= n &amp;lt;= &lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt; xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="011da0f3d1d6c75639ffb6db3b663d10df8596d2" translate="yes" xml:space="preserve">
          <source>A version can be tagged with an arbitrary list of strings. The interpretation of the list of tags is entirely dependent on the entity that this version applies to.</source>
          <target state="translated">一个版本可以用一个任意的字符串列表来标记。标签列表的解释完全取决于这个版本所适用的实体。</target>
        </trans-unit>
        <trans-unit id="ecaf2ca21f3f2373e5185cd515851b6e67ee803a" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:peekTBQueue&quot;&gt;peekTBQueue&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ffeb4910a01e5cd6d72fcebc814ef710471656" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">无法重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:readTBQueue&quot;&gt;readTBQueue&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b08df2ea8c4c791467734758ae49b0aa839c743" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">不重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:peekTChan&quot;&gt;peekTChan&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5e78e2ce5a1352cca108846156255775dd7108" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:readTChan&quot;&gt;readTChan&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff76e55acfcccd02a15d736db81fe96146722925" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">不 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 版本。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; 功能企图把价值 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; ，返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果它是成功的，或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="28577cb8a660e56c217a279acfd2976c3b7454ed" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryPutTMVar&quot;&gt;tryPutTMVar&lt;/a&gt;&lt;/code&gt; function attempts to put the value &lt;code&gt;a&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, returning &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if it was successful, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dc8f0973fefa88de9a13d12ee694150980b61d" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:readTMVar&quot;&gt;readTMVar&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed2b50c296f40c959a6e33c87f8de3078552d7bb" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="translated">的一个版本 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 不 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; 。该 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 是空的，或者 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 挤满了内容 &lt;code&gt;a&lt;/code&gt; 。在 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; 之后， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 保留为空。</target>
        </trans-unit>
        <trans-unit id="5433d7bb6120760452598bf6c542c3024a31c810" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; that does not &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was empty, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; was full with contents &lt;code&gt;a&lt;/code&gt;. After &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:tryTakeTMVar&quot;&gt;tryTakeTMVar&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; is left empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30f3fd19a32279f9ca43fcf5051a4b725b4afb0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:peekTQueue&quot;&gt;peekTQueue&lt;/a&gt;&lt;/code&gt; 的版本，不会重试。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2433a0ad5e90f34ad9f4bf45621e0ceb170fdea6" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; which does not retry. Instead it returns &lt;code&gt;Nothing&lt;/code&gt; if no value is available.</source>
          <target state="translated">不重试的 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:readTQueue&quot;&gt;readTQueue&lt;/a&gt;&lt;/code&gt; 版本。相反，如果没有可用值，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc561502aa5288942ce875d139d9631abcf512c" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; with the arguments swapped around; useful in situations where the code for the handler is shorter. For example:</source>
          <target state="translated">一个带有参数互换的 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 版本；在处理程序的代码较短的情况下很有用。例如：</target>
        </trans-unit>
        <trans-unit id="1c3e44a662ef33517cd5d56bc8e42cf32ad0c3d0" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; with the arguments swapped around (see &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;control-exception#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 的版本，其中的参数互换了（请参阅 &lt;code&gt;&lt;a href=&quot;control-exception#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e66efe0c3f15c8fafbf44d9ce27299363bc807ef" translate="yes" xml:space="preserve">
          <source>A version of &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; that forces the (pair) result of the function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 的版本，用于强制函数的（对）结果。</target>
        </trans-unit>
        <trans-unit id="bef2aa5115f3db1a79e2efec0dfffeeae204b525" translate="yes" xml:space="preserve">
          <source>A vertical bar denotes disjunction, i.e. one of the two sides is required. A comma denotes conjunction, i.e. both sides are required. Conjunction binds stronger than disjunction.</source>
          <target state="translated">竖条表示不连贯,即两边中必须有一边。逗号表示连接,即两边都需要。连词比不连词的约束力更强。</target>
        </trans-unit>
        <trans-unit id="edf34a57d05a3c5d4ea50057dd0ce34f6a6b36fa" translate="yes" xml:space="preserve">
          <source>A very experimental flag that makes dictionary-valued expressions seem cheap to the optimiser.</source>
          <target state="translated">一个非常实验性的标志,让字典值的表达式在优化器看来很廉价。</target>
        </trans-unit>
        <trans-unit id="7c65e4b2cb887d618e9c4063061a15033cdc0051" translate="yes" xml:space="preserve">
          <source>A violation of the &amp;ldquo;forall-or-nothing&amp;rdquo; rule looks like this:</source>
          <target state="translated">违反&amp;ldquo;全部或全部&amp;rdquo;规则的情况如下：</target>
        </trans-unit>
        <trans-unit id="a5feb9baead6354d4dfbb9ad7fa5678327d72c84" translate="yes" xml:space="preserve">
          <source>A visible type application is preceded with an &lt;code&gt;@&lt;/code&gt; sign. (To disambiguate the syntax, the &lt;code&gt;@&lt;/code&gt; must be preceded with a non-identifier letter, usually a space. For example, &lt;code&gt;read@Int 5&lt;/code&gt; would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</source>
          <target state="translated">可见类型的应用程序前面带有 &lt;code&gt;@&lt;/code&gt; 符号。（要消除语法歧义， &lt;code&gt;@&lt;/code&gt; 之前必须加一个非标识符字母，通常是一个空格。例如， &lt;code&gt;read@Int 5&lt;/code&gt; 不会解析。）只要知道函数的完整多态类型，就可以使用它。如果函数是标识符（常见情况），则仅在为标识符提供类型签名后，才认为其类型是已知的。如果标识符没有类型签名，则不能使用可见的类型应用程序。</target>
        </trans-unit>
        <trans-unit id="f7aecd3b32383a90db727ba6bc951dd96bb7555b" translate="yes" xml:space="preserve">
          <source>A way of creating ByteStrings outside the IO monad. The &lt;code&gt;Int&lt;/code&gt; argument gives the final size of the ByteString.</source>
          <target state="translated">一种在IO monad外部创建ByteString的方法。在 &lt;code&gt;Int&lt;/code&gt; 参数给出的字节串的最终大小。</target>
        </trans-unit>
        <trans-unit id="ae700162fd083eb51a2e5484581b63431c6cf961" translate="yes" xml:space="preserve">
          <source>A weak pointer expresses a relationship between two objects, the &lt;em&gt;key&lt;/em&gt; and the &lt;em&gt;value&lt;/em&gt;: if the key is considered to be alive by the garbage collector, then the value is also alive. A reference from the value to the key does &lt;em&gt;not&lt;/em&gt; keep the key alive.</source>
          <target state="translated">弱指针表示&lt;em&gt;键&lt;/em&gt;和&lt;em&gt;值&lt;/em&gt;两个对象之间的关系：如果垃圾回收器认为键是活动的，则该值也是活动的。从值到键的引用&lt;em&gt;不会&lt;/em&gt;使键保持活动状态。</target>
        </trans-unit>
        <trans-unit id="4c0a7ed1da2479162371079b8163cabf26c83c98" translate="yes" xml:space="preserve">
          <source>A weak pointer may also have a finalizer of type &lt;code&gt;IO ()&lt;/code&gt;; if it does, then the finalizer will be run at most once, at a time after the key has become unreachable by the program (&quot;dead&quot;). The storage manager attempts to run the finalizer(s) for an object soon after the object dies, but promptness is not guaranteed.</source>
          <target state="translated">弱指针也可能具有 &lt;code&gt;IO ()&lt;/code&gt; 类型的终结器；如果确实如此，则终结器将最多运行一次，一次是在程序无法访问密钥之后（&amp;ldquo;死&amp;rdquo;）。对象死亡后，存储管理器会尝试为该对象运行终结器，但是不能保证快速性。</target>
        </trans-unit>
        <trans-unit id="a955a161a9eee216cd6b80d8d47df1c807c9be34" translate="yes" xml:space="preserve">
          <source>A weak pointer object with a key and a value. The value has type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">具有键和值的弱指针对象。该值的类型为 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b5c16f462f6b8ca64b6aee48fd180f321af7cba" translate="yes" xml:space="preserve">
          <source>A whole String fragment</source>
          <target state="translated">一个完整的字符串片段</target>
        </trans-unit>
        <trans-unit id="1306d902863c6c0a77b6f4d1230a385868937f62" translate="yes" xml:space="preserve">
          <source>A wide character string with explicit length information in &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt;s instead of a terminating NUL (allowing NUL characters in the middle of the string).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CWchar&quot;&gt;CWchar&lt;/a&gt;&lt;/code&gt; 中具有明确长度信息的宽字符串，而不是终止NUL（允许在字符串中间使用NUL字符）。</target>
        </trans-unit>
        <trans-unit id="987253a26575543a06fc7e055fbc0251b63eb205" translate="yes" xml:space="preserve">
          <source>A word begins either at the start of the line or after an unescaped whitespace character.</source>
          <target state="translated">一个字的开头是在行的开始,或者是在一个未加空格的字符之后。</target>
        </trans-unit>
        <trans-unit id="98bca88a2b006e940b1f7f785915d961c11c9f72" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by the type &lt;code&gt;w&lt;/code&gt; of output to accumulate.</source>
          <target state="translated">由输出类型 &lt;code&gt;w&lt;/code&gt; 参数化的writer monad 进行累加。</target>
        </trans-unit>
        <trans-unit id="07ef82639a79658d53d1fcd5bfce5876d5b9adb5" translate="yes" xml:space="preserve">
          <source>A writer monad parameterized by:</source>
          <target state="translated">一个以下列方式为参数的作家单子:</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="882edca3292f207f02c04f0e4d828075132b5c5b" translate="yes" xml:space="preserve">
          <source>ADDATTRS</source>
          <target state="translated">ADDATTRS</target>
        </trans-unit>
        <trans-unit id="d37db076be2c745cf98c9bb60cf88dbf2626e6b7" translate="yes" xml:space="preserve">
          <source>AM/PM symbols</source>
          <target state="translated">AM/PM符号</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="e95867ec94d8c275a2d1d9afac6a1d2ffb7fd390" translate="yes" xml:space="preserve">
          <source>ASCII (Char7)</source>
          <target state="translated">ASCII码 (Char7)</target>
        </trans-unit>
        <trans-unit id="2f934a30b8b57fba10b2b745dc320b339724b1b7" translate="yes" xml:space="preserve">
          <source>ASCII &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt; are all numbers:</source>
          <target state="translated">ASCII &lt;code&gt;'0'&lt;/code&gt; 到 &lt;code&gt;'9'&lt;/code&gt; 都是数字：</target>
        </trans-unit>
        <trans-unit id="cae061a530cef71c477f974034de1fd1d9b43ecb" translate="yes" xml:space="preserve">
          <source>ATOM</source>
          <target state="translated">ATOM</target>
        </trans-unit>
        <trans-unit id="09116156619580f2fa8233d5bca8cf8644f9c359" translate="yes" xml:space="preserve">
          <source>Abandon evaluation of a statement after a breakpoint</source>
          <target state="translated">断点后放弃对语句的评估。</target>
        </trans-unit>
        <trans-unit id="c38c6ea6c11538ed82fd288d53c904871944106f" translate="yes" xml:space="preserve">
          <source>Abandons the current evaluation (only available when stopped at a breakpoint).</source>
          <target state="translated">放弃当前的评估(仅在断点处停止时可用)。</target>
        </trans-unit>
        <trans-unit id="f07c8230701366b843cd68845fafa5d65a1de2d9" translate="yes" xml:space="preserve">
          <source>About validity:</source>
          <target state="translated">关于有效性。</target>
        </trans-unit>
        <trans-unit id="05edf0d68cd3c84475eb832e7d283639e6bdeca9" translate="yes" xml:space="preserve">
          <source>Above, except that if the last line of the first argument stops at least one position before the first line of the second begins, these two lines are overlapped. For example:</source>
          <target state="translated">以上,但如果第一个参数的最后一行在第二个参数的第一行开始前至少一个位置停止,这两行就会重叠。例如:如果第一个参数的最后一行在第二个参数的第一行开始前至少停了一个位置,那么这两行就会重叠。</target>
        </trans-unit>
        <trans-unit id="ef82336eb495d4e5324f732f879ad3b7c7dd9b61" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a7dc34cb7ea60a4e1ddaf0a591cdafbc0e403cf" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2d972269377ed5359cdd2dcc108f0e3936d78b1" translate="yes" xml:space="preserve">
          <source>Above, with no overlapping. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; is associative, with identity &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以上，没有重叠。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 是关联的，标识为 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88874691ade84811a148df43dee3e898c7993db4" translate="yes" xml:space="preserve">
          <source>Above, without dovetailing.</source>
          <target state="translated">以上,没有榫卯。</target>
        </trans-unit>
        <trans-unit id="ffc84c11cb600f5730c837f24132ad44932f0e4a" translate="yes" xml:space="preserve">
          <source>Above; if there is no overlap it &quot;dovetails&quot; the two</source>
          <target state="translated">以上;如果没有重叠,则将两者 &quot;对接&quot;</target>
        </trans-unit>
        <trans-unit id="2c7fe8b95b08b1e64796580d91044372f5603e8d" translate="yes" xml:space="preserve">
          <source>Absolute cursor movements</source>
          <target state="translated">绝对光标移动</target>
        </trans-unit>
        <trans-unit id="44530d6a736fdaae47537dfbad7f8dda6f90c1ca" translate="yes" xml:space="preserve">
          <source>Absolute intervals</source>
          <target state="translated">绝对区间</target>
        </trans-unit>
        <trans-unit id="05675a8df55f00a801d7267f15ceae258c856842" translate="yes" xml:space="preserve">
          <source>Absolute value.</source>
          <target state="translated">绝对值。</target>
        </trans-unit>
        <trans-unit id="be11481292069bbf4e5d32f6f22e3e0ba35a6c06" translate="yes" xml:space="preserve">
          <source>AbsoluteSeek</source>
          <target state="translated">AbsoluteSeek</target>
        </trans-unit>
        <trans-unit id="d18ae99534459c5602deda227d35dbfc2f1e9957" translate="yes" xml:space="preserve">
          <source>AbsoluteTime</source>
          <target state="translated">AbsoluteTime</target>
        </trans-unit>
        <trans-unit id="434cecc208a8b4bb275114bca8d90f1c47541833" translate="yes" xml:space="preserve">
          <source>AbsoluteTime is TAI, time as measured by a clock.</source>
          <target state="translated">AbsoluteTime是TAI,是由时钟测量的时间。</target>
        </trans-unit>
        <trans-unit id="667a8cf10407b19099b8b8a8c853533598abd554" translate="yes" xml:space="preserve">
          <source>Abstract data types can be implemented not only with data declarations, but also newtypes and type synonyms (with the restriction that a type synonym must be fully eta-reduced, e.g., &lt;code&gt;type T = ...&lt;/code&gt; to be accepted.) For example, the following are all valid implementations of the T above:</source>
          <target state="translated">抽象数据类型不仅可以用数据声明来实现，还可以用新类型和类型同义词来实现（但要限制类型同义词必须完全用eta来表示，例如，要接受的 &lt;code&gt;type T = ...&lt;/code&gt; ）。以下是上述T的所有有效实现：</target>
        </trans-unit>
        <trans-unit id="beb8fcf15e248371df65aec656beac0bfea7c0b8" translate="yes" xml:space="preserve">
          <source>Abstract representation of vertices.</source>
          <target state="translated">顶点的抽象表示。</target>
        </trans-unit>
        <trans-unit id="f326ddf7104d3df6fa13479c593c244c4623b73c" translate="yes" xml:space="preserve">
          <source>Abstract syntax definitions for Template Haskell.</source>
          <target state="translated">模板Haskell的抽象语法定义。</target>
        </trans-unit>
        <trans-unit id="71b7aef56068b7e751389cca7071da4abd7a1c80" translate="yes" xml:space="preserve">
          <source>Accept leading and trailing whitespace?</source>
          <target state="translated">接受前导空格和后导空格?</target>
        </trans-unit>
        <trans-unit id="95d34f3b555d7e27b1e17d75f2e37485b204658e" translate="yes" xml:space="preserve">
          <source>Accept leading whitespace?</source>
          <target state="translated">接受前导空格?</target>
        </trans-unit>
        <trans-unit id="bc52205c7ec889cf4cba765533bcd4e5d13957bc" translate="yes" xml:space="preserve">
          <source>Acceptable data</source>
          <target state="translated">可接受的数据</target>
        </trans-unit>
        <trans-unit id="3a8a3f0706793232d22f7100e8ea68a2faa1f5f0" translate="yes" xml:space="preserve">
          <source>Access to GHC's call-stack simulation</source>
          <target state="translated">访问GHC的调用堆栈模拟。</target>
        </trans-unit>
        <trans-unit id="4756089d5cd10709a1d37fad3e346fb021462dee" translate="yes" xml:space="preserve">
          <source>AccessMode</source>
          <target state="translated">AccessMode</target>
        </trans-unit>
        <trans-unit id="f9fce24b3c49b79586973841924c190bcf8769f7" translate="yes" xml:space="preserve">
          <source>Accessing arrays</source>
          <target state="translated">访问数组</target>
        </trans-unit>
        <trans-unit id="aff0bc5a5aaa0b373eac340c6aadb774a3a23049" translate="yes" xml:space="preserve">
          <source>Accessing the pointer to the array contents</source>
          <target state="translated">访问指向数组内容的指针。</target>
        </trans-unit>
        <trans-unit id="3efd139cf44f823a7b553a058c94da8090307f52" translate="yes" xml:space="preserve">
          <source>Accessors to GHC RTS flags. Descriptions of flags can be seen in &lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC User's Guide&lt;/a&gt;, or by running RTS help message using &lt;code&gt;+RTS --help&lt;/code&gt;.</source>
          <target state="translated">GHC RTS标志的访问者。标志的描述可以在《&lt;a href=&quot;https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime_control.html&quot;&gt;GHC用户指南》中找到&lt;/a&gt;，也可以通过使用 &lt;code&gt;+RTS --help&lt;/code&gt; 运行RTS帮助消息来看到。</target>
        </trans-unit>
        <trans-unit id="7edca54ae2bf350d49cd477266ad9dd7d55aedcd" translate="yes" xml:space="preserve">
          <source>According to [1]:</source>
          <target state="translated">根据[1]。</target>
        </trans-unit>
        <trans-unit id="2d6dfb6165d33d7dc1b66480f6a0d421d69dd337" translate="yes" xml:space="preserve">
          <source>According to the GMP documentation, the underlying function &lt;code&gt;mpz_nextprime()&lt;/code&gt; &quot;uses a probabilistic algorithm to identify primes. For practical purposes it's adequate, the chance of a composite passing will be extremely small.&quot;</source>
          <target state="translated">根据GMP文档，底层函数 &lt;code&gt;mpz_nextprime()&lt;/code&gt; &amp;ldquo;使用概率算法来识别素数。出于实际目的，这是足够的，复合传递的机会非常小。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a91ad95de89488856c8210673c103c15b4491b35" translate="yes" xml:space="preserve">
          <source>According to the rules above &lt;code&gt;X&lt;/code&gt; has a CUSK. Yet, the kind of &lt;code&gt;k&lt;/code&gt; is undetermined. It is thus quantified over, giving &lt;code&gt;X&lt;/code&gt; the kind &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt;.</source>
          <target state="translated">根据上面的规则， &lt;code&gt;X&lt;/code&gt; 有一个CUSK。但是， &lt;code&gt;k&lt;/code&gt; 的种类尚未确定。因此，它被量化，给 &lt;code&gt;X&lt;/code&gt; 表示所有 &lt;code&gt;forall k1 (k :: k1). Proxy k -&amp;gt; Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d5e0f0e68219f2793950ff4f739b0707416bc38" translate="yes" xml:space="preserve">
          <source>Accordingly, the rule for kind quantification in higher-rank contexts has changed slightly. In GHC 7, if a kind variable was mentioned for the first time in the kind of a variable bound in a non-top-level &lt;code&gt;forall&lt;/code&gt;, the kind variable was bound there, too. That is, in &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; was bound by the same &lt;code&gt;forall&lt;/code&gt; as the &lt;code&gt;a&lt;/code&gt;. In GHC 8, however, all kind variables mentioned in a type are bound at the outermost level. If you want one bound in a higher-rank &lt;code&gt;forall&lt;/code&gt;, include it explicitly.</source>
          <target state="translated">因此，在较高等级的环境中进行种类量化的规则已略有变化。在GHC 7中，如果第一次在非顶级 &lt;code&gt;forall&lt;/code&gt; 中绑定的变量的种类中提到了种类变量，则该种类变量也在那里绑定。即，在 &lt;code&gt;f :: (forall (a :: k). ...) -&amp;gt; ...&lt;/code&gt; 中， &lt;code&gt;k&lt;/code&gt; 用相同结合 &lt;code&gt;forall&lt;/code&gt; 作为 &lt;code&gt;a&lt;/code&gt; 。但是，在GHC 8中，类型中提到的所有种类变量都绑定在最外层。如果要在较高级别的 &lt;code&gt;forall&lt;/code&gt; 中绑定一个，请明确包括它。</target>
        </trans-unit>
        <trans-unit id="1bb0023c7c1fa4cd60dd0df32c9589498220f1d0" translate="yes" xml:space="preserve">
          <source>Accordingly, the type environment seen by &lt;code&gt;reify&lt;/code&gt; includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</source>
          <target state="translated">因此， &lt;code&gt;reify&lt;/code&gt; 看到的类型环境包括直到最前面的声明组末尾的所有顶级声明，但不包含更多顶级声明。</target>
        </trans-unit>
        <trans-unit id="82bedfe88009972d90237d52b7f414b23e6d5eb6" translate="yes" xml:space="preserve">
          <source>Accum</source>
          <target state="translated">Accum</target>
        </trans-unit>
        <trans-unit id="50b4f3d88aa3c9059e12c063f7c950d2f9b4b778" translate="yes" xml:space="preserve">
          <source>Accum operations</source>
          <target state="translated">累计业务</target>
        </trans-unit>
        <trans-unit id="cd4bf7ea6fd4060189e1e1baaa24ebb42d7660ad" translate="yes" xml:space="preserve">
          <source>AccumT</source>
          <target state="translated">AccumT</target>
        </trans-unit>
        <trans-unit id="50412c7500ef5d04ef8c2e37d60a2b1db38c9207" translate="yes" xml:space="preserve">
          <source>Accumulating maps</source>
          <target state="translated">累积地图</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="6347206826a895475f5f91774a889e897ffc7d63" translate="yes" xml:space="preserve">
          <source>Action &lt;code&gt;askString&lt;/code&gt; requests user to enter a string, and passes it to the continuation. &lt;code&gt;askString&lt;/code&gt; takes as a parameter a continuation taking a string parameter, and returning &lt;code&gt;IO ()&lt;/code&gt;. Compare its signature to &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; definition.</source>
          <target state="translated">动作 &lt;code&gt;askString&lt;/code&gt; 请求用户输入一个字符串，并将其传递给延续。 &lt;code&gt;askString&lt;/code&gt; 接受带有字符串参数并返回 &lt;code&gt;IO ()&lt;/code&gt; 的延续作为参数。将其签名与 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:runContT&quot;&gt;runContT&lt;/a&gt;&lt;/code&gt; 定义进行比较。</target>
        </trans-unit>
        <trans-unit id="a2f1b38e49644d95f7b46650e509c991d77060f8" translate="yes" xml:space="preserve">
          <source>Action to be executed</source>
          <target state="translated">有待执行的行动</target>
        </trans-unit>
        <trans-unit id="f5278c8649d913f335c11a62f866017db4429c6b" translate="yes" xml:space="preserve">
          <source>Actions on directories</source>
          <target state="translated">关于目录的行动</target>
        </trans-unit>
        <trans-unit id="696ed90b8efd0baea13c573b2e7c286d011d6b3c" translate="yes" xml:space="preserve">
          <source>Actions on files</source>
          <target state="translated">对档案采取的行动</target>
        </trans-unit>
        <trans-unit id="7083b72c48cfaf651eebc9aa10754311beefc8de" translate="yes" xml:space="preserve">
          <source>Activate cross-compilation mode (see &lt;a href=&quot;#hsc2hs-cross&quot;&gt;Cross-compilation&lt;/a&gt;).</source>
          <target state="translated">激活交叉编译模式（请参阅&lt;a href=&quot;#hsc2hs-cross&quot;&gt;交叉编译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="583d9a705b86bbdfe3e1d9047b3ea1485ccadeeb" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; ,除非 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 引用符号链接。在这种情况下，将返回符号链接本身的 &lt;code&gt;FileStatus&lt;/code&gt; 信息，而不是它所指向的文件的信息。</target>
        </trans-unit>
        <trans-unit id="7d65523818024ea88107f6287927f036ddf6afd4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb8dd245b9cb57f179bf3b4b88042343c063795" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接（因此更改了链接本身的权限）。</target>
        </trans-unit>
        <trans-unit id="00b98c6571c6f97fdd25d5e837fe03213c325e22" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; except when the &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; refers to a symbolic link. In that case the &lt;code&gt;FileStatus&lt;/code&gt; information of the symbolic link itself is returned instead of that of the file it points to.</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:getFileStatus&quot;&gt;getFileStatus&lt;/a&gt;&lt;/code&gt; ,除非 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring-filepath#t:RawFilePath&quot;&gt;RawFilePath&lt;/a&gt;&lt;/code&gt; 引用符号链接。在这种情况下，将返回符号链接本身的 &lt;code&gt;FileStatus&lt;/code&gt; 信息，而不是它所指向的文件的信息。</target>
        </trans-unit>
        <trans-unit id="cbcea92f66c4289d12fcd3463f6bb4e3fab3bda6" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; but does not follow symlinks (and thus changes permissions on the link itself).</source>
          <target state="translated">充当 &lt;code&gt;&lt;a href=&quot;system-posix-files-bytestring#v:setOwnerAndGroup&quot;&gt;setOwnerAndGroup&lt;/a&gt;&lt;/code&gt; ,但不遵循符号链接（因此更改了链接本身的权限）。</target>
        </trans-unit>
        <trans-unit id="6a6c3ff29419f1c7034849f1db0a070b794f9ad2" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">充当 &lt;code&gt;setFileSize&lt;/code&gt; ,但使用文件描述符而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49be567080d7b410e84b47729961520e4de920c4" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setFileSize&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b7078adb2d96736d050720e01d8ae82392b27c" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">充当 &lt;code&gt;setOwnerAndGroup&lt;/code&gt; ,但使用文件描述符而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f40c80358e12a1e2aaf02b1148d6c20fcfd4ba45" translate="yes" xml:space="preserve">
          <source>Acts as &lt;code&gt;setOwnerAndGroup&lt;/code&gt; but uses a file descriptor instead of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce17679436ea260fadec4591a677de22164d0f8" translate="yes" xml:space="preserve">
          <source>Actually &lt;code&gt;hsc2hs&lt;/code&gt; does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code.</source>
          <target state="translated">实际上， &lt;code&gt;hsc2hs&lt;/code&gt; 不会直接输出Haskell文件。它创建一个包含头文件的C程序，并自动进行编译和运行。该程序输出Haskell代码。</target>
        </trans-unit>
        <trans-unit id="eb4c8a6633849d6709d07c9f3e63104f63a51077" translate="yes" xml:space="preserve">
          <source>Add a finalizer that will run in the Q monad after the current module has been type checked. This only makes sense when run within a top-level splice.</source>
          <target state="translated">增加一个定型器,它将在当前模块被类型检查后在Q单体中运行。这只有在顶层拼接中运行时才有意义。</target>
        </trans-unit>
        <trans-unit id="de0de177dcddf4173fd744c404b8ba61f96637ed" translate="yes" xml:space="preserve">
          <source>Add a finalizer to an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; (GHC only). See &lt;a href=&quot;foreign-foreignptr&quot;&gt;Foreign.ForeignPtr&lt;/a&gt; and &lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt; for more about finalizers.</source>
          <target state="translated">将终结器添加到 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; （仅适用于GHC）。有关&lt;a href=&quot;foreign-foreignptr&quot;&gt;终结&lt;/a&gt;器的更多信息，请参见Foreign.ForeignPtr和&lt;a href=&quot;system-mem-weak&quot;&gt;System.Mem.Weak&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87eb63d6dca38f792891dceb6d3068ba951d4549" translate="yes" xml:space="preserve">
          <source>Add a line to the history unless it matches the previously recorded line.</source>
          <target state="translated">在历史记录中添加一行,除非它与之前记录的行相匹配。</target>
        </trans-unit>
        <trans-unit id="aaca03fa0d32c5a3d402a6fb5fcc0ded2bb915ec" translate="yes" xml:space="preserve">
          <source>Add a line to the history, and remove all previous entries which are the same as it.</source>
          <target state="translated">在历史记录中添加一行,并删除所有与之相同的先前条目。</target>
        </trans-unit>
        <trans-unit id="1d7fd5dfa46b0f645d5db42f20504f6c3caf7358" translate="yes" xml:space="preserve">
          <source>Add a trailing file path separator if one is not already present.</source>
          <target state="translated">如果没有尾部的文件路径分隔符,则添加一个尾部的文件路径分隔符。</target>
        </trans-unit>
        <trans-unit id="c5f1a8ca3a641a6b0ef6dbe461171ca7f604eb5a" translate="yes" xml:space="preserve">
          <source>Add additional top-level declarations. The added declarations will be type checked along with the current declaration group.</source>
          <target state="translated">添加额外的顶层声明。增加的声明将与当前声明组一起进行类型检查。</target>
        </trans-unit>
        <trans-unit id="cecd1aea8fe88c39fcc8f71681a3e087791c984b" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使已有扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34878ebb3f1e96601aafa913d00d7bd263cdc36c" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使存在扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89357b09335d29d387cf17547863b974b8decc59" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使已有扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:-60-.-62-&quot;&gt;&amp;lt;.&amp;gt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e0f266814b31f57d2a4d4f2e065ebded03e6c4" translate="yes" xml:space="preserve">
          <source>Add an extension, even if there is already one there, equivalent to &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">即使存在扩展名，也要添加一个扩展名，等同于 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:addExtension&quot;&gt;addExtension&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88bd486d89c4fede722e2d2391a03c0fd1f29c23" translate="yes" xml:space="preserve">
          <source>Add entries to the Static Pointer Table</source>
          <target state="translated">向静态指针表添加条目。</target>
        </trans-unit>
        <trans-unit id="573b000c455e2582361374a0f2d5ce932b4443a5" translate="yes" xml:space="preserve">
          <source>Add months (clipped to last day), then add days</source>
          <target state="translated">添加月份(剪到最后一天),然后添加天数。</target>
        </trans-unit>
        <trans-unit id="11f2dacfd6ba9147a205050f051361aedae62583" translate="yes" xml:space="preserve">
          <source>Add months (rolling over to next month), then add days</source>
          <target state="translated">添加月份(滚动到下个月),然后添加天数。</target>
        </trans-unit>
        <trans-unit id="b015364a9bf90321fb61c3a98f1cdc612fdf7a8d" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.</source>
          <target state="translated">加月份,过了月份最后一天的天数剪到最后一天。例如,2005-01-30+1个月=2005-02-28。</target>
        </trans-unit>
        <trans-unit id="1ce9d4dd3c00c35abdeda445f12f814c42604388" translate="yes" xml:space="preserve">
          <source>Add months, with days past the last day of the month rolling over to the next month. For instance, 2005-01-30 + 1 month = 2005-03-02.</source>
          <target state="translated">加月份,超过当月最后一天的天数滚入下个月。例如,2005-01-30+1个月=2005-03-02。</target>
        </trans-unit>
        <trans-unit id="45aa2700c673ebfa0acebc5efea925be3a17cb6f" translate="yes" xml:space="preserve">
          <source>Add one to the given number using the state monad:</source>
          <target state="translated">使用状态单体在给定的数字上加一。</target>
        </trans-unit>
        <trans-unit id="ad0277793f67d2e393175d08b52db34131c5ef10" translate="yes" xml:space="preserve">
          <source>Add signed integers reporting overflow. First member of result is the sum truncated to an &lt;code&gt;Int#&lt;/code&gt;; second member is zero if the true sum fits in an &lt;code&gt;Int#&lt;/code&gt;, nonzero if overflow occurred (the sum is either too large or too small to fit in an &lt;code&gt;Int#&lt;/code&gt;).</source>
          <target state="translated">添加有符号整数报告溢出。结果的第一个成员是被截断为 &lt;code&gt;Int#&lt;/code&gt; 的总和；如果真正的总和适合 &lt;code&gt;Int#&lt;/code&gt; ，则第二个成员为零；如果发生溢出，则第二个成员为非零（总和太大或太小而无法适合 &lt;code&gt;Int#&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0fcd5e56314036018a9f0cac00e78ef55a1787b" translate="yes" xml:space="preserve">
          <source>Add some helper code that starts up and shuts down the Haskell RTS:</source>
          <target state="translated">增加一些启动和关闭Haskell RTS的助手代码。</target>
        </trans-unit>
        <trans-unit id="985586c7f3031f00d6269e644d3adc10e6ea07bc" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS option when running the program to see timing stats, which will help to tell you whether your program got faster by using more CPUs or not. If the user time is greater than the elapsed time, then the program used more than one CPU. You should also run the program without &lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt;&lt;code&gt;-N ⟨x⟩&lt;/code&gt;&lt;/a&gt; for comparison.</source>
          <target state="translated">运行程序时添加 &lt;code&gt;-s [⟨file⟩]&lt;/code&gt; RTS选项以查看计时统计信息，这将有助于告诉您程序是否通过使用更多的CPU来加快速度。如果用户时间大于经过时间，则该程序使用了多个CPU。您还应该运行不带&lt;a href=&quot;#rts-flag--N%20%E2%9F%A8x%E2%9F%A9&quot;&gt; &lt;code&gt;-N ⟨x⟩&lt;/code&gt; &lt;/a&gt;的程序进行比较。</target>
        </trans-unit>
        <trans-unit id="343b1a229f6a10110d459f27e6591278cc0810b3" translate="yes" xml:space="preserve">
          <source>Add the global package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt;&lt;code&gt;-no-global-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the global package database should be loaded.</source>
          <target state="translated">将全局软件包数据库添加到当前堆栈的顶部。在&lt;a href=&quot;#ghc-flag--no-global-package-db&quot;&gt; &lt;code&gt;-no-global-package-db&lt;/code&gt; &lt;/a&gt;之后，可以使用此选项来指定堆栈中应装入全局软件包数据库的位置。</target>
        </trans-unit>
        <trans-unit id="24dc1f25cbb780084188d4ff897a81d5104622f0" translate="yes" xml:space="preserve">
          <source>Add the global package db to the stack.</source>
          <target state="translated">将全局包db添加到栈中。</target>
        </trans-unit>
        <trans-unit id="fe975763255492732af82ca06ecb5eda5e5fa904" translate="yes" xml:space="preserve">
          <source>Add the package database ⟨file⟩ on top of the current stack.</source>
          <target state="translated">在当前堆栈的基础上添加包数据库⟨file⟩。</target>
        </trans-unit>
        <trans-unit id="6134bf2d1b2295efc8fa6b7e828ec4d22ba2e38e" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package database on top of the current stack. This option can be used after &lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt;&lt;code&gt;-no-user-package-db&lt;/code&gt;&lt;/a&gt; to specify the position in the stack where the user&amp;rsquo;s package database should be loaded.</source>
          <target state="translated">将用户的软件包数据库添加到当前堆栈的顶部。可以在&lt;a href=&quot;#ghc-flag--no-user-package-db&quot;&gt; &lt;code&gt;-no-user-package-db&lt;/code&gt; &lt;/a&gt;之后使用此选项，以指定堆栈中应装载用户的软件包数据库的位置。</target>
        </trans-unit>
        <trans-unit id="30d336c4a71c8e660819935f8d9b591c05d3839d" translate="yes" xml:space="preserve">
          <source>Add the user&amp;rsquo;s package db to the stack.</source>
          <target state="translated">将用户的程序包db添加到堆栈中。</target>
        </trans-unit>
        <trans-unit id="f0c714c0819e829fa65b99edbce416f762fa1cd5" translate="yes" xml:space="preserve">
          <source>Add the user's package db to the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e83704b0c13e474a873f78d2503ff9d5058a2e" translate="yes" xml:space="preserve">
          <source>Add two &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">添加两个 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="42140a41e27de0c19e086f86091f816243e8209e" translate="yes" xml:space="preserve">
          <source>Add two non-negative numbers. Errors out on overflow.</source>
          <target state="translated">加两个非负数。溢出时出错。</target>
        </trans-unit>
        <trans-unit id="e2856c1714aa39e0ac4378840b55f10a1492a342" translate="yes" xml:space="preserve">
          <source>Add two vectors element-wise.</source>
          <target state="translated">将两个向量元素相加。</target>
        </trans-unit>
        <trans-unit id="d21ffb0b2e887326fe4eaccd172c45b78c0f6321" translate="yes" xml:space="preserve">
          <source>Add unsigned integers reporting overflow. The first element of the pair is the result. The second element is the carry flag, which is nonzero on overflow. See also &lt;code&gt;plusWord2#&lt;/code&gt;.</source>
          <target state="translated">添加无符号整数报告溢出。该对中的第一个元素是结果。第二个元素是进位标志，溢出时非零。另请参见 &lt;code&gt;plusWord2#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4224f11c255c4982dd554902608b0a229771245f" translate="yes" xml:space="preserve">
          <source>Add unsigned integers, with the high part (carry) in the first component of the returned pair and the low part in the second component of the pair. See also &lt;code&gt;addWordC#&lt;/code&gt;.</source>
          <target state="translated">添加无符号整数，在返回的对的第一部分的高位（进位），在对的第二部分的低位。另请参见 &lt;code&gt;addWordC#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7bc6acbb336def5a2fed21adc84cf2eba8c8695" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th clipped to Feb 28th if necessary. For instance, 2004-02-29 + 2 years = 2006-02-28.</source>
          <target state="translated">加年份,匹配月份和日期,必要时将2月29日剪到2月28日。例如:2004-02-29+2年=2006-02-28。</target>
        </trans-unit>
        <trans-unit id="00a5a0f630ddf36709167f1d67babdf5ba438d3b" translate="yes" xml:space="preserve">
          <source>Add years, matching month and day, with Feb 29th rolled over to Mar 1st if necessary. For instance, 2004-02-29 + 2 years = 2006-03-01.</source>
          <target state="translated">加年份,匹配月份和日期,必要时2月29日滚到3月1日。例如:2004-02-29+2年=2006-03-01。</target>
        </trans-unit>
        <trans-unit id="b78eacb0dc09583fbc5860e25537c0fbd17b2217" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the directory search list for &lt;code&gt;#include&lt;/code&gt; files</source>
          <target state="translated">将⟨dir⟩添加到 &lt;code&gt;#include&lt;/code&gt; 文件的目录搜索列表中</target>
        </trans-unit>
        <trans-unit id="3af3cf99d9bd473db5a8f166f611704c815a0e2a" translate="yes" xml:space="preserve">
          <source>Add ⟨dir⟩ to the list of directories searched for libraries</source>
          <target state="translated">将⟨dir⟩添加到搜索库的目录列表中。</target>
        </trans-unit>
        <trans-unit id="22a6f927fd045f27916f2841389ceb5619f2f520" translate="yes" xml:space="preserve">
          <source>Add ⟨file⟩ to the package db stack.</source>
          <target state="translated">将⟨file⟩添加到包中的db栈中。</target>
        </trans-unit>
        <trans-unit id="fd862d70f0a0e1b3f98b9cfd9a82f7a12719414c" translate="yes" xml:space="preserve">
          <source>Add ⟨module⟩(s) to the current target set, and perform a reload. Normally pre-compiled code for the module will be loaded if available, or otherwise the module will be compiled to byte-code. Using the &lt;code&gt;*&lt;/code&gt; prefix forces the module to be loaded as byte-code.</source>
          <target state="translated">将&amp;ldquo;模块&amp;rdquo;添加到当前目标集中，然后执行重新加载。通常，将加载模块的预编译代码（如果可用），否则，模块将被编译为字节码。使用 &lt;code&gt;*&lt;/code&gt; 前缀将强制模块以字节码加载。</target>
        </trans-unit>
        <trans-unit id="d5c0d264184b29e5240b822c85a976bae183083b" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior.</source>
          <target state="translated">添加 &lt;code&gt;~&lt;/code&gt; 前面 &lt;code&gt;x&lt;/code&gt; 给出了经常偷懒行为。</target>
        </trans-unit>
        <trans-unit id="320069f40befc715427528e74af5fccc8e33c273" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;~&lt;/code&gt; in front of &lt;code&gt;x&lt;/code&gt; gives the regular lazy behavior. The general rule is that we add an implicit bang on the outermost pattern, unless disabled with &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">添加 &lt;code&gt;~&lt;/code&gt; 前面 &lt;code&gt;x&lt;/code&gt; 给出了经常偷懒行为。一般规则是，除非在 &lt;code&gt;~&lt;/code&gt; 禁用，否则我们在最外面的模式上添加一个隐式爆炸。</target>
        </trans-unit>
        <trans-unit id="d83058e490d2d8e416a97aa6b2da12e694c423cc" translate="yes" xml:space="preserve">
          <source>Adding a new kind of pure computation to an applicative functor.</source>
          <target state="translated">将一种新的纯计算添加到一个应用型漏子中。</target>
        </trans-unit>
        <trans-unit id="3e22ec51f6417f07ed5484e9c1f31e458834a41e" translate="yes" xml:space="preserve">
          <source>Adding a type signature dramatically changes the result! This is a rather counter-intuitive phenomenon, worth watching out for.</source>
          <target state="translated">添加类型签名会极大地改变结果! 这是一个比较反常的现象,值得注意。</target>
        </trans-unit>
        <trans-unit id="99385bb5ea9d50b509bba76a80c6d5cf02fdad9b" translate="yes" xml:space="preserve">
          <source>Adding the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo; turns type errors into warnings while loading. This allows to use the portions of the module that are correct, even if there are type errors in some definitions. Effectively, the &amp;ldquo;-fdefer-type-errors&amp;rdquo; flag is set before loading and unset after loading if the flag has not already been set before. See &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;Deferring type errors to runtime&lt;/a&gt; for further motivation and details.</source>
          <target state="translated">添加可选的&amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;会在加载时将类型错误转换为警告。即使某些定义中存在类型错误，这也允许使用模块的正确部分。实际上，&amp;ldquo;-fdefer-type-errors&amp;rdquo;标志是在加载之前设置的，如果之前尚未设置，则在加载之后取消设置。有关进一步的动机和详细信息，请参见将&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;类型错误延迟到运行时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00f220c3a56210a9843d04890d61a40e6f8811dd" translate="yes" xml:space="preserve">
          <source>Addition of type-level naturals.</source>
          <target state="translated">增加类型级别的自然人。</target>
        </trans-unit>
        <trans-unit id="1d55c4561961d726b476a4d113ce4ac1271e1f3d" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;Integer&lt;/code&gt; operations</source>
          <target state="translated">其他 &lt;code&gt;Integer&lt;/code&gt; 运算</target>
        </trans-unit>
        <trans-unit id="452f31724597f25fbb7b21a77fe4b6fccc9c9f11" translate="yes" xml:space="preserve">
          <source>Additional arguments to the pre-processor can be passed in using the &lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt;&lt;code&gt;-optF ⟨option⟩&lt;/code&gt;&lt;/a&gt; option. These are fed to ⟨cmd⟩ on the command line after the three standard input and output arguments.</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghc-flag--optF%20%E2%9F%A8option%E2%9F%A9&quot;&gt; &lt;code&gt;-optF ⟨option⟩&lt;/code&gt; &lt;/a&gt;选项将其他参数传递给预处理器。在三个标准输入和输出参数之后，这些参数将被馈送到命令行上的&amp;ldquo; cmd&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ba84f116cccb8aaddf33910d85c19273f9b5c33d" translate="yes" xml:space="preserve">
          <source>Additional conversion operations to &lt;code&gt;Integer&lt;/code&gt;</source>
          <target state="translated">附加到 &lt;code&gt;Integer&lt;/code&gt; 转换操作</target>
        </trans-unit>
        <trans-unit id="05dd2fde350699cecd8602584538e2a5301a7997" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得用于解构序列的其他功能。</target>
        </trans-unit>
        <trans-unit id="5cf2915563496656545c5e0888c8da42599eb5f8" translate="yes" xml:space="preserve">
          <source>Additional functions for deconstructing sequences are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33810ea2f256277dbeeee354b4b9748e64cd54e7" translate="yes" xml:space="preserve">
          <source>Additional generic representation type constructors</source>
          <target state="translated">额外的通用表示类型构造器</target>
        </trans-unit>
        <trans-unit id="fefa8177b546e09c697ef3ccda7dfb9a8468dadd" translate="yes" xml:space="preserve">
          <source>Additional submodules</source>
          <target state="translated">其他子模块</target>
        </trans-unit>
        <trans-unit id="d5fc75cb6b2328204ad6e4f5c7b8aa1503974318" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;ghc-pkg list&lt;/code&gt; reminds you that there are broken packages and suggests &lt;code&gt;ghc-pkg check&lt;/code&gt;, which displays more information about the nature of the failure:</source>
          <target state="translated">此外， &lt;code&gt;ghc-pkg list&lt;/code&gt; 会提醒您有损坏的软件包，并建议 &lt;code&gt;ghc-pkg check&lt;/code&gt; ，它显示有关故障性质的更多信息：</target>
        </trans-unit>
        <trans-unit id="4dc57812bc7acb080b8b1b3c9a8dc29f687921a8" translate="yes" xml:space="preserve">
          <source>Additionally, any files specified with &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; flags will be read after the standard files, allowing the use of custom .ghci files.</source>
          <target state="translated">此外，将在标准文件之后读取用&lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt;标志指定的所有文件，从而允许使用自定义.ghci文件。</target>
        </trans-unit>
        <trans-unit id="8273902569bf382d8f68303982acb32861c6cbb8" translate="yes" xml:space="preserve">
          <source>Additionally, in function definitions, variables bound by matching earlier curried arguments may be used in view pattern expressions in later arguments:</source>
          <target state="translated">此外,在函数定义中,通过匹配前面的策源地参数所绑定的变量可以在后面的参数中使用视图模式表达式。</target>
        </trans-unit>
        <trans-unit id="f89673843f1be6757860a64501f5bc027e357960" translate="yes" xml:space="preserve">
          <source>Additionally, the following flags are accepted by &lt;code&gt;ghc-pkg&lt;/code&gt;:</source>
          <target state="translated">此外， &lt;code&gt;ghc-pkg&lt;/code&gt; 接受以下标志：</target>
        </trans-unit>
        <trans-unit id="6098dd57b05f9b5adb478e7eb1c70e1499221dae" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;#10826&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea07a4f598cd1862ca91a8d811d4455a836c0db0" translate="yes" xml:space="preserve">
          <source>Additionally, the use of &lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;annotations&lt;/a&gt; is forbidden, as that would allow bypassing Safe Haskell restrictions. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;Issue #10826&lt;/a&gt; for details.</source>
          <target state="translated">此外，禁止使用&lt;a href=&quot;extending_ghc#annotation-pragmas&quot;&gt;注释&lt;/a&gt;，因为这样可以绕过Safe Haskell限制。有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10826&quot;&gt;问题＃10826&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba7d071e5cf6b03c15819e3ffdf6a64a0ef17bfa" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduce memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">此外,这种实现将位图放在树叶中。它们的大小是机器字的自然大小(32位或64位),并大大减少了密集集的内存占用和执行时间,例如,许多值很可能相互靠近的集。渐近论不受这种优化的影响。</target>
        </trans-unit>
        <trans-unit id="9433cfd346f8c54358a2f7edce3cb77efb148924" translate="yes" xml:space="preserve">
          <source>Additionally, this implementation places bitmaps in the leaves of the tree. Their size is the natural size of a machine word (32 or 64 bits) and greatly reduces the memory footprint and execution times for dense sets, e.g. sets where it is likely that many values lie close to each other. The asymptotics are not affected by this optimization.</source>
          <target state="translated">此外,这种实现将位图放在树叶中。它们的大小是机器字的自然大小(32位或64位),并大大减少了密集集的内存占用和执行时间,例如,许多值很可能相互靠近的集。渐近论不受这种优化的影响。</target>
        </trans-unit>
        <trans-unit id="1bf2d76785594ad916dd8c2e5e99f51e13db7893" translate="yes" xml:space="preserve">
          <source>Additionally, unless &lt;code&gt;-hide-all-packages&lt;/code&gt; is specified &lt;code&gt;ghc&lt;/code&gt; will also look for the package environment in the following locations:</source>
          <target state="translated">另外，除非指定了 &lt;code&gt;-hide-all-packages&lt;/code&gt; ，否则 &lt;code&gt;ghc&lt;/code&gt; 还将在以下位置查找软件包环境：</target>
        </trans-unit>
        <trans-unit id="2aa983ad06fdb2dac09d7b6232814da70747e9ee" translate="yes" xml:space="preserve">
          <source>Additive</source>
          <target state="translated">Additive</target>
        </trans-unit>
        <trans-unit id="0d42cec26dbc762aafe43e05a50f969d0b7505d7" translate="yes" xml:space="preserve">
          <source>Addr</source>
          <target state="translated">Addr</target>
        </trans-unit>
        <trans-unit id="e78f3509a8a9919b87bca8268eb67a1992a398dd" translate="yes" xml:space="preserve">
          <source>Addr#</source>
          <target state="translated">Addr#</target>
        </trans-unit>
        <trans-unit id="9693f97edb3f213e60bf04638a2964d95c0a8e70" translate="yes" xml:space="preserve">
          <source>AddrRep</source>
          <target state="translated">AddrRep</target>
        </trans-unit>
        <trans-unit id="e1bcdaba63c737122befb027c96355aebd956e8a" translate="yes" xml:space="preserve">
          <source>Address range information necessary for efficient lookup in debug information.</source>
          <target state="translated">调试信息中有效查找所需的地址范围信息。</target>
        </trans-unit>
        <trans-unit id="2bea019ec2ca9ce8cba25638cef6e4ebf912a40d" translate="yes" xml:space="preserve">
          <source>Adds a core plugin to the compilation pipeline.</source>
          <target state="translated">为编译管道添加一个核心插件。</target>
        </trans-unit>
        <trans-unit id="f141d838836915fbdfd335ae66e883d10b2bee58" translate="yes" xml:space="preserve">
          <source>Adds a location description and maybe a file path and file handle to an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;. If any of the file handle or file path is not given the corresponding value in the &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; remains unaltered.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 添加位置描述，可能还添加文件路径和文件句柄。如果未提供任何文件句柄或文件路径，则 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中的相应值将保持不变。</target>
        </trans-unit>
        <trans-unit id="14518bca79b10a8d6a6afac2dc2d74ba60c9789a" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="translated">向所有&lt;em&gt;呼叫站点&lt;/em&gt;添加自动 &lt;code&gt;SCC&lt;/code&gt; 注释。当使用概要分析来生成堆栈跟踪时，这特别有用。有关更多详细信息，请参见函数&lt;a href=&quot;../libraries/base-4.13.0.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;或&lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt; &lt;code&gt;-xc&lt;/code&gt; &lt;/a&gt; RTS标志（&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;黑客，调试器和过度关注的灵魂的RTS选项&lt;/a&gt;）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4dd58b10c5df43531b5419e150eab3428f317659" translate="yes" xml:space="preserve">
          <source>Adds an automatic &lt;code&gt;SCC&lt;/code&gt; annotation to all &lt;em&gt;call sites&lt;/em&gt;. This is particularly useful when using profiling for the purposes of generating stack traces; see the function &lt;a href=&quot;../libraries/base-4.14.1.0/debug-trace#v:traceShow&quot;&gt;Debug.Trace.traceShow&lt;/a&gt;, or the &lt;a href=&quot;runtime_control#rts-flag--xc&quot;&gt;&lt;code&gt;-xc&lt;/code&gt;&lt;/a&gt; RTS flag (&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;) for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fd2a08806dfb482db344074817b7f6e5c01441" translate="yes" xml:space="preserve">
          <source>Adds ⟨file⟩ to the stack of package databases. Additionally, ⟨file⟩ will also be the database modified by a &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;unregister&lt;/code&gt;, &lt;code&gt;expose&lt;/code&gt; or &lt;code&gt;hide&lt;/code&gt; command, unless it is overridden by a later &lt;code&gt;--package-db&lt;/code&gt;, &lt;code&gt;--user&lt;/code&gt; or &lt;code&gt;--global&lt;/code&gt; option.</source>
          <target state="translated">将&amp;ldquo; file&amp;rdquo;添加到软件包数据库堆栈中。此外，⟨file⟩也将是由一个修改了数据库 &lt;code&gt;register&lt;/code&gt; ， &lt;code&gt;unregister&lt;/code&gt; ， &lt;code&gt;expose&lt;/code&gt; 或 &lt;code&gt;hide&lt;/code&gt; 命令，除非它受到一个后覆盖 &lt;code&gt;--package-db&lt;/code&gt; ， &lt;code&gt;--user&lt;/code&gt; 或 &lt;code&gt;--global&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="6b704187610182fd9bd374b8590aaa1ef187a2e9" translate="yes" xml:space="preserve">
          <source>Adjacency list representation of a graph, mapping each vertex to its list of successors.</source>
          <target state="translated">图的邻接列表表示,将每个顶点映射到它的后继列表。</target>
        </trans-unit>
        <trans-unit id="b54a06cdf203c292a9600afc8f4877852335267a" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array</source>
          <target state="translated">调整阵列的大小</target>
        </trans-unit>
        <trans-unit id="90ae8e7c61f1d870875dbba75294d0ee30d78240" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array in the given pool.</source>
          <target state="translated">调整给定池中数组的大小。</target>
        </trans-unit>
        <trans-unit id="0f13658ace97bdbb476bffd14472478597823d14" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array including an extra position for the end marker.</source>
          <target state="translated">调整数组的大小,包括结束标记的额外位置。</target>
        </trans-unit>
        <trans-unit id="8f64f3b151b220c78b035080db416951b86c9133" translate="yes" xml:space="preserve">
          <source>Adjust the size of an array with an end marker in the given pool.</source>
          <target state="translated">在给定的池子中调整一个带有结束标记的数组的大小。</target>
        </trans-unit>
        <trans-unit id="22c056b1203c0d0dbe4975dcb12541b083750969" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size of the required type.</source>
          <target state="translated">将池中元素的存储区域调整为所需类型的给定大小。</target>
        </trans-unit>
        <trans-unit id="7b78d30e021c76a4d2cd9b8d7c83d0401635e998" translate="yes" xml:space="preserve">
          <source>Adjust the storage area for an element in the pool to the given size.</source>
          <target state="translated">将池中元素的存储区域调整为给定大小。</target>
        </trans-unit>
        <trans-unit id="483b6c748f94c6096a813d4e1202da0abec1197a" translate="yes" xml:space="preserve">
          <source>Administration: errors, locations and IO</source>
          <target state="translated">管理:错误、位置和IO</target>
        </trans-unit>
        <trans-unit id="e796c7c730ff7dabd900a81e118126dd63495d56" translate="yes" xml:space="preserve">
          <source>Advance a pointer into an array by the given number of elements</source>
          <target state="translated">将指针按给定的元素数推进到数组中。</target>
        </trans-unit>
        <trans-unit id="260fc09cb1bd463d426655ad971e67b80c27f04d" translate="yes" xml:space="preserve">
          <source>Advances the given address by the given offset in bytes.</source>
          <target state="translated">将给定的地址以字节为单位向前推进。</target>
        </trans-unit>
        <trans-unit id="8295b736050208f7764a760aab4c1497c80f65b8" translate="yes" xml:space="preserve">
          <source>Advice</source>
          <target state="translated">Advice</target>
        </trans-unit>
        <trans-unit id="1f3b7ab3442ed00e15ed0541b2686cab5245f648" translate="yes" xml:space="preserve">
          <source>Advice parameter for &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; 操作的Advice参数。</target>
        </trans-unit>
        <trans-unit id="641791da837ed200728e9e50c3a7a04bddd511ba" translate="yes" xml:space="preserve">
          <source>AdviceDontNeed</source>
          <target state="translated">AdviceDontNeed</target>
        </trans-unit>
        <trans-unit id="ea4292d4f711440375ee49d21953e80b5e52f970" translate="yes" xml:space="preserve">
          <source>AdviceNoReuse</source>
          <target state="translated">AdviceNoReuse</target>
        </trans-unit>
        <trans-unit id="74d7e2511ff18bffd6e754606fb5eef4017e56ae" translate="yes" xml:space="preserve">
          <source>AdviceNormal</source>
          <target state="translated">AdviceNormal</target>
        </trans-unit>
        <trans-unit id="81df8c0f743f838767314197c10a01806cad2ee1" translate="yes" xml:space="preserve">
          <source>AdviceRandom</source>
          <target state="translated">AdviceRandom</target>
        </trans-unit>
        <trans-unit id="ccfd39209774bc0bd28a1949494a57c9a708ab38" translate="yes" xml:space="preserve">
          <source>AdviceSequential</source>
          <target state="translated">AdviceSequential</target>
        </trans-unit>
        <trans-unit id="42c90330aa2e9c8f79a56b93334f2cee6565ec83" translate="yes" xml:space="preserve">
          <source>AdviceWillNeed</source>
          <target state="translated">AdviceWillNeed</target>
        </trans-unit>
        <trans-unit id="ed7d231de2d15caa7608638f366b36b040083e12" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;ldquo;</source>
          <target state="translated">在&amp;ldquo;对于每个类别约束 &lt;code&gt;(C t1 ... tn)&lt;/code&gt; &amp;rdquo;之后，添加&amp;ldquo;或每个量化的约束 &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="962b02c7a62413f64f2ece2fa9269c59c618e145" translate="yes" xml:space="preserve">
          <source>After &amp;ldquo;for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt;&amp;rdquo;, add &amp;ldquo;or each quantified constraint &lt;code&gt;(forall as. context =&amp;gt; C t1 .. tn)&lt;/code&gt;&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0f8ce28395257ee72603489cfcfd39f2ac90c3" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, the current context is set to:</source>
          <target state="translated">一个后&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令，当前上下文被设置为：</target>
        </trans-unit>
        <trans-unit id="07383eb16f1578a01af993380c0758317c77da4a" translate="yes" xml:space="preserve">
          <source>After analysing this declaration, GHC will discover that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; can be kind-polymorphic, with &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; and &lt;code&gt;c :: k2&lt;/code&gt;. We thus infer the following kind:</source>
          <target state="translated">在分析了此声明之后，GHC将发现 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 可以是种类多态的，具有 &lt;code&gt;a :: k2 -&amp;gt; Type&lt;/code&gt; 和 &lt;code&gt;c :: k2&lt;/code&gt; 。因此，我们推断出以下几种：</target>
        </trans-unit>
        <trans-unit id="43eb39a82773f2a643009be434c6a85d6547dd46" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 与原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 共享底层字节缓冲区。因此，用C或使用poke 修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 会导致 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的内容更改，从而破坏引用透明性。通过共享创建的其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; （例如通过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 生成的那些）也将反映这些更改。修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 将破坏引用透明性。为了避免这种情况，请使用 &lt;code&gt;useAsCString&lt;/code&gt; ，它会复制原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f34b11d2d5cf5b9fa61ceda45199281dda85ee6f" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">调用此函数后， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 与原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 共享基础字节缓冲区。从而修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; ，用C或使用poke CStringLen会导致 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的内容发生更改，从而破坏了引用透明性。通过共享创建的其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; （例如通过 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; 生成的那些）也将反映这些更改。修改 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 将破坏引用透明性。为避免这种情况，请使用 &lt;code&gt;useAsCStringLen&lt;/code&gt; ，它会复制原始 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82a058ea48e1049a3153e84c6e2e32200ba90877" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCString&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb3d574900104a74408c8731d7eda427531f654" translate="yes" xml:space="preserve">
          <source>After calling this function the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; shares the underlying byte buffer with the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. Thus modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;, either in C, or using poke, will cause the contents of the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to change, breaking referential transparency. Other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s created by sharing (such as those produced via &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;) will also reflect these changes. Modifying the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; will break referential transparency. To avoid this, use &lt;code&gt;useAsCStringLen&lt;/code&gt;, which makes a copy of the original &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6923804e768f3da3c4e34a50b537baa1cecaa53f" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;f&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">扩展同义词后， &lt;code&gt;f&lt;/code&gt; 具有法定（GHC中）类型：</target>
        </trans-unit>
        <trans-unit id="e94a959addb55b4d2ce5f3c538f5e0b4451a9198" translate="yes" xml:space="preserve">
          <source>After expanding the synonym, &lt;code&gt;foo&lt;/code&gt; has the legal (in GHC) type:</source>
          <target state="translated">扩展同义词后， &lt;code&gt;foo&lt;/code&gt; 具有法定（GHC中）类型：</target>
        </trans-unit>
        <trans-unit id="06d0d43c4a9a4534a91da534db4a4831101176f7" translate="yes" xml:space="preserve">
          <source>After expanding type synonyms, GHC does validity checking on types, looking for the following malformedness which isn&amp;rsquo;t detected simply by kind checking:</source>
          <target state="translated">扩展类型同义词后，GHC对类型进行有效性检查，查找以下不能通过类型检查简单检测到的格式错误：</target>
        </trans-unit>
        <trans-unit id="0449647915398655b7a878613d9a9af3cfaf3fda" translate="yes" xml:space="preserve">
          <source>After running a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action there are three possibilities for what comes next:</source>
          <target state="translated">运行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作后，接下来可能发生三种情况：</target>
        </trans-unit>
        <trans-unit id="f4bbb708c55cef458c6b0bed0fa5801c96a405ff" translate="yes" xml:space="preserve">
          <source>After starting &lt;code&gt;remote-iserv ⟨tmp_dir⟩ ⟨port⟩&lt;/code&gt; on the target and providing it with a temporary folder (where it will copy the necessary libraries to load to) and port it will listen for the proxy to connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8861d66315ce749c004b7e24b472e22e1345c7" translate="yes" xml:space="preserve">
          <source>After we&amp;rsquo;ve finished invoking our Haskell functions, we can call &lt;code&gt;hs_exit()&lt;/code&gt;, which terminates the RTS.</source>
          <target state="translated">调用完Haskell函数后，可以调用 &lt;code&gt;hs_exit()&lt;/code&gt; 来终止RTS。</target>
        </trans-unit>
        <trans-unit id="2fa08ab3cb629ae0630f4dccf9a63999f34ccc01" translate="yes" xml:space="preserve">
          <source>Again, if &lt;code&gt;C&lt;/code&gt; contains no class methods, the instance context will be redundant, so GHC will instead generate &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt;.</source>
          <target state="translated">同样，如果 &lt;code&gt;C&lt;/code&gt; 不包含类方法，则实例上下文将是多余的，因此GHC会生成 &lt;code&gt;instance C c_1 c_2 ... c_(m-1) (N n_1 n_2 ... n_q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80611142c1da75771c803bc1306de5dd47e954cb" translate="yes" xml:space="preserve">
          <source>Alexander Berntsen 2014</source>
          <target state="translated">Alexander Berntsen 2014年</target>
        </trans-unit>
        <trans-unit id="0f9d329fecfee776bcba1d14e6bca4840fae8ece" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;#12717&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70df90ba28c32aa3934681405622b497740ae050" translate="yes" xml:space="preserve">
          <source>Algebraic data types specified in a signature cannot be implemented using pattern synonyms. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;Issue #12717&lt;/a&gt;</source>
          <target state="translated">签名中指定的代数数据类型不能使用模式同义词来实现。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12717&quot;&gt;问题＃12717&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a995fe628ebfb0ac7cc0c0b98a66a1d60308575a" translate="yes" xml:space="preserve">
          <source>Algebraic properties:</source>
          <target state="translated">代数性质。</target>
        </trans-unit>
        <trans-unit id="00fe36cee0a001e71e45449595c2a673824d1b79" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:biasum&quot;&gt;biasum&lt;/a&gt;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="308d7f644aaa00a5665368fb713217dcb84b51ce" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bifor_&quot;&gt;bifor_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="9cdf35744dcefb67854cfd9303dbe37b27518062" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bisequence_&quot;&gt;bisequence_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="107c8c77b99ddea22e0d4483b070454ccd2a71ae" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="23f78602884a7b538f91b984806e37d22c871f3b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bifor&quot;&gt;bifor&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="0c1b2d82c320084f6a2ecaa9b2bb2ee948dec368" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bisequence&quot;&gt;bisequence&lt;/a&gt;&lt;/code&gt; 别名。</target>
        </trans-unit>
        <trans-unit id="60cc1b8e67da53fd1ea040fa3bfb7016cc924b7f" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-bitraversable#v:bitraverse&quot;&gt;bitraverse&lt;/a&gt;&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="dc75b7adfd72cadf1d0c28de54a66b5886fa0528" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt;. Returns True if its parameter is 1# and False if it is 0#.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#v:tagToEnum-35-&quot;&gt;tagToEnum#&lt;/a&gt;&lt;/code&gt; 的别名。如果参数为1＃，则返回True；如果参数为0＃，则返回False。</target>
        </trans-unit>
        <trans-unit id="b5417a2480ca72a7d0a8e8c2b271f31533da5d02" translate="yes" xml:space="preserve">
          <source>Align functions at given boundary.</source>
          <target state="translated">在给定的边界对准函数。</target>
        </trans-unit>
        <trans-unit id="309cb56d1cbd5360ce8e4fa89688161c57474b68" translate="yes" xml:space="preserve">
          <source>Align functions to multiples of the given value. Only valid values are powers of two.</source>
          <target state="translated">将函数对齐到给定值的倍数。只有有效值是二的幂。</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="be7cbc9171e2709ef932f92879b2fa92b735095e" translate="yes" xml:space="preserve">
          <source>All are based directly on their similarly-named &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; counterparts.</source>
          <target state="translated">所有这些都直接基于其类似名称的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#t:ReadP&quot;&gt;ReadP&lt;/a&gt;&lt;/code&gt; 副本。</target>
        </trans-unit>
        <trans-unit id="a6cd8f76353135f8eca4c08f035ed3722d4ad99a" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where &lt;code&gt;n&lt;/code&gt; is the number of bits in the type.</source>
          <target state="translated">所有算术均以2 ^ n为模，其中 &lt;code&gt;n&lt;/code&gt; 是类型中的位数。</target>
        </trans-unit>
        <trans-unit id="5c996c3cc62dedfc6f0f7accd3202c5cbe66b76c" translate="yes" xml:space="preserve">
          <source>All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; raise an error on negative arguments.</source>
          <target state="translated">所有算术均以2 ^ n为模，其中n是类型中的位数。这方面的一个非显而易见的后果是 &lt;code&gt;&lt;a href=&quot;prelude#v:negate&quot;&gt;negate&lt;/a&gt;&lt;/code&gt; 应该&lt;em&gt;不是&lt;/em&gt;消极的论点引发错误。</target>
        </trans-unit>
        <trans-unit id="0cb70b7dc62c8932f9a5fdafd462f49e1a9ac846" translate="yes" xml:space="preserve">
          <source>All data that is read will be decoded as UTF-8.</source>
          <target state="translated">所有被读取的数据将被解码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="63944b6a06201ae38dfb9a4d0c8e79dcd222ae47" translate="yes" xml:space="preserve">
          <source>All formats</source>
          <target state="translated">所有格式</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
