<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="ef2cf419db4400f92d4c16bda25b7b49de7c246f" translate="yes" xml:space="preserve">
          <source>Evaluate the argument to weak head normal form.</source>
          <target state="translated">评估论证到弱头正常形式。</target>
        </trans-unit>
        <trans-unit id="6060f4f46d5f080bbe6d3a4e15ea7e03aae4d623" translate="yes" xml:space="preserve">
          <source>Evaluates the given expression (or from the last breakpoint if no expression is given), and additionally logs the evaluation steps for later inspection using &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt;.</source>
          <target state="translated">评估给定的表达式（如果没有给出表达式，则从最后一个断点开始），并另外记录评估步骤，以供以后使用&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;检查。请参阅&lt;a href=&quot;#tracing&quot;&gt;跟踪和历史记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bc4cf67d5d67cdacfaa5ff060fb29cd523c09db" translate="yes" xml:space="preserve">
          <source>Evaluates the relevant functions at each element in the structure, running the action, and builds a new structure with the same shape, using the results produced from sequencing the actions.</source>
          <target state="translated">评估结构中每个元素处的相关功能,运行动作,利用动作排序产生的结果,建立一个形状相同的新结构。</target>
        </trans-unit>
        <trans-unit id="5600c714a91cbc3264f491ad475c86811b22d09a" translate="yes" xml:space="preserve">
          <source>Evaluating &lt;code&gt;f&lt;/code&gt; directly shows a call stack with a single entry, while evaluating &lt;code&gt;g&lt;/code&gt;, which also requests its call-site, shows two entries, one for each computation &amp;ldquo;annotated&amp;rdquo; with &lt;code&gt;HasCallStack&lt;/code&gt;.</source>
          <target state="translated">评估 &lt;code&gt;f&lt;/code&gt; 直接显示一个具有单个条目的调用堆栈，而评估 &lt;code&gt;g&lt;/code&gt; （也请求其调用位置）显示两个条目，每个计算均使用 &lt;code&gt;HasCallStack&lt;/code&gt; 进行 &amp;ldquo;注释&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="6de480eeff47d7212d5e046acac48253bd022e55" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th prefix takes \( O(\log(\min(i, n-i))) \), but evaluating every prefix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">评估第3个前缀需要O(log(\min(i,n-i))),但评估序列中的每一个前缀都需要O(n)由于共享。</target>
        </trans-unit>
        <trans-unit id="6396b8883a4c5c234f705d6f1fbf827f38a7835a" translate="yes" xml:space="preserve">
          <source>Evaluating the \( i \)th suffix takes \( O(\log(\min(i, n-i))) \), but evaluating every suffix in the sequence takes \( O(n) \) due to sharing.</source>
          <target state="translated">评估第(i )个后缀需要(O(log(\min(i,n-i))))))))),但评估序列中的每个后缀都需要(O(n)))))由于共享。</target>
        </trans-unit>
        <trans-unit id="ea09e351bce3db4c6389ffff16dcaf057265f37f" translate="yes" xml:space="preserve">
          <source>Evaluation has started on a spark.</source>
          <target state="translated">评价已经开始有了火花。</target>
        </trans-unit>
        <trans-unit id="bcce67319f3801a5d8320bd2ddeb26734158769d" translate="yes" xml:space="preserve">
          <source>Even if data families are defined as toplevel declarations, functions that perform different computations for different family instances may still need to be defined as methods of type classes. In particular, the following is not possible:</source>
          <target state="translated">即使数据族被定义为顶层声明,对于不同的族实例执行不同计算的函数可能仍然需要被定义为类型类的方法。特别是,以下情况是不可能的。</target>
        </trans-unit>
        <trans-unit id="712f436fb09e995690fe8d40968566162f8678b8" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;a&lt;/code&gt; is ill-typed, it is not used in the end, so if all that we&amp;rsquo;re interested in is &lt;code&gt;main&lt;/code&gt; it can be useful to be able to ignore the problems in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;a&lt;/code&gt; 是生病类型的，它不是用到底，所以如果一切是我们感兴趣的是 &lt;code&gt;main&lt;/code&gt; 它可以是可以忽略的问题是很有用 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c423833e7459f388f7a025deca957c83022894ae" translate="yes" xml:space="preserve">
          <source>Even though a field label is duplicated in its defining module, it may be possible to use the selector unambiguously elsewhere. For example, another module could import &lt;code&gt;S(x)&lt;/code&gt; but not &lt;code&gt;T(x)&lt;/code&gt;, and then use &lt;code&gt;x&lt;/code&gt; unambiguously.</source>
          <target state="translated">即使字段标签在其定义模块中重复，也可以在其他地方明确使用选择器。例如，另一个模块可以导入 &lt;code&gt;S(x)&lt;/code&gt; 而不导入 &lt;code&gt;T(x)&lt;/code&gt; ，然后明确地使用 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="852a6172c09d70538bebcbe548e6b3e70b6d5e28" translate="yes" xml:space="preserve">
          <source>Even though most of these examples are using the list monad, monad comprehensions work for any monad. The &lt;code&gt;base&lt;/code&gt; package offers all necessary instances for lists, which make &lt;a href=&quot;#extension-MonadComprehensions&quot;&gt;&lt;code&gt;MonadComprehensions&lt;/code&gt;&lt;/a&gt; backward compatible to built-in, transform and parallel list comprehensions.</source>
          <target state="translated">即使这些示例大多数都使用列表monad，但是monad理解对于任何monad都有效。该 &lt;code&gt;base&lt;/code&gt; 包提供了列出了所有必要的情况下，使&lt;a href=&quot;#extension-MonadComprehensions&quot;&gt; &lt;code&gt;MonadComprehensions&lt;/code&gt; &lt;/a&gt;向后兼容的内置，转换和并行列表内涵。</target>
        </trans-unit>
        <trans-unit id="1e2fd9aaf66af88d1fa27ea41b45f571960a585c" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">即使偏移量表示为 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; ，对于负偏移量，结果也是不确定的。</target>
        </trans-unit>
        <trans-unit id="7a5f2b0889226d76221df5eba41dfdfd027c049a" translate="yes" xml:space="preserve">
          <source>Even though the shift-amount is expressed as &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;, the result is undefined for negative shift-amounts.</source>
          <target state="translated">即使偏移量表示为 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; ，对于负偏移量，结果也不确定。</target>
        </trans-unit>
        <trans-unit id="8a98b3fabc4357473affe9eff5dad04c75f7f6eb" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">即使有两个 &lt;code&gt;x&lt;/code&gt; 的范围，很清楚的是， &lt;code&gt;x&lt;/code&gt; 中的定义中的图案 &lt;code&gt;ok1&lt;/code&gt; 只能意味着字段 &lt;code&gt;x&lt;/code&gt; 从类型 &lt;code&gt;S&lt;/code&gt; 。对于功能 &lt;code&gt;ok2&lt;/code&gt; 同样。然而，在记录更新 &lt;code&gt;bad1&lt;/code&gt; 并在记录选择 &lt;code&gt;bad2&lt;/code&gt; 目前尚不清楚这两种类型的意图。</target>
        </trans-unit>
        <trans-unit id="4622930c8ec60ffdcb4687bdfc5e61a4075cdba8" translate="yes" xml:space="preserve">
          <source>Even though there are two &lt;code&gt;x&lt;/code&gt;&amp;rsquo;s in scope, it is clear that the &lt;code&gt;x&lt;/code&gt; in the pattern in the definition of &lt;code&gt;ok1&lt;/code&gt; can only mean the field &lt;code&gt;x&lt;/code&gt; from type &lt;code&gt;S&lt;/code&gt;. Similarly for the function &lt;code&gt;ok2&lt;/code&gt;. However, in the record update in &lt;code&gt;bad1&lt;/code&gt; and the record selection in &lt;code&gt;bad2&lt;/code&gt; it is not clear which of the two types is intended.</source>
          <target state="translated">即使有两个 &lt;code&gt;x&lt;/code&gt; 的范围，很清楚的是， &lt;code&gt;x&lt;/code&gt; 中的定义中的图案 &lt;code&gt;ok1&lt;/code&gt; 只能意味着字段 &lt;code&gt;x&lt;/code&gt; 从类型 &lt;code&gt;S&lt;/code&gt; 。对于功能 &lt;code&gt;ok2&lt;/code&gt; 同样。然而，在记录更新 &lt;code&gt;bad1&lt;/code&gt; 并在记录选择 &lt;code&gt;bad2&lt;/code&gt; 目前尚不清楚这两种类型的意图。</target>
        </trans-unit>
        <trans-unit id="2711d7494e1ded0fd3622ca6129c265f52351d7e" translate="yes" xml:space="preserve">
          <source>Even when set to &lt;code&gt;ignore&lt;/code&gt;, a local script will still be processed if given by &lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt;&lt;code&gt;-ghci-script&lt;/code&gt;&lt;/a&gt; on the command line, or sourced via &lt;a href=&quot;#ghci-cmd-:script&quot;&gt;&lt;code&gt;:script&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">即使设置为 &lt;code&gt;ignore&lt;/code&gt; ，如果在命令行上通过&lt;a href=&quot;#ghc-flag--ghci-script&quot;&gt; &lt;code&gt;-ghci-script&lt;/code&gt; &lt;/a&gt;给出或通过&lt;a href=&quot;#ghci-cmd-:script&quot;&gt; &lt;code&gt;:script&lt;/code&gt; &lt;/a&gt;来获取本地脚本，仍将对其进行处理。</target>
        </trans-unit>
        <trans-unit id="28e0cceb61d9188b63cc75de845a0be5868e83b8" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">即使带有标志&lt;a href=&quot;../using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;，构造函数 &lt;code&gt;T&lt;/code&gt; 的字段也不会被解包。</target>
        </trans-unit>
        <trans-unit id="73d7a0d774535278c1215097572fe0930f17dd2b" translate="yes" xml:space="preserve">
          <source>Even with the flags &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the field of the constructor &lt;code&gt;T&lt;/code&gt; is not unpacked.</source>
          <target state="translated">即使带有标志&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;，构造函数 &lt;code&gt;T&lt;/code&gt; 的字段也不会被解包。</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="0c619c8d6ba2035f81d9f010c08ec0b1177929e5" translate="yes" xml:space="preserve">
          <source>Event logging</source>
          <target state="translated">事件记录</target>
        </trans-unit>
        <trans-unit id="913641e09266e8cb48d5e95316fd86cbe16755ba" translate="yes" xml:space="preserve">
          <source>EventManager</source>
          <target state="translated">EventManager</target>
        </trans-unit>
        <trans-unit id="ff23fd7f42569a5bfa090dd486d103be85fd0164" translate="yes" xml:space="preserve">
          <source>Eventlog tracing</source>
          <target state="translated">事件日志追踪</target>
        </trans-unit>
        <trans-unit id="c19ae7eba2908ba6569d481309090a0fda383fe3" translate="yes" xml:space="preserve">
          <source>Eventlog tracing is a performance profiling system. These functions emit extra events into the eventlog. In combination with eventlog profiling tools these functions can be used for monitoring execution and investigating performance problems.</source>
          <target state="translated">Eventlog追踪是一个性能分析系统。这些函数会向事件日志中发射额外的事件。结合事件日志分析工具,这些函数可用于监控执行情况和调查性能问题。</target>
        </trans-unit>
        <trans-unit id="9202d6978f7b6c56daee6dab6c663c232e9764fd" translate="yes" xml:space="preserve">
          <source>Events can have extra information added, but existing fields cannot be changed. Tools should ignore extra fields at the end of the event record.</source>
          <target state="translated">事件可以添加额外的信息,但不能改变现有的字段。工具应忽略事件记录末尾的额外字段。</target>
        </trans-unit>
        <trans-unit id="82d16de768c1684f419fe23bd359b377e6758d1e" translate="yes" xml:space="preserve">
          <source>Every complete Haskell program must define &lt;code&gt;main&lt;/code&gt; in module &lt;code&gt;Main&lt;/code&gt; in package &lt;code&gt;main&lt;/code&gt;. Omitting the &lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt;&lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt;&lt;/a&gt; flag compiles code for package &lt;code&gt;main&lt;/code&gt;. Failure to do so leads to a somewhat obscure link-time error of the form:</source>
          <target state="translated">每一个完整的Haskell程序必须定义 &lt;code&gt;main&lt;/code&gt; 模块 &lt;code&gt;Main&lt;/code&gt; 在包 &lt;code&gt;main&lt;/code&gt; 。省略&lt;a href=&quot;#ghc-flag--this-unit-id%20%E2%9F%A8unit-id%E2%9F%A9&quot;&gt; &lt;code&gt;-this-unit-id ⟨unit-id⟩&lt;/code&gt; &lt;/a&gt;标志可编译包 &lt;code&gt;main&lt;/code&gt; 的代码。否则，将导致以下形式的链接时错误：</target>
        </trans-unit>
        <trans-unit id="d0912fd6d2a0271d302c52a4acaff179b0c6995b" translate="yes" xml:space="preserve">
          <source>Every cycle in the module import graph must be broken by a &lt;code&gt;hs-boot&lt;/code&gt; file. Suppose that modules &lt;code&gt;A.hs&lt;/code&gt; and &lt;code&gt;B.hs&lt;/code&gt; are Haskell source files, thus:</source>
          <target state="translated">模块导入图中的每个循环都必须由 &lt;code&gt;hs-boot&lt;/code&gt; 文件打断。假设模块 &lt;code&gt;A.hs&lt;/code&gt; 和 &lt;code&gt;B.hs&lt;/code&gt; 是Haskell源文件，因此：</target>
        </trans-unit>
        <trans-unit id="33d86826edcd97dcbde5f7c16a0f10d7e8256a5b" translate="yes" xml:space="preserve">
          <source>Every language extension can also be turned into a command-line flag by prefixing it with &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo;; for example &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt;. (Similarly, all &amp;ldquo;&lt;code&gt;-X&lt;/code&gt;&amp;rdquo; flags can be written as &lt;code&gt;LANGUAGE&lt;/code&gt; pragmas.)</source>
          <target state="translated">通过将每个语言扩展名加上&amp;ldquo; &lt;code&gt;-X&lt;/code&gt; &amp;rdquo; 前缀，也可以将其转换为命令行标志。例如 &lt;code&gt;-XForeignFunctionInterface&lt;/code&gt; 。（类似地，所有&amp;ldquo; &lt;code&gt;-X&lt;/code&gt; &amp;rdquo;标志都可以写为 &lt;code&gt;LANGUAGE&lt;/code&gt; pragma。）</target>
        </trans-unit>
        <trans-unit id="3b078eee456a9f087a6cc6922257a7666e3223df" translate="yes" xml:space="preserve">
          <source>Every language extension can be switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">每种语言扩展都可以通过命令行标志&amp;ldquo; &lt;code&gt;-X...&lt;/code&gt; &amp;rdquo;（例如 &lt;code&gt;-XTemplateHaskell&lt;/code&gt; ）打开，并通过标志&amp;ldquo; &lt;code&gt;-XNo...&lt;/code&gt; &amp;rdquo;关闭；（例如 &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="89191834b0668388b7f06081ebe85c6fc7aa3ea9" translate="yes" xml:space="preserve">
          <source>Every language option can switched on by a command-line flag &amp;ldquo;&lt;code&gt;-X...&lt;/code&gt;&amp;rdquo; (e.g. &lt;code&gt;-XTemplateHaskell&lt;/code&gt;), and switched off by the flag &amp;ldquo;&lt;code&gt;-XNo...&lt;/code&gt;&amp;rdquo;; (e.g. &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt;).</source>
          <target state="translated">每种语言选项都可以通过命令行标志&amp;ldquo; &lt;code&gt;-X...&lt;/code&gt; &amp;rdquo;（例如 &lt;code&gt;-XTemplateHaskell&lt;/code&gt; ）打开，并通过标志&amp;ldquo; &lt;code&gt;-XNo...&lt;/code&gt; &amp;rdquo; 关闭；（例如 &lt;code&gt;-XNoTemplateHaskell&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c21e6f680a01c2f8b28c8d60711b7527a58afada" translate="yes" xml:space="preserve">
          <source>Every module has a &lt;em&gt;module name&lt;/em&gt; defined in its source code (&lt;code&gt;module A.B.C where ...&lt;/code&gt;).</source>
          <target state="translated">每个模块都有一个在其源代码中定义的&lt;em&gt;模块名称&lt;/em&gt;（ &lt;code&gt;module A.B.C where ...&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b9fd929db55af9188984a5b1f15ada92d9684dba" translate="yes" xml:space="preserve">
          <source>Every new binding shadows any existing bindings of the same name, including entities that are in scope in the current module context.</source>
          <target state="translated">每一个新的绑定都会屏蔽任何现有的同名绑定,包括在当前模块上下文范围内的实体。</target>
        </trans-unit>
        <trans-unit id="f7098378d870c69a4432ef9315748f42a7c6f2be" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">每个线程都有一个分配计数器，该计数器跟踪该线程分配了多少内存。计数器初始化为零，并且 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 设置当前值。分配计数器的计数是* down *，因此在没有调用 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 的情况下，其值是线程分配的内存字节数的取反。</target>
        </trans-unit>
        <trans-unit id="87fea7be991371f64729bc8780fc11210c633480" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">每个线程都有一个分配计数器，该计数器跟踪该线程分配了多少内存。计数器初始化为零，并且 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 设置当前值。分配计数器的计数是* down *，因此在没有调用 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 的情况下，其值是线程分配的内存字节数的取反。</target>
        </trans-unit>
        <trans-unit id="abfc0f0b13db0da312949b88776c9010f5397cef" translate="yes" xml:space="preserve">
          <source>Every thread has an allocation counter that tracks how much memory has been allocated by the thread. The counter is initialized to zero, and &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; sets the current value. The allocation counter counts *down*, so in the absence of a call to &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; its value is the negation of the number of bytes of memory allocated by the thread.</source>
          <target state="translated">每个线程都有一个分配计数器，该计数器跟踪该线程分配了多少内存。计数器初始化为零，并且 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 设置当前值。分配计数器的计数是* down *，因此在没有调用 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 的情况下，其值是线程分配的内存字节数的取反。</target>
        </trans-unit>
        <trans-unit id="2cdcb7a5f8b0e5da9d82d98917b19bde316858e5" translate="yes" xml:space="preserve">
          <source>Exactly the same reasoning applies to &lt;code&gt;ExNumPat&lt;/code&gt;: matching against &lt;code&gt;ExNumPat&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, and &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt;.</source>
          <target state="translated">完全相同的推理适用于 &lt;code&gt;ExNumPat&lt;/code&gt; ：与 &lt;code&gt;ExNumPat&lt;/code&gt; 匹配&lt;em&gt;需要&lt;/em&gt;约束 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; ，并&lt;em&gt;提供&lt;/em&gt;约束 &lt;code&gt;(Show b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b96d27d4acb5d7b08b44caf941f831bab1b616f" translate="yes" xml:space="preserve">
          <source>Exactly the same situation can arise in instance declarations themselves. Suppose we have</source>
          <target state="translated">在实例声明本身也会出现完全相同的情况。假设我们有</target>
        </trans-unit>
        <trans-unit id="fe669a2e98268a4e3f1914eea2b10b28c27678b1" translate="yes" xml:space="preserve">
          <source>Examine the generated profiling information, use the information to optimise your program, and repeat as necessary.</source>
          <target state="translated">检查生成的剖析信息,使用这些信息来优化你的程序,并根据需要重复。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="5ab5c95eb13c56a3fee4135ddda2d5191c14c8f0" translate="yes" xml:space="preserve">
          <source>Example 1: Custom Error Data Type</source>
          <target state="translated">例1:自定义错误数据类型</target>
        </trans-unit>
        <trans-unit id="9341e16e31da6f2a70822dbce4c15a6563123345" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Continuation Usage</source>
          <target state="translated">例1:简单的延续用法</target>
        </trans-unit>
        <trans-unit id="65d8343070f8245126756e9e6474efdb37e4866c" translate="yes" xml:space="preserve">
          <source>Example 1: Simple Reader Usage</source>
          <target state="translated">例1:简单的读者使用方法</target>
        </trans-unit>
        <trans-unit id="e7b57a0dcf99e0a81e45002d7fa9585327408c44" translate="yes" xml:space="preserve">
          <source>Example 2: Modifying Reader Content With &lt;code&gt;local&lt;/code&gt;</source>
          <target state="translated">示例2：使用 &lt;code&gt;local&lt;/code&gt; 修改阅读器内容</target>
        </trans-unit>
        <trans-unit id="b7af5856636b2b3dd64495544e0d58ec7921152b" translate="yes" xml:space="preserve">
          <source>Example 2: Using &lt;code&gt;callCC&lt;/code&gt;</source>
          <target state="translated">示例2：使用 &lt;code&gt;callCC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f1f4d7e09a4ce050bc861cd17fcfb325ccd1802" translate="yes" xml:space="preserve">
          <source>Example 2: Using ErrorT Monad Transformer</source>
          <target state="translated">例子2:使用ErrorT单项式变换器</target>
        </trans-unit>
        <trans-unit id="49670fce677705355449a0491c747c92f53b6377" translate="yes" xml:space="preserve">
          <source>Example 2: Using ExceptT Monad Transformer</source>
          <target state="translated">例2:使用ExceptT单项式变换器</target>
        </trans-unit>
        <trans-unit id="3b38bf4f99b69316fc2cabc16fe8efbc23e17cdb" translate="yes" xml:space="preserve">
          <source>Example 3: &lt;code&gt;ReaderT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">示例3： &lt;code&gt;ReaderT&lt;/code&gt; Monad变压器</target>
        </trans-unit>
        <trans-unit id="2f4dd83523e08d239122d5d7b82fdc40b87078e4" translate="yes" xml:space="preserve">
          <source>Example 3: Using &lt;code&gt;ContT&lt;/code&gt; Monad Transformer</source>
          <target state="translated">示例3：使用 &lt;code&gt;ContT&lt;/code&gt; Monad变压器</target>
        </trans-unit>
        <trans-unit id="589c32b6f4517cdf800a8b3876ce51a0178b7a54" translate="yes" xml:space="preserve">
          <source>Example type:</source>
          <target state="translated">例子类型:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用实例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fa37f54302b03973bfbf2aa3fb535779d3383bb4" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">示例（行为与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 相同）：</target>
        </trans-unit>
        <trans-unit id="790f2b42181ca616b7c127aef6e902fd9e8081ef" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">示例（行为与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 相同）：</target>
        </trans-unit>
        <trans-unit id="d081741e630d4cf15f0c6ba49848ab7e7fafe785" translate="yes" xml:space="preserve">
          <source>Examples (with behaviour identical to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">示例（行为与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 相同）：</target>
        </trans-unit>
        <trans-unit id="65ef181bf5a5a0563ded8a2fc63cfcae3d45812a" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 的差异示例：</target>
        </trans-unit>
        <trans-unit id="80e96827fe2478980a86e49ef7458c4629812185" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 的差异示例：</target>
        </trans-unit>
        <trans-unit id="ddfe2a057d0d4bd32c75bee00a3afd1b7f3cd6fd" translate="yes" xml:space="preserve">
          <source>Examples of differences from &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 的差异示例：</target>
        </trans-unit>
        <trans-unit id="3e6a1dcd0a3510c1fa35b2c9952fa51f9d56da66" translate="yes" xml:space="preserve">
          <source>Examples of short-cicuit reduction include various boolean predicates that test whether some or all the elements of a structure satisfy a given condition. Because these don't necessarily consume the entire list, they typically employ &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; with an operator that is conditionally strict in its second argument. Once the termination condition is met the second argument (tail of the input structure) is ignored. No result is returned until that happens.</source>
          <target state="translated">短路减少的示例包括各种布尔谓词，这些布尔谓词测试结构的某些或全部元素是否满足给定条件。因为这些不一定消耗整个列表，所以它们通常将 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 与第二个参数中有条件严格的运算符一起使用。满足终止条件后，将忽略第二个参数（输入结构的尾部）。在发生这种情况之前，不会返回任何结果。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="498245f3f1e8f9b6f80d7ed20c13e42f043f24d9" translate="yes" xml:space="preserve">
          <source>Except</source>
          <target state="translated">Except</target>
        </trans-unit>
        <trans-unit id="150f49a28cd9890f5d74255011dd9ae13178dd32" translate="yes" xml:space="preserve">
          <source>ExceptT</source>
          <target state="translated">ExceptT</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="53a706616e11935ca633fadc1928372183e733d2" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">异常传递在源线程和目标线程之间同步： &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在目标线程引发异常之前不会返回。因此，调用线程可以确定目标线程已接收到异常。相对于其他异常，异常传递也是原子的。在处理竞争条件时，原子性是一个有用的属性：例如，如果有两个线程可以互相杀死，则可以确保只有一个线程可以杀死另一个线程。</target>
        </trans-unit>
        <trans-unit id="6b1c0dab2d59aa101f6c17d2f3c37c8dbb32aef4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">异常传递在源线程和目标线程之间同步： &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在目标线程引发异常之前不会返回。因此，调用线程可以确定目标线程已接收到异常。相对于其他异常，异常传递也是原子的。在处理竞争条件时，原子性是一个有用的属性：例如，如果有两个线程可以互相杀死，则可以确保只有一个线程可以杀死另一个线程。</target>
        </trans-unit>
        <trans-unit id="f9ca0b055b03c1b83f5d783045937b6b971fc2c7" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">异常传递在源线程和目标线程之间同步： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在目标线程引发异常之前不会返回。因此，调用线程可以确定目标线程已接收到异常。相对于其他异常，异常传递也是原子的。在处理竞争条件时，原子性是一个有用的属性：例如，如果有两个线程可以互相杀死，则可以确保只有一个线程可以杀死另一个线程。</target>
        </trans-unit>
        <trans-unit id="63b8e6291d3f08aeaec124c66c6cff001d6c6ea4" translate="yes" xml:space="preserve">
          <source>Exception delivery synchronizes between the source and target thread: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception has been raised in the target thread. The calling thread can thus be certain that the target thread has received the exception. Exception delivery is also atomic with respect to other exceptions. Atomicity is a useful property to have when dealing with race conditions: e.g. if there are two threads that can kill each other, it is guaranteed that only one of the threads will get to kill the other.</source>
          <target state="translated">异常传递在源线程和目标线程之间同步： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在目标线程引发异常之前不会返回。因此，调用线程可以确定目标线程已接收到异常。相对于其他异常，异常传递也是原子的。在处理竞争条件时，原子性是一个有用的属性：例如，如果有两个线程可以互相杀死，则可以确保只有一个线程可以杀死另一个线程。</target>
        </trans-unit>
        <trans-unit id="e0356c4346732233d71d4ad17145a3a7d64d539e" translate="yes" xml:space="preserve">
          <source>Exception handling in the I/O monad</source>
          <target state="translated">I/O单体中的异常处理</target>
        </trans-unit>
        <trans-unit id="4aba3643c6de6f96be69c3234f88f2d7abee91b2" translate="yes" xml:space="preserve">
          <source>Exception handling within STM actions.</source>
          <target state="translated">在STM动作中处理异常。</target>
        </trans-unit>
        <trans-unit id="eda52cb4b163a3d91ebc6efd255a35eb5c788dd0" translate="yes" xml:space="preserve">
          <source>Exception operations</source>
          <target state="translated">异常操作</target>
        </trans-unit>
        <trans-unit id="1e0456156d2599fba71e66665c8effe9eb0cdf9b" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle-lock#v:hLock&quot;&gt;hLock&lt;/a&gt;&lt;/code&gt; 在不支持 &lt;code&gt;flock&lt;/code&gt; 的非Windows平台上引发的异常。</target>
        </trans-unit>
        <trans-unit id="ab0e1caad4d21b7759b69123f35074bf121ac468" translate="yes" xml:space="preserve">
          <source>Exception thrown by &lt;code&gt;hLock&lt;/code&gt; on non-Windows platforms that don't support &lt;code&gt;flock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hLock&lt;/code&gt; 在不支持 &lt;code&gt;flock&lt;/code&gt; 的非Windows平台上引发的异常。</target>
        </trans-unit>
        <trans-unit id="8bcbec4a21f1200ac1b10210e0b80c9fa92ae9e7" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. pattern matching failure and &lt;code&gt;error&lt;/code&gt;) can be treated as breakpoints, to help locate the source of an exception in the program.</source>
          <target state="translated">异常（例如，模式匹配失败和 &lt;code&gt;error&lt;/code&gt; ）可以视为断点，以帮助在程序中定位异常的来源。</target>
        </trans-unit>
        <trans-unit id="19252ae3666000a0b6f93913a391be3ee8a0b825" translate="yes" xml:space="preserve">
          <source>Exceptions and exception-handling functions.</source>
          <target state="translated">异常和异常处理功能。</target>
        </trans-unit>
        <trans-unit id="581d67742f82ff9913666449de206cda75556316" translate="yes" xml:space="preserve">
          <source>Exceptions generated by array operations</source>
          <target state="translated">数组操作产生的异常</target>
        </trans-unit>
        <trans-unit id="934839970d31235dc74d44785440bb7587cc9762" translate="yes" xml:space="preserve">
          <source>Exceptions that occur in the &lt;code&gt;IO&lt;/code&gt; monad. An &lt;code&gt;IOException&lt;/code&gt; records a more specific error type, a descriptive string and maybe the handle that was used when the error was flagged.</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; monad 中发生的异常。一个 &lt;code&gt;IOException&lt;/code&gt; 异常记录一个更具体的错误类型，描述字符串，也许当被标记的错误使用手柄。</target>
        </trans-unit>
        <trans-unit id="08dd9b4521175f2b7645b6d05dd66e3f5d1e5a7a" translate="yes" xml:space="preserve">
          <source>ExclusiveLock</source>
          <target state="translated">ExclusiveLock</target>
        </trans-unit>
        <trans-unit id="a9e5edeee4b6bddbc59b5bc41ce4029d4ec4727e" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析的，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="42e1121c05300716bc1e0f10a008032170bf3cee" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="0d633fda1eda86ee2dbe83ca841bdba34c00b7fb" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="da49c4c138af06cdc6e4ed0555a2d722ce3bbf8b" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析的，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="fbbcf8ab79fd69b3cdf42660517413d00119f401" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="08446105cf0896c803b6a80b50cd0e07cfad78bd" translate="yes" xml:space="preserve">
          <source>Executable &amp;amp; arguments, or shell command. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, relative paths are resolved with respect to the current working directory. If &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; is provided, it is implementation-dependent whether relative paths are resolved with respect to &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; or the current working directory, so absolute paths should be used to ensure portability.</source>
          <target state="translated">可执行文件和参数，或Shell命令。如果 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则相对于当前工作目录解析相对路径。如果提供了 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; ，则相对路径是相对于 &lt;code&gt;&lt;a href=&quot;system-process-internals#v:cwd&quot;&gt;cwd&lt;/a&gt;&lt;/code&gt; 还是当前工作目录解析，则取决于实现方式，因此应使用绝对路径来确保可移植性。</target>
        </trans-unit>
        <trans-unit id="82e45ade933abb2dbef129bbe667e5f06567379e" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">执行一个 &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 并将返回的块作为惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回。延迟执行工作，即仅在强制延迟 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的一部分时才执行。</target>
        </trans-unit>
        <trans-unit id="bbdca60aa1528cc59e2424298bc2fbc065b117a6" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">执行一个 &lt;code&gt;&lt;a href=&quot;data-binary-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 并将返回的块作为惰性 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回。延迟执行工作，即仅在强制延迟 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的一部分时才执行。</target>
        </trans-unit>
        <trans-unit id="44cef8606c2d8d69b084ef725295c455661c70d1" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; and return the generated chunks as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The work is performed lazy, i.e., only when a chunk of the lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is forced.</source>
          <target state="translated">执行一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 并将返回的块作为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 返回。延迟执行工作，即仅在强制延迟 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的一部分时才执行。</target>
        </trans-unit>
        <trans-unit id="2d4c37228081ad690471866bfb49855698ac1573" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and return the computed result and the bytes written during the computation as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 并以惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 形式返回计算结果和在计算过程中写入的字节。</target>
        </trans-unit>
        <trans-unit id="0a91780a4fbc0b4b5a96ff84d0f2ad27c4390b00" translate="yes" xml:space="preserve">
          <source>Execute a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; with a buffer-allocation strategy and a continuation. For example, &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; is implemented as follows.</source>
          <target state="translated">使用缓冲区分配策略和继续执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 期权。例如， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:putToLazyByteString&quot;&gt;putToLazyByteString&lt;/a&gt;&lt;/code&gt; 实现如下。</target>
        </trans-unit>
        <trans-unit id="34b863a511860977e79077de7a231a7aecf1ada7" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment</source>
          <target state="translated">在修改后的环境中执行计算</target>
        </trans-unit>
        <trans-unit id="9074ee855e6397968c72ac1444df19911eaa577a" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在修改后的环境（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 的更通用版本）中执行计算。</target>
        </trans-unit>
        <trans-unit id="9bad7ac26cf07893f9cefd43f5bb9c7a61a20d5d" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a more general version of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在修改后的环境（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 的更通用版本）中执行计算。</target>
        </trans-unit>
        <trans-unit id="1c369096a8c214ef9f4515d93a67dbb9c70e723b" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在修改后的环境（ &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 的特殊化）中执行计算。</target>
        </trans-unit>
        <trans-unit id="e148fe739f9c54b1accabc69b62a9d19fee91018" translate="yes" xml:space="preserve">
          <source>Execute a computation in a modified environment (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在修改后的环境（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:withReaderT&quot;&gt;withReaderT&lt;/a&gt;&lt;/code&gt; 的特殊化）中执行计算。</target>
        </trans-unit>
        <trans-unit id="53f59c8f15736e3200571bde489e9c2748a0204d" translate="yes" xml:space="preserve">
          <source>Execute an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action, throwing a &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; if the predicate yields &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; when applied to the result returned by the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. If no exception is raised, return the result of the computation.</source>
          <target state="translated">执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，如果谓词在应用于 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回的结果时产生 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;system-io-error#v:userError&quot;&gt;userError&lt;/a&gt;&lt;/code&gt; 。如果没有异常，则返回计算结果。</target>
        </trans-unit>
        <trans-unit id="42c77fe8561e333489414079969807a39fd1e151" translate="yes" xml:space="preserve">
          <source>Execute an action with a fresh memory pool, which gets automatically deallocated (including its contents) after the action has finished.</source>
          <target state="translated">用新的内存池执行一个动作,动作结束后,内存池会自动去分配(包括其内容)。</target>
        </trans-unit>
        <trans-unit id="1262c3e03a483c6a9341f4b12dfc5bd8ac87a7c4" translate="yes" xml:space="preserve">
          <source>Executes a computation in a modified environment.</source>
          <target state="translated">在修改后的环境中执行计算。</target>
        </trans-unit>
        <trans-unit id="8210b4609b3b832c81bcd8b6f74a6b3190413ae8" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">使用&lt;em&gt;遮罩的&lt;/em&gt;异步异常执行IO计算。也就是说，任何试图使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在当前线程中引发异常的线程都将被阻塞，直到再次取消屏蔽异步异常为止。</target>
        </trans-unit>
        <trans-unit id="46ec0e1cddb9075cc884b834b53f50ddc817ddcc" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">使用&lt;em&gt;遮罩的&lt;/em&gt;异步异常执行IO计算。也就是说，任何试图使用 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在当前线程中引发异常的线程都将被阻塞，直到再次取消屏蔽异步异常为止。</target>
        </trans-unit>
        <trans-unit id="60c9626b83b84fd2f338afec521f991b9505634c" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">使用&lt;em&gt;遮罩的&lt;/em&gt;异步异常执行IO计算。也就是说，任何试图使用 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在当前线程中引发异常的线程都将被阻塞，直到再次取消屏蔽异步异常为止。</target>
        </trans-unit>
        <trans-unit id="778dbd9e9bf309d9af09860bc9150a182f094e04" translate="yes" xml:space="preserve">
          <source>Executes an IO computation with asynchronous exceptions &lt;em&gt;masked&lt;/em&gt;. That is, any thread which attempts to raise an exception in the current thread with &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will be blocked until asynchronous exceptions are unmasked again.</source>
          <target state="translated">使用&lt;em&gt;遮罩的&lt;/em&gt;异步异常执行IO计算。也就是说，任何试图使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; 在当前线程中引发异常的线程都将被阻塞，直到再次取消屏蔽异步异常为止。</target>
        </trans-unit>
        <trans-unit id="a7ed1222c5da10b5796d9be8df9484fce7ea06e0" translate="yes" xml:space="preserve">
          <source>Executes the GHCi built-in command (e.g. &lt;code&gt;::type 3&lt;/code&gt;). That is, look up on the list of builtin commands, excluding defined macros. See also: &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">执行GHCi内置命令（例如 &lt;code&gt;::type 3&lt;/code&gt; ）。即，在内置命令列表中查找，不包括已定义的宏。另请参阅&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbee69c7c6cc3983066537c6b9014eb13e8768e2" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. The syntax for file-name arguments respects shell quoting rules, i.e., file names containing spaces can be enclosed in double quotes or with spaces escaped with a backslash. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将文件的行作为一系列GHCi命令执行。文件名参数的语法遵循shell引用规则，即，包含空格的文件名可以用双引号引起来，也可以用反斜杠转义。该命令与&lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt;设置的多行语句兼容。</target>
        </trans-unit>
        <trans-unit id="f33de9056690f98ecc8c217e510931ae85b64fa5" translate="yes" xml:space="preserve">
          <source>Executes the lines of a file as a series of GHCi commands. This command is compatible with multiline statements as set by &lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt;&lt;code&gt;:set +m&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将文件的行作为一系列GHCi命令执行。该命令与&lt;a href=&quot;#ghci-cmd-:set%20+m&quot;&gt; &lt;code&gt;:set +m&lt;/code&gt; &lt;/a&gt;设置的多行语句兼容。</target>
        </trans-unit>
        <trans-unit id="88c84a00bbe497217dba4b84e9db2cf8c6f33404" translate="yes" xml:space="preserve">
          <source>Executes the shell command ⟨command⟩.</source>
          <target state="translated">执行shell命令⟨command⟩。</target>
        </trans-unit>
        <trans-unit id="130a9408743cf5a376559c419e05f9b8d8b461ba" translate="yes" xml:space="preserve">
          <source>Executes ⟨expr⟩ as a computation of type &lt;code&gt;IO String&lt;/code&gt;, and then executes the resulting string as a list of GHCi commands. Multiple commands are separated by newlines. The &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; command is useful with &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&amp;ldquo; expr&amp;rdquo;作为 &lt;code&gt;IO String&lt;/code&gt; 类型的计算执行，然后将结果字符串作为GHCi命令列表执行。多个命令用换行符分隔。的&lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt;命令是有用的&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df5c4bfe66f918bc7c61afbbe38d05d87f6b7882" translate="yes" xml:space="preserve">
          <source>Executing Builders</source>
          <target state="translated">执行建设者</target>
        </trans-unit>
        <trans-unit id="520995e98a5bbbbf4ce95c15e55e45c660e4b3b8" translate="yes" xml:space="preserve">
          <source>Executing an external command.</source>
          <target state="translated">执行外部命令。</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="b0b8748c9d02d8c4d95223629ecf3c2f6ccc5b43" translate="yes" xml:space="preserve">
          <source>Execution can be single-stepped: the evaluator will suspend execution approximately after every reduction, allowing local variables to be inspected. This is equivalent to setting a breakpoint at every point in the program.</source>
          <target state="translated">执行可以是单步的:评估器将在每次缩减后大约暂停执行,允许检查局部变量。这相当于在程序的每一个点设置一个断点。</target>
        </trans-unit>
        <trans-unit id="52ff4dea904274d587ed05e7bceeb9003bc66ab2" translate="yes" xml:space="preserve">
          <source>Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn&amp;rsquo;t suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected.</source>
          <target state="translated">执行可以在跟踪模式下进行，在该模式下，评估者会记住每个评估步骤，但不会在达到实际断点之前暂停执行。发生这种情况时，可以检查评估步骤的历史记录。</target>
        </trans-unit>
        <trans-unit id="d4a32174885111edde7b30c063a41b35b8521952" translate="yes" xml:space="preserve">
          <source>Execution has stopped at the breakpoint. The prompt has changed to indicate that we are currently stopped at a breakpoint, and the location: &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt;. To further clarify the location, we can use the &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">执行已在断点处停止。提示已更改为指示我们当前已在断点处停止，并且位置： &lt;code&gt;[qsort.hs:2:15-46]&lt;/code&gt; 。为了进一步阐明位置，我们可以使用&lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="b38d4aa4381d31a400e67cc71ccd460974a035c6" translate="yes" xml:space="preserve">
          <source>Execution phase markers</source>
          <target state="translated">执行阶段标志</target>
        </trans-unit>
        <trans-unit id="b6a16f53ed00195637e6e17e5494787580135e59" translate="yes" xml:space="preserve">
          <source>Execution strategies</source>
          <target state="translated">执行战略</target>
        </trans-unit>
        <trans-unit id="cadc56108302cd7d8880934930f927b8c99fbe2b" translate="yes" xml:space="preserve">
          <source>Existence tests</source>
          <target state="translated">存在性测试</target>
        </trans-unit>
        <trans-unit id="5e7584235c55bf0269fd90b3b4973495fe948001" translate="yes" xml:space="preserve">
          <source>ExistentialQuantification</source>
          <target state="translated">ExistentialQuantification</target>
        </trans-unit>
        <trans-unit id="e47aae11b0445849d13a157318e577826b351212" translate="yes" xml:space="preserve">
          <source>Exit the iserv process</source>
          <target state="translated">退出iserv进程</target>
        </trans-unit>
        <trans-unit id="cb193431524e4fae58710e9d90f4bc84b69056c1" translate="yes" xml:space="preserve">
          <source>ExitCaseAbort</source>
          <target state="translated">ExitCaseAbort</target>
        </trans-unit>
        <trans-unit id="0ff1b7133e455e31a96b40324f51f574297a78d9" translate="yes" xml:space="preserve">
          <source>ExitCode</source>
          <target state="translated">ExitCode</target>
        </trans-unit>
        <trans-unit id="9627d6dbece3ab140288e68f186ca8a53c5850a2" translate="yes" xml:space="preserve">
          <source>ExitSuccess</source>
          <target state="translated">ExitSuccess</target>
        </trans-unit>
        <trans-unit id="85e8ee4560b4d8b0a12df383127ad6ef2e825d1e" translate="yes" xml:space="preserve">
          <source>Exiting</source>
          <target state="translated">Exiting</target>
        </trans-unit>
        <trans-unit id="c80dbce7b21ef649a1c74b9ef8ebe0514f23c1e1" translate="yes" xml:space="preserve">
          <source>Exiting the program.</source>
          <target state="translated">退出程序。</target>
        </trans-unit>
        <trans-unit id="5871b8d86fba0af13c05dc83a5e5933bb7903327" translate="yes" xml:space="preserve">
          <source>Exp</source>
          <target state="translated">Exp</target>
        </trans-unit>
        <trans-unit id="78e98755476e343b08d10ea6578596f90d796f0c" translate="yes" xml:space="preserve">
          <source>ExpQ</source>
          <target state="translated">ExpQ</target>
        </trans-unit>
        <trans-unit id="9869e506c38f643f1fe985347c015deace6baa22" translate="yes" xml:space="preserve">
          <source>Expand</source>
          <target state="translated">Expand</target>
        </trans-unit>
        <trans-unit id="8f96935efd9a006ac921c7dacf0d186433812322" translate="yes" xml:space="preserve">
          <source>Expects an absolute file path.</source>
          <target state="translated">期待一个绝对的文件路径。</target>
        </trans-unit>
        <trans-unit id="51dd39f18dcb2e2562fb241ac2f6aeea3606be0c" translate="yes" xml:space="preserve">
          <source>Explicit &lt;code&gt;forall&lt;/code&gt; is not always required &amp;ndash; see &lt;a href=&quot;#pattern-equiv-form&quot;&gt;pattern signature equivalent&lt;/a&gt; for the example in this section, or &lt;a href=&quot;#pattern-type-sigs&quot;&gt;Pattern type signatures&lt;/a&gt;.</source>
          <target state="translated">并非总是需要显式的 &lt;code&gt;forall&lt;/code&gt; -请参阅本节中示例&lt;a href=&quot;#pattern-equiv-form&quot;&gt;等效的模式签名&lt;/a&gt;或&lt;a href=&quot;#pattern-type-sigs&quot;&gt;模式类型签名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6fa2778c6121e57a5aad745d718637106bc0e5c3" translate="yes" xml:space="preserve">
          <source>Explicit braces and semicolons can be used instead of layout:</source>
          <target state="translated">明确的大括号和分号可以用来代替布局。</target>
        </trans-unit>
        <trans-unit id="5cda5ab7163622c96737f0b582eb504bee024916" translate="yes" xml:space="preserve">
          <source>Explicit lists (e.g. &lt;code&gt;[True, False]&lt;/code&gt;)</source>
          <target state="translated">显式列表（例如 &lt;code&gt;[True, False]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="9833c09c86535a2d945ed19a1102c3bdf82ae3e8" translate="yes" xml:space="preserve">
          <source>ExplicitForAll</source>
          <target state="translated">ExplicitForAll</target>
        </trans-unit>
        <trans-unit id="8d15960eecc2d5f40b4acc3f555b51fa8aaf3c23" translate="yes" xml:space="preserve">
          <source>ExplicitNamespaces</source>
          <target state="translated">ExplicitNamespaces</target>
        </trans-unit>
        <trans-unit id="02890a2e735d14626c63f3129c86c7cdabb1bec5" translate="yes" xml:space="preserve">
          <source>Explicitly Bidirectional</source>
          <target state="translated">明确为双向的</target>
        </trans-unit>
        <trans-unit id="2d4285ba133d39020951d187ad418ec009ca8997" translate="yes" xml:space="preserve">
          <source>Explicitly bidirectional pattern synonyms offer greater flexibility than implicitly bidirectional ones in terms of the syntax that is permitted. For instance, the following is not a legal implicitly bidirectional pattern synonym:</source>
          <target state="translated">在允许使用的语法方面,显式双向模式同义词比隐式双向模式同义词具有更大的灵活性。例如,以下不属于合法的隐式双向模式同义词。</target>
        </trans-unit>
        <trans-unit id="ef7581dde501937e3e482f6cd7c00557b65093e7" translate="yes" xml:space="preserve">
          <source>Explicitly run the finaliser associated with a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. References to this value after finalisation may generate invalid memory references.</source>
          <target state="translated">显式运行与 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 关联的终结器。终结后对此值的引用可能会生成无效的内存引用。</target>
        </trans-unit>
        <trans-unit id="e9b873f46071db66ba372c05baac4fdf01be75c1" translate="yes" xml:space="preserve">
          <source>Exponent</source>
          <target state="translated">Exponent</target>
        </trans-unit>
        <trans-unit id="877e2989e6c895bad022c9991582cbad6570c551" translate="yes" xml:space="preserve">
          <source>Exponentiation of type-level naturals.</source>
          <target state="translated">类型级自然数的指数化。</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="e32d807a50078398a9f45631a08c1c50a2f61bc8" translate="yes" xml:space="preserve">
          <source>Exports just the class name.</source>
          <target state="translated">只输出类名。</target>
        </trans-unit>
        <trans-unit id="3fc8d12d849fbc12100a92378eb6aae4e19b9f4a" translate="yes" xml:space="preserve">
          <source>Exports the class, the associated type &lt;code&gt;GMap&lt;/code&gt; and the member functions &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;lookup&lt;/code&gt;, and &lt;code&gt;insert&lt;/code&gt;. The data constructors of &lt;code&gt;GMap&lt;/code&gt; (in this case &lt;code&gt;GMapEither&lt;/code&gt;) are not exported.</source>
          <target state="translated">导出类，关联的类型 &lt;code&gt;GMap&lt;/code&gt; 和成员函数 &lt;code&gt;empty&lt;/code&gt; ， &lt;code&gt;lookup&lt;/code&gt; 和 &lt;code&gt;insert&lt;/code&gt; 。 &lt;code&gt;GMap&lt;/code&gt; 的数据构造函数（在本例中为 &lt;code&gt;GMapEither&lt;/code&gt; ）不会导出。</target>
        </trans-unit>
        <trans-unit id="96d97ba437aa14160758958471b9ae9dd5fd0d5d" translate="yes" xml:space="preserve">
          <source>Expose all unfoldings, even for very large or recursive functions.</source>
          <target state="translated">暴露所有的展开,即使是非常大的或递归的函数。</target>
        </trans-unit>
        <trans-unit id="97a05c5e3c535062788e96f9df6b2c9df3c0c670" translate="yes" xml:space="preserve">
          <source>Expose package by id ⟨unit-id⟩</source>
          <target state="translated">暴露包的id⟨unit-id⟩。</target>
        </trans-unit>
        <trans-unit id="37688778d1dbdfb3378a202fe8582b76a44a828a" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩</source>
          <target state="translated">暴露包⟨pkg⟩。</target>
        </trans-unit>
        <trans-unit id="81f3b1cdb0761f66a9a464a1c7c58d8507de68a8" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">暴露软件包&amp;ldquo; pkg&amp;rdquo;，并将其设置为不信任状态。请参阅&lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8c2973c3230c9855092c9a09e0ad4f1866c0b24" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be distrusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">暴露软件包&amp;ldquo; pkg&amp;rdquo;并将其设置为不信任状态。请参阅&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11e656340a6337a3a218f8e6e5a6343ef2676dc0" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">公开软件包&amp;ldquo; pkg&amp;rdquo;并将其设置为受信任。请参阅&lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80e66e14fce5ee7a55e29cdb00dc7373ae77bc67" translate="yes" xml:space="preserve">
          <source>Expose package ⟨pkg⟩ and set it to be trusted. See &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;.</source>
          <target state="translated">公开软件包&amp;ldquo; pkg&amp;rdquo;并将其设置为受信任。请参阅&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a89902d15adce30fd9f53b376aa347621678477" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg-id⟩ for plugins</source>
          <target state="translated">为插件公开⟨pkg-id⟩。</target>
        </trans-unit>
        <trans-unit id="0d375bc2563394c46196316fad7e222d95093011" translate="yes" xml:space="preserve">
          <source>Expose ⟨pkg⟩ for plugins</source>
          <target state="translated">暴露⟨pkg⟩为插件。</target>
        </trans-unit>
        <trans-unit id="31273b92a37ac408e2bf693485bae87890959943" translate="yes" xml:space="preserve">
          <source>Exposes a package in the plugin namespace like &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package
⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its installed package ID rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; flags to GHC. &lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">在插件名称空间中公开一个软件包，例如&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;，但是该软件包是以其已安装的软件包ID而不是名称来命名的。这是一种更可靠的命名包的方法，可用于选择否则会被遮盖的包。 Cabal将&lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt;标志传递给GHC。&lt;a href=&quot;#ghc-flag--plugin-package-id%20%E2%9F%A8pkg-id%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package-id ⟨pkg-id⟩&lt;/code&gt; &lt;/a&gt;支持稀化和重&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;命名模块中&lt;/a&gt;介绍的稀化和重命名。</target>
        </trans-unit>
        <trans-unit id="7282a9f671014a5a12b95db9b6e9d0017367cafb" translate="yes" xml:space="preserve">
          <source>Exposes a package like &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;, but the package is named by its unit ID (i.e. the value of &lt;code&gt;id&lt;/code&gt; in its entry in the installed package database, also previously known as an installed package ID) rather than by name. This is a more robust way to name packages, and can be used to select packages that would otherwise be shadowed. Cabal passes &lt;code&gt;-package-id&lt;/code&gt; flags to GHC. &lt;code&gt;-package-id&lt;/code&gt; supports thinning and renaming described in &lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">公开像&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;这样的软件包，但是该软件包以其单位ID（即已安装的软件包数据库中其条目中 &lt;code&gt;id&lt;/code&gt; 的值，也称为先前已安装的软件包ID）命名，而不是通过名称来命名。这是一种更可靠的命名包的方法，可用于选择否则会被遮盖的包。Cabal将 &lt;code&gt;-package-id&lt;/code&gt; 标志传递给GHC。 &lt;code&gt;-package-id&lt;/code&gt; 支持稀化和重&lt;a href=&quot;#package-thinning-and-renaming&quot;&gt;命名模块中&lt;/a&gt;描述的稀化和重命名。</target>
        </trans-unit>
        <trans-unit id="eba39a9246ec8d3133e56adef9502fd5768f6301" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it a trusted package regardless of the package database.</source>
          <target state="translated">如果包⟨pkg⟩被隐藏了,就会暴露包,不管包数据库如何,都认为是受信任的包。</target>
        </trans-unit>
        <trans-unit id="1863c0103a35229fbd10f03c71eaa9dfd10d3726" translate="yes" xml:space="preserve">
          <source>Exposes package ⟨pkg⟩ if it was hidden and considers it an untrusted package regardless of the package database.</source>
          <target state="translated">暴露包⟨pkg⟩如果是隐藏的包,不管包数据库如何,都认为是不信任的包。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="b4b58a3bd3bca39250be0caf31bc3f191c3d3f5c" translate="yes" xml:space="preserve">
          <source>Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</source>
          <target state="translated">表达式引号接受大多数 Haskell 语言结构。然而,目前表达式引号不支持一些特定于 GHC 的扩展,包括</target>
        </trans-unit>
        <trans-unit id="776e1ed70ff53446d3e23e14206d1868975984de" translate="yes" xml:space="preserve">
          <source>Expression splices: anonymous and named wildcards can be used in expression signatures. Extra-constraints wildcards are not supported, just like in regular expression signatures.</source>
          <target state="translated">表达式拼接:表达式签名中可以使用匿名和命名的通配符。不支持额外约束通配符,就像在正则表达式签名中一样。</target>
        </trans-unit>
        <trans-unit id="4c356f5e7e4d5da3fa92f3a447cf549c220408dd" translate="yes" xml:space="preserve">
          <source>Expression type annotations</source>
          <target state="translated">表达式注释</target>
        </trans-unit>
        <trans-unit id="3da441768abbdbc67e62f834d5dc1520b1d2404c" translate="yes" xml:space="preserve">
          <source>Expression-evaluation mode. This is very similar to interactive mode, except that there is a single expression to evaluate (⟨expr⟩) which is given on the command line. See &lt;a href=&quot;#eval-mode&quot;&gt;Expression evaluation mode&lt;/a&gt; for more details.</source>
          <target state="translated">表情评估模式。这与交互模式非常相似，除了在命令行上有一个要评估的表达式（⟨expr⟩）。有关更多详细信息，请参见&lt;a href=&quot;#eval-mode&quot;&gt;表达式评估模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="275a91a95ab556ed8f4f58810f3754cc004740c4" translate="yes" xml:space="preserve">
          <source>Exquisitely unsafe.</source>
          <target state="translated">异常不安全。</target>
        </trans-unit>
        <trans-unit id="f20ecbb0b8def6d6be9c1c1d5504d4aa8e121b40" translate="yes" xml:space="preserve">
          <source>Extended euclidean algorithm.</source>
          <target state="translated">扩展的欧几里得算法。</target>
        </trans-unit>
        <trans-unit id="1376ee00053aa4b8f335d718cd6b32eade0d6b7b" translate="yes" xml:space="preserve">
          <source>Extended version of &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 的扩展版本</target>
        </trans-unit>
        <trans-unit id="2fde66be8f0b7d74100f58661df4304a6a4125c1" translate="yes" xml:space="preserve">
          <source>ExtendedDefaultRules</source>
          <target state="translated">ExtendedDefaultRules</target>
        </trans-unit>
        <trans-unit id="a5fe846d7930403bb12925a53f1812f6d7b386f3" translate="yes" xml:space="preserve">
          <source>ExtendedFormat</source>
          <target state="translated">ExtendedFormat</target>
        </trans-unit>
        <trans-unit id="d297572cdf75e0fc69b0851ecb181ba44e9e43c3" translate="yes" xml:space="preserve">
          <source>ExtendedFunctions</source>
          <target state="translated">ExtendedFunctions</target>
        </trans-unit>
        <trans-unit id="19831f202245d7d2e8594d815d8ec9b0ca11a673" translate="yes" xml:space="preserve">
          <source>Extending To New Types</source>
          <target state="translated">扩展到新类型</target>
        </trans-unit>
        <trans-unit id="d9d7e1571d0f21e76efd77f308d22979ff95823f" translate="yes" xml:space="preserve">
          <source>Extending the atomicity to multiple &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;s is problematic, so it is recommended that if you need to do anything more complicated then using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; instead is a good idea.</source>
          <target state="translated">将原子性扩展到多个 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 是有问题的，因此建议如果您需要做更复杂的事情，则最好使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32e045360ba1cab276fc39bb4d35f14e0162488f" translate="yes" xml:space="preserve">
          <source>Extensible Exceptions</source>
          <target state="translated">可扩展的异常</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="0508e77219f46be972ce3c02c3d431e8dfa41ced" translate="yes" xml:space="preserve">
          <source>Extension functions</source>
          <target state="translated">扩展功能</target>
        </trans-unit>
        <trans-unit id="b548c2c0e4fdd3a3b443d1717032aa1c37d0f158" translate="yes" xml:space="preserve">
          <source>External API for GHC's Handle implementation</source>
          <target state="translated">GHC手柄实现的外部API。</target>
        </trans-unit>
        <trans-unit id="16bb88e5a699d082f65df34dff99c2cc562f221d" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Frameset</source>
          <target state="translated">XHTML框架中的额外属性</target>
        </trans-unit>
        <trans-unit id="f69729e705bc5ed85ac415d6b079562cec0ad227" translate="yes" xml:space="preserve">
          <source>Extra attributes in XHTML Transitional</source>
          <target state="translated">在XHTML过渡期的额外属性</target>
        </trans-unit>
        <trans-unit id="553906fce6304e8619f26f965d66b3c128e56184" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Frameset</source>
          <target state="translated">XHTML框架组中的额外元素</target>
        </trans-unit>
        <trans-unit id="26b12138ed5c4f776e03e07094f229d75bf93c68" translate="yes" xml:space="preserve">
          <source>Extra elements in XHTML Transitional</source>
          <target state="translated">XHTML过渡期的额外元素</target>
        </trans-unit>
        <trans-unit id="da60db19e688c9d65306dbe01f15f0fdb2f70b5e" translate="yes" xml:space="preserve">
          <source>Extra functions for creating and executing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. They are intended for application-specific fine-tuning the performance of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">用于创建和执行 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的附加功能。它们旨在用于特定于应用程序的微调 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的性能。</target>
        </trans-unit>
        <trans-unit id="376098e515a5a7a4ad09f15cc26f6f580a3f3f98" translate="yes" xml:space="preserve">
          <source>Extra instances</source>
          <target state="translated">额外实例</target>
        </trans-unit>
        <trans-unit id="9007458c8fef52cf2dfc82ca45560435a502b151" translate="yes" xml:space="preserve">
          <source>Extra libraries may be specified on the command line using the normal &lt;code&gt;-llib&lt;/code&gt; option. (The term &lt;em&gt;library&lt;/em&gt; here refers to libraries of foreign object code; for using libraries of Haskell source code, see &lt;a href=&quot;#ghci-modules-filenames&quot;&gt;Modules vs. filenames&lt;/a&gt;.) For example, to load the &amp;ldquo;m&amp;rdquo; library:</source>
          <target state="translated">可以使用普通的 &lt;code&gt;-llib&lt;/code&gt; 选项在命令行上指定其他库。（这里的&lt;em&gt;库&lt;/em&gt;是指外来对象代码的库；有关使用Haskell源代码的库，请参阅&lt;a href=&quot;#ghci-modules-filenames&quot;&gt;模块与文件名&lt;/a&gt;。）例如，加载&amp;ldquo; m&amp;rdquo;库：</target>
        </trans-unit>
        <trans-unit id="94db6ab5b7a358912d06ebf314fa45afb8a5bfbb" translate="yes" xml:space="preserve">
          <source>Extra-constraints wildcards cannot be named.</source>
          <target state="translated">额外约束通配符不能被命名。</target>
        </trans-unit>
        <trans-unit id="85204331cdc5a5234455094d82f670148ee95ebf" translate="yes" xml:space="preserve">
          <source>Extract &lt;em&gt;n&lt;/em&gt;-th (0-based) limb in &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;n&lt;/em&gt; must be less than size as reported by &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 中提取第&lt;em&gt;n&lt;/em&gt;个（从0开始）肢体。&lt;em&gt;n&lt;/em&gt;必须小于 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeofBigNat-35-&quot;&gt;sizeofBigNat#&lt;/a&gt;&lt;/code&gt; 报告的大小。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83cd2d2591e39909edf59b0149e6f118b65261cb" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">提取Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 从Haskell的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并在其上执行的操作。</target>
        </trans-unit>
        <trans-unit id="8caedd806eb75a1dd1593915008b003746bd2766" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">提取Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 从Haskell的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并在其上执行的操作。</target>
        </trans-unit>
        <trans-unit id="e1fa28e22bcf37a9620ff9632c0178f62249b64b" translate="yes" xml:space="preserve">
          <source>Extract a Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; from a Haskell &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and perform an action on it.</source>
          <target state="translated">提取Windows &lt;code&gt;&lt;a href=&quot;system-win32-types#t:HANDLE&quot;&gt;HANDLE&lt;/a&gt;&lt;/code&gt; 从Haskell的 &lt;code&gt;&lt;a href=&quot;../base/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并在其上执行的操作。</target>
        </trans-unit>
        <trans-unit id="19459f6f6029b9562ac7b8bae42f2d17949ad995" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 中提取呼叫站点列表。</target>
        </trans-unit>
        <trans-unit id="dac372cf1e3a7a31e848e034a3e801d7adfa82f1" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 中提取呼叫站点列表。</target>
        </trans-unit>
        <trans-unit id="15320bf99294a6713c984fb7ea9afb23bf9f7574" translate="yes" xml:space="preserve">
          <source>Extract a list of call-sites from the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 中提取呼叫站点列表。</target>
        </trans-unit>
        <trans-unit id="b3c94be241aef7a388442a14750ccab2863f4fb0" translate="yes" xml:space="preserve">
          <source>Extract a witness of equality of two types</source>
          <target state="translated">提取两种类型的平等见证</target>
        </trans-unit>
        <trans-unit id="1c9f2b2fd473a09dd65773f2fc4162151096161e" translate="yes" xml:space="preserve">
          <source>Extract bits from a word at locations specified by a mask.</source>
          <target state="translated">在掩码指定的位置从字中提取比特。</target>
        </trans-unit>
        <trans-unit id="f3c5f3c2ea4a5cd70d10527f67daa863bccf6943" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 16 bits of a word at locations specified by a mask.</source>
          <target state="translated">在掩码指定的位置从字的低16位中提取比特。</target>
        </trans-unit>
        <trans-unit id="c24c9008df295389591cc7deb4f2a2d68e7c6b1c" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 32 bits of a word at locations specified by a mask.</source>
          <target state="translated">在掩码指定的位置从字的低32位提取比特。</target>
        </trans-unit>
        <trans-unit id="f2cc34ff176f2175e6e34bb0cdc8cd7517e09bd6" translate="yes" xml:space="preserve">
          <source>Extract bits from lower 8 bits of a word at locations specified by a mask.</source>
          <target state="translated">在掩码指定的位置从字的低8位提取比特。</target>
        </trans-unit>
        <trans-unit id="f1857d7fa6cd46609ec91ad030bedb1462ff8de3" translate="yes" xml:space="preserve">
          <source>Extract equality of the arguments from an equality of applied types</source>
          <target state="translated">从应用类型的平等中提取参数的平等性。</target>
        </trans-unit>
        <trans-unit id="a99a8380cb42a1ba110471522ef91ef98bfe57c8" translate="yes" xml:space="preserve">
          <source>Extract equality of type constructors from an equality of applied types</source>
          <target state="translated">从应用类型的平等中提取类型构造函数的平等。</target>
        </trans-unit>
        <trans-unit id="209b131507b67783064eca27720c5bbe3fbc4b1e" translate="yes" xml:space="preserve">
          <source>Extract everything except the last element of the stream.</source>
          <target state="translated">提取除了流的最后一个元素之外的所有内容。</target>
        </trans-unit>
        <trans-unit id="e6da9a2e3b63f515594693602b689849079aaa62" translate="yes" xml:space="preserve">
          <source>Extract the denominator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">用缩小的形式提取比的分母:分子和分母没有公因数,分母为正数。</target>
        </trans-unit>
        <trans-unit id="faa5733bddece05d48a2d5fab4a6b5d19927ff0f" translate="yes" xml:space="preserve">
          <source>Extract the first component of a pair.</source>
          <target state="translated">提取一对中的第一个成分。</target>
        </trans-unit>
        <trans-unit id="8e1431bbaba37fcca3d788ca32422f37c47e0f53" translate="yes" xml:space="preserve">
          <source>Extract the first element of the stream.</source>
          <target state="translated">提取流的第一个元素。</target>
        </trans-unit>
        <trans-unit id="74dba7610acef8dde9eb95e9dcdd115a56c67e63" translate="yes" xml:space="preserve">
          <source>Extract the last element of the stream.</source>
          <target state="translated">提取流的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="71672882a12f0371a79613a5b2a1896e09a4aea8" translate="yes" xml:space="preserve">
          <source>Extract the message string from an error message</source>
          <target state="translated">从错误信息中提取信息字符串</target>
        </trans-unit>
        <trans-unit id="0627b6c102c0812e00a5765ad3ea478aeb42dc0d" translate="yes" xml:space="preserve">
          <source>Extract the numerator of the ratio in reduced form: the numerator and denominator have no common factor and the denominator is positive.</source>
          <target state="translated">用缩小的形式提取比的分子:分子和分母没有公因数,分母为正数。</target>
        </trans-unit>
        <trans-unit id="ccae588e4f18a0d7150f16e84a2466cf53e67121" translate="yes" xml:space="preserve">
          <source>Extract the output from a writer computation.</source>
          <target state="translated">提取作家计算的输出。</target>
        </trans-unit>
        <trans-unit id="e13a7d27f5717a8051ad34044b84ac3c322dad08" translate="yes" xml:space="preserve">
          <source>Extract the output from an accumulation computation.</source>
          <target state="translated">从累积计算中提取输出。</target>
        </trans-unit>
        <trans-unit id="9b59da5a9fb1822fe3838decbce6b18c7bb10353" translate="yes" xml:space="preserve">
          <source>Extract the possibly-empty tail of the stream.</source>
          <target state="translated">提取流中可能为空的尾巴。</target>
        </trans-unit>
        <trans-unit id="c80d49f20d5312d630bb4c89de7be96ba635eeb8" translate="yes" xml:space="preserve">
          <source>Extract the second component of a pair.</source>
          <target state="translated">提取一对中的第二个成分。</target>
        </trans-unit>
        <trans-unit id="048e8268764c5263423031088d1cd0a66e5df985" translate="yes" xml:space="preserve">
          <source>Extract the untyped representation from the typed representation</source>
          <target state="translated">从类型化表征中提取非类型化表征。</target>
        </trans-unit>
        <trans-unit id="f87182d58b2e5c3b8ac01884cc785fccbf6f2e02" translate="yes" xml:space="preserve">
          <source>Extracting components of fractions.</source>
          <target state="translated">提取分数的成分。</target>
        </trans-unit>
        <trans-unit id="66c1d08c125187599a1f446de72b7b3934ea1356" translate="yes" xml:space="preserve">
          <source>Extracting sublists</source>
          <target state="translated">提取子列表</target>
        </trans-unit>
        <trans-unit id="1e06f8844a90f3392493e9ddf149b5c480a88612" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">用于在异常monad中进行计算的提取器。（ &lt;code&gt;&lt;a href=&quot;../transformers-0.5.6.2/control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 的倒数）。</target>
        </trans-unit>
        <trans-unit id="f6f7a3f48fe2a36a8d1f4f84df1cff70314fddb2" translate="yes" xml:space="preserve">
          <source>Extractor for computations in the exception monad. (The inverse of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">用于在异常monad中进行计算的提取器。（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:except&quot;&gt;except&lt;/a&gt;&lt;/code&gt; 的倒数）。</target>
        </trans-unit>
        <trans-unit id="3aca5f828a77e707fa46ed0c55a1b00b856836a4" translate="yes" xml:space="preserve">
          <source>Extractor for computations with accumulating errors.</source>
          <target state="translated">累积误差计算的提取器。</target>
        </trans-unit>
        <trans-unit id="e2053668b7ebb2019a802842e9789436a8c0f771" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">从列表提取物 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 全部 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 元素。按顺序提取所有 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="23593562fd69e1de66ae4e632731e63b67f94b89" translate="yes" xml:space="preserve">
          <source>Extracts from a list of &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; all the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements. All the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; elements are extracted in order.</source>
          <target state="translated">从列表提取物 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 全部 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 元素。按顺序提取所有 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="47765e86c15d457b99a9254fc457aec3171dfef3" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中提取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。如果需要，此函数具有关闭 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并刷新其写缓冲区的副作用。</target>
        </trans-unit>
        <trans-unit id="56cd8ea295a261029ef6e0001e10564c02952e69" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中提取 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。如果需要，此函数具有关闭 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并刷新其写缓冲区的副作用。</target>
        </trans-unit>
        <trans-unit id="12df19590e3fea55c64fb5d4077a86cd9854c08f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;. This function has the side effect of closing the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; and flushing its write buffer, if necessary.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中提取 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。如果需要，此函数具有关闭 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 并刷新其写缓冲区的副作用。</target>
        </trans-unit>
        <trans-unit id="d37c14699604a03fd4d86810b3d7950f2e52cc77" translate="yes" xml:space="preserve">
          <source>Extracts the bounds of an immutable array</source>
          <target state="translated">提取一个不可变数组的边界。</target>
        </trans-unit>
        <trans-unit id="3927ad512fc6801a8c448cfc25e6c4a5aa1e6fdc" translate="yes" xml:space="preserve">
          <source>Extracts the column number from a source position.</source>
          <target state="translated">从源位置提取列号。</target>
        </trans-unit>
        <trans-unit id="f98a98ccf1f30629f52ac9fd6ceee04b851c3cb8" translate="yes" xml:space="preserve">
          <source>Extracts the imaginary part of a complex number.</source>
          <target state="translated">提取复数的虚部。</target>
        </trans-unit>
        <trans-unit id="72b735a2e8cc21e50312444f0be2cba46269cdb2" translate="yes" xml:space="preserve">
          <source>Extracts the line number from a source position.</source>
          <target state="translated">从源位置提取行号。</target>
        </trans-unit>
        <trans-unit id="5aa85df9b78b3e81e43bd5f3eef197d388f12497" translate="yes" xml:space="preserve">
          <source>Extracts the list of error messages from the parse error</source>
          <target state="translated">从解析错误中提取错误信息列表。</target>
        </trans-unit>
        <trans-unit id="1d52fc67cbb595042e4bfe8748fe75b10e3bfaf9" translate="yes" xml:space="preserve">
          <source>Extracts the name of the source from a source position.</source>
          <target state="translated">从源位置提取源的名称。</target>
        </trans-unit>
        <trans-unit id="fa7820eeb9c8d1f0372901d7c48b937c85bd82cf" translate="yes" xml:space="preserve">
          <source>Extracts the real part of a complex number.</source>
          <target state="translated">提取复数的实部。</target>
        </trans-unit>
        <trans-unit id="1463e681d793be66e7fe209521155ad317d859f8" translate="yes" xml:space="preserve">
          <source>Extracts the source position from the parse error</source>
          <target state="translated">从解析错误中提取源位置。</target>
        </trans-unit>
        <trans-unit id="3b729075855fa307e52f7a82b9acfe92bcb6b2c8" translate="yes" xml:space="preserve">
          <source>F. Lundh: The Fast Search Algorithm. &lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm&lt;/a&gt; (2006)</source>
          <target state="translated">F. Lundh：快速搜索算法。&lt;a href=&quot;http://effbot.org/zone/stringlib.htm&quot;&gt;http://effbot.org/zone/stringlib.htm（2006&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="280c80844f01a9db84ec5402a6bd821338a8cfbf" translate="yes" xml:space="preserve">
          <source>FD</source>
          <target state="translated">FD</target>
        </trans-unit>
        <trans-unit id="07e3e68b1daed47acfe17b62cf16a3642bb89af6" translate="yes" xml:space="preserve">
          <source>FD_CLOEXEC</source>
          <target state="translated">FD_CLOEXEC</target>
        </trans-unit>
        <trans-unit id="6f76a711154e10c8b7d9ded2ab1414e67e29bdbc" translate="yes" xml:space="preserve">
          <source>FFExponent</source>
          <target state="translated">FFExponent</target>
        </trans-unit>
        <trans-unit id="9aa9cec1f34d9fa7339b6f9c8dfdf9bf6e52e0d8" translate="yes" xml:space="preserve">
          <source>FFFixed</source>
          <target state="translated">FFFixed</target>
        </trans-unit>
        <trans-unit id="de69c96e4288f9614d0d84273990ab542079c11c" translate="yes" xml:space="preserve">
          <source>FFFormat</source>
          <target state="translated">FFFormat</target>
        </trans-unit>
        <trans-unit id="b3876baa83fd86b2878e18b0db680254a946fea2" translate="yes" xml:space="preserve">
          <source>FFGeneric</source>
          <target state="translated">FFGeneric</target>
        </trans-unit>
        <trans-unit id="62b8d6cc22c479012823c38f9f1c4e6a0ca2ec3f" translate="yes" xml:space="preserve">
          <source>FFI datatypes and operations that use or require concurrency (GHC only).</source>
          <target state="translated">使用或需要并发的FFI数据类型和操作(仅GHC)。</target>
        </trans-unit>
        <trans-unit id="72ef38f5a65a645f475c68f4dff976400453ed6a" translate="yes" xml:space="preserve">
          <source>FFI support is enabled by default, but can be enabled or disabled explicitly with the &lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt;&lt;code&gt;ForeignFunctionInterface&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">FFI支持默认情况下处于启用状态，但可以使用&lt;a href=&quot;#extension-ForeignFunctionInterface&quot;&gt; &lt;code&gt;ForeignFunctionInterface&lt;/code&gt; &lt;/a&gt;标志显式启用或禁用。</target>
        </trans-unit>
        <trans-unit id="e54402f59eaf0ee8458f6bec4af7033bf2817f96" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with SimpleMAPI</source>
          <target state="translated">与SimpleMAPI交互的FFI-bindings。</target>
        </trans-unit>
        <trans-unit id="d9f5ec79f6b4ceeadbaeb6e44d31fab891b6c294" translate="yes" xml:space="preserve">
          <source>FFI-bindings to interact with Win32 Security</source>
          <target state="translated">与Win32安全交互的FFI-绑定</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="b5842d158a0ef95bb05982b944ce15a5f0702019" translate="yes" xml:space="preserve">
          <source>FOR ALL</source>
          <target state="translated">所有人</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="e7c189bd9105436a22b6dc9c0118398b753dc2ec" translate="yes" xml:space="preserve">
          <source>FPFormat</source>
          <target state="translated">FPFormat</target>
        </trans-unit>
        <trans-unit id="b332cee2f39f6c7203f896ba88110e82aff15a68" translate="yes" xml:space="preserve">
          <source>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</source>
          <target state="translated">面对上面描述的问题,一些Haskell程序员可能会想使用类似下面版本的类声明。</target>
        </trans-unit>
        <trans-unit id="dae896f141aeb2a67159098fa3c417c9d9c6e0ef" translate="yes" xml:space="preserve">
          <source>Failure records information about the cause/location of the failure. Failure values bypass the bound function, other values are used as inputs to the bound function.</source>
          <target state="translated">失败记录了关于失败的原因/位置的信息。失败值绕过约束函数,其他值作为约束函数的输入。</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="93d46a9da7001524df4cde3ca05b775fe0b85bf2" translate="yes" xml:space="preserve">
          <source>Family instances are implicitly exported, just like class instances. However, this applies only to the heads of instances, not to the data constructors an instance defines.</source>
          <target state="translated">家族实例和类实例一样,是隐式导出的。但是,这只适用于实例的头部,而不是实例定义的数据构造函数。</target>
        </trans-unit>
        <trans-unit id="7c03cfd18e7c0aa33fb0869c7db1ce2c71a9f1e4" translate="yes" xml:space="preserve">
          <source>FamilyResultSig</source>
          <target state="translated">FamilyResultSig</target>
        </trans-unit>
        <trans-unit id="5709a3aacba98eb7dab9b3ec1486beeceefdb838" translate="yes" xml:space="preserve">
          <source>FamilyResultSigQ</source>
          <target state="translated">FamilyResultSigQ</target>
        </trans-unit>
        <trans-unit id="6ee40b96a43fdbccb9bc7964f655f965fe647da5" translate="yes" xml:space="preserve">
          <source>Fanin: Split the input between the two argument arrows and merge their outputs.</source>
          <target state="translated">Fanin:在两个参数箭头之间分割输入,并合并其输出。</target>
        </trans-unit>
        <trans-unit id="3d081b433b8a30d7f41b2cdd2ab22d0c446b40a8" translate="yes" xml:space="preserve">
          <source>Fanout: send the input to both argument arrows and combine their output.</source>
          <target state="translated">扇出:将输入发送到两个参数箭头,并结合它们的输出。</target>
        </trans-unit>
        <trans-unit id="a1448d14f32031abf80a6b03dd5aed71399356a2" translate="yes" xml:space="preserve">
          <source>Fast &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; logarithms to base 2. &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; are of general usefulness, the others are only needed for a fast implementation of &lt;code&gt;fromRational&lt;/code&gt;. Since they are needed in &lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;, we must expose this module, but it should not show up in the docs.</source>
          <target state="translated">以2为底的快速 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 对数 &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:wordLog2-35-&quot;&gt;wordLog2#&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer-logarithms-internals#v:integerLog2-35-&quot;&gt;integerLog2#&lt;/a&gt;&lt;/code&gt; 和wordLog2＃具有通用性，其他两个仅用于快速实现 &lt;code&gt;fromRational&lt;/code&gt; 。由于&lt;a href=&quot;ghc-float&quot;&gt;GHC.Float&lt;/a&gt;中需要它们，因此我们必须公开此模块，但不应在文档中显示它。</target>
        </trans-unit>
        <trans-unit id="604c30fffeb97fca92cde7e102ee6fa4c46126b4" translate="yes" xml:space="preserve">
          <source>Fast access to the system clock.</source>
          <target state="translated">快速访问系统时钟。</target>
        </trans-unit>
        <trans-unit id="dd750b3188ada6606559e5e05cd316edbb060aa4" translate="yes" xml:space="preserve">
          <source>Fast character manipulation functions.</source>
          <target state="translated">快速的字符操作功能。</target>
        </trans-unit>
        <trans-unit id="a12096fc3f71f15571f0bdb559c8a630fd59e216" translate="yes" xml:space="preserve">
          <source>Fast substring search for &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh.</source>
          <target state="translated">根据Boyer，Moore，Horspool，Sunday和Lundh的工作，快速搜索 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的子字符串。</target>
        </trans-unit>
        <trans-unit id="ff1949d07a3568ece3a1b271a32199c64e456437" translate="yes" xml:space="preserve">
          <source>Fast substring search for lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, based on work by Boyer, Moore, Horspool, Sunday, and Lundh. Adapted from the strict implementation.</source>
          <target state="translated">基于Boyer，Moore，Horspool，Sunday和Lundh的工作，对懒惰的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 进行快速子字符串搜索。从严格执行改编而成。</target>
        </trans-unit>
        <trans-unit id="d5053d7cd5f1b006c98595f6bd4ac62f10f404ea" translate="yes" xml:space="preserve">
          <source>Fast, unchecked bit shifting functions.</source>
          <target state="translated">快速、未被选中的位移功能。</target>
        </trans-unit>
        <trans-unit id="6ce335ee3b25f9d7b908119c787dacbffab32155" translate="yes" xml:space="preserve">
          <source>Fd</source>
          <target state="translated">Fd</target>
        </trans-unit>
        <trans-unit id="f4e08a048eae08fd45b1d7080137ccedd2e9a232" translate="yes" xml:space="preserve">
          <source>FdKey</source>
          <target state="translated">FdKey</target>
        </trans-unit>
        <trans-unit id="9075ca9a523e56d968e61c7fa9bd0c125d3dbaa9" translate="yes" xml:space="preserve">
          <source>FdOption</source>
          <target state="translated">FdOption</target>
        </trans-unit>
        <trans-unit id="ff381dc1fa65f2d09b763ebd9d555902bb4b8aa8" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 提供更多输入。如果 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 被 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 将输入添加到 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 未消耗的输入。</target>
        </trans-unit>
        <trans-unit id="4e9b2c02289e4857fb2ab57f2809114796555b9f" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 提供更多输入。如果 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 被 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 将输入添加到 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 未消耗的输入。</target>
        </trans-unit>
        <trans-unit id="69e3b2b59aa4aebef05a2ee1ed5b935914ea9021" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 提供更多输入。如果 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 被 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 将输入添加到 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 未消耗的输入。</target>
        </trans-unit>
        <trans-unit id="99b4648ed500c37b8a76ac1f7c07fc6a62b9d886" translate="yes" xml:space="preserve">
          <source>Feed a &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; with more input. If the &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; it will add the input to &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; of unconsumed input.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 提供更多输入。如果 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 被 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Done&quot;&gt;Done&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-binary-get#v:Fail&quot;&gt;Fail&lt;/a&gt;&lt;/code&gt; 将输入添加到 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 未消耗的输入。</target>
        </trans-unit>
        <trans-unit id="7bd5bf737c14ded7353e41c04daecd9804c7b9d6" translate="yes" xml:space="preserve">
          <source>Feed marked inputs through the argument arrow, passing the rest through unchanged to the output.</source>
          <target state="translated">将标记的输入通过参数箭头送入,其余的不变地传递到输出。</target>
        </trans-unit>
        <trans-unit id="c8d7677e19495f21da984fe4e2829b7ca91b27c7" translate="yes" xml:space="preserve">
          <source>Feedback</source>
          <target state="translated">Feedback</target>
        </trans-unit>
        <trans-unit id="b1673adba303c1f23dda58f316aeab11e438ee50" translate="yes" xml:space="preserve">
          <source>Fetch the current value of the state within the monad.</source>
          <target state="translated">获取单体内状态的当前值。</target>
        </trans-unit>
        <trans-unit id="9655bb220d4cd1a7d2999eacc755e15eb55c9e74" translate="yes" xml:space="preserve">
          <source>Fetch the value of the environment.</source>
          <target state="translated">获取环境的值。</target>
        </trans-unit>
        <trans-unit id="c251e678b25c081d063a5d28ed8182955bdb81eb" translate="yes" xml:space="preserve">
          <source>Fewest inaccessible clauses</source>
          <target state="translated">尽量减少不可接触的条款</target>
        </trans-unit>
        <trans-unit id="7e2728111a7fab96f0d3a4080311c545fe9cc7bf" translate="yes" xml:space="preserve">
          <source>Fewest redundant clauses</source>
          <target state="translated">冗余条款最少</target>
        </trans-unit>
        <trans-unit id="d6b6429e633d85c9027c14440388d087da532ae3" translate="yes" xml:space="preserve">
          <source>Fewest uncovered clauses</source>
          <target state="translated">未涵盖的条款最少</target>
        </trans-unit>
        <trans-unit id="28f549c52b7931248dae14989071407da27552c4" translate="yes" xml:space="preserve">
          <source>Field CapNo</source>
          <target state="translated">字段编号</target>
        </trans-unit>
        <trans-unit id="03ded020bc6474da975890833ccd8f148e8a07d9" translate="yes" xml:space="preserve">
          <source>Field CapNo:</source>
          <target state="translated">场地帽号</target>
        </trans-unit>
        <trans-unit id="b4fe29f979583aef741d1f90e93bfaa345f64333" translate="yes" xml:space="preserve">
          <source>Field CapSetId</source>
          <target state="translated">字段 CapSetId</target>
        </trans-unit>
        <trans-unit id="fac78598db657aa0c38e0a7b064e261405764b90" translate="yes" xml:space="preserve">
          <source>Field CapSetId:</source>
          <target state="translated">字段CapSetId。</target>
        </trans-unit>
        <trans-unit id="3d376a5f188ba09d0575c030e75276555ef3037b" translate="yes" xml:space="preserve">
          <source>Field String</source>
          <target state="translated">字段字符串</target>
        </trans-unit>
        <trans-unit id="a62e5ff1d5e101aeed17e5d052a10aaa3017be5b" translate="yes" xml:space="preserve">
          <source>Field String:</source>
          <target state="translated">字段字符串。</target>
        </trans-unit>
        <trans-unit id="5e33298c696fedbed9fc0116f43829e5721d9f07" translate="yes" xml:space="preserve">
          <source>Field TaskId</source>
          <target state="translated">字段任务ID</target>
        </trans-unit>
        <trans-unit id="a3803a8cbdbe813e945dd95bbdc4dffab8ccbfd7" translate="yes" xml:space="preserve">
          <source>Field TaskId:</source>
          <target state="translated">现场任务ID。</target>
        </trans-unit>
        <trans-unit id="6ee11d3a290e704407e05db1631372bf1b3dbe72" translate="yes" xml:space="preserve">
          <source>Field ThreadId</source>
          <target state="translated">字段 ThreadId</target>
        </trans-unit>
        <trans-unit id="c3a47467c208f9af64bcfa1d0225564748d7312c" translate="yes" xml:space="preserve">
          <source>Field ThreadId:</source>
          <target state="translated">Field ThreadId:</target>
        </trans-unit>
        <trans-unit id="033928db92181f79852ddc994a0c003ec14b17e1" translate="yes" xml:space="preserve">
          <source>Field Word16</source>
          <target state="translated">场字16</target>
        </trans-unit>
        <trans-unit id="cbcfd83bc4c9e590b27d81c7a0808713eab58ee9" translate="yes" xml:space="preserve">
          <source>Field Word16:</source>
          <target state="translated">场字16。</target>
        </trans-unit>
        <trans-unit id="46e5a07512e61c7eb3e794df15878325a5e53713" translate="yes" xml:space="preserve">
          <source>Field Word32</source>
          <target state="translated">字段 Word32</target>
        </trans-unit>
        <trans-unit id="42f1a115395af35bce115c6c82b59e4a4a5087fa" translate="yes" xml:space="preserve">
          <source>Field Word32:</source>
          <target state="translated">字段Word32。</target>
        </trans-unit>
        <trans-unit id="e0536b1c8eb0eeac80c4b4a595b342d8367bd6a0" translate="yes" xml:space="preserve">
          <source>Field Word32[]</source>
          <target state="translated">字段 Word32[]</target>
        </trans-unit>
        <trans-unit id="e59e9060dc4635660cb6bfaff4355ba8a486745a" translate="yes" xml:space="preserve">
          <source>Field Word32[]:</source>
          <target state="translated">字段Word32[]。</target>
        </trans-unit>
        <trans-unit id="727d70feadcbb92b2fc2f2668935aa3272996214" translate="yes" xml:space="preserve">
          <source>Field Word64</source>
          <target state="translated">字段64</target>
        </trans-unit>
        <trans-unit id="7cbbdf7e0b7dfdebe7dfe21d03bf00d60a18f320" translate="yes" xml:space="preserve">
          <source>Field Word64:</source>
          <target state="translated">场字64。</target>
        </trans-unit>
        <trans-unit id="a846bfa3518bf3d88d0ce3066df98c589343374a" translate="yes" xml:space="preserve">
          <source>Field Word8</source>
          <target state="translated">字段8</target>
        </trans-unit>
        <trans-unit id="bb7b88f825a8de27b63373e28f7a77a5b201a208" translate="yes" xml:space="preserve">
          <source>Field Word8:</source>
          <target state="translated">场字8。</target>
        </trans-unit>
        <trans-unit id="038766ad89a5656bc1a23b0e43bb712d94a7a368" translate="yes" xml:space="preserve">
          <source>Field [String]</source>
          <target state="translated">字段[字符串]</target>
        </trans-unit>
        <trans-unit id="2a2dd2f21d7d7ea1bc52b694a50f6bf5a257e793" translate="yes" xml:space="preserve">
          <source>Field [String]:</source>
          <target state="translated">字段[字符串]。</target>
        </trans-unit>
        <trans-unit id="bb83d98e1af99f389ea1d7d36d6591ca3c321b0c" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">字段歧义消除可以与修剪结合使用（请参见&lt;a href=&quot;#record-puns&quot;&gt;Record puns&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="6f697941f4e61d5357bc8e695debb7df5928ebe4" translate="yes" xml:space="preserve">
          <source>Field disambiguation can be combined with punning (see &lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt;). For example:</source>
          <target state="translated">字段歧义消除可以与修剪结合使用（请参见&lt;a href=&quot;record_puns#record-puns&quot;&gt;Record puns&lt;/a&gt;）。例如：</target>
        </trans-unit>
        <trans-unit id="8ba709dee54d841422d5cda9c86dc36f0733a53e" translate="yes" xml:space="preserve">
          <source>Field names used as selector functions or in record updates must be unambiguous, either because there is only one such field in scope, or because a type signature is supplied, as described in the following sections.</source>
          <target state="translated">作为选择函数或在记录更新中使用的字段名必须是明确的,因为在范围内只有一个这样的字段,或者因为提供了类型签名,如以下章节所述。</target>
        </trans-unit>
        <trans-unit id="9a36bac12f2598c38413b503ceea750d14ea1043" translate="yes" xml:space="preserve">
          <source>Field selectors can be used in conjunction with &lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt;&lt;code&gt;TypeApplications&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;. The type of a field selector is constructed by using the surrounding definition as context. This section provides a specification for how this construction works. We will explain it by considering three different forms of field selector, each of which is a minor variation of the same general theme.</source>
          <target state="translated">字段选择器可以与&lt;a href=&quot;type_applications#extension-TypeApplications&quot;&gt; &lt;code&gt;TypeApplications&lt;/code&gt; &lt;/a&gt;结合使用，如&lt;a href=&quot;type_applications#visible-type-application&quot;&gt;可见类型应用程序中所述&lt;/a&gt;。字段选择器的类型是通过使用周围的定义作为上下文来构造的。本节提供有关此构造如何工作的规范。我们将通过考虑三种不同形式的字段选择器对其进行解释，每种形式都是同一通用主题的一个较小变体。</target>
        </trans-unit>
        <trans-unit id="ebd7785607bbf364d54013deccebdf1687696229" translate="yes" xml:space="preserve">
          <source>Field selectors for GADT constructors (&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;Declaring data types with explicit constructor signatures&lt;/a&gt;) are slightly more involved. Consider the following example:</source>
          <target state="translated">GADT构造函数的字段选择器（&lt;a href=&quot;gadt_syntax#gadt-style&quot;&gt;使用显式构造函数签名声明数据类型&lt;/a&gt;）要稍微复杂一些。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="553b7393804c0c51c21d68612ff28deebee6c2a3" translate="yes" xml:space="preserve">
          <source>FieldExp</source>
          <target state="translated">FieldExp</target>
        </trans-unit>
        <trans-unit id="96c72c07ebaaebcb224edc3159fd04027f378cf3" translate="yes" xml:space="preserve">
          <source>FieldExpQ</source>
          <target state="translated">FieldExpQ</target>
        </trans-unit>
        <trans-unit id="52cf3a69b95afcaef5b9552017ab1d7a46942649" translate="yes" xml:space="preserve">
          <source>FieldFormat</source>
          <target state="translated">FieldFormat</target>
        </trans-unit>
        <trans-unit id="ab3ea29114e079d7ead09ebd02437860e63f295e" translate="yes" xml:space="preserve">
          <source>FieldFormatter</source>
          <target state="translated">FieldFormatter</target>
        </trans-unit>
        <trans-unit id="9056803e7437f22b8f8eb0183fd8d5b6660b20fa" translate="yes" xml:space="preserve">
          <source>FieldPat</source>
          <target state="translated">FieldPat</target>
        </trans-unit>
        <trans-unit id="99b0c84f03868d4e48b3119185190cb080d238ad" translate="yes" xml:space="preserve">
          <source>FieldPatQ</source>
          <target state="translated">FieldPatQ</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="6047eeaf6d96600fc3b89f57d9a82133eebd5fc4" translate="yes" xml:space="preserve">
          <source>Fields may be used as selector functions only if they are unambiguous, so this is still not allowed if both &lt;code&gt;S(x)&lt;/code&gt; and &lt;code&gt;T(x)&lt;/code&gt; are in scope:</source>
          <target state="translated">仅当字段明确时才可以将其用作选择器函数，因此，如果 &lt;code&gt;S(x)&lt;/code&gt; 和 &lt;code&gt;T(x)&lt;/code&gt; 都在范围内，则仍然不允许这样做：</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="7ab560f3cbaa2fc5f6b6fc34d0cb745e71f21f9f" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; if it exists.</source>
          <target state="translated">文件 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/default&lt;/code&gt; 如果存在）。</target>
        </trans-unit>
        <trans-unit id="a167c672375de2f34928b4566c71bf22a7ede991" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨name⟩.</source>
          <target state="translated">如果环境变量&lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-8&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt;设置为&amp;ldquo; &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 则文件$ HOME / .ghc / arch-os-version / environments / name。</target>
        </trans-unit>
        <trans-unit id="3a01ef2357593bcb0e4fedb3c673c8bc39be504e" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; if you pass the option &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt;.</source>
          <target state="translated">如果传递选项 &lt;code&gt;-package-env ⟨name⟩&lt;/code&gt; 则文件 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d06905a4f43f7d68d079a1292926a4fcdc15ef19" translate="yes" xml:space="preserve">
          <source>File &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; if it exists in the current directory or any parent directory (but not the user&amp;rsquo;s home directory).</source>
          <target state="translated">文件 &lt;code&gt;.ghc.environment.arch-os-version&lt;/code&gt; 如果存在于当前目录或任何父目录（而不是用户的主目录）中。</target>
        </trans-unit>
        <trans-unit id="47f3e4a191350f85b1fb6c184e322e3d2487d97a" translate="yes" xml:space="preserve">
          <source>File allocation</source>
          <target state="translated">文件分配</target>
        </trans-unit>
        <trans-unit id="d5a78f8cfc23c487b733c48af2524d1ee745f3b1" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">文件名和目录名是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值，其确切含义取决于操作系统。可以打开文件，产生一个句柄，然后可以使用该句柄对文件的内容进行操作。</target>
        </trans-unit>
        <trans-unit id="838ab5322e72167e410c8392a44814f02f10e077" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">文件名和目录名是 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值，其确切含义取决于操作系统。可以打开文件，产生一个句柄，然后可以使用该句柄对文件的内容进行操作。</target>
        </trans-unit>
        <trans-unit id="bd52e06d55d1bf7bfbc10d5c00841d3fab42c29d" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">文件名和目录名是 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值，其确切含义取决于操作系统。可以打开文件，产生一个句柄，然后可以使用该句柄对文件的内容进行操作。</target>
        </trans-unit>
        <trans-unit id="effea5a9629c10713fe758f268aee8fd6abebbd6" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">文件名和目录名是 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值，其确切含义取决于操作系统。可以打开文件，产生一个句柄，然后可以使用该句柄对文件的内容进行操作。</target>
        </trans-unit>
        <trans-unit id="3d0b0e37f272404afcc389cc877def43f90e9575" translate="yes" xml:space="preserve">
          <source>File and directory names are values of type &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.</source>
          <target state="translated">文件名和目录名是 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 类型的值，其确切含义取决于操作系统。可以打开文件，产生一个句柄，然后可以使用该句柄对文件的内容进行操作。</target>
        </trans-unit>
        <trans-unit id="f47bb7024cb7d59562a12c46b66ef954ecbf1490" translate="yes" xml:space="preserve">
          <source>File descriptor to close.</source>
          <target state="translated">要关闭的文件描述符。</target>
        </trans-unit>
        <trans-unit id="b66bde9fc5bb83fdf4ea939e331fb8664459ca24" translate="yes" xml:space="preserve">
          <source>File extension character</source>
          <target state="translated">文件扩展符</target>
        </trans-unit>
        <trans-unit id="1c0021e329eb90f6a7b2780c57945209da61a258" translate="yes" xml:space="preserve">
          <source>File locking</source>
          <target state="translated">文件锁定</target>
        </trans-unit>
        <trans-unit id="0c722e113405e21abbf91991823e490fd909ebc5" translate="yes" xml:space="preserve">
          <source>File mode (such as permissions).</source>
          <target state="translated">文件模式(如权限)。</target>
        </trans-unit>
        <trans-unit id="44351e19bb95196b5909f0387569e8792f24a314" translate="yes" xml:space="preserve">
          <source>File modes</source>
          <target state="translated">文件模式</target>
        </trans-unit>
        <trans-unit id="79327cb41236e902d5cca2599b9eff800842dc2d" translate="yes" xml:space="preserve">
          <source>File name manipulations</source>
          <target state="translated">文件名操作</target>
        </trans-unit>
        <trans-unit id="e5ec2bfca476afbb5e2e6543807ac3bfb533a1ec" translate="yes" xml:space="preserve">
          <source>File name template. If the template is &quot;foo.ext&quot; then the created file will be &quot;fooXXX.ext&quot; where XXX is some random number. Note that this should not contain any path separator characters.</source>
          <target state="translated">文件名模板。如果模板是 &quot;foo.ext&quot;,那么创建的文件将是 &quot;fooXXX.ext&quot;,其中XXX是一些随机数。请注意,这不应该包含任何路径分隔符。</target>
        </trans-unit>
        <trans-unit id="8cdd2b3998531feb2e79d752bcd3196891becba3" translate="yes" xml:space="preserve">
          <source>File names with &amp;ldquo;meaningful&amp;rdquo; suffixes (e.g., &lt;code&gt;.lhs&lt;/code&gt; or &lt;code&gt;.o&lt;/code&gt;) cause the &amp;ldquo;right thing&amp;rdquo; to happen to those files.</source>
          <target state="translated">具有&amp;ldquo;有意义&amp;rdquo;后缀的文件名（例如 &lt;code&gt;.lhs&lt;/code&gt; 或 &lt;code&gt;.o&lt;/code&gt; ）导致这些文件发生&amp;ldquo;正确的事情&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="50384c5cc1d9206b4a0bea9f93b399ae83f9025e" translate="yes" xml:space="preserve">
          <source>File options</source>
          <target state="translated">文件选项</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">文件状态</target>
        </trans-unit>
        <trans-unit id="af9774e2bc6c59627690a0dedee37b68e10ba597" translate="yes" xml:space="preserve">
          <source>File synchronisation</source>
          <target state="translated">同步文件</target>
        </trans-unit>
        <trans-unit id="0d3da9368089813c88f07b933bfd9982df74058a" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if the environment variable &lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt;&lt;/a&gt; is set to ⟨file⟩.</source>
          <target state="translated">如果环境变量&lt;a href=&quot;#envvar-GHC_ENVIRONMENT&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;GHC_ENVIRONMENT&lt;/code&gt; &lt;/a&gt;设置为&amp;ldquo; 文件&amp;rdquo;，则文件&amp;ldquo;文件&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="b068141256755be393e8c5f4ab9d5a23cddf020c" translate="yes" xml:space="preserve">
          <source>File ⟨file⟩ if you pass the option &lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt;&lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果传递选项&lt;a href=&quot;#ghc-flag--package-env%20%E2%9F%A8file%E2%9F%A9%7C%E2%9F%A8name%E2%9F%A9&quot;&gt; &lt;code&gt;-package-env ⟨file⟩|⟨name⟩&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e845ec2f1dbe4ebb6bd5b44fdbd30e02fb4fa0b5" translate="yes" xml:space="preserve">
          <source>File-header pragmas are read once only, before pre-processing the file (e.g. with cpp).</source>
          <target state="translated">在对文件进行预处理之前,文件头实用程序只被读取一次(例如用cpp)。</target>
        </trans-unit>
        <trans-unit id="67f0fd4191e0b800a67e17dea08cd79d328c985d" translate="yes" xml:space="preserve">
          <source>FileAttributeOrFlag</source>
          <target state="translated">FileAttributeOrFlag</target>
        </trans-unit>
        <trans-unit id="419fb1d579fa24f7d06409a1560297bf55604fcb" translate="yes" xml:space="preserve">
          <source>FileID</source>
          <target state="translated">FileID</target>
        </trans-unit>
        <trans-unit id="5f8df2e8132fa7064ada28629c5b3817e3b4756e" translate="yes" xml:space="preserve">
          <source>FileLock</source>
          <target state="translated">FileLock</target>
        </trans-unit>
        <trans-unit id="80805853ea06d36fa4fd830be6185f04c78d62c7" translate="yes" xml:space="preserve">
          <source>FileLockingNotSupported</source>
          <target state="translated">FileLockingNotSupported</target>
        </trans-unit>
        <trans-unit id="a85de67499f0473cd81c3a219d6d486f9eeb80fa" translate="yes" xml:space="preserve">
          <source>FileMapAccess</source>
          <target state="translated">FileMapAccess</target>
        </trans-unit>
        <trans-unit id="0b25eeca51a2e908f97898c9ef3aefb4ac120d01" translate="yes" xml:space="preserve">
          <source>FileMode</source>
          <target state="translated">FileMode</target>
        </trans-unit>
        <trans-unit id="96e38f15ed4165180f2f72b882ad922453b8f857" translate="yes" xml:space="preserve">
          <source>FileNameLimit</source>
          <target state="translated">FileNameLimit</target>
        </trans-unit>
        <trans-unit id="cf5d49897833b10ad5a74c57196b79bf6729d833" translate="yes" xml:space="preserve">
          <source>FileNamesAreNotTruncated</source>
          <target state="translated">FileNamesAreNotTruncated</target>
        </trans-unit>
        <trans-unit id="d680e5e98dcdbf2c7c4f9799336719546329a1dd" translate="yes" xml:space="preserve">
          <source>FileNotificationFlag</source>
          <target state="translated">FileNotificationFlag</target>
        </trans-unit>
        <trans-unit id="2ee875689c41837c399f4d2c32f5259de761b9de" translate="yes" xml:space="preserve">
          <source>FileOffset</source>
          <target state="translated">FileOffset</target>
        </trans-unit>
        <trans-unit id="6c82ffd5741d0c27e25cc781899c3fe7b6f8fa63" translate="yes" xml:space="preserve">
          <source>FilePath</source>
          <target state="translated">FilePath</target>
        </trans-unit>
        <trans-unit id="c3604acc9cca295c426ebae9f7a5c570e9e3927d" translate="yes" xml:space="preserve">
          <source>FilePtrDirection</source>
          <target state="translated">FilePtrDirection</target>
        </trans-unit>
        <trans-unit id="3b19d1904d22317055740540571508037b9e04a5" translate="yes" xml:space="preserve">
          <source>FileSizeBits</source>
          <target state="translated">FileSizeBits</target>
        </trans-unit>
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">文件名完成</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">可执行文件的文件扩展名（包括点号，如果有的话）（在POSIX系统上通常为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，在Windows或OS / 2上通常为 &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">可执行文件的文件名（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">文件名/目录功能</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">文件和手柄</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">带有其他后缀(或没有后缀)的文件会直接传递给链接器。</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">用一个字节值填充内存区域中给定数量的字节。</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">用所需值填充内存区域</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">使用某些&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; &amp;rdquo;操作过滤另一个映射中缺少其键的条目。</target>
        </trans-unit>
        <trans-unit id="ee2b47e5e988f9baa37856993c9dc8cd3c328a52" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">使用某些&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; &amp;rdquo;操作过滤另一个映射中缺少其键的条目。</target>
        </trans-unit>
        <trans-unit id="296c67f523b9ac6e28bfc4ebfa4d796103625519" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">使用某些&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; &amp;rdquo;操作过滤另一个映射中缺少其键的条目。</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">筛选其他地图中没有键的条目。</target>
        </trans-unit>
        <trans-unit id="86fec396e3e13493b2a91cd89771fd664be0f9b3" translate="yes" xml:space="preserve">
          <source>FinalPtr</source>
          <target state="translated">FinalPtr</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">最后确定的数据指针</target>
        </trans-unit>
        <trans-unit id="4654b2a5f2578ac85eb620c7f87d7844f6e0bb05" translate="yes" xml:space="preserve">
          <source>Finalization</source>
          <target state="translated">Finalization</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">终结处理手段（a）安排对 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的后续调用不返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ；（b）运行终结器。</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">敲定弱指针。返回值是一个未装箱的元组，包含世界的新状态和一个&amp;ldquo;未装箱的Maybe&amp;rdquo;，由 &lt;code&gt;Int#&lt;/code&gt; 和一个（可能无效的）完成动作表示。一种 &lt;code&gt;Int#&lt;/code&gt; 的 &lt;code&gt;1&lt;/code&gt; 表示该终结是有效的。来自终结器的返回值 &lt;code&gt;b&lt;/code&gt; 应该被忽略。</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">终结&lt;em&gt;器&lt;/em&gt;可以可靠地用于显式创建并具有标识的类型，例如 &lt;code&gt;IORef&lt;/code&gt; 和 &lt;code&gt;MVar&lt;/code&gt; 。但是，要将终结器放置在这些类型之一上，应使用为该类型提供的特定操作，例如分别使用 &lt;code&gt;mkWeakIORef&lt;/code&gt; 和 &lt;code&gt;addMVarFinalizer&lt;/code&gt; （非均匀性是偶然的）。这些操作附终结对原始对象框（例如内部 &lt;code&gt;MutVar#&lt;/code&gt; 中的情况下 &lt;code&gt;IORef&lt;/code&gt; ），因为终结附接到所述框本身当外箱是由编译器优化掉失败。</target>
        </trans-unit>
        <trans-unit id="521c7faf6958e48a574367992f9c07725b55b76b" translate="yes" xml:space="preserve">
          <source>Finalizers are all C functions.</source>
          <target state="translated">决算器都是C函数。</target>
        </trans-unit>
        <trans-unit id="ce238574b6a6dbcd2a65c4596886dabb147b08b1" translate="yes" xml:space="preserve">
          <source>Finalizers are all Haskell functions.</source>
          <target state="translated">Finalizers都是Haskell函数。</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">最后，约束约束完成后，GHC调用 &lt;code&gt;tcPluginStop&lt;/code&gt; ，从而允许插件处理已分配的任何资源（例如，终止SMT求解器过程）。</target>
        </trans-unit>
        <trans-unit id="cc10bc2ea70467315012d5ca45b95d793b626303" translate="yes" xml:space="preserve">
          <source>Finally, after the &lt;code&gt;interruptible&lt;/code&gt; foreign call returns into Haskell, the Haskell code should allow exceptions to be raised (&lt;code&gt;Control.Exception&lt;/code&gt;&amp;lsquo;s &lt;code&gt;allowInterrupt&lt;/code&gt;, or &lt;code&gt;interruptible yield&lt;/code&gt; for non-&lt;code&gt;-threaded&lt;/code&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ghc/issues/8684&lt;/a&gt;), and implement the &lt;code&gt;EINTR&lt;/code&gt;-retrying in Haskell (e.g. using e.g. &lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;).</source>
          <target state="translated">最后，后 &lt;code&gt;interruptible&lt;/code&gt; 外交调用返回到哈斯克尔，Haskell的代码应允许引发的异常（ &lt;code&gt;Control.Exception&lt;/code&gt; 的 &lt;code&gt;allowInterrupt&lt;/code&gt; ，或 &lt;code&gt;interruptible yield&lt;/code&gt; 用于非 &lt;code&gt;-threaded&lt;/code&gt; ，看到&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/8684&quot;&gt;https://gitlab.haskell.org/ghc/ ghc / issues / 8684&lt;/a&gt;），并在Haskell中实现 &lt;code&gt;EINTR&lt;/code&gt; 重试（例如，使用例如&lt;a href=&quot;../../libraries/base-4.15.0.0/foreign-c-error#v:throwErrnoIfMinus1Retry&quot;&gt;Foreign.C.Error.throwErrnoIfMinus1Retry&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">最后，这是 &lt;code&gt;readFile'&lt;/code&gt; 示例的异常安全变体：</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">最后，可以使用 &lt;code&gt;-main-is&lt;/code&gt; 标志或&lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt;命令调用其他函数：</target>
        </trans-unit>
        <trans-unit id="17193f32610866d1f4357bb64bd6417d7a0e85e0" translate="yes" xml:space="preserve">
          <source>Finally, since those &lt;code&gt;DynFlags&lt;/code&gt; updates happen after the plugins are loaded, you cannot from a &lt;code&gt;DynFlags&lt;/code&gt; plugin register other plugins by just adding them to the &lt;code&gt;plugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;. In order to achieve this, you would have to load them yourself and store the result into the &lt;code&gt;cachedPlugins&lt;/code&gt; field of &lt;code&gt;DynFlags&lt;/code&gt;.</source>
          <target state="translated">最后，由于这些 &lt;code&gt;DynFlags&lt;/code&gt; 更新是在插件加载后发生的，因此您无法从 &lt;code&gt;DynFlags&lt;/code&gt; 插件通过将其他插件添加到 &lt;code&gt;DynFlags&lt;/code&gt; 的 &lt;code&gt;plugins&lt;/code&gt; 字段来注册其他插件。为了实现这一点，你就必须自己加载它们，并把结果存储到 &lt;code&gt;cachedPlugins&lt;/code&gt; 领域 &lt;code&gt;DynFlags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">最后，将 &lt;code&gt;Just&lt;/code&gt; 结果收集到地图中：</target>
        </trans-unit>
        <trans-unit id="3ed43b18c0eb498b61dd7767854552765f4cd553" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;m&lt;/code&gt; implementation of &lt;code&gt;generalBracket&lt;/code&gt; returns the pairs &lt;code&gt;(b, s)&lt;/code&gt; and &lt;code&gt;(c, s)&lt;/code&gt;. For monad transformers other than &lt;code&gt;StateT&lt;/code&gt;, this will be some other type representing the effects and values performed and returned by the &lt;code&gt;use&lt;/code&gt; and &lt;code&gt;release&lt;/code&gt; actions. The effect part of the &lt;code&gt;use&lt;/code&gt; result, in this case &lt;code&gt;_s2&lt;/code&gt;, usually needs to be discarded, since those effects have already been incorporated in the &lt;code&gt;release&lt;/code&gt; action.</source>
          <target state="translated">最后， &lt;code&gt;generalBracket&lt;/code&gt; 的 &lt;code&gt;m&lt;/code&gt; 实现返回对 &lt;code&gt;(b, s)&lt;/code&gt; 和 &lt;code&gt;(c, s)&lt;/code&gt; 。对于除 &lt;code&gt;StateT&lt;/code&gt; 以外的monad转换器，这将是其他一些类型，表示 &lt;code&gt;use&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 操作执行和返回的效果和值。 &lt;code&gt;use&lt;/code&gt; 结果的效果部分（在这种情况下为 &lt;code&gt;_s2&lt;/code&gt; ）通常需要丢弃，因为这些效果已经包含在 &lt;code&gt;release&lt;/code&gt; 动作中。</target>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">最后，选项 &lt;code&gt;-hcsuf&lt;/code&gt; &amp;ldquo;后缀&amp;rdquo;将更改编译器生成的中间C文件的 &lt;code&gt;.hc&lt;/code&gt; 文件后缀。</target>
        </trans-unit>
        <trans-unit id="5463d0aeddf364c8fd3a47a2799ef56cd3b82670" translate="yes" xml:space="preserve">
          <source>Finally, there's one more special case, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt;, which can short-circuit when the monad &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, and the operator invokes &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最后，还有另一种特殊情况 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt; ，当monad &lt;code&gt;m&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 且操作员调用 &lt;code&gt;&lt;a href=&quot;control-monad#v:mzero&quot;&gt;mzero&lt;/a&gt;&lt;/code&gt; 时，它可能会短路。</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">最后,我们可以继续当前的执行。</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">最后,我们需要一个匹配单个字符的原始解析器,从中可以构造任意复杂的解析器。</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">最后,我们运行解码器。</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">查找&lt;em&gt;与&lt;/em&gt;目标约束&lt;em&gt;匹配&lt;/em&gt;的所有实例\（I \）；也就是说，目标约束是\（I \）的替换实例。这些实例声明是&lt;em&gt;候选对象&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">找出所有未解决的约束条件。然后</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">找出树的深度;即从树根到最远的叶子的枝数。</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">查找系统对文件的限制</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">查找字符串中所有(可能重叠的)子串的索引。</target>
        </trans-unit>
        <trans-unit id="113e5a7f7ef4741af748a8e459880c7c315f837d" translate="yes" xml:space="preserve">
          <source>Find the indices of all non-overlapping occurences of a substring in a string.</source>
          <target state="translated">查找字符串中所有非重叠出现的子串的索引。</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">找出树中的最大值。</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">查找形式为 &lt;code&gt;(C a)&lt;/code&gt; 的约束，其中 &lt;code&gt;a&lt;/code&gt; 是类型变量，然后将这些约束划分为共享公共类型变量 &lt;code&gt;a&lt;/code&gt; 的组。</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">寻找长度</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">完成并清理面向行的用户交互会话。阻止对 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 的现有调用。</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">有限图形</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">有限英特图(懒惰接口)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">有限英特图(严格接口)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">有限集</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">有限地图(懒惰界面</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">有限地图(严格接口)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">有限集</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">有限序列</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">首先争论的是是否要砍掉尾部的0</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">结果的第一部分是 &lt;code&gt;log2 n&lt;/code&gt; ，第二部分是 &lt;code&gt;0#&lt;/code&gt; ,如果&lt;em&gt;n&lt;/em&gt;是2的幂。</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">目标中的第一个偏移量&lt;em&gt;不&lt;/em&gt;复制（即&lt;em&gt;不&lt;/em&gt;长度）</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">首先查看是否存在给定的未量化约束 &lt;code&gt;C t&lt;/code&gt; 。如果是这样，使用它来解决约束。</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">首先， &lt;code&gt;M&lt;/code&gt; 导入 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 。这是一个不安全的模块，但是 &lt;code&gt;M&lt;/code&gt; 是使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的，因此 &lt;code&gt;P&lt;/code&gt; 的作者负责该导入。 &lt;code&gt;C&lt;/code&gt; 信任 &lt;code&gt;P&lt;/code&gt; 的作者，因此可以导入。</target>
        </trans-unit>
        <trans-unit id="3ce8d182339545e607fa71963b2eed8264ebafc8" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;rsquo;s author, so this import is fine.</source>
          <target state="translated">首先， &lt;code&gt;M&lt;/code&gt; 导入 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 。这是一个不安全的模块，但是 &lt;code&gt;M&lt;/code&gt; 是由&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的，因此 &lt;code&gt;P&lt;/code&gt; 的作者对此导入负责。 &lt;code&gt;C&lt;/code&gt; 信任 &lt;code&gt;P&lt;/code&gt; 的作者，因此可以导入。</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">首先,将模块加载到GHCi中。</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">首先,从定义的宏中查找名称上的精确匹配。</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">首先,它们使终止解析成为可能,而这在以前是不可能的。例如,考虑以下一般玫瑰数据类型的实例声明</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">固定尺寸的构建器基元</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">固定尺寸基元</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">固定宽度的十六进制数</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">可以为类型构造函数声明固定性,也可以为类声明固定性,就像为数据构造函数声明固定性一样。但是,在固定性声明中不能区分两者,固定性声明为数据构造函数和对应的类型构造函数设置了固定性。例如</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">固定性声明与Haskell中完全一样。</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">固定性查询</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">构造者的固定性</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">固定性、类型同义词、开放的类型/数据族声明与普通Haskell一样是允许的。</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">标记为&amp;ldquo;之后停止&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; 的标志。</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">在各个子系统中控制调试输出和额外检查的标志。</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">扁平化严格的构造函数字段</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用指针大小的表示形式展平严格的构造函数字段。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="e4ccb090ca696917e5de23363132c4238087f15c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 。请参见&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5aa9a79151c09f2b1c44f8f5b45f86e26536f4e8" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 。请参见&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handle&quot;&gt;handle&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12167983d0afff206c046e1d6d922143291d5f3e" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchAll&quot;&gt;catchAll&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd78f746eff5d069a4c69da8e38598e4dcbf4a4c" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a015af1d71e496c444ce3c462d153241cce86f16" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchIf&quot;&gt;catchIf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dafc2e8e7144d1472eedd451318a1d1537aeb13" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 。请参见&lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f081d19b6a1634db731d6fc797a0dd377b306de" translate="yes" xml:space="preserve">
          <source>Flipped &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">翻转 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:catchJust&quot;&gt;catchJust&lt;/a&gt;&lt;/code&gt; 。请参见&lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:handleJust&quot;&gt;handleJust&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 的翻转版本。</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 的翻转版本。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">向内浮动让装订，使其装订位置更近。请参阅&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;浮动：移动绑定以提供更快的程序（ICFP'96）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e0526b9852afffdf9689fa74f06581b7f3b3784" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;rsquo;96)&lt;/a&gt;.</source>
          <target state="translated">向内浮动浮动装订，使其装订位置更近。请参阅&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;浮动：移动绑定以提供更快的程序（ICFP'96）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">浮动方法</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">浮点数/整数转换,封装的primops。</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">浮动类型</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">将提供的写缓冲区中的所有数据冲出设备。返回的缓冲区应该是空的,并且可以写。</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">刷新自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 的&lt;/a&gt;缓冲区（如果有）。这可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">从所提供的写入缓冲区中无阻挡地冲出数据到设备。返回写入的字节数和剩余的缓冲区。</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">刷新当前缓冲区。这将引入一个分块边界。</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">冲洗缓冲区状态</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">冲洗隐式解析状态</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">使用单体折叠一个列表。</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">将一棵树按深度优先的顺序折成一个 &quot;摘要 &quot;值。</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">明智地折叠 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">从右往左折。</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="37d91c80ee36726ccf43b2e7f00be807a7045256" translate="yes" xml:space="preserve">
          <source>Foldable structures are reduced to a summary value by accumulating contributions to the result one element at a time.</source>
          <target state="translated">可折叠结构通过一次一个元素累积对结果的贡献,还原成一个摘要值。</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">折叠动作</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">褶皱和横移</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">按增加键的顺序折叠。</target>
        </trans-unit>
        <trans-unit id="8bd6a5b4641abf50c3fa996016c263fddb09d728" translate="yes" xml:space="preserve">
          <source>Folds of unbounded structures do not terminate when the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator is strict:</source>
          <target state="translated">当monoid的 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 运算符严格时，无界结构的折叠不会终止：</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">在Mark Jones的建议下，GHC &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;在Haskell的Typing Haskell&lt;/a&gt;论文中提出了一个更通用的方案。在GHC中&lt;em&gt;，依赖性分析会忽略对具有显式类型签名的变量的引用&lt;/em&gt;。精致的依赖关系分析的结果是，依赖项组更小，并且更多的绑定将进行类型检查。例如，考虑：</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">遵循ISO-10646标准，GHC中的 &lt;code&gt;maxBound :: Char&lt;/code&gt; 为 &lt;code&gt;0x10FFFF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">遵循&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html中&lt;/a&gt;的建议</target>
        </trans-unit>
        <trans-unit id="24f8eb6fedbc854f6eb4756da6cd5c7a8c568aea" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">遵循&lt;a href=&quot;https://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html中&lt;/a&gt;的建议</target>
        </trans-unit>
        <trans-unit id="31d946127399c2228b066615f8fa0d54aa0a373b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt;, the &lt;em&gt;non-deterministic&lt;/em&gt; behaviour of &lt;code&gt;List&lt;/code&gt; is most easily seen in the case of a list of lists (of elements of some common fixed type). The result is a cross-product of all the sublists:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; ，在列表列表（某些常见固定类型的元素）的情况下，最容易看到 &lt;code&gt;List&lt;/code&gt; &lt;em&gt;的不确定&lt;/em&gt;性行为。结果是所有子列表的叉积：</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; ，计算它们的最大公约数 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; 和满足 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; &lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;的系数 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;CalendarDiffDays&lt;/code&gt; （和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;Day&lt;/code&gt; （与 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;DayOfWeek&lt;/code&gt; （和 &lt;code&gt;Day&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;LocalTime&lt;/code&gt; （和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;NominalDiffTime&lt;/code&gt; 和 &lt;code&gt;DiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;TimeOfDay&lt;/code&gt; （和 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;TimeZone&lt;/code&gt; （以及 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; 和 &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 为同义词 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于POSIX用户，这等效于 &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于POSIX用户，这等效于 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">对于双向模式同义词,模式同义词作为表达式的使用具有以下类型</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">对于一个类来说,每个类型变量都必须注解一个种类。</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">对于一个复数 &lt;code&gt;z&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; 与的大小的数 &lt;code&gt;z&lt;/code&gt; ，但在正实方向取向，而 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 具有的相位 &lt;code&gt;z&lt;/code&gt; ，但单位幅度。</target>
        </trans-unit>
        <trans-unit id="bde3bc31dcf2451837a45deb22082c15149b6c7b" translate="yes" xml:space="preserve">
          <source>For a comprehensive listing of supported platforms, please refer to &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;</source>
          <target state="translated">有关受支持平台的完整列表，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&quot;&gt;https://gitlab.haskell.org/ghc/ghc/-/wikis/platforms&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">对于顶级数据类型 &lt;code&gt;::&lt;/code&gt; ：后引入的所有类型的变量 &lt;code&gt;::&lt;/code&gt; 必须明确量化。</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">对于数据类型，每个类型变量都必须带有一种类型。在GADT式的声明，也可能是一种签名（与顶级 &lt;code&gt;::&lt;/code&gt; 在头），但这个注释的存在与否并不影响申报是否有完整的签名。</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">有关详细讨论，请参阅Levent Erkok的论文，&amp;ldquo; &lt;em&gt;单子计算中的值递归&amp;rdquo;&lt;/em&gt;，俄勒冈大学研究生院，2002年。</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 中&lt;/a&gt;使用的算法的完整规范，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;此Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa43273cfde854c1384910a8e3bf21706a4937f0" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 中&lt;/a&gt;使用的算法的完整规范，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor&quot;&gt;此Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">有关完整的示例，请参阅GHC源代码树中的 &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义应与</target>
        </trans-unit>
        <trans-unit id="f4c2f154344db246f733b27e08b4fac32576674c" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义上应与以下内容相同：</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义应与</target>
        </trans-unit>
        <trans-unit id="eb1a2ffe8319962a0d9758d8d5c92f844737e908" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to:</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义上应与以下内容相同：</target>
        </trans-unit>
        <trans-unit id="4ffd351d10bb1cc76d3c976825e9c103713a2402" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">对于给定的堆大小（使用&lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt;选项），压缩实际上可以通过允许执行较少的GC来减少GC的成本。当活动数据与堆大小的比率较高（例如大于30％）时，这种可能性更大。</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">对于给定的堆大小（使用 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 选项），压缩实际上可以通过允许执行较少的GC来减少GC的成本。当活动数据与堆大小的比率较高（例如大于30％）时，这种可能性更大。</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">对于附加到物理文件的句柄 &lt;code&gt;hdl&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回该文件的大小（以8位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">对于附加到物理文件的句柄 &lt;code&gt;hdl&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回该文件的大小（以8位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">对于x的lambda绑定变量或大小写绑定变量，程序员要么为x提供了显式的多态类型，要么GHC的类型推断将假定x的类型中没有forall。</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关单 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; 版本，请参见unfoldForestM_BF。</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关单 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; 版本，请参见unfoldTreeM_BF。</target>
        </trans-unit>
        <trans-unit id="41fb437ba339dfd70d91e29e645efbb597123e67" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables must introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">对于新类型，规则与数据类型的规则相同，除非启用了&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;，如果存在种类签名，则类型构造函数仅具有CUSK。与具有顶级 &lt;code&gt;::&lt;/code&gt; 的数据类型一样，必须在 &lt;code&gt;::&lt;/code&gt; 必须明确量化之后引入所有种类变量</target>
        </trans-unit>
        <trans-unit id="4d8cf6ad049da3ffe486c394fe0bd5021d502284" translate="yes" xml:space="preserve">
          <source>For a newtype, the rules are the same as they are for a data type unless &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled. With &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level &lt;code&gt;::&lt;/code&gt;, all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified</source>
          <target state="translated">对于新类型，规则与数据类型的规则相同，除非启用了&lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;，如果存在种类签名，则类型构造函数仅具有CUSK。与具有顶级 &lt;code&gt;::&lt;/code&gt; 的数据类型一样，必须明确量化 &lt;code&gt;::&lt;/code&gt; 之后引入的所有种类变量</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">对于普通的 &lt;code&gt;foreign export&lt;/code&gt; ，文件 &lt;code&gt;M_stub.h&lt;/code&gt; 包含用于外部导出函数的C原型。例如，如果我们编译以下模块：</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">对于一个多义类型族,种类会像类型一样被检查是否存在差异性。例如,以下是可以接受的。</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">有关只读状态，请参见&lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于可读句柄 &lt;code&gt;hdl&lt;/code&gt; ，如果当前I / O位置等于文件的长度，则如果无法从 &lt;code&gt;hdl&lt;/code&gt; 或物理文件中获取更多输入，则 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于可读句柄 &lt;code&gt;hdl&lt;/code&gt; ，如果当前I / O位置等于文件的长度，则如果无法从 &lt;code&gt;hdl&lt;/code&gt; 或物理文件中获取更多输入，则 &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">有关具有相同接口的严格版本，请参见&lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">对于一个类型同义词,每个类型变量和结果类型都必须用种类来注释。</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">对于单向的记录模式同义词,我们定义了记录选择器,但不允许记录更新或构造。</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">有关允许一定范围的异常值的变体，请参见&lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参阅&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;地图介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参见&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;集合介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参见其&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;集合介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">对于所有类型（请注意，这三个是由 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; 完成的）：</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">对于几乎所有明智的程序来说,这将表明一个错误,你可能打算写。</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">对于&amp;ldquo;无法打包&amp;rdquo;的 &lt;code&gt;U(...)&lt;/code&gt; 参数，内部的信息说明其组件的严格性。因此，如果参数是一对，并且说 &lt;code&gt;U(AU(LSS))&lt;/code&gt; ，则意味着&amp;ldquo;未使用该对的第一个组件；第二个组件本身是不可拆包的，包含三个组件（第一个组件是惰性的，第二个和第二个是严格的）。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="d1cb9e82bcd8a245aaf6652f2e48d70c05a6dea5" translate="yes" xml:space="preserve">
          <source>For an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; functor &lt;strong&gt;&lt;code&gt;f&lt;/code&gt;&lt;/strong&gt; and a Traversable functor &lt;strong&gt;&lt;code&gt;t&lt;/code&gt;&lt;/strong&gt;, the type signatures of &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; are rather similar:</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 函子&lt;strong&gt; &lt;code&gt;f&lt;/code&gt; &lt;/strong&gt;和Traversable函子&lt;strong&gt; &lt;code&gt;t&lt;/code&gt; &lt;/strong&gt;， &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 的类型签名非常相似：</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">为了&lt;em&gt;有效地实现编码&lt;/em&gt;，重要的是（a）花很少的时间将Haskell值转换为结果字节序列，&lt;em&gt;以及&lt;/em&gt;（b）结果序列的表示形式可以有效地消耗它。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 通过提供O（1）合并操作以及对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 和其他标准Haskell值的基本编码的有效实现来支持（a）。它们通过将结果提供为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 来支持（b），它在内部只是指向连续原始内存&lt;em&gt;块&lt;/em&gt;的指针的链接列表。懒 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 可以通过将它们写入文件或通过网络套接字发送它们的函数来有效地使用。请注意，每个块边界都会产生昂贵的额外工作（例如系统调用），必须在消耗块主体上花费的工作中分摊。因此， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 需格外小心，以确保平均块大小足够大。足够大的确切含义取决于应用程序。当前实现已调整为在4kb和32kb之间的平均块大小，这应该适合大多数应用程序。</target>
        </trans-unit>
        <trans-unit id="c98483df7da3278fbc5172993ad0a88f8fc1d389" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">为了&lt;em&gt;有效地实现编码&lt;/em&gt;，重要的是（a）花费很少的时间将Haskell值转换为结果字节序列，&lt;em&gt;以及&lt;/em&gt;（b）结果序列的表示形式可以有效地使用。通过提供O（1）合并操作以及 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 和其他标准Haskell值的基本编码的有效实现， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的支持（a）。它们通过将结果提供为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 来支持（b），它在内部只是指向连续原始内存&lt;em&gt;块&lt;/em&gt;的指针的链接列表。懒惰的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;可以通过将它们写入文件或通过网络套接字发送它们的函数来有效地消耗s。请注意，每个块边界都会产生昂贵的额外工作（例如，系统调用），必须在消耗块主体上花费的工作中分摊。因此， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 需格外小心，以确保平均块大小足够大。足够大的确切含义取决于应用程序。当前实现已调整为在4kb和32kb之间的平均块大小，这应该适合大多数应用程序。</target>
        </trans-unit>
        <trans-unit id="3496a2b758ef763c20485808c9274b5b6efa235b" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">为了&lt;em&gt;有效地实现编码&lt;/em&gt;，重要的是（a）花费很少的时间将Haskell值转换为结果字节序列，&lt;em&gt;以及&lt;/em&gt;（b）结果序列的表示形式可以有效地使用。通过提供O（1）合并操作以及 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 和其他标准Haskell值的基本编码的有效实现， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的支持（a）。它们通过将结果提供为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 来支持（b），它在内部只是指向连续原始内存&lt;em&gt;块&lt;/em&gt;的指针的链接列表。懒惰的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; &lt;em&gt;&lt;/em&gt;可以通过将它们写入文件或通过网络套接字发送它们的函数来有效地消耗s。请注意，每个块边界都会产生昂贵的额外工作（例如，系统调用），必须在消耗块主体上花费的工作中分摊。因此， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 需格外小心，以确保平均块大小足够大。足够大的确切含义取决于应用程序。当前实现已调整为在4kb和32kb之间的平均块大小，这应该适合大多数应用程序。</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">对于枚举，假定无效构造函数从左到右编号，索引为0到n-1（含0和n-1）。这与 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类定义的编号相同。例如，给定数据类型：</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">有关演示为什么这样做不安全的示例，请参见&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">例如，我们有一个名为 &lt;code&gt;Recip.hs&lt;/code&gt; 的程序，该程序计算倒数的精确十进制表示形式，并在方括号中指出重复部分。</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">对于一个交互式的应用程序来说,使用空闲GC可能是一个好主意,因为这将允许在没有Haskell计算发生的空闲时间内运行终结器和检测死锁线程。另外,这将意味着当应用程序繁忙时GC不太可能发生,因此响应性可能会得到改善。但是,如果堆中的实时数据量特别大,那么空闲GC可能会造成明显的延迟,而过小的间隔可能会对交互响应性产生不利影响。</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">对于任何导入的模块，GHC要求import语句中的模块名称与使用&lt;a href=&quot;#search-path&quot;&gt;&amp;ldquo;搜索路径&amp;rdquo;中&lt;/a&gt;指定的策略找到的接口文件（或源文件）中的模块名称完全匹配。这意味着对于大多数模块，源文件名应与模块名匹配。</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">对于作为 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类的实例的任何类型，应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">对于作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类的实例的任何类型，应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">对于具有大量字符串文字的应用程序， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 可能是瓶颈。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; （仅适用于 GHC）。</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">对于有大量字符串字元的应用,pack可能是一个瓶颈。</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">为了与现有make脚本向后兼容，当与&lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;结合使用时，将省略链接阶段（与 &lt;code&gt;--make -no-link&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，一种变量&lt;em&gt;并不&lt;/em&gt;需要明确的约束，即使启动类型与 &lt;code&gt;forall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">为了向后兼容</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">对于二进制构造函数</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">对于&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;，阶段号表示何时完全允许内联。</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">对于模式通配符和表达式通配符，&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;将扩展到缺少&lt;em&gt;的范围内&lt;/em&gt;记录字段。具体来说，&amp;ldquo; &lt;code&gt;C {..}&lt;/code&gt; &amp;rdquo; 的扩展包括 &lt;code&gt;f&lt;/code&gt; ,当且仅当：</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">对于装箱的值（即，由指针表示的值），在提升类型（包含&amp;perp;）和未提升类型（不包含）之间进行了进一步的区分。</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">对于可能包含可变长度填充的功能，请改用 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="347db935aa14d91363ea82db49f93c38e6d9eb78" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9a7a9bf985a5fc7968bcd7963a4107803bb41d4" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">要在任何两个整数类型之间进行强制转换，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; ，它专门用于所有常见情况，因此应足够快。在整数类型之间来回强制单词类型（请参阅&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;）会保留表示形式，而不是符号。</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">要在任何两个整数类型之间进行强制转换，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; ，它专门用于所有常见情况，因此应足够快。在整数类型之间来回强制单词类型会保留表示形式，而不是符号。</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">对于配置文件。它使用 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;/etc/xdg&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 或 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; （例如 &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">对于配置文件。它使用 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.config&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%APPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。可以视为 &lt;code&gt;/etc&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">用于数据文件（例如图像）。它使用 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;/usr/local/share/&lt;/code&gt; 和 &lt;code&gt;/usr/share/&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 或 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; （例如 &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">用于数据文件（例如图像）。它使用 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.local/share&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%APPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。可以视为 &lt;code&gt;/usr/share&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">为了解码和生成简单的外部二进制格式（例如C结构），可以使用Binary，但是通常不适合复杂协议。而是直接使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 原语。</target>
        </trans-unit>
        <trans-unit id="af244705c99bde3579744323c9a3a740b23bae24" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;GHC&lt;/em&gt;Runtime/Interpreter.hs.</source>
          <target state="translated">有关远程GHCi的详细信息，请参见编译器&lt;em&gt;GHC&lt;/em&gt; Runtime / Interpreter.hs中的注释[Remote GHCi] 。</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">有关远程GHCi的详细信息，请参见编译器&lt;em&gt;ghci&lt;/em&gt; GHCi.hs中的注释[Remote GHCi]。</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">对于总和类型的每个替代，都会生成一个包含这些字段的布局。例如，如果替代项具有 &lt;code&gt;Int&lt;/code&gt; ， &lt;code&gt;Float#&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 字段，则布局将具有32位字，32位float和指针字段。</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">每次收集垃圾,我们都会打印。</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">对于每个导入声明 &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; ，一行记录 &lt;code&gt;M&lt;/code&gt; 对 &lt;code&gt;X&lt;/code&gt; 的依赖关系：</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">对于每个导入声明，在 &lt;code&gt;M&lt;/code&gt; 中 &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; ，该行记录 &lt;code&gt;M&lt;/code&gt; 对 &lt;code&gt;X&lt;/code&gt; 的依赖性：</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">对于树中的每个节点，将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;rootLabel&lt;/code&gt; ，并将 &lt;code&gt;f&lt;/code&gt; 应用于每个 &lt;code&gt;subForest&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">对于空数据类型，将 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 用作表示形式。例如，</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">有关此主题的更多详细信息，请参见&lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&amp;ldquo;正确处理SIGINT / SIGQUIT&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">对于以这种方式导入的每个 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 模块 &lt;code&gt;A.hs&lt;/code&gt; ，都必须存在一个源文件 &lt;code&gt;A.hs-boot&lt;/code&gt; 。该文件包含 &lt;code&gt;A.hs&lt;/code&gt; 的缩写版本，因此：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">例如， &lt;code&gt;-l-ag&lt;/code&gt; 将禁用除GC事件（ &lt;code&gt;g&lt;/code&gt; ）之外的所有事件类（ &lt;code&gt;-a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e539a440aea70f6c1e340e284061ee3f7564fb32" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">例如，将 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="0faa4a03eb1b621e96ddafa75b4d631885ce8235" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">例如，将 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="54977218cb67963281b7e0eb298f559214d3d420" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">例如，将 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="a8c5988831e8e7e699f73f0c98007bcd1ce68a11" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; is applied to two lists to produce the list of corresponding sums:</source>
          <target state="translated">例如，将 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt; (+)&lt;/code&gt; 应用于两个列表以产生相应总和的列表：</target>
        </trans-unit>
        <trans-unit id="a52ed97184e92138a6e73030c8150e134f0bb680" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;Fixed 1000&lt;/code&gt; will give you a &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; with a resolution of 1000.</source>
          <target state="translated">例如，&amp;ldquo; &lt;code&gt;Fixed 1000&lt;/code&gt; 将为您提供分辨率为1000的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 的&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7adc62b058c0496c81ae2687046d64f2c845f5f6" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;IO&lt;/code&gt; or &lt;code&gt;Either&lt;/code&gt; would be invalid base monads, but &lt;code&gt;Reader&lt;/code&gt; or &lt;code&gt;State&lt;/code&gt; would be acceptable.</source>
          <target state="translated">例如， &lt;code&gt;IO&lt;/code&gt; 或 &lt;code&gt;Either&lt;/code&gt; 将是无效的基本单子，但 &lt;code&gt;Reader&lt;/code&gt; 或 &lt;code&gt;State&lt;/code&gt; 将是可接受的。</target>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">例如， &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; 复制大小小于或等于1kb的严格 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，否则直接将其插入。这意味着所生成的惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的平均块大小可能低至513字节，因为在直接插入的1025字节严格 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 之间始终总是只有一个字节。</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; 将被解析为 &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; ，而不是 &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，UTF-8是将Unicode字符编码为字节序列。UTF-8 的 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，UTF-8是将Unicode字符编码为字节序列。UTF-8 的 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="025997d25e9ad541ddb4bccc051a89bbfefa2c23" translate="yes" xml:space="preserve">
          <source>For example, a program might have several distinct phases with different performance or resource behaviour in each phase. To properly interpret the profile graph we really want to see when each phase starts and ends.</source>
          <target state="translated">例如,一个程序可能有几个不同的阶段,每个阶段的性能或资源行为不同。为了正确地解释剖面图,我们真的想知道每个阶段的开始和结束时间。</target>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">例如,一个打印前20个整数和它们的2次方的程序可以写成。</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">例如,用户定义的树的数据类型为</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">例如,用GHC编译以下模块。</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">例如,考虑</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">例如，考虑一个程序 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">例如,考虑一个不打算与函数一起使用的类型类,但用户不小心在函数类型处使用了它,也许是因为他们错过了某个函数的参数。那么,与其得到标准的GHC关于遗漏实例的消息,不如发出一个针对EDSL的更友好的消息。同样,类型级函数的还原可能会因为一个错误而卡住,这时如果能报告一个EDSL特定的错误,而不是一个关于模糊类型的通用错误,那就更好了。</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">例如，考虑是否有一个名为 &lt;code&gt;:time&lt;/code&gt; 的宏，并且在外壳中键入了 &lt;code&gt;:t 3&lt;/code&gt; －应该怎么办？我们用于完成命令的当前算法是：</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">例如，考虑下面的并行版本的老 &lt;code&gt;nfib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">例如，考虑以下定义（使用&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="1e3fcef7520fd5f38bbab6908aface3e182c9e1f" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">例如，考虑以下定义（使用&lt;a href=&quot;scoped_type_variables#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">例如,给定一个数据类型</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">例如，给定某种索引类型的值的列表， &lt;code&gt;hist&lt;/code&gt; 生成直方图，表示指定范围内每个索引的出现次数：</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">例如,给定某个索引类型的值的列表,hist产生一个指定范围内每个索引出现次数的直方图。</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">例如,给定声明</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">例如，这是GHC的 &lt;code&gt;nofib&lt;/code&gt; 基准套件为 &lt;code&gt;sphere&lt;/code&gt; 程序生成的堆配置文件，</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">例如，这是我们可能实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;回显服务器的方式&lt;/a&gt;，它 &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 使用监听网络套接字上的客户端连接并在客户端连接句柄上回显客户端输入：</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">例如，如果GHC编译文件 &lt;code&gt;src/A/B/C.hs&lt;/code&gt; 中的模块 &lt;code&gt;A.B.C&lt;/code&gt; ，而没有 &lt;code&gt;-odir&lt;/code&gt; 或 &lt;code&gt;-hidir&lt;/code&gt; 标志，则该接口文件将放在 &lt;code&gt;src/A/B/C.hi&lt;/code&gt; 和对象中文件中 &lt;code&gt;src/A/B/C.o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">例如，如果接口位于导入值的类型附近，那么GHC可以很好地为导入模块生成Duff代码。&lt;em&gt;这也适用于接口内部的编译指示！&lt;/em&gt;如果编译指示在撒谎（例如，关于某个值的&amp;ldquo; arity&amp;rdquo;），则可能会产生达芙代码。此外，即使类型没有变化，arities也会改变。</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">例如,如果以下数据类型在作用域中</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">例如，如果我们在软件包规范 &lt;code&gt;HSfoo&lt;/code&gt; Haskell库指定为HSfoo，则将调用GHC实际使用的各种库：</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">例如，如果您正在检查程序的核心，并且发现 &lt;code&gt;foo&lt;/code&gt; 没有被内联。您可以通过 &lt;code&gt;-dinline-check foo&lt;/code&gt; ，您将看到有关为什么不内联 &lt;code&gt;foo&lt;/code&gt; 的报告。</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">例如,在具有这种行为的80列终端中,以下内容将打印单倍行距而不是双倍行距。</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">例如，在下面的程序中， &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;f'&lt;/code&gt; 是等效的：</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">例如,项目可以写成:</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">例如，使用相同 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 的对 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 的多次调用将共享相同的输入历史记录。相反，多次调用 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; 将使用不同的历史记录，除非它们共享相同的历史记录文件。</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">例如,一种可能的应用是将字典重新标准化。</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">例如，记住 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">例如，有时您可能想使用以下命令来获得&amp;ldquo;类同义词&amp;rdquo;的效果：</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">例如，假设搜索路径包含目录 &lt;code&gt;d1&lt;/code&gt; ， &lt;code&gt;d2&lt;/code&gt; 和 &lt;code&gt;d3&lt;/code&gt; ，并且我们处于&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式下，查找模块 &lt;code&gt;A.B.C&lt;/code&gt; 的源文件。GHC将查看 &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; ， &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; ， &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">例如，假设您有一个要在子字符串 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 上分割的字符串，例如 &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; 。与其搜索索引 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 并在该索引之前和之后获取子字符串， &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; 使用breakOnAll&amp;ldquo; ::&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">例如，假设您要读取文件，但是如果该文件不存在，则继续以包含&amp;ldquo;&amp;rdquo;的方式继续。您可能会想捕获所有异常并在处理程序中返回&amp;ldquo;&amp;rdquo;。但是，这会带来各种不良后果。例如，如果用户在适当的时候按下Ctrl-C，则将捕获 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 异常，并且程序将在文件包含&amp;ldquo;&amp;rdquo;的信念下继续运行。同样，如果另一个线程试图杀死读取文件的线程，则 &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 异常将被忽略。</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">例如,以下数据类型中的构造函数字段。</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">例如，数据类型 &lt;code&gt;2 * A&lt;/code&gt; 和 &lt;code&gt;A + A&lt;/code&gt; 是同构的，但是某些计算更自然地用一种或另一种来表示。为了充分利用这两个方面，我们可以选择一个作为实现，然后提供一组模式同义词，以便用户根据需要使用其他表示形式。然后，我们可以指定一个 &lt;code&gt;COMPLETE&lt;/code&gt; &lt;code&gt;LeftChoice&lt;/code&gt; 注，以通知模式匹配检查器一个在LeftChoice和 &lt;code&gt;RightChoice&lt;/code&gt; 上都匹配的函数是合计的。</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">例如,以下代码为GHC所接受。</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">例如，以下选项将生成仅限于 &lt;code&gt;Branch&lt;/code&gt; 和 &lt;code&gt;Leaf&lt;/code&gt; 构造函数的保留配置文件：</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">比如说,这些都是可以的。</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">例如，此代码将需要 &lt;code&gt;Monad&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">例如，这种情况会使 &lt;code&gt;name&lt;/code&gt; 的领域 &lt;code&gt;Person&lt;/code&gt; 访问使用 &lt;code&gt;#fullname&lt;/code&gt; 还有：</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">例如，这返回 &lt;code&gt;f x&lt;/code&gt; 的值，但首先输出消息。</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">例如,这。</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">例如,要启用FFI和CPP的预处理。</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">例如，要执行一个简单的 &lt;code&gt;ls&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">例如，要链接由对象的程序 &lt;code&gt;Foo.o&lt;/code&gt; 和 &lt;code&gt;Main.o&lt;/code&gt; ，在那里我们利用了的 &lt;code&gt;network&lt;/code&gt; 包，我们需要给GHC的 &lt;code&gt;-package&lt;/code&gt; 从而标志：</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">例如，要加载和运行包含 &lt;code&gt;Main&lt;/code&gt; 模块的Haskell程序，我们可能会说：</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">例如，要解析YYYY-MM-DD格式的日期，同时允许月份和日期具有可选的前导零（请注意，用于 &lt;code&gt;%m&lt;/code&gt; 和 &lt;code&gt;%d&lt;/code&gt; 的 &lt;code&gt;-&lt;/code&gt; 修饰符）：</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">例如,启动一个进程并向其stdin中输入一个字符串。</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">例如,将一个字符串标记化,放弃定界符。</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">例如,我们可以用直接递归的方法将阶乘函数写成</target>
        </trans-unit>
        <trans-unit id="c57a91fc90c21d96ad621001af54d878ab863159" translate="yes" xml:space="preserve">
          <source>For example, when &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;(:)&lt;/code&gt;, all three cases return an immediate value, respectively &lt;code&gt;z&lt;/code&gt; or a &lt;em&gt;cons cell&lt;/em&gt; holding &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt;, with the remainder the structure, if any, encapsulated in a lazy thunk. This meets the expected efficient &lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt; behaviour of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，当 &lt;code&gt;f&lt;/code&gt; 为 &lt;code&gt;(:)&lt;/code&gt; 时，所有三种情况均返回立即数，分别为 &lt;code&gt;z&lt;/code&gt; 或保存 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;l&lt;/code&gt; 的&lt;em&gt;cons单元&lt;/em&gt;，其余结构（如果有的话）封装在一个惰性thunk中。这符合 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 预期的有效&lt;a href=&quot;#corec&quot;&gt;corecursive&lt;/a&gt;行为。</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">例如,在编译模块A时,如果B没有导入A(直接或间接),则只能运行从B导入的Template Haskell函数。原因应该很清楚:要运行B,我们必须编译并运行A,但我们目前正在对A进行类型检查。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">例如： &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 难看，但不应该成为问题。</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">对于四部分GHC版本号 &lt;code&gt;x.y.z.z'&lt;/code&gt; ，价值 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 是整数⟨z⟩而价值 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; 设置为整数⟨z'⟩。</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">有关内射型族的完整详细信息，请参阅Haskell研讨会2015年论文Haskell &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;内射型族&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">但是，对于隐藏的软件包，您需要使用 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 标志来请求装入软件包：</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由于历史原因，保留值&lt;em&gt;不是&lt;/em&gt;强制的。要强制使用，请使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f8792d57e48a774641d9734879dcb766f223ec" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果值存在于距结构左侧有限距离处，则 &lt;code&gt;&lt;a href=&quot;data-foldable#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 终止：</target>
        </trans-unit>
        <trans-unit id="462ce6044e470f38fd8877b9aec9d317b89c01cb" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果值存在于距结构左侧有限距离处，则 &lt;code&gt;&lt;a href=&quot;data-list#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 终止：</target>
        </trans-unit>
        <trans-unit id="1265e702058729814c9070a553091ab6668e71f9" translate="yes" xml:space="preserve">
          <source>For infinite structures, &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; terminates if the value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果值存在于距结构左侧有限距离处，则 &lt;code&gt;&lt;a href=&quot;prelude#v:notElem&quot;&gt;notElem&lt;/a&gt;&lt;/code&gt; 终止：</target>
        </trans-unit>
        <trans-unit id="e2b4e1b52d9313f4a64b67c682815f36e8dd1565" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果所寻求的值距该结构的左侧有限距离，则 &lt;code&gt;&lt;a href=&quot;data-foldable#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的默认实现终止：</target>
        </trans-unit>
        <trans-unit id="4930b164ff12550352bb2ae49b0f3eafab2481e2" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果所寻求的值距该结构的左侧有限距离，则 &lt;code&gt;&lt;a href=&quot;data-list#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的默认实现终止：</target>
        </trans-unit>
        <trans-unit id="8ce546ec8413f6538f8a26e19ca0ec25047ae9e5" translate="yes" xml:space="preserve">
          <source>For infinite structures, the default implementation of &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; terminates if the sought-after value exists at a finite distance from the left side of the structure:</source>
          <target state="translated">对于无限结构，如果所寻求的值距该结构的左侧有限距离，则 &lt;code&gt;&lt;a href=&quot;prelude#v:elem&quot;&gt;elem&lt;/a&gt;&lt;/code&gt; 的默认实现终止：</target>
        </trans-unit>
        <trans-unit id="c30b64ae65331781837d75efd9f6decbae446e0c" translate="yes" xml:space="preserve">
          <source>For information on what bound threads are, see the documentation for the &lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;.</source>
          <target state="translated">有关绑定线程是什么的信息，请参见&lt;a href=&quot;../../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">例如,一个简单的配置文件可能是这样的。</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">例如,如果你有以下类型的家庭。</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">例如，使用 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; 运行程序将产生一个名为 &lt;code&gt;hello-world.hp&lt;/code&gt; 的堆概要文件和一个名为 &lt;code&gt;hello-world.prof&lt;/code&gt; 的成本中心概要文件。</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">例如，以 &lt;code&gt;-fno-specialise -O1&lt;/code&gt; 为例。尽管 &lt;code&gt;-fno-specialise&lt;/code&gt; 出现在命令行中，但仍将启用专门化。出现这种情况是 &lt;code&gt;-O1&lt;/code&gt; &lt;code&gt;-fspecialise&lt;/code&gt; 意味着-fspecialise，它将覆盖前一个标志。相比之下， &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; 会像人们期望的那样在不进行专门化的情况下进行编译。</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">例如，类型为 &lt;code&gt;not'&lt;/code&gt; 的第一个通配符将产生以下错误消息：</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">例如，我们可以使用此接口为在诸如此类的非饱和函数上的 &lt;code&gt;show&lt;/code&gt; 应用程序提供更有用的错误消息，</target>
        </trans-unit>
        <trans-unit id="be75888101f27133692a26f5d016cfc15af97616" translate="yes" xml:space="preserve">
          <source>For lists we get the natural order of effects by using &lt;strong&gt;&lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt;&lt;/strong&gt; as the operator and &lt;strong&gt;&lt;code&gt;(traverse f as)&lt;/code&gt;&lt;/strong&gt; as the operand (the actual definition is written as an equivalent right fold in order to enable &lt;em&gt;fusion&lt;/em&gt; rules):</source>
          <target state="translated">对于列表，我们通过使用&lt;strong&gt; &lt;code&gt;(prepend &amp;lt;$&amp;gt; f a)&lt;/code&gt; &lt;/strong&gt;作为运算符并使用&lt;strong&gt; &lt;code&gt;(traverse f as)&lt;/code&gt; &lt;/strong&gt;作为操作数来获得效果的自然顺序（实际定义写为等效的右折以启用&lt;em&gt;融合&lt;/em&gt;规则）：</target>
        </trans-unit>
        <trans-unit id="e819cf0fe0a721d8aa2edb789360b689a7c6df8a" translate="yes" xml:space="preserve">
          <source>For lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; is the identity:</source>
          <target state="translated">对于列表， &lt;code&gt;&lt;a href=&quot;data-foldable#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 是标识：</target>
        </trans-unit>
        <trans-unit id="cd75721614a832379340eb5515b1192ef0f86e97" translate="yes" xml:space="preserve">
          <source>For many structures reasonably efficient &lt;code&gt;Foldable&lt;/code&gt; instances can be derived automatically, by enabling the &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC extension. When this works, it is generally not necessary to define a custom instance by hand. Though in some cases one may be able to get slightly faster hand-tuned code, care is required to avoid producing slower code, or code that is not sufficiently lazy, strict or &lt;em&gt;lawful&lt;/em&gt;.</source>
          <target state="translated">对于许多结构，通过启用 &lt;code&gt;DeriveFoldable&lt;/code&gt; GHC扩展，可以自动派生合理有效的 &lt;code&gt;Foldable&lt;/code&gt; 实例。当此方法起作用时，通常不必手动定义自定义实例。尽管在某些情况下，也许可以得到稍微快一些的手动调整的代码，但还是需要小心以免产生较慢的代码，或者是不够懒惰，严格或&lt;em&gt;合法的代码&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2512d10fb7fc1b9dbc0084916fcb3b49c0227bdb" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">多年以来，报价的类型一直固定为&amp;ldquo; Q Exp&amp;rdquo;，但是通过更精确地指定最小接口，它使 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; 可以从报价中纯粹提取出来，而不会与 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 交互。</target>
        </trans-unit>
        <trans-unit id="15ee88f85580b5f1cfacfb67956f3e66087a0c8d" translate="yes" xml:space="preserve">
          <source>For many years the type of a quotation was fixed to be `Q Exp` but by more precisely specifying the minimal interface it enables the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; to be extracted purely from the quotation without interacting with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">多年以来，报价的类型一直固定为&amp;ldquo; Q Exp&amp;rdquo;，但是通过更精确地指定最小接口，它使 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Exp&quot;&gt;Exp&lt;/a&gt;&lt;/code&gt; 可以从报价中纯粹提取出来，而不会与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 交互。</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">对于确实属于 &lt;code&gt;MonadFix&lt;/code&gt; 类的monad，GHC提供了do-notation的扩展版本，它允许递归绑定。所述&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;（语言编译指示： &lt;code&gt;RecursiveDo&lt;/code&gt; ）提供了必要的语法支持，将所述关键字 &lt;code&gt;mdo&lt;/code&gt; 和 &lt;code&gt;rec&lt;/code&gt; 分别用于较高和较低水平的符号的。与 &lt;code&gt;do&lt;/code&gt; 表达式中的绑定不同，由 &lt;code&gt;mdo&lt;/code&gt; 和 &lt;code&gt;rec&lt;/code&gt; 引入的绑定是递归定义的，就像在普通的let表达式中一样。由于使用了新关键字 &lt;code&gt;mdo&lt;/code&gt; ，因此我们也将该符号称为&lt;em&gt;mdo-notation&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">有关此功能的更多详细信息，请参阅Joachim Breitner，Richard A. Eisenberg，Simon Peyton Jones和Stephanie Weirich撰写的《&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;安全强制》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8f223131e45f78084be7dce3cc5c1c0ae03a548a" translate="yes" xml:space="preserve">
          <source>For more details on the implementation see the Paper: &amp;ldquo;Extending the Haskell Foreign Function Interface with Concurrency&amp;rdquo;. Last known to be accessible &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">有关实现的更多详细信息，请参见论文：&amp;ldquo;使用并发扩展Haskell外部函数接口&amp;rdquo;。上次已知可&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf&quot;&gt;在此处&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="94a68e78d61b7ecc371a39ec450b9f0dee51b088" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki页面&lt;/a&gt;或原始论文&lt;a href=&quot;#generics2010&quot; id=&quot;id100&quot;&gt;[Generics2010]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki页面&lt;/a&gt;或原始论文&lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b72896971c07169fb5840e32ce47aee311c5c705" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&lt;a href=&quot;https://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki页面&lt;/a&gt;或原始论文&lt;a href=&quot;#generics2010&quot; id=&quot;id2&quot;&gt;[Generics2010]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">有关更多详细信息，请参阅Conor McBride和Ross Paterson撰写的&amp;ldquo; &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;带效果的应用程序编程&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">有关更多详细信息，请参见 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">有关GHC产生的调试信息的更多信息，请参见Peter Wortmann的博士学位论文&amp;ldquo; &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;分析优化的Haskell：因果分析和实现&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da91b931841e7893478b07acb85bd4ccd0928c7e" translate="yes" xml:space="preserve">
          <source>For more information about this type's representation, see the comments in its implementation.</source>
          <target state="translated">关于该类型表示的更多信息,请参见其实现中的注释。</target>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">有关ticky-ticky配置文件的更多信息，请参见&lt;a href=&quot;profiling#ticky-ticky&quot;&gt;使用&amp;ldquo; ticky-ticky&amp;rdquo;配置文件（对于实现者）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">有关使用API​​的更多信息以及更多示例和参考，请参见&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="586a78695eb0609dc531b936f637d0814cfd2fee" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">有关使用API​​的更多信息以及更多示例和参考，请参见&lt;a href=&quot;https://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">有关更多信息，您可以参考作为该库设计基础的&lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;原始论文&lt;/a&gt;：/ John Hughes的《漂亮印刷库的设计》，发表于Advanced Functional Programming，1995年。</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请访问新的SYB Wiki：&lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http&lt;/a&gt; : //www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB。</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类的文档。</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类的文档。@自4.9.0.0起</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">有关更多动机和细节，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt;页面或&lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;原始论文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="53c2c97747aa9fe39ba73a8b92072d90e3a4f755" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">有关更多动机和细节，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/defer-errors-to-runtime&quot;&gt;Wiki&lt;/a&gt;页面或&lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;原始论文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">对于大多数应用程序，只需使用以下 &lt;code&gt;Settings&lt;/code&gt; 标志就足够了：</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">对于大多数应用程序（例如REPL）， &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 应该具有正确的效果。</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">对于大多数数组类型，此操作为O（&lt;em&gt;n&lt;/em&gt;），其中&lt;em&gt;n&lt;/em&gt;是数组的大小。但是，diffarray包提供了一种数组类型，对此操作，其操作复杂度与更新次数呈线性关系。</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">对于嵌套的 &lt;code&gt;foralls&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">对于newtypes， &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; 所使用的总是衍生 &lt;code&gt;newtype&lt;/code&gt; 策略，即使没有 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 启用。（使用存量策略得出的实例应该没有明显的区别。）</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">对于非必需文件（例如，缓存）。它使用 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.cache&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ）。可以视为 &lt;code&gt;/var/cache&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">有关Haskell终结器的非便携式支持，请参见&lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="3383003efe56493c3ba8ee51d572a1bd3e32533a" translate="yes" xml:space="preserve">
          <source>For now, this module is the API for working with type-level literals. However, please note that it is a work in progress and is subject to change. Once the design of the &lt;code&gt;DataKinds&lt;/code&gt; feature is more stable, this will be considered only an internal GHC module, and the programmer interface for working with type-level data will be defined in a separate library.</source>
          <target state="translated">目前，该模块是用于处理类型级文字的API。但是，请注意，这是一项正在进行的工作，可能会随时更改。一旦 &lt;code&gt;DataKinds&lt;/code&gt; 功能的设计更加稳定，就只能将其视为内部GHC模块，并且将在单独的库中定义用于处理类型级别数据的程序员接口。</target>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">对于开放和封闭类型族,可以命名结果,但跳过注入性注解。对于关联类型同义词来说,情况并非如此,在这里,没有注入性注解的命名结果将被解释为关联类型同义词的默认值。</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">对于其他任何类型的类。</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">有关其他文档，请参阅：&lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http&lt;/a&gt; : //www.haskell.org/haskellwiki/Template_Haskell</target>
        </trans-unit>
        <trans-unit id="91b1fc2b5558fcebb47a9cb90615ec89658550a4" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">有关其他文档，请参阅：&lt;a href=&quot;https://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http&lt;/a&gt; : //www.haskell.org/haskellwiki/Template_Haskell</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">对于第1部分，我们定义一个类 &lt;code&gt;Encode'&lt;/code&gt; 。也许令人惊讶的是，此类是通过类型 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 的类型构造函数 &lt;code&gt;f&lt;/code&gt; 进行参数化的。这是一种技术性：所有表示类型构造函数都以 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 作为基本类型进行操作。但是从未使用过类型参数。将来可能会对此进行更改。该类具有单个方法，并且使用希望最终函数具有的类型，但是我们用 &lt;code&gt;f p&lt;/code&gt; 替换了泛型类型参数 &lt;code&gt;a&lt;/code&gt; 的出现（其中 &lt;code&gt;p&lt;/code&gt; 是任何参数；将不使用）。</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">对于实数， &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; （负）， &lt;code&gt;0&lt;/code&gt; （零）或 &lt;code&gt;1&lt;/code&gt; （正）。</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">对于实数， &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; （负）， &lt;code&gt;0&lt;/code&gt; （零）或 &lt;code&gt;1&lt;/code&gt; （正）。</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">对于有很多字段的记录,在记录模式中单独写出每个字段可能会很烦人,如</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">对于单构造函数数据类型，派生的实例声明如Haskell 2010报告的第19章第2节中的元组所示：&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https&lt;/a&gt; : //www.haskell.org/onlinereport/haskell2010/haskellch19.html。</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">由于某些原因，Mingw附带了 &lt;code&gt;readline&lt;/code&gt; 库，但没有附带 &lt;code&gt;readline&lt;/code&gt; 标头。结果，GHC（如Hugs）在Windows 上不使用 &lt;code&gt;readline&lt;/code&gt; 进行交互式输入。您可以通过使用emacs shell缓冲区获得紧密的模拟！</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">对于一些特殊的使用情况,您可能希望对哪些事件进行更多的控制。⟨flags⟩是一个由0个或多个字符组成的序列,表示要记录哪些类别的事件。目前,这些事件的类别可以被启用/禁用。</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">对于一些值,我们只关心列表的内容,而不是它们的顺序。</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">对于火花事件有两种模式:采样和完全精确。每种火花的生命周期中都有各种事件,通常只是产生和运行,但也有一些更特殊的可能性。在采样模式下,每一种火花事件的出现次数都是以频繁的间隔进行采样。在完全精确模式下,每一个火花事件都会被单独记录。后者有较高的运行时开销,默认情况下不启用。</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">出于技术原因，GHCi仅对解释的模块支持 &lt;code&gt;*&lt;/code&gt; -form。编译模块和包模块只能将其导出贡献到当前作用域中。为了确保GHCI负载解释的模块的版本，添加 &lt;code&gt;*&lt;/code&gt; 加载模块，例如，当 &lt;code&gt;:load *M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">出于技术原因，字节码编译器无法与其中一个优化过程很好地交互，因此我们在使用解释器时禁用了优化。这不是很大的损失：通过编译需要快速执行的代码片段，而不是在启用优化的情况下解释它们，您将获得更大的胜利。</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">对于派生的 &lt;code&gt;Bad Int&lt;/code&gt; 实例，GHC需要生成以下内容：</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">对于派生的 &lt;code&gt;Ex&lt;/code&gt; 实例，GHC需要生成以下内容：</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">对于第一个信任定义，信任保证由GHC通过安全语言施加的限制提供。对于信任的第二种定义，保证最初由模块作者提供。然后，客户端C通过指示他们信任该模块所驻留的包来建立他们对模块作者的信任。由于GHC不为&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译模块提供任何保证，因此需要此信任链。</target>
        </trans-unit>
        <trans-unit id="060c8275f3511e9a847d9b963216480ea97ce2de" translate="yes" xml:space="preserve">
          <source>For the first two examples we show sequenceA fully evaluating a a structure and collecting the results.</source>
          <target state="translated">对于前两个例子,我们展示了sequenceA完全评估一个结构并收集结果。</target>
        </trans-unit>
        <trans-unit id="d323edf5bc66a27abef8680a58a3a1cdc8c8ab90" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">对于字符串数据本身， &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;b#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 每个元素都使用一个字节，四舍五入到最接近的单词。例如，包括开销在内，长度为10的 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 在32位平台上将为 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 字节，而在64位平台上则为 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">对于字符串数据本身， &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;ByteString&lt;/code&gt; 每个元素都使用一个字节，四舍五入到最接近的单词。例如，包括开销在内，长度为10的 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 在32位平台上将为 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 个字节，而在64位平台上则为 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 个字节。</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">对于这些monad变压器， &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 是monad 类别中的自然变换，即对于任何monad变换 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a，</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">由于这些原因，GHC为 &lt;code&gt;tryPutMVar&lt;/code&gt; 和 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 提供了一个外部API ，您可以使用该API 廉价而异步地从C / C ++唤醒Haskell线程。</target>
        </trans-unit>
        <trans-unit id="5539b287ec186ea0d65a4fd7ea031c83904aceb1" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targeting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">因此，在解释GDB提供的源位置时，我们应该谨慎。尽管这些位置在某种意义上通常是&amp;ldquo;正确的&amp;rdquo;，但它们并不总是有用的。这就是为什么在分配成本时，针对Haskell的性能分析工具应在标准源位置信息中添加特定于GHC的注释（由 &lt;code&gt;-g2&lt;/code&gt; 发出）。</target>
        </trans-unit>
        <trans-unit id="3771cc36c2c4040313b7547f14f2698b45ba9921" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpreting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">因此，在解释GDB提供的源位置时，我们应该谨慎。尽管这些位置在某种意义上通常是&amp;ldquo;正确的&amp;rdquo;，但它们并不总是有用的。这就是为什么在分配成本时，针对Haskell的性能分析工具应在GHC特定注释（由 &lt;code&gt;-g2&lt;/code&gt; 发出）中补充标准源位置信息。</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">因此，在解释GDB提供的源位置时，我们应该谨慎。尽管这些位置在某种意义上通常是&amp;ldquo;正确的&amp;rdquo;，但它们并不总是有用的。这就是为什么在分配成本时，针对Haskell的性能分析工具应在GHC特定注释（由 &lt;code&gt;-g2&lt;/code&gt; 发出）中补充标准源位置信息。</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">对于三部分的GHC版本号 &lt;code&gt;x.y.z&lt;/code&gt; ， &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 的值是整数⟨z⟩。</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">对于&lt;em&gt;两个或多个元素的&lt;/em&gt;类型级别列表，例如上面的 &lt;code&gt;foo2&lt;/code&gt; 的签名，可以省略引号，因为含义是明确的。但是对于一或零个元素的列表（如 &lt;code&gt;foo0&lt;/code&gt; 和 &lt;code&gt;foo1&lt;/code&gt; ），必须使用引号，因为类型 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;[Int]&lt;/code&gt; 在Haskell中具有现有含义。</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">对于类型和类，GHCi还汇总了提及它们的实例。为了避免显示不相关的信息，仅在以下情况下显示一个实例：（a）其标题提到&amp;ldquo;名称&amp;rdquo;，并且（b）由于&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;的结果，该实例中提及的所有其他内容都在范围内（限定或其他）或&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">对于单利构造体</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 这样的无界类型， &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">为了与GHCi一起使用，每个库也应该有一个目标文件。目标文件的名称并&lt;em&gt;没有&lt;/em&gt;拥有 &lt;code&gt;lib&lt;/code&gt; 前缀，并具有所用平台的正常目标后缀。</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">对于大于1 的 &lt;code&gt;n&lt;/code&gt; 值，我们使用 &lt;code&gt;par&lt;/code&gt; 引发一个线程来评估 &lt;code&gt;nfib (n-1)&lt;/code&gt; ，然后使用 &lt;code&gt;pseq&lt;/code&gt; 强制父线程评估 &lt;code&gt;nfib (n-2)&lt;/code&gt; 然后再将这两个变量相加子表达式。在这种&amp;ldquo;分而治之&amp;rdquo;的方法中，我们仅为计算的一个分支触发一个新线程（让父级对另一个分支求值）。此外，我们必须使用 &lt;code&gt;pseq&lt;/code&gt; 以确保母公司将评估 &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt; &lt;code&gt;n1&lt;/code&gt; 表达式 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 。将表达式重新排序为 &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; 是不够的，因为编译器可能不会生成从左到右评估加数的代码。</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">对于GHC的 &lt;code&gt;x.y.z&lt;/code&gt; 版本， &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值是整数⟨xyy⟩（如果⟩y⟨是一位数字，则添加前导零，因此例如在GHC的6.2版本中， &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ）。有关&lt;a href=&quot;intro#version-numbering&quot;&gt;GHC版本编号策略的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="930d459a31fb0c473c8d3d450ef14232e956aa5e" translate="yes" xml:space="preserve">
          <source>ForallInvis</source>
          <target state="translated">ForallInvis</target>
        </trans-unit>
        <trans-unit id="fc5f64a4d6f12d0fb09adaae4cd55424315fc13f" translate="yes" xml:space="preserve">
          <source>ForallVis</source>
          <target state="translated">ForallVis</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">强制GHC内联一个值。</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">强制将 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 转换为正常形式。</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">强制从另一张地图上删除键值缺失的条目,否则保留不变。</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">GHC通过TH支持的国外格式</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">在内部使用UTF-16的外部函数可能会以 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 为单位而不是字符返回索引。这些函数可以安全地与此类索引一起使用，因为在必要时它们将调整偏移量以保持Unicode字符串的有效性。</target>
        </trans-unit>
        <trans-unit id="f235bf33c8f99af06dcf27d617dccc24437bf4f1" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">在内部使用UTF-16的外部函数可能会以 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 为单位而不是字符返回索引。这些函数可以安全地与此类索引一起使用，因为在必要时它们将调整偏移量以保持Unicode字符串的有效性。</target>
        </trans-unit>
        <trans-unit id="06f04f5e4c57ead75bb6944301f5d150eaeca514" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">在内部使用UTF-16的外部函数可能会以 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 为单位而不是字符返回索引。这些函数可以安全地与此类索引一起使用，因为在必要时它们将调整偏移量以保持Unicode字符串的有效性。</target>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">通过可配置的编码支持CStrings的国外集结。</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">分叉一个线程,并在线程即将终止时调用所提供的函数,出现异常或返回值。该函数的调用会屏蔽异步异常。</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">分组和执行</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">分叉和杀线。</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">叉车等</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">由幅度和相位的极性分量形成复数。</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">正式地说,在 Haskell 98 中,程序中的一个实体(函数、类型或类)是由定义它的模块名和它的名称这对组合来唯一识别的。在GHC中,一个实体是由一个三联:包、模块和名称来唯一定义的。</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">形式上，类 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 表示从 &lt;code&gt;Hask&lt;/code&gt; - &amp;gt; &lt;code&gt;Hask&lt;/code&gt; 开始的bifunctor。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 格式化为行列表。</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 格式化为行列表。</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">用C式格式化字符串格式化一个可变数量的参数。</target>
        </trans-unit>
        <trans-unit id="6c1b349cc09f134d48d7a222aba9e73980432c3a" translate="yes" xml:space="preserve">
          <source>Format picture translation</source>
          <target state="translated">格式图片翻译</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">格式字符串</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;格式化字符串。</target>
        </trans-unit>
        <trans-unit id="9e7448bd68705edd6cbfa67e98ce2811cf8f693f" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;格式化字符串。</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">格式字符串。</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">格式化转储</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">将数字格式化为文本</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">将数字的格式化为ASCII文本。</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">形成两个整数的比。</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">幸运的是,GHC提供了两种变通方法。</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">幸运的是，调试器包括一个通用的打印命令&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;，它可以检查变量的实际运行时值并尝试重构其类型。如果我们尝试在 &lt;code&gt;left&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">小数除法。</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">小数文字的处理方式相同，不同之处在于翻译是 &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">小数,支持实除。</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">释放使用&lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt;或&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String中的&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 或任何 &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt;函数分配的内存块。</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">先前由 &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; 创建的免费数据</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">释放缓存的调试数据。</target>
        </trans-unit>
        <trans-unit id="11a51d8a12071a090bc68657f6d6227b831062a8" translate="yes" xml:space="preserve">
          <source>Frees a function pointer to the window closure which has been set directly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; or indirectly by &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt;. You should call this function in your window closure's &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; case unless you delegate that case to &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; (e.g. as part of the default).</source>
          <target state="translated">释放指向由 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:setWindowClosure&quot;&gt;setWindowClosure&lt;/a&gt;&lt;/code&gt; 直接设置或由 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:createWindowEx&quot;&gt;createWindowEx&lt;/a&gt;&lt;/code&gt; 间接设置的窗口关闭的函数指针。您应该在窗口关闭的 &lt;code&gt;&lt;a href=&quot;graphics-win32-message#v:wM_NCDESTROY&quot;&gt;wM_NCDESTROY&lt;/a&gt;&lt;/code&gt; 情况下调用此函数，除非将该情况委托给 &lt;code&gt;&lt;a href=&quot;graphics-win32-window#v:defWindowProc&quot;&gt;defWindowProc&lt;/a&gt;&lt;/code&gt; （例如，作为默认值的一部分）。</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">冻结一个呼叫栈,防止任何进一步的呼叫站点被添加。</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">冻结可变数组。之后不要变异 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">在给定的 &lt;code&gt;CallStack&lt;/code&gt; 上冻结堆栈，以防止将任何其他呼叫站点压入堆栈。</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">新名字</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">从升序列表</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">从降序列表</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">从无序列表</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">来自与 &lt;code&gt;Ix&lt;/code&gt; 不同的模块</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">从语义的角度来看。</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">从句法上看。</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">从这里,我们可以将f应用于任何类型为Integer的参数,并观察结果。</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">从字符串到构造函数,反之亦然:所有数据类型。</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">从 &lt;code&gt;x1==x2&lt;/code&gt; 我们需要 &lt;code&gt;Eq a&lt;/code&gt; ，这很好。从 &lt;code&gt;c1==c2&lt;/code&gt; 我们需要 &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; ，这在今天的Haskell中已经&lt;em&gt;不&lt;/em&gt;适合了；我们没有办法解决这种限制。</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">从 &lt;code&gt;x==x&lt;/code&gt; 我们需要一个 &lt;code&gt;Eq (m Int)&lt;/code&gt; 约束，但是上下文仅提供了一种方法来找出 &lt;code&gt;Ord (m a)&lt;/code&gt; 约束。但是从给定的约束中 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; 我们得出所有a的第二个给定约束 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; ，由此我们可以轻松求解 &lt;code&gt;Eq (m Int)&lt;/code&gt; 。这个过程与超类已经起作用的方式非常相似：给定 &lt;code&gt;Ord a&lt;/code&gt; 约束，我们派生第二个给定 &lt;code&gt;Eq a&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">从摘要中:</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从所涉及的类型签名来看，这似乎应该分配一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 值和两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。但是，当在GHC下启用优化的情况下编译模块时，两个中间 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值将被优化掉，并且该函数将被编译为源 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上的单个循环。</target>
        </trans-unit>
        <trans-unit id="694096b3017c32a2a22ef4b2a40ca9ccd292d59e" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从所涉及的类型签名来看，这似乎应该分配一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 值和两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。但是，当在GHC下启用优化的情况下编译模块时，两个中间 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值将被优化，并且该函数将被编译为源 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上的单个循环。</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">从所涉及的类型签名来看，这似乎应该分配一个 &lt;code&gt;ByteString&lt;/code&gt; 值和两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。但是，当在GHC下启用优化的情况下编译模块时，两个中间 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值将被优化掉，并且该函数将被编译为源 &lt;code&gt;ByteString&lt;/code&gt; 上的单个循环。</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="9cba7ac0176caf9e0fd3fa137920b3f27031c36f" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">前端插件（如编译器插件）由注册的插件导出。但是，与编译器模块不同，前端插件是至少导出单个 &lt;code&gt;GHC.Plugins.FrontendPlugin&lt;/code&gt; 类型的标识符 &lt;code&gt;frontendPlugin&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">前端插件（如编译器插件）由注册的插件导出。但是，与编译器模块不同，前端插件是至少导出单个 &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; 类型的标识符 &lt;code&gt;frontendPlugin&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="ba860eaf95bc28dd3ebf66d6ea432e5dcf5bfbfd" translate="yes" xml:space="preserve">
          <source>Full list of currently supported flags:</source>
          <target state="translated">当前支持的旗帜的完整列表。</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">功能构成:</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">功能指针</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">产生一个可能完成的清单的函数</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">函数,产生一个可能的补全列表。第一个参数是单词左边的行内容,反过来。第二个参数是要完成的单词。</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">用于处理编码错误的函数类型。它有两个输入。</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">函数类型。最后一个类型参数可以出现在函数类型的任何地方，只要它出现在&lt;em&gt;协变&lt;/em&gt;位置即可。为了说明这意味着什么，请考虑以下三个示例：</target>
        </trans-unit>
        <trans-unit id="a1f17265bebe4b2d092da403bdca66fa2464fc46" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">如Mark Jones在&lt;a href=&quot;#jones2000&quot; id=&quot;id2&quot;&gt;[Jones2000]中&lt;/a&gt;描述的那样，实现了功能依赖性。</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">如Mark Jones在&lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]中&lt;/a&gt;所述，实现了功能依赖。</target>
        </trans-unit>
        <trans-unit id="7435c5d7a8b15c59a912dbfd0c1a6479554619cb" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">如Mark Jones在&lt;a href=&quot;#jones2000&quot; id=&quot;id31&quot;&gt;[Jones2000]中&lt;/a&gt;描述的那样，实现了功能依赖性。</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">在类声明的语法中,通过一个竖条引入功能依赖;例如</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">功能上的依赖性使问题复杂化。假设我们有:</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">与元组数据类型相关的函数。</target>
        </trans-unit>
        <trans-unit id="654ea9aec402ec9bb954f259abf37b24e92ef692" translate="yes" xml:space="preserve">
          <source>Functions called when a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is finalized. Note that C finalizers and Haskell finalizers cannot be mixed.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 完成时调用的函数。请注意，C终结器和Haskell终结器不能混合使用。</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">POSIX标准定义的用于操纵和查询文件系统的功能。尽可能指示基础POSIX函数的名称。通常，可以在系统手册页或&lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt;（需要免费注册）中获得关于POSIX功能的更完整文档以及对不同错误情况的更详细说明。</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">使用几种标准编码将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值与 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 相互转换的函数。</target>
        </trans-unit>
        <trans-unit id="db91a2c7ff023def688156c0f6c192f7664fb169" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">使用几种标准编码将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值与 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.12.1/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 相互转换的函数。</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">使用几种标准编码将惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值与惰性 &lt;code&gt;ByteString&lt;/code&gt; 相互转换的函数。</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">追踪和监控执行的功能。</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">&lt;code&gt;GHC.Stack&lt;/code&gt; 模块中的函数可用于获取当前堆栈并进行渲染。</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">从MAPI DLL加载的函数</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">字符串上的函数</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">关于类型文字的函数</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">可以被编译器融合的函数,都会用 &quot;服从融合 &quot;来记录。</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">读取文本数据时经常使用的功能。</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">向量和单子类</target>
        </trans-unit>
        <trans-unit id="5d9b79097d152d34620f656052ce7bc908e4adee" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right, performing an action on each element.</source>
          <target state="translated">表示可以从左到右遍历的数据结构的函数,对每个元素进行操作。</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">表示可以从左到右遍历的数据结构的漏斗。</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">可以在此 &lt;code&gt;let&lt;/code&gt; 语句中添加更多的绑定，因此GHCi通过更改提示指示下一行继续上一行。请注意，布局生效，所以要更多的绑定到这个 &lt;code&gt;let&lt;/code&gt; 我们不得不排队起来：</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">此外,任何定义必须满足以下条件:</target>
        </trans-unit>
        <trans-unit id="2d13054939bf42393691d74b91312a9380f6750a" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt;&lt;code&gt;-l
⟨flags⟩&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此外，GHC还允许您指定通过自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;写入事件日志数据（请参见&lt;a href=&quot;#rts-flag--l%20%E2%9F%A8flags%E2%9F%A9&quot;&gt; &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; &lt;/a&gt;）的方式：</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此外，GHC还允许您指定通过自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;写入事件日志数据（请参见&lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt;）的方式：</target>
        </trans-unit>
        <trans-unit id="66b3cc6f1053b257141eef62d3c7cec2ae3a9542" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt; do not obey the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule when their type variables are not explicitly quantified:</source>
          <target state="translated">此外，当未明确量化其类型变量时，&lt;a href=&quot;rewrite_rules#rewrite-rules&quot;&gt;重写规则&lt;/a&gt;将不遵循 &lt;code&gt;forall&lt;/code&gt; 或无规则：</target>
        </trans-unit>
        <trans-unit id="ec453e68989fa3914f8826d8c0c518b544aaa06f" translate="yes" xml:space="preserve">
          <source>Furthermore, GADT constructors do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; would be rejected, since it would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">此外，如果使用了至少其中一个，则GADT构造函数不允许在 &lt;code&gt;opt_forall&lt;/code&gt; 或 &lt;code&gt;opt_ctxt&lt;/code&gt; 周围包含最外面的括号。例如， &lt;code&gt;MkU :: (forall a. a -&amp;gt; U)&lt;/code&gt; 将被拒绝，因为它会将 &lt;code&gt;forall&lt;/code&gt; 视为嵌套。</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">此外,GHC还提供了一个轻量级的注释机制,你可以用元数据来注释你的源代码,以后你可以用编译器API或编译器插件来检查。</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">此外,GHCi将打印I/O操作的结果,如果(也只有当)。</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">此外,如下图所示,你可能会在运行使用不稳定接口编译的程序时出现大问题。</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">此外，不同的词法类型变量代表不同的类型变量。这意味着每个程序员编写的类型签名（包括一个包含自由作用域类型变量的类型签名）都表示一个&lt;em&gt;刚性&lt;/em&gt;类型。也就是说，类型对于类型检查器是完全已知的，并且不涉及任何推断。</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">此外，对于每个类型构造函数，都有一个实例可以强制使用该类型构造函数。例如，让 &lt;code&gt;D&lt;/code&gt; 为具有三个类型实 &lt;code&gt;newtype&lt;/code&gt; 的原型类型构造函数（ &lt;code&gt;data&lt;/code&gt; 或newtype），它们具有 &lt;code&gt;nominal&lt;/code&gt; ， &lt;code&gt;representational&lt;/code&gt; 角色。 &lt;code&gt;phantom&lt;/code&gt; 。然后有一个表格的实例</target>
        </trans-unit>
        <trans-unit id="e69b97115f19d41bf37478c44ac8035f4b89ab99" translate="yes" xml:space="preserve">
          <source>Furthermore, instance declarations types do not permit outermost parentheses that surround the &lt;code&gt;opt_forall&lt;/code&gt; or &lt;code&gt;opt_ctxt&lt;/code&gt;, if at least one of them are used. For example, &lt;code&gt;instance (forall a. C a)&lt;/code&gt; would be rejected, since GHC would treat the &lt;code&gt;forall&lt;/code&gt; as being nested.</source>
          <target state="translated">此外，实例声明类型不允许使用至少一个包围在 &lt;code&gt;opt_forall&lt;/code&gt; 或 &lt;code&gt;opt_ctxt&lt;/code&gt; 周围的最外面的括号。例如， &lt;code&gt;instance (forall a. C a)&lt;/code&gt; 将被拒绝，因为GHC将把 &lt;code&gt;forall&lt;/code&gt; 视为嵌套。</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">此外，结尾的 &lt;code&gt;#-}&lt;/code&gt; 应该在开头 &lt;code&gt;{-#&lt;/code&gt; 右边的一列中开始。</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">此外，类型 &lt;code&gt;t&lt;/code&gt; 被约束为具有 &lt;code&gt;Typeable&lt;/code&gt; 实例。因此，以下内容是非法的：</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">此外,我们还限制了以下特征。</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">面向融合 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 的函数，用于在 &lt;code&gt;Text&lt;/code&gt; 和几种常见编码之间进行转换。</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">易熔 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 取向功能懒之间转换 &lt;code&gt;Text&lt;/code&gt; 和一些常见的编码。</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">将来的 &lt;code&gt;integer_gmp&lt;/code&gt; 版本可能不再支持负 &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="ce2582f55bf244541fd784a5f9f776bd503eadbf" translate="yes" xml:space="preserve">
          <source>GADT constructor types are currently not permitted to have nested &lt;code&gt;forall&lt;/code&gt;s or &lt;code&gt;=&amp;gt;&lt;/code&gt;s. (e.g., something like &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; would be rejected.) As a result, &lt;code&gt;gadt_sig&lt;/code&gt; puts all of its quantification and constraints up front with &lt;code&gt;opt_forall&lt;/code&gt; and &lt;code&gt;opt_context&lt;/code&gt;. Note that higher-rank &lt;code&gt;forall&lt;/code&gt;s and &lt;code&gt;=&amp;gt;&lt;/code&gt;s are only permitted if they do not appear directly to the right of a function arrow in a &lt;code&gt;prefix_gadt_body&lt;/code&gt;. (e.g., something like &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; is allowed, since parentheses separate the &lt;code&gt;forall&lt;/code&gt; from the &lt;code&gt;-&amp;gt;&lt;/code&gt;.)</source>
          <target state="translated">目前不允许GADT构造函数类型嵌套 &lt;code&gt;forall&lt;/code&gt; 或 &lt;code&gt;=&amp;gt;&lt;/code&gt; 。 （例如，诸如 &lt;code&gt;MkT :: Int -&amp;gt; forall a. a -&amp;gt; T&lt;/code&gt; 将被拒绝。）因此， &lt;code&gt;gadt_sig&lt;/code&gt; 将其所有量化和约束放在 &lt;code&gt;opt_forall&lt;/code&gt; 和 &lt;code&gt;opt_context&lt;/code&gt; 的前面。请注意，只有在它们不直接出现在 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 中的功能箭头右侧的情况下，才允许使用更高级别的 &lt;code&gt;forall&lt;/code&gt; s和 &lt;code&gt;=&amp;gt;&lt;/code&gt; 。 （例如， &lt;code&gt;MkS :: Int -&amp;gt; (forall a. a) -&amp;gt; S&lt;/code&gt; 的东西，因为括号将 &lt;code&gt;forall&lt;/code&gt; 与 &lt;code&gt;-&amp;gt;&lt;/code&gt; 分开。）</target>
        </trans-unit>
        <trans-unit id="844bd170f572f4ec24f5e9600fd9f1281aa26e3c" translate="yes" xml:space="preserve">
          <source>GADT constructors are extra particular about their &lt;code&gt;forall&lt;/code&gt;s. In addition to adhering to the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule, GADT constructors also forbid nested &lt;code&gt;forall&lt;/code&gt;s. For example, GHC would reject the following GADT:</source>
          <target state="translated">GADT构造函数对他们的 &lt;code&gt;forall&lt;/code&gt; 尤为关注。除了遵守 &lt;code&gt;forall&lt;/code&gt; -or-nothing规则外，GADT构造函数还禁止嵌套 &lt;code&gt;forall&lt;/code&gt; 。例如，GHC会拒绝以下GADT：</target>
        </trans-unit>
        <trans-unit id="5254c66df5fb20f0f8f5d6b6fad2ca033bf6a230" translate="yes" xml:space="preserve">
          <source>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</source>
          <target state="translated">GADT 风格的数据声明可以绑定其输入,也可以在独立的种类签名之外使用内联签名。</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC风格的响应文件。</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="71e2fb25bf34a1d6ca4d0e65e2d0d3bee84e64bf" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;relevant chapter&lt;/a&gt; of the Haskell Report for more details.</source>
          <target state="translated">GHC（大部分）符合Haskell报告中指定的Haskell外部功能接口。&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch8.html&quot;&gt;有关&lt;/a&gt;更多详细信息，请参阅Haskell报告的相关章节。</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC（大部分）符合Haskell外部功能接口，该接口的定义是&lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;上的Haskell报告的一部分。</target>
        </trans-unit>
        <trans-unit id="0064178248eb2eacd8d3ac6bab315de2aca56d04" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC（始终使用&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;）试图内联（或&amp;ldquo;展开&amp;rdquo;）&amp;ldquo;足够小&amp;rdquo;的函数/值，从而避免了调用开销并可能暴露其他更奇妙的优化。 GHC具有一套启发式方法，可在很长一段时间内使用许多基准进行调整，这些方法可决定何时在其调用位置内联函数是有益的。启发式方法旨在内联函数，如果这样做似乎是有益的，但不会引起过多的代码膨胀。如果函数看起来太大，则不会内联，并且大于特定大小的函数甚至不会在接口文件中导出其定义。可以使用标志来更改控制这些启发式决策的某些阈值，请参见&lt;a href=&quot;../using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC（始终使用&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;）试图内联（或&amp;ldquo;展开&amp;rdquo;）&amp;ldquo;足够小&amp;rdquo;的函数/值，从而避免了调用开销并可能暴露其他更奇妙的优化。 GHC具有一套启发式方法，可在很长一段时间内使用许多基准进行调整，这些方法可确定何时在其调用位置内联函数是有益的。启发式方法旨在内联函数，如果这样做似乎是有益的，但不会引起过多的代码膨胀。如果函数看起来太大，则不会内联，并且大于特定大小的函数甚至不会在接口文件中导出其定义。可以使用标志来更改控制这些启发式决策的某些阈值，请参见&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8可以评估涉及类型级自然数的算术表达式。可以使用类型家族 &lt;code&gt;(+), (*), (^)&lt;/code&gt; 进行加，乘和幂运算来构造此类表达式。可以使用 &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; 比较数字，将返回提升的布尔值，或者使用 &lt;code&gt;(&amp;lt;=)&lt;/code&gt; 比较数字作为约束。例如：</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8通过声明类型和种类确实是相同的，扩展了种类多态性的概念。 GHC中没有任何东西可以区分类型和种类。对此的另一种思考方式是， &lt;code&gt;Bool&lt;/code&gt; 类型和&amp;ldquo;提升类型&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; 实际上是相同的。 （请注意，术语 &lt;code&gt;True&lt;/code&gt; 和类型 &lt;code&gt;'True&lt;/code&gt; 仍然是不同的，因为前者可以在表达式中使用，而后者可以在类型中使用。）类型和种类之间缺乏区别是依赖类型语言的标志。完全依赖类型的语言也消除了表达式和类型之间的差异，但是在GHC中做到这一点又是另一回事了。</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2支持模块签名（ &lt;code&gt;hsig&lt;/code&gt; 文件），它允许您编写签名来代替模块实现，从而将实现的选择推迟到以后的某个时间点。没有&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;不能使用该功能; 本手册将重点介绍签名的语法和语义。</target>
        </trans-unit>
        <trans-unit id="078f9d9639e0226176f8bd445a4da3cf27270446" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2支持模块签名（ &lt;code&gt;hsig&lt;/code&gt; 文件），它允许您编写签名来代替模块实现，从而将实现的选择推迟到以后的某个时间点。没有&lt;a href=&quot;https://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;不能使用该功能;本手册将重点介绍签名的语法和语义。</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC扩展:这是获取GHC特定扩展的认可方式。</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC注意：为了在不阻塞系统中所有其他线程的情况下调用 &lt;code&gt;waitForProcess&lt;/code&gt; ，必须使用 &lt;code&gt;-threaded&lt;/code&gt; 编译程序。</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">&lt;strong&gt;如果有疑问&lt;/strong&gt;，GHC会采用&lt;strong&gt;拒绝&lt;/strong&gt;。我们可以看到它在实践中是多么痛苦，并在必要时尝试更大胆的尝试。</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">当线程通过 &lt;code&gt;foreign export&lt;/code&gt; 调用Haskell函数时，GHC会分配少量线程本地内存。通常在 &lt;code&gt;hs_exit()&lt;/code&gt; 之前不会释放此内存；内存被缓存，以便随后对Haskell的调用很快。但是，如果您的应用程序正在长时间运行，并反复创建调用Haskell的新线程，则您可能希望安排在已完成调用Haskell函数的那些线程中释放此内存。为此，请从要释放其内存的线程中调用 &lt;code&gt;hs_thread_done()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC允许存在式也可以和记录语法一起使用。例如:</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC允许以十进制、八进制、十六进制、二进制或浮点数的形式给出数字文字。</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC允许由&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;启用的独立 &lt;code&gt;deriving&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC允许类型构造函数、类和类型变量成为运算符,并且可以写成infix,很像表达式。更具体地说。</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC还允许可见类型应用,用户可以声明类型参数在类型多态情况下被实例化。它的用法在术语层面与可见类型应用类似,如上所述。</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC还支持&lt;em&gt;种类异构的&lt;/em&gt;相等性，后者将两种类型的潜在不同种类联系起来。异类平等被拼写为 &lt;code&gt;~~&lt;/code&gt; 。以下是 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~~&lt;/code&gt; 的种类，以更好地理解它们之间的区别：</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC始终将实例的&lt;em&gt;最后一个&lt;/em&gt;参数（在此示例中为 &lt;code&gt;Foo&lt;/code&gt; ）视为派生其实例的类型。</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC 将可怕的单形限制(Haskell 报告的 4.5.5 节)应用于隐式参数。例如,请考虑:</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC假定源文件只使用ASCII或UTF-8,其他编码不被识别,但无效的UTF-8序列会在注释中被忽略,所以只要非注释的源码是ASCII,就可以使用其他编码,如拉丁语1。然而,无效的UTF-8序列将在注释中被忽略,所以只要非注释源码是ASCII码,就可以使用其他编码,如Latin-1。</target>
        </trans-unit>
        <trans-unit id="db91b54c27a7f2bcbfa6b8c3b3b4820b8e9289ae" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC尝试使用垃圾收集器检测线程何时死锁。无法访问的线程（无法通过跟随活动对象的指针找到）必须处于死锁状态，在这种情况下，该线程将被发送异常。根据线程的死锁方式，可以是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC尝试使用垃圾收集器检测何时线程死锁。无法访问的线程（无法通过跟随活动对象的指针找到）必须处于死锁状态，在这种情况下，该线程将被发送异常。根据线程的死锁方式，可以是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c272c9b0ad07c2ab3a7ed8c9cf27b583eb6bbea9" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC尝试使用垃圾收集器检测线程何时死锁。无法访问的线程（无法通过跟随活动对象的指针找到）必须处于死锁状态，在这种情况下，该线程将被发送异常。根据线程的死锁方式，可以是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC在编译时会积累有关Haskell源文件的大量信息。扩展接口文件是一种将某些信息持久保存到磁盘的方法，以便外部工具（例如IDE的工具）可以避免再次进行解析，类型检查和重命名。这些文件包含</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC计算每个接口文件以及接口文件中每个声明的指纹（实际上是MD5哈希）。它还在每个接口文件中保留了上次编译文件时使用的所有指纹的列表。如果源文件的修改日期早于 &lt;code&gt;.o&lt;/code&gt; 文件的日期（即，自从上次编译文件以来源文件没有更改），并且重新编译检查已启用，则GHC会很聪明。它将这次需要的东西的指纹与上次需要的东西的指纹进行比较（从正在编译的模块的接口文件中收集）；如果它们都相同，它将在过程的早期停止编译，并显示&amp;ldquo;不需要编译&amp;rdquo;。多么美丽的景象！</target>
        </trans-unit>
        <trans-unit id="7db002a47d7a1c542bad6dcda111e3df7de5d2cf" translate="yes" xml:space="preserve">
          <source>GHC can also be configured using environment variables. Currently the only variable it supports is &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt;, which, when set, disables Unicode output regardless of locale settings. &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; can be set to anything +(event an empty string) to trigger this behaviour.</source>
          <target state="translated">也可以使用环境变量配置GHC。当前，它支持的唯一变量是 &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; ，如果设置了该变量，则无论区域设置如何，都将禁用Unicode输出。可以将 &lt;code&gt;GHC_NO_UNICODE&lt;/code&gt; 设置为+（事件为空字符串）以触发此行为。</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">如果GHC知道这些代码没有被导出,那么它对这些代码的处理就会更加激进。</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC自带了许多库。这些都在单独的文档中描述。</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC带有时间和空间剖析系统，因此您可以回答诸如&amp;ldquo;为什么我的程序为什么这么慢？&amp;rdquo;或&amp;ldquo;为什么我的程序使用那么多的内存？&amp;rdquo;之类的问题。</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC编译一些程序构造的速度很慢。</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC完全忽略了浮点环境,运行时既不修改也不读取。</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC 在当前目录中创建一个子目录 &lt;code&gt;.hpc&lt;/code&gt; ，并将HPC索引（ &lt;code&gt;.mix&lt;/code&gt; ）文件放在其中，每个编译的模块一个。您无需担心这些文件：它们包含 &lt;code&gt;hpc&lt;/code&gt; 工具在程序运行后为已编译模块生成coverage数据所需的信息。</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC目前在扩展同义词之前会进行种类检查(不过即使这样也可以改变)。</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHC当前使用一种非常简单的语法匹配算法来将规则LHS与表达式进行匹配。它寻求一种替代方法，使LHS和表达式在语法上相等于模alpha转换。如有必要，模式（规则）而不是表达式被eta扩展。（扩展Eta表达式可能会导致懒惰错误。）但是beta转换不是这样（这称为高阶匹配）。</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC 根据此原理在多个 &lt;code&gt;COMPLETE&lt;/code&gt; 集之间进行歧义消除。为了使事情更加正式，当模式匹配检查器为某些数据类型构造函数 &lt;code&gt;T&lt;/code&gt; 请求一组构造函数时，检查器返回：</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC知道程序中正在使用哪种具体的类型级别文字后，便立即释放该约束。请注意，这仅适用于&lt;em&gt;文字&lt;/em&gt;，不适用于任意类型表达式。例如，该形式的约束 &lt;code&gt;KnownNat (a + b)&lt;/code&gt; 将&lt;em&gt;不&lt;/em&gt;被简化为 &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; 相反，GHC将保持约束不变，直到可以将 &lt;code&gt;a + b&lt;/code&gt; 简化为恒定值为止。</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC不允许你有一个数据类型,其上下文提到的类型变量不是数据类型参数。例如:</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">根据Haskell 98的要求，GHC不会在解析过程中对表达式进行固定性解析（但Haskell 2010则不如此）。例如，根据Haskell 98报告，以下表达式是合法的：</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">GHC不必为每个编译都重新启动，这意味着它可以在编译之间缓存信息。使用 &lt;code&gt;ghc --make&lt;/code&gt; 编译多模块程序的速度可能是在每个源文件上单独运行 &lt;code&gt;ghc&lt;/code&gt; 的速度的两倍。</target>
        </trans-unit>
        <trans-unit id="7fc5be5c4ca5725b6d97a12bfd6fd11cb070f451" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full laziness. Although GHC&amp;rsquo;s full-laziness optimisation does enable some transformations which would be performed by a fully lazy implementation (such as extracting repeated computations from loops), these transformations are not applied consistently, so don&amp;rsquo;t rely on them.</source>
          <target state="translated">GHC没有实现完全的懒惰。尽管GHC的完全懒惰优化确实启用了一些完全懒惰的实现将执行的转换（例如从循环中提取重复的计算），但是这些转换并没有始终如一地应用，因此请不要依赖它们。</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC没有实现完全的懒惰。如果未启用优化，并且未给出 &lt;code&gt;-fno-full-laziness&lt;/code&gt; ，则将执行一些增加共享的转换，例如从循环中提取重复的计算。这些转换与完全懒惰的实现所进行的转换相同，不同之处在于GHC不会始终采用完全懒惰，因此请不要依赖它。</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC确保内联不会永远持续下去：每个相互递归的组都被一个或多个从未内联的&lt;em&gt;循环断路器&lt;/em&gt;削减（请参阅&lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;2002年7月JFP 12（4），GHC&lt;/a&gt;内联的秘密）。 GHC尝试不选择具有 &lt;code&gt;INLINE&lt;/code&gt; 编译指示的功能作为循环断路器，但是当没有选择时，甚至可以选择INLINE功能，在这种情况下，将忽略 &lt;code&gt;INLINE&lt;/code&gt; 编译指示。例如，对于自递归函数，循环断路器只能是该函数本身，因此始终忽略 &lt;code&gt;INLINE&lt;/code&gt; 编译指示。</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC通过内置的ghc包向用户公开其内部API。它允许您编写利用GHC整个编译驱动程序的程序，以便以编程方式分析或编译Haskell代码。此外，GHC使用户能够在编译过程中加载编译器插件-允许查看和更改GHC内部中间表示形式Core的模块。插件适用于诸如实验优化或分析之类的事情，并且在许多常见情况下为编译器开发提供了较低的进入门槛。</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC通过附加的呼叫约定 &lt;code&gt;prim&lt;/code&gt; 扩展了FFI ，例如：</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC对这个列表进行了扩展,增加了几个可以自动衍生的类。</target>
        </trans-unit>
        <trans-unit id="b8da89741da234fc1301b6c98edbd981b7cba345" translate="yes" xml:space="preserve">
          <source>GHC generates case expressions without a default alternative in some cases:</source>
          <target state="translated">GHC生成的大小写表达式在某些情况下没有默认的选择。</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC具有 &lt;code&gt;-dynload&lt;/code&gt; 链接标志，用于选择用于在运行时查找共享库的方法。当前有两种模式：</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC具有全面的优化器，因此当您真正想要使用它（并且有足够的时间来节省时间）时，GHC可以生成非常快速的代码。另外，默认选项是尽可能快地编译，同时不花太多精力来优化生成的代码（尽管GHC可能不是您所描述的快速编译器：-）。</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC有一个自定义的求解器，用于释放涉及 &lt;code&gt;Typeable&lt;/code&gt; 类的约束，并且禁止手写实例。这样可以确保程序员无法通过编写伪造的实例来破坏类型系统。</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC有一些内置的特殊行为的函数。特别是:</target>
        </trans-unit>
        <trans-unit id="8bdd8132100b5a3de15d0bde30890b059463f096" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse &lt;code&gt;-Werror&lt;/code&gt;, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC有许多选项，它们可以选择在编译过程中可以生成哪种类型的非致命错误消息，也称为警告。一些选项控制单个警告，其他选项控制警告的集合。要关闭单个警告 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; ，请使用 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; 。要反转 &lt;code&gt;-Werror&lt;/code&gt; （使所有警告变为错误），请使用 &lt;code&gt;-Wwarn&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC有许多选项，可以选择在编译过程中可以生成哪些类型的非致命错误消息，也称为警告。一些选项控制单个警告，而其他选项控制警告的集合。要关闭单个警告 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; ，请使用 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; 。要反转使所有警告变为错误的 &lt;code&gt;-Wwarn&lt;/code&gt; ，请使用-Wwarn。</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC具有对&lt;em&gt;签名稀疏的&lt;/em&gt;实验性支持，当签名具有显式导出列表而没有签名本身的模块导出时，将使用GHC 。在这种情况下，导出列表将&lt;em&gt;在&lt;/em&gt;合并&lt;em&gt;后&lt;/em&gt;应用于最终导出列表，特别是，您可以引用未在本地 &lt;code&gt;hsig&lt;/code&gt; 文件的主体中声明的实体。</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC对&lt;em&gt;Impredicative多态性的&lt;/em&gt;支持非常&lt;em&gt;脆弱&lt;/em&gt;，启用了&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;。如果可行，这意味着您&lt;em&gt;可以&lt;/em&gt;在多态类型上调用多态函数，并在多态类型上参数化数据结构。例如：</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC能够在编译时加载编译器插件。该功能类似于&lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;提供的功能，允许用户编写插件，这些插件可以调整约束求解器的行为，检查和修改编译管道，以及转换和检查GHC的中间语言Core。插件适用于实验分析或优化，不需要更改GHC的源代码即可使用。</target>
        </trans-unit>
        <trans-unit id="22a7c64e218b3312ad9be925711deec4357a32a4" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC能够在编译时加载编译器插件。该功能类似于&lt;a href=&quot;https://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;提供的功能，允许用户编写插件，这些插件可以调整约束求解器的行为，检查和修改编译管道，以及转换和检查GHC的中间语言Core。插件适用于实验分析或优化，不需要更改GHC的源代码即可使用。</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC必须将您的代码与各种库链接，可能包括：用户提供的，GHC提供的和系统提供的（例如 &lt;code&gt;-lm&lt;/code&gt; 数学库）。</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC有两个主要组件：一个交互式的Haskell解释器（也称为GHCI），在所描述&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCI&lt;/a&gt;和批处理编译器，在整个描述&lt;a href=&quot;using#using-ghc&quot;&gt;使用GHC&lt;/a&gt;。实际上，GHC包含一个单独的程序，该程序仅以不同的选项运行，以提供交互式或批处理系统。</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHC主页</target>
        </trans-unit>
        <trans-unit id="7b51be1ff5f1ddedfd931ac8c672d1058c111c02" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">当使用&lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;标志打开优化时，GHC将忽略断言。也就是说， &lt;code&gt;assert pred e&lt;/code&gt; 形式的表达式将被重写为 &lt;code&gt;e&lt;/code&gt; 。您也可以使用&lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt;选项禁用断言。选项&lt;a href=&quot;../using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt;允许启用断言，即使打开优化也是如此。</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">当使用&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;标志打开优化时，GHC将忽略断言。也就是说， &lt;code&gt;assert pred e&lt;/code&gt; 形式的表达式将被重写为 &lt;code&gt;e&lt;/code&gt; 。您也可以使用&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt;选项禁用断言。选项&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt;允许启用断言，即使打开优化也是如此。</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC对Haskell 2010报告的FFI章节实施了一些特定于GHC的扩展。这些扩展&lt;a href=&quot;#ffi-ghcexts&quot;&gt;在FFI章节的GHC扩展中进行了&lt;/a&gt;描述，但请注意，使用这些功能的程序不可移植。因此，应尽可能避免使用这些功能。</target>
        </trans-unit>
        <trans-unit id="1383e2906207b123b97681b2a7fc069bbcc74f65" translate="yes" xml:space="preserve">
          <source>GHC implements an &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; extension as specified in &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;this GHC proposal&lt;/a&gt;. &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; relaxes the restrictions around what types can appear inside of a &lt;code&gt;newtype&lt;/code&gt;. For example, the type</source>
          <target state="translated">GHC实施了&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0013-unlifted-newtypes.rst&quot;&gt;此GHC提案中&lt;/a&gt;指定的&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;扩展。&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;放松围绕什么类型可以内出现的限制 &lt;code&gt;newtype&lt;/code&gt; 。例如，类型</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC实现了先发制人的多任务处理:线程的执行以随机方式交错进行。更具体地说,一个线程每当分配一些内存时就可能被抢占,不幸的是,这意味着不进行分配的紧缩循环往往会锁定其他线程(然而,这似乎只发生在病态的benchmark风格的代码中)。</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC实现了对Haskell的一些主要扩展,支持并发和并行编程。首先让我们建立术语。</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">当涉及到类型函数或类型变量时,GHC保守地实现了这个测试。例如</target>
        </trans-unit>
        <trans-unit id="0fc31183c1e70f82a9bdd1edfbb35d0be9ae0a6c" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;../phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC包含各种标志，这些标志允许在编译时运行任意进程。&lt;a href=&quot;../phases#pre-processor&quot;&gt;定制预处理器&lt;/a&gt;标志就是这样的一个例子。另一个是Template Haskell在编译时执行Haskell代码（包括IO操作）的能力。 Safe Haskell&lt;em&gt;无法解决此危险&lt;/em&gt;（尽管禁止使用Template Haskell）。</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC包含各种标志，这些标志允许在编译时运行任意进程。一个这样的例子是&lt;a href=&quot;phases#pre-processor&quot;&gt;定制预处理器&lt;/a&gt;标志。另一个是Template Haskell在编译时执行Haskell代码（包括IO操作）的能力。Safe Haskell &lt;em&gt;不能解决这种危险&lt;/em&gt;（尽管Template Haskell是不允许的功能）。</target>
        </trans-unit>
        <trans-unit id="d09bb52c1f872e95bf9ee5c47a2b96510a0df672" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC包括对在对称的共享内存多处理器（SMP）上并行运行Haskell程序的支持。默认情况下，GHC在一个处理器上运行您的程序。如果要使其并行运行，则必须将程序与&lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接，并使用RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 选项运行它；请参阅&lt;a href=&quot;../using-concurrent#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;）。运行时将在可用的OS线程之间调度正在运行的Haskell线程，并与 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS选项指定的并行运行数量一样多。</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC包括支持在对称的共享内存多处理器（SMP）上并行运行Haskell程序。默认情况下，GHC在一个处理器上运行程序。如果要使其并行运行，则必须将程序与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接，并使用RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 选项运行它；请参阅&lt;a href=&quot;using-concurrent#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;）。运行时将在可用的OS线程中调度正在运行的Haskell线程，并与 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS选项指定的并行运行数量一样。</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC是一个由多个阶段组成的大型程序。您可以使用下面列出的 &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; 标志告诉GHC转储各个编译阶段的信息。请注意，其中一些往往会产生大量输出。您可以通过传递&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;来防止它们阻塞标准输出。</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC建立在大量原始数据类型和操作之上；从某种意义上说，&amp;ldquo;原始&amp;rdquo;无法在Haskell本身中定义。虽然您确实可以使用这些东西来编写快速的代码，但从长远来看，使用高级语言功能和库通常会减轻很多痛苦，并且从长远来看，它会更令人满意。运气好的话，在任何情况下，您编写的代码都将被优化为有效的非盒装版本。如果不是的话，我们想知道。</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC本身就是Haskell程序，因此，如果您需要将选项直接传递到GHC的运行时系统，则可以将它们包含在 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; （请参阅&lt;a href=&quot;runtime_control#runtime-control&quot;&gt;运行编译的程序&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">对于没有&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 的&lt;/a&gt;常规编译，GHC令人惊讶地令人生畏。</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC对于重复工作是非常谨慎的。例如,可以考虑</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC对接口文件非常敏感。例如，如果它拾取了非标准的 &lt;code&gt;Prelude.hi&lt;/code&gt; 文件，那么将会发生非常糟糕的事情。如果打开 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude选项，则除非您知道自己在做什么，否则编译器几乎肯定会死。</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC在优化程序的过程中,不断尝试应用这些规则。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHC特别知道两个软件包数据库。</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC允许您使用 &lt;code&gt;-with-rtsopts&lt;/code&gt; 标志（&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）在编译时更改程序的默认RTS选项。这样做的常见用法是为程序提供默认的堆和/或堆栈大小，该默认堆和/或堆栈大小大于默认值。例如，要设置 &lt;code&gt;-H128m -K64m&lt;/code&gt; ，请与 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">通过编译运行时系统调用的&amp;ldquo;挂钩&amp;rdquo;，GHC使您可以对任何给定程序的某些RTS设置进行基本控制。RTS包含这些挂钩的存根定义，但是通过编写您自己的版本并在GHC命令行上链接它，您可以覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC通过语言扩展&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;解除了此限制。首先，限制是一个非常愚蠢的限制，因此&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;隐含了&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="026e2f888db92431c91e24d1a0558f32b93663ed" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC通过语言扩展&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;解除了此限制。首先，该限制是一个非常愚蠢的限制，因此&lt;a href=&quot;multi_param_type_classes#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;隐含了&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC喜欢单构造数据类型。</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC保留了一个属性，即所有居住类型的类型（不同于类型构造函数或类型级别数据）告诉我们该类型值的运行时表示形式。此数据类型编码运行时值的选择。注意 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; 参数化；这正是我们的意思，即类型的类型会编码运行时表示形式。</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC绝对不尝试验证规则的LHS和RHS具有相同的含义。通常这是无法确定的，而在大多数有趣的情况下则是不可行的。责任完全是程序员的责任！</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC没有试图确保规则是汇合的或终止的。例如:</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC可以在 &lt;code&gt;.debug_info&lt;/code&gt; 部分中生成以下标准DIE，</target>
        </trans-unit>
        <trans-unit id="093f5ff97cdf917305aab74e98feadff3bea2477" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;../codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">通过C进行编译时，GHC不再包含外部头文件，因此不会执行此检查。进行此更改是为了与本&lt;a href=&quot;../codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;（&lt;a href=&quot;../phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）兼容，并严格遵守FFI规范，该规范要求FFI调用不得进行宏扩展以及使用C头文件时可能会应用的其他CPP转换。这种方法还简化了跨模块和包边界的外部调用的内联：编译外部调用的内联版本时，不需要头文件可用，因此编译器可以在任何上下文中自由地内联外部调用。</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">通过C进行编译时，GHC不再包含外部头文件，因此不会执行此检查。进行此更改是为了与本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;（&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）兼容，并严格遵守FFI规范，该规范要求FFI调用不得进行宏扩展以及使用C头文件时可能应用的其他CPP转换。这种方法还简化了跨模块和包边界的外部调用的内联：编译外部调用的内联版本时，不需要头文件可用，因此编译器可以在任何上下文中自由地内联外部调用。</target>
        </trans-unit>
        <trans-unit id="9a9906447d97115265712315061f7cad299f0951" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">通过C进行编译时，GHC不再包含外部头文件，因此不会执行此检查。进行此更改是为了与本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;（&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）兼容，并严格遵守FFI规范，该规范要求FFI调用不得进行宏扩展以及使用C头文件时可能会应用的其他CPP转换。这种方法还简化了跨模块和包边界的外部调用的内联：编译外部调用的内联版本时，不需要头文件可用，因此编译器可以在任何上下文中自由地内联外部调用。</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC通常会为您导入 &lt;code&gt;Prelude.hi&lt;/code&gt; 文件。如果您不想这样做，请给它一个 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; 选项。这样做的想法是您可以导入自己的前奏。 （但不要称其为 &lt;code&gt;Prelude&lt;/code&gt; ； Haskell模块的名称空间是平坦的，并且您不得与任何Prelude模块冲突。）</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC注意：当垃圾收集器检测到该 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 已被程序未引用时，该句柄将自动关闭。但是，通常不建议依赖此行为：垃圾收集器是不可预测的。如果可能，请在不再需要它们时使用显式 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 关闭 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。当文件描述符用完时，GHC当前不尝试释放它们，这是您的责任，以确保不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC注意：启动程序时，功能数量由 &lt;code&gt;+RTS -N&lt;/code&gt; 选项指定。如果底层操作系统支持，则可以使用 &lt;code&gt;+RTS -qa&lt;/code&gt; 将功能固定在实际的处理器核心上，尽管在实践中这通常是不必要的（在某些情况下可能会降低性能-建议进行实验）。</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
