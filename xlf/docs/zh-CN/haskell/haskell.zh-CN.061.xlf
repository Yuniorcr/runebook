<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="15bb173707cc00113315f136acf915560a27f60c" translate="yes" xml:space="preserve">
          <source>FileStatus</source>
          <target state="translated">FileStatus</target>
        </trans-unit>
        <trans-unit id="6774947837a99235d0bd2076b121b3dd3a43aa95" translate="yes" xml:space="preserve">
          <source>FileTag</source>
          <target state="translated">FileTag</target>
        </trans-unit>
        <trans-unit id="1baa34e6560f1522cca6ce9d9df461092e8ec59b" translate="yes" xml:space="preserve">
          <source>FileType</source>
          <target state="translated">FileType</target>
        </trans-unit>
        <trans-unit id="4324ba3b44136bad26f9c65258416f168b463786" translate="yes" xml:space="preserve">
          <source>Filename completion</source>
          <target state="translated">文件名完成</target>
        </trans-unit>
        <trans-unit id="2ebfcb3969f0ba497b6130046dbc6f62106ac185" translate="yes" xml:space="preserve">
          <source>Filename extension for executable files (including the dot if any) (usually &lt;code&gt;&quot;&quot;&lt;/code&gt; on POSIX systems and &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; on Windows or OS/2).</source>
          <target state="translated">可执行文件的文件扩展名（包括点号，如果有的话）（在POSIX系统上通常为 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，在Windows或OS / 2上通常为 &lt;code&gt;&quot;.exe&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="430a7fb7f4eedabcec0ba92367e6b4e3cc37cb65" translate="yes" xml:space="preserve">
          <source>Filename of the executable (see &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; for details)</source>
          <target state="translated">可执行文件的文件名（有关详细信息，请参见 &lt;code&gt;&lt;a href=&quot;system-process#v:RawCommand&quot;&gt;RawCommand&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c1e5594cbcf5d29cd4606ef3b29742013aa676d3" translate="yes" xml:space="preserve">
          <source>Filename/directory functions</source>
          <target state="translated">文件名/目录功能</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="1d68fcbcaa9e6c0596bd77cd85d8ef1430e2e255" translate="yes" xml:space="preserve">
          <source>Files and handles</source>
          <target state="translated">文件和手柄</target>
        </trans-unit>
        <trans-unit id="8c12ce59fd07366870c4918986c036d5b1718b2d" translate="yes" xml:space="preserve">
          <source>Files with other suffixes (or without suffixes) are passed straight to the linker.</source>
          <target state="translated">带有其他后缀(或没有后缀)的文件会直接传递给链接器。</target>
        </trans-unit>
        <trans-unit id="0bcfe196150a905d9689e141f80a3a2ecefe16ce" translate="yes" xml:space="preserve">
          <source>Fill a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e773234ce1275af1c68adf87a3b4bc236bada9" translate="yes" xml:space="preserve">
          <source>Fill a given number of bytes in memory area with a byte value.</source>
          <target state="translated">用一个字节值填充内存区域中给定数量的字节。</target>
        </trans-unit>
        <trans-unit id="cd4d3d8bc69124ec20ace02425021dd9178e5281" translate="yes" xml:space="preserve">
          <source>Filling up memory area with required values</source>
          <target state="translated">用所需值填充内存区域</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="8022a4851f7324da6865a694a01b0bcaab7a2f99" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map using some &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">使用某些&amp;ldquo; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; &amp;rdquo;操作过滤另一个映射中缺少其键的条目。</target>
        </trans-unit>
        <trans-unit id="787c541edc37e7915b5310e8847885791e0e7bf2" translate="yes" xml:space="preserve">
          <source>Filter the entries whose keys are missing from the other map.</source>
          <target state="translated">筛选其他地图中没有键的条目。</target>
        </trans-unit>
        <trans-unit id="65039e687d346fc2cb3b9e4ba3fdebf8936d6f9e" translate="yes" xml:space="preserve">
          <source>FinalQuote</source>
          <target state="translated">FinalQuote</target>
        </trans-unit>
        <trans-unit id="e068667dac3c14788401a6fb7eba398f0213b990" translate="yes" xml:space="preserve">
          <source>Finalised data pointers</source>
          <target state="translated">最后确定的数据指针</target>
        </trans-unit>
        <trans-unit id="4bf1c69e4a67738c229264f62b72b00175b94776" translate="yes" xml:space="preserve">
          <source>Finalization means (a) arrange that subsequent calls to &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;; and (b) run the finalizer.</source>
          <target state="translated">终结处理手段（a）安排对 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 的后续调用不返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ；（b）运行终结器。</target>
        </trans-unit>
        <trans-unit id="4f4bcb977484412c1a687b2717df3db42e0223d6" translate="yes" xml:space="preserve">
          <source>Finalize a weak pointer. The return value is an unboxed tuple containing the new state of the world and an &quot;unboxed Maybe&quot;, represented by an &lt;code&gt;Int#&lt;/code&gt; and a (possibly invalid) finalization action. An &lt;code&gt;Int#&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; indicates that the finalizer is valid. The return value &lt;code&gt;b&lt;/code&gt; from the finalizer should be ignored.</source>
          <target state="translated">敲定弱指针。返回值是一个未装箱的元组，包含世界的新状态和一个&amp;ldquo;未装箱的Maybe&amp;rdquo;，由 &lt;code&gt;Int#&lt;/code&gt; 和一个（可能无效的）完成动作表示。一种 &lt;code&gt;Int#&lt;/code&gt; 的 &lt;code&gt;1&lt;/code&gt; 表示该终结是有效的。来自终结器的返回值 &lt;code&gt;b&lt;/code&gt; 应该被忽略。</target>
        </trans-unit>
        <trans-unit id="f43bcd35f75b6b03cc41d4b7b36c9671eee326a4" translate="yes" xml:space="preserve">
          <source>FinalizerEnvPtr</source>
          <target state="translated">FinalizerEnvPtr</target>
        </trans-unit>
        <trans-unit id="b1542ae832d41717b2363b38f917247984d58f95" translate="yes" xml:space="preserve">
          <source>FinalizerPtr</source>
          <target state="translated">FinalizerPtr</target>
        </trans-unit>
        <trans-unit id="86d2d2c2528b5945d0ddc3f7f67ee4046606e5af" translate="yes" xml:space="preserve">
          <source>Finalizers &lt;em&gt;can&lt;/em&gt; be used reliably for types that are created explicitly and have identity, such as &lt;code&gt;IORef&lt;/code&gt; and &lt;code&gt;MVar&lt;/code&gt;. However, to place a finalizer on one of these types, you should use the specific operation provided for that type, e.g. &lt;code&gt;mkWeakIORef&lt;/code&gt; and &lt;code&gt;addMVarFinalizer&lt;/code&gt; respectively (the non-uniformity is accidental). These operations attach the finalizer to the primitive object inside the box (e.g. &lt;code&gt;MutVar#&lt;/code&gt; in the case of &lt;code&gt;IORef&lt;/code&gt;), because attaching the finalizer to the box itself fails when the outer box is optimised away by the compiler.</source>
          <target state="translated">终结&lt;em&gt;器&lt;/em&gt;可以可靠地用于显式创建并具有标识的类型，例如 &lt;code&gt;IORef&lt;/code&gt; 和 &lt;code&gt;MVar&lt;/code&gt; 。但是，要将终结器放置在这些类型之一上，应使用为该类型提供的特定操作，例如分别使用 &lt;code&gt;mkWeakIORef&lt;/code&gt; 和 &lt;code&gt;addMVarFinalizer&lt;/code&gt; （非均匀性是偶然的）。这些操作附终结对原始对象框（例如内部 &lt;code&gt;MutVar#&lt;/code&gt; 中的情况下 &lt;code&gt;IORef&lt;/code&gt; ），因为终结附接到所述框本身当外箱是由编译器优化掉失败。</target>
        </trans-unit>
        <trans-unit id="d549824ec075b07eaad0c57b8862f0cccdfc5850" translate="yes" xml:space="preserve">
          <source>Finally, GHC calls &lt;code&gt;tcPluginStop&lt;/code&gt; after constraint solving is finished, allowing the plugin to dispose of any resources it has allocated (e.g. terminating the SMT solver process).</source>
          <target state="translated">最后，约束约束完成后，GHC调用 &lt;code&gt;tcPluginStop&lt;/code&gt; ，从而允许插件处理已分配的任何资源（例如，终止SMT求解器过程）。</target>
        </trans-unit>
        <trans-unit id="3cd050ec35a76e1f6b5c1338ce2268aeea42675b" translate="yes" xml:space="preserve">
          <source>Finally, here's an exception safe variant of the &lt;code&gt;readFile'&lt;/code&gt; example:</source>
          <target state="translated">最后，这是 &lt;code&gt;readFile'&lt;/code&gt; 示例的异常安全变体：</target>
        </trans-unit>
        <trans-unit id="17da083d84fc49d2631cf9ff7d2f3b4b5c95891b" translate="yes" xml:space="preserve">
          <source>Finally, other functions can be called, either with the &lt;code&gt;-main-is&lt;/code&gt; flag or the &lt;a href=&quot;#ghci-cmd-:run&quot;&gt;&lt;code&gt;:run&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">最后，可以使用 &lt;code&gt;-main-is&lt;/code&gt; 标志或&lt;a href=&quot;#ghci-cmd-:run&quot;&gt; &lt;code&gt;:run&lt;/code&gt; &lt;/a&gt;命令调用其他函数：</target>
        </trans-unit>
        <trans-unit id="c467715713120e1ab32f93515b00b2a5a923fdd5" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;Just&lt;/code&gt; results are collected into a map:</source>
          <target state="translated">最后，将 &lt;code&gt;Just&lt;/code&gt; 结果收集到地图中：</target>
        </trans-unit>
        <trans-unit id="d6c8dcc229ec5ccc377436c171a4012c21910c22" translate="yes" xml:space="preserve">
          <source>Finally, the option &lt;code&gt;-hcsuf&lt;/code&gt; ⟨suffix⟩ will change the &lt;code&gt;.hc&lt;/code&gt; file suffix for compiler-generated intermediate C files.</source>
          <target state="translated">最后，选项 &lt;code&gt;-hcsuf&lt;/code&gt; &amp;ldquo;后缀&amp;rdquo;将更改编译器生成的中间C文件的 &lt;code&gt;.hc&lt;/code&gt; 文件后缀。</target>
        </trans-unit>
        <trans-unit id="fc21bc943ef04af59cbece2a0d2f3e7aa3c249b5" translate="yes" xml:space="preserve">
          <source>Finally, we can continue the current execution:</source>
          <target state="translated">最后,我们可以继续当前的执行。</target>
        </trans-unit>
        <trans-unit id="824e9c7851504a7db73de275ca7092aca8efe89b" translate="yes" xml:space="preserve">
          <source>Finally, we need a primitive parser that matches a single character, from which arbitrarily complex parsers may be constructed:</source>
          <target state="translated">最后,我们需要一个匹配单个字符的原始解析器,从中可以构造任意复杂的解析器。</target>
        </trans-unit>
        <trans-unit id="15a842f146978f80ebeda74728fb6bdd46209f69" translate="yes" xml:space="preserve">
          <source>Finally, we run the decoder:</source>
          <target state="translated">最后,我们运行解码器。</target>
        </trans-unit>
        <trans-unit id="58b7317f6459da4bc2d4c53f36913a47893253c7" translate="yes" xml:space="preserve">
          <source>Find all instances \(I\) that &lt;em&gt;match&lt;/em&gt; the target constraint; that is, the target constraint is a substitution instance of \(I\). These instance declarations are the &lt;em&gt;candidates&lt;/em&gt;.</source>
          <target state="translated">查找&lt;em&gt;与&lt;/em&gt;目标约束&lt;em&gt;匹配&lt;/em&gt;的所有实例\（I \）；也就是说，目标约束是\（I \）的替换实例。这些实例声明是&lt;em&gt;候选对象&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="a7248c9b5f73c1345281963f4418269f1f39c210" translate="yes" xml:space="preserve">
          <source>Find all the unsolved constraints. Then:</source>
          <target state="translated">找出所有未解决的约束条件。然后</target>
        </trans-unit>
        <trans-unit id="2ba0bc35b28ca786d80a16baa1ce7be74e4b397c" translate="yes" xml:space="preserve">
          <source>Find depth of the tree; i.e. the number of branches from the root of the tree to the furthest leaf:</source>
          <target state="translated">找出树的深度;即从树根到最远的叶子的枝数。</target>
        </trans-unit>
        <trans-unit id="f29c9313754b1cc2ec832d12ee7fe9edac95906b" translate="yes" xml:space="preserve">
          <source>Find system-specific limits for a file</source>
          <target state="translated">查找系统对文件的限制</target>
        </trans-unit>
        <trans-unit id="386219c63f990092e910133ace2da72816782f7e" translate="yes" xml:space="preserve">
          <source>Find the indexes of all (possibly overlapping) occurences of a substring in a string.</source>
          <target state="translated">查找字符串中所有(可能重叠的)子串的索引。</target>
        </trans-unit>
        <trans-unit id="d2e1b44278f49d501705a64e05bbba0c134de2fb" translate="yes" xml:space="preserve">
          <source>Find the maximum value in the tree:</source>
          <target state="translated">找出树中的最大值。</target>
        </trans-unit>
        <trans-unit id="d1f6a92389a4b52704904fd8094536f941eee60f" translate="yes" xml:space="preserve">
          <source>Find those that are of form &lt;code&gt;(C a)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable, and partition those constraints into groups that share a common type variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">查找形式为 &lt;code&gt;(C a)&lt;/code&gt; 的约束，其中 &lt;code&gt;a&lt;/code&gt; 是类型变量，然后将这些约束划分为共享公共类型变量 &lt;code&gt;a&lt;/code&gt; 的组。</target>
        </trans-unit>
        <trans-unit id="f82c18b0ef12da1e73963f388a45c81ada40f595" translate="yes" xml:space="preserve">
          <source>FindData</source>
          <target state="translated">FindData</target>
        </trans-unit>
        <trans-unit id="9cebb52c73ccfc1577160b27a264b7adee7d64e0" translate="yes" xml:space="preserve">
          <source>Finding the length</source>
          <target state="translated">寻找长度</target>
        </trans-unit>
        <trans-unit id="fed4c9053d8c85c9d95957c6e01431c7805f793d" translate="yes" xml:space="preserve">
          <source>Fingerprint</source>
          <target state="translated">Fingerprint</target>
        </trans-unit>
        <trans-unit id="3e9225380b48c0d61062495100edfad871bc3253" translate="yes" xml:space="preserve">
          <source>Finish and clean up the line-oriented user interaction session. Blocks on an existing call to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">完成并清理面向行的用户交互会话。阻止对 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 的现有调用。</target>
        </trans-unit>
        <trans-unit id="fec3922ffd4b25efcef1a899d1768f35b7868ec0" translate="yes" xml:space="preserve">
          <source>Finite Graphs</source>
          <target state="translated">有限图形</target>
        </trans-unit>
        <trans-unit id="522d06d1d6ea9ca0805eab7331127be7478e7382" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (lazy interface)</source>
          <target state="translated">有限英特图(懒惰接口)</target>
        </trans-unit>
        <trans-unit id="747317a4e3d40d7a20e3837df1cd88296c1c8b01" translate="yes" xml:space="preserve">
          <source>Finite Int Maps (strict interface)</source>
          <target state="translated">有限英特图(严格接口)</target>
        </trans-unit>
        <trans-unit id="4d744986315c5e9c1268a1c78b68b2bbeb84e7e9" translate="yes" xml:space="preserve">
          <source>Finite Int Sets</source>
          <target state="translated">有限集</target>
        </trans-unit>
        <trans-unit id="29c95a33910ced5bead65681b4bd0706727df804" translate="yes" xml:space="preserve">
          <source>Finite Maps (lazy interface)</source>
          <target state="translated">有限地图(懒惰界面</target>
        </trans-unit>
        <trans-unit id="f94c42dd95ea5ef128c8b03aa31efa72d11ac882" translate="yes" xml:space="preserve">
          <source>Finite Maps (strict interface)</source>
          <target state="translated">有限地图(严格接口)</target>
        </trans-unit>
        <trans-unit id="215000a5770bdb612d30ff0a9cffc3c9f4c807d0" translate="yes" xml:space="preserve">
          <source>Finite Sets</source>
          <target state="translated">有限集</target>
        </trans-unit>
        <trans-unit id="5e413d7374fdcec7f72bf32287ef8fde5eb28ea8" translate="yes" xml:space="preserve">
          <source>Finite sequences</source>
          <target state="translated">有限序列</target>
        </trans-unit>
        <trans-unit id="90b6286ad1ab4887e55ec1d1c65eee759a111435" translate="yes" xml:space="preserve">
          <source>FiniteBits</source>
          <target state="translated">FiniteBits</target>
        </trans-unit>
        <trans-unit id="916a78d701ded328cd66da58a97ef8cd28a99e84" translate="yes" xml:space="preserve">
          <source>First</source>
          <target state="translated">First</target>
        </trans-unit>
        <trans-unit id="6f8344a8752e429a8925c432e27736350eeb7113" translate="yes" xml:space="preserve">
          <source>First arg is whether to chop off trailing zeros</source>
          <target state="translated">首先争论的是是否要砍掉尾部的0</target>
        </trans-unit>
        <trans-unit id="b8249d53487d925c0152bda624de2b210dac99de" translate="yes" xml:space="preserve">
          <source>First component of result is &lt;code&gt;log2 n&lt;/code&gt;, second is &lt;code&gt;0#&lt;/code&gt; iff &lt;em&gt;n&lt;/em&gt; is a power of two.</source>
          <target state="translated">结果的第一部分是 &lt;code&gt;log2 n&lt;/code&gt; ，第二部分是 &lt;code&gt;0#&lt;/code&gt; ,如果&lt;em&gt;n&lt;/em&gt;是2的幂。</target>
        </trans-unit>
        <trans-unit id="a9cad0415018d8c69517c0334ce25bcce363662a" translate="yes" xml:space="preserve">
          <source>First offset in destination &lt;em&gt;not&lt;/em&gt; to copy (i.e. &lt;em&gt;not&lt;/em&gt; length)</source>
          <target state="translated">目标中的第一个偏移量&lt;em&gt;不&lt;/em&gt;复制（即&lt;em&gt;不&lt;/em&gt;长度）</target>
        </trans-unit>
        <trans-unit id="39654ea89be5465e22c967a1c060f3374651a48d" translate="yes" xml:space="preserve">
          <source>First see if there is a given un-quantified constraint &lt;code&gt;C t&lt;/code&gt;. If so, use it to solve the constraint.</source>
          <target state="translated">首先查看是否存在给定的未量化约束 &lt;code&gt;C t&lt;/code&gt; 。如果是这样，使用它来解决约束。</target>
        </trans-unit>
        <trans-unit id="8529e6d22ea6c668f307a8a09698c6b3be2a8a1c" translate="yes" xml:space="preserve">
          <source>First, &lt;code&gt;M&lt;/code&gt; imports &lt;code&gt;System.IO.Unsafe&lt;/code&gt;. This is an unsafe module, however &lt;code&gt;M&lt;/code&gt; was compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; , so &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author takes responsibility for that import. &lt;code&gt;C&lt;/code&gt; trusts &lt;code&gt;P&lt;/code&gt;&amp;lsquo;s author, so this import is fine.</source>
          <target state="translated">首先， &lt;code&gt;M&lt;/code&gt; 导入 &lt;code&gt;System.IO.Unsafe&lt;/code&gt; 。这是一个不安全的模块，但是 &lt;code&gt;M&lt;/code&gt; 是使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译的，因此 &lt;code&gt;P&lt;/code&gt; 的作者负责该导入。 &lt;code&gt;C&lt;/code&gt; 信任 &lt;code&gt;P&lt;/code&gt; 的作者，因此可以导入。</target>
        </trans-unit>
        <trans-unit id="5b49ba602a9142b1d175089fed4f6f1f4747d3e6" translate="yes" xml:space="preserve">
          <source>First, load the module into GHCi:</source>
          <target state="translated">首先,将模块加载到GHCi中。</target>
        </trans-unit>
        <trans-unit id="a26ce7d1c9ec3e2375b176ca79a824e47e99e926" translate="yes" xml:space="preserve">
          <source>First, look up an exact match on the name from the defined macros.</source>
          <target state="translated">首先,从定义的宏中查找名称上的精确匹配。</target>
        </trans-unit>
        <trans-unit id="72664d951135405f560298e2723cacf7238281f9" translate="yes" xml:space="preserve">
          <source>Firstly, they enable terminating resolution where this was not possible before. Consider for instance the following instance declaration for the general rose datatype</source>
          <target state="translated">首先,它们使终止解析成为可能,而这在以前是不可能的。例如,考虑以下一般玫瑰数据类型的实例声明</target>
        </trans-unit>
        <trans-unit id="b6ac73901d489c6617642d5ff6f615191248b174" translate="yes" xml:space="preserve">
          <source>FixIOException</source>
          <target state="translated">FixIOException</target>
        </trans-unit>
        <trans-unit id="ab98f5b85764b8561cacbb055a963cd334928cba" translate="yes" xml:space="preserve">
          <source>Fixed</source>
          <target state="translated">Fixed</target>
        </trans-unit>
        <trans-unit id="a9ea98de04db18cc178f8c2aef76ded13d01953b" translate="yes" xml:space="preserve">
          <source>Fixed-size builder primitives</source>
          <target state="translated">固定尺寸的构建器基元</target>
        </trans-unit>
        <trans-unit id="183fb4772d6165cb8789b4e327df15e3ac4d66f2" translate="yes" xml:space="preserve">
          <source>Fixed-size primitives</source>
          <target state="translated">固定尺寸基元</target>
        </trans-unit>
        <trans-unit id="7fb4ae59c760325c298601ab13e509f25fc37166" translate="yes" xml:space="preserve">
          <source>Fixed-width hexadecimal numbers</source>
          <target state="translated">固定宽度的十六进制数</target>
        </trans-unit>
        <trans-unit id="9b5b062b987d276248796f56a62721479458d294" translate="yes" xml:space="preserve">
          <source>FixedPrim</source>
          <target state="translated">FixedPrim</target>
        </trans-unit>
        <trans-unit id="094a567c1926190b7bfd7c0b37606606648002d4" translate="yes" xml:space="preserve">
          <source>Fixities may be declared for type constructors, or classes, just as for data constructors. However, one cannot distinguish between the two in a fixity declaration; a fixity declaration sets the fixity for a data constructor and the corresponding type constructor. For example:</source>
          <target state="translated">可以为类型构造函数声明固定性,也可以为类声明固定性,就像为数据构造函数声明固定性一样。但是,在固定性声明中不能区分两者,固定性声明为数据构造函数和对应的类型构造函数设置了固定性。例如</target>
        </trans-unit>
        <trans-unit id="2b82bbf7b0c566bd4539bf8810f46c5179f626f4" translate="yes" xml:space="preserve">
          <source>Fixity</source>
          <target state="translated">Fixity</target>
        </trans-unit>
        <trans-unit id="57d494452eec64b65e5dc39ee592c4fe9616d8e2" translate="yes" xml:space="preserve">
          <source>Fixity declarations are exactly as in Haskell.</source>
          <target state="translated">固定性声明与Haskell中完全一样。</target>
        </trans-unit>
        <trans-unit id="eb3a8c37524386d27f7d07ee18bd0c65f631fe49" translate="yes" xml:space="preserve">
          <source>Fixity lookup</source>
          <target state="translated">固定性查询</target>
        </trans-unit>
        <trans-unit id="ff8a94000f86e8a577cd0b25a42fc9985d6fd243" translate="yes" xml:space="preserve">
          <source>Fixity of constructors</source>
          <target state="translated">构造者的固定性</target>
        </trans-unit>
        <trans-unit id="3b3ce8c52db6806c8b912790bee2abcfa0095fad" translate="yes" xml:space="preserve">
          <source>Fixity, type synonym, open type/data family declarations are permitted as in normal Haskell.</source>
          <target state="translated">固定性、类型同义词、开放的类型/数据族声明与普通Haskell一样是允许的。</target>
        </trans-unit>
        <trans-unit id="88b3259b4db22b3078551b6bfb8b24795404727c" translate="yes" xml:space="preserve">
          <source>FixityDirection</source>
          <target state="translated">FixityDirection</target>
        </trans-unit>
        <trans-unit id="ce8b7e3c9475365f4009091caff86162598e45a6" translate="yes" xml:space="preserve">
          <source>FixityI</source>
          <target state="translated">FixityI</target>
        </trans-unit>
        <trans-unit id="a774409a00c21de377cf8ed5c6a56b8547973042" translate="yes" xml:space="preserve">
          <source>Flag</source>
          <target state="translated">Flag</target>
        </trans-unit>
        <trans-unit id="97377a994fd4b8ac108223fa55cd48065f0287d8" translate="yes" xml:space="preserve">
          <source>Flag saying &amp;ldquo;stop after&amp;rdquo;</source>
          <target state="translated">标记为&amp;ldquo;之后停止&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c79a88ff731c8edaa92ba0e1a888148cff60ea92" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlopen&quot;&gt;dlopen&lt;/a&gt;&lt;/code&gt; 的标志。</target>
        </trans-unit>
        <trans-unit id="aea2c8ec1977d6e31bcb021cb1dabebaa2c6f4b8" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68646c4bfdfb2b77627104cc76a37fdf802fe2ab" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43b5985213e56988275f428db4afd1aca092b76c" translate="yes" xml:space="preserve">
          <source>Flags for &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt;. Notice that &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; might not be available on your particular platform! Use &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker#v:dlsym&quot;&gt;dlsym&lt;/a&gt;&lt;/code&gt; 的标志。请注意， &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Next&quot;&gt;Next&lt;/a&gt;&lt;/code&gt; 可能在您的特定平台上不可用！使用 &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:haveRtldNext&quot;&gt;haveRtldNext&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6604408a39b5823a2d8caf9d995d09a15ce36fdd" translate="yes" xml:space="preserve">
          <source>Flags to control debugging output &amp;amp; extra checking in various subsystems.</source>
          <target state="translated">在各个子系统中控制调试输出和额外检查的标志。</target>
        </trans-unit>
        <trans-unit id="953fe397d4a88b2eb7a202d8c11d1d4f2b2605c7" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields</source>
          <target state="translated">扁平化严格的构造函数字段</target>
        </trans-unit>
        <trans-unit id="32ce3a4131c78ef5b3006aaff0098352e801ebfd" translate="yes" xml:space="preserve">
          <source>Flatten strict constructor fields with a pointer-sized representation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用指针大小的表示形式展平严格的构造函数字段。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="50dc207a02ef3d6c64feba0eb22a156d325327b3" translate="yes" xml:space="preserve">
          <source>FlexibleContexts</source>
          <target state="translated">FlexibleContexts</target>
        </trans-unit>
        <trans-unit id="dcec06754c91ecfff545b2f2cce80146b795726a" translate="yes" xml:space="preserve">
          <source>FlexibleInstances</source>
          <target state="translated">FlexibleInstances</target>
        </trans-unit>
        <trans-unit id="5f4b18a46cb894bc45a39a5999838fa58714fd24" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt;&lt;/code&gt; 的翻转版本。</target>
        </trans-unit>
        <trans-unit id="fb11700d163e40830d0bae242266c3294e9edd3a" translate="yes" xml:space="preserve">
          <source>Flipped version of &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 的翻转版本。</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="11c392eaf9a273578cddca36e05784e7ec0207b3" translate="yes" xml:space="preserve">
          <source>Float let-bindings inwards, nearer their binding site. See &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;Let-floating: moving bindings to give faster programs (ICFP&amp;lsquo;96)&lt;/a&gt;.</source>
          <target state="translated">向内浮动让装订，使其装订位置更近。请参阅&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz&quot;&gt;浮动：移动绑定以提供更快的程序（ICFP'96）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a99a789a6440d2e0783c52c14f1b895aa85ee6da" translate="yes" xml:space="preserve">
          <source>Float methods</source>
          <target state="translated">浮动方法</target>
        </trans-unit>
        <trans-unit id="03c6a3d4a620ad6a95690d9257e6602cfa12ec6b" translate="yes" xml:space="preserve">
          <source>Float#</source>
          <target state="translated">Float#</target>
        </trans-unit>
        <trans-unit id="e84ef7c494482d98641252e0399d1dd94c8bfe32" translate="yes" xml:space="preserve">
          <source>Float/Int conversions, wrapped primops</source>
          <target state="translated">浮点数/整数转换,封装的primops。</target>
        </trans-unit>
        <trans-unit id="471bcd60035338d11d9230973a397e8b65fdb767" translate="yes" xml:space="preserve">
          <source>FloatElemRep</source>
          <target state="translated">FloatElemRep</target>
        </trans-unit>
        <trans-unit id="89b3a61017b0b9614ae8ccc16d0818a913c0e924" translate="yes" xml:space="preserve">
          <source>FloatRep</source>
          <target state="translated">FloatRep</target>
        </trans-unit>
        <trans-unit id="a653d15a4777ec0f86a07afd7ce540d8514fe97b" translate="yes" xml:space="preserve">
          <source>FloatX16#</source>
          <target state="translated">FloatX16#</target>
        </trans-unit>
        <trans-unit id="11e6eacae4a18d2e4bd76e48d4a57fa313675caf" translate="yes" xml:space="preserve">
          <source>FloatX4#</source>
          <target state="translated">FloatX4#</target>
        </trans-unit>
        <trans-unit id="29c459076fc63798f4132325e3f3f308a1e5b6f4" translate="yes" xml:space="preserve">
          <source>FloatX8#</source>
          <target state="translated">FloatX8#</target>
        </trans-unit>
        <trans-unit id="ab224b51965363d31db26ddc6738fa145bb46562" translate="yes" xml:space="preserve">
          <source>Floating</source>
          <target state="translated">Floating</target>
        </trans-unit>
        <trans-unit id="26f84222b978702da534998cccf7e093da992898" translate="yes" xml:space="preserve">
          <source>Floating types</source>
          <target state="translated">浮动类型</target>
        </trans-unit>
        <trans-unit id="450e2ff7d08682a58ebee70fca61dbfb6a6e7063" translate="yes" xml:space="preserve">
          <source>FlowAction</source>
          <target state="translated">FlowAction</target>
        </trans-unit>
        <trans-unit id="6e5ef5487191e4dd22398274011cf12de9a91e94" translate="yes" xml:space="preserve">
          <source>Flush all the data from the supplied write buffer out to the device. The returned buffer should be empty, and ready for writing.</source>
          <target state="translated">将提供的写缓冲区中的所有数据冲出设备。返回的缓冲区应该是空的,并且可以写。</target>
        </trans-unit>
        <trans-unit id="bf6064155984dcdefe2820b834eb03fc5450e184" translate="yes" xml:space="preserve">
          <source>Flush buffers (if any) of your custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;. This can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">刷新自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 的&lt;/a&gt;缓冲区（如果有）。这可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="358b7b4736340628089a578a4f127145e9f86637" translate="yes" xml:space="preserve">
          <source>Flush data from the supplied write buffer out to the device without blocking. Returns the number of bytes written and the remaining buffer.</source>
          <target state="translated">从所提供的写入缓冲区中无阻挡地冲出数据到设备。返回写入的字节数和剩余的缓冲区。</target>
        </trans-unit>
        <trans-unit id="cd61c8c15dd02466359a4d4a7b35cb820213dbe9" translate="yes" xml:space="preserve">
          <source>Flush the current buffer. This introduces a chunk boundary.</source>
          <target state="translated">刷新当前缓冲区。这将引入一个分块边界。</target>
        </trans-unit>
        <trans-unit id="8f2757271a40ce096379108294905c1babb07ac2" translate="yes" xml:space="preserve">
          <source>Flushing the buffer state</source>
          <target state="translated">冲洗缓冲区状态</target>
        </trans-unit>
        <trans-unit id="245ac1ca610984dee51983b1a19924096b479a7d" translate="yes" xml:space="preserve">
          <source>Flushing the implicit parse state</source>
          <target state="translated">冲洗隐式解析状态</target>
        </trans-unit>
        <trans-unit id="2374f7905efdc0f4f714c25a7472902042311cdf" translate="yes" xml:space="preserve">
          <source>Fold a list using the monoid.</source>
          <target state="translated">使用单体折叠一个列表。</target>
        </trans-unit>
        <trans-unit id="0a7cc99c934753ce6e6950e7c43626ab6fa6d2f5" translate="yes" xml:space="preserve">
          <source>Fold a tree into a &quot;summary&quot; value in depth-first order.</source>
          <target state="translated">将一棵树按深度优先的顺序折成一个 &quot;摘要 &quot;值。</target>
        </trans-unit>
        <trans-unit id="f67973842ff2d508f50cd5451a0e67d4a63ae01e" translate="yes" xml:space="preserve">
          <source>Fold an &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; case-wise, just like &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">明智地折叠 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; ，就像 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="5f671e4bd34a867cbf0e6b25023adc640a86e3db" translate="yes" xml:space="preserve">
          <source>Fold from right to left.</source>
          <target state="translated">从右往左折。</target>
        </trans-unit>
        <trans-unit id="8b610be124aa3a40ce1b39d37fc11b0b04c6263e" translate="yes" xml:space="preserve">
          <source>Foldable</source>
          <target state="translated">Foldable</target>
        </trans-unit>
        <trans-unit id="6b84829350dde1e376868f53c48ad67c4112eee6" translate="yes" xml:space="preserve">
          <source>Folding actions</source>
          <target state="translated">折叠动作</target>
        </trans-unit>
        <trans-unit id="2d8b815138c38106cf926a1dd7d970d8c84885c4" translate="yes" xml:space="preserve">
          <source>Folds</source>
          <target state="translated">Folds</target>
        </trans-unit>
        <trans-unit id="c88897f7a995c31a2d98d1a61bd0b6af136abc63" translate="yes" xml:space="preserve">
          <source>Folds and traversals</source>
          <target state="translated">褶皱和横移</target>
        </trans-unit>
        <trans-unit id="2186e55af17afc5fa2144b8775a49f1290a3d33b" translate="yes" xml:space="preserve">
          <source>Folds in order of increasing key.</source>
          <target state="translated">按增加键的顺序折叠。</target>
        </trans-unit>
        <trans-unit id="d57295c01bef2c30b4729669a29577172c281ea3" translate="yes" xml:space="preserve">
          <source>Following a suggestion of Mark Jones, in his paper &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;Typing Haskell in Haskell&lt;/a&gt;, GHC implements a more general scheme. In GHC &lt;em&gt;the dependency analysis ignores references to variables that have an explicit type signature&lt;/em&gt;. As a result of this refined dependency analysis, the dependency groups are smaller, and more bindings will typecheck. For example, consider:</source>
          <target state="translated">在Mark Jones的建议下，GHC &lt;a href=&quot;https://web.cecs.pdx.edu/~mpj/thih/&quot;&gt;在Haskell的Typing Haskell&lt;/a&gt;论文中提出了一个更通用的方案。在GHC中&lt;em&gt;，依赖性分析会忽略对具有显式类型签名的变量的引用&lt;/em&gt;。精致的依赖关系分析的结果是，依赖项组更小，并且更多的绑定将进行类型检查。例如，考虑：</target>
        </trans-unit>
        <trans-unit id="5cb7231f65ffda9aaf11e030c71a231be4c4e62b" translate="yes" xml:space="preserve">
          <source>Following the ISO-10646 standard, &lt;code&gt;maxBound :: Char&lt;/code&gt; in GHC is &lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="translated">遵循ISO-10646标准，GHC中的 &lt;code&gt;maxBound :: Char&lt;/code&gt; 为 &lt;code&gt;0x10FFFF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="683450681a094431fa846533675f44d1e8b059fa" translate="yes" xml:space="preserve">
          <source>Follows the recommendations in &lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&lt;/a&gt;</source>
          <target state="translated">遵循&lt;a href=&quot;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html&quot;&gt;http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html中&lt;/a&gt;的建议</target>
        </trans-unit>
        <trans-unit id="7e8a1a6a78e6e0c64059181cdc137c3f13446688" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; and &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt;, compute their greatest common divisor &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; and the coefficient &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; satisfying &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;em&gt;b&lt;/em&gt;&lt;/code&gt; ，计算它们的最大公约数 &lt;code&gt;&lt;em&gt;g&lt;/em&gt;&lt;/code&gt; 和满足 &lt;code&gt;&lt;em&gt;a&lt;/em&gt;&lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b&lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;&lt;/code&gt; &lt;em&gt;s&lt;/em&gt; + &lt;em&gt;b &lt;/em&gt;&lt;em&gt;t&lt;/em&gt; = &lt;em&gt;g&lt;/em&gt;的系数 &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="438754bee88837ce49606e1c3c4cb154a8fdc138" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffDays&lt;/code&gt; (and &lt;code&gt;CalendarDiffTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;CalendarDiffDays&lt;/code&gt; （和 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="38c17a34f43461761882cc425a0ecd3ab0e949ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;CalendarDiffTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;CalendarDiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c0143b791c012f113a8232c3ab197fb3753fd36" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Day&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;Day&lt;/code&gt; （与 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="20a7a91f2f957f2a10870727acfcfa4a35d3973b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DayOfWeek&lt;/code&gt; (and &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;DayOfWeek&lt;/code&gt; （和 &lt;code&gt;Day&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="72a84ee2f0f4c4168eef092af153fed065cacbf6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;LocalTime&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;LocalTime&lt;/code&gt; （和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="43312a6d64a5882430cc27d6c5bcaff6112fd683" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;NominalDiffTime&lt;/code&gt; and &lt;code&gt;DiffTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;NominalDiffTime&lt;/code&gt; 和 &lt;code&gt;DiffTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="58ae54bfb7d2d0244bc285d96a987c748a014820" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeOfDay&lt;/code&gt; (and &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;UniversalTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;TimeOfDay&lt;/code&gt; （和 &lt;code&gt;LocalTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;UniversalTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="de676cebc1b71a848f33653aed6cf2c30d41ec6c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;TimeZone&lt;/code&gt; (and &lt;code&gt;ZonedTime&lt;/code&gt; and &lt;code&gt;UTCTime&lt;/code&gt;):</source>
          <target state="translated">对于 &lt;code&gt;TimeZone&lt;/code&gt; （以及 &lt;code&gt;ZonedTime&lt;/code&gt; 和 &lt;code&gt;UTCTime&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="780610a5f5cec081a6e5e8e4fd872022d4b9ccd3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;ZonedTime&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;UTCTime&lt;/code&gt; 和 &lt;code&gt;ZonedTime&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="41f6ee1958af63054f1e2c3d4dd9c1a48d13ac68" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; and &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;base &amp;gt;= 4.8.0&lt;/code&gt; 和 &lt;code&gt;containers &amp;gt;= 0.5.11&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateM&quot;&gt;replicateM&lt;/a&gt;&lt;/code&gt; 为同义词 &lt;code&gt;&lt;a href=&quot;data-sequence#v:replicateA&quot;&gt;replicateA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc47e5122f21703f2a3de45263a7aaf0eac1316f" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于POSIX用户，这等效于 &lt;code&gt;&lt;a href=&quot;../unix-2.7.2.2/system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c17acddc624fd77e3cb189ccd12fd6ee29107023" translate="yes" xml:space="preserve">
          <source>For POSIX users, this is equivalent to &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于POSIX用户，这等效于 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:getEnv&quot;&gt;getEnv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12834118955436c30a4e545201bc91502d57a5e3" translate="yes" xml:space="preserve">
          <source>For a bidirectional pattern synonym, a use of the pattern synonym as an expression has the type</source>
          <target state="translated">对于双向模式同义词,模式同义词作为表达式的使用具有以下类型</target>
        </trans-unit>
        <trans-unit id="68e1aba695e3ce91a31fd34537a2f0dd4c81abe3" translate="yes" xml:space="preserve">
          <source>For a class, every type variable must be annotated with a kind.</source>
          <target state="translated">对于一个类来说,每个类型变量都必须注解一个种类。</target>
        </trans-unit>
        <trans-unit id="8fe53f9ccf4406924e6b6d736fa635a1f07be35e" translate="yes" xml:space="preserve">
          <source>For a complex number &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; is a number with the magnitude of &lt;code&gt;z&lt;/code&gt;, but oriented in the positive real direction, whereas &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; has the phase of &lt;code&gt;z&lt;/code&gt;, but unit magnitude.</source>
          <target state="translated">对于一个复数 &lt;code&gt;z&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:abs&quot;&gt;abs&lt;/a&gt; z&lt;/code&gt; 与的大小的数 &lt;code&gt;z&lt;/code&gt; ，但在正实方向取向，而 &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt; z&lt;/code&gt; 具有的相位 &lt;code&gt;z&lt;/code&gt; ，但单位幅度。</target>
        </trans-unit>
        <trans-unit id="381187e4f3ff0b6bc5d10ac5d2f67f7b97f7590a" translate="yes" xml:space="preserve">
          <source>For a datatype with a top-level &lt;code&gt;::&lt;/code&gt;: all kind variables introduced after the &lt;code&gt;::&lt;/code&gt; must be explicitly quantified.</source>
          <target state="translated">对于顶级数据类型 &lt;code&gt;::&lt;/code&gt; ：后引入的所有类型的变量 &lt;code&gt;::&lt;/code&gt; 必须明确量化。</target>
        </trans-unit>
        <trans-unit id="ee774f603ab065899ff7fb5a9bcaeae920fd5a55" translate="yes" xml:space="preserve">
          <source>For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level &lt;code&gt;::&lt;/code&gt; in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</source>
          <target state="translated">对于数据类型，每个类型变量都必须带有一种类型。在GADT式的声明，也可能是一种签名（与顶级 &lt;code&gt;::&lt;/code&gt; 在头），但这个注释的存在与否并不影响申报是否有完整的签名。</target>
        </trans-unit>
        <trans-unit id="7c12c8fb4a7f215c82a05683a5710f3a85d7f1fd" translate="yes" xml:space="preserve">
          <source>For a detailed discussion, see Levent Erkok's thesis, &lt;em&gt;Value Recursion in Monadic Computations&lt;/em&gt;, Oregon Graduate Institute, 2002.</source>
          <target state="translated">有关详细讨论，请参阅Levent Erkok的论文，&amp;ldquo; &lt;em&gt;单子计算中的值递归&amp;rdquo;&lt;/em&gt;，俄勒冈大学研究生院，2002年。</target>
        </trans-unit>
        <trans-unit id="ff2aa12fcb0881466720f2e80b4f0d096c83a123" translate="yes" xml:space="preserve">
          <source>For a full specification of the algorithms used in &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;this wiki page&lt;/a&gt;.</source>
          <target state="translated">有关&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 中&lt;/a&gt;使用的算法的完整规范，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/Compiler/DeriveFunctor&quot;&gt;此Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f753874b80e6283217fbd2405e5d7bb6c4151408" translate="yes" xml:space="preserve">
          <source>For a fully working example, see &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; in the GHC source tree.</source>
          <target state="translated">有关完整的示例，请参阅GHC源代码树中的 &lt;code&gt;testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b02bfdafd93af69d743b0ce3c0a4317ebee1f2be" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义应与</target>
        </trans-unit>
        <trans-unit id="ce4b8eeb28d94d8e7c6254b4d94c9ba94f5eaa06" translate="yes" xml:space="preserve">
          <source>For a general &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; structure this should be semantically identical to,</source>
          <target state="translated">对于一般的 &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 结构，其语义应与</target>
        </trans-unit>
        <trans-unit id="690c81581725977a80c5ea6bb4e5ee9018b2f21a" translate="yes" xml:space="preserve">
          <source>For a given heap size (using the &lt;code&gt;-H ⟨size⟩&lt;/code&gt; option), compaction can in fact reduce the GC cost by allowing fewer GCs to be performed. This is more likely when the ratio of live data to heap size is high, say greater than 30%.</source>
          <target state="translated">对于给定的堆大小（使用 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; 选项），压缩实际上可以通过允许执行较少的GC来减少GC的成本。当活动数据与堆大小的比率较高（例如大于30％）时，这种可能性更大。</target>
        </trans-unit>
        <trans-unit id="dade435c995cd800c773d6e4aa166b67efb6ca38" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">对于附加到物理文件的句柄 &lt;code&gt;hdl&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回该文件的大小（以8位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="d3c63f5fcdc6df7421dc6b15f96e58c2cd3eb2d6" translate="yes" xml:space="preserve">
          <source>For a handle &lt;code&gt;hdl&lt;/code&gt; which attached to a physical file, &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns the size of that file in 8-bit bytes.</source>
          <target state="translated">对于附加到物理文件的句柄 &lt;code&gt;hdl&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;system-io#v:hFileSize&quot;&gt;hFileSize&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回该文件的大小（以8位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="346fb7900fc27cffc7ae7ee52aedbaed80128cb6" translate="yes" xml:space="preserve">
          <source>For a lambda-bound or case-bound variable, x, either the programmer provides an explicit polymorphic type for x, or GHC&amp;rsquo;s type inference will assume that x&amp;rsquo;s type has no foralls in it.</source>
          <target state="translated">对于x的lambda绑定变量或大小写绑定变量，程序员要么为x提供了显式的多态类型，要么GHC的类型推断将假定x的类型中没有forall。</target>
        </trans-unit>
        <trans-unit id="f6acc7fc1a003a7f2eed93e34c1d5012a4db3a7b" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关单 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldForestM_BF&quot;&gt;unfoldForestM_BF&lt;/a&gt;&lt;/code&gt; 版本，请参见unfoldForestM_BF。</target>
        </trans-unit>
        <trans-unit id="c7723435d9290343f2201698a48102c4e2963ac9" translate="yes" xml:space="preserve">
          <source>For a monadic version see &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关单 &lt;code&gt;&lt;a href=&quot;data-tree#v:unfoldTreeM_BF&quot;&gt;unfoldTreeM_BF&lt;/a&gt;&lt;/code&gt; 版本，请参见unfoldTreeM_BF。</target>
        </trans-unit>
        <trans-unit id="deb1847901cd6f8ebc084093215bfbec76990b3e" translate="yes" xml:space="preserve">
          <source>For a plain &lt;code&gt;foreign export&lt;/code&gt;, the file &lt;code&gt;M_stub.h&lt;/code&gt; contains a C prototype for the foreign exported function. For example, if we compile the following module:</source>
          <target state="translated">对于普通的 &lt;code&gt;foreign export&lt;/code&gt; ，文件 &lt;code&gt;M_stub.h&lt;/code&gt; 包含用于外部导出函数的C原型。例如，如果我们编译以下模块：</target>
        </trans-unit>
        <trans-unit id="2010d0ed548d603dcd6e8de87d973f011d76f796" translate="yes" xml:space="preserve">
          <source>For a polykinded type family, the kinds are checked for apartness just like types. For example, the following is accepted:</source>
          <target state="translated">对于一个多义类型族,种类会像类型一样被检查是否存在差异性。例如,以下是可以接受的。</target>
        </trans-unit>
        <trans-unit id="1ec55d48cfc12f5eb55df6ee4c9fc9967d025743" translate="yes" xml:space="preserve">
          <source>For a read-only state, see &lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;.</source>
          <target state="translated">有关只读状态，请参见&lt;a href=&quot;control-monad-trans-reader&quot;&gt;Control.Monad.Trans.Reader&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89e5871716007219289211d50f9f31d07f96bebe" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于可读句柄 &lt;code&gt;hdl&lt;/code&gt; ，如果当前I / O位置等于文件的长度，则如果无法从 &lt;code&gt;hdl&lt;/code&gt; 或物理文件中获取更多输入，则 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2287783eee0e5de776e32c05f70808452f33fbd" translate="yes" xml:space="preserve">
          <source>For a readable handle &lt;code&gt;hdl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if no further input can be taken from &lt;code&gt;hdl&lt;/code&gt; or for a physical file, if the current I/O position is equal to the length of the file. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于可读句柄 &lt;code&gt;hdl&lt;/code&gt; ，如果当前I / O位置等于文件的长度，则如果无法从 &lt;code&gt;hdl&lt;/code&gt; 或物理文件中获取更多输入，则 &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adff34a3466fde4a9da78cc13745c730ac48fbdb" translate="yes" xml:space="preserve">
          <source>For a strict version with the same interface, see &lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;.</source>
          <target state="translated">有关具有相同接口的严格版本，请参见&lt;a href=&quot;control-monad-trans-state-strict&quot;&gt;Control.Monad.Trans.State.Strict&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7841e1d83167e58d01ed6bbf031eb35a3b28a384" translate="yes" xml:space="preserve">
          <source>For a type synonym, every type variable and the result type must all be annotated with kinds:</source>
          <target state="translated">对于一个类型同义词,每个类型变量和结果类型都必须用种类来注释。</target>
        </trans-unit>
        <trans-unit id="8a7dabb4a59eac239d73f8d88adf219f4a141e0a" translate="yes" xml:space="preserve">
          <source>For a unidirectional record pattern synonym we define record selectors but do not allow record updates or construction.</source>
          <target state="translated">对于单向的记录模式同义词,我们定义了记录选择器,但不允许记录更新或构造。</target>
        </trans-unit>
        <trans-unit id="ea4172896e3aa016d0abf8c8c8b0c573b135be3c" translate="yes" xml:space="preserve">
          <source>For a variant allowing a range of exception values, see &lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;.</source>
          <target state="translated">有关允许一定范围的异常值的变体，请参见&lt;a href=&quot;control-monad-trans-except&quot;&gt;Control.Monad.Trans.Except&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="348fe1968c9295273d516331a948a6159bdca8cf" translate="yes" xml:space="preserve">
          <source>For a version that ignores the results, see &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关忽略结果的版本，请参见 &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bitraverse_&quot;&gt;bitraverse_&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd461bef656027f3a267dac7f770cf766ddc2c2e" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;maps introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参阅&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/map.html&quot;&gt;地图介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="93f1a6621ab377cb23e0289b270fa1e8b0fea36d" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see the &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参见&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;集合介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d40c81c0c5fac25219b486dd4532b6661cea779f" translate="yes" xml:space="preserve">
          <source>For a walkthrough of the most commonly used functions see their &lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;sets introduction&lt;/a&gt;.</source>
          <target state="translated">有关最常用功能的演练，请参见其&lt;a href=&quot;https://haskell-containers.readthedocs.io/en/latest/set.html&quot;&gt;集合介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b41a37cf99caafb018a9e5b3dc8989fdb6d5ec4" translate="yes" xml:space="preserve">
          <source>For all types (note these three are done by &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;, not by &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">对于所有类型（请注意，这三个是由 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;data-time-format-internal#v:formatCharacter&quot;&gt;formatCharacter&lt;/a&gt;&lt;/code&gt; 完成的）：</target>
        </trans-unit>
        <trans-unit id="5679f68c9f6e5d539aa213e495939714c629e80c" translate="yes" xml:space="preserve">
          <source>For almost all sensible programs this will indicate a bug, and you probably intended to write:</source>
          <target state="translated">对于几乎所有明智的程序来说,这将表明一个错误,你可能打算写。</target>
        </trans-unit>
        <trans-unit id="63a574ff5f92276a16df15dd4fc8478ad9638408" translate="yes" xml:space="preserve">
          <source>For an &amp;ldquo;unpackable&amp;rdquo; &lt;code&gt;U(...)&lt;/code&gt; argument, the info inside tells the strictness of its components. So, if the argument is a pair, and it says &lt;code&gt;U(AU(LSS))&lt;/code&gt;, that means &amp;ldquo;the first component of the pair isn&amp;rsquo;t used; the second component is itself unpackable, with three components (lazy in the first, strict in the second \&amp;amp; third).&amp;rdquo;</source>
          <target state="translated">对于&amp;ldquo;无法打包&amp;rdquo;的 &lt;code&gt;U(...)&lt;/code&gt; 参数，内部的信息说明其组件的严格性。因此，如果参数是一对，并且说 &lt;code&gt;U(AU(LSS))&lt;/code&gt; ，则意味着&amp;ldquo;未使用该对的第一个组件；第二个组件本身是不可拆包的，包含三个组件（第一个组件是惰性的，第二个和第二个是严格的）。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="61b4aadcc9e022579cc277ee1163fd8f6a08abf6" translate="yes" xml:space="preserve">
          <source>For an &lt;em&gt;efficient implementation of an encoding&lt;/em&gt;, it is important that (a) little time is spent on converting the Haskell values to the resulting sequence of bytes &lt;em&gt;and&lt;/em&gt; (b) that the representation of the resulting sequence is such that it can be consumed efficiently. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s support (a) by providing an O(1) concatentation operation and efficient implementations of basic encodings for &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s, and other standard Haskell values. They support (b) by providing their result as a lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, which is internally just a linked list of pointers to &lt;em&gt;chunks&lt;/em&gt; of consecutive raw memory. Lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s can be efficiently consumed by functions that write them to a file or send them over a network socket. Note that each chunk boundary incurs expensive extra work (e.g., a system call) that must be amortized over the work spent on consuming the chunk body. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s therefore take special care to ensure that the average chunk size is large enough. The precise meaning of large enough is application dependent. The current implementation is tuned for an average chunk size between 4kb and 32kb, which should suit most applications.</source>
          <target state="translated">为了&lt;em&gt;有效地实现编码&lt;/em&gt;，重要的是（a）花很少的时间将Haskell值转换为结果字节序列，&lt;em&gt;以及&lt;/em&gt;（b）结果序列的表示形式可以有效地消耗它。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 通过提供O（1）合并操作以及对 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 和其他标准Haskell值的基本编码的有效实现来支持（a）。它们通过将结果提供为惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 来支持（b），它在内部只是指向连续原始内存&lt;em&gt;块&lt;/em&gt;的指针的链接列表。懒 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 可以通过将它们写入文件或通过网络套接字发送它们的函数来有效地使用。请注意，每个块边界都会产生昂贵的额外工作（例如系统调用），必须在消耗块主体上花费的工作中分摊。因此， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 需格外小心，以确保平均块大小足够大。足够大的确切含义取决于应用程序。当前实现已调整为在4kb和32kb之间的平均块大小，这应该适合大多数应用程序。</target>
        </trans-unit>
        <trans-unit id="85427d3349c7624ec90481011c2c435a5c350f38" translate="yes" xml:space="preserve">
          <source>For an enumeration, the nullary constructors are assumed to be numbered left-to-right with the indices being 0 to n-1 inclusive. This is the same numbering defined by the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class. For example, given the datatype:</source>
          <target state="translated">对于枚举，假定无效构造函数从左到右编号，索引为0到n-1（含0和n-1）。这与 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类定义的编号相同。例如，给定数据类型：</target>
        </trans-unit>
        <trans-unit id="2317d704439c0e816415f233729962e630340d1c" translate="yes" xml:space="preserve">
          <source>For an example demonstrating why this is unsafe, see &lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</source>
          <target state="translated">有关演示为什么这样做不安全的示例，请参见&lt;a href=&quot;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&quot;&gt;https://mail.haskell.org/pipermail/haskell-cafe/2009-April/060719.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5f98c16b96cd9f3dba7b2312cfd924a11d7ac8d" translate="yes" xml:space="preserve">
          <source>For an example we have a program, called &lt;code&gt;Recip.hs&lt;/code&gt;, which computes exact decimal representations of reciprocals, with recurring parts indicated in brackets.</source>
          <target state="translated">例如，我们有一个名为 &lt;code&gt;Recip.hs&lt;/code&gt; 的程序，该程序计算倒数的精确十进制表示形式，并在方括号中指出重复部分。</target>
        </trans-unit>
        <trans-unit id="6f3c284585c0a604bb804752c3dde88c28f43321" translate="yes" xml:space="preserve">
          <source>For an interactive application, it is probably a good idea to use the idle GC, because this will allow finalizers to run and deadlocked threads to be detected in the idle time when no Haskell computation is happening. Also, it will mean that a GC is less likely to happen when the application is busy, and so responsiveness may be improved. However, if the amount of live data in the heap is particularly large, then the idle GC can cause a significant delay, and too small an interval could adversely affect interactive responsiveness.</source>
          <target state="translated">对于一个交互式的应用程序来说,使用空闲GC可能是一个好主意,因为这将允许在没有Haskell计算发生的空闲时间内运行终结器和检测死锁线程。另外,这将意味着当应用程序繁忙时GC不太可能发生,因此响应性可能会得到改善。但是,如果堆中的实时数据量特别大,那么空闲GC可能会造成明显的延迟,而过小的间隔可能会对交互响应性产生不利影响。</target>
        </trans-unit>
        <trans-unit id="945a445d8ac893cd2e10d46914fbf37b660fe8b4" translate="yes" xml:space="preserve">
          <source>For any module that is imported, GHC requires that the name of the module in the import statement exactly matches the name of the module in the interface file (or source file) found using the strategy specified in &lt;a href=&quot;#search-path&quot;&gt;The search path&lt;/a&gt;. This means that for most modules, the source file name should match the module name.</source>
          <target state="translated">对于任何导入的模块，GHC要求import语句中的模块名称与使用&lt;a href=&quot;#search-path&quot;&gt;&amp;ldquo;搜索路径&amp;rdquo;中&lt;/a&gt;指定的策略找到的接口文件（或源文件）中的模块名称完全匹配。这意味着对于大多数模块，源文件名应与模块名匹配。</target>
        </trans-unit>
        <trans-unit id="c4fde380f1c057e17c4834c04b581f9f36e12710" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">对于作为 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类的实例的任何类型，应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="2668d63ce3c1412ab95942782c64db8a803782a5" translate="yes" xml:space="preserve">
          <source>For any type that is an instance of class &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; as well as &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt;, the following should hold:</source>
          <target state="translated">对于作为 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 类的实例的任何类型，应满足以下条件：</target>
        </trans-unit>
        <trans-unit id="f5b0590b7a86a642764875b6c543da9446390b3c" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can be a bottleneck. In such cases, consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; (GHC only).</source>
          <target state="translated">对于具有大量字符串文字的应用程序， &lt;code&gt;&lt;a href=&quot;data-bytestring#v:pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 可能是瓶颈。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackAddress&quot;&gt;unsafePackAddress&lt;/a&gt;&lt;/code&gt; （仅适用于 GHC）。</target>
        </trans-unit>
        <trans-unit id="157ede2fd9143a8b3502fbb97415660d94e7cb64" translate="yes" xml:space="preserve">
          <source>For applications with large numbers of string literals, pack can be a bottleneck.</source>
          <target state="translated">对于有大量字符串字元的应用,pack可能是一个瓶颈。</target>
        </trans-unit>
        <trans-unit id="56b658eb8fe6b5f04e699bc25917bb161ec51372" translate="yes" xml:space="preserve">
          <source>For backward compatibility with existing make scripts, when used in combination with &lt;a href=&quot;#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;, the linking phase is omitted (same as &lt;code&gt;--make -no-link&lt;/code&gt;).</source>
          <target state="translated">为了与现有make脚本向后兼容，当与&lt;a href=&quot;#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;结合使用时，将省略链接阶段（与 &lt;code&gt;--make -no-link&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="a0f746a46394a3d26c67f678278e9c3f5556799d" translate="yes" xml:space="preserve">
          <source>For backward compatibility, kind variables &lt;em&gt;do not&lt;/em&gt; need to be bound explicitly, even if the type starts with &lt;code&gt;forall&lt;/code&gt;.</source>
          <target state="translated">为了向后兼容，一种变量&lt;em&gt;并不&lt;/em&gt;需要明确的约束，即使启动类型与 &lt;code&gt;forall&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eb9aa8c4991a1b62e3c275f5d3018b0177bfba7" translate="yes" xml:space="preserve">
          <source>For backwards compatibility</source>
          <target state="translated">为了向后兼容</target>
        </trans-unit>
        <trans-unit id="27a3fb60d0c46913898e711aaa2f8bee288627da" translate="yes" xml:space="preserve">
          <source>For binary constructors</source>
          <target state="translated">对于二进制构造函数</target>
        </trans-unit>
        <trans-unit id="113ecb566c4518b38725ad5c1d8eb800bb73f6cc" translate="yes" xml:space="preserve">
          <source>For both &lt;a href=&quot;#pragma-INLINE&quot;&gt;&lt;code&gt;INLINE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pragma-NOINLINE&quot;&gt;&lt;code&gt;NOINLINE&lt;/code&gt;&lt;/a&gt;, the phase number says when inlining is allowed at all.</source>
          <target state="translated">对于&lt;a href=&quot;#pragma-INLINE&quot;&gt; &lt;code&gt;INLINE&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pragma-NOINLINE&quot;&gt; &lt;code&gt;NOINLINE&lt;/code&gt; &lt;/a&gt;，阶段号表示何时完全允许内联。</target>
        </trans-unit>
        <trans-unit id="62d66553e100d412ce77e1fe48bae79aaea2144a" translate="yes" xml:space="preserve">
          <source>For both pattern and expression wildcards, the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to the missing &lt;em&gt;in-scope&lt;/em&gt; record fields. Specifically the expansion of &amp;ldquo;&lt;code&gt;C {..}&lt;/code&gt;&amp;rdquo; includes &lt;code&gt;f&lt;/code&gt; if and only if:</source>
          <target state="translated">对于模式通配符和表达式通配符，&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;将扩展到缺少&lt;em&gt;的范围内&lt;/em&gt;记录字段。具体来说，&amp;ldquo; &lt;code&gt;C {..}&lt;/code&gt; &amp;rdquo; 的扩展包括 &lt;code&gt;f&lt;/code&gt; ,当且仅当：</target>
        </trans-unit>
        <trans-unit id="c79b50d69800a59416d8d5cf9c81be241c6cfd46" translate="yes" xml:space="preserve">
          <source>For boxed values (that is, values that are represented by a pointer), a further distinction is made, between lifted types (that contain &amp;perp;), and unlifted ones (that don't).</source>
          <target state="translated">对于装箱的值（即，由指针表示的值），在提升类型（包含&amp;perp;）和未提升类型（不包含）之间进行了进一步的区分。</target>
        </trans-unit>
        <trans-unit id="5ac3a49892d34dca6a91a788fcd33beaec7c04fe" translate="yes" xml:space="preserve">
          <source>For capabilities which may contain variable-length padding, use &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">对于可能包含可变长度填充的功能，请改用 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput&quot;&gt;tiGetOutput&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a6e2851e87788aba1413fa210db4c6f6c972b19" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b49217666ee344468a322492b5c79e209e32151" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;ghc-io#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5a20c491f4c7cf4edd8064f53d84a0223202bb" translate="yes" xml:space="preserve">
          <source>For catching exceptions in pure (non-&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;) expressions, see the function &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关在纯（非 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; ）表达式中捕获异常的信息，请参见函数 &lt;code&gt;&lt;a href=&quot;control-exception#v:evaluate&quot;&gt;evaluate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad72b8f09f320f536c51fd5fb47c559cb7126920" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types (see &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;) to and from integer types preserves representation, not sign.</source>
          <target state="translated">要在任何两个整数类型之间进行强制转换，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; ，它专门用于所有常见情况，因此应足够快。在整数类型之间来回强制单词类型（请参阅&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;）会保留表示形式，而不是符号。</target>
        </trans-unit>
        <trans-unit id="6af5be5e40fc3970696dd7cb02cedeef47e8ddad" translate="yes" xml:space="preserve">
          <source>For coercing between any two integer types, use &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign.</source>
          <target state="translated">要在任何两个整数类型之间进行强制转换，请使用 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; ，它专门用于所有常见情况，因此应足够快。在整数类型之间来回强制单词类型会保留表示形式，而不是符号。</target>
        </trans-unit>
        <trans-unit id="d569e185ce7fabcffce84351a9be98fa6e429e2d" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/etc/xdg&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">对于配置文件。它使用 &lt;code&gt;XDG_CONFIG_DIRS&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;/etc/xdg&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 或 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; （例如 &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ecc757e7efb65d0598236167a0b25a6cc54dc8ed" translate="yes" xml:space="preserve">
          <source>For configuration files. It uses the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.config&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">对于配置文件。它使用 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.config&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%APPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。可以视为 &lt;code&gt;/etc&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="c8bbf2f4e0dcd53b9576e5192a8bbd3f2edac0bb" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;/usr/local/share/&lt;/code&gt; and &lt;code&gt;/usr/share/&lt;/code&gt;. On Windows, the default is &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; or &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; (e.g. &lt;code&gt;C:/ProgramData&lt;/code&gt;).</source>
          <target state="translated">用于数据文件（例如图像）。它使用 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;/usr/local/share/&lt;/code&gt; 和 &lt;code&gt;/usr/share/&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%PROGRAMDATA%&lt;/code&gt; 或 &lt;code&gt;%ALLUSERSPROFILE%&lt;/code&gt; （例如 &lt;code&gt;C:/ProgramData&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f2c0b2306c8d3878f085903482b9a90782cfe6b1" translate="yes" xml:space="preserve">
          <source>For data files (e.g. images). It uses the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.local/share&lt;/code&gt;. On Windows, the default is &lt;code&gt;%APPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/usr/share&lt;/code&gt;.</source>
          <target state="translated">用于数据文件（例如图像）。它使用 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.local/share&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%APPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Roaming&lt;/code&gt; ）。可以视为 &lt;code&gt;/usr/share&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="fae8b417bf3bf5318948c8b0b508758745adb6f5" translate="yes" xml:space="preserve">
          <source>For decoding and generating simple external binary formats (e.g. C structures), Binary may be used, but in general is not suitable for complex protocols. Instead use the &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; primitives directly.</source>
          <target state="translated">为了解码和生成简单的外部二进制格式（例如C结构），可以使用Binary，但是通常不适合复杂协议。而是直接使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-binary#t:Get&quot;&gt;Get&lt;/a&gt;&lt;/code&gt; 原语。</target>
        </trans-unit>
        <trans-unit id="7e906ad780906310d51f386651923755220b051e" translate="yes" xml:space="preserve">
          <source>For details on Remote GHCi, see Note [Remote GHCi] in compiler&lt;em&gt;ghci&lt;/em&gt;GHCi.hs.</source>
          <target state="translated">有关远程GHCi的详细信息，请参见编译器&lt;em&gt;ghci&lt;/em&gt; GHCi.hs中的注释[Remote GHCi]。</target>
        </trans-unit>
        <trans-unit id="e1ce5f8e660c7a1a97eb8290bd06346fb0073e69" translate="yes" xml:space="preserve">
          <source>For each alternative of the sum type, a layout that consists of these fields is generated. For example, if an alternative has &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; fields, the layout will have an 32bit word, 32bit float and pointer fields.</source>
          <target state="translated">对于总和类型的每个替代，都会生成一个包含这些字段的布局。例如，如果替代项具有 &lt;code&gt;Int&lt;/code&gt; ， &lt;code&gt;Float#&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 字段，则布局将具有32位字，32位float和指针字段。</target>
        </trans-unit>
        <trans-unit id="757a36cc9fb80bb745216ef2b4ffc5c6499465dc" translate="yes" xml:space="preserve">
          <source>For each garbage collection, we print:</source>
          <target state="translated">每次收集垃圾,我们都会打印。</target>
        </trans-unit>
        <trans-unit id="482f5994f6e216e0ba86b514f2ee819b9680d690" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">对于每个导入声明 &lt;code&gt;import X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt; ，一行记录 &lt;code&gt;M&lt;/code&gt; 对 &lt;code&gt;X&lt;/code&gt; 的依赖关系：</target>
        </trans-unit>
        <trans-unit id="c02e72408897c523f9a6c45e14bb555eade7491d" translate="yes" xml:space="preserve">
          <source>For each import declaration &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;, a line recording the dependence of &lt;code&gt;M&lt;/code&gt; on &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">对于每个导入声明，在 &lt;code&gt;M&lt;/code&gt; 中 &lt;code&gt;import {-# SOURCE #-} X&lt;/code&gt; ，该行记录 &lt;code&gt;M&lt;/code&gt; 对 &lt;code&gt;X&lt;/code&gt; 的依赖性：</target>
        </trans-unit>
        <trans-unit id="2200dfec6b12718042bc1df9e4ba8ac51a77f634" translate="yes" xml:space="preserve">
          <source>For each node in the tree, apply &lt;code&gt;f&lt;/code&gt; to the &lt;code&gt;rootLabel&lt;/code&gt; and the result of applying &lt;code&gt;f&lt;/code&gt; to each &lt;code&gt;subForest&lt;/code&gt;.</source>
          <target state="translated">对于树中的每个节点，将 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;rootLabel&lt;/code&gt; ，并将 &lt;code&gt;f&lt;/code&gt; 应用于每个 &lt;code&gt;subForest&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="3057e0dd6d54e41f208fa76fa96588cff9717be1" translate="yes" xml:space="preserve">
          <source>For empty datatypes, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; is used as a representation. For example,</source>
          <target state="translated">对于空数据类型，将 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; 用作表示形式。例如，</target>
        </trans-unit>
        <trans-unit id="367e92ce36a947e0da868cc6cdcfc2f796641103" translate="yes" xml:space="preserve">
          <source>For even more detail on this topic, see &lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&quot;Proper handling of SIGINT/SIGQUIT&quot;&lt;/a&gt;.</source>
          <target state="translated">有关此主题的更多详细信息，请参见&lt;a href=&quot;http://www.cons.org/cracauer/sigint.html&quot;&gt;&amp;ldquo;正确处理SIGINT / SIGQUIT&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bdb8867f7ccd15d71a69ed939e98d09ad4ef1b15" translate="yes" xml:space="preserve">
          <source>For every module &lt;code&gt;A.hs&lt;/code&gt; that is &lt;code&gt;{-# SOURCE #-}&lt;/code&gt;-imported in this way there must exist a source file &lt;code&gt;A.hs-boot&lt;/code&gt;. This file contains an abbreviated version of &lt;code&gt;A.hs&lt;/code&gt;, thus:</source>
          <target state="translated">对于以这种方式导入的每个 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 模块 &lt;code&gt;A.hs&lt;/code&gt; ，都必须存在一个源文件 &lt;code&gt;A.hs-boot&lt;/code&gt; 。该文件包含 &lt;code&gt;A.hs&lt;/code&gt; 的缩写版本，因此：</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="b0f621e891e9171328261480a78acacdfb576180" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-l-ag&lt;/code&gt; would disable all event classes (&lt;code&gt;-a&lt;/code&gt;) except for GC events (&lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">例如， &lt;code&gt;-l-ag&lt;/code&gt; 将禁用除GC事件（ &lt;code&gt;g&lt;/code&gt; ）之外的所有事件类（ &lt;code&gt;-a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9a47ad65e0c2a3d400457a0b11356459b95bcb1d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; copies strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose size is less or equal to 1kb, and inserts them directly otherwise. This implies that the average chunk-size of the generated lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; may be as low as 513 bytes, as there could always be just a single byte between the directly inserted 1025 byte, strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">例如， &lt;code&gt;byteStringThreshold 1024&lt;/code&gt; 复制大小小于或等于1kb的严格 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ，否则直接将其插入。这意味着所生成的惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 的平均块大小可能低至513字节，因为在直接插入的1025字节严格 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 之间始终总是只有一个字节。</target>
        </trans-unit>
        <trans-unit id="6fde4b70734a8fac9093ea2a07235b341112181d" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; will be parsed as &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt;, not as &lt;code&gt;f
(\a -&amp;gt; a) b&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;f \a -&amp;gt; a b&lt;/code&gt; 将被解析为 &lt;code&gt;f (\a -&amp;gt; a b)&lt;/code&gt; ，而不是 &lt;code&gt;f (\a -&amp;gt; a) b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d68c2abf3bd572e6b394677caea8c74a91c6ffaa" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，UTF-8是将Unicode字符编码为字节序列。UTF-8 的 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a131281d0c878473b424da7f5958a8ee1d5ccf4b" translate="yes" xml:space="preserve">
          <source>For example, UTF-8 is an encoding of Unicode characters into a sequence of bytes. The &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; for UTF-8 is &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，UTF-8是将Unicode字符编码为字节序列。UTF-8 的 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d40901ab3bf757ac476fdd101797decf03e3512" translate="yes" xml:space="preserve">
          <source>For example, a program to print the first 20 integers and their powers of 2 could be written as:</source>
          <target state="translated">例如,一个打印前20个整数和它们的2次方的程序可以写成。</target>
        </trans-unit>
        <trans-unit id="a9ef3024ea8891eb534acb48c1b294262c997e19" translate="yes" xml:space="preserve">
          <source>For example, a user-defined datatype of trees</source>
          <target state="translated">例如,用户定义的树的数据类型为</target>
        </trans-unit>
        <trans-unit id="744409e78bf68170b982ca29c657867bee8ffa37" translate="yes" xml:space="preserve">
          <source>For example, compiling the following module with GHC:</source>
          <target state="translated">例如,用GHC编译以下模块。</target>
        </trans-unit>
        <trans-unit id="e6d6e2ba2b5ca72099050bc51954934eb60bffb4" translate="yes" xml:space="preserve">
          <source>For example, consider</source>
          <target state="translated">例如,考虑</target>
        </trans-unit>
        <trans-unit id="7bb345fb3af895621bd1d63c6e6ef0f332232c9b" translate="yes" xml:space="preserve">
          <source>For example, consider a program &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">例如，考虑一个程序 &lt;code&gt;foo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c25100ceaa78174d12c46a1aeb9aca894d0c3090" translate="yes" xml:space="preserve">
          <source>For example, consider a type class that is not intended to be used with functions, but the user accidentally used it at a function type, perhaps because they missed an argument to some function. Then, instead of getting the standard GHC message about a missing instance, it would be nicer to emit a more friendly message specific to the EDSL. Similarly, the reduction of a type-level function may get stuck due to an error, at which point it would be nice to report an EDSL specific error, rather than a generic error about an ambiguous type.</source>
          <target state="translated">例如,考虑一个不打算与函数一起使用的类型类,但用户不小心在函数类型处使用了它,也许是因为他们错过了某个函数的参数。那么,与其得到标准的GHC关于遗漏实例的消息,不如发出一个针对EDSL的更友好的消息。同样,类型级函数的还原可能会因为一个错误而卡住,这时如果能报告一个EDSL特定的错误,而不是一个关于模糊类型的通用错误,那就更好了。</target>
        </trans-unit>
        <trans-unit id="d37882239b62f8f60c67248b5ef090444ecd46a4" translate="yes" xml:space="preserve">
          <source>For example, consider if you had a macro named &lt;code&gt;:time&lt;/code&gt; and in the shell, typed &lt;code&gt;:t 3&lt;/code&gt; &amp;mdash; what should happen? The current algorithm we use for completing commands is:</source>
          <target state="translated">例如，考虑是否有一个名为 &lt;code&gt;:time&lt;/code&gt; 的宏，并且在外壳中键入了 &lt;code&gt;:t 3&lt;/code&gt; －应该怎么办？我们用于完成命令的当前算法是：</target>
        </trans-unit>
        <trans-unit id="65686db81caecd61279e7eeb51586e09d8ed9938" translate="yes" xml:space="preserve">
          <source>For example, consider the following parallel version of our old nemesis, &lt;code&gt;nfib&lt;/code&gt;:</source>
          <target state="translated">例如，考虑下面的并行版本的老 &lt;code&gt;nfib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="93bbe6300a112cc074a95237a2b5bafd43171b4b" translate="yes" xml:space="preserve">
          <source>For example, consider these definitions (with &lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt;&lt;code&gt;ScopedTypeVariables&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">例如，考虑以下定义（使用&lt;a href=&quot;#extension-ScopedTypeVariables&quot;&gt; &lt;code&gt;ScopedTypeVariables&lt;/code&gt; &lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d42fd5e5b201e8c6886f2c95796540ee28c71bc6" translate="yes" xml:space="preserve">
          <source>For example, given a data type</source>
          <target state="translated">例如,给定一个数据类型</target>
        </trans-unit>
        <trans-unit id="4bdc75c67cb68db483ee29ec3c932f3c07d61e7e" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, &lt;code&gt;hist&lt;/code&gt; produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">例如，给定某种索引类型的值的列表， &lt;code&gt;hist&lt;/code&gt; 生成直方图，表示指定范围内每个索引的出现次数：</target>
        </trans-unit>
        <trans-unit id="c355f67c4b8d78811097c4401689f016752e1ba0" translate="yes" xml:space="preserve">
          <source>For example, given a list of values of some index type, hist produces a histogram of the number of occurrences of each index within a specified range:</source>
          <target state="translated">例如,给定某个索引类型的值的列表,hist产生一个指定范围内每个索引出现次数的直方图。</target>
        </trans-unit>
        <trans-unit id="1eab4f69e1d74fb57993a017da4c8e140181fdb5" translate="yes" xml:space="preserve">
          <source>For example, given the declarations</source>
          <target state="translated">例如,给定声明</target>
        </trans-unit>
        <trans-unit id="092e743ba03cbd9f10aa95f011412e94dc868f41" translate="yes" xml:space="preserve">
          <source>For example, here is a heap profile produced for the &lt;code&gt;sphere&lt;/code&gt; program from GHC&amp;rsquo;s &lt;code&gt;nofib&lt;/code&gt; benchmark suite,</source>
          <target state="translated">例如，这是GHC的 &lt;code&gt;nofib&lt;/code&gt; 基准套件为 &lt;code&gt;sphere&lt;/code&gt; 程序生成的堆配置文件，</target>
        </trans-unit>
        <trans-unit id="7a34f8af22ee4347fe8ec5e1224bf70e5de3ef73" translate="yes" xml:space="preserve">
          <source>For example, here is how we might implement an &lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;echo server&lt;/a&gt;, using &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; both to listen for client connections on a network socket and to echo client input on client connection handles:</source>
          <target state="translated">例如，这是我们可能实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Echo_Protocol&quot;&gt;回显服务器的方式&lt;/a&gt;，它 &lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt;&lt;/code&gt; 使用监听网络套接字上的客户端连接并在客户端连接句柄上回显客户端输入：</target>
        </trans-unit>
        <trans-unit id="ee6da42913659645d60841805c91275892b69538" translate="yes" xml:space="preserve">
          <source>For example, if GHC compiles the module &lt;code&gt;A.B.C&lt;/code&gt; in the file &lt;code&gt;src/A/B/C.hs&lt;/code&gt;, with no &lt;code&gt;-odir&lt;/code&gt; or &lt;code&gt;-hidir&lt;/code&gt; flags, the interface file will be put in &lt;code&gt;src/A/B/C.hi&lt;/code&gt; and the object file in &lt;code&gt;src/A/B/C.o&lt;/code&gt;.</source>
          <target state="translated">例如，如果GHC编译文件 &lt;code&gt;src/A/B/C.hs&lt;/code&gt; 中的模块 &lt;code&gt;A.B.C&lt;/code&gt; ，而没有 &lt;code&gt;-odir&lt;/code&gt; 或 &lt;code&gt;-hidir&lt;/code&gt; 标志，则该接口文件将放在 &lt;code&gt;src/A/B/C.hi&lt;/code&gt; 和对象中文件中 &lt;code&gt;src/A/B/C.o&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4fd5a35e83d4d92107628f0b0a526842c88f6f3" translate="yes" xml:space="preserve">
          <source>For example, if an interface is lying about the type of an imported value then GHC may well generate duff code for the importing module. &lt;em&gt;This applies to pragmas inside interfaces too!&lt;/em&gt; If the pragma is lying (e.g., about the &amp;ldquo;arity&amp;rdquo; of a value), then duff code may result. Furthermore, arities may change even if types do not.</source>
          <target state="translated">例如，如果接口位于导入值的类型附近，那么GHC可以很好地为导入模块生成Duff代码。&lt;em&gt;这也适用于接口内部的编译指示！&lt;/em&gt;如果编译指示在撒谎（例如，关于某个值的&amp;ldquo; arity&amp;rdquo;），则可能会产生达芙代码。此外，即使类型没有变化，arities也会改变。</target>
        </trans-unit>
        <trans-unit id="01897242c453eafb4b01262fb63540cca636483f" translate="yes" xml:space="preserve">
          <source>For example, if the following datatype is in scope</source>
          <target state="translated">例如,如果以下数据类型在作用域中</target>
        </trans-unit>
        <trans-unit id="feecbb8b0e63385c2814e7a6c80293daa6efef5d" translate="yes" xml:space="preserve">
          <source>For example, if we specify a Haskell library as &lt;code&gt;HSfoo&lt;/code&gt; in the package spec, then the various flavours of library that GHC actually uses will be called:</source>
          <target state="translated">例如，如果我们在软件包规范 &lt;code&gt;HSfoo&lt;/code&gt; Haskell库指定为HSfoo，则将调用GHC实际使用的各种库：</target>
        </trans-unit>
        <trans-unit id="5aac58398382b1dc4e6fa1f8a176b54c3c8f6891" translate="yes" xml:space="preserve">
          <source>For example, if you are inspecting the core of your program and you observe that &lt;code&gt;foo&lt;/code&gt; is not being inlined. You can pass &lt;code&gt;-dinline-check foo&lt;/code&gt; and you will see a report about why &lt;code&gt;foo&lt;/code&gt; is not inlined.</source>
          <target state="translated">例如，如果您正在检查程序的核心，并且发现 &lt;code&gt;foo&lt;/code&gt; 没有被内联。您可以通过 &lt;code&gt;-dinline-check foo&lt;/code&gt; ，您将看到有关为什么不内联 &lt;code&gt;foo&lt;/code&gt; 的报告。</target>
        </trans-unit>
        <trans-unit id="b110bc690a93e5b10bf8e0914df1a07ee1433b91" translate="yes" xml:space="preserve">
          <source>For example, in an 80-column terminal with this behavior, the following will print single-spaced instead of double-spaced:</source>
          <target state="translated">例如,在具有这种行为的80列终端中,以下内容将打印单倍行距而不是双倍行距。</target>
        </trans-unit>
        <trans-unit id="6ed162bad590f5003d7d426fd5ae42fa4f804a10" translate="yes" xml:space="preserve">
          <source>For example, in the following program, &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;f'&lt;/code&gt; are equivalent:</source>
          <target state="translated">例如，在下面的程序中， &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;f'&lt;/code&gt; 是等效的：</target>
        </trans-unit>
        <trans-unit id="f4f0daf85ba8e99d49b00ae49cc0b4883f326a6b" translate="yes" xml:space="preserve">
          <source>For example, item can be written as:</source>
          <target state="translated">例如,项目可以写成:</target>
        </trans-unit>
        <trans-unit id="23d438828de5a37dbac482cecf3993a3fb389e7b" translate="yes" xml:space="preserve">
          <source>For example, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; using the same &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; will share the same input history. In constrast, multiple calls to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; will use distinct histories unless they share the same history file.</source>
          <target state="translated">例如，使用相同 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 的对 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#v:queryInput&quot;&gt;queryInput&lt;/a&gt;&lt;/code&gt; 的多次调用将共享相同的输入历史记录。相反，多次调用 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputT&quot;&gt;runInputT&lt;/a&gt;&lt;/code&gt; 将使用不同的历史记录，除非它们共享相同的历史记录文件。</target>
        </trans-unit>
        <trans-unit id="cccb8365a356d9204a1e3e6be4d959bd5de7a6a9" translate="yes" xml:space="preserve">
          <source>For example, one possible application is to reify dictionaries:</source>
          <target state="translated">例如,一种可能的应用是将字典重新标准化。</target>
        </trans-unit>
        <trans-unit id="f442cf832dad88fc0e7646f66ee10e0363b7080d" translate="yes" xml:space="preserve">
          <source>For example, remembering that &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt;:</source>
          <target state="translated">例如，记住 &lt;code&gt;putStrLn :: String -&amp;gt; IO ()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d9a2c926ccbb0f9d553917af57bd1f41d6413ed1" translate="yes" xml:space="preserve">
          <source>For example, sometimes you might want to use the following to get the effect of a &amp;ldquo;class synonym&amp;rdquo;:</source>
          <target state="translated">例如，有时您可能想使用以下命令来获得&amp;ldquo;类同义词&amp;rdquo;的效果：</target>
        </trans-unit>
        <trans-unit id="e5b7402fa6acb4a815984441e87927a1f6479149" translate="yes" xml:space="preserve">
          <source>For example, suppose the search path contains directories &lt;code&gt;d1&lt;/code&gt;, &lt;code&gt;d2&lt;/code&gt;, and &lt;code&gt;d3&lt;/code&gt;, and we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode looking for the source file for a module &lt;code&gt;A.B.C&lt;/code&gt;. GHC will look in &lt;code&gt;d1/A/B/C.hs&lt;/code&gt;, &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt;, &lt;code&gt;d2/A/B/C.hs&lt;/code&gt;, and so on.</source>
          <target state="translated">例如，假设搜索路径包含目录 &lt;code&gt;d1&lt;/code&gt; ， &lt;code&gt;d2&lt;/code&gt; 和 &lt;code&gt;d3&lt;/code&gt; ，并且我们处于&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式下，查找模块 &lt;code&gt;A.B.C&lt;/code&gt; 的源文件。GHC将查看 &lt;code&gt;d1/A/B/C.hs&lt;/code&gt; ， &lt;code&gt;d1/A/B/C.lhs&lt;/code&gt; ， &lt;code&gt;d2/A/B/C.hs&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="bdd681ea0a0383fa82b3cb4fd238264b1f0a0e95" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a string that you want to split on the substring &lt;code&gt;&quot;::&quot;&lt;/code&gt;, such as &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt;. Instead of searching for the index of &lt;code&gt;&quot;::&quot;&lt;/code&gt; and taking the substrings before and after that index, you would instead use &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">例如，假设您有一个要在子字符串 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 上分割的字符串，例如 &lt;code&gt;&quot;foo::bar::quux&quot;&lt;/code&gt; 。与其搜索索引 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 并在该索引之前和之后获取子字符串， &lt;code&gt;breakOnAll &quot;::&quot;&lt;/code&gt; 使用breakOnAll&amp;ldquo; ::&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ac114f663d8e987abd5e387676a684751e04a820" translate="yes" xml:space="preserve">
          <source>For example, suppose you want to read a file, but if it doesn't exist then continue as if it contained &quot;&quot;. You might be tempted to just catch all exceptions and return &quot;&quot; in the handler. However, this has all sorts of undesirable consequences. For example, if the user presses control-C at just the right moment then the &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; exception will be caught, and the program will continue running under the belief that the file contains &quot;&quot;. Similarly, if another thread tries to kill the thread reading the file then the &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; exception will be ignored.</source>
          <target state="translated">例如，假设您要读取文件，但是如果该文件不存在，则继续以包含&amp;ldquo;&amp;rdquo;的方式继续。您可能会想捕获所有异常并在处理程序中返回&amp;ldquo;&amp;rdquo;。但是，这会带来各种不良后果。例如，如果用户在适当的时候按下Ctrl-C，则将捕获 &lt;code&gt;&lt;a href=&quot;control-exception#v:UserInterrupt&quot;&gt;UserInterrupt&lt;/a&gt;&lt;/code&gt; 异常，并且程序将在文件包含&amp;ldquo;&amp;rdquo;的信念下继续运行。同样，如果另一个线程试图杀死读取文件的线程，则 &lt;code&gt;&lt;a href=&quot;control-exception#v:ThreadKilled&quot;&gt;ThreadKilled&lt;/a&gt;&lt;/code&gt; 异常将被忽略。</target>
        </trans-unit>
        <trans-unit id="2b47a77367f051fe58214e2454bd4b98b948cadb" translate="yes" xml:space="preserve">
          <source>For example, the constructor fields in the following data types</source>
          <target state="translated">例如,以下数据类型中的构造函数字段。</target>
        </trans-unit>
        <trans-unit id="7651edd96e5c58d56d08d8f8dadcaee786526668" translate="yes" xml:space="preserve">
          <source>For example, the data types &lt;code&gt;2 * A&lt;/code&gt; and &lt;code&gt;A + A&lt;/code&gt; are isomorphic but some computations are more naturally expressed in terms of one or the other. To get the best of both worlds, we can choose one as our implementation and then provide a set of pattern synonyms so that users can use the other representation if they desire. We can then specify a &lt;code&gt;COMPLETE&lt;/code&gt; pragma in order to inform the pattern match checker that a function which matches on both &lt;code&gt;LeftChoice&lt;/code&gt; and &lt;code&gt;RightChoice&lt;/code&gt; is total.</source>
          <target state="translated">例如，数据类型 &lt;code&gt;2 * A&lt;/code&gt; 和 &lt;code&gt;A + A&lt;/code&gt; 是同构的，但是某些计算更自然地用一种或另一种来表示。为了充分利用这两个方面，我们可以选择一个作为实现，然后提供一组模式同义词，以便用户根据需要使用其他表示形式。然后，我们可以指定一个 &lt;code&gt;COMPLETE&lt;/code&gt; &lt;code&gt;LeftChoice&lt;/code&gt; 注，以通知模式匹配检查器一个在LeftChoice和 &lt;code&gt;RightChoice&lt;/code&gt; 上都匹配的函数是合计的。</target>
        </trans-unit>
        <trans-unit id="ee57ef376af738c0cc39be9b8a3aeffd655a9804" translate="yes" xml:space="preserve">
          <source>For example, the following code is accepted by GHC:</source>
          <target state="translated">例如,以下代码为GHC所接受。</target>
        </trans-unit>
        <trans-unit id="ed55721fe5eca931044c06dd74e928c1a9366863" translate="yes" xml:space="preserve">
          <source>For example, the following options will generate a retainer profile restricted to &lt;code&gt;Branch&lt;/code&gt; and &lt;code&gt;Leaf&lt;/code&gt; constructors:</source>
          <target state="translated">例如，以下选项将生成仅限于 &lt;code&gt;Branch&lt;/code&gt; 和 &lt;code&gt;Leaf&lt;/code&gt; 构造函数的保留配置文件：</target>
        </trans-unit>
        <trans-unit id="e24297250355b4a78eb62d1dc56e97787e232bfc" translate="yes" xml:space="preserve">
          <source>For example, these are okay:</source>
          <target state="translated">比如说,这些都是可以的。</target>
        </trans-unit>
        <trans-unit id="15e69e99eeb37907f6273e21ee4ff58bdd61a0ee" translate="yes" xml:space="preserve">
          <source>For example, this code will require a &lt;code&gt;Monad&lt;/code&gt; constraint:</source>
          <target state="translated">例如，此代码将需要 &lt;code&gt;Monad&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="900e1e6015412435fcee921be92977f023f6a57e" translate="yes" xml:space="preserve">
          <source>For example, this instance would make the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; accessible using &lt;code&gt;#fullname&lt;/code&gt; as well:</source>
          <target state="translated">例如，这种情况会使 &lt;code&gt;name&lt;/code&gt; 的领域 &lt;code&gt;Person&lt;/code&gt; 访问使用 &lt;code&gt;#fullname&lt;/code&gt; 还有：</target>
        </trans-unit>
        <trans-unit id="47bbb9c1056126a12b9da3b641c5bfc651a0ba80" translate="yes" xml:space="preserve">
          <source>For example, this returns the value of &lt;code&gt;f x&lt;/code&gt; but first outputs the message.</source>
          <target state="translated">例如，这返回 &lt;code&gt;f x&lt;/code&gt; 的值，但首先输出消息。</target>
        </trans-unit>
        <trans-unit id="225929f65a69a76a61aa35be9e43fc3fd618afeb" translate="yes" xml:space="preserve">
          <source>For example, this:</source>
          <target state="translated">例如,这。</target>
        </trans-unit>
        <trans-unit id="9016b1102f311501fac46c1e7eecc35288f12dcc" translate="yes" xml:space="preserve">
          <source>For example, to enable the FFI and preprocessing with CPP:</source>
          <target state="translated">例如,要启用FFI和CPP的预处理。</target>
        </trans-unit>
        <trans-unit id="26497d08a388e4d2412b7f1fab7c57d63571afa3" translate="yes" xml:space="preserve">
          <source>For example, to execute a simple &lt;code&gt;ls&lt;/code&gt; command:</source>
          <target state="translated">例如，要执行一个简单的 &lt;code&gt;ls&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="a3311a9da6750dc8b9fba90d3be35024a5d05bc0" translate="yes" xml:space="preserve">
          <source>For example, to link a program consisting of objects &lt;code&gt;Foo.o&lt;/code&gt; and &lt;code&gt;Main.o&lt;/code&gt;, where we made use of the &lt;code&gt;network&lt;/code&gt; package, we need to give GHC the &lt;code&gt;-package&lt;/code&gt; flag thus:</source>
          <target state="translated">例如，要链接由对象的程序 &lt;code&gt;Foo.o&lt;/code&gt; 和 &lt;code&gt;Main.o&lt;/code&gt; ，在那里我们利用了的 &lt;code&gt;network&lt;/code&gt; 包，我们需要给GHC的 &lt;code&gt;-package&lt;/code&gt; 从而标志：</target>
        </trans-unit>
        <trans-unit id="275c801d323aafd23c71b3f1fd4a2ba975854334" translate="yes" xml:space="preserve">
          <source>For example, to load and run a Haskell program containing a module &lt;code&gt;Main&lt;/code&gt;, we might say:</source>
          <target state="translated">例如，要加载和运行包含 &lt;code&gt;Main&lt;/code&gt; 模块的Haskell程序，我们可能会说：</target>
        </trans-unit>
        <trans-unit id="24c8dec48e12a5f61c3e7a6ffbc6374c90c7019e" translate="yes" xml:space="preserve">
          <source>For example, to parse a date in YYYY-MM-DD format, while allowing the month and date to have optional leading zeros (notice the &lt;code&gt;-&lt;/code&gt; modifier used for &lt;code&gt;%m&lt;/code&gt; and &lt;code&gt;%d&lt;/code&gt;):</source>
          <target state="translated">例如，要解析YYYY-MM-DD格式的日期，同时允许月份和日期具有可选的前导零（请注意，用于 &lt;code&gt;%m&lt;/code&gt; 和 &lt;code&gt;%d&lt;/code&gt; 的 &lt;code&gt;-&lt;/code&gt; 修饰符）：</target>
        </trans-unit>
        <trans-unit id="76f9ac11e3675b26b9adf85da24c93afef2ec32c" translate="yes" xml:space="preserve">
          <source>For example, to start a process and feed a string to its stdin:</source>
          <target state="translated">例如,启动一个进程并向其stdin中输入一个字符串。</target>
        </trans-unit>
        <trans-unit id="5fcd1945807a0dc794011bc0d68f612088c3c98d" translate="yes" xml:space="preserve">
          <source>For example, to tokenise a string, dropping delimiters:</source>
          <target state="translated">例如,将一个字符串标记化,放弃定界符。</target>
        </trans-unit>
        <trans-unit id="e8a9d355c1624f157a17b017f14330568fefc5e8" translate="yes" xml:space="preserve">
          <source>For example, we can write the factorial function using direct recursion as</source>
          <target state="translated">例如,我们可以用直接递归的方法将阶乘函数写成</target>
        </trans-unit>
        <trans-unit id="dd38bf999f51a8e6ab980a4cc02677fcbb4c986c" translate="yes" xml:space="preserve">
          <source>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</source>
          <target state="translated">例如,在编译模块A时,如果B没有导入A(直接或间接),则只能运行从B导入的Template Haskell函数。原因应该很清楚:要运行B,我们必须编译并运行A,但我们目前正在对A进行类型检查。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="17c57644c0265103527c3af40403358dc202cd31" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never
defined.&lt;/code&gt; Unsightly, but shouldn&amp;rsquo;t be a problem.</source>
          <target state="translated">例如： &lt;code&gt;&amp;hellip;warning: \`Foo' declared \`static' but never defined.&lt;/code&gt; 难看，但不应该成为问题。</target>
        </trans-unit>
        <trans-unit id="476b28066e3c89df50c21f73368a0e01098fb0aa" translate="yes" xml:space="preserve">
          <source>For four-part GHC version numbers &lt;code&gt;x.y.z.z'&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩ while the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; is set to the integer ⟨z&amp;rsquo;⟩.</source>
          <target state="translated">对于四部分GHC版本号 &lt;code&gt;x.y.z.z'&lt;/code&gt; ，价值 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 是整数⟨z⟩而价值 &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL2__&lt;/code&gt; 设置为整数⟨z'⟩。</target>
        </trans-unit>
        <trans-unit id="ebd87276392f86aa606645575def965bf344530d" translate="yes" xml:space="preserve">
          <source>For full details on injective type families refer to Haskell Symposium 2015 paper &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;Injective type families for Haskell&lt;/a&gt;.</source>
          <target state="translated">有关内射型族的完整详细信息，请参阅Haskell研讨会2015年论文Haskell &lt;a href=&quot;http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf&quot;&gt;内射型族&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01178e47382bdc6446961872841b23fc4c45fd85" translate="yes" xml:space="preserve">
          <source>For hidden packages, however, you need to request the package be loaded by using the &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; flag:</source>
          <target state="translated">但是，对于隐藏的软件包，您需要使用 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 标志来请求装入软件包：</target>
        </trans-unit>
        <trans-unit id="b3a5c6fd42825560c95317b78e19114644f5b7ff" translate="yes" xml:space="preserve">
          <source>For historical reasons, the preserved values are /&lt;em&gt;not&lt;/em&gt;/ forced. To force them, use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由于历史原因，保留值&lt;em&gt;不是&lt;/em&gt;强制的。要强制使用，请使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:preserveMissing-39-&quot;&gt;preserveMissing'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="2937ae469e44a6da2ea2b9c7c56013ccc4d03ea5" translate="yes" xml:space="preserve">
          <source>For instance, a simple profile might look like this,</source>
          <target state="translated">例如,一个简单的配置文件可能是这样的。</target>
        </trans-unit>
        <trans-unit id="2df4182fc612ce7805e7516eb9a2b62d1493ffae" translate="yes" xml:space="preserve">
          <source>For instance, if you had the following type family:</source>
          <target state="translated">例如,如果你有以下类型的家庭。</target>
        </trans-unit>
        <trans-unit id="ce40606b41f00effc4c8dc141b9ea10bdc0fc070" translate="yes" xml:space="preserve">
          <source>For instance, running a program with &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; would produce a heap profile named &lt;code&gt;hello-world.hp&lt;/code&gt; and a cost-centre profile named &lt;code&gt;hello-world.prof&lt;/code&gt;.</source>
          <target state="translated">例如，使用 &lt;code&gt;+RTS -h -p -pohello-world&lt;/code&gt; 运行程序将产生一个名为 &lt;code&gt;hello-world.hp&lt;/code&gt; 的堆概要文件和一个名为 &lt;code&gt;hello-world.prof&lt;/code&gt; 的成本中心概要文件。</target>
        </trans-unit>
        <trans-unit id="dea0253ba024112a72eb14c4873c0ade6c78487c" translate="yes" xml:space="preserve">
          <source>For instance, take the example of &lt;code&gt;-fno-specialise -O1&lt;/code&gt;. Despite the &lt;code&gt;-fno-specialise&lt;/code&gt; appearing in the command line, specialisation will still be enabled. This is the case as &lt;code&gt;-O1&lt;/code&gt; implies &lt;code&gt;-fspecialise&lt;/code&gt;, overriding the previous flag. By contrast, &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; will compile without specialisation, as one would expect.</source>
          <target state="translated">例如，以 &lt;code&gt;-fno-specialise -O1&lt;/code&gt; 为例。尽管 &lt;code&gt;-fno-specialise&lt;/code&gt; 出现在命令行中，但仍将启用专门化。出现这种情况是 &lt;code&gt;-O1&lt;/code&gt; &lt;code&gt;-fspecialise&lt;/code&gt; 意味着-fspecialise，它将覆盖前一个标志。相比之下， &lt;code&gt;-O1 -fno-specialise&lt;/code&gt; 会像人们期望的那样在不进行专门化的情况下进行编译。</target>
        </trans-unit>
        <trans-unit id="a6868e1fb2efeb3425d8a627bfc9d0ba2d117c39" translate="yes" xml:space="preserve">
          <source>For instance, the first wildcard in the type signature &lt;code&gt;not'&lt;/code&gt; would produce the following error message:</source>
          <target state="translated">例如，类型为 &lt;code&gt;not'&lt;/code&gt; 的第一个通配符将产生以下错误消息：</target>
        </trans-unit>
        <trans-unit id="958aeaf1ba8d61f0734b35c84475403f19531d00" translate="yes" xml:space="preserve">
          <source>For instance, we might use this interface to provide a more useful error message for applications of &lt;code&gt;show&lt;/code&gt; on unsaturated functions like this,</source>
          <target state="translated">例如，我们可以使用此接口为在诸如此类的非饱和函数上的 &lt;code&gt;show&lt;/code&gt; 应用程序提供更有用的错误消息，</target>
        </trans-unit>
        <trans-unit id="529b0aa96caf3e90c0267b32ba2bc9db119509d3" translate="yes" xml:space="preserve">
          <source>For monads that do belong to the &lt;code&gt;MonadFix&lt;/code&gt; class, GHC provides an extended version of the do-notation that allows recursive bindings. The &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; (language pragma: &lt;code&gt;RecursiveDo&lt;/code&gt;) provides the necessary syntactic support, introducing the keywords &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; for higher and lower levels of the notation respectively. Unlike bindings in a &lt;code&gt;do&lt;/code&gt; expression, those introduced by &lt;code&gt;mdo&lt;/code&gt; and &lt;code&gt;rec&lt;/code&gt; are recursively defined, much like in an ordinary let-expression. Due to the new keyword &lt;code&gt;mdo&lt;/code&gt;, we also call this notation the &lt;em&gt;mdo-notation&lt;/em&gt;.</source>
          <target state="translated">对于确实属于 &lt;code&gt;MonadFix&lt;/code&gt; 类的monad，GHC提供了do-notation的扩展版本，它允许递归绑定。所述&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;（语言编译指示： &lt;code&gt;RecursiveDo&lt;/code&gt; ）提供了必要的语法支持，将所述关键字 &lt;code&gt;mdo&lt;/code&gt; 和 &lt;code&gt;rec&lt;/code&gt; 分别用于较高和较低水平的符号的。与 &lt;code&gt;do&lt;/code&gt; 表达式中的绑定不同，由 &lt;code&gt;mdo&lt;/code&gt; 和 &lt;code&gt;rec&lt;/code&gt; 引入的绑定是递归定义的，就像在普通的let表达式中一样。由于使用了新关键字 &lt;code&gt;mdo&lt;/code&gt; ，因此我们也将该符号称为&lt;em&gt;mdo-notation&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aadaa664cff3605a3ecf9e7a3dabf2341d6ea100" translate="yes" xml:space="preserve">
          <source>For more details about this feature, please refer to &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;Safe Coercions&lt;/a&gt; by Joachim Breitner, Richard A. Eisenberg, Simon Peyton Jones and Stephanie Weirich.</source>
          <target state="translated">有关此功能的更多详细信息，请参阅Joachim Breitner，Richard A. Eisenberg，Simon Peyton Jones和Stephanie Weirich撰写的《&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/coercible.pdf&quot;&gt;安全强制》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ddd7518e52d21c45b5c0164d5371d0d7f78e6094" translate="yes" xml:space="preserve">
          <source>For more details please refer to the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki page&lt;/a&gt; or the original paper &lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参阅&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC.Generics&quot;&gt;Haskell Wiki页面&lt;/a&gt;或原始论文&lt;a href=&quot;#generics2010&quot; id=&quot;id98&quot;&gt;[Generics2010]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68f5a6bc7d7f62ba632eabd939ff41eed834fc73" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;Applicative Programming with Effects&lt;/a&gt;, by Conor McBride and Ross Paterson.</source>
          <target state="translated">有关更多详细信息，请参阅Conor McBride和Ross Paterson撰写的&amp;ldquo; &lt;a href=&quot;http://www.soi.city.ac.uk/~ross/papers/Applicative.html&quot;&gt;带效果的应用程序编程&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60fb5a666c6a0eaff8450effcf1a6d5878676b82" translate="yes" xml:space="preserve">
          <source>For more details, see documentation of &lt;code&gt;posix_fadvise(2)&lt;/code&gt;.</source>
          <target state="translated">有关更多详细信息，请参见 &lt;code&gt;posix_fadvise(2)&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="0f151a8de0b0ae047ee77db2f883d4d612f14350" translate="yes" xml:space="preserve">
          <source>For more information about the debug information produced by GHC see Peter Wortmann&amp;rsquo;s PhD thesis, &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;*Profiling Optimized Haskell: Causal Analysis and Implementation*&lt;/a&gt;.</source>
          <target state="translated">有关GHC产生的调试信息的更多信息，请参见Peter Wortmann的博士学位论文&amp;ldquo; &lt;a href=&quot;http://etheses.whiterose.ac.uk/8321/&quot;&gt;分析优化的Haskell：因果分析和实现&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8560ce11100cb4fa01d3828472236f160a993060" translate="yes" xml:space="preserve">
          <source>For more information on ticky-ticky profiling, see &lt;a href=&quot;profiling#ticky-ticky&quot;&gt;Using &amp;ldquo;ticky-ticky&amp;rdquo; profiling (for implementors)&lt;/a&gt;.</source>
          <target state="translated">有关ticky-ticky配置文件的更多信息，请参见&lt;a href=&quot;profiling#ticky-ticky&quot;&gt;使用&amp;ldquo; ticky-ticky&amp;rdquo;配置文件（对于实现者）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90f12f7b9c44042f6fe71df1a74617adb00702bb" translate="yes" xml:space="preserve">
          <source>For more information on using the API, as well as more samples and references, please see &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;this Haskell.org wiki page&lt;/a&gt;.</source>
          <target state="translated">有关使用API​​的更多信息以及更多示例和参考，请参见&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/As_a_library&quot;&gt;Haskell.org Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90ef63ab6766f7302158ada5c6e4dcb9f048e311" translate="yes" xml:space="preserve">
          <source>For more information you can refer to the &lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;original paper&lt;/a&gt; that serves as the basis for this libraries design: /The Design of a Pretty-printing Library/ by John Hughes, in Advanced Functional Programming, 1995.</source>
          <target state="translated">有关更多信息，您可以参考作为该库设计基础的&lt;a href=&quot;http://belle.sourceforge.net/doc/hughes95design.pdf&quot;&gt;原始论文&lt;/a&gt;：/ John Hughes的《漂亮印刷库的设计》，发表于Advanced Functional Programming，1995年。</target>
        </trans-unit>
        <trans-unit id="c0bed00e62b5493248939b4aa33a94f717129c1a" translate="yes" xml:space="preserve">
          <source>For more information, please visit the new SYB wiki: &lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请访问新的SYB Wiki：&lt;a href=&quot;http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB&quot;&gt;http&lt;/a&gt; : //www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB。</target>
        </trans-unit>
        <trans-unit id="11f58187631ea148f4d89e652dfc9bc68f732d9a" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类的文档。</target>
        </trans-unit>
        <trans-unit id="d3bff78a356bfb09cb0493c71dac3667a53fc420" translate="yes" xml:space="preserve">
          <source>For more information, refer to the documentation for the &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class. @since 4.9.0.0</source>
          <target state="translated">有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类的文档。@自4.9.0.0起</target>
        </trans-unit>
        <trans-unit id="8573bf99480b0bd0d6d5a2fda62633bf25a04224" translate="yes" xml:space="preserve">
          <source>For more motivation and details please refer to the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt; page or the &lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;original paper&lt;/a&gt;.</source>
          <target state="translated">有关更多动机和细节，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/DeferErrorsToRuntime&quot;&gt;Wiki&lt;/a&gt;页面或&lt;a href=&quot;http://dreixel.net/research/pdf/epdtecp.pdf&quot;&gt;原始论文&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b784e8618e297958090335defe46f4624f38965b" translate="yes" xml:space="preserve">
          <source>For most application, it should suffice to instead use the following &lt;code&gt;Settings&lt;/code&gt; flags:</source>
          <target state="translated">对于大多数应用程序，只需使用以下 &lt;code&gt;Settings&lt;/code&gt; 标志就足够了：</target>
        </trans-unit>
        <trans-unit id="ff5273016b7cb616c8b49961a6a41e99d096cb1a" translate="yes" xml:space="preserve">
          <source>For most applications (e.g., a REPL), &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; should have the correct effect.</source>
          <target state="translated">对于大多数应用程序（例如REPL）， &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 应该具有正确的效果。</target>
        </trans-unit>
        <trans-unit id="311f2e122e6dc16e2237dcd6b98b5829a7cc728a" translate="yes" xml:space="preserve">
          <source>For most array types, this operation is O(&lt;em&gt;n&lt;/em&gt;) where &lt;em&gt;n&lt;/em&gt; is the size of the array. However, the diffarray package provides an array type for which this operation has complexity linear in the number of updates.</source>
          <target state="translated">对于大多数数组类型，此操作为O（&lt;em&gt;n&lt;/em&gt;），其中&lt;em&gt;n&lt;/em&gt;是数组的大小。但是，diffarray包提供了一种数组类型，对此操作，其操作复杂度与更新次数呈线性关系。</target>
        </trans-unit>
        <trans-unit id="4b9cb8cf6aa6594114627e9c8f2d2cd6fbe2360a" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="25d34b5c0599445985c48feed3e52ab547a8c854" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;ghc-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="afe02a91645487a5cca5e4dc2b2da47de7589838" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="6484245051d629100f2583ede948c431b601c733" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="fe6e0410468523c927a0d7a9f8ddef7668228bfb" translate="yes" xml:space="preserve">
          <source>For most types, the default definition for &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; will be used, but the function is included in the class definition so that an optimized version can be provided for specific types.</source>
          <target state="translated">对于大多数类型，将使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 的默认定义，但该函数包含在类定义中，以便可以为特定类型提供优化版本。</target>
        </trans-unit>
        <trans-unit id="aa070a0116630a05d217085a9df4b403160dd6f8" translate="yes" xml:space="preserve">
          <source>For nested &lt;code&gt;foralls&lt;/code&gt;, e.g.</source>
          <target state="translated">对于嵌套的 &lt;code&gt;foralls&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="458047bcd2a4d374f9800d54638670eed4df239c" translate="yes" xml:space="preserve">
          <source>For newtypes, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; are always derived using the &lt;code&gt;newtype&lt;/code&gt; strategy, even without &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; enabled. (There should be no observable difference to instances derived using the stock strategy.)</source>
          <target state="translated">对于newtypes， &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; 所使用的总是衍生 &lt;code&gt;newtype&lt;/code&gt; 策略，即使没有 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 启用。（使用存量策略得出的实例应该没有明显的区别。）</target>
        </trans-unit>
        <trans-unit id="4694f0c96ed1c1078475be69652119149e496dc9" translate="yes" xml:space="preserve">
          <source>For non-essential files (e.g. cache). It uses the &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; environment variable. On non-Windows systems, the default is &lt;code&gt;~/.cache&lt;/code&gt;. On Windows, the default is &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; (e.g. &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt;). Can be considered as the user-specific equivalent of &lt;code&gt;/var/cache&lt;/code&gt;.</source>
          <target state="translated">对于非必需文件（例如，缓存）。它使用 &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 环境变量。在非Windows系统上，默认值为 &lt;code&gt;~/.cache&lt;/code&gt; 。在Windows上，默认值为 &lt;code&gt;%LOCALAPPDATA%&lt;/code&gt; （例如 &lt;code&gt;C:/Users/&lt;em&gt;&amp;lt;user&amp;gt;&lt;/em&gt;/AppData/Local&lt;/code&gt; ）。可以视为 &lt;code&gt;/var/cache&lt;/code&gt; 的用户特定等效项。</target>
        </trans-unit>
        <trans-unit id="6bb8c51cac0d107dff7666d44f386ca6ef354c70" translate="yes" xml:space="preserve">
          <source>For non-portable support of Haskell finalizers, see the &lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">有关Haskell终结器的非便携式支持，请参见&lt;a href=&quot;foreign-concurrent&quot;&gt;Foreign.Concurrent&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="33b56c18b23f9ecb1cf4345cdf08508ff77d0dd4" translate="yes" xml:space="preserve">
          <source>For open and closed type families it is OK to name the result but skip the injectivity annotation. This is not the case for associated type synonyms, where the named result without injectivity annotation will be interpreted as associated type synonym default.</source>
          <target state="translated">对于开放和封闭类型族,可以命名结果,但跳过注入性注解。对于关联类型同义词来说,情况并非如此,在这里,没有注入性注解的命名结果将被解释为关联类型同义词的默认值。</target>
        </trans-unit>
        <trans-unit id="37dc725ee9dc508be5d616956f4278bb5bbb1e54" translate="yes" xml:space="preserve">
          <source>For other any type class:</source>
          <target state="translated">对于其他任何类型的类。</target>
        </trans-unit>
        <trans-unit id="8992b141ebf84616833ad66b803c7e3a3842868f" translate="yes" xml:space="preserve">
          <source>For other documentation, refer to: &lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http://www.haskell.org/haskellwiki/Template_Haskell&lt;/a&gt;</source>
          <target state="translated">有关其他文档，请参阅：&lt;a href=&quot;http://www.haskell.org/haskellwiki/Template_Haskell&quot;&gt;http&lt;/a&gt; : //www.haskell.org/haskellwiki/Template_Haskell</target>
        </trans-unit>
        <trans-unit id="0f140c5422fa14edb971c7e4308e840e46380100" translate="yes" xml:space="preserve">
          <source>For part 1, we define a class &lt;code&gt;Encode'&lt;/code&gt;. Perhaps surprisingly, this class is parameterized over a type constructor &lt;code&gt;f&lt;/code&gt; of kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt;. This is a technicality: all the representation type constructors operate with kind &lt;code&gt;* -&amp;gt; *&lt;/code&gt; as base kind. But the type argument is never being used. This may be changed at some point in the future. The class has a single method, and we use the type we want our final function to have, but we replace the occurrences of the generic type argument &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;f p&lt;/code&gt; (where the &lt;code&gt;p&lt;/code&gt; is any argument; it will not be used).</source>
          <target state="translated">对于第1部分，我们定义一个类 &lt;code&gt;Encode'&lt;/code&gt; 。也许令人惊讶的是，此类是通过类型 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 的类型构造函数 &lt;code&gt;f&lt;/code&gt; 进行参数化的。这是一种技术性：所有表示类型构造函数都以 &lt;code&gt;* -&amp;gt; *&lt;/code&gt; 作为基本类型进行操作。但是从未使用过类型参数。将来可能会对此进行更改。该类具有单个方法，并且使用希望最终函数具有的类型，但是我们用 &lt;code&gt;f p&lt;/code&gt; 替换了泛型类型参数 &lt;code&gt;a&lt;/code&gt; 的出现（其中 &lt;code&gt;p&lt;/code&gt; 是任何参数；将不使用）。</target>
        </trans-unit>
        <trans-unit id="f87b5de1b3b5f32164f5ee5dc4fb8f8f96f8dc64" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">对于实数， &lt;code&gt;&lt;a href=&quot;ghc-num#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; （负）， &lt;code&gt;0&lt;/code&gt; （零）或 &lt;code&gt;1&lt;/code&gt; （正）。</target>
        </trans-unit>
        <trans-unit id="9e94d05b9e837b15d27a9fea860bba07c986003d" translate="yes" xml:space="preserve">
          <source>For real numbers, the &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;-1&lt;/code&gt; (negative), &lt;code&gt;0&lt;/code&gt; (zero) or &lt;code&gt;1&lt;/code&gt; (positive).</source>
          <target state="translated">对于实数， &lt;code&gt;&lt;a href=&quot;prelude#v:signum&quot;&gt;signum&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; （负）， &lt;code&gt;0&lt;/code&gt; （零）或 &lt;code&gt;1&lt;/code&gt; （正）。</target>
        </trans-unit>
        <trans-unit id="378724e14b1bb63abfcba6089e6f23a18b0dbb9a" translate="yes" xml:space="preserve">
          <source>For records with many fields, it can be tiresome to write out each field individually in a record pattern, as in</source>
          <target state="translated">对于有很多字段的记录,在记录模式中单独写出每个字段可能会很烦人,如</target>
        </trans-unit>
        <trans-unit id="7aac7c40c3604036ed41bcd7832a5e3d3aad7a7a" translate="yes" xml:space="preserve">
          <source>For single-constructor datatypes, the derived instance declarations are as shown for tuples in chapter 19, section 2 of the Haskell 2010 report: &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&lt;/a&gt;.</source>
          <target state="translated">对于单构造函数数据类型，派生的实例声明如Haskell 2010报告的第19章第2节中的元组所示：&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch19.html&quot;&gt;https&lt;/a&gt; : //www.haskell.org/onlinereport/haskell2010/haskellch19.html。</target>
        </trans-unit>
        <trans-unit id="bd08981965b6a477e0c93e10e8a2c46079dd7254" translate="yes" xml:space="preserve">
          <source>For some reason, Mingw ships with the &lt;code&gt;readline&lt;/code&gt; library, but not with the &lt;code&gt;readline&lt;/code&gt; headers. As a result, GHC (like Hugs) does not use &lt;code&gt;readline&lt;/code&gt; for interactive input on Windows. You can get a close simulation by using an emacs shell buffer!</source>
          <target state="translated">由于某些原因，Mingw附带了 &lt;code&gt;readline&lt;/code&gt; 库，但没有附带 &lt;code&gt;readline&lt;/code&gt; 标头。结果，GHC（如Hugs）在Windows 上不使用 &lt;code&gt;readline&lt;/code&gt; 进行交互式输入。您可以通过使用emacs shell缓冲区获得紧密的模拟！</target>
        </trans-unit>
        <trans-unit id="c3d65c0e9a2a6354ca7a3aa3f79014b97e396ace" translate="yes" xml:space="preserve">
          <source>For some special use cases you may want more control over which events are included. The ⟨flags⟩ is a sequence of zero or more characters indicating which classes of events to log. Currently these the classes of events that can be enabled/disabled:</source>
          <target state="translated">对于一些特殊的使用情况,您可能希望对哪些事件进行更多的控制。⟨flags⟩是一个由0个或多个字符组成的序列,表示要记录哪些类别的事件。目前,这些事件的类别可以被启用/禁用。</target>
        </trans-unit>
        <trans-unit id="6c52999f5dadb28c826189af8598c10c0d62c8c4" translate="yes" xml:space="preserve">
          <source>For some values, we only care about the lists contents, not their order,</source>
          <target state="translated">对于一些值,我们只关心列表的内容,而不是它们的顺序。</target>
        </trans-unit>
        <trans-unit id="5a30fff547bbac81b4549d50a582f44afe1ea5d2" translate="yes" xml:space="preserve">
          <source>For spark events there are two modes: sampled and fully accurate. There are various events in the life cycle of each spark, usually just creating and running, but there are some more exceptional possibilities. In the sampled mode the number of occurrences of each kind of spark event is sampled at frequent intervals. In the fully accurate mode every spark event is logged individually. The latter has a higher runtime overhead and is not enabled by default.</source>
          <target state="translated">对于火花事件有两种模式:采样和完全精确。每种火花的生命周期中都有各种事件,通常只是产生和运行,但也有一些更特殊的可能性。在采样模式下,每一种火花事件的出现次数都是以频繁的间隔进行采样。在完全精确模式下,每一个火花事件都会被单独记录。后者有较高的运行时开销,默认情况下不启用。</target>
        </trans-unit>
        <trans-unit id="8e967e8009285dc0e4dfe1b3126affb641d4d480" translate="yes" xml:space="preserve">
          <source>For technical reasons, GHCi can only support the &lt;code&gt;*&lt;/code&gt;-form for modules that are interpreted. Compiled modules and package modules can only contribute their exports to the current scope. To ensure that GHCi loads the interpreted version of a module, add the &lt;code&gt;*&lt;/code&gt; when loading the module, e.g. &lt;code&gt;:load *M&lt;/code&gt;.</source>
          <target state="translated">出于技术原因，GHCi仅对解释的模块支持 &lt;code&gt;*&lt;/code&gt; -form。编译模块和包模块只能将其导出贡献到当前作用域中。为了确保GHCI负载解释的模块的版本，添加 &lt;code&gt;*&lt;/code&gt; 加载模块，例如，当 &lt;code&gt;:load *M&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0829deec59e025f397584544c425b37ed5413ca9" translate="yes" xml:space="preserve">
          <source>For technical reasons, the bytecode compiler doesn&amp;rsquo;t interact well with one of the optimisation passes, so we have disabled optimisation when using the interpreter. This isn&amp;rsquo;t a great loss: you&amp;rsquo;ll get a much bigger win by compiling the bits of your code that need to go fast, rather than interpreting them with optimisation turned on.</source>
          <target state="translated">出于技术原因，字节码编译器无法与其中一个优化过程很好地交互，因此我们在使用解释器时禁用了优化。这不是很大的损失：通过编译需要快速执行的代码片段，而不是在启用优化的情况下解释它们，您将获得更大的胜利。</target>
        </trans-unit>
        <trans-unit id="f3841d95008ee269104a63c61bf0120449a66e76" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Bad Int&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">对于派生的 &lt;code&gt;Bad Int&lt;/code&gt; 实例，GHC需要生成以下内容：</target>
        </trans-unit>
        <trans-unit id="4eaf58a3a8ca8af861b90aa91e9b822949a939a3" translate="yes" xml:space="preserve">
          <source>For the derived &lt;code&gt;Ex&lt;/code&gt; instance, GHC would need to generate something like this:</source>
          <target state="translated">对于派生的 &lt;code&gt;Ex&lt;/code&gt; 实例，GHC需要生成以下内容：</target>
        </trans-unit>
        <trans-unit id="ffa588946311197a1b2c4ff685a498c96580d6ce" translate="yes" xml:space="preserve">
          <source>For the first trust definition the trust guarantee is provided by GHC through the restrictions imposed by the safe language. For the second definition of trust, the guarantee is provided initially by the module author. The client C then establishes that they trust the module author by indicating they trust the package the module resides in. This trust chain is required as GHC provides no guarantee for &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; compiled modules.</source>
          <target state="translated">对于第一个信任定义，信任保证由GHC通过安全语言施加的限制提供。对于信任的第二种定义，保证最初由模块作者提供。然后，客户端C通过指示他们信任该模块所驻留的包来建立他们对模块作者的信任。由于GHC不为&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;编译模块提供任何保证，因此需要此信任链。</target>
        </trans-unit>
        <trans-unit id="32cc9253b78847faffaa8325c66bc83a4331016c" translate="yes" xml:space="preserve">
          <source>For the string data itself, both &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ByteString&lt;/code&gt; use one byte per element, rounded up to the nearest word. For example, including the overheads, a length 10 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; would take &lt;code&gt;16 + 12 = 28&lt;/code&gt; bytes on a 32bit platform and &lt;code&gt;32 + 16 = 48&lt;/code&gt; bytes on a 64bit platform.</source>
          <target state="translated">对于字符串数据本身， &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;ByteString&lt;/code&gt; 每个元素都使用一个字节，四舍五入到最接近的单词。例如，包括开销在内，长度为10的 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 在32位平台上将为 &lt;code&gt;16 + 12 = 28&lt;/code&gt; 个字节，而在64位平台上则为 &lt;code&gt;32 + 16 = 48&lt;/code&gt; 个字节。</target>
        </trans-unit>
        <trans-unit id="2dfb67f7f13b2578a8003b1f16579b450e09d029" translate="yes" xml:space="preserve">
          <source>For these monad transformers, &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a natural transformation in the category of monads, i.e. for any monad transformation &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt;,</source>
          <target state="translated">对于这些monad变压器， &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 是monad 类别中的自然变换，即对于任何monad变换 &lt;code&gt;t :: M a -&amp;gt; N a&lt;/code&gt; a- &amp;gt; N a，</target>
        </trans-unit>
        <trans-unit id="67e40ed20b98dd2eb671037144a5a29659a48929" translate="yes" xml:space="preserve">
          <source>For these reasons GHC provides an external API to &lt;code&gt;tryPutMVar&lt;/code&gt;, &lt;code&gt;hs_try_putmvar&lt;/code&gt;, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</source>
          <target state="translated">由于这些原因，GHC为 &lt;code&gt;tryPutMVar&lt;/code&gt; 和 &lt;code&gt;hs_try_putmvar&lt;/code&gt; 提供了一个外部API ，您可以使用该API 廉价而异步地从C / C ++唤醒Haskell线程。</target>
        </trans-unit>
        <trans-unit id="9b01d6140708791731ce8e176317b02d04ed594b" translate="yes" xml:space="preserve">
          <source>For this reason we should be cautious when interpretting the source locations provided by GDB. While these locations will usually be in some sense &amp;ldquo;correct&amp;rdquo;, they aren&amp;rsquo;t always useful. This is why profiling tools targetting Haskell should supplement the standard source location information with GHC-specific annotations (emitted with &lt;code&gt;-g2&lt;/code&gt;) when assigning costs.</source>
          <target state="translated">因此，在解释GDB提供的源位置时，我们应该谨慎。尽管这些位置在某种意义上通常是&amp;ldquo;正确的&amp;rdquo;，但它们并不总是有用的。这就是为什么在分配成本时，针对Haskell的性能分析工具应在GHC特定注释（由 &lt;code&gt;-g2&lt;/code&gt; 发出）中补充标准源位置信息。</target>
        </trans-unit>
        <trans-unit id="cacc0718d7e72594c1a05f793c384e9988e904e4" translate="yes" xml:space="preserve">
          <source>For three-part GHC version numbers &lt;code&gt;x.y.z&lt;/code&gt;, the value of &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; is the integer ⟨z⟩.</source>
          <target state="translated">对于三部分的GHC版本号 &lt;code&gt;x.y.z&lt;/code&gt; ， &lt;code&gt;__GLASGOW_HASKELL_PATCHLEVEL1__&lt;/code&gt; 的值是整数⟨z⟩。</target>
        </trans-unit>
        <trans-unit id="188a9697d8960ecca4fddfef544f2b460160723f" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="3ada1c90cd5232324681478bf68909f9821cd1f0" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="477f18a8cee4f79bac4ee3f97a03e846b9653542" translate="yes" xml:space="preserve">
          <source>For tuples, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; constraint on &lt;code&gt;a&lt;/code&gt; determines how the first values merge. For example, &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s concatenate:</source>
          <target state="translated">对于元组，在 &lt;code&gt;&lt;a href=&quot;prelude#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 上约束 &lt;code&gt;a&lt;/code&gt; 确定第一值是如何合并。例如， &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 串联：</target>
        </trans-unit>
        <trans-unit id="7016d35532abd78914b16b8e9e5320cbf10c3da6" translate="yes" xml:space="preserve">
          <source>For type-level lists of &lt;em&gt;two or more elements&lt;/em&gt;, such as the signature of &lt;code&gt;foo2&lt;/code&gt; above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in &lt;code&gt;foo0&lt;/code&gt; and &lt;code&gt;foo1&lt;/code&gt;), the quote is required, because the types &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[Int]&lt;/code&gt; have existing meanings in Haskell.</source>
          <target state="translated">对于&lt;em&gt;两个或多个元素的&lt;/em&gt;类型级别列表，例如上面的 &lt;code&gt;foo2&lt;/code&gt; 的签名，可以省略引号，因为含义是明确的。但是对于一或零个元素的列表（如 &lt;code&gt;foo0&lt;/code&gt; 和 &lt;code&gt;foo1&lt;/code&gt; ），必须使用引号，因为类型 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;[Int]&lt;/code&gt; 在Haskell中具有现有含义。</target>
        </trans-unit>
        <trans-unit id="f9d5f6ee9e1d0773bd91e69a976df850879bd39d" translate="yes" xml:space="preserve">
          <source>For types and classes, GHCi also summarises instances that mention them. To avoid showing irrelevant information, an instance is shown only if (a) its head mentions ⟨name⟩, and (b) all the other things mentioned in the instance are in scope (either qualified or otherwise) as a result of a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:module&quot;&gt;&lt;code&gt;:module&lt;/code&gt;&lt;/a&gt; commands.</source>
          <target state="translated">对于类型和类，GHCi还汇总了提及它们的实例。为了避免显示不相关的信息，仅在以下情况下显示一个实例：（a）其标题提到&amp;ldquo;名称&amp;rdquo;，并且（b）由于&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;的结果，该实例中提及的所有其他内容都在范围内（限定或其他）或&lt;a href=&quot;#ghci-cmd-:module&quot;&gt; &lt;code&gt;:module&lt;/code&gt; &lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="47016a9c155d56e31c98a5182e288d8d66335bae" translate="yes" xml:space="preserve">
          <source>For unary constructors</source>
          <target state="translated">对于单利构造体</target>
        </trans-unit>
        <trans-unit id="3804078f78b2c6305b48a6307a75661e75a4d323" translate="yes" xml:space="preserve">
          <source>For unbounded types like &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 这样的无界类型， &lt;code&gt;&lt;a href=&quot;data-bits#v:rotate&quot;&gt;rotate&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;data-bits#v:shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4299789099cbf566592e41318a28abf099452da3" translate="yes" xml:space="preserve">
          <source>For use with GHCi, each library should have an object file too. The name of the object file does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;lib&lt;/code&gt; prefix, and has the normal object suffix for your platform.</source>
          <target state="translated">为了与GHCi一起使用，每个库也应该有一个目标文件。目标文件的名称并&lt;em&gt;没有&lt;/em&gt;拥有 &lt;code&gt;lib&lt;/code&gt; 前缀，并具有所用平台的正常目标后缀。</target>
        </trans-unit>
        <trans-unit id="2630e9cec4ca5b11b5ae4aa835141d30d2fd8d21" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;n&lt;/code&gt; greater than 1, we use &lt;code&gt;par&lt;/code&gt; to spark a thread to evaluate &lt;code&gt;nfib (n-1)&lt;/code&gt;, and then we use &lt;code&gt;pseq&lt;/code&gt; to force the parent thread to evaluate &lt;code&gt;nfib (n-2)&lt;/code&gt; before going on to add together these two subexpressions. In this divide-and-conquer approach, we only spark a new thread for one branch of the computation (leaving the parent to evaluate the other branch). Also, we must use &lt;code&gt;pseq&lt;/code&gt; to ensure that the parent will evaluate &lt;code&gt;n2&lt;/code&gt;&lt;em&gt;before&lt;/em&gt;&lt;code&gt;n1&lt;/code&gt; in the expression &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt;. It is not sufficient to reorder the expression as &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt;, because the compiler may not generate code to evaluate the addends from left to right.</source>
          <target state="translated">对于大于1 的 &lt;code&gt;n&lt;/code&gt; 值，我们使用 &lt;code&gt;par&lt;/code&gt; 引发一个线程来评估 &lt;code&gt;nfib (n-1)&lt;/code&gt; ，然后使用 &lt;code&gt;pseq&lt;/code&gt; 强制父线程评估 &lt;code&gt;nfib (n-2)&lt;/code&gt; 然后再将这两个变量相加子表达式。在这种&amp;ldquo;分而治之&amp;rdquo;的方法中，我们仅为计算的一个分支触发一个新线程（让父级对另一个分支求值）。此外，我们必须使用 &lt;code&gt;pseq&lt;/code&gt; 以确保母公司将评估 &lt;code&gt;n2&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt; &lt;code&gt;n1&lt;/code&gt; 表达式 &lt;code&gt;(n1 + n2 + 1)&lt;/code&gt; 。将表达式重新排序为 &lt;code&gt;(n2 + n1 + 1)&lt;/code&gt; 是不够的，因为编译器可能不会生成从左到右评估加数的代码。</target>
        </trans-unit>
        <trans-unit id="833cc29e3ca3cd40dea4e5990721a0c2c0e6e2a7" translate="yes" xml:space="preserve">
          <source>For version &lt;code&gt;x.y.z&lt;/code&gt; of GHC, the value of &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; is the integer ⟨xyy⟩ (if ⟨y⟩ is a single digit, then a leading zero is added, so for example in version 6.2 of GHC, &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt;). More information in &lt;a href=&quot;intro#version-numbering&quot;&gt;GHC version numbering policy&lt;/a&gt;.</source>
          <target state="translated">对于GHC的 &lt;code&gt;x.y.z&lt;/code&gt; 版本， &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 的值是整数⟨xyy⟩（如果⟩y⟨是一位数字，则添加前导零，因此例如在GHC的6.2版本中， &lt;code&gt;__GLASGOW_HASKELL__==602&lt;/code&gt; ）。有关&lt;a href=&quot;intro#version-numbering&quot;&gt;GHC版本编号策略的&lt;/a&gt;更多信息。</target>
        </trans-unit>
        <trans-unit id="9f28be70ee0e5b943be20d61fc496445d3c212bd" translate="yes" xml:space="preserve">
          <source>Force GHC to inline a value.</source>
          <target state="translated">强制GHC内联一个值。</target>
        </trans-unit>
        <trans-unit id="a7d87bafad299b2161dda9a58e63b3f96665d77f" translate="yes" xml:space="preserve">
          <source>Force a &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; to normal form.</source>
          <target state="translated">强制将 &lt;code&gt;&lt;a href=&quot;data-typeable#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 转换为正常形式。</target>
        </trans-unit>
        <trans-unit id="b3e1df0f2bdfd332765ff5812d39df923d34d2d6" translate="yes" xml:space="preserve">
          <source>Force the entries whose keys are missing from the other map and otherwise preserve them unchanged.</source>
          <target state="translated">强制从另一张地图上删除键值缺失的条目,否则保留不变。</target>
        </trans-unit>
        <trans-unit id="50ca9997d86f8ded3e64badd3d8a285f7f58295a" translate="yes" xml:space="preserve">
          <source>ForceSpecConstr</source>
          <target state="translated">ForceSpecConstr</target>
        </trans-unit>
        <trans-unit id="316d9703cf033d39685405519176248df170f94f" translate="yes" xml:space="preserve">
          <source>Foreign</source>
          <target state="translated">Foreign</target>
        </trans-unit>
        <trans-unit id="c0146d93cdce22c9be8cd3f9cab8d08969353dc4" translate="yes" xml:space="preserve">
          <source>Foreign formats supported by GHC via TH</source>
          <target state="translated">GHC通过TH支持的国外格式</target>
        </trans-unit>
        <trans-unit id="7f40d160ba2387e27fcd81cc062ef6d270959462" translate="yes" xml:space="preserve">
          <source>Foreign functions that use UTF-16 internally may return indices in units of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; instead of characters. These functions may safely be used with such indices, as they will adjust offsets if necessary to preserve the validity of a Unicode string.</source>
          <target state="translated">在内部使用UTF-16的外部函数可能会以 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 为单位而不是字符返回索引。这些函数可以安全地与此类索引一起使用，因为在必要时它们将调整偏移量以保持Unicode字符串的有效性。</target>
        </trans-unit>
        <trans-unit id="1286675988bccc3af5f10d1742d504ae15e29428" translate="yes" xml:space="preserve">
          <source>Foreign marshalling support for CStrings with configurable encodings</source>
          <target state="translated">通过可配置的编码支持CStrings的国外集结。</target>
        </trans-unit>
        <trans-unit id="0859bd97836968ae374d07116e3dc9cd1c792332" translate="yes" xml:space="preserve">
          <source>Foreign.C.Error</source>
          <target state="translated">Foreign.C.Error</target>
        </trans-unit>
        <trans-unit id="690f9c43315bf0f53c59f0ead7261289984f80cc" translate="yes" xml:space="preserve">
          <source>Foreign.C.String</source>
          <target state="translated">Foreign.C.String</target>
        </trans-unit>
        <trans-unit id="0d8c0c0c869725d3e5a290ea1bd0154f90329b54" translate="yes" xml:space="preserve">
          <source>Foreign.C.Types</source>
          <target state="translated">Foreign.C.Types</target>
        </trans-unit>
        <trans-unit id="7d97c94339d1338677ead19d873092b037a681ee" translate="yes" xml:space="preserve">
          <source>Foreign.Concurrent</source>
          <target state="translated">Foreign.Concurrent</target>
        </trans-unit>
        <trans-unit id="ca33d0224eada8a62673063ebb4beeb1d5c364b8" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr</source>
          <target state="translated">Foreign.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="fec1ff9f155f7aecb8a9c9afbbd7c199f0ad0a4d" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Safe</source>
          <target state="translated">Foreign.ForeignPtr.Safe</target>
        </trans-unit>
        <trans-unit id="f69294eb7e08c8d22462d5d33a8ed6a7e1d095e1" translate="yes" xml:space="preserve">
          <source>Foreign.ForeignPtr.Unsafe</source>
          <target state="translated">Foreign.ForeignPtr.Unsafe</target>
        </trans-unit>
        <trans-unit id="25bc28e29c71c1f9e77e3144861913407d39a05a" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal</source>
          <target state="translated">Foreign.Marshal</target>
        </trans-unit>
        <trans-unit id="7d1de99ecec974a4cc06846997a5642ce7e5207e" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Alloc</source>
          <target state="translated">Foreign.Marshal.Alloc</target>
        </trans-unit>
        <trans-unit id="34878c43ce6c0c1af86d41cd9921a4ee5f245a03" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Array</source>
          <target state="translated">Foreign.Marshal.Array</target>
        </trans-unit>
        <trans-unit id="92e3167a907bdc1222dc2d026cf2ba11246d8dc3" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Error</source>
          <target state="translated">Foreign.Marshal.Error</target>
        </trans-unit>
        <trans-unit id="8a7a411fa1f5af48f3df4c5bc1f61cb7696fe119" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Pool</source>
          <target state="translated">Foreign.Marshal.Pool</target>
        </trans-unit>
        <trans-unit id="7b25d01718919e3ce39586acacb255d2ed0d2a1f" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Safe</source>
          <target state="translated">Foreign.Marshal.Safe</target>
        </trans-unit>
        <trans-unit id="7c7103fd359ba066b392b41f8f6b0763350b3734" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Unsafe</source>
          <target state="translated">Foreign.Marshal.Unsafe</target>
        </trans-unit>
        <trans-unit id="af4a982e3ee46919384a0fa17fa230e3fcff9621" translate="yes" xml:space="preserve">
          <source>Foreign.Marshal.Utils</source>
          <target state="translated">Foreign.Marshal.Utils</target>
        </trans-unit>
        <trans-unit id="3223be426d0cdd1356fd2286241936ef6d3776c4" translate="yes" xml:space="preserve">
          <source>Foreign.Ptr</source>
          <target state="translated">Foreign.Ptr</target>
        </trans-unit>
        <trans-unit id="5027f6a00f24a331a0a2c00858c48833746f143a" translate="yes" xml:space="preserve">
          <source>Foreign.StablePtr</source>
          <target state="translated">Foreign.StablePtr</target>
        </trans-unit>
        <trans-unit id="819868f38d58136fcaa5d12146fb0f0c1e93f966" translate="yes" xml:space="preserve">
          <source>Foreign.Storable</source>
          <target state="translated">Foreign.Storable</target>
        </trans-unit>
        <trans-unit id="f2e5ff4797622913221ace3c0f488aecb6763737" translate="yes" xml:space="preserve">
          <source>ForeignFunctionInterface</source>
          <target state="translated">ForeignFunctionInterface</target>
        </trans-unit>
        <trans-unit id="c2ad3b41dcfdfcb4cdc30a8b1047888336b299be" translate="yes" xml:space="preserve">
          <source>ForeignHANDLE</source>
          <target state="translated">ForeignHANDLE</target>
        </trans-unit>
        <trans-unit id="15867b934b9041f19d00947d6efc59ac6319cf3c" translate="yes" xml:space="preserve">
          <source>ForeignHValue</source>
          <target state="translated">ForeignHValue</target>
        </trans-unit>
        <trans-unit id="4c81499005daf21faf5cf91d16a0534956f2909d" translate="yes" xml:space="preserve">
          <source>ForeignPtr</source>
          <target state="translated">ForeignPtr</target>
        </trans-unit>
        <trans-unit id="c624eaa10676fb999d8a5b6feb05f3b52f934560" translate="yes" xml:space="preserve">
          <source>ForeignPtrContents</source>
          <target state="translated">ForeignPtrContents</target>
        </trans-unit>
        <trans-unit id="6f2e78934322ebeb373ed863a4f0571cb731dad3" translate="yes" xml:space="preserve">
          <source>ForeignRef</source>
          <target state="translated">ForeignRef</target>
        </trans-unit>
        <trans-unit id="625b683a019ce7ae97d5cf12c7b91734ec7d1897" translate="yes" xml:space="preserve">
          <source>ForeignSrcLang</source>
          <target state="translated">ForeignSrcLang</target>
        </trans-unit>
        <trans-unit id="f41c4e4dab0b44d75dad0c04a0156d326c95b774" translate="yes" xml:space="preserve">
          <source>Forest</source>
          <target state="translated">Forest</target>
        </trans-unit>
        <trans-unit id="210c313feac20bb8ddb1dd7cbec2b356b3072a0a" translate="yes" xml:space="preserve">
          <source>Fork a thread and call the supplied function when the thread is about to terminate, with an exception or a returned value. The function is called with asynchronous exceptions masked.</source>
          <target state="translated">分叉一个线程,并在线程即将终止时调用所提供的函数,出现异常或返回值。该函数的调用会屏蔽异步异常。</target>
        </trans-unit>
        <trans-unit id="b1cbaa12a8b3d860d7a7e72293e672a2ff7acd71" translate="yes" xml:space="preserve">
          <source>Forking and executing</source>
          <target state="translated">分组和执行</target>
        </trans-unit>
        <trans-unit id="4017d24e3f2f76b82ff8d264b0bfa897d184d50d" translate="yes" xml:space="preserve">
          <source>Forking and killing threads.</source>
          <target state="translated">分叉和杀线。</target>
        </trans-unit>
        <trans-unit id="062c8f7ca75a391f115434ac85e20074eaf4a4b6" translate="yes" xml:space="preserve">
          <source>Forking and suchlike</source>
          <target state="translated">叉车等</target>
        </trans-unit>
        <trans-unit id="142946f950e6a3c69461157ecd922afefd29abfb" translate="yes" xml:space="preserve">
          <source>Form a complex number from polar components of magnitude and phase.</source>
          <target state="translated">由幅度和相位的极性分量形成复数。</target>
        </trans-unit>
        <trans-unit id="a60392868ec861fd3b4efe2f9b78306da95d0a07" translate="yes" xml:space="preserve">
          <source>Formally speaking, in Haskell 98, an entity (function, type or class) in a program is uniquely identified by the pair of the module name in which it is defined and its name. In GHC, an entity is uniquely defined by a triple: package, module, and name.</source>
          <target state="translated">正式地说,在 Haskell 98 中,程序中的一个实体(函数、类型或类)是由定义它的模块名和它的名称这对组合来唯一识别的。在GHC中,一个实体是由一个三联:包、模块和名称来唯一定义的。</target>
        </trans-unit>
        <trans-unit id="f76337fdd96b77e407773d674b30b0bcd18c1c85" translate="yes" xml:space="preserve">
          <source>Formally, the class &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; represents a bifunctor from &lt;code&gt;Hask&lt;/code&gt; -&amp;gt; &lt;code&gt;Hask&lt;/code&gt;.</source>
          <target state="translated">形式上，类 &lt;code&gt;&lt;a href=&quot;data-bifunctor#t:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; 表示从 &lt;code&gt;Hask&lt;/code&gt; - &amp;gt; &lt;code&gt;Hask&lt;/code&gt; 开始的bifunctor。</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="817d72cb0e35af2d4da048907c1e9f5d6dc84fe4" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 格式化为行列表。</target>
        </trans-unit>
        <trans-unit id="9b3c1914896872682c2c5207b9848f7bd13b8136" translate="yes" xml:space="preserve">
          <source>Format a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; as a list of lines.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 格式化为行列表。</target>
        </trans-unit>
        <trans-unit id="64f559e1932e1e1e55a815f201bd5318c25248c5" translate="yes" xml:space="preserve">
          <source>Format a variable number of arguments with the C-style formatting string.</source>
          <target state="translated">用C式格式化字符串格式化一个可变数量的参数。</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">格式字符串</target>
        </trans-unit>
        <trans-unit id="15a38fe668d67202702d0adb7731f3ab46da832d" translate="yes" xml:space="preserve">
          <source>Format string according to &lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;http://tools.ietf.org/html/rfc822#section-5&quot;&gt;RFC822&lt;/a&gt;格式化字符串。</target>
        </trans-unit>
        <trans-unit id="c69b10975ea22ae776aa724f607ec9f6aa5721da" translate="yes" xml:space="preserve">
          <source>Format string.</source>
          <target state="translated">格式字符串。</target>
        </trans-unit>
        <trans-unit id="c49ce58749cd62ae589b86a35e201efa147e3749" translate="yes" xml:space="preserve">
          <source>FormatAdjustment</source>
          <target state="translated">FormatAdjustment</target>
        </trans-unit>
        <trans-unit id="70e56ae13abeac549bcfdb5f59450b6d50c08e51" translate="yes" xml:space="preserve">
          <source>FormatExtension</source>
          <target state="translated">FormatExtension</target>
        </trans-unit>
        <trans-unit id="5d785a947d237d49fab80da22e92f51d9955949e" translate="yes" xml:space="preserve">
          <source>FormatParse</source>
          <target state="translated">FormatParse</target>
        </trans-unit>
        <trans-unit id="b72b753c33b18ecb90ec05cd82bed66f783d6a0c" translate="yes" xml:space="preserve">
          <source>FormatSign</source>
          <target state="translated">FormatSign</target>
        </trans-unit>
        <trans-unit id="7e09c6d5d576e97515cc176e731476beaa374961" translate="yes" xml:space="preserve">
          <source>FormatTime</source>
          <target state="translated">FormatTime</target>
        </trans-unit>
        <trans-unit id="2a8d33f179c3fdae21d8031b20bfc9d0ae643b20" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="0565c40664395019883a78394d3992cdd6a29f2a" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="7e70e56ba2ac14918e7e20dbc0ecdc4f08e831a7" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="f4f8c93e825cbbd257bef8a02316190482d9eebc" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 数值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="99b405a8b0c3cbb2780273aefe5ba19eb6dfc98f" translate="yes" xml:space="preserve">
          <source>Formatter for &lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 值的格式化程序。</target>
        </trans-unit>
        <trans-unit id="1fb27c72113587f58e32eab2d4c73f0ebb454ce4" translate="yes" xml:space="preserve">
          <source>Formatting dumps</source>
          <target state="translated">格式化转储</target>
        </trans-unit>
        <trans-unit id="052cfbf508f19822df3fa5723c6e45d70e424a82" translate="yes" xml:space="preserve">
          <source>Formatting numbers as text</source>
          <target state="translated">将数字格式化为文本</target>
        </trans-unit>
        <trans-unit id="9756f760957e76b727a94e2c4ebba6cd0fc0c583" translate="yes" xml:space="preserve">
          <source>Formatting of numbers as ASCII text.</source>
          <target state="translated">将数字的格式化为ASCII文本。</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="deab3e00883d05a243bf5b0e77d440ef22fdfed1" translate="yes" xml:space="preserve">
          <source>Forms the ratio of two integral numbers.</source>
          <target state="translated">形成两个整数的比。</target>
        </trans-unit>
        <trans-unit id="63d9155e692b47f7489ea16b510f66604795ffc2" translate="yes" xml:space="preserve">
          <source>Fortunately GHC provides two workarounds.</source>
          <target state="translated">幸运的是,GHC提供了两种变通方法。</target>
        </trans-unit>
        <trans-unit id="3285674b1fed9c0d76a5d4be734aa793887b9b9c" translate="yes" xml:space="preserve">
          <source>Fortunately, the debugger includes a generic printing command, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, which can inspect the actual runtime value of a variable and attempt to reconstruct its type. If we try it on &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">幸运的是，调试器包括一个通用的打印命令&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;，它可以检查变量的实际运行时值并尝试重构其类型。如果我们尝试在 &lt;code&gt;left&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5de5f3adc837b664b0c550c9600b073ca7c029bb" translate="yes" xml:space="preserve">
          <source>Fractional</source>
          <target state="translated">Fractional</target>
        </trans-unit>
        <trans-unit id="4ee506c817db93cddd17a9bfc7e90e7929ba9ac1" translate="yes" xml:space="preserve">
          <source>Fractional division.</source>
          <target state="translated">小数除法。</target>
        </trans-unit>
        <trans-unit id="b7f4445862e6ae9531f4b6c20b5111d59a0f6376" translate="yes" xml:space="preserve">
          <source>Fractional literals are handled in just the same way, except that the translation is &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt;.</source>
          <target state="translated">小数文字的处理方式相同，不同之处在于翻译是 &lt;code&gt;fromRational (3.68::Rational)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c28c0e5aed14aa92c66ee9d85b73c91926a063b" translate="yes" xml:space="preserve">
          <source>Fractional numbers, supporting real division.</source>
          <target state="translated">小数,支持实除。</target>
        </trans-unit>
        <trans-unit id="82bc6ab69601270775fa67172582c91fb0a4a8cd" translate="yes" xml:space="preserve">
          <source>Free a block of memory that was allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; or any of the &lt;code&gt;new&lt;/code&gt;&lt;em&gt;X&lt;/em&gt; functions in &lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt; or &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;.</source>
          <target state="translated">释放使用&lt;a href=&quot;foreign-marshal-array&quot;&gt;Foreign.Marshal.Array&lt;/a&gt;或&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String中的&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:mallocBytes&quot;&gt;mallocBytes&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; 或任何 &lt;code&gt;new&lt;/code&gt; &lt;em&gt;X&lt;/em&gt;函数分配的内存块。</target>
        </trans-unit>
        <trans-unit id="99ee535db19c7fed33ade7d6567514f1b90cbd2f" translate="yes" xml:space="preserve">
          <source>Free data previously created by &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">先前由 &lt;code&gt;&lt;a href=&quot;ghci-message#v:PrepFFI&quot;&gt;PrepFFI&lt;/a&gt;&lt;/code&gt; 创建的免费数据</target>
        </trans-unit>
        <trans-unit id="4149e5ff6e145e457b073182334b5e7994374fef" translate="yes" xml:space="preserve">
          <source>Free the cached debug data.</source>
          <target state="translated">释放缓存的调试数据。</target>
        </trans-unit>
        <trans-unit id="835a9413b3500f88ebd65d3f3a099585661ce5a1" translate="yes" xml:space="preserve">
          <source>Freeze a call-stack, preventing any further call-sites from being appended.</source>
          <target state="translated">冻结一个呼叫栈,防止任何进一步的呼叫站点被添加。</target>
        </trans-unit>
        <trans-unit id="d77d8d6f00b87c26b8cacf7082e9df15e70c77ad" translate="yes" xml:space="preserve">
          <source>Freeze a mutable array. Do not mutate the &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; afterwards!</source>
          <target state="translated">冻结可变数组。之后不要变异 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="3cbf8b26c0873962d81de4914650cb76bb9b807d" translate="yes" xml:space="preserve">
          <source>Freeze the stack at the given &lt;code&gt;CallStack&lt;/code&gt;, preventing any further call-sites from being pushed onto it.</source>
          <target state="translated">在给定的 &lt;code&gt;CallStack&lt;/code&gt; 上冻结堆栈，以防止将任何其他呼叫站点压入堆栈。</target>
        </trans-unit>
        <trans-unit id="b9fc39f5344fe15184815d93e0ed318d916cfe42" translate="yes" xml:space="preserve">
          <source>Fresh names</source>
          <target state="translated">新名字</target>
        </trans-unit>
        <trans-unit id="d166e844a3f3f87149cc4f866eb998e9a751c72a" translate="yes" xml:space="preserve">
          <source>Friday</source>
          <target state="translated">Friday</target>
        </trans-unit>
        <trans-unit id="37dda3a9ea66f14ada71778600674c8b446efe85" translate="yes" xml:space="preserve">
          <source>From Ascending Lists</source>
          <target state="translated">从升序列表</target>
        </trans-unit>
        <trans-unit id="dde237215ea6fcfcb47d350794652f262577482d" translate="yes" xml:space="preserve">
          <source>From Descending Lists</source>
          <target state="translated">从降序列表</target>
        </trans-unit>
        <trans-unit id="ea889b16fbe49283cc535ae8005c5b414dd907d0" translate="yes" xml:space="preserve">
          <source>From Unordered Lists</source>
          <target state="translated">从无序列表</target>
        </trans-unit>
        <trans-unit id="ec5ec9c6f6fb9b3f12cb867846a71ac3385b451b" translate="yes" xml:space="preserve">
          <source>From a different module than &lt;code&gt;Ix&lt;/code&gt;</source>
          <target state="translated">来自与 &lt;code&gt;Ix&lt;/code&gt; 不同的模块</target>
        </trans-unit>
        <trans-unit id="773618ef2831cbf23002ae5536fc39efbf8e5287" translate="yes" xml:space="preserve">
          <source>From a semantic point of view:</source>
          <target state="translated">从语义的角度来看。</target>
        </trans-unit>
        <trans-unit id="2fc93a684c9bf3e71ee51e44f522a8a42caa44d2" translate="yes" xml:space="preserve">
          <source>From a syntactic point of view:</source>
          <target state="translated">从句法上看。</target>
        </trans-unit>
        <trans-unit id="9c95c79505f22121b4295dc89b0deedb0cd62bb1" translate="yes" xml:space="preserve">
          <source>From here, we can apply f to any argument of type Integer and observe the results.</source>
          <target state="translated">从这里,我们可以将f应用于任何类型为Integer的参数,并观察结果。</target>
        </trans-unit>
        <trans-unit id="65237fa5c41874136927b1dd87c188874f9356a5" translate="yes" xml:space="preserve">
          <source>From strings to constructors and vice versa: all data types</source>
          <target state="translated">从字符串到构造函数,反之亦然:所有数据类型。</target>
        </trans-unit>
        <trans-unit id="3b2239783ff3d9519a980e73646e0d065f0b5416" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x1==x2&lt;/code&gt; we need &lt;code&gt;Eq a&lt;/code&gt;, which is fine. From &lt;code&gt;c1==c2&lt;/code&gt; we need &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; which is &lt;em&gt;not&lt;/em&gt; fine in Haskell today; we have no way to solve such a constraint.</source>
          <target state="translated">从 &lt;code&gt;x1==x2&lt;/code&gt; 我们需要 &lt;code&gt;Eq a&lt;/code&gt; ，这很好。从 &lt;code&gt;c1==c2&lt;/code&gt; 我们需要 &lt;code&gt;Eq (f (Rose f a))&lt;/code&gt; ，这在今天的Haskell中已经&lt;em&gt;不&lt;/em&gt;适合了；我们没有办法解决这种限制。</target>
        </trans-unit>
        <trans-unit id="fe6c0223120c23453cd68ad8351310715d567d44" translate="yes" xml:space="preserve">
          <source>From the &lt;code&gt;x==x&lt;/code&gt; we need an &lt;code&gt;Eq (m Int)&lt;/code&gt; constraint, but the context only gives us a way to figure out &lt;code&gt;Ord (m a)&lt;/code&gt; constraints. But from the given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; we derive a second given constraint &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt;, and from that we can readily solve &lt;code&gt;Eq (m Int)&lt;/code&gt;. This process is very similar to the way that superclasses already work: given an &lt;code&gt;Ord a&lt;/code&gt; constraint we derive a second given &lt;code&gt;Eq a&lt;/code&gt; constraint.</source>
          <target state="translated">从 &lt;code&gt;x==x&lt;/code&gt; 我们需要一个 &lt;code&gt;Eq (m Int)&lt;/code&gt; 约束，但是上下文仅提供了一种方法来找出 &lt;code&gt;Ord (m a)&lt;/code&gt; 约束。但是从给定的约束中 &lt;code&gt;forall a. Ord a =&amp;gt; Ord (m a)&lt;/code&gt; 我们得出所有a的第二个给定约束 &lt;code&gt;forall a. Ord a =&amp;gt; Eq (m a)&lt;/code&gt; ，由此我们可以轻松求解 &lt;code&gt;Eq (m Int)&lt;/code&gt; 。这个过程与超类已经起作用的方式非常相似：给定 &lt;code&gt;Ord a&lt;/code&gt; 约束，我们派生第二个给定 &lt;code&gt;Eq a&lt;/code&gt; 约束。</target>
        </trans-unit>
        <trans-unit id="f3ccd46c83ed0ec15b20ac59a4d1d0cd9e4d0387" translate="yes" xml:space="preserve">
          <source>From the abstract:</source>
          <target state="translated">从摘要中:</target>
        </trans-unit>
        <trans-unit id="8f586d4299cff81ec9f4dbb22fee7f8864d5b6b4" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从所涉及的类型签名来看，这似乎应该分配一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 值和两个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。但是，当在GHC下启用优化的情况下编译模块时，两个中间 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值将被优化掉，并且该函数将被编译为源 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#v:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 上的单个循环。</target>
        </trans-unit>
        <trans-unit id="da1b74e67991ce47776d51a891d2ebaba67a4de6" translate="yes" xml:space="preserve">
          <source>From the type signatures involved, this looks like it should allocate one &lt;code&gt;ByteString&lt;/code&gt; value, and two &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values. However, when a module is compiled with optimisation enabled under GHC, the two intermediate &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values will be optimised away, and the function will be compiled down to a single loop over the source &lt;code&gt;ByteString&lt;/code&gt;.</source>
          <target state="translated">从所涉及的类型签名来看，这似乎应该分配一个 &lt;code&gt;ByteString&lt;/code&gt; 值和两个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值。但是，当在GHC下启用优化的情况下编译模块时，两个中间 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值将被优化掉，并且该函数将被编译为源 &lt;code&gt;ByteString&lt;/code&gt; 上的单个循环。</target>
        </trans-unit>
        <trans-unit id="6319621270065df2076d59ecc28d7681834cf630" translate="yes" xml:space="preserve">
          <source>Front-end</source>
          <target state="translated">Front-end</target>
        </trans-unit>
        <trans-unit id="d62d9c8956bde0556d61352d45bccf3852eca058" translate="yes" xml:space="preserve">
          <source>Frontend plugins, like compiler plugins, are exported by registered plugins. However, unlike compiler modules, frontend plugins are modules that export at least a single identifier &lt;code&gt;frontendPlugin&lt;/code&gt; of type &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt;.</source>
          <target state="translated">前端插件（如编译器插件）由注册的插件导出。但是，与编译器模块不同，前端插件是至少导出单个 &lt;code&gt;GhcPlugins.FrontendPlugin&lt;/code&gt; 类型的标识符 &lt;code&gt;frontendPlugin&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="276f7c7cbfb0b8260fdd7e80f21f3c6030a9846c" translate="yes" xml:space="preserve">
          <source>FsModifier</source>
          <target state="translated">FsModifier</target>
        </trans-unit>
        <trans-unit id="18e66a137332691b1ae47570995daffc16926de1" translate="yes" xml:space="preserve">
          <source>FsModifiers</source>
          <target state="translated">FsModifiers</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="a49f394638f73a008e2a6ab49d4b6e70abd398cc" translate="yes" xml:space="preserve">
          <source>FunDep</source>
          <target state="translated">FunDep</target>
        </trans-unit>
        <trans-unit id="92c04eeff3f0a42e14b1ae0e114869df39b965bc" translate="yes" xml:space="preserve">
          <source>FunLike</source>
          <target state="translated">FunLike</target>
        </trans-unit>
        <trans-unit id="5c9b47aa1445e6cb4d1617a035b8bafcb7684dca" translate="yes" xml:space="preserve">
          <source>FunPtr</source>
          <target state="translated">FunPtr</target>
        </trans-unit>
        <trans-unit id="a86870628cb20261d52821b6306ebd7581fdea16" translate="yes" xml:space="preserve">
          <source>Function composition.</source>
          <target state="translated">功能构成:</target>
        </trans-unit>
        <trans-unit id="d6054df2c54398efbf27ace21713f95c0a24cb59" translate="yes" xml:space="preserve">
          <source>Function pointers</source>
          <target state="translated">功能指针</target>
        </trans-unit>
        <trans-unit id="aa8776b9cbbee9db87d3477fe33414619d326897" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions</source>
          <target state="translated">产生一个可能完成的清单的函数</target>
        </trans-unit>
        <trans-unit id="4ddcb5893b8b93e1794a989e859abc36b85a0805" translate="yes" xml:space="preserve">
          <source>Function to produce a list of possible completions. The first argument is the line contents to the left of the word, reversed. The second argument is the word to be completed.</source>
          <target state="translated">函数,产生一个可能的补全列表。第一个参数是单词左边的行内容,反过来。第二个参数是要完成的单词。</target>
        </trans-unit>
        <trans-unit id="04d492d7d7dbe814e8a3fb4f74d794a0b412f642" translate="yes" xml:space="preserve">
          <source>Function type for handling a coding error. It is supplied with two inputs:</source>
          <target state="translated">用于处理编码错误的函数类型。它有两个输入。</target>
        </trans-unit>
        <trans-unit id="ebada3a4561582f6522218c04a731fcb04129871" translate="yes" xml:space="preserve">
          <source>Function types. The last type parameter can appear anywhere in a function type as long as it occurs in a &lt;em&gt;covariant&lt;/em&gt; position. To illustrate what this means, consider the following three examples:</source>
          <target state="translated">函数类型。最后一个类型参数可以出现在函数类型的任何地方，只要它出现在&lt;em&gt;协变&lt;/em&gt;位置即可。为了说明这意味着什么，请考虑以下三个示例：</target>
        </trans-unit>
        <trans-unit id="22db9b73edaf2bfe5c3f6cffd0e6f0cc95517cd8" translate="yes" xml:space="preserve">
          <source>Functional dependencies are implemented as described by Mark Jones in &lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]&lt;/a&gt;.</source>
          <target state="translated">如Mark Jones在&lt;a href=&quot;#jones2000&quot; id=&quot;id30&quot;&gt;[Jones2000]中&lt;/a&gt;所述，实现了功能依赖。</target>
        </trans-unit>
        <trans-unit id="ac158651392c4f27c972abe1cd7fb99ffc1d8e40" translate="yes" xml:space="preserve">
          <source>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</source>
          <target state="translated">在类声明的语法中,通过一个竖条引入功能依赖;例如</target>
        </trans-unit>
        <trans-unit id="d1cf447b9d82509bd034707bd67b6d2cd8a410e7" translate="yes" xml:space="preserve">
          <source>Functional dependencies complicate matters. Suppose we have:</source>
          <target state="translated">功能上的依赖性使问题复杂化。假设我们有:</target>
        </trans-unit>
        <trans-unit id="a36463ef34fd5c22a3ab6a871cfc8a4acae515ba" translate="yes" xml:space="preserve">
          <source>FunctionalDependencies</source>
          <target state="translated">FunctionalDependencies</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="45b91122a610c434ec9ea5fb0448a65fa46cc4f4" translate="yes" xml:space="preserve">
          <source>Functions associated with the tuple data types.</source>
          <target state="translated">与元组数据类型相关的函数。</target>
        </trans-unit>
        <trans-unit id="e2bc2aa5709cf3957c4e61f48d1f5ceec2be3360" translate="yes" xml:space="preserve">
          <source>Functions defined by the POSIX standards for manipulating and querying the file system. Names of underlying POSIX functions are indicated whenever possible. A more complete documentation of the POSIX functions together with a more detailed description of different error conditions are usually available in the system's manual pages or from &lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt; (free registration required).</source>
          <target state="translated">POSIX标准定义的用于操纵和查询文件系统的功能。尽可能指示基础POSIX函数的名称。通常，可以在系统手册页或&lt;a href=&quot;http://www.unix.org/version3/online.html&quot;&gt;http://www.unix.org/version3/online.html&lt;/a&gt;（需要免费注册）中获得关于POSIX功能的更完整文档以及对不同错误情况的更详细说明。</target>
        </trans-unit>
        <trans-unit id="ef2638ff979efc064c3b114a029ccd9016977415" translate="yes" xml:space="preserve">
          <source>Functions for converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">使用几种标准编码将 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值与 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 相互转换的函数。</target>
        </trans-unit>
        <trans-unit id="8073ea9327a4d7c6639e6bad896a175b4a67c6eb" translate="yes" xml:space="preserve">
          <source>Functions for converting lazy &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values to and from lazy &lt;code&gt;ByteString&lt;/code&gt;, using several standard encodings.</source>
          <target state="translated">使用几种标准编码将惰性 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值与惰性 &lt;code&gt;ByteString&lt;/code&gt; 相互转换的函数。</target>
        </trans-unit>
        <trans-unit id="1cbb4c1f2e7daa321ba6fcea8db0876732346830" translate="yes" xml:space="preserve">
          <source>Functions for tracing and monitoring execution.</source>
          <target state="translated">追踪和监控执行的功能。</target>
        </trans-unit>
        <trans-unit id="16479fdb416d456904dff714b27125ccc720f7ec" translate="yes" xml:space="preserve">
          <source>Functions in the module &lt;code&gt;GHC.Stack&lt;/code&gt; can be used to get the current stack and render it.</source>
          <target state="translated">&lt;code&gt;GHC.Stack&lt;/code&gt; 模块中的函数可用于获取当前堆栈并进行渲染。</target>
        </trans-unit>
        <trans-unit id="4b4538c6823abddd718b4a67c6f47e9707112536" translate="yes" xml:space="preserve">
          <source>Functions loaded from MAPI DLL</source>
          <target state="translated">从MAPI DLL加载的函数</target>
        </trans-unit>
        <trans-unit id="991363ecbdab5aa793ffe2963ab2340e55ed7869" translate="yes" xml:space="preserve">
          <source>Functions on strings</source>
          <target state="translated">字符串上的函数</target>
        </trans-unit>
        <trans-unit id="acd1d73a01569b4597b066ffad662bac0febbd6d" translate="yes" xml:space="preserve">
          <source>Functions on type literals</source>
          <target state="translated">关于类型文字的函数</target>
        </trans-unit>
        <trans-unit id="eae4e0d01438335e190495d84c53f36a1091da41" translate="yes" xml:space="preserve">
          <source>Functions that can be fused by the compiler are documented with the phrase &quot;Subject to fusion&quot;.</source>
          <target state="translated">可以被编译器融合的函数,都会用 &quot;服从融合 &quot;来记录。</target>
        </trans-unit>
        <trans-unit id="bf76ba3ead8b51a76bd5375c7610a24216c56497" translate="yes" xml:space="preserve">
          <source>Functions used frequently when reading textual data.</source>
          <target state="translated">读取文本数据时经常使用的功能。</target>
        </trans-unit>
        <trans-unit id="bf5a0c8672a8cfdd38dd0c49de54779584af909e" translate="yes" xml:space="preserve">
          <source>Functor</source>
          <target state="translated">Functor</target>
        </trans-unit>
        <trans-unit id="4e092e6221592052ff27de9c36b604a94b3b2bfa" translate="yes" xml:space="preserve">
          <source>Functor and monad classes</source>
          <target state="translated">向量和单子类</target>
        </trans-unit>
        <trans-unit id="de3a870c86fad9ae631a01eb1c00a47d95865fc9" translate="yes" xml:space="preserve">
          <source>Functors representing data structures that can be traversed from left to right.</source>
          <target state="translated">表示可以从左到右遍历的数据结构的漏斗。</target>
        </trans-unit>
        <trans-unit id="bbce868c145bac81161a114f3f858a43df4b009e" translate="yes" xml:space="preserve">
          <source>Further bindings can be added to this &lt;code&gt;let&lt;/code&gt; statement, so GHCi indicates that the next line continues the previous one by changing the prompt. Note that layout is in effect, so to add more bindings to this &lt;code&gt;let&lt;/code&gt; we have to line them up:</source>
          <target state="translated">可以在此 &lt;code&gt;let&lt;/code&gt; 语句中添加更多的绑定，因此GHCi通过更改提示指示下一行继续上一行。请注意，布局生效，所以要更多的绑定到这个 &lt;code&gt;let&lt;/code&gt; 我们不得不排队起来：</target>
        </trans-unit>
        <trans-unit id="49fac13714bb93079e42783f2bb2ccb3989a542a" translate="yes" xml:space="preserve">
          <source>Further, any definition must satisfy the following:</source>
          <target state="translated">此外,任何定义必须满足以下条件:</target>
        </trans-unit>
        <trans-unit id="08da0d9c9c42c5828b70fcadcfc0cc2b4842f426" translate="yes" xml:space="preserve">
          <source>Furthermore GHC lets you specify the way event log data (see &lt;a href=&quot;profiling#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt;) is written through a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">此外，GHC还允许您指定通过自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;写入事件日志数据（请参见&lt;a href=&quot;profiling#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt;）的方式：</target>
        </trans-unit>
        <trans-unit id="20e7c89627716c573e1aa633f5ad999d25b91e8d" translate="yes" xml:space="preserve">
          <source>Furthermore, GHC offers a lightweight annotation mechanism that you can use to annotate your source code with metadata, which you can later inspect with either the compiler API or a compiler plugin.</source>
          <target state="translated">此外,GHC还提供了一个轻量级的注释机制,你可以用元数据来注释你的源代码,以后你可以用编译器API或编译器插件来检查。</target>
        </trans-unit>
        <trans-unit id="82324c0c7e914d3c23571245dd382b3b90349133" translate="yes" xml:space="preserve">
          <source>Furthermore, GHCi will print the result of the I/O action if (and only if):</source>
          <target state="translated">此外,GHCi将打印I/O操作的结果,如果(也只有当)。</target>
        </trans-unit>
        <trans-unit id="6db505903547bc2c8bcd995bca119457f6ba82f6" translate="yes" xml:space="preserve">
          <source>Furthermore, as sketched below, you may have big problems running programs compiled using unstable interfaces.</source>
          <target state="translated">此外,如下图所示,你可能会在运行使用不稳定接口编译的程序时出现大问题。</target>
        </trans-unit>
        <trans-unit id="cb2c15d21b992fb8a453c178e3d2d2c870eaaae3" translate="yes" xml:space="preserve">
          <source>Furthermore, distinct lexical type variables stand for distinct type variables. This means that every programmer-written type signature (including one that contains free scoped type variables) denotes a &lt;em&gt;rigid&lt;/em&gt; type; that is, the type is fully known to the type checker, and no inference is involved.</source>
          <target state="translated">此外，不同的词法类型变量代表不同的类型变量。这意味着每个程序员编写的类型签名（包括一个包含自由作用域类型变量的类型签名）都表示一个&lt;em&gt;刚性&lt;/em&gt;类型。也就是说，类型对于类型检查器是完全已知的，并且不涉及任何推断。</target>
        </trans-unit>
        <trans-unit id="80b236431e261295b1f5b32062e509044fb85c6f" translate="yes" xml:space="preserve">
          <source>Furthermore, for every type constructor there is an instance that allows to coerce under the type constructor. For example, let &lt;code&gt;D&lt;/code&gt; be a prototypical type constructor (&lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt;) with three type arguments, which have roles &lt;code&gt;nominal&lt;/code&gt;, &lt;code&gt;representational&lt;/code&gt; resp. &lt;code&gt;phantom&lt;/code&gt;. Then there is an instance of the form</source>
          <target state="translated">此外，对于每个类型构造函数，都有一个实例可以强制使用该类型构造函数。例如，让 &lt;code&gt;D&lt;/code&gt; 为具有三个类型实 &lt;code&gt;newtype&lt;/code&gt; 的原型类型构造函数（ &lt;code&gt;data&lt;/code&gt; 或newtype），它们具有 &lt;code&gt;nominal&lt;/code&gt; ， &lt;code&gt;representational&lt;/code&gt; 角色。 &lt;code&gt;phantom&lt;/code&gt; 。然后有一个表格的实例</target>
        </trans-unit>
        <trans-unit id="406f927a9f4a120e269216ff8cb7178a7f5cb0c5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="dad09ada7622a5ff58effb3bd3aac868b8da28f5" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;control-monad-instances#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="6b37d25bdd8ec825cf9b78ad8552aaf509c01998" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="44ff1800f7634bcf2c0b0c914a264ded817850d3" translate="yes" xml:space="preserve">
          <source>Furthermore, the &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; operations should relate as follows:</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 操作应与以下内容相关：</target>
        </trans-unit>
        <trans-unit id="2cb5d14e799a2d7958a05582a6f9320def2c5536" translate="yes" xml:space="preserve">
          <source>Furthermore, the closing &lt;code&gt;#-}&lt;/code&gt; should start in a column to the right of the opening &lt;code&gt;{-#&lt;/code&gt;.</source>
          <target state="translated">此外，结尾的 &lt;code&gt;#-}&lt;/code&gt; 应该在开头 &lt;code&gt;{-#&lt;/code&gt; 右边的一列中开始。</target>
        </trans-unit>
        <trans-unit id="fa16c9671ec072c0212b1b51c49a6c158062b0d0" translate="yes" xml:space="preserve">
          <source>Furthermore, type &lt;code&gt;t&lt;/code&gt; is constrained to have a &lt;code&gt;Typeable&lt;/code&gt; instance. The following are therefore illegal:</source>
          <target state="translated">此外，类型 &lt;code&gt;t&lt;/code&gt; 被约束为具有 &lt;code&gt;Typeable&lt;/code&gt; 实例。因此，以下内容是非法的：</target>
        </trans-unit>
        <trans-unit id="2081970b86a7491a8d3bcc2579c359ea225ff58b" translate="yes" xml:space="preserve">
          <source>Furthermore, we restrict the following features:</source>
          <target state="translated">此外,我们还限制了以下特征。</target>
        </trans-unit>
        <trans-unit id="db033d11f970572cb3e9cddec9da0ae34cfa380a" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">面向融合 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 的函数，用于在 &lt;code&gt;Text&lt;/code&gt; 和几种常见编码之间进行转换。</target>
        </trans-unit>
        <trans-unit id="a475567b5216c28471ecd6c4d8d53d3b335fb9fb" translate="yes" xml:space="preserve">
          <source>Fusible &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt;-oriented functions for converting between lazy &lt;code&gt;Text&lt;/code&gt; and several common encodings.</source>
          <target state="translated">易熔 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-types#t:Stream&quot;&gt;Stream&lt;/a&gt;&lt;/code&gt; 取向功能懒之间转换 &lt;code&gt;Text&lt;/code&gt; 和一些常见的编码。</target>
        </trans-unit>
        <trans-unit id="cdf2e5fcd33e60c149dbaeb7315f4ef9de629849" translate="yes" xml:space="preserve">
          <source>Fusion</source>
          <target state="translated">Fusion</target>
        </trans-unit>
        <trans-unit id="159a326f6758bdce7f9997d0ada252499a6c2735" translate="yes" xml:space="preserve">
          <source>Future versions of &lt;code&gt;integer_gmp&lt;/code&gt; may not support negative &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; values anymore.</source>
          <target state="translated">将来的 &lt;code&gt;integer_gmp&lt;/code&gt; 版本可能不再支持负 &lt;code&gt;&lt;em&gt;e&lt;/em&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="a55c9301ac576415d00c242a35c90cc869774f23" translate="yes" xml:space="preserve">
          <source>GADTSyntax</source>
          <target state="translated">GADTSyntax</target>
        </trans-unit>
        <trans-unit id="b91e38c288753eac615e73903fc03c7c3f13ec52" translate="yes" xml:space="preserve">
          <source>GADTs</source>
          <target state="translated">GADTs</target>
        </trans-unit>
        <trans-unit id="f31ea1a5194f51cb6d88f62e8060b3252067edcb" translate="yes" xml:space="preserve">
          <source>GBinaryGet</source>
          <target state="translated">GBinaryGet</target>
        </trans-unit>
        <trans-unit id="630e224c436c0a989f821b5b56c84b74804fbf46" translate="yes" xml:space="preserve">
          <source>GBinaryPut</source>
          <target state="translated">GBinaryPut</target>
        </trans-unit>
        <trans-unit id="7a52054f44519ad82fe4dc7c2dba3037f7ea46fd" translate="yes" xml:space="preserve">
          <source>GCC style response files.</source>
          <target state="translated">GCC风格的响应文件。</target>
        </trans-unit>
        <trans-unit id="9b8227183b46b7bedd6daac69544744f519a2020" translate="yes" xml:space="preserve">
          <source>GCDetails</source>
          <target state="translated">GCDetails</target>
        </trans-unit>
        <trans-unit id="1fb7f8ebd1ef6f3150ef633cd4b56e250a52dea9" translate="yes" xml:space="preserve">
          <source>GCFlags</source>
          <target state="translated">GCFlags</target>
        </trans-unit>
        <trans-unit id="726e40cb883acbb4ae39a6abc67af0f3d15c0557" translate="yes" xml:space="preserve">
          <source>GET_FILEEX_INFO_LEVELS</source>
          <target state="translated">GET_FILEEX_INFO_LEVELS</target>
        </trans-unit>
        <trans-unit id="4deab4e364b1f9987c532fb9308d3fa747de34eb" translate="yes" xml:space="preserve">
          <source>GHC</source>
          <target state="translated">GHC</target>
        </trans-unit>
        <trans-unit id="f8b0fde53dfe6ccde028a6e0d7a726451f64e9f6" translate="yes" xml:space="preserve">
          <source>GHC (mostly) conforms to the Haskell Foreign Function Interface, whose definition is part of the Haskell Report on &lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;.</source>
          <target state="translated">GHC（大部分）符合Haskell外部功能接口，该接口的定义是&lt;a href=&quot;http://www.haskell.org/&quot;&gt;http://www.haskell.org/&lt;/a&gt;上的Haskell报告的一部分。</target>
        </trans-unit>
        <trans-unit id="71a795962bc4f20caecc626cc98073806d56af3d" translate="yes" xml:space="preserve">
          <source>GHC (with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, as always) tries to inline (or &amp;ldquo;unfold&amp;rdquo;) functions/values that are &amp;ldquo;small enough,&amp;rdquo; thus avoiding the call overhead and possibly exposing other more-wonderful optimisations. GHC has a set of heuristics, tuned over a long period of time using many benchmarks, that decide when it is beneficial to inline a function at its call site. The heuristics are designed to inline functions when it appears to be beneficial to do so, but without incurring excessive code bloat. If a function looks too big, it won&amp;rsquo;t be inlined, and functions larger than a certain size will not even have their definition exported in the interface file. Some of the thresholds that govern these heuristic decisions can be changed using flags, see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;.</source>
          <target state="translated">GHC（始终使用&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;）试图内联（或&amp;ldquo;展开&amp;rdquo;）&amp;ldquo;足够小&amp;rdquo;的函数/值，从而避免了调用开销并可能暴露其他更奇妙的优化。 GHC具有一套启发式方法，可在很长一段时间内使用许多基准进行调整，这些方法可确定何时在其调用位置内联函数是有益的。启发式方法旨在内联函数，如果这样做似乎是有益的，但不会引起过多的代码膨胀。如果函数看起来太大，则不会内联，并且大于特定大小的函数甚至不会在接口文件中导出其定义。可以使用标志来更改控制这些启发式决策的某些阈值，请参见&lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *：与平台无关的标志&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd5aeb70f3062d7e5273699b9f6ad00fc86027b7" translate="yes" xml:space="preserve">
          <source>GHC 7.8 can evaluate arithmetic expressions involving type-level natural numbers. Such expressions may be constructed using the type-families &lt;code&gt;(+), (*), (^)&lt;/code&gt; for addition, multiplication, and exponentiation. Numbers may be compared using &lt;code&gt;(&amp;lt;=?)&lt;/code&gt;, which returns a promoted boolean value, or &lt;code&gt;(&amp;lt;=)&lt;/code&gt;, which compares numbers as a constraint. For example:</source>
          <target state="translated">GHC 7.8可以评估涉及类型级自然数的算术表达式。可以使用类型家族 &lt;code&gt;(+), (*), (^)&lt;/code&gt; 进行加，乘和幂运算来构造此类表达式。可以使用 &lt;code&gt;(&amp;lt;=?)&lt;/code&gt; 比较数字，将返回提升的布尔值，或者使用 &lt;code&gt;(&amp;lt;=)&lt;/code&gt; 比较数字作为约束。例如：</target>
        </trans-unit>
        <trans-unit id="93d695e035decd28303f08218eaa7d61529f41ac" translate="yes" xml:space="preserve">
          <source>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type &lt;code&gt;Bool&lt;/code&gt; and the &amp;ldquo;promoted kind&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; are actually identical. (Note that term &lt;code&gt;True&lt;/code&gt; and the type &lt;code&gt;'True&lt;/code&gt; are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</source>
          <target state="translated">GHC 8通过声明类型和种类确实是相同的，扩展了种类多态性的概念。 GHC中没有任何东西可以区分类型和种类。对此的另一种思考方式是， &lt;code&gt;Bool&lt;/code&gt; 类型和&amp;ldquo;提升类型&amp;rdquo; &lt;code&gt;Bool&lt;/code&gt; 实际上是相同的。 （请注意，术语 &lt;code&gt;True&lt;/code&gt; 和类型 &lt;code&gt;'True&lt;/code&gt; 仍然是不同的，因为前者可以在表达式中使用，而后者可以在类型中使用。）类型和种类之间缺乏区别是依赖类型语言的标志。完全依赖类型的语言也消除了表达式和类型之间的差异，但是在GHC中做到这一点又是另一回事了。</target>
        </trans-unit>
        <trans-unit id="83ef026940faed1f89548023088d18a255245d64" translate="yes" xml:space="preserve">
          <source>GHC 8.2 supports module signatures (&lt;code&gt;hsig&lt;/code&gt; files), which allow you to write a signature in place of a module implementation, deferring the choice of implementation until a later point in time. This feature is not intended to be used without &lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;; this manual entry will focus on the syntax and semantics of signatures.</source>
          <target state="translated">GHC 8.2支持模块签名（ &lt;code&gt;hsig&lt;/code&gt; 文件），它允许您编写签名来代替模块实现，从而将实现的选择推迟到以后的某个时间点。没有&lt;a href=&quot;http://www.haskell.org/cabal/&quot;&gt;Cabal&lt;/a&gt;不能使用该功能; 本手册将重点介绍签名的语法和语义。</target>
        </trans-unit>
        <trans-unit id="6a35186132a8c1a5f44b29b9623541079c426c64" translate="yes" xml:space="preserve">
          <source>GHC Extensions: this is the Approved Way to get at GHC-specific extensions.</source>
          <target state="translated">GHC扩展:这是获取GHC特定扩展的认可方式。</target>
        </trans-unit>
        <trans-unit id="abcf3ed735387a1fc13551630355fd6051450c51" translate="yes" xml:space="preserve">
          <source>GHC Note: in order to call &lt;code&gt;waitForProcess&lt;/code&gt; without blocking all the other threads in the system, you must compile the program with &lt;code&gt;-threaded&lt;/code&gt;.</source>
          <target state="translated">GHC注意：为了在不阻塞系统中所有其他线程的情况下调用 &lt;code&gt;waitForProcess&lt;/code&gt; ，必须使用 &lt;code&gt;-threaded&lt;/code&gt; 编译程序。</target>
        </trans-unit>
        <trans-unit id="9ef7fdb5e004e11962f2db47b8f53e696192e47e" translate="yes" xml:space="preserve">
          <source>GHC adopts &lt;strong&gt;Reject if in doubt&lt;/strong&gt; for now. We can see how painful it is in practice, and try something more ambitious if necessary.</source>
          <target state="translated">&lt;strong&gt;如果有疑问&lt;/strong&gt;，GHC会采用&lt;strong&gt;拒绝&lt;/strong&gt;。我们可以看到它在实践中是多么痛苦，并在必要时尝试更大胆的尝试。</target>
        </trans-unit>
        <trans-unit id="41082220042afac899ff2b83b24c9b3630d70113" translate="yes" xml:space="preserve">
          <source>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a &lt;code&gt;foreign export&lt;/code&gt;. This memory is not normally freed until &lt;code&gt;hs_exit()&lt;/code&gt;; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call &lt;code&gt;hs_thread_done()&lt;/code&gt; from the thread whose memory you want to free.</source>
          <target state="translated">当线程通过 &lt;code&gt;foreign export&lt;/code&gt; 调用Haskell函数时，GHC会分配少量线程本地内存。通常在 &lt;code&gt;hs_exit()&lt;/code&gt; 之前不会释放此内存；内存被缓存，以便随后对Haskell的调用很快。但是，如果您的应用程序正在长时间运行，并反复创建调用Haskell的新线程，则您可能希望安排在已完成调用Haskell函数的那些线程中释放此内存。为此，请从要释放其内存的线程中调用 &lt;code&gt;hs_thread_done()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bfd38ebcc64be5e8d02f6d23ecc2c6046c1c0fd" translate="yes" xml:space="preserve">
          <source>GHC allows existentials to be used with records syntax as well. For example:</source>
          <target state="translated">GHC允许存在式也可以和记录语法一起使用。例如:</target>
        </trans-unit>
        <trans-unit id="7c1ae7a2aaa5f27ea408c81b882456db054bdf4d" translate="yes" xml:space="preserve">
          <source>GHC allows for numeric literals to be given in decimal, octal, hexadecimal, binary, or float notation.</source>
          <target state="translated">GHC允许以十进制、八进制、十六进制、二进制或浮点数的形式给出数字文字。</target>
        </trans-unit>
        <trans-unit id="b980cf594e963e0e8219b555b4d47dab40b3eb42" translate="yes" xml:space="preserve">
          <source>GHC allows stand-alone &lt;code&gt;deriving&lt;/code&gt; declarations, enabled by &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">GHC允许由&lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt; &lt;code&gt;StandaloneDeriving&lt;/code&gt; &lt;/a&gt;启用的独立 &lt;code&gt;deriving&lt;/code&gt; 声明：</target>
        </trans-unit>
        <trans-unit id="8296b4add8c32598594b426a3d8785f116cea0b4" translate="yes" xml:space="preserve">
          <source>GHC allows type constructors, classes, and type variables to be operators, and to be written infix, very much like expressions. More specifically:</source>
          <target state="translated">GHC允许类型构造函数、类和类型变量成为运算符,并且可以写成infix,很像表达式。更具体地说。</target>
        </trans-unit>
        <trans-unit id="eb4326185e022f2904a00d722e6d3c8a8c919585" translate="yes" xml:space="preserve">
          <source>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</source>
          <target state="translated">GHC还允许可见类型应用,用户可以声明类型参数在类型多态情况下被实例化。它的用法在术语层面与可见类型应用类似,如上所述。</target>
        </trans-unit>
        <trans-unit id="e0505316426448a3c6e8360de65d79da12c2648e" translate="yes" xml:space="preserve">
          <source>GHC also supports &lt;em&gt;kind-heterogeneous&lt;/em&gt; equality, which relates two types of potentially different kinds. Heterogeneous equality is spelled &lt;code&gt;~~&lt;/code&gt;. Here are the kinds of &lt;code&gt;~&lt;/code&gt; and &lt;code&gt;~~&lt;/code&gt; to better understand their difference:</source>
          <target state="translated">GHC还支持&lt;em&gt;种类异构的&lt;/em&gt;相等性，后者将两种类型的潜在不同种类联系起来。异类平等被拼写为 &lt;code&gt;~~&lt;/code&gt; 。以下是 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;~~&lt;/code&gt; 的种类，以更好地理解它们之间的区别：</target>
        </trans-unit>
        <trans-unit id="ba76d7ceb7b661bae37e18ce6f07732378f6626a" translate="yes" xml:space="preserve">
          <source>GHC always treats the &lt;em&gt;last&lt;/em&gt; parameter of the instance (&lt;code&gt;Foo&lt;/code&gt; in this example) as the type whose instance is being derived.</source>
          <target state="translated">GHC始终将实例的&lt;em&gt;最后一个&lt;/em&gt;参数（在此示例中为 &lt;code&gt;Foo&lt;/code&gt; ）视为派生其实例的类型。</target>
        </trans-unit>
        <trans-unit id="3c323be157c96acdab287f807375f9b719b64a63" translate="yes" xml:space="preserve">
          <source>GHC applies the dreaded Monomorphism Restriction (section 4.5.5 of the Haskell Report) to implicit parameters. For example, consider:</source>
          <target state="translated">GHC 将可怕的单形限制(Haskell 报告的 4.5.5 节)应用于隐式参数。例如,请考虑:</target>
        </trans-unit>
        <trans-unit id="085bc7758e841a7674950854ea86b028e0155c10" translate="yes" xml:space="preserve">
          <source>GHC assumes that source files are ASCII or UTF-8 only, other encoding are not recognised. However, invalid UTF-8 sequences will be ignored in comments, so it is possible to use other encodings such as Latin-1, as long as the non-comment source code is ASCII only.</source>
          <target state="translated">GHC假定源文件只使用ASCII或UTF-8,其他编码不被识别,但无效的UTF-8序列会在注释中被忽略,所以只要非注释的源码是ASCII,就可以使用其他编码,如拉丁语1。然而,无效的UTF-8序列将在注释中被忽略,所以只要非注释源码是ASCII码,就可以使用其他编码,如Latin-1。</target>
        </trans-unit>
        <trans-unit id="3d3ac693ce7ba01fac9e81d67e5485761f5520b6" translate="yes" xml:space="preserve">
          <source>GHC attempts to detect when threads are deadlocked using the garbage collector. A thread that is not reachable (cannot be found by following pointers from live objects) must be deadlocked, and in this case the thread is sent an exception. The exception is either &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt;, depending on the way in which the thread is deadlocked.</source>
          <target state="translated">GHC尝试使用垃圾收集器检测何时线程死锁。无法访问的线程（无法通过跟随活动对象的指针找到）必须处于死锁状态，在这种情况下，该线程将被发送异常。根据线程的死锁方式，可以是 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:BlockedIndefinitelyOnSTM&quot;&gt;BlockedIndefinitelyOnSTM&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:NonTermination&quot;&gt;NonTermination&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:Deadlock&quot;&gt;Deadlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51e22a881769a40b9be873a2cbaae3065ee10a9c" translate="yes" xml:space="preserve">
          <source>GHC builds up a wealth of information about a Haskell source file as it compiles it. Extended interface files are a way of persisting some of this information to disk so that external tools, such as IDE&amp;rsquo;s, can avoid parsing, typechecking, and renaming all over again. These files contain</source>
          <target state="translated">GHC在编译时会积累有关Haskell源文件的大量信息。扩展接口文件是一种将某些信息持久保存到磁盘的方法，以便外部工具（例如IDE的工具）可以避免再次进行解析，类型检查和重命名。这些文件包含</target>
        </trans-unit>
        <trans-unit id="95040b8ff0496443822f0456826fbfe3fd01b8e2" translate="yes" xml:space="preserve">
          <source>GHC calculates a fingerprint (in fact an MD5 hash) of each interface file, and of each declaration within the interface file. It also keeps in every interface file a list of the fingerprints of everything it used when it last compiled the file. If the source file&amp;rsquo;s modification date is earlier than the &lt;code&gt;.o&lt;/code&gt; file&amp;rsquo;s date (i.e. the source hasn&amp;rsquo;t changed since the file was last compiled), and the recompilation checking is on, GHC will be clever. It compares the fingerprints on the things it needs this time with the fingerprints on the things it needed last time (gleaned from the interface file of the module being compiled); if they are all the same it stops compiling early in the process saying &amp;ldquo;Compilation IS NOT required&amp;rdquo;. What a beautiful sight!</source>
          <target state="translated">GHC计算每个接口文件以及接口文件中每个声明的指纹（实际上是MD5哈希）。它还在每个接口文件中保留了上次编译文件时使用的所有指纹的列表。如果源文件的修改日期早于 &lt;code&gt;.o&lt;/code&gt; 文件的日期（即，自从上次编译文件以来源文件没有更改），并且重新编译检查已启用，则GHC会很聪明。它将这次需要的东西的指纹与上次需要的东西的指纹进行比较（从正在编译的模块的接口文件中收集）；如果它们都相同，它将在过程的早期停止编译，并显示&amp;ldquo;不需要编译&amp;rdquo;。多么美丽的景象！</target>
        </trans-unit>
        <trans-unit id="6a07d417f72643413044febaee57f46f8892bf38" translate="yes" xml:space="preserve">
          <source>GHC can be quite a bit more aggressive with pieces of code if it knows they are not exported.</source>
          <target state="translated">如果GHC知道这些代码没有被导出,那么它对这些代码的处理就会更加激进。</target>
        </trans-unit>
        <trans-unit id="20b3fdac58effb1981a662cd5b9d15a2246601cf" translate="yes" xml:space="preserve">
          <source>GHC comes with a number of libraries. These are described in separate documentation.</source>
          <target state="translated">GHC自带了许多库。这些都在单独的文档中描述。</target>
        </trans-unit>
        <trans-unit id="e04da29f82d35f8657a7c056280732b0f61a3942" translate="yes" xml:space="preserve">
          <source>GHC comes with a time and space profiling system, so that you can answer questions like &amp;ldquo;why is my program so slow?&amp;rdquo;, or &amp;ldquo;why is my program using so much memory?&amp;rdquo;.</source>
          <target state="translated">GHC带有时间和空间剖析系统，因此您可以回答诸如&amp;ldquo;为什么我的程序为什么这么慢？&amp;rdquo;或&amp;ldquo;为什么我的程序使用那么多的内存？&amp;rdquo;之类的问题。</target>
        </trans-unit>
        <trans-unit id="da055bb0f39bef03c75247c94877951076bed2b9" translate="yes" xml:space="preserve">
          <source>GHC compiles some program constructs slowly:</source>
          <target state="translated">GHC编译一些程序构造的速度很慢。</target>
        </trans-unit>
        <trans-unit id="de2e40df6054756a65674cc009e4351de51b3690" translate="yes" xml:space="preserve">
          <source>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</source>
          <target state="translated">GHC完全忽略了浮点环境,运行时既不修改也不读取。</target>
        </trans-unit>
        <trans-unit id="549d84269c7b3028d7034e66451015b450c55e63" translate="yes" xml:space="preserve">
          <source>GHC creates a subdirectory &lt;code&gt;.hpc&lt;/code&gt; in the current directory, and puts HPC index (&lt;code&gt;.mix&lt;/code&gt;) files in there, one for each module compiled. You don&amp;rsquo;t need to worry about these files: they contain information needed by the &lt;code&gt;hpc&lt;/code&gt; tool to generate the coverage data for compiled modules after the program is run.</source>
          <target state="translated">GHC 在当前目录中创建一个子目录 &lt;code&gt;.hpc&lt;/code&gt; ，并将HPC索引（ &lt;code&gt;.mix&lt;/code&gt; ）文件放在其中，每个编译的模块一个。您无需担心这些文件：它们包含 &lt;code&gt;hpc&lt;/code&gt; 工具在程序运行后为已编译模块生成coverage数据所需的信息。</target>
        </trans-unit>
        <trans-unit id="704d8fd09c4c661d97d55003569a629d6a64a062" translate="yes" xml:space="preserve">
          <source>GHC currently does kind checking before expanding synonyms (though even that could be changed).</source>
          <target state="translated">GHC目前在扩展同义词之前会进行种类检查(不过即使这样也可以改变)。</target>
        </trans-unit>
        <trans-unit id="d5c2a962ee75e672cc63c1570d298f7423d987d4" translate="yes" xml:space="preserve">
          <source>GHC currently uses a very simple, syntactic, matching algorithm for matching a rule LHS with an expression. It seeks a substitution which makes the LHS and expression syntactically equal modulo alpha conversion. The pattern (rule), but not the expression, is eta-expanded if necessary. (Eta-expanding the expression can lead to laziness bugs.) But not beta conversion (that&amp;rsquo;s called higher-order matching).</source>
          <target state="translated">GHC当前使用一种非常简单的语法匹配算法来将规则LHS与表达式进行匹配。它寻求一种替代方法，使LHS和表达式在语法上相等于模alpha转换。如有必要，模式（规则）而不是表达式被eta扩展。（扩展Eta表达式可能会导致懒惰错误。）但是beta转换不是这样（这称为高阶匹配）。</target>
        </trans-unit>
        <trans-unit id="ef6d67c2bca6e1b47545829cfc42b1d411dd7f6d" translate="yes" xml:space="preserve">
          <source>GHC disambiguates between multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets based on this rationale. To make things more formal, when the pattern-match checker requests a set of constructors for some data type constructor &lt;code&gt;T&lt;/code&gt;, the checker returns:</source>
          <target state="translated">GHC 根据此原理在多个 &lt;code&gt;COMPLETE&lt;/code&gt; 集之间进行歧义消除。为了使事情更加正式，当模式匹配检查器为某些数据类型构造函数 &lt;code&gt;T&lt;/code&gt; 请求一组构造函数时，检查器返回：</target>
        </trans-unit>
        <trans-unit id="bd05d936e9882b073172126b6706e5f4c689fb33" translate="yes" xml:space="preserve">
          <source>GHC discharges the constraint as soon as it knows what concrete type-level literal is being used in the program. Note that this works only for &lt;em&gt;literals&lt;/em&gt; and not arbitrary type expressions. For example, a constraint of the form &lt;code&gt;KnownNat (a + b)&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be simplified to &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt;; instead, GHC will keep the constraint as is, until it can simplify &lt;code&gt;a + b&lt;/code&gt; to a constant value.</source>
          <target state="translated">GHC知道程序中正在使用哪种具体的类型级别文字后，便立即释放该约束。请注意，这仅适用于&lt;em&gt;文字&lt;/em&gt;，不适用于任意类型表达式。例如，该形式的约束 &lt;code&gt;KnownNat (a + b)&lt;/code&gt; 将&lt;em&gt;不&lt;/em&gt;被简化为 &lt;code&gt;(KnownNat a, KnownNat b)&lt;/code&gt; ; 相反，GHC将保持约束不变，直到可以将 &lt;code&gt;a + b&lt;/code&gt; 简化为恒定值为止。</target>
        </trans-unit>
        <trans-unit id="167343e68b8bf1a9e7ec5d0c5832fa2540cf35a0" translate="yes" xml:space="preserve">
          <source>GHC does not allow you to have a data type with a context that mentions type variables that are not data type parameters. For example:</source>
          <target state="translated">GHC不允许你有一个数据类型,其上下文提到的类型变量不是数据类型参数。例如:</target>
        </trans-unit>
        <trans-unit id="b579c8b8d2f4a7ab2a00594e0e2267c4041770d7" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t do the fixity resolution in expressions during parsing as required by Haskell 98 (but not by Haskell 2010). For example, according to the Haskell 98 report, the following expression is legal:</source>
          <target state="translated">根据Haskell 98的要求，GHC不会在解析过程中对表达式进行固定性解析（但Haskell 2010则不如此）。例如，根据Haskell 98报告，以下表达式是合法的：</target>
        </trans-unit>
        <trans-unit id="8769daf9bb42ddf2fdd9c103027d5dea23101781" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t have to be restarted for each compilation, which means it can cache information between compilations. Compiling a multi-module program with &lt;code&gt;ghc --make&lt;/code&gt; can be up to twice as fast as running &lt;code&gt;ghc&lt;/code&gt; individually on each source file.</source>
          <target state="translated">GHC不必为每个编译都重新启动，这意味着它可以在编译之间缓存信息。使用 &lt;code&gt;ghc --make&lt;/code&gt; 编译多模块程序的速度可能是在每个源文件上单独运行 &lt;code&gt;ghc&lt;/code&gt; 的速度的两倍。</target>
        </trans-unit>
        <trans-unit id="f91f388f5cbc4088b94a5ec84cec7c04e6042e38" translate="yes" xml:space="preserve">
          <source>GHC doesn&amp;rsquo;t implement complete full-laziness. When optimisation in on, and &lt;code&gt;-fno-full-laziness&lt;/code&gt; is not given, some transformations that increase sharing are performed, such as extracting repeated computations from a loop. These are the same transformations that a fully lazy implementation would do, the difference is that GHC doesn&amp;rsquo;t consistently apply full-laziness, so don&amp;rsquo;t rely on it.</source>
          <target state="translated">GHC没有实现完全的懒惰。如果未启用优化，并且未给出 &lt;code&gt;-fno-full-laziness&lt;/code&gt; ，则将执行一些增加共享的转换，例如从循环中提取重复的计算。这些转换与完全懒惰的实现所进行的转换相同，不同之处在于GHC不会始终采用完全懒惰，因此请不要依赖它。</target>
        </trans-unit>
        <trans-unit id="bfe0f580bb15aa44cde9df1fbad436113357809b" translate="yes" xml:space="preserve">
          <source>GHC ensures that inlining cannot go on forever: every mutually-recursive group is cut by one or more &lt;em&gt;loop breakers&lt;/em&gt; that is never inlined (see &lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;Secrets of the GHC inliner, JFP 12(4) July 2002&lt;/a&gt;). GHC tries not to select a function with an &lt;code&gt;INLINE&lt;/code&gt; pragma as a loop breaker, but when there is no choice even an INLINE function can be selected, in which case the &lt;code&gt;INLINE&lt;/code&gt; pragma is ignored. For example, for a self-recursive function, the loop breaker can only be the function itself, so an &lt;code&gt;INLINE&lt;/code&gt; pragma is always ignored.</source>
          <target state="translated">GHC确保内联不会永远持续下去：每个相互递归的组都被一个或多个从未内联的&lt;em&gt;循环断路器&lt;/em&gt;削减（请参阅&lt;a href=&quot;http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm&quot;&gt;2002年7月JFP 12（4），GHC&lt;/a&gt;内联的秘密）。 GHC尝试不选择具有 &lt;code&gt;INLINE&lt;/code&gt; 编译指示的功能作为循环断路器，但是当没有选择时，甚至可以选择INLINE功能，在这种情况下，将忽略 &lt;code&gt;INLINE&lt;/code&gt; 编译指示。例如，对于自递归函数，循环断路器只能是该函数本身，因此始终忽略 &lt;code&gt;INLINE&lt;/code&gt; 编译指示。</target>
        </trans-unit>
        <trans-unit id="d1e987d1c3d82c8013500d719ac2e258ed684a94" translate="yes" xml:space="preserve">
          <source>GHC exposes its internal APIs to users through the built-in ghc package. It allows you to write programs that leverage GHC&amp;rsquo;s entire compilation driver, in order to analyze or compile Haskell code programmatically. Furthermore, GHC gives users the ability to load compiler plugins during compilation - modules which are allowed to view and change GHC&amp;rsquo;s internal intermediate representation, Core. Plugins are suitable for things like experimental optimizations or analysis, and offer a lower barrier of entry to compiler development for many common cases.</source>
          <target state="translated">GHC通过内置的ghc包向用户公开其内部API。它允许您编写利用GHC整个编译驱动程序的程序，以便以编程方式分析或编译Haskell代码。此外，GHC使用户能够在编译过程中加载编译器插件-允许查看和更改GHC内部中间表示形式Core的模块。插件适用于诸如实验优化或分析之类的事情，并且在许多常见情况下为编译器开发提供了较低的进入门槛。</target>
        </trans-unit>
        <trans-unit id="7c167fa8597da83d2d6c70ee64cf8fd148a64239" translate="yes" xml:space="preserve">
          <source>GHC extends the FFI with an additional calling convention &lt;code&gt;prim&lt;/code&gt;, e.g.:</source>
          <target state="translated">GHC通过附加的呼叫约定 &lt;code&gt;prim&lt;/code&gt; 扩展了FFI ，例如：</target>
        </trans-unit>
        <trans-unit id="2709b25bb09f206c0b1acccbf37562ea657795ca" translate="yes" xml:space="preserve">
          <source>GHC extends this list with several more classes that may be automatically derived:</source>
          <target state="translated">GHC对这个列表进行了扩展,增加了几个可以自动衍生的类。</target>
        </trans-unit>
        <trans-unit id="2927c8c0dcc59d688d14e863c87024ee56f40a67" translate="yes" xml:space="preserve">
          <source>GHC has a &lt;code&gt;-dynload&lt;/code&gt; linking flag to select the method that is used to find shared libraries at runtime. There are currently two modes:</source>
          <target state="translated">GHC具有 &lt;code&gt;-dynload&lt;/code&gt; 链接标志，用于选择用于在运行时查找共享库的方法。当前有两种模式：</target>
        </trans-unit>
        <trans-unit id="37868d9918c1e5d3985d0159ec2eb8abe357d679" translate="yes" xml:space="preserve">
          <source>GHC has a comprehensive optimiser, so when you want to Really Go For It (and you&amp;rsquo;ve got time to spare) GHC can produce pretty fast code. Alternatively, the default option is to compile as fast as possible while not making too much effort to optimise the generated code (although GHC probably isn&amp;rsquo;t what you&amp;rsquo;d describe as a fast compiler :-).</source>
          <target state="translated">GHC具有全面的优化器，因此当您真正想要使用它（并且有足够的时间来节省时间）时，GHC可以生成非常快速的代码。另外，默认选项是尽可能快地编译，同时不花太多精力来优化生成的代码（尽管GHC可能不是您所描述的快速编译器：-）。</target>
        </trans-unit>
        <trans-unit id="50704903e2fa0767c23ef5592e01c0142e232598" translate="yes" xml:space="preserve">
          <source>GHC has a custom solver for discharging constraints that involve class &lt;code&gt;Typeable&lt;/code&gt;, and handwritten instances are forbidden. This ensures that the programmer cannot subvert the type system by writing bogus instances.</source>
          <target state="translated">GHC有一个自定义的求解器，用于释放涉及 &lt;code&gt;Typeable&lt;/code&gt; 类的约束，并且禁止手写实例。这样可以确保程序员无法通过编写伪造的实例来破坏类型系统。</target>
        </trans-unit>
        <trans-unit id="dd2651a370808140aecb0389d7da1dfec93f9973" translate="yes" xml:space="preserve">
          <source>GHC has a few built-in functions with special behaviour. In particular:</source>
          <target state="translated">GHC有一些内置的特殊行为的函数。特别是:</target>
        </trans-unit>
        <trans-unit id="7b5cd4da1d694b042ff22d18106007056b905706" translate="yes" xml:space="preserve">
          <source>GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt;, use &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt;. To reverse``-Werror``, which makes all warnings into errors, use &lt;code&gt;-Wwarn&lt;/code&gt;.</source>
          <target state="translated">GHC有许多选项，可以选择在编译过程中可以生成哪些类型的非致命错误消息，也称为警告。一些选项控制单个警告，而其他选项控制警告的集合。要关闭单个警告 &lt;code&gt;-W&amp;lt;wflag&amp;gt;&lt;/code&gt; ，请使用 &lt;code&gt;-Wno-&amp;lt;wflag&amp;gt;&lt;/code&gt; 。要反转使所有警告变为错误的 &lt;code&gt;-Wwarn&lt;/code&gt; ，请使用-Wwarn。</target>
        </trans-unit>
        <trans-unit id="dc26cabb6e31043f801f34ba96fce33c2cd76158" translate="yes" xml:space="preserve">
          <source>GHC has experimental support for &lt;em&gt;signature thinning&lt;/em&gt;, which is used when a signature has an explicit export list without a module export of the signature itself. In this case, the export list applies to the final export list &lt;em&gt;after&lt;/em&gt; merging, in particular, you may refer to entities which are not declared in the body of the local &lt;code&gt;hsig&lt;/code&gt; file.</source>
          <target state="translated">GHC具有对&lt;em&gt;签名稀疏的&lt;/em&gt;实验性支持，当签名具有显式导出列表而没有签名本身的模块导出时，将使用GHC 。在这种情况下，导出列表将&lt;em&gt;在&lt;/em&gt;合并&lt;em&gt;后&lt;/em&gt;应用于最终导出列表，特别是，您可以引用未在本地 &lt;code&gt;hsig&lt;/code&gt; 文件的主体中声明的实体。</target>
        </trans-unit>
        <trans-unit id="ae1857d5e68b869ba0f3a7a41a92f227174acdbb" translate="yes" xml:space="preserve">
          <source>GHC has extremely flaky support for &lt;em&gt;impredicative polymorphism&lt;/em&gt;, enabled with &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt;. If it worked, this would mean that you &lt;em&gt;could&lt;/em&gt; call a polymorphic function at a polymorphic type, and parameterise data structures over polymorphic types. For example:</source>
          <target state="translated">GHC对&lt;em&gt;Impredicative多态性的&lt;/em&gt;支持非常&lt;em&gt;脆弱&lt;/em&gt;，启用了&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;。如果可行，这意味着您&lt;em&gt;可以&lt;/em&gt;在多态类型上调用多态函数，并在多态类型上参数化数据结构。例如：</target>
        </trans-unit>
        <trans-unit id="a7863559f9ec9cb2b2a5ec1dc3cee9a5175090f2" translate="yes" xml:space="preserve">
          <source>GHC has the ability to load compiler plugins at compile time. The feature is similar to the one provided by &lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;, and allows users to write plugins that can adjust the behaviour of the constraint solver, inspect and modify the compilation pipeline, as well as transform and inspect GHC&amp;rsquo;s intermediate language, Core. Plugins are suitable for experimental analysis or optimization, and require no changes to GHC&amp;rsquo;s source code to use.</source>
          <target state="translated">GHC能够在编译时加载编译器插件。该功能类似于&lt;a href=&quot;http://gcc.gnu.org/wiki/plugins&quot;&gt;GCC&lt;/a&gt;提供的功能，允许用户编写插件，这些插件可以调整约束求解器的行为，检查和修改编译管道，以及转换和检查GHC的中间语言Core。插件适用于实验分析或优化，不需要更改GHC的源代码即可使用。</target>
        </trans-unit>
        <trans-unit id="3a2700135014d3391d235e2779538d1dbae6f7d0" translate="yes" xml:space="preserve">
          <source>GHC has to link your code with various libraries, possibly including: user-supplied, GHC-supplied, and system-supplied (&lt;code&gt;-lm&lt;/code&gt; math library, for example).</source>
          <target state="translated">GHC必须将您的代码与各种库链接，可能包括：用户提供的，GHC提供的和系统提供的（例如 &lt;code&gt;-lm&lt;/code&gt; 数学库）。</target>
        </trans-unit>
        <trans-unit id="6fb872fe440b0daf385b4b8ff21367d65f6f7fa0" translate="yes" xml:space="preserve">
          <source>GHC has two main components: an interactive Haskell interpreter (also known as GHCi), described in &lt;a href=&quot;ghci#ghci&quot;&gt;Using GHCi&lt;/a&gt;, and a batch compiler, described throughout &lt;a href=&quot;using#using-ghc&quot;&gt;Using GHC&lt;/a&gt;. In fact, GHC consists of a single program which is just run with different options to provide either the interactive or the batch system.</source>
          <target state="translated">GHC有两个主要组件：一个交互式的Haskell解释器（也称为GHCI），在所描述&lt;a href=&quot;ghci#ghci&quot;&gt;使用GHCI&lt;/a&gt;和批处理编译器，在整个描述&lt;a href=&quot;using#using-ghc&quot;&gt;使用GHC&lt;/a&gt;。实际上，GHC包含一个单独的程序，该程序仅以不同的选项运行，以提供交互式或批处理系统。</target>
        </trans-unit>
        <trans-unit id="2dfd60f79ee4ba2079225942cc8483b2227556fc" translate="yes" xml:space="preserve">
          <source>GHC home page</source>
          <target state="translated">GHC主页</target>
        </trans-unit>
        <trans-unit id="f354abc94fdf02ee4cd7aec76ce15252272ca1c5" translate="yes" xml:space="preserve">
          <source>GHC ignores assertions when optimisation is turned on with the &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; flag. That is, expressions of the form &lt;code&gt;assert pred e&lt;/code&gt; will be rewritten to &lt;code&gt;e&lt;/code&gt;. You can also disable assertions using the &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fignore-asserts&lt;/code&gt;&lt;/a&gt; option. The option &lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt;&lt;code&gt;-fno-ignore-asserts&lt;/code&gt;&lt;/a&gt; allows enabling assertions even when optimisation is turned on.</source>
          <target state="translated">当使用&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;标志打开优化时，GHC将忽略断言。也就是说， &lt;code&gt;assert pred e&lt;/code&gt; 形式的表达式将被重写为 &lt;code&gt;e&lt;/code&gt; 。您也可以使用&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fignore-asserts&lt;/code&gt; &lt;/a&gt;选项禁用断言。选项&lt;a href=&quot;using-optimisation#ghc-flag--fignore-asserts&quot;&gt; &lt;code&gt;-fno-ignore-asserts&lt;/code&gt; &lt;/a&gt;允许启用断言，即使打开优化也是如此。</target>
        </trans-unit>
        <trans-unit id="d193c3b9ee9bd64a2c40a91ed8f0f72fd80e9a86" translate="yes" xml:space="preserve">
          <source>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in &lt;a href=&quot;#ffi-ghcexts&quot;&gt;GHC extensions to the FFI Chapter&lt;/a&gt;, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</source>
          <target state="translated">GHC对Haskell 2010报告的FFI章节实施了一些特定于GHC的扩展。这些扩展&lt;a href=&quot;#ffi-ghcexts&quot;&gt;在FFI章节的GHC扩展中进行了&lt;/a&gt;描述，但请注意，使用这些功能的程序不可移植。因此，应尽可能避免使用这些功能。</target>
        </trans-unit>
        <trans-unit id="b01529699aab62d7c26cc7ea486b2bf3a314d4cc" translate="yes" xml:space="preserve">
          <source>GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).</source>
          <target state="translated">GHC实现了先发制人的多任务处理:线程的执行以随机方式交错进行。更具体地说,一个线程每当分配一些内存时就可能被抢占,不幸的是,这意味着不进行分配的紧缩循环往往会锁定其他线程(然而,这似乎只发生在病态的benchmark风格的代码中)。</target>
        </trans-unit>
        <trans-unit id="784ab21057de1abbfb56e2df7ec894a968e45b8e" translate="yes" xml:space="preserve">
          <source>GHC implements some major extensions to Haskell to support concurrent and parallel programming. Let us first establish terminology:</source>
          <target state="translated">GHC实现了对Haskell的一些主要扩展,支持并发和并行编程。首先让我们建立术语。</target>
        </trans-unit>
        <trans-unit id="384027abc0c0211dec27023d54430b773e937baf" translate="yes" xml:space="preserve">
          <source>GHC implements this test conservatively when type functions, or type variables, are involved. For example</source>
          <target state="translated">当涉及到类型函数或类型变量时,GHC保守地实现了这个测试。例如</target>
        </trans-unit>
        <trans-unit id="ac0d768afcace80925944278709c9070e93b287f" translate="yes" xml:space="preserve">
          <source>GHC includes a variety of flags that allow arbitrary processes to be run at compilation time. One such example is the &lt;a href=&quot;phases#pre-processor&quot;&gt;custom pre-processor&lt;/a&gt; flag. Another is the ability of Template Haskell to execute Haskell code at compilation time, including IO actions. Safe Haskell &lt;em&gt;does not address this danger&lt;/em&gt; (although, Template Haskell is a disallowed feature).</source>
          <target state="translated">GHC包含各种标志，这些标志允许在编译时运行任意进程。一个这样的例子是&lt;a href=&quot;phases#pre-processor&quot;&gt;定制预处理器&lt;/a&gt;标志。另一个是Template Haskell在编译时执行Haskell代码（包括IO操作）的能力。Safe Haskell &lt;em&gt;不能解决这种危险&lt;/em&gt;（尽管Template Haskell是不允许的功能）。</target>
        </trans-unit>
        <trans-unit id="5a501e79a5be96c764587e4f4a538a164615c592" translate="yes" xml:space="preserve">
          <source>GHC includes support for running Haskell programs in parallel on symmetric, shared-memory multi-processor (SMP). By default GHC runs your program on one processor; if you want it to run in parallel you must link your program with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, and run it with the RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option; see &lt;a href=&quot;using-concurrent#using-smp&quot;&gt;Using SMP parallelism&lt;/a&gt;). The runtime will schedule the running Haskell threads among the available OS threads, running as many in parallel as you specified with the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS option.</source>
          <target state="translated">GHC包括支持在对称的共享内存多处理器（SMP）上并行运行Haskell程序。默认情况下，GHC在一个处理器上运行程序。如果要使其并行运行，则必须将程序与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接，并使用RTS &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 选项运行它；请参阅&lt;a href=&quot;using-concurrent#using-smp&quot;&gt;使用SMP并行性&lt;/a&gt;）。运行时将在可用的OS线程中调度正在运行的Haskell线程，并与 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; RTS选项指定的并行运行数量一样。</target>
        </trans-unit>
        <trans-unit id="8a61ad13cc654370f6a14c4d7207d6379e372d1d" translate="yes" xml:space="preserve">
          <source>GHC is a large program consisting of a number of stages. You can tell GHC to dump information from various stages of compilation using the &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; flags listed below. Note that some of these tend to produce a lot of output. You can prevent them from clogging up your standard output by passing &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC是一个由多个阶段组成的大型程序。您可以使用下面列出的 &lt;code&gt;-ddump-⟨pass⟩&lt;/code&gt; 标志告诉GHC转储各个编译阶段的信息。请注意，其中一些往往会产生大量输出。您可以通过传递&lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;来防止它们阻塞标准输出。</target>
        </trans-unit>
        <trans-unit id="0e827b1ebcca328b1f8fef7330a8dfc0af882c0d" translate="yes" xml:space="preserve">
          <source>GHC is built on a raft of primitive data types and operations; &amp;ldquo;primitive&amp;rdquo; in the sense that they cannot be defined in Haskell itself. While you really can use this stuff to write fast code, we generally find it a lot less painful, and more satisfying in the long run, to use higher-level language features and libraries. With any luck, the code you write will be optimised to the efficient unboxed version in any case. And if it isn&amp;rsquo;t, we&amp;rsquo;d like to know about it.</source>
          <target state="translated">GHC建立在大量原始数据类型和操作之上；从某种意义上说，&amp;ldquo;原始&amp;rdquo;无法在Haskell本身中定义。虽然您确实可以使用这些东西来编写快速的代码，但从长远来看，使用高级语言功能和库通常会减轻很多痛苦，并且从长远来看，它会更令人满意。运气好的话，在任何情况下，您编写的代码都将被优化为有效的非盒装版本。如果不是的话，我们想知道。</target>
        </trans-unit>
        <trans-unit id="036d822f43fafc704cccf229faeb8f39d429451c" translate="yes" xml:space="preserve">
          <source>GHC is itself a Haskell program, so if you need to pass options directly to GHC&amp;rsquo;s runtime system you can enclose them in &lt;code&gt;+RTS ... -RTS&lt;/code&gt; (see &lt;a href=&quot;runtime_control#runtime-control&quot;&gt;Running a compiled program&lt;/a&gt;).</source>
          <target state="translated">GHC本身就是Haskell程序，因此，如果您需要将选项直接传递到GHC的运行时系统，则可以将它们包含在 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; （请参阅&lt;a href=&quot;runtime_control#runtime-control&quot;&gt;运行编译的程序&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5f1fbb021ad6ec77459e40f9cdfa738fe516428c" translate="yes" xml:space="preserve">
          <source>GHC is surprisingly zippy for normal compilations without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;!</source>
          <target state="translated">对于没有&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 的&lt;/a&gt;常规编译，GHC令人惊讶地令人生畏。</target>
        </trans-unit>
        <trans-unit id="e1b0068bc94f72b8b3701c6252a51b85e66a7b86" translate="yes" xml:space="preserve">
          <source>GHC is very cautious about duplicating work. For example, consider</source>
          <target state="translated">GHC对于重复工作是非常谨慎的。例如,可以考虑</target>
        </trans-unit>
        <trans-unit id="1e880a64634c393c137ab909ff23b9fa67d62722" translate="yes" xml:space="preserve">
          <source>GHC is very sensitive about interface files. For example, if it picks up a non-standard &lt;code&gt;Prelude.hi&lt;/code&gt; file, pretty terrible things will happen. If you turn on &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;-XNoImplicitPrelude option, the compiler will almost surely die, unless you know what you are doing.</source>
          <target state="translated">GHC对接口文件非常敏感。例如，如果它拾取了非标准的 &lt;code&gt;Prelude.hi&lt;/code&gt; 文件，那么将会发生非常糟糕的事情。如果打开 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; -XNoImplicitPrelude选项，则除非您知道自己在做什么，否则编译器几乎肯定会死。</target>
        </trans-unit>
        <trans-unit id="8f98bd19130c85af22543d9122fb6b893c3ab021" translate="yes" xml:space="preserve">
          <source>GHC keeps trying to apply the rules as it optimises the program. For example, consider:</source>
          <target state="translated">GHC在优化程序的过程中,不断尝试应用这些规则。例如,考虑:</target>
        </trans-unit>
        <trans-unit id="c971ed60f0f8cac8a9dfb32c0fc05213d73e4927" translate="yes" xml:space="preserve">
          <source>GHC knows about two package databases in particular:</source>
          <target state="translated">GHC特别知道两个软件包数据库。</target>
        </trans-unit>
        <trans-unit id="ee518910a69d6b3ec07ce5ab8b5533533d1b86a4" translate="yes" xml:space="preserve">
          <source>GHC lets you change the default RTS options for a program at compile time, using the &lt;code&gt;-with-rtsopts&lt;/code&gt; flag (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). A common use for this is to give your program a default heap and/or stack size that is greater than the default. For example, to set &lt;code&gt;-H128m -K64m&lt;/code&gt;, link with &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt;.</source>
          <target state="translated">GHC允许您使用 &lt;code&gt;-with-rtsopts&lt;/code&gt; 标志（&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）在编译时更改程序的默认RTS选项。这样做的常见用法是为程序提供默认的堆和/或堆栈大小，该默认堆和/或堆栈大小大于默认值。例如，要设置 &lt;code&gt;-H128m -K64m&lt;/code&gt; ，请与 &lt;code&gt;-with-rtsopts=&quot;-H128m -K64m&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb99e557b948da3d443c3d321414623817fdd5f6" translate="yes" xml:space="preserve">
          <source>GHC lets you exercise rudimentary control over certain RTS settings for any given program, by compiling in a &amp;ldquo;hook&amp;rdquo; that is called by the run-time system. The RTS contains stub definitions for these hooks, but by writing your own version and linking it on the GHC command line, you can override the defaults.</source>
          <target state="translated">通过编译运行时系统调用的&amp;ldquo;挂钩&amp;rdquo;，GHC使您可以对任何给定程序的某些RTS设置进行基本控制。RTS包含这些挂钩的存根定义，但是通过编写您自己的版本并在GHC命令行上链接它，您可以覆盖默认值。</target>
        </trans-unit>
        <trans-unit id="cad9041737a68aff4c044f186cb6f1f6cdc933e2" translate="yes" xml:space="preserve">
          <source>GHC lifts this restriction with language extension &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt;. The restriction is a pretty stupid one in the first place, so &lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt;&lt;code&gt;ConstrainedClassMethods&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GHC通过语言扩展&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;解除了此限制。首先，限制是一个非常愚蠢的限制，因此&lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt; &lt;code&gt;MultiParamTypeClasses&lt;/code&gt; &lt;/a&gt;隐含了&lt;a href=&quot;#extension-ConstrainedClassMethods&quot;&gt; &lt;code&gt;ConstrainedClassMethods&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8ba60a7f4df257517ab7d5d783f3cc489a09b60" translate="yes" xml:space="preserve">
          <source>GHC loves single-constructor data-types:</source>
          <target state="translated">GHC喜欢单构造数据类型。</target>
        </trans-unit>
        <trans-unit id="7fe0475e3ee29056ea60e7039fdeca427dd3ce9a" translate="yes" xml:space="preserve">
          <source>GHC maintains a property that the kind of all inhabited types (as distinct from type constructors or type-level data) tells us the runtime representation of values of that type. This datatype encodes the choice of runtime value. Note that &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; is parameterised by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt;; this is precisely what we mean by the fact that a type's kind encodes the runtime representation.</source>
          <target state="translated">GHC保留了一个属性，即所有居住类型的类型（不同于类型构造函数或类型级别数据）告诉我们该类型值的运行时表示形式。此数据类型编码运行时值的选择。注意 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:TYPE&quot;&gt;TYPE&lt;/a&gt;&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:RuntimeRep&quot;&gt;RuntimeRep&lt;/a&gt;&lt;/code&gt; 参数化；这正是我们的意思，即类型的类型会编码运行时表示形式。</target>
        </trans-unit>
        <trans-unit id="1ff86cb3c00be570a738bdb82648ae498fe4fba6" translate="yes" xml:space="preserve">
          <source>GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer&amp;rsquo;s!</source>
          <target state="translated">GHC绝对不尝试验证规则的LHS和RHS具有相同的含义。通常这是无法确定的，而在大多数有趣的情况下则是不可行的。责任完全是程序员的责任！</target>
        </trans-unit>
        <trans-unit id="b7463d030f30e5fbf0ea5c1acd7285f721a4849a" translate="yes" xml:space="preserve">
          <source>GHC makes no attempt to make sure that the rules are confluent or terminating. For example:</source>
          <target state="translated">GHC没有试图确保规则是汇合的或终止的。例如:</target>
        </trans-unit>
        <trans-unit id="37534f2a655b7b54b3a6e0e503e96b3a7186887d" translate="yes" xml:space="preserve">
          <source>GHC may produce the following standard DIEs in the &lt;code&gt;.debug_info&lt;/code&gt; section,</source>
          <target state="translated">GHC可以在 &lt;code&gt;.debug_info&lt;/code&gt; 部分中生成以下标准DIE，</target>
        </trans-unit>
        <trans-unit id="421a7300b70d01de5b5db3b095ba0095f1fbdbfa" translate="yes" xml:space="preserve">
          <source>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the &lt;a href=&quot;codegens#native-code-gen&quot;&gt;native code generator&lt;/a&gt; (&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt;&lt;code&gt;-fasm&lt;/code&gt;&lt;/a&gt;) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there&amp;rsquo;s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</source>
          <target state="translated">通过C进行编译时，GHC不再包含外部头文件，因此不会执行此检查。进行此更改是为了与本&lt;a href=&quot;codegens#native-code-gen&quot;&gt;机代码生成器&lt;/a&gt;（&lt;a href=&quot;phases#ghc-flag--fasm&quot;&gt; &lt;code&gt;-fasm&lt;/code&gt; &lt;/a&gt;）兼容，并严格遵守FFI规范，该规范要求FFI调用不得进行宏扩展以及使用C头文件时可能应用的其他CPP转换。这种方法还简化了跨模块和包边界的外部调用的内联：编译外部调用的内联版本时，不需要头文件可用，因此编译器可以在任何上下文中自由地内联外部调用。</target>
        </trans-unit>
        <trans-unit id="2b8ae90a6a33abf2e10b63d4f5e2fffb42594017" translate="yes" xml:space="preserve">
          <source>GHC normally imports &lt;code&gt;Prelude.hi&lt;/code&gt; files for you. If you&amp;rsquo;d rather it didn&amp;rsquo;t, then give it a &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; option. The idea is that you can then import a Prelude of your own. (But don&amp;rsquo;t call it &lt;code&gt;Prelude&lt;/code&gt;; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</source>
          <target state="translated">GHC通常会为您导入 &lt;code&gt;Prelude.hi&lt;/code&gt; 文件。如果您不想这样做，请给它一个 &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; 选项。这样做的想法是您可以导入自己的前奏。 （但不要称其为 &lt;code&gt;Prelude&lt;/code&gt; ； Haskell模块的名称空间是平坦的，并且您不得与任何Prelude模块冲突。）</target>
        </trans-unit>
        <trans-unit id="51a9a8d7dba56ae1e5e3495d0ce96e9d8abfbf97" translate="yes" xml:space="preserve">
          <source>GHC note: a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; will be automatically closed when the garbage collector detects that it has become unreferenced by the program. However, relying on this behaviour is not generally recommended: the garbage collector is unpredictable. If possible, use an explicit &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; to close &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s when they are no longer required. GHC does not currently attempt to free up file descriptors when they have run out, it is your responsibility to ensure that this doesn't happen.</source>
          <target state="translated">GHC注意：当垃圾收集器检测到该 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 已被程序未引用时，该句柄将自动关闭。但是，通常不建议依赖此行为：垃圾收集器是不可预测的。如果可能，请在不再需要它们时使用显式 &lt;code&gt;&lt;a href=&quot;system-io#v:hClose&quot;&gt;hClose&lt;/a&gt;&lt;/code&gt; 关闭 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 。当文件描述符用完时，GHC当前不尝试释放它们，这是您的责任，以确保不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="40c291d3bf2780069335f412ddeb31f3318572c7" translate="yes" xml:space="preserve">
          <source>GHC note: the number of capabilities is specified by the &lt;code&gt;+RTS -N&lt;/code&gt; option when the program is started. Capabilities can be fixed to actual processor cores with &lt;code&gt;+RTS -qa&lt;/code&gt; if the underlying operating system supports that, although in practice this is usually unnecessary (and may actually degrade performance in some cases - experimentation is recommended).</source>
          <target state="translated">GHC注意：启动程序时，功能数量由 &lt;code&gt;+RTS -N&lt;/code&gt; 选项指定。如果底层操作系统支持，则可以使用 &lt;code&gt;+RTS -qa&lt;/code&gt; 将功能固定在实际的处理器核心上，尽管在实践中这通常是不必要的（在某些情况下可能会降低性能-建议进行实验）。</target>
        </trans-unit>
        <trans-unit id="115bd9cb4711dab5b627ce7841a7aee928c90c42" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。与mallocForeignPtr一样，它在垃圾回收堆中使用固定的内存。与mallocForeignPtr不同，使用mallocPlainForeignPtr创建的ForeignPtr不包含终结器。无法将终结器添加到使用mallocPlainForeignPtr创建的ForeignPtr中。这对于仅存在于Haskell内的ForeignPtr（例如为打包字符串创建的ForeignPtr）很有用。尝试将终结器添加到以此方式创建的ForeignPtr或终结该指针，将引发异常。</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在，GHC允许您直接使用扩展名&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;来指定类型变量的种类，无论类型变量是否被显式绑定。</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHC现在允许使用扩展&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;派生此类实例，因此可以编写</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHC现在支持一种用于协调并发Haskell线程活动的新方法，称为软件事务存储（STM）。该&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM文件&lt;/a&gt;是一个很好的介绍STM是什么，以及如何使用它。</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHC在这里为您提供帮助。对于用户源中的 &lt;code&gt;assert&lt;/code&gt; 的每次使用：</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHC只知道已&lt;em&gt;安装的&lt;/em&gt;软件包。已安装的软件包位于软件包数据库中。有关软件包数据库以及如何控制GHC可以看到哪些软件包数据库或特定的一组软件包的详细信息，请参见&lt;a href=&quot;#package-databases&quot;&gt;软件包数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHC如下执行隐式量化。在用户编写的类型的最外层（仅），当且仅当没有显式的 &lt;code&gt;forall&lt;/code&gt; 时，GHC 才会找到该类型中提到的所有不在范围内的类型变量，并对其进行通用量化。例如，以下对等效：</target>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHC在每次调用时都会重新计算依赖关系,所以依赖关系永远不会与源码不同步。</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHC在两个方面放宽了这一规则。</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC报告错误，说是那种 &lt;code&gt;a&lt;/code&gt; 应该是一种可变 &lt;code&gt;k&lt;/code&gt; ，而不是 &lt;code&gt;Type&lt;/code&gt; 。这是因为，通过查看所有类型的签名 &lt;code&gt;forall a. Proxy a&lt;/code&gt; ，GHC假定 &lt;code&gt;a&lt;/code&gt; 的种类应被概括，而不限于 &lt;code&gt;Type&lt;/code&gt; 。然后，由于功能定义比其类型签名更具体，该功能定义被拒绝。</target>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC要求使用 &lt;code&gt;hs-boot&lt;/code&gt; 文件来减少相互递归模块之间的递归循环，如&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中所述&lt;/a&gt;。Haskell报告说（&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;第5.7节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC通过三个步骤解决了 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC通过三个步骤解决了 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHC &lt;code&gt;HasCallStack&lt;/code&gt; 解决了HasCallStack约束：</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">GHC有时会对类型化的孔提出有效的孔配合,这可以通过一些标志来配置。</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHC支持&lt;em&gt;种类索引的&lt;/em&gt;类型族，其中族在类型和类型上都匹配。没有完整的用户提供的种类签名，GHC &lt;em&gt;不会&lt;/em&gt;推断出这种行为，因为这样做有时会推断出非主要类型。确实，我们可以将种类索引视为一种多态递归形式，其中一种类型在其定义中使用的种类不同于其最一般的种类。</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHC支持按&lt;em&gt;词法作用域定义的类型变量&lt;/em&gt;，没有这些&lt;em&gt;变量&lt;/em&gt;，根本无法编写某些类型签名。例如：</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC支持&lt;em&gt;重载标签&lt;/em&gt;，这是一种标识符形式，其解释可能取决于其类型和文字文本。当&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;启用扩展，过载标签可以用前缀的散列被写入，例如 &lt;code&gt;#foo&lt;/code&gt; 。此表达式的类型为 &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC支持&lt;em&gt;重载字符串文字&lt;/em&gt;。通常，字符串文字的类型为 &lt;code&gt;String&lt;/code&gt; ，但是启用重载字符串文字（使用&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;）后，字符串文字的类型为 &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHC支持&lt;em&gt;列表符号的重载&lt;/em&gt;。让我们回顾一下构造列表的概念。在Haskell中，可以通过以下七种方式使用列表符号：</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC默认情况下支持并发Haskell，不需要特殊选项或以某种方式编译的库。要访问并发Haskell支持库，只需导入&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent即可&lt;/a&gt;。该模块的文档中提供了有关并发Haskell的更多信息。</target>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC支持的模式匹配称为扩展&lt;em&gt;爆炸图案&lt;/em&gt;，写 &lt;code&gt;!pat&lt;/code&gt; 。Haskell Prime正在考虑使用爆炸样式。在&lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell的主要特征描述&lt;/a&gt;含有比下面的材料更多讨论和示例。</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHC支持未装箱元素的数组，包括 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Char&lt;/code&gt; 在内的几种基本算术元素类型：有关详细信息，请参见&lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt;库。这些数组可能比使用&lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt;库中的标准Haskell 98数组快得多。</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHC同时支持并发和并行。</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHC支持多个后端代码生成器。这是编译器的一部分,负责将GHC使用的最后一个中间表示法(一种叫做Cmm的形式,是一种简单的、类似于C的语言),编译成可执行代码。下面介绍一下GHC支持的后端。</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC在类型级别支持数字和字符串文字，从而可以方便地访问大量预定义的类型级别常量。数值文字属于 &lt;code&gt;Nat&lt;/code&gt; 类型，字符串文字属于 &lt;code&gt;Symbol&lt;/code&gt; 类型。&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;语言扩展启用了此功能。</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHC支持多种语言扩展，包括并发，外部函数接口，异常，类型系统扩展（例如多参数类型类，局部通用和存在量化），功能依赖项，作用域类型变量和显式拆箱类型。这些都在&lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC语言功能中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHC支持在SMP(对称多处理器)上并行运行Haskell程序。</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHC支持多种编译指示，或在源代码中提供给编译器的指令。语法通常不会影响程序的含义，但可能会影响所生成代码的效率。</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHC支持相互递归模块的编译。本节将解释如何编译。</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHC支持这些语言选项。</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC支持类型参数的三种不同角色：名义，代表性和幻像。如果类型参数具有名义上的作用，那么两个不同的类型实际上根本不能完全不同：它们必须是相同的（在减少类型族之后）。如果类型参数具有代表性，则两个类型必须具有相同的代表性。 （如果 &lt;code&gt;T&lt;/code&gt; 的第一个参数的角色是表示性的，则 &lt;code&gt;T Age Bool c&lt;/code&gt; 和 &lt;code&gt;T Int Bool c&lt;/code&gt; 将具有相同的表示形式，因为 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; 具有相同的表示形式。）如果类型参数具有幻像角色，则不需要更多信息。</target>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHC采取保守的立场:它接受前两个,但不接受第三个。规则是:推断的实例上下文中的每个约束必须只由类型变量组成,不能重复。</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">然后,GHC使用这些集合中的每一个检查模式覆盖率。如果这些集合中的任何一个都通过了模式覆盖率检查器,没有警告,那么我们就完成了。如果每个集合至少产生一个警告,那么GHC必须根据结果的好坏来选择其中的一个警告集合。结果的优先顺序是这样的。</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHC跟踪我们所谓的&lt;em&gt;推断&lt;/em&gt;类型变量和&lt;em&gt;指定&lt;/em&gt;类型变量之间的区别。仅指定的类型变量可用于可见类型应用程序的实例化。一个例子很好地说明了这一点：</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">GHC曾经有一个通用类的实现，如&amp;ldquo;可派生类型类&amp;rdquo;一书中所定义，Ralf Hinze和Simon Peyton Jones，Haskell Workshop，蒙特利尔，2000年9月，第94-105页。这些已被删除，并由&lt;a href=&quot;#generic-programming&quot;&gt;对通用编程&lt;/a&gt;的更一般的支持代替。</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">GHC默认情况下使用复制垃圾收集器。&amp;ldquo; GC期间复制的字节&amp;rdquo;告诉您在垃圾回收期间必须复制多少字节。</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC使用&lt;a href=&quot;#instance-termination&quot;&gt;Paterson条件&lt;/a&gt;来确保实例解析终止。这些规则如何针对量化约束进行修改？有两种方式。</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">8.8之前的GHC版本定义了未记录的函数 &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; 和 &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; ,而不是 &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; 和 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 。这些名称现在已弃用。</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC将为所有未标记为INLINE的导出功能自动添加 &lt;code&gt;SCC&lt;/code&gt; 注释。如果要在INLINE函数上建立成本中心，则必须手动添加。</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC将为所有未标记为INLINE的顶级绑定自动添加 &lt;code&gt;SCC&lt;/code&gt; 注释。如果要在INLINE函数上建立成本中心，则必须手动添加。</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">GHC会抱怨这一点,因为你以后可能会加上</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">GHC将生成一个实例,该实例等同于</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHC将重写这一点,以包括作出断言的源头位置。</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">GHC将使用 &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; 成功编译该模块，因为默认的导出列表将包括 &lt;code&gt;program&lt;/code&gt; 而不是 &lt;code&gt;main&lt;/code&gt; ，这是Haskell报告通常要求的。</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">GHC的 &lt;code&gt;-main-is&lt;/code&gt; 选项可用于将顶级入口点的名称从 &lt;code&gt;main&lt;/code&gt; 更改为任何其他变量。当编译主模块并且使用 &lt;code&gt;-main-is&lt;/code&gt; 重命名默认入口点时，GHC还将在默认导出列表中使用备用名称。</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">GHC的行为由选项控制，由于历史原因，这些选项有时也称为命令行标志或参数。可以通过三种方式指定选项：</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">GHC的行为首先由模式标志控制。这些标志只能给出一个，但不一定是命令行上的第一个选项。例如，</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">GHC的编译输出通常会进入 &lt;code&gt;.hc&lt;/code&gt; ， &lt;code&gt;.o&lt;/code&gt; 等文件，具体取决于上次运行的编译阶段。选项 &lt;code&gt;-o file&lt;/code&gt; 将最后运行阶段的输出重定向到⟨file⟩。</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">GHC的默认行为是，&lt;em&gt;一个实例必须与它要解析的约束完全匹配&lt;/em&gt;。例如，约束 &lt;code&gt;C Int Bool&lt;/code&gt; 与实例（A）和（B）匹配，因此将被拒绝；而 &lt;code&gt;C Int Char&lt;/code&gt; 仅匹配（A），因此选择了（A）。</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">GHC的实现与Haskell 98定义有所不同，在某种意义上， &lt;code&gt;isAlpha&lt;/code&gt; 仍将不区分大小写的Unicode字母字符识别为字母。</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">GHC的 &lt;code&gt;array&lt;/code&gt; 实现从列表中的最后一对（索引，值）对中获取一个数组插槽的值，并且不检查重复项。原因是效率，纯净和简单。</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">GHC 对整数类型的 &lt;code&gt;Read&lt;/code&gt; 类的实现接受十六进制和八进制文字（Haskell 98报告中的代码不接受）。因此，例如</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHC的mdo表示法的实现紧随原始翻译，如&lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell的&lt;/a&gt;&lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;递归方法一书中&lt;/a&gt;所述，而Haskell则基于Monadic计算中的Value Recursion。此外，GHC扩展了前一篇论文中描述的语法，并使用了 &lt;code&gt;rec&lt;/code&gt; 关键字标记的较低级语法，如下所述。</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">可以使用通过数据类型对递归进行编码的标准方法，来说服GHC的内线不终止：</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">如果您编写不终止的重写规则（&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite规则&lt;/a&gt;），或者如果您通过数据类型对递归进行编码（&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC中的Bug&lt;/a&gt;），则GHC的优化器可能会有所不同。为避免使编译器陷入无限循环，优化器会携带&amp;ldquo;滴答计数&amp;rdquo;，并在超过此计数时停止内联并应用重​​写规则。该限制设置为程序大小的倍数，因此，较大的程序会获得更多滴答声。该 &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; 标志可以让你改变乘数。默认值为100；默认值为100。大于100的数字给出更多的刻度，而小于100的数字给出更少的刻度。</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">由于在运行时系统中进行了大量实验和调整，GHC的并行性支持在6.12.1中得到了改进。我们仍然有兴趣了解它对您的运作情况，并且也有兴趣收集并行程序以添加到我们的基准测试套件中。</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">GHC的配置文件系统将成本分配给成本中心。成本只是评估表达式所需的时间或空间（内存）。成本中心是围绕表达式的程序注释；带注释的表达式引起的所有成本都分配给封闭的成本中心。此外，GHC将在运行时记住任何给定表达式的封闭成本中心堆栈，并生成成本归因的调用树。</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">GHC的性能分析系统支持&amp;ldquo;成本中心堆栈&amp;rdquo;：一种在类似调用图的结构中查看Haskell程序配置文件的方式。有关更多详细信息，请参见&lt;a href=&quot;profiling#profiling&quot;&gt;分析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">GHC的运行时系统具有内置支持，可从运行中的Haskell程序收集堆栈跟踪信息。目前这要求 &lt;code&gt;libdw&lt;/code&gt; 从图书馆 &lt;code&gt;elfutils&lt;/code&gt; 封装。当然，除非在可执行文件及其依赖库中提供了调试信息，否则回溯几乎没有用。</target>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC的运行时系统实现了协作式多任务处理，仅当程序分配时，上下文切换才可能发生。这意味着未分配的程序可能永远不会进行上下文切换。对于使用STM的程序尤其如此，在观察到不一致的状态后，它们可能会死锁。有关更多讨论，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;问题＃367&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">GHC的类型系统支持类型中的&lt;em&gt;任意等级的&lt;/em&gt;显式通用量化。例如，以下所有类型都是合法的：</target>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">GHC的数组实现。</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">GHC对并发性的实施</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">GHC对 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 数据类型的实现。</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">默认情况下，GHC不再依赖cygwin，而是本地Windows程序。它是使用mingw构建的，并且在编译Haskell源代码时会使用mingw的GHC（即使您从cygwin的bash调用它），但是这里重要的是-就像任何其他普通的Windows程序一样-GHC和它生成的可执行文件都不是了解Cygwin假装的Unix层次结构。 GHC很乐意接受 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\\&lt;/code&gt; 作为路径分隔符，但是它不知道在哪里可以找到 &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; 或 &lt;code&gt;/bin/bash&lt;/code&gt; 等。在Cygwin的bash中或在Cygwin下运行的make-session中使用GHC时，这会带来各种乐趣。</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;是GHC的交互式环境，在其中可以交互评估Haskell表达式并可以解释程序。如果您熟悉&lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;，那么GHCi 就是您的家。但是，GHCi还支持以交互方式加载已编译的代码，并支持GHC提供的所有&lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;语言扩展。GHCi还包括一个交互式调试器（请参阅&lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">实际上,GHCi 接受的是语句,而不仅仅是提示中的表达式,这意味着你可以将值和函数绑定到名称上,并在未来的表达式或语句中使用。这意味着你可以将值和函数绑定到名称上,并在未来的表达式或语句中使用它们。</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCi实际上维护着&lt;em&gt;两种&lt;/em&gt;选择：</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCi还可以从命令行加载普通目标文件（ &lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.obj&lt;/code&gt; ,具体取决于您的平台）或静态归档文件（ &lt;code&gt;.a&lt;/code&gt; ）。只需将名称对象文件或库添加到命令行即可。在Windows上，GHCi还支持 &lt;code&gt;big-obj&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">当运行解释代码时,GHCi可以使用剖析系统收集堆栈跟踪信息。要获得堆栈跟踪信息,请像这样启动GHCi。</target>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">GHCi命令全部以&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo; 开头，并由单个命令名和零个或多个参数组成。可以缩写命令名称，并解决歧义以支持更常用的命令。</target>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi包含一个简单的命令式调试器，您可以在其中停止运行的计算以检查变量的值。该调试器已集成到GHCi中，并且默认情况下处于打开状态：不需要任何标志即可启用调试功能。有一个主要限制：断点和单步仅在解释模块中可用；调试器看不到已编译的代码&lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCi不仅可以立即执行简单的表达式评估。如果为某些 &lt;code&gt;a&lt;/code&gt; 输入 &lt;code&gt;IO a&lt;/code&gt; 类型的表达式，则GHCi将其作为IO计算&lt;em&gt;执行&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCi不遵守您所在范围的模块中的 &lt;code&gt;default&lt;/code&gt; 声明。相反，对于在命令行中键入的表达式，您始终会获得默认的默认类型行为。即 &lt;code&gt;default(Int,Double)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi已加载 &lt;code&gt;Main&lt;/code&gt; 模块，并且提示符已更改为 &lt;code&gt;*Main&amp;gt;&lt;/code&gt; ,以指示在提示符下键入的表达式的当前上下文是我们刚刚加载的 &lt;code&gt;Main&lt;/code&gt; 模块（我们将在稍后&lt;a href=&quot;#ghci-scope&quot;&gt;的真正作用域中&lt;/a&gt;解释 &lt;code&gt;*&lt;/code&gt; 的含义）在提示符下？）。因此，我们现在可以键入涉及 &lt;code&gt;Main.hs&lt;/code&gt; 中的函数的表达式：</target>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi提供了对放置断点的表达式的自由变量&lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt;的绑定（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ），此外还为表达式的结果提供了绑定（ &lt;code&gt;_result&lt;/code&gt; ）。这些变量就像您可能在GHCi中定义的其他变量一样。您可以在提示符下键入的表达式中使用它们，也可以使用&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;询问它们的类型，依此类推。但是，有一个重要的区别：这些变量只能具有部分类型。例如，如果我们尝试显示 &lt;code&gt;left&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi 将整行解释为一个表达式来评估。该表达式可能不会跨越好几行--只要你按下回车键,GHCi就会尝试评估它。</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">使用命令 &lt;code&gt;ghci&lt;/code&gt; 或 &lt;code&gt;ghc --interactive&lt;/code&gt; 调用GHCi 。也可以在命令行上指定一个或多个模块或文件名。这指示GHCi加载指定的模块或文件名（以及它们依赖的所有模块），就像您在GHCi提示符下说过 &lt;code&gt;:load modules&lt;/code&gt; 一样（请参阅&lt;a href=&quot;#ghci-commands&quot;&gt;GHCi命令&lt;/a&gt;）。例如，要启动GHCi并加载其最顶层模块位于文件 &lt;code&gt;Main.hs&lt;/code&gt; 中的程序，我们可以说：</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置&lt;/a&gt; GHCi选项，而使用&lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; 取消设置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCi告诉我们，在其他绑定中， &lt;code&gt;f&lt;/code&gt; 在范围内。但是，尚不完全了解其类型，因此无法将其应用于任何参数。但是，请注意其第一个参数的类型与 &lt;code&gt;x&lt;/code&gt; 的类型相同，并且其结果类型与 &lt;code&gt;_result&lt;/code&gt; 共享。</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">GHCi 在引擎盖下使用&lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt;。您可以将其配置为除其他外，从GHCi历史记录中删除副本。请参阅：&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline用户首选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCi将制表完整范围内的名称；例如，如果您运行GHCi并键入 &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; 那么GHCi会将其扩展为 &lt;code&gt;Just&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">垃圾回收需要比实际驻留更多的内存。该因素取决于所使用的垃圾收集算法的类型：标准世代复制收集器中的主要GC通常将需要\（3L \）个字节的内存，其中\（L \）是活动数据量。这是因为默认情况下（请参阅RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 选项），我们允许旧一代在收集之前增长到其大小的两倍（\（2L \）），并且还需要复制\（L \）个字节将实时数据导入。使用压缩收集（请参阅&lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;选项）时，它减少为\（2L \），并且可以通过调整 &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 选项来进一步减少。同时添加分配区域的大小（请参见 &lt;code&gt;-A ⟨size⟩&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">一般数量 Semaphores</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">一般组合功能</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">一般组合功能</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">超级类方法的一般定义</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得常规折叠。</target>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">一般调度设施</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">一般渲染</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">通用有限序列。</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">列表函数的一般化</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">广义代数数据类型通过允许构造函数具有更丰富的返回类型来广义普通代数数据类型。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">广义列表理解是对列表理解语法糖的进一步增强，可以进行SQL熟悉的排序和分组等操作。它们在&amp;ldquo; &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;综合理解：使用&amp;rdquo;排序依据&amp;rdquo;和&amp;ldquo;分组依据&amp;rdquo;的理解中&lt;/a&gt;得到了充分的描述，只是我们使用的语法与本文略有不同。</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Control.Exception的一般化</target>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">高阶种类的泛化铸造</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">使用命题平等的类型安全浇注的通用形式。</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">使用表征平等的类型安全投递的通用形式</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">归一化职能</target>
        </trans-unit>
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">一般来说，&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;时，GHC会尝试推断最通用的声明类型。在许多情况下（例如，在数据类型声明中），该定义在右侧可以告知种类推断。但这并非总是如此。考虑</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">通常，您只能为同一模块中定义的功能提供&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;编译指示。但是，如果在函数 &lt;code&gt;f&lt;/code&gt; 的定义位置为函数f赋予了&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; pragma，则可以随后通过导入模块对其进行特殊化（请参阅&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;）。例如</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">生成一个可捕获的名称。这种名称的出现将根据发生地的 Haskell 范围规则进行解析。</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">生成一个新鲜的名字,无法捕捉。</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">以适合&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;工具输入的形式生成包依赖关系图。例如，生成依赖图的PDF：</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">生成一个共享库(相对于可执行文件)。</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">生成一个独立的静态库(相对于可执行文件)。这在交叉编译时很有用。该库和它的所有依赖关系最终会被整合到一个单一的静态库中,可以与之链接。</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">生成字节码</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生成字节码而不是目标码。这是GHCi中的默认设置。字节码当前只能在交互式解释器中使用，不能保存到磁盘。该选项仅对反转&lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;的效果有用。</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">生成与位置无关的可执行文件的代码(如有)。</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">生成与动态库链接的代码</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以可链接到与位置无关的可执行文件的方式生成代码。该代码当前在Linux x86和x86-64上有效。在Windows上，从不使用与位置无关的代码，因此该标志在该平台上为空。要链接最终的可执行文件，请使用&lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">生成彩色输出。</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">生成适合包含在LaTeX文档中的封装PostScript。通常，以横向模式在9英寸宽乘6英寸高的区域中绘制PostScript图形，并且 &lt;code&gt;hp2ps&lt;/code&gt; 将该区域安排为大约在a4纸上居中。此格式便于详细研究图形，但不适合包含在LaTeX文档中。所述 &lt;code&gt;-e&lt;/code&gt; 选项使得在纵向模式下要绘制的曲线图，与浮子指定以英寸，毫米或点（默认值）的宽度。生成的PostScript文件符合Encapsulated PostScript（EPS）约定，并且可以使用Rokicki的dvi-to-PostScript转换器 &lt;code&gt;dvips&lt;/code&gt; 将其包含在LaTeX文档中。</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">生成对象代码</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">生成对象代码。这是在GHCi之外的默认值,可以与GHCi一起使用,使对象代码优先于字节码生成。</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">生成与位置无关的代码(可放入共享库的代码)。目前在Linux x86和x86-64上工作。在Windows上,位置无关的代码从来不会被使用,所以这个标志在该平台上是不可行的。</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">生成与位置无关的代码(如有)</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">由预处理器生成,以传达原始源的源行号。</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">为Vi风格的编辑器（&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt;）或Emacs风格的编辑器（&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt;）生成一个&amp;ldquo;标签&amp;rdquo;文件。如果未指定文件名，则分别使用默认 &lt;code&gt;tags&lt;/code&gt; 或 &lt;code&gt;TAGS&lt;/code&gt; 。创建当前加载模块中所有功能，构造函数和类型的标记。必须解释所有模块，这些命令才能起作用。</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在文件 &lt;code&gt;prog.hp&lt;/code&gt; 中生成一个基本的堆配置文件。要生&lt;strong&gt;成堆&lt;/strong&gt;配置文件图，请使用&lt;strong&gt;hp2ps&lt;/strong&gt;（请参阅&lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash;将堆配置文件呈现到PostScript&lt;/a&gt;）。基本堆配置文件由数据构造函数分解，而其他类型的闭包（函数，thunk等）则分为大类（例如 &lt;code&gt;FUN&lt;/code&gt; ， &lt;code&gt;THUNK&lt;/code&gt; ）。要获得更详细的配置文件，请使用完整的分析支持（&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;）。可以缩短为&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">在一次GHC中生成动态和静态目标文件。此选项在功能上等同于运行GHC两次，第二次添加 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">生成以下实例</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">生成和展开ByteStrings</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">生成和展开</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">通用构造函数类</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">通用实例</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">通用操作定义为 &lt;code&gt;gunfold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHC中的通用编程支持允许实例化时使用不需要用户指定的方法来定义类：方法主体由GHC自动派生。例如，这类似于标准类（例如 &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; ）的情况，但是现在用户定义的类会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">通用代表类型</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">通用表示类型</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">通用支持</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">通用类型类</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">获取一个以NUL字节结束的懒惰ByteString。返回的字符串不包含NUL字节。如果到了输入端没有找到NUL,则失败。</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">在$ PATH变量中获取 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">在$ PATH变量中获取 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">在断点处获取对自由变量的引用。</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">使用提供的投影函数,获取状态的特定分量。</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">获取当前执行栈状态的字符串表示。</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">获取当前执行栈状态的跟踪。</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">获取所有的分机。</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">获取一个环境值或默认值。</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">获得一个执行堆栈。</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">获取当前运行时的系统统计数据。</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad 获取状态。请注意，状态是在其中执行模板Haskell表达式的Haskell模块本地的。</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 放在 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">获取与给定值关联的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 放在 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">获取与给定值关联的 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">获取某地时间在某一子午线上的UT1时间(单位:度,正数为东)。</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">获取一个时区的当地时间的UTC时间。</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">获取基本名称,不含扩展名或路径。</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">获取 &lt;code&gt;PATH&lt;/code&gt; 环境变量的内容。</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">从系统时钟获取当前 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">从系统时钟获取当前POSIX时间。</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">获取当前行输入历史。</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">获取当前时区。</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">获取当前线程中 &lt;code&gt;errno&lt;/code&gt; 的当前值。</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">获取终端的默认大小。对于可调整大小的终端（例如 &lt;code&gt;xterm&lt;/code&gt; ），这些可能与实际尺寸不符。</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">获取目录名,上移一级。</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">从文件路径中获取驱动器。</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">获取连接到终端的手柄的呼应状态。</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">获取文件的扩展名， &lt;code&gt;.ext&lt;/code&gt; 没有扩展名，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，否则返回.ext。</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">获取文件名。</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">获取另一个字符串中子字符串的第一个索引，如果找不到该字符串，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;findSubstring p s&lt;/code&gt; 等同于 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">获取一天中给定时间的午夜后的分数。</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">通过使用窗口的标题获取当前控制台窗口的句柄。请参阅：&lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt; : //support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">获取当前控制台窗口的句柄。</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">获取给定钥匙的标签。</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的标签。</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的标签。</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">获取UT1时间在某一子午线上的当地时间(以度为单位,正数为东)。</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">获取一个时区的UTC时间的当地时间。</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">获取给定时间的当地时区(根据夏季调整而变化)。</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TBQueue&lt;/code&gt; 中获取下一个值而不删除它，如果通道为空，则重试。</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TChan&lt;/code&gt; 获取下一个值而不删除它，如果通道为空则重试。</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TQueue&lt;/code&gt; 获取下一个值而不删除它，如果通道为空，则重试。</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; 中的皮秒数。</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">获取一年中的星期一开始的星期几和星期几。第一个星期一为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%W&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。星期一是1，星期日是7（在 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 中为 &lt;code&gt;%u&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">获取一年中的星期天开始的星期几。第一个星期天为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%U&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。周日是0，星期六是6（如 &lt;code&gt;%w&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">获取文件或目录的权限。</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">获取固定值的优先级。</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">获取剩余的字节作为一个懒惰的ByteString。请注意,这可能是一个昂贵的函数,因为它强制读取所有的输入并将字符串保存在内存中。</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 中获取秒数。</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的源范围。</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的源范围。</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">获取连接到对象的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">获取对应于给定格式指定器的字符串。</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">获取系统时间，以1970年UTC为起始时间，忽略leap秒。 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 通常比 &lt;code&gt;getCurrentTime&lt;/code&gt; 快得多。</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的尾部。</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的尾部。</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">获取从午夜开始的一天的时间。超过24小时的时间将被转换为闰秒。</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">获取一天的时间,给定从午夜起一天的分数。</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">获取一天中某一时间的午夜后的时间。</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">获取至此读取的总字节数。</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">获取用户名。参见：&lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https&lt;/a&gt; : //github.com/haskell/win32/issues/8，http : &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;//lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">获取/设置前景窗口。</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">从给定的操作系统手柄或POSIX fd中获取一个GHC手柄文件描述。</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">使用所提供的投影函数,获取状态的特定组成部分。</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">获取索引的构造函数(仅代数数据类型)。</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">获取一个代数数据类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">获取构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">获取构造函数的字段标签。标签列表的返回顺序与原始构造函数声明中给出的顺序相同。</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">获取构造函数的固定性</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">获取构造函数的索引(仅代数数据类型)。</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">获取一个代数数据类型的最大构造函数索引。</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">获取类型构造函数的模块:在name前取*.*.*...。</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">获取一个数据类型的公开展示。</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">获取建造者的公开展示</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">获取构造函数的字符串</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">获取包括模块在内的类型构造函数</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">获取非限定类型构造函数:在name前丢弃*.*.*...。</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给插件模块提供参数；必须使用&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;指定模块。</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">给插件模块提供参数；必须使用 &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 指定模块</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">给予明确的类型签名。</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">给定一个压缩包和它的一个块的地址,返回下一个块和它的大小,如果参数是压缩包中的最后一个块,则返回#nullAddr。</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">给定路径段列表，请展开 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 。路径段不得包含路径分隔符。</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">给定一个字符串列表,将它们连接成一个单一的字符串,并对某些字符进行转义,在每个字符串之间添加一个换行符。转义是通过在任何空格、单引号、双引号或反斜杠字符前添加一个反斜杠字符来完成的,因此必须删除这个转义字符。未转码的空白字符(在本例中是新行)是这种 &quot;传输 &quot;格式的一部分,用于表示前一个字符串的结束和新字符串的开始。</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">给定一个结构元素映射到列表的方法,计算所有这些列表的顺序连接。</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">给定一个名称或路径， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 追加 &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; 的查询和搜索在给定的搜索目录列表中的可执行文件，并返回所有出现。</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">鉴于形式的平行理解。</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">给定形式的模式同义词定义</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">给定程序 &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; 和参数 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; ， &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 返回适合粘贴到 &lt;code&gt;/bin/sh&lt;/code&gt; （在Unix系统上）或 &lt;code&gt;CMD.EXE&lt;/code&gt; （在Windows上）的字符串。</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将源数组中的元素复制到目的数组中。两个数组都必须完全包含指定的范围,但这并不被检查。在源数组和目的数组是同一个数组的情况下,源数组和目的数组的区域可能会重叠。</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将源数组中的元素复制到目的数组中。两个数组必须完全包含指定的范围,但这并不被检查。两个数组在不同状态下必须不是同一个数组,但这也不被选中。</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将元素从源数组复制到目的数组。源数组和目的数组可以指同一个数组。两个数组必须完全包含指定的范围,但这并不被检查。允许区域重叠,但这只有在源数组和目的数组都是同一个数组时才有可能。</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量和要复制的元素数量,用源数组中的元素创建一个新的数组。所提供的数组必须完全包含指定的范围,但这并不被检查。</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">给定一串串接的字符串，请通过除去某些字符的&lt;em&gt;引号&lt;/em&gt;和/或&lt;em&gt;转义&lt;/em&gt;符来分隔每个字符串。</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">给定类型为 &lt;code&gt;Right a&lt;/code&gt; 的值，GHC必须产生类型为 &lt;code&gt;Right b&lt;/code&gt; 的值。由于 &lt;code&gt;Right&lt;/code&gt; 构造函数的参数的类型为 &lt;code&gt;Either Int a&lt;/code&gt; ，因此代码对它进行递归调用 &lt;code&gt;fmap&lt;/code&gt; ，以生成 &lt;code&gt;Either Int b&lt;/code&gt; 类型的值，该值又用于构造 &lt;code&gt;Right b&lt;/code&gt; 类型的最终值。</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">给定年份,根据东正教传统找到复活节。</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">给定一个年份,根据格里高利年法找出复活节</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">给定一年,根据东正教的传统,找出受难节满月的日子</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">给定一个年份,根据格里高利法找出受难节满月。</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">给定一个任意地址和一个对齐约束， &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 产生下一个满足对齐约束的更高地址。对齐约束 &lt;code&gt;x&lt;/code&gt; 由 &lt;code&gt;x&lt;/code&gt; 整除的任何地址都可以满足。此操作是幂等的。</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">给定一个任意地址和一个对齐约束， &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 产生下一个满足对齐约束的更高地址。对齐约束 &lt;code&gt;x&lt;/code&gt; 由 &lt;code&gt;x&lt;/code&gt; 整除的任何地址都可以满足。此操作是幂等的。</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个Int单位的偏移量,读取一个元素。假设索引在边界内。意味着有一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个Int单位的偏移量,写一个元素。假设索引在边界内。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,一个Int单位的偏移量,预期的旧值和新值,如果当前值与提供的旧值匹配,则执行原子比较和交换,即写入新值。返回操作前元素的值。意味着有一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(单位为Int),以及一个AND值,原子地AND元素的值。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,和偏移量(Int单位),以及一个NAND值,原子地将该值NAND到元素上。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(单位为Int),以及一个要OR的值,原子性地对元素进行OR操作。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要XOR的值,原子地对元素的值进行XOR。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要添加的值,原子地将其添加到元素中。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要减去的值,原子地减去元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">假设 &lt;code&gt;Int#&lt;/code&gt; 的类型不是 &lt;code&gt;Type&lt;/code&gt; ，则 &lt;code&gt;Maybe Int#&lt;/code&gt; 是禁止了Int＃。同样，由于类型变量倾向于是 &lt;code&gt;Type&lt;/code&gt; 类型（例如，在 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; ，所有类型变量的类型都为 &lt;code&gt;Type&lt;/code&gt; ） ，多态性倾向于不适用于原始类型。退后一步是有道理的，因为多态函数需要操纵指向其数据的指针，并且大多数基本类型都未装箱。</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">鉴于此方法适用于 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ,因此如果您请求0或更少的重复，则允许失败，默认定义将这样做。</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">鉴于此方法适用于 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ,因此如果您请求0或更少的重复，则允许失败，默认定义将这样做。</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">但是，考虑到我们具有 &lt;code&gt;Collects&lt;/code&gt; 的依赖项信息，我们可以推论 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 必须相等，因为它们在具有相同第一个参数 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;Collects&lt;/code&gt; 约束中都作为第二个参数出现。因此，我们可以为 &lt;code&gt;f&lt;/code&gt; 推断一个更短，更准确的类型：</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">给定示例 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">给定示例 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">鉴于GADT（通用代数数据类型）提供的功能，似乎上述定义似乎是可行的。但是，与GADT相反，类型族是&lt;em&gt;开放的。&lt;/em&gt;也就是说，总是可以在其他模块中添加新实例。支持跨不同数据实例的模式匹配将需要一种可扩展的案例构造形式。</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">给定所需的最大大小和一个用于生成ByteString内容的函数，createAndTrim生成 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。需要生成函数返回实际的最终大小（&amp;lt;=最大大小），然后将结果字节数组重新分配给该大小。</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">给定可执行文件的名称或路径后， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 会在系统定义的位置列表中搜索此类文件，该位置通常包括 &lt;code&gt;PATH&lt;/code&gt; 以及可能的更多内容。如果找到，则返回可执行文件的完整路径。例如， &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; 通常会为您提供GHC的路径。</target>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">给定一个契约的第一个块的指针,以及根对象在旧的地址空间中的地址,修正契约内部的指针,使其在内存中的位置与序列化时不同。在导入一个序列化的契约后,这个方法必须准确调用一次,并返回新的契约和新的调整后的根地址。</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">考虑到这个声明,下面是形式良好和形式不良类型的例子。</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">提供 &lt;code&gt;+RTS -?&lt;/code&gt; RTS选项选项将打印出程序中实际可用的RTS选项（具体取决于您的编译方式）。</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">为一个类方法提供一个rule是个坏主意。</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">格拉斯哥Haskell是一个不断变化的系统，因此肯定会有错误。如果找到一个，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;此Wiki页面&lt;/a&gt;以获取有关如何报告它的信息。</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">绑定在TH AST之外的全局名。一个原始的名字(只出现,不绑定)也需要命名空间来确定我们命名的是什么东西</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">转到&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC主页&lt;/a&gt;，然后单击 &amp;ldquo;下载&amp;rdquo;链接为您的平台下载GHC。</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">除了&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;）之外，&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;扩展允许在单个模块中使用相同的字段名称声明多个数据类型。例如，它允许：</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">控制GHC允许功能展开的最大大小。（展开的&amp;ldquo;大小&amp;rdquo;以在呼叫站点展开（又称内联）的&amp;ldquo;代码膨胀&amp;rdquo;反映了成本。较大的功能将被分配较高的成本。）</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">图形算法</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">图形结构</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">图形属性</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">图形变换</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">公历</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">组有执行权限。</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">组有阅读权限。</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">组有读、写和执行权限。</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">组有写权限。</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">组语句（与&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">防止负结果值</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">防范空指针</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">警卫使用 &lt;code&gt;guard&lt;/code&gt; 功能翻译，该功能需要 &lt;code&gt;MonadPlus&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">为可能失败的IO操作提供保护</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch，Daniel Ferizovic和Yihan Sun，&amp;ldquo; &lt;em&gt;只需加入并行有序集&lt;/em&gt; &amp;rdquo;，&lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https：&lt;/a&gt; //arxiv.org/abs/1602.02120v3 。</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">HACKER TERRITORY.HACKER TERRITORY.黑客栈。(你被警告。 )</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">然而,这通常不是你想做的!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPC以两种主要方式显示两种信息：带有摘要统计信息的文本报告（ &lt;code&gt;hpc report&lt;/code&gt; ）和带有颜色标记的源（ &lt;code&gt;hpc markup&lt;/code&gt; ）。对于布尔覆盖率，每个警卫，条件或限定词都有四种可能的结果：出现True和False值；只有真；只有错误；从未评估。在hpc-markup输出中，以黄色背景突出显示表示该程序的一部分从未被评估过。绿色背景表示始终为True表达式，红色背景表示始终为False。</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPC不会尝试锁定 &lt;code&gt;.tix&lt;/code&gt; 文件，因此同一目录中同时运行的多个二进制文件将显示竞争状态。在编译时，无法更改生成的 &lt;code&gt;.tix&lt;/code&gt; 文件的名称。在运行时，可以使用&lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; &lt;/a&gt;更改生成的 &lt;code&gt;.tix&lt;/code&gt; 文件的名称。如果重命名二进制文件，则 &lt;code&gt;.tix&lt;/code&gt; 文件的名称也将更改。HPC不适用于GHCi。</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">HPC检测通过&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt;标志启用：</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">处理一个错误。</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">处理一个异常。</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">处理由文件描述符(FD)实现的操作。</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">处理属性</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">读取的手柄</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stderr&lt;/code&gt; 的句柄（无=&amp;gt;使用现有的 &lt;code&gt;stderr&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stdin&lt;/code&gt; 的句柄（无=&amp;gt;使用现有的 &lt;code&gt;stdin&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stdout&lt;/code&gt; 的句柄（无=&amp;gt;使用现有 &lt;code&gt;stdout&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">要写给的手柄</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">当发生异常时要调用的处理程序</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">处理特定类型修饰符</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">使用Win32 API处理硬链接。[仅NTFS]</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">处理信号</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
