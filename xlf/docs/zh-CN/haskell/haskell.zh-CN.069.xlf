<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="2a4e313748880e797d1bcb646d76cb8547d19d57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型有时被用来表示一个值，其是正确或错误; 按照惯例， &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数用于保存错误值，而 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数用于保存正确的值（助记符：&amp;ldquo; right&amp;rdquo;也表示&amp;ldquo; correct&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="f0e4baff05206c672300bb2b38395a9530159b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型表示的值与两种可能性：type的值 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 或者是 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c8bc066a25dbdc9345dc643976410a0121b2ada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类定义平等（ &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）和不等式（ &lt;code&gt;&lt;a href=&quot;data-eq#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ）。&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出的所有基本数据类型都是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例，并且 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 可以针对其组成也是 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例的任何数据类型派生。</target>
        </trans-unit>
        <trans-unit id="69af3900bc4a32d170db2d927f8de7596335e0e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instances traverse the real part first.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 的情况下，首先遍历实部。</target>
        </trans-unit>
        <trans-unit id="5eff372cb874b6edeef6ee4a0a04355990bb5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-foldable#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和结构，并返回该结构的最左边的元素相匹配的谓词，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="168798718c8d67f564d095b7f2c27b1f23db19a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-foldable#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="7cca4119f8a53ddfe67d87125c91cc29b78f8689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-foldable#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="f9699a12c867a28d982d3293073c01ca1c9af29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">来自 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 将忽略 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值，但会将提供的函数应用于 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 中包含的值：</target>
        </trans-unit>
        <trans-unit id="b77100b25e8a5a0820122925237280bb25f1620c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; function is also available as the infix operator &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 功能也可作为管道符 &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="75d054c2f2cab23d848c32214fa7c03446c931b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; functor.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 仿函数。</target>
        </trans-unit>
        <trans-unit id="91affd44c758dc656c5a465b34202e2474e6eec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; type is an adjacency list representation of a finite, directed graph with vertices of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-graph#t:Graph&quot;&gt;Graph&lt;/a&gt;&lt;/code&gt; 类型是有限的邻接表表示，向图型的顶点 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da965f8602a83550c13d9322bdab8f201adad863" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; type represents a &lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;strongly-connected component&lt;/a&gt; of a graph.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-graph#t:SCC&quot;&gt;SCC&lt;/a&gt;&lt;/code&gt; 类型表示&lt;a href=&quot;https://en.wikipedia.org/wiki/Strongly_connected_component&quot;&gt;强连接分量&lt;/a&gt;的曲线图的。</target>
        </trans-unit>
        <trans-unit id="b13b673bb0340c3f60ad133cedd86aba2eebb7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f78d4fb8fef90bc420e0f272097151354016eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990e9e27ae850a84a5975a64be27bfdd1b9f5808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; argument specifies a &lt;em&gt;capability number&lt;/em&gt; (see &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;). Typically capabilities correspond to physical processors, but the exact behaviour is implementation-dependent. The value passed to &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; is interpreted modulo the total number of capabilities as returned by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 参数指定一个&lt;em&gt;能力号&lt;/em&gt;（见 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; ）。通常，功能对应于物理处理器，但确切的行为取决于实现。传递给值 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:forkOn&quot;&gt;forkOn&lt;/a&gt;&lt;/code&gt; 解释模的能力的总人数为返回 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:getNumCapabilities&quot;&gt;getNumCapabilities&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26c55fb3d34eb375b02ebba32fb7b2dd27c91fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9babf39e61d88f08afacef329c45b58b748886e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-strict&quot;&gt;mapMissing，&lt;/a&gt;则将在插入结果之前强制结果。如果您在此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则不会。</target>
        </trans-unit>
        <trans-unit id="918fcfe1bbabd9b098a3357af6b4c10845874e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您从此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则将在插入结果之前强制执行结果。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-lazy&quot;&gt;mapMissing，&lt;/a&gt;则不会。</target>
        </trans-unit>
        <trans-unit id="7e82dc1c0b8d264abe9b7b565b8cd539e1dbf5c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1641ed0171bfd491e6f0e6638191a7945a81dba8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;Functor&lt;/code&gt; ， &lt;code&gt;Traversable&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="ca6e272f4b13fc32e4e87c18c5a09335a1d8e5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from key of type &lt;code&gt;Int&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt; v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;Int&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="318814e0b6ddaa927c58b1267d22b77390f5ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; module, so if they are used the resulting map may contain suspended values (thunks).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 类型懒惰和严格的模块之间共享，这意味着相同 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="89f7bb2231b7f0bb854265a80968d382d2ee4a72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; type represents a set of elements of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-intset#t:IntSet&quot;&gt;IntSet&lt;/a&gt;&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235975fc327cbd37e2885a32990dd1d50e6ef2a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在一个类型到整数映射值的连续子区间。它主要用于数组索引（请参阅数组包）。</target>
        </trans-unit>
        <trans-unit id="213033fe7d1bfa8957877f18a3b95df927b829f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in type onto integers. It is used primarily for array indexing (see the array package). &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; uses row-major order.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在类型值的连续的子范围映射到整数。它主要用于数组索引（请参阅数组包）。 &lt;code&gt;&lt;a href=&quot;data-ix#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 使用行优先顺序。</target>
        </trans-unit>
        <trans-unit id="1c9726b499ba205a67e8661afa56b3f5e6610bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 功能列表差异（非关联）。根据 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-list#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; 的结果，依次将 &lt;code&gt;ys&lt;/code&gt; 的每个元素的第一次出现（如果有的话）从 &lt;code&gt;xs&lt;/code&gt; 中删除。从而</target>
        </trans-unit>
        <trans-unit id="d02a0fb924a1fb516ed51240226d0d6e5d964fd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和两个列表并移除所述第二列表中的每个元素的第一次出现返回第一个列表。</target>
        </trans-unit>
        <trans-unit id="0d81ce03e6c4879c98e79164e27980ccd4245607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 机能下降，其中给定的断言为所有元素的列表中最大的后缀。例如：</target>
        </trans-unit>
        <trans-unit id="8e6ebb6facf4e5e8507546d0730cd3d8aaa7cdbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回在给定列表的第一个元素的索引，其等于（由 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）到查询元件，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="35376b9066c242bc547e361977a97acd67654b38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 功能延伸 &lt;code&gt;&lt;a href=&quot;data-list#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; ，通过返回所有元素的索引等于查询元件，按升序排列。</target>
        </trans-unit>
        <trans-unit id="777c2200547e9739ba52a7633b954736b9823c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function is just &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; specialized to the list monad:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 功能只 &lt;code&gt;&lt;a href=&quot;control-monad#v:mfilter&quot;&gt;mfilter&lt;/a&gt;&lt;/code&gt; 专门到列表单子：</target>
        </trans-unit>
        <trans-unit id="a5d8b6f3eaba5030a68bf5d06e480657d33033a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a structure and returns the leftmost element of the structure matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和结构，并返回该结构的最左边的元素相匹配的谓词，或者 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="75b2422f251ce2039aaef3829d2dd5ca0ff38fd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和列表，并返回第一个元素的索引列表中的满足谓词，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="9ea9c7c9c9ab7b6e747e9ebc107dbbfddd67c972" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;data-list#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="be32822442735a04d54fa68d012d24ba5b89a668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为要素下降的数量。</target>
        </trans-unit>
        <trans-unit id="2812d742b2328d1abd314aebeef9aa75d01e9698" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 功能的重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 数值作为索引。</target>
        </trans-unit>
        <trans-unit id="737fc86009d880ef7008902e996d5561992367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为重复数作出。</target>
        </trans-unit>
        <trans-unit id="3402cafa3322e6ce9bc65e493a0acf1f2884672d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 函数是的重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为在该分割的位置。</target>
        </trans-unit>
        <trans-unit id="f78c90a57d5cce824e07db93d2197f95aa21a155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为元素采取的数量。</target>
        </trans-unit>
        <trans-unit id="ca4d378c787c5b9b2a06ae77c402a921da5aae20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数接受一个列表，并返回列表的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="b33d3992fa75b8c5a7295f072191cef6471b5d58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a2aa0c2fff9d0cd85f48ee4e5c547b1e24beae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有的初始段，第一最短。例如，</target>
        </trans-unit>
        <trans-unit id="e70f04ea60546783e780339c103b21d6a6b67467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 函数有两个列表清单交集。例如，</target>
        </trans-unit>
        <trans-unit id="a6dc46001b61fa48ad57e1c564b945db378bd949" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1446aaefcfea8557eabaae6ea889f9011ff1bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一个名单载，完全和完整，第二个内的任何地方。</target>
        </trans-unit>
        <trans-unit id="8577e2ac2954a5de0cd6238c09ea92a58c9fb7f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if all the elements of the first list occur, in order, in the second. The elements do not have to occur consecutively.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isSubsequenceOf&quot;&gt;isSubsequenceOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; ，如果所有发生的第一个list的元素，为了在第二。元素不必连续出现。</target>
        </trans-unit>
        <trans-unit id="4a40ec49296ced12343a8fd18ca5c49b63aabe04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的后缀。第二个列表必须是有限的。</target>
        </trans-unit>
        <trans-unit id="1b34469353a0b037b47cce6d230cb4cb71110874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将函数应用于结构的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="b6ebf56806d59584f196cd5d11b8904d0639b1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于结构的每个元素，从右向左传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="7eb6f6e78bb431c6ad213eb9d21c75fa95dc7ddf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;data-list#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="fc7232b1ebffbebb739ba096d41e32596b9eedb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词的列表，并返回一对和不满足谓词，分别元素列表的; 即</target>
        </trans-unit>
        <trans-unit id="2b6ed649212daaa5b7d86c6ccef6bf66b085c1db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有排列的列表。</target>
        </trans-unit>
        <trans-unit id="2f287658e3d55e31f32fe140091016332ce08537" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="a463a93b298d3088c6a486752b752d20e4b0de19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 函数实现稳定的排序算法。这是 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="095b73e07b36153b051dcf74ac3cefd56274581f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 功能的非重载版本 &lt;code&gt;&lt;a href=&quot;data-list#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b88e9d47462c1b9615bcd7d7acc05eba51c65b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有子序列的列表。</target>
        </trans-unit>
        <trans-unit id="eff98324d1a84c781b046e919d0b375a374d6a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="ac33ccd64dfa538162e29b5368275ac3dcab2e9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换其参数的行和列。例如，</target>
        </trans-unit>
        <trans-unit id="21074974ba0da203fdbe3139596e6c3eb82eacd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数是双重`&amp;rdquo;至 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：而 &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似减小了列表的摘要值， &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 构建从种子值的列表。该函数接受元素，如果完成生成列表，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，或者返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是列表的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。例如，</target>
        </trans-unit>
        <trans-unit id="6f5fe84f2f6e359d0b958ffdfd50c5ad6c942d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 函数返回两个列表名单工会。例如，</target>
        </trans-unit>
        <trans-unit id="26aa6f38df9eac11f0ca7ea5149a65e6f035439a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 功能是非重载版本的 &lt;code&gt;&lt;a href=&quot;data-list#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3512932a90bda2966b9c4bde2bc99fdaee65977a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="465b134f0e0674fc306964e8911a4c8f5a23b544" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 功能需要四倍和回报四个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eab7f028c5e43e9c371d7627b6af73045109e75d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 函数采用的五元组，并返回五个列表，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6934051d9d7b99ca14d42b993760a93edf9a7566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 函数采用六元组，并返回6个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="782bb3363a3945b001878329fde4ebb88dcb6fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 函数采用的七元组，并返回7个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;data-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17802af283250b2eaa32a2ecb8cb86776774ec7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 函数有四个名单，并返回四倍的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="6bce1a1341ac4dd8d73f1e68a1710aec2a623827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 功能需要五个名单和返回的五元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="451d4d26a4f677865f2a3a707b38064fca9f4083" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 功能需要六个月名单和返回的六元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="c305b363ee1ef77beb2a8edb13e3c0d40953e5c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 功能需要七名名单和返回的七元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;data-list#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="88779bb5c5d951c52ff0e703df09adaeddb2bdff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="60ff42280ef2fd04c5a52b0fb6c4ced9f80d259b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 函数采用结合了四个元件，以及四个列表并返回其逐点组合的列表，类似于一个函数 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="9fb3b6d637e7bdf78afcd7364064abe2b747412a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 功能需要，结合五行，以及五个列表，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="76824cb1a5c46cd7971e7c2fd78abbe2f0690804" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 功能需要，结合六大要素，以及6名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="c2eb2006a61b2e5916c9fa720bb30884f6a6a25d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 功能需要它结合了七个要素，以及七名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;data-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="657b1604cfab08f6d70ddcd61991924e84fa776b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; function is equivalent to &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:break&quot;&gt;break&lt;/a&gt; p&lt;/code&gt; 功能相当于 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:span&quot;&gt;span&lt;/a&gt; (not . p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee5bf1dc8f489bf35d33f57749203f70974c1fd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a stream and returns a list of streams such that flattening the resulting list is equal to the argument. Moreover, each stream in the resulting list contains only equal elements. For example, in list notation:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数有一个流，并返回这样的流的列表的是平坦化结果列表是等于参数。此外，结果列表中的每个流仅包含相等的元素。例如，在列表符号中：</target>
        </trans-unit>
        <trans-unit id="d4768abc565ec9f4747dd76eb1df6c5aed894777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the finite prefixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数接受一个流 &lt;code&gt;xs&lt;/code&gt; 并返回所有的有限前缀 &lt;code&gt;xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37ce52036d19badb8eb3e19e52707cf238bc5e53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if the first argument is a prefix of the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:isPrefixOf&quot;&gt;isPrefixOf&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果第一个参数是第二的前缀。</target>
        </trans-unit>
        <trans-unit id="bd9fc5f9beeabe2f81cfc9e7c5d9e742fa36f643" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; means 'essence'.) It is a special case of &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own inequality test.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 功能从列表中移除重复的元素。特别是，它仅保留每个元素的第一次出现。（名称 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; 表示&amp;ldquo;本质&amp;rdquo;。）这是 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的不平等测试。</target>
        </trans-unit>
        <trans-unit id="1fd2343fdb59771c84cb4f982c7246f3073f744d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="3ca6a46f6f161da72b75fa2b96c21284bff63000" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate &lt;code&gt;p&lt;/code&gt; and a stream &lt;code&gt;xs&lt;/code&gt;, and returns a pair of lists. The first list corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; holds; the second corresponds to the elements of &lt;code&gt;xs&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; does not hold.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词 &lt;code&gt;p&lt;/code&gt; 和流 &lt;code&gt;xs&lt;/code&gt; ，并返回一个对列表。第一个列表对应于 &lt;code&gt;xs&lt;/code&gt; 的元素，其中 &lt;code&gt;p&lt;/code&gt; 成立；第二个对应于 &lt;code&gt;xs&lt;/code&gt; 的元素，其中 &lt;code&gt;p&lt;/code&gt; 不成立。</target>
        </trans-unit>
        <trans-unit id="97f203f3e97c286860c77a16076e2c5ba5e804b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; function takes a stream &lt;code&gt;xs&lt;/code&gt; and returns all the suffixes of &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:tails&quot;&gt;tails&lt;/a&gt;&lt;/code&gt; 函数接受一个流 &lt;code&gt;xs&lt;/code&gt; 并返回所有的后缀 &lt;code&gt;xs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4b73a8b2bef137b1be451c67193ea1b9dd5278a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is analogous to &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;'s &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; operation.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数类似于&lt;a href=&quot;data-list&quot;&gt;Data.List模块&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="2413c236691707253e811091fb05fcbb1bf0b562" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; function is the inverse of the &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 功能是逆 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="ce09038022ed3cd501096c0d8a1d4d43ab363fc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; function takes two streams and returns a stream of corresponding pairs.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 函数有两个流，并返回对应的对流。</target>
        </trans-unit>
        <trans-unit id="f10666c8af44a76f18b1cbb206ccc5dbbcf92fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; function generalizes &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. Rather than tupling the elements, the elements are combined using the function passed as the first argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 功能概括 &lt;code&gt;&lt;a href=&quot;data-list-nonempty#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。而不是组合元素，而是使用作为第一个参数传递的函数来组合元素。</target>
        </trans-unit>
        <trans-unit id="16a4e90fc05f7eb7703f8d38de0941aad54680ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;. A &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; is strict in its keys but lazy in its values.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;k&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 是在其键严格的，但在它的值懒惰。</target>
        </trans-unit>
        <trans-unit id="4715b3b3e03f7ebfbfad3ed60bdf0126093bd7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-strict&quot;&gt;Data.Map.Merge.Strict&lt;/a&gt; then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-strict&quot;&gt;mapMissing，&lt;/a&gt;则将在插入结果之前强制结果。如果您在此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则不会。</target>
        </trans-unit>
        <trans-unit id="2b155238023fcafca6284b024ed0af65f6650208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; functions are shared by the lazy and strict modules. Only the choice of merge tactics determines strictness. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from this module then the results will be forced before they are inserted. If you use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; from &lt;a href=&quot;data-map-merge-lazy&quot;&gt;Data.Map.Merge.Lazy&lt;/a&gt; then they will not.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 功能由懒惰和严格的模块共享。只有合并策略的选择才能确定严格性。如果您从此模块中使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; ，则将在插入结果之前强制执行结果。如果您使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mapMissing&quot;&gt;mapMissing&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;data-map-merge-lazy&quot;&gt;mapMissing，&lt;/a&gt;则不会。</target>
        </trans-unit>
        <trans-unit id="662c04a7a17ee001eac580254bab8523defdb93a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; type represents a finite map (sometimes called a dictionary) from keys of type &lt;code&gt;k&lt;/code&gt; to values of type &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt; k v&lt;/code&gt; 类型表示从型的键的有限地图（有时称为字典） &lt;code&gt;k&lt;/code&gt; 到类型的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12662a5070f04b0d43497ea05090a5128c804911" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; type is shared between the lazy and strict modules, meaning that the same &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; value can be passed to functions in both modules. This means that the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances are the same as for the &lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt; module, so if they are used the resulting maps may contain suspended values (thunks).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 种类的懒惰和严格的模块之间共享，这意味着相同的 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 值可以被传递给函数在这两个模块。这意味着 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#v:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例与&lt;a href=&quot;data-map-lazy&quot;&gt;Data.Map.Lazy&lt;/a&gt;模块的实例相同，因此，如果使用它们，则生成的映射可能包含挂起的值（thunk）。</target>
        </trans-unit>
        <trans-unit id="7f52f3aa69ba900643917df0d514ebfe7065396f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="f185e83cdbbc510aa029904011adfe83bd8b1220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="e8aa4a4fc49f7638e33b52125beaf5389284d595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8e3cc1728b8d32e7bd6e33d7191898329f389751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; function extracts the element out of a &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and throws an error if its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromJust&quot;&gt;fromJust&lt;/a&gt;&lt;/code&gt; 函数提取的元素出来的 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; ，如果它的参数是抛出一个错误 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de4cf2aa7df453c08de73e06681e00b3a9d47c30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值，并 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="7a5a7a323996766db88ca0c88884029bb8a6704d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is of the form &lt;code&gt;Just _&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:isJust&quot;&gt;isJust&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当它的参数是形式 &lt;code&gt;Just _&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52483bf501d37712c976868bb9284af355744fac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff its argument is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果参数为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;data-maybe#v:isNothing&quot;&gt;isNothing&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eee25b35452f5d1cfc414313539edda0a7120764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; on an empty list or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the first element of the list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:listToMaybe&quot;&gt;listToMaybe&lt;/a&gt;&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 空列表或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ，其中 &lt;code&gt;a&lt;/code&gt; 是列表的第一个元素。</target>
        </trans-unit>
        <trans-unit id="d9226f117113df71e3656c9e6013ce6d6bf13f04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; function is a version of &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; which can throw out elements. In particular, the functional argument returns something of type &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt;. If this is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no element is added on to the result list. If it is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt;, then &lt;code&gt;b&lt;/code&gt; is included in the result list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 功能是一个版本 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ，可以扔出去的元素。特别是，函数参数返回类型 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; b&lt;/code&gt; 东西。如果为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则不会将任何元素添加到结果列表。如果它是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; b&lt;/code&gt; ，则 &lt;code&gt;b&lt;/code&gt; 包含在结果列表中。</target>
        </trans-unit>
        <trans-unit id="85d0ce65a11dff7a785fa5be5465e4febfc6e9a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 的功能需要一个默认值，函数，和 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值为 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该函数返回默认值。否则，它将函数应用于 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 内的值并返回结果。</target>
        </trans-unit>
        <trans-unit id="5c611fd7648ec2451334092c9df4afb5e19ad5d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;data-maybe#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数返回一个空列表，而给出 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，则返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="795a9f9783333374a76593a231e073666138ebda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; monoid is defined by the numerical addition operator and `0` as neutral element:</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Sum&quot;&gt;Sum&lt;/a&gt;&lt;/code&gt; 半群由数值加法运算符和定义`0`为中性元素：</target>
        </trans-unit>
        <trans-unit id="9acde1593d8ad750d5ecbfa06d97960b56f05f43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。如果 &lt;code&gt;a&lt;/code&gt; 具有与之关联的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例，则比较由此包装的两个值将得到与它们正常排序顺序相反的结果。在按广义列表 &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 排序时，这特别有用，例如：then down by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="2d480aba9ca8f558b9bab4a7470c617258413273" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类用于全序数据类型。</target>
        </trans-unit>
        <trans-unit id="9743e6ce1ccca02d84b310e0c03e3b64b006ece2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is defined to always pick the smaller number: &amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Min&quot;&gt;Min&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 实例定义为始终选择较小的数字：&amp;gt;&amp;gt;&amp;gt; Min 1 &amp;lt;&amp;gt; Min 2 &amp;lt;&amp;gt; Min 3 &amp;lt;&amp;gt; Min 4 :: Min Int Min {getMin = 1}</target>
        </trans-unit>
        <trans-unit id="d415a40b49223b304b71b398a708eb25f07e68ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; type represents a finite sequence of values of type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt; a&lt;/code&gt; 类型表示类型的值的有限序列 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13ce1c3f2600f3e2f50834c056ec8fa70e4eab37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; type represents a set of elements of type &lt;code&gt;e&lt;/code&gt;. Most operations require that &lt;code&gt;e&lt;/code&gt; be an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class. A &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; is strict in its elements.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt; e&lt;/code&gt; 类型表示一组类型的元素的 &lt;code&gt;e&lt;/code&gt; 。大多数操作都要求 &lt;code&gt;e&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类的实例。一 &lt;code&gt;&lt;a href=&quot;data-set#t:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 是在其元素严格。</target>
        </trans-unit>
        <trans-unit id="8881e3fb681798d7bf981e8e9d449509800437b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type is implemented using arrays that are not guaranteed to have a fixed address in the Haskell heap. All communication with native code must thus occur by copying data back and forth.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型是使用不能保证在Haskell的堆的固定地址阵列实现。因此，所有与本机代码的通信都必须通过来回复制数据来进行。</target>
        </trans-unit>
        <trans-unit id="9d9c2733ed15ccf0d235e8a6b100f93fe8426bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; type's internal representation is UTF-16, using the platform's native endianness. This makes copied data suitable for use with native libraries that use a similar representation, such as ICU. To interoperate with native libraries that use different internal representations, such as UTF-8 or UTF-32, consider using the functions in the &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型的内部表现为UTF-16，使用平台的本机字节序。这使复制的数据适合与使用类似表示形式的本机库一起使用，例如ICU。要与使用不同内部表示形式的本机库（例如UTF-8或UTF-32）进行互操作，请考虑使用&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-text#v:Encoding&quot;&gt;Encoding&lt;/a&gt;&lt;/code&gt; 模块中的函数。</target>
        </trans-unit>
        <trans-unit id="161f7f591d2f56a095b5a6738fe11dc948f83c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-text#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和一个严格 &lt;code&gt;&lt;a href=&quot;data-text#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="c5823a0c22eaaaf0e0d80ffbc2bbde448d239204" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-array#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; 由于构造暴露 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d764c078d54b6747b82b1fb65bc90cbfdc33a9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; constructor is exposed since &lt;code&gt;text-1.1.1.3&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-array#t:MArray&quot;&gt;MArray&lt;/a&gt;&lt;/code&gt; 因为构造暴露 &lt;code&gt;text-1.1.1.3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e4b96f6778d5f3fbaa9eb0f8c186a8f261148c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; functions accept a &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; that represents a possibly incomplete input (e.g. a packet from a network stream) that may not end on a UTF-8 boundary.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8&quot;&gt;streamDecodeUtf8&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; 函数接受一个 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示一个可能不完整输入（例如，从网络流分组），其可以不是UTF-8边界结束。</target>
        </trans-unit>
        <trans-unit id="d8de0eaf04140ba7158dddc8d0be85ce0ccccc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和流并返回第一个元素的索引满足谓词的信息流中。</target>
        </trans-unit>
        <trans-unit id="bf384e38dd6fd9c82df77df8975246cdedc34701" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; function takes a predicate and a stream and returns the index of the first element in the stream satisfying the predicate.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:findIndexI&quot;&gt;findIndexI&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和流并返回第一个元素的索引满足谓词的信息流中。</target>
        </trans-unit>
        <trans-unit id="ee94ea37dfd7850ffc9a486e3dd92c091c5cbec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; code points.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 码点。</target>
        </trans-unit>
        <trans-unit id="66da5760dab680492ae3a48dc3a35550be6dc4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; of the given code point.</source>
          <target state="translated">给定代码点的 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-size#t:Size&quot;&gt;Size&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a75e1f66c9b008e7ba6ff420a20501b8af837a38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-text-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 功能需要类型的函数 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 作为其参数。来自标准输入设备的全部输入作为其参数传递给此函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="b417d4f678288b71d35accb0f99175761f3e1e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The entire file is read strictly, as with &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。与 &lt;code&gt;&lt;a href=&quot;data-text-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，严格读取整个文件。</target>
        </trans-unit>
        <trans-unit id="68615baf25b8a5dabb727f9a05e4f69c95e23d72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; and returns a list of &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数采用一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; ，并返回的列表 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; S，从而使结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="448dca813f1fb16bef7c7de2c7c5fae5b0a093ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bea18231a8f3d26a5fe0119fe32dfbafea55d681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and a strict &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;. Performs replacement on invalid scalar values.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和一个严格 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新的 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。对无效的标量值执行替换。</target>
        </trans-unit>
        <trans-unit id="1a76ea813e8c21de4f80acb76647bc2ec24349f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; as its argument. The entire input from the standard input device is passed (lazily) to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-text-lazy-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 功能需要类型的函数 &lt;code&gt;Text -&amp;gt; Text&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入（作为参数）（延迟地）传递给此函数，结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="0f4eb06ba150dfea2048571ec4f24a657175124e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它将函数应用于结构的每个元素，从左到右传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="7d943aed90068948d72a0d5858ba1b7944e9decb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a structure, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new structure.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-traversable#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为等的组合 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将一个函数应用于结构的每个元素，从右向左传递一个累加参数，并返回该累加器的最终值以及新结构。</target>
        </trans-unit>
        <trans-unit id="6a5f7c77832ccee5dc8f444bf10cb820686c5a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; type represents a forest of &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-tree#t:Forest&quot;&gt;Forest&lt;/a&gt; a&lt;/code&gt; 类型代表的森林 &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 秒。</target>
        </trans-unit>
        <trans-unit id="4dde0b10b0f433f8901cc6d31ae5f25b888075e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; type represents a lazy, possibly infinite, multi-way tree (also known as a &lt;em&gt;rose tree&lt;/em&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;data-tree#t:Tree&quot;&gt;Tree&lt;/a&gt; a&lt;/code&gt; 类型代表一个懒惰的，可能是无限的，多路树（也被称为&lt;em&gt;玫瑰树&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="8007180e7dc5a974039c84bcb837081428c5c9da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; class reifies types to some extent by associating type representations to types. These type representations can be compared, and one can in turn define a type-safe cast operation. To this end, an unsafe cast is guarded by a test for type (representation) equivalence. The module &lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt; uses Typeable for an implementation of dynamics. The module &lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt; uses Typeable and type-safe cast (but not dynamics) to support the &quot;Scrap your boilerplate&quot; style of generic programming.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 类按类型交涉类型相关联的类型具体化在一定程度上。可以对这些类型表示进行比较，然后可以依次定义一种类型安全的强制转换操作。为此，通过类型（表示）等效性测试来保护不安全的转换。&lt;a href=&quot;data-dynamic&quot;&gt;Data.Dynamic&lt;/a&gt;模块将Typeable用于动态实现。&lt;a href=&quot;data-data&quot;&gt;Data.Data&lt;/a&gt;模块使用Typeable和类型安全的强制转换（但不使用动态转换）来支持通用编程的&amp;ldquo;废话&amp;rdquo;样式。</target>
        </trans-unit>
        <trans-unit id="d043229d0aba230c46b619f1751b3e8e83785014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function outputs the trace message given as its first argument, before returning the second argument as its result.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 函数输出给定的作为第一个参数，返回第二自变量作为其结果之前跟踪消息。</target>
        </trans-unit>
        <trans-unit id="140721e416adc2345c2c2facce319e06db5e38ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; function should &lt;em&gt;only&lt;/em&gt; be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 功能应&lt;em&gt;仅&lt;/em&gt;用于调试，或用于监测执行。该函数不是参照透明的：其类型表明它是纯函数，但具有输出跟踪消息的副作用。</target>
        </trans-unit>
        <trans-unit id="605bec91baff60047b066d4e1ac30c1faa493023" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; functions print messages to an output stream. They are intended for &quot;printf debugging&quot;, that is: tracing the flow of execution and printing interesting values.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceShow&quot;&gt;traceShow&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 功能消息输出到输出流。它们用于&amp;ldquo; printf调试&amp;rdquo;，即：跟踪执行流并打印有趣的值。</target>
        </trans-unit>
        <trans-unit id="a88df11e31fce4c7204e009946e93a681d719b46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; function behaves like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; with the difference that the message is emitted to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEvent&quot;&gt;traceEvent&lt;/a&gt;&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; 与该消息被发射到事件日志，事件日志，如果分析是可用的，并在运行时启用的差别。</target>
        </trans-unit>
        <trans-unit id="49d4ea0d4504acbc4d1aca32b1293ddbe4063444" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; function emits a message to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceEventIO&quot;&gt;traceEventIO&lt;/a&gt;&lt;/code&gt; 分析可用并在运行时启用，则traceEventIO函数会向事件日志发出消息。</target>
        </trans-unit>
        <trans-unit id="b3a4eae130c3225cefb9efb90d8be9b83b521fab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; function outputs the trace message from the IO monad. This sequences the output with respect to other IO actions.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceIO&quot;&gt;traceIO&lt;/a&gt;&lt;/code&gt; 函数输出来自IO单子跟踪消息。这将根据其他IO动作对输出进行排序。</target>
        </trans-unit>
        <trans-unit id="d97ccf67a57dfd415eb74011cb7d1b6a77ff69bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime. The &lt;code&gt;String&lt;/code&gt; is the name of the marker. The name is just used in the profiling tools to help you keep clear which marker is which.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarker&quot;&gt;traceMarker&lt;/a&gt;&lt;/code&gt; 功能发出一个标记，事件日志，事件日志，如果分析是可用的，并在运行时启用。该 &lt;code&gt;String&lt;/code&gt; 是标记的名称。该名称仅在分析工具中使用，以帮助您弄清楚哪个标记是哪个标记。</target>
        </trans-unit>
        <trans-unit id="fa771e47c5e0835b60259fdc80c34fd55cfa3c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; function emits a marker to the eventlog, if eventlog profiling is available and enabled at runtime.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 分析可用并在运行时启用，则traceMarkerIO函数将向事件日志发出标记。</target>
        </trans-unit>
        <trans-unit id="65a90e57ddce6b3095e1eb053172e0add59b8b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="47f829e4b12e19d9b1b9c867b798c3d41bfa7cc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。该模块是外部功能接口（FFI）的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;外部&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="4fea14f33688c221cc4b82a2e64457f2c1daf4c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="46ba37e75544b376d91afd7d94cc178e3d4edd60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; type and operations. This module is part of the Foreign Function Interface (FFI) and will usually be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。该模块是外部功能接口（FFI）的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;外部&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="05673b670d8de49659d7ca54ef48d3649d1c6cc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 功能投射的指针从一种类型到另一个。</target>
        </trans-unit>
        <trans-unit id="f4a69e977af812c4c1901ff0ace0b2bb4a9d9dd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package).</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-arr#t:Ix&quot;&gt;Ix&lt;/a&gt;&lt;/code&gt; 类用于在一个类型到整数映射值的连续子区间。它主要用于数组索引（请参阅数组包）。</target>
        </trans-unit>
        <trans-unit id="e348453b816674bfaf92baa8a27076b87c3aa9bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; function deals with repeated indices in the association list using an &lt;em&gt;accumulating function&lt;/em&gt; which combines the values of associations with the same index.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-arr#v:accumArray&quot;&gt;accumArray&lt;/a&gt;&lt;/code&gt; 与使用在所述关联列表中重复指数函数优惠&lt;em&gt;累积功能&lt;/em&gt;相结合的关联的值具有相同的索引。</target>
        </trans-unit>
        <trans-unit id="7873c676664db92e7ab0f598d2d48e71762b5260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="ee50bbd3c67bae7f49e378336e2e433f6106ccf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-base#v:join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 的功能是传统的单子连接操作。它用于删除单子结构的一个级别，将其绑定参数投射到外部级别。</target>
        </trans-unit>
        <trans-unit id="27aabb232ca4b09ca8d220a432dd7f16df59a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 操作允许（力，在一个合作多任务执行）一个上下文切换到任何其它目前可运行的线程（如果有的话），并实施并发抽象时是偶尔是有用的。</target>
        </trans-unit>
        <trans-unit id="4a132846a2c0d7c2c3007c1d18b85a3d84e2a398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; action allows (forces, in a co-operative multitasking implementation) a context-switch to any other currently runnable threads (if any), and is occasionally useful when implementing concurrency abstractions.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:yield&quot;&gt;yield&lt;/a&gt;&lt;/code&gt; 操作允许（力，在一个合作多任务执行）一个上下文切换到任何其它目前可运行的线程（如果有的话），并实施并发抽象时是偶尔是有用的。</target>
        </trans-unit>
        <trans-unit id="9dd95524ffc61573839150d5ca8d3bbeafd0b7a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类用于命名的类型的上限和下限。 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 的超类，因为未完全排序的类型也可能具有上限和下限。</target>
        </trans-unit>
        <trans-unit id="3e4a35f48d43f24d53c5bb16b69fba56be493a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类可衍生自任何枚举类型; &lt;code&gt;&lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;data&lt;/code&gt; 声明中列出的第一个构造函数，而 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 是最后一个。 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 也可以导出单构造的数据类型，其构成类型在 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="674d2d4d75029f825bd270a8d08697ebd9b70ba6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-enum#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="c5cd6d00d90b1e061059918ba18205b11c14c002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; type allows you to reverse sort order conveniently. A value of type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt;). If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt;&lt;/code&gt; 类型，您可以方便地反向排序。类型为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; 的值包含类型 &lt;code&gt;a&lt;/code&gt; a的值（表示为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; a&lt;/code&gt; ）。如果 &lt;code&gt;a&lt;/code&gt; 具有与之关联的 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 实例，则比较由此包装的两个值将得到与它们正常排序顺序相反的结果。在按广义列表 &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt; 排序时，这特别有用，例如：then down by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x</target>
        </trans-unit>
        <trans-unit id="bf4c3fac24e8ca008ba612ac6b40c0fcd012f0f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; class and its methods are intended to be used in conjunction with the OverloadedLists extension.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:IsList&quot;&gt;IsList&lt;/a&gt;&lt;/code&gt; 类及其方法意在与OverloadedLists扩展一起使用。</target>
        </trans-unit>
        <trans-unit id="d7ba5830092cef4d84647e79c69131dbc7adc059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; type function returns the type of items of the structure &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-exts#t:Item&quot;&gt;Item&lt;/a&gt;&lt;/code&gt; 类型函数返回结构 &lt;code&gt;l&lt;/code&gt; 的项目类型。</target>
        </trans-unit>
        <trans-unit id="0f84b47ee1d124d1ca79a226e83d25027b22134b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; function constructs the structure &lt;code&gt;l&lt;/code&gt; from the given list of &lt;code&gt;Item l&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 函数构造结构 &lt;code&gt;l&lt;/code&gt; 从给定的清单 &lt;code&gt;Item l&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ceee73322b5e0bdd5f3091f55d6384a70d17944b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; function takes the input list's length as a hint. Its behaviour should be equivalent to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. The hint can be used to construct the structure &lt;code&gt;l&lt;/code&gt; more efficiently compared to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt;. If the given hint does not equal to the input list's length the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; is not specified.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 函数获取输入列表长度作为提示。它的行为应等效于 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 。与 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromList&quot;&gt;fromList&lt;/a&gt;&lt;/code&gt; 相比，该提示可用于更有效地构造结构 &lt;code&gt;l&lt;/code&gt; 。如果给定的提示不等于输入列表的长度，则不指定 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:fromListN&quot;&gt;fromListN&lt;/a&gt;&lt;/code&gt; 的行为。</target>
        </trans-unit>
        <trans-unit id="c5c04c12c048d0307d00092d987715f0d989db28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:groupWith&quot;&gt;groupWith&lt;/a&gt;&lt;/code&gt; 函数使用用户提供的功能，其上这些预计元件由平等突出的元件每列表元素的以第一排序输入列表，然后以形成基团</target>
        </trans-unit>
        <trans-unit id="695facc226b98a2fdc94f961971c4ce121f69e9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; function restrains strictness analysis a little. The call &lt;code&gt;lazy e&lt;/code&gt; means the same as &lt;code&gt;e&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; has a magical property so far as strictness analysis is concerned: it is lazy in its first argument, even though its semantics is strict. After strictness analysis has run, calls to &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; are inlined to be the identity function.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 功能性约束的严格分析一点点。调用 &lt;code&gt;lazy e&lt;/code&gt; 的含义与 &lt;code&gt;e&lt;/code&gt; 相同，但是就严格性分析而言， &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 具有神奇的性质：即使其语义严格，它的第一个参数也是惰性的。运行严格性分析后，内联到 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; 的调用将成为身份功能。</target>
        </trans-unit>
        <trans-unit id="c62e040021cb66d2ce6289579ad247f811fcaf97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; function can be used to give a hint to the compiler that its argument will be called at most once, which may (or may not) enable certain optimizations. It can be useful to improve the performance of code in continuation passing style.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; 的功能可以被用来给出提示给编译器，它的参数将至多一次被调用，其可以（或可以不）使某些优化。以连续传递方式提高代码性能可能很有用。</target>
        </trans-unit>
        <trans-unit id="738f70f90664f23041407e78e7481ca578a61fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; function sorts a list of elements using the user supplied function to project something out of each element</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:sortWith&quot;&gt;sortWith&lt;/a&gt;&lt;/code&gt; 函数对使用用户提供的函数，项目东西元素的列表每个元素的</target>
        </trans-unit>
        <trans-unit id="f8c0871b5b6f8b978adbdfa4a64b81796ab60e0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; function extracts a list of &lt;code&gt;Item l&lt;/code&gt; from the structure &lt;code&gt;l&lt;/code&gt;. It should satisfy fromList . toList = id.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:toList&quot;&gt;toList&lt;/a&gt;&lt;/code&gt; 函数提取列表 &lt;code&gt;Item l&lt;/code&gt; 从结构 &lt;code&gt;l&lt;/code&gt; 。它应该满足fromList。toList = ID。</target>
        </trans-unit>
        <trans-unit id="b18ac779aba3ac796c0284e4d2cc3bb7c69a9f44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is parameterised in the same way as &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt;. The type argument of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; should normally be an instance of class &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 被以同样的方式作为参数化 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的类型参数通常应为 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="c5c813e0c538449c8b967f68e862c925ce84f9ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; invocations indicate that the enclosed part is the representation of the first and second constructor of datatype &lt;code&gt;Tree&lt;/code&gt;, respectively. Here, the meta-information regarding constructor names, fixity and whether it has named fields or not is encoded at the type level. The &lt;code&gt;'MetaCons&lt;/code&gt; type is also an instance of the type class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt;. This type class can be used to obtain information about the constructor at the value level.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Leaf&quot; 'PrefixI 'False)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:C1&quot;&gt;C1&lt;/a&gt; ('MetaCons &quot;Node&quot; 'PrefixI 'False)&lt;/code&gt; 调用指示该封闭部分是数据类型的第一和第二构造的表示 &lt;code&gt;Tree&lt;/code&gt; ，分别。在这里，有关构造函数名称，固定性以及是否具有命名字段的元信息在类型级别进行编码。该 &lt;code&gt;'MetaCons&lt;/code&gt; 类型也是类型的类的实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Constructor&quot;&gt;Constructor&lt;/a&gt;&lt;/code&gt; 。此类型类可用于在值级别获取有关构造函数的信息。</target>
        </trans-unit>
        <trans-unit id="4b3758b0106cdc9eb50e8251878d12e347f33b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; tag indicates that the enclosed part is the representation of the datatype &lt;code&gt;Tree&lt;/code&gt;. Again, the meta-information is encoded at the type level. The &lt;code&gt;'MetaData&lt;/code&gt; type is an instance of class &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt;, which can be used to obtain the name of a datatype, the module it has been defined in, the package it is located under, and whether it has been defined using &lt;code&gt;data&lt;/code&gt; or &lt;code&gt;newtype&lt;/code&gt; at the value level.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:D1&quot;&gt;D1&lt;/a&gt; ('MetaData &quot;Tree&quot; &quot;Main&quot; &quot;package-name&quot; 'False)&lt;/code&gt; 标签指示包围的部分是数据类型的表示 &lt;code&gt;Tree&lt;/code&gt; 。同样，元信息是在类型级别上编码的。所述 &lt;code&gt;'MetaData&lt;/code&gt; 类型是类的实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Datatype&quot;&gt;Datatype&lt;/a&gt;&lt;/code&gt; ，这可以被用来获得一个数据类型的名字，它在被限定的模块，它位于下包，以及它是否已使用被定义 &lt;code&gt;data&lt;/code&gt; 或 &lt;code&gt;newtype&lt;/code&gt; 在价值水平。</target>
        </trans-unit>
        <trans-unit id="490133c0313c9ba8b7db7fbe7e0fe5b2bf18b53d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; class can be generalized to range over types of kind &lt;code&gt;k -&amp;gt; *&lt;/code&gt;, for any kind &lt;code&gt;k&lt;/code&gt;. To do so, derive a &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; instance with the &lt;code&gt;PolyKinds&lt;/code&gt; extension enabled. For example, the declaration</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 类可以推广到范围在类型种 &lt;code&gt;k -&amp;gt; *&lt;/code&gt; ，对于任何一种 &lt;code&gt;k&lt;/code&gt; 。为此，派生启用 &lt;code&gt;PolyKinds&lt;/code&gt; 扩展的 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Generic1&quot;&gt;Generic1&lt;/a&gt;&lt;/code&gt; 实例。例如，声明</target>
        </trans-unit>
        <trans-unit id="b51e7af78f64d86aed93f2c4d635092dabfbb762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness
      'DecidedLazy)&lt;/code&gt; tag indicates several things. The &lt;code&gt;'Nothing&lt;/code&gt; indicates that there is no record field selector associated with this field of the constructor (if there were, it would have been marked &lt;code&gt;'Just
      &quot;recordName&quot;&lt;/code&gt; instead). The other types contain meta-information on the field's strictness:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:S1&quot;&gt;S1&lt;/a&gt; ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)&lt;/code&gt; 标签指示几件事情。在 &lt;code&gt;'Nothing&lt;/code&gt; 表明存在与构造的这个领域相关的任何记录字段选择器（如果有的话，它会被标记为 &lt;code&gt;'Just &quot;recordName&quot;&lt;/code&gt; 代替）。其他类型包含有关字段严格性的元信息：</target>
        </trans-unit>
        <trans-unit id="d0cdba7fd39b9182aef4d3fd8dd460a16d152145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ccb84e64bf7ed15245460804350d5f1cb2e76cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; is used to construct &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt;s, and specifies how they handle illegal sequences.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#t:CodingFailureMode&quot;&gt;CodingFailureMode&lt;/a&gt;&lt;/code&gt; 用于构建 &lt;code&gt;&lt;a href=&quot;system-io#v:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; S，并且指定他们如何处理非法的序列。</target>
        </trans-unit>
        <trans-unit id="727269e258ca0cc1f5b84b187e061106f48b55ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限清单的产品。</target>
        </trans-unit>
        <trans-unit id="29f4142ef18f41223155d901b10e8d9efcecd6fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-list#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限列表的总和。</target>
        </trans-unit>
        <trans-unit id="791089d56d61f4d3b56178eb7352f6df80bab567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-list#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb018b60fccf9ba007b71e9eb3d8a718941c0f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-list#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="24f96e687e4620b9109ecaf114edba80a1baa66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="266e593abd43191340f9b33fd8e15a10e0dc922a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;ghc-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="b66270e05d2350973bd17982c61ae01a11e0a3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; class and the &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 类和 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d90a8339ada736c69e4569a04518d30718bf0396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; function is list difference (non-associative). In the result of &lt;code&gt;xs&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt;&lt;code&gt;ys&lt;/code&gt;, the first occurrence of each element of &lt;code&gt;ys&lt;/code&gt; in turn (if any) has been removed from &lt;code&gt;xs&lt;/code&gt;. Thus</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; 功能列表差异（非关联）。根据 &lt;code&gt;xs&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-92--92-&quot;&gt;\\&lt;/a&gt;&lt;/code&gt; &lt;code&gt;ys&lt;/code&gt; 的结果，依次将 &lt;code&gt;ys&lt;/code&gt; 的每个元素的第一次出现（如果有的话）从 &lt;code&gt;xs&lt;/code&gt; 中删除。从而</target>
        </trans-unit>
        <trans-unit id="5f790bce52b575010739edf6cb02aa96c2885cb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:deleteFirstsBy&quot;&gt;deleteFirstsBy&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和两个列表并移除所述第二列表中的每个元素的第一次出现返回第一个列表。</target>
        </trans-unit>
        <trans-unit id="a978c3a6eaa51a8f531e3682bd2d367abf6607ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; function drops the largest suffix of a list in which the given predicate holds for all elements. For example:</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:dropWhileEnd&quot;&gt;dropWhileEnd&lt;/a&gt;&lt;/code&gt; 机能下降，其中给定的断言为所有元素的列表中最大的后缀。例如：</target>
        </trans-unit>
        <trans-unit id="109bdc9435b830725cf189c556de56387a5634f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; function returns the index of the first element in the given list which is equal (by &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) to the query element, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; 函数返回在给定列表的第一个元素的索引，其等于（由 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）到查询元件，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="fadb3e5498f5526f3f541154cc26a34805337369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements equal to the query element, in ascending order.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndices&quot;&gt;elemIndices&lt;/a&gt;&lt;/code&gt; 功能延伸 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:elemIndex&quot;&gt;elemIndex&lt;/a&gt;&lt;/code&gt; ，通过返回所有元素的索引等于查询元件，按升序排列。</target>
        </trans-unit>
        <trans-unit id="6568db6f34d6f7a7bf8a446041bb3489740f3067" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the first element in the list matching the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:find&quot;&gt;find&lt;/a&gt;&lt;/code&gt; 功能需要一个谓语和一个列表，返回列表中的第一个元素相匹配的谓语，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，如果没有这样的元素。</target>
        </trans-unit>
        <trans-unit id="4275cc9b36aa0e4769199e754686defa1594e4b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; function takes a predicate and a list and returns the index of the first element in the list satisfying the predicate, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if there is no such element.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; 函数采用一个谓语和列表，并返回第一个元素的索引列表中的满足谓词，或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 如果不存在这样的元件。</target>
        </trans-unit>
        <trans-unit id="2f76c76695266af5e321e89b84f46bb9a822c35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; function extends &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt;, by returning the indices of all elements satisfying the predicate, in ascending order.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndices&quot;&gt;findIndices&lt;/a&gt;&lt;/code&gt; 功能扩展 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:findIndex&quot;&gt;findIndex&lt;/a&gt;&lt;/code&gt; ，通过返回满足谓词的所有元素的索引，按升序排列。</target>
        </trans-unit>
        <trans-unit id="305fac941a1cc5c29fd70cdde5362cbcac036635" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to drop.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericDrop&quot;&gt;genericDrop&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:drop&quot;&gt;drop&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为要素下降的数量。</target>
        </trans-unit>
        <trans-unit id="acf544a13e18ba4358a78c184967bf2f876a1aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the index.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericIndex&quot;&gt;genericIndex&lt;/a&gt;&lt;/code&gt; 功能的重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:-33--33-&quot;&gt;!!&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 数值作为索引。</target>
        </trans-unit>
        <trans-unit id="813efa98177dcd58489481e0cb89e0133d9e87e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of repetitions to make.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericReplicate&quot;&gt;genericReplicate&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:replicate&quot;&gt;replicate&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为重复数作出。</target>
        </trans-unit>
        <trans-unit id="d7d4ee3930a7434ca7c403b4565de9be9be21b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the position at which to split.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericSplitAt&quot;&gt;genericSplitAt&lt;/a&gt;&lt;/code&gt; 函数是的重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:splitAt&quot;&gt;splitAt&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为在该分割的位置。</target>
        </trans-unit>
        <trans-unit id="e4afafa2336fcae4601a2eaca8e96fec05a60b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; function is an overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt;, which accepts any &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; value as the number of elements to take.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:genericTake&quot;&gt;genericTake&lt;/a&gt;&lt;/code&gt; 函数是一个重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:take&quot;&gt;take&lt;/a&gt;&lt;/code&gt; ，它接受任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 值作为元素采取的数量。</target>
        </trans-unit>
        <trans-unit id="f4f6a5e91131c42f6af8de505ab848b2b5f93891" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument. Moreover, each sublist in the result contains only equal elements. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 函数接受一个列表，并返回列表的列表，使得结果的级联是等于参数。此外，结果中的每个子列表仅包含相等的元素。例如，</target>
        </trans-unit>
        <trans-unit id="d100c0bef6b2c8b32f44a08a7e7eacb8db8f8cbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:groupBy&quot;&gt;groupBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34b65659a51ccdb8baad87c00cd32d74ef9d403b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; function returns all initial segments of the argument, shortest first. For example,</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:inits&quot;&gt;inits&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有的初始段，第一最短。例如，</target>
        </trans-unit>
        <trans-unit id="144853d03169fd7769ada44b12eba567928f0591" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; function takes the list intersection of two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 函数有两个列表清单交集。例如，</target>
        </trans-unit>
        <trans-unit id="605c4315b576beab0a53cad6a48c3adba1b2f451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersectBy&quot;&gt;intersectBy&lt;/a&gt;&lt;/code&gt; 功能是与非过负荷版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:intersect&quot;&gt;intersect&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abf262d8a1cc937359d5c3c8f6075d27f69eb8ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is contained, wholly and intact, anywhere within the second.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isInfixOf&quot;&gt;isInfixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一个名单载，完全和完整，第二个内的任何地方。</target>
        </trans-unit>
        <trans-unit id="88d273a08a3e06000e98c2629e1e60ff60ea1336" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; function takes two lists and returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; iff the first list is a suffix of the second. The second list must be finite.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:isSuffixOf&quot;&gt;isSuffixOf&lt;/a&gt;&lt;/code&gt; 函数有两个列表，并返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 当且仅当第一清单第二的后缀。第二个列表必须是有限的。</target>
        </trans-unit>
        <trans-unit id="551caf48474039991548fe9ddb64d72b72493414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from left to right, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumL&quot;&gt;mapAccumL&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; ; 它对列表的每个元素应用一个函数，从左到右传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="8de586ae79a455858fed3746ae4e38cd05c48c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; function behaves like a combination of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;; it applies a function to each element of a list, passing an accumulating parameter from right to left, and returning a final value of this accumulator together with the new list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:mapAccumR&quot;&gt;mapAccumR&lt;/a&gt;&lt;/code&gt; 函数的行为的组合等 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似 ; 它将函数应用于列表的每个元素，从右到左传递一个累加参数，并返回该累加器的最终值以及新列表。</target>
        </trans-unit>
        <trans-unit id="2391074ba068c80233175c59983a54b8066a4878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the greatest element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:maximumBy&quot;&gt;maximumBy&lt;/a&gt;&lt;/code&gt; 功能需要一个比较函数和一个列表，并通过比较函数返回列表中的最大元素。该列表必须是有限且非空的。</target>
        </trans-unit>
        <trans-unit id="cef47277c570e470c285b99dbd14acd85cf932dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; function takes a comparison function and a list and returns the least element of the list by the comparison function. The list must be finite and non-empty.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:minimumBy&quot;&gt;minimumBy&lt;/a&gt;&lt;/code&gt; 函数采用一个比较功能和列表，并通过比较函数返回列表的最小元素。该列表必须是有限且非空的。</target>
        </trans-unit>
        <trans-unit id="057b661eee28e56248a47e5a122b7f8d64ae8148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt;, except it uses a user-supplied equality predicate instead of the overloaded &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nubBy&quot;&gt;nubBy&lt;/a&gt;&lt;/code&gt; 功能行为就像 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:nub&quot;&gt;nub&lt;/a&gt;&lt;/code&gt; ，除了它使用一个用户提供的相等谓词来代替重载 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="19f8893f6a607220120cf57b88c38b3c50e89e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; function takes a predicate a list and returns the pair of lists of elements which do and do not satisfy the predicate, respectively; i.e.,</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:partition&quot;&gt;partition&lt;/a&gt;&lt;/code&gt; 函数采用一个谓词的列表，并返回一对和不满足谓词，分别元素列表的; 即</target>
        </trans-unit>
        <trans-unit id="2d853a061eb012af5ee71d94b4188db9e7e27bb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; function returns the list of all permutations of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:permutations&quot;&gt;permutations&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有排列的列表。</target>
        </trans-unit>
        <trans-unit id="0d369bcd6ff7a16017fc81230836cb1e2c9c3d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of a finite list of numbers.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限清单的产品。</target>
        </trans-unit>
        <trans-unit id="7601896a58f38cef45cf3ec9dd3675ffa2b1f23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; function implements a stable sorting algorithm. It is a special case of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt;, which allows the programmer to supply their own comparison function.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 函数实现稳定的排序算法。这是 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 的特例，它允许程序员提供自己的比较功能。</target>
        </trans-unit>
        <trans-unit id="c7da3570e28419be0578ffd1de4f0b1fde8e86aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; 功能的非重载版本 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1f49bd6e008dde965696cc4f68b37f4c1c2ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; function returns the list of all subsequences of the argument.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:subsequences&quot;&gt;subsequences&lt;/a&gt;&lt;/code&gt; 函数返回参数的所有子序列的列表。</target>
        </trans-unit>
        <trans-unit id="a6406e7e60d1afb305384d5af825ad223afd4d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of a finite list of numbers.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算数字的有限列表的总和。</target>
        </trans-unit>
        <trans-unit id="26c98a67aa07a5febf23006c6463cf654a93d6a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; function transposes the rows and columns of its argument. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:transpose&quot;&gt;transpose&lt;/a&gt;&lt;/code&gt; 功能调换其参数的行和列。例如，</target>
        </trans-unit>
        <trans-unit id="c88aa8ebb4d5e9ab3079fc636599897089099a45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; function is a `dual' to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;: while &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; reduces a list to a summary value, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; builds a list from a seed value. The function takes the element and returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if it is done producing the list or returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(a,b)&lt;/code&gt;, in which case, &lt;code&gt;a&lt;/code&gt; is a prepended to the list and &lt;code&gt;b&lt;/code&gt; is used as the next element in a recursive call. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 函数是双重`&amp;rdquo;至 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; ：而 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 相似减小了列表的摘要值， &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 构建从种子值的列表。该函数接受元素，如果完成生成列表，则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，或者返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(a,b)&lt;/code&gt; ，在这种情况下， &lt;code&gt;a&lt;/code&gt; 是列表的前缀， &lt;code&gt;b&lt;/code&gt; 用作递归调用中的下一个元素。例如，</target>
        </trans-unit>
        <trans-unit id="27a85700d4b6c91457baf0366be6c72427d177b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; function returns the list union of the two lists. For example,</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 函数返回两个列表名单工会。例如，</target>
        </trans-unit>
        <trans-unit id="897e5cd71a34240e2a452fc04aada2f8a3873766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; function is the non-overloaded version of &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unionBy&quot;&gt;unionBy&lt;/a&gt;&lt;/code&gt; 功能是非重载版本的 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:union&quot;&gt;union&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a213a220259b72a83d767902fd9b906a21d8991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f131d892100da4fd025f7a8ecff18fd3436b21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; function takes a list of quadruples and returns four lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip4&quot;&gt;unzip4&lt;/a&gt;&lt;/code&gt; 功能需要四倍和回报四个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f19f192bc7bca3bb3b366a104a1495f29a2a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; function takes a list of five-tuples and returns five lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip5&quot;&gt;unzip5&lt;/a&gt;&lt;/code&gt; 函数采用的五元组，并返回五个列表，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12f0884943983f42126b4d7235d7fee19d6961ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; function takes a list of six-tuples and returns six lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip6&quot;&gt;unzip6&lt;/a&gt;&lt;/code&gt; 函数采用六元组，并返回6个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd0ada4ba254397c7f2074cd7fe54881a14745ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; function takes a list of seven-tuples and returns seven lists, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip7&quot;&gt;unzip7&lt;/a&gt;&lt;/code&gt; 函数采用的七元组，并返回7个清单，类似于一个列表 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a0bedc800fc663f9a45123739d0871e9842832" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; function takes four lists and returns a list of quadruples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip4&quot;&gt;zip4&lt;/a&gt;&lt;/code&gt; 函数有四个名单，并返回四倍的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="b833eb65f6d996a715798ed453669aa9621f8431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; function takes five lists and returns a list of five-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip5&quot;&gt;zip5&lt;/a&gt;&lt;/code&gt; 功能需要五个名单和返回的五元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="59728e29b809276b20b7cc9ae48caadda444d7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; function takes six lists and returns a list of six-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip6&quot;&gt;zip6&lt;/a&gt;&lt;/code&gt; 功能需要六个月名单和返回的六元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="df3589322d209e15f6610db4bb0c1c54692646e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; function takes seven lists and returns a list of seven-tuples, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip7&quot;&gt;zip7&lt;/a&gt;&lt;/code&gt; 功能需要七名名单和返回的七元组的列表，类似于 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zip&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="7fb675c3384f90b4e5fdef7383e6b1b6d07309c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="4d9d273ee2479cdb2c6b8ef0f65b15d495db5a7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; function takes a function which combines four elements, as well as four lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith4&quot;&gt;zipWith4&lt;/a&gt;&lt;/code&gt; 函数采用结合了四个元件，以及四个列表并返回其逐点组合的列表，类似于一个函数 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="6aa1fdb5c348373284d6b8cfbe31c2976333f351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; function takes a function which combines five elements, as well as five lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith5&quot;&gt;zipWith5&lt;/a&gt;&lt;/code&gt; 功能需要，结合五行，以及五个列表，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="5fd0df64a913d6523d2c136a1cb0ba65ca9434f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; function takes a function which combines six elements, as well as six lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith6&quot;&gt;zipWith6&lt;/a&gt;&lt;/code&gt; 功能需要，结合六大要素，以及6名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="57fc99e0dcfb0d585978688443e7472a5b1473e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; function takes a function which combines seven elements, as well as seven lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith7&quot;&gt;zipWith7&lt;/a&gt;&lt;/code&gt; 功能需要它结合了七个要素，以及七名名单，并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="b1325d57361ccc732ebb070de994b0a2421219c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; types and operations.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 类型和操作。</target>
        </trans-unit>
        <trans-unit id="5763505508dac7b11615ee08a7acaba3fb632110" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; function casts a pointer from one type to another.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:castPtr&quot;&gt;castPtr&lt;/a&gt;&lt;/code&gt; 功能投射的指针从一种类型到另一个。</target>
        </trans-unit>
        <trans-unit id="a500ee9d80b7f54eb7f8c916b79c09da04687f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; class and instances for basic data types.</source>
          <target state="translated">基本数据类型的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 类和实例。</target>
        </trans-unit>
        <trans-unit id="f5c958fd454a64dcb4c746fc275eb37dbbac1200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;ghc-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86c3288ccf7776810d20b3731af2e3b40bfcb247" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; class, and related operations.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类，以及相关业务。</target>
        </trans-unit>
        <trans-unit id="9d5187961ae2687bea868b7eebea12a2b0fc9457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; Monad.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-st#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 单子。</target>
        </trans-unit>
        <trans-unit id="1a6e8251d60596b015e69b7b30aa3903c1d58def" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; that can be used to look up the given &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticKey&quot;&gt;StaticKey&lt;/a&gt;&lt;/code&gt; 可用于查找指定 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed23a830eec8e95fb04719f3ba021e908eb49a47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 功能让你运行一个I / O运算在 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。请注意：可以确保在单个 &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 计算中对 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 的调用顺序，但不能保证运行拼接的顺序。</target>
        </trans-unit>
        <trans-unit id="fa005a185e418ee86a0f14b966d5bed4334ff0bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; type, a value &lt;code&gt;q&lt;/code&gt; of this type can be used in the syntax &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt;. In fact, for convenience, a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; actually defines multiple quasiquoters to be used in different splice contexts; if you are only interested in defining a quasiquoter to be used for expressions, you would define a &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; with only &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt;, and leave the other fields stubbed out with errors.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 类型，值 &lt;code&gt;q&lt;/code&gt; 这种类型的可以在语法中使用 &lt;code&gt;[q| ... string to parse ...|]&lt;/code&gt; 。实际上，为方便起见， &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 实际上定义了多个拟引用符，这些拟引用符可用于不同的剪接上下文中。如果你只在定义用于表达式quasiquoter兴趣的话，你会定义一个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#t:QuasiQuoter&quot;&gt;QuasiQuoter&lt;/a&gt;&lt;/code&gt; 只有 &lt;code&gt;&lt;a href=&quot;language-haskell-th-quote#v:quoteExp&quot;&gt;quoteExp&lt;/a&gt;&lt;/code&gt; ，并留下错误灭掉其他领域。</target>
        </trans-unit>
        <trans-unit id="822f6a374e5da6792e8281daef5bc8cbc52436fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; function lets you run an I/O computation in the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Take care: you are guaranteed the ordering of calls to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; within a single &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; computation, but not about the order in which splices are run.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 功能让你运行一个I / O运算在 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 单子。请注意：可以确保在单个 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; 计算中对 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:runIO&quot;&gt;runIO&lt;/a&gt;&lt;/code&gt; 的调用顺序，但不能保证运行拼接的顺序。</target>
        </trans-unit>
        <trans-unit id="8a0d53f38c6a950df5eadf21a9f9db4dfc69bf0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class is used to name the upper and lower limits of a type. &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is not a superclass of &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; since types that are not totally ordered may also have upper and lower bounds.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类用于命名的类型的上限和下限。 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 的超类，因为未完全排序的类型也可能具有上限和下限。</target>
        </trans-unit>
        <trans-unit id="bf58cbc6033627535675be41f7c5c26c9a969514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; class may be derived for any enumeration type; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; is the first constructor listed in the &lt;code&gt;data&lt;/code&gt; declaration and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; is the last. &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; may also be derived for single-constructor datatypes whose constituent types are in &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 类可衍生自任何枚举类型; &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;data&lt;/code&gt; 声明中列出的第一个构造函数，而 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 是最后一个。 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 也可以导出单构造的数据类型，其构成类型在 &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f24f4c3acddeb2d8485bbd7d048662ea4520e018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type is sometimes used to represent a value which is either correct or an error; by convention, the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor is used to hold an error value and the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor is used to hold a correct value (mnemonic: &quot;right&quot; also means &quot;correct&quot;).</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型有时被用来表示一个值，其是正确或错误; 按照惯例， &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数用于保存错误值，而 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数用于保存正确的值（助记符：&amp;ldquo; right&amp;rdquo;也表示&amp;ldquo; correct&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9d02c060c8f45391329e1f6687a2f0b6730500f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type represents values with two possibilities: a value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型表示的值与两种可能性：type的值 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; a b&lt;/code&gt; 或者是 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt; a&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt; b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e44fd4d00d0795dea5f783f70db56faa6bffc024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; class defines equality (&lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt;) and inequality (&lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt;). All the basic datatypes exported by the &lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt; are instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; may be derived for any datatype whose constituents are also instances of &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类定义平等（ &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; ）和不等式（ &lt;code&gt;&lt;a href=&quot;prelude#v:-47--61-&quot;&gt;/=&lt;/a&gt;&lt;/code&gt; ）。&lt;a href=&quot;prelude&quot;&gt;Prelude&lt;/a&gt;导出的所有基本数据类型都是 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例，并且 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 可以针对其组成也是 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 的实例的任何数据类型派生。</target>
        </trans-unit>
        <trans-unit id="75fb7e193c14639f9f2c840b46b6b678ecc93443" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type encapsulates an optional value. A value of type &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; either contains a value of type &lt;code&gt;a&lt;/code&gt; (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt;), or it is empty (represented as &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;). Using &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is a good way to deal with errors or exceptional cases without resorting to drastic measures such as &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型封装了一个可选值。类型的值 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt; a&lt;/code&gt; 或者包含类型的值 &lt;code&gt;a&lt;/code&gt; （表示为 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt; a&lt;/code&gt; ），或者它是空的（表示为 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ）。使用 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 是处理错误或特殊情况的好方法，而无需采取诸如 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 严厉措施。</target>
        </trans-unit>
        <trans-unit id="9d4644834b747ca6136ef2aaff7f66c325592783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; type is also a monad. It is a simple kind of error monad, where all errors are represented by &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. A richer error monad can be built using the &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 类型也是一个单子。这是一种简单的错误单子，所有错误都由 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 表示。可以使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 类型构建更丰富的错误单子。</target>
        </trans-unit>
        <trans-unit id="b2bc4ca3d8934e365fb80ceb2378eb5082b3a17f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; class defines the basic operations over a &lt;em&gt;monad&lt;/em&gt;, a concept from a branch of mathematics known as &lt;em&gt;category theory&lt;/em&gt;. From the perspective of a Haskell programmer, however, it is best to think of a monad as an &lt;em&gt;abstract datatype&lt;/em&gt; of actions. Haskell's &lt;code&gt;do&lt;/code&gt; expressions provide a convenient syntax for writing monadic expressions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 类定义的基本操作在&lt;em&gt;单子&lt;/em&gt;从被称为数学的一个分支，一个概念&lt;em&gt;范畴论&lt;/em&gt;。但是，从Haskell程序员的角度来看，最好将monad视为动作的&lt;em&gt;抽象数据类型&lt;/em&gt;。Haskell的 &lt;code&gt;do&lt;/code&gt; 表达式为编写单子表达式提供了一种方便的语法。</target>
        </trans-unit>
        <trans-unit id="7aaef56b80f737eb27df9b1e3d02aefbb49c126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; allows us to chain together multiple actions which may fail, and fail overall if any of the individual steps failed. First we'll write a function that can either parse an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;, or fail.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例使我们可以将可能失败的多个动作链接在一起，如果任何单个步骤失败，则整体失败。首先，我们将编写一个可以从 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 解析 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 或失败的函数。</target>
        </trans-unit>
        <trans-unit id="7b3a6ba7d1631eb7dffbc7a80d33a50655ec5cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class is used for totally ordered datatypes.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类用于全序数据类型。</target>
        </trans-unit>
        <trans-unit id="7fb9b92b465e420832be5f52da24e03070664a5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; from our &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance will ignore &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values, but will apply the supplied function to values contained in a &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">来自 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例的 &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 将忽略 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 值，但会将提供的函数应用于 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 中包含的值：</target>
        </trans-unit>
        <trans-unit id="bb778616987d1ec9e7af8ce5c3a0fe1ad6f720c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 方法限制到类型 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdbf4d018722d263569f1a254868963b4ff029df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入一个字符串，其被懒惰地读取，因为它需要（同 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aa6a84a7de6790cd0de53c018c33b1487b75f830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 函数采用类型的函数 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入作为其参数传递给该函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="79b16f25ddf4b36594ea2e938465c9296ed38dc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;prelude#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0e4582487867df9d645782b484418688a1f3f58c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; function takes a default value, a function, and a &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the function returns the default value. Otherwise, it applies the function to the value inside the &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; and returns the result.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;prelude#v:maybe&quot;&gt;maybe&lt;/a&gt;&lt;/code&gt; 的功能需要一个默认值，函数，和 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 的值。如果 &lt;code&gt;&lt;a href=&quot;prelude#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值为 &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则该函数返回默认值。否则，它将函数应用于 &lt;code&gt;&lt;a href=&quot;prelude#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 内的值并返回结果。</target>
        </trans-unit>
        <trans-unit id="c131692c2bade036458b0d1127914f219c7dd175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能输出任何可打印类型到标准输出设备的值。可打印类型是属于 &lt;code&gt;&lt;a href=&quot;prelude#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类的实例的那些类型； &lt;code&gt;&lt;a href=&quot;prelude#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作将值转换为字符串以输出，并添加换行符。</target>
        </trans-unit>
        <trans-unit id="8c7fc1c52a42ce0024aec6c65a38a9e6dc8fb7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; function computes the product of the numbers of a structure.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:product&quot;&gt;product&lt;/a&gt;&lt;/code&gt; 功能计算结构的数的乘积。</target>
        </trans-unit>
        <trans-unit id="f99911d99a3ef08fe8f375dba1db41c4eecf08d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 功能从一个字符串，它必须由输入处理被完全消耗读取输入。如果解析不成功，则 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 失败并显示 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ，因此不建议在实际应用程序中使用它。使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 作为安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="4ffdc3ac1e36da7a1438f94612f331c6323f073b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。像 &lt;code&gt;&lt;a href=&quot;prelude#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，按需延迟读取文件。</target>
        </trans-unit>
        <trans-unit id="1edaaff10f2fbe79640944d7ec56cb49a4bed802" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 功能类似于 &lt;code&gt;&lt;a href=&quot;prelude#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 不同之处在于它用信号解析失败的 &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子终止程序，而不是。</target>
        </trans-unit>
        <trans-unit id="9e25de194b180f1f5888a1fb8e989cb909435014" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 函数组合 &lt;code&gt;&lt;a href=&quot;prelude#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfe43d67eb01eceb873ed3fd660e71f0f5174638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; function computes the sum of the numbers of a structure.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;prelude#v:sum&quot;&gt;sum&lt;/a&gt;&lt;/code&gt; 函数计算结构的数的总和。</target>
        </trans-unit>
        <trans-unit id="bbb5313ec9e6c9e5650625c5d2da153e452b2504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; method restricted to the type &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 方法限制到类型 &lt;code&gt;&lt;a href=&quot;data-char#v:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a04819fa78c89f5452b8780304a58025b2a647c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; function takes a list of triples and returns three lists, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:unzip3&quot;&gt;unzip3&lt;/a&gt;&lt;/code&gt; 函数接受三元并返回三个列表，类似的列表 &lt;code&gt;&lt;a href=&quot;prelude#v:unzip&quot;&gt;unzip&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052c2b73f585f4387bcfea6e35542d389d49e8f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; function takes a function which combines three elements, as well as three lists and returns a list of their point-wise combination, analogous to &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt;. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith3&quot;&gt;zipWith3&lt;/a&gt;&lt;/code&gt; 功能需要，是由三个要素，以及三个列表并返回其逐点组合的清单，类似于一个功能 &lt;code&gt;&lt;a href=&quot;prelude#v:zipWith&quot;&gt;zipWith&lt;/a&gt;&lt;/code&gt; 。它能够进行列表融合，但仅限于其第一个列表参数及其结果列表。</target>
        </trans-unit>
        <trans-unit id="645f48f9edaa9bdfcdbd50f2978b6ca7c976e666" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; input functions (e.g. &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt;) don't automatically convert to Unicode, so this function is provided to make the conversion from a multibyte string in the given code page to a proper Unicode string. To get the code page for the console, use &lt;code&gt;getConsoleCP&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system#v:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 输入功能（如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; ）不会自动转换为Unicode，所以提供了这个功能，使从给定的代码页中的多字节字符串到一个适当的Unicode字符串转换。要获取控制台的代码页，请使用 &lt;code&gt;getConsoleCP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9915513312e5b9714f0fe4288381e0da0f72704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; monad transformer provides direct, low-level access to the user's line history state.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:InputT&quot;&gt;InputT&lt;/a&gt;&lt;/code&gt; 单子变压器提供给用户的在线历史记录状态直接，低级别的访问。</target>
        </trans-unit>
        <trans-unit id="77b115021e101641ef1f81dd36bd9d5f8a21f7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; method enables us to &quot;lift&quot; a function that manages IO actions (such as &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt;) into a function that wraps arbitrary monadic actions.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:controlIO&quot;&gt;controlIO&lt;/a&gt;&lt;/code&gt; 方法使我们能够&amp;ldquo;升降机&amp;rdquo;管理IO操作（如函数 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-monadexception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; ）到一个函数，它包裹任意的一元操作。</target>
        </trans-unit>
        <trans-unit id="d97760ad46f0a47182108cce3dd3552c71ffced8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; monoid abstracts away all padding and control sequence output. Unfortunately, that datatype is difficult to integrate into existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;-based APIs such as pretty-printers. Thus, as a workaround, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; also lets us access the control sequences as &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The one caveat is that it will not allow you to access padded control sequences as Strings. For example:</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:TermOutput&quot;&gt;TermOutput&lt;/a&gt;&lt;/code&gt; 独异抽象了所有填充和控制序列输出。不幸的是，该数据类型很难集成到现有的基于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的API（例如pretty-printer）中。因此，作为一种解决方法， &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:tiGetOutput1&quot;&gt;tiGetOutput1&lt;/a&gt;&lt;/code&gt; 还允许我们以 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的形式访问控制序列。一个警告是，它不允许您将填充的控制序列作为字符串访问。例如：</target>
        </trans-unit>
        <trans-unit id="7ff1172a4964334b38f0ed53fd5acdd80ad6655a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; constant is the smallest measurable difference in CPU time that the implementation can record, and is given as an integral number of picoseconds.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-cputime#v:cpuTimePrecision&quot;&gt;cpuTimePrecision&lt;/a&gt;&lt;/code&gt; 常数是在CPU时间最小可测量的差异是，实现可以记录，并给出皮秒的整数倍。</target>
        </trans-unit>
        <trans-unit id="d42c1bb360791782c56c45d321fb837bc1ed609e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; type is used to record whether certain operations are permissible on a file/directory. &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; get and set these permissions, respectively. Permissions apply both to files and directories. For directories, the executable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, and for files the searchable field will be &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;. Note that directories may be searchable without being readable, if permission has been given to use them as part of a path, but not to examine the directory contents.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory#t:Permissions&quot;&gt;Permissions&lt;/a&gt;&lt;/code&gt; 类型是用来记录某些操作是否在一个文件/目录允许的。 &lt;code&gt;&lt;a href=&quot;system-directory#v:getPermissions&quot;&gt;getPermissions&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-directory#v:setPermissions&quot;&gt;setPermissions&lt;/a&gt;&lt;/code&gt; 分别获取和设置这些权限。权限适用于文件和目录。对于目录，可执行字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; ，对于文件，可搜索字段将为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 。请注意，如果已允许使用目录作为路径的一部分，但不检查目录内容，则可以搜索目录而不可读。</target>
        </trans-unit>
        <trans-unit id="a7fb38ca78261525df1464df4fb698278b8051df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; function takes a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;s and returns a list of all the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 函数接受列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; S和返回所有的列表 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="b9dec7d9cce3f521b0de7412db5964162658ad1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 功能建立接收任何处理 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中所保护的作用提出 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 是由的异常处理功能，建立了一个最新的处理程序捕获。这些处理程序不是选择性的：捕获了所有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。必须通过重新引发任何不需要的异常，在处理程序中显式提供异常传播。例如，在</target>
        </trans-unit>
        <trans-unit id="ff85ed75d901b4d2c7aa0d2761fd28a6697d0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; function takes a default value and and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; value. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, it returns the default values; otherwise, it returns the value contained in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:fromMaybe&quot;&gt;fromMaybe&lt;/a&gt;&lt;/code&gt; 功能需要一个默认值，并 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，则返回默认值；否则，返回默认值。否则，它返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 中包含的值。</target>
        </trans-unit>
        <trans-unit id="2c7eae4b2c5061e05af7d962b180cd3821808d93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; function returns an empty list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; or a singleton list when given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当给出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:maybeToList&quot;&gt;maybeToList&lt;/a&gt;&lt;/code&gt; 函数返回一个空列表，而给出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 时，则返回一个单例列表。</target>
        </trans-unit>
        <trans-unit id="c0aa3120b7fd0765f6ac196cefe19e035c54f08e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; operation returns all user input as a single string, which is read lazily as it is needed (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 操作返回所有的用户输入一个字符串，其被懒惰地读取，因为它需要（同 &lt;code&gt;&lt;a href=&quot;system-io#v:hGetContents&quot;&gt;hGetContents&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="49101be718bf6fa482ea1ac280c8c3978edbdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; function takes a function of type &lt;code&gt;String-&amp;gt;String&lt;/code&gt; as its argument. The entire input from the standard input device is passed to this function as its argument, and the resulting string is output on the standard output device.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;system-io#v:interact&quot;&gt;interact&lt;/a&gt;&lt;/code&gt; 函数采用类型的函数 &lt;code&gt;String-&amp;gt;String&lt;/code&gt; 作为其参数。来自标准输入设备的整个输入作为其参数传递给该函数，并且结果字符串在标准输出设备上输出。</target>
        </trans-unit>
        <trans-unit id="c28c31ff8d6196f0cd154601474e1e3b9b58f9bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function outputs a value of any printable type to the standard output device. Printable types are those that are instances of class &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; converts values to strings for output using the &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; operation and adds a newline.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能输出任何可打印类型到标准输出设备的值。可打印类型是属于 &lt;code&gt;&lt;a href=&quot;text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 类的实例的那些类型； &lt;code&gt;&lt;a href=&quot;system-io#v:print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; 操作将值转换为字符串以输出，并添加换行符。</target>
        </trans-unit>
        <trans-unit id="825ef90fdaca88a42de4c139d5e6c64085f34a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 函数读取文件并返回该文件的内容作为字符串。像 &lt;code&gt;&lt;a href=&quot;system-io#v:getContents&quot;&gt;getContents&lt;/a&gt;&lt;/code&gt; 一样，按需延迟读取文件。</target>
        </trans-unit>
        <trans-unit id="c55ec6a3320441e71baa3c7cddc99bb5586ab05b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; function is similar to &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; except that it signals parse failure to the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad instead of terminating the program.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 功能类似于 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 不同之处在于它用信号解析失败的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子终止程序，而不是。</target>
        </trans-unit>
        <trans-unit id="892d5a8616ddf159523b449a487e6243305ef9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; function combines &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io#v:readLn&quot;&gt;readLn&lt;/a&gt;&lt;/code&gt; 函数组合 &lt;code&gt;&lt;a href=&quot;system-io#v:getLine&quot;&gt;getLine&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-io#v:readIO&quot;&gt;readIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f01cd96e2bf006a175917ef728b5ef21ad4ad33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; function establishes a handler that receives any &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; raised in the action protected by &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; is caught by the most recent handler established by one of the exception handling functions. These handlers are not selective: all &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt;s are caught. Exception propagation must be explicitly provided in a handler by re-raising any unwanted exceptions. For example, in</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 功能建立接收任何处理 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 中所保护的作用提出 &lt;code&gt;&lt;a href=&quot;system-io-error#v:catchIOError&quot;&gt;catchIOError&lt;/a&gt;&lt;/code&gt; 。一个 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 是由的异常处理功能，建立了一个最新的处理程序捕获。这些处理程序不是选择性的：捕获了所有 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。必须通过重新引发任何不需要的异常，在处理程序中显式提供异常传播。例如，在</target>
        </trans-unit>
        <trans-unit id="8e2935b648dbc65061463e0e0bc3ae9bc38731b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; function clears the environment of all name-value pairs.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:clearEnv&quot;&gt;clearEnv&lt;/a&gt;&lt;/code&gt; 功能清除所有名称-值对的环境。</target>
        </trans-unit>
        <trans-unit id="369194824dad3c17becd69feafce80094511a779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 功能插入或重置当前环境列表中的环境变量名称。如果列表中不存在变量 &lt;code&gt;name&lt;/code&gt; ，则会使用给定值将其插入。如果变量确实存在，则测试参数 &lt;code&gt;overwrite&lt;/code&gt; ；否则，将测试参数覆盖。如果 &lt;code&gt;overwrite&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则不重置变量，否则将其重置为给定值。</target>
        </trans-unit>
        <trans-unit id="e16fdd3c2060c8b0e7dcb0de6c67a978ff67d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 函数删除从环境变量名的所有实例。</target>
        </trans-unit>
        <trans-unit id="6390faf5740aef6b3fe69f665e1639661b490c68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; function inserts or resets the environment variable name in the current environment list. If the variable &lt;code&gt;name&lt;/code&gt; does not exist in the list, it is inserted with the given value. If the variable does exist, the argument &lt;code&gt;overwrite&lt;/code&gt; is tested; if &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the variable is not reset, otherwise it is reset to the given value.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; 功能插入或重置当前环境列表中的环境变量名称。如果列表中不存在变量 &lt;code&gt;name&lt;/code&gt; ，则会使用给定值将其插入。如果变量确实存在，则测试参数 &lt;code&gt;overwrite&lt;/code&gt; ；否则，将测试参数覆盖。如果 &lt;code&gt;overwrite&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ，则不重置变量，否则将其重置为给定值。</target>
        </trans-unit>
        <trans-unit id="908e9623e5b8e5381ae3293c89d2d6a40a5a4714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; function deletes all instances of the variable name from the environment.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;system-posix-env-bytestring#v:unsetEnv&quot;&gt;unsetEnv&lt;/a&gt;&lt;/code&gt; 函数删除从环境变量名的所有实例。</target>
        </trans-unit>
        <trans-unit id="236f78121c4a2f2bf7b4a76db19e5a7170bc2449" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-posix-io#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 函数创建一对连接的文件描述符。第一个组件是要读取的fd，第二个组件是写端。尽管管道可能是双向的，但这种行为不是可移植的，为此，程序员应使用两个单独的管道。如果这是一个无效的描述符，可能会引发异常。</target>
        </trans-unit>
        <trans-unit id="d4b473f0667d5a6b55f733ab3a3194586555807c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; function creates a pair of connected file descriptors. The first component is the fd to read from, the second is the write end. Although pipes may be bidirectional, this behaviour is not portable and programmers should use two separate pipes for this purpose. May throw an exception if this is an invalid descriptor.</source>
          <target state="translated">所述 &lt;code&gt;&lt;a href=&quot;system-posix-io-bytestring#v:createPipe&quot;&gt;createPipe&lt;/a&gt;&lt;/code&gt; 函数创建一对连接的文件描述符。第一个组件是要读取的fd，第二个组件是写端。尽管管道可能是双向的，但这种行为不是可移植的，为此，程序员应使用两个单独的管道。如果这是一个无效的描述符，可能会引发异常。</target>
        </trans-unit>
        <trans-unit id="50694ec6aab0913f0db1bc83f6e0ed0aed5dd7e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-printf#t:HPrintfType&quot;&gt;HPrintfType&lt;/a&gt;&lt;/code&gt; 类为可变参数魔法 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; 。从模块中看不到它的实现。</target>
        </trans-unit>
        <trans-unit id="290847fe4ef7b4c780f17cc14317e4a804018f65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; class provides the variable argument magic for &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;. Its implementation is intentionally not visible from this module. If you attempt to pass an argument of a type which is not an instance of this class to &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt;, then the compiler will report it as a missing instance of &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfType&quot;&gt;PrintfType&lt;/a&gt;&lt;/code&gt; 类为可变参数神奇 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 。从模块中看不到它的实现。如果您尝试将不是此类的实例的类型的参数传递给 &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-printf#v:hPrintf&quot;&gt;hPrintf&lt;/a&gt;&lt;/code&gt; ，则编译器会将其报告为缺少的 &lt;code&gt;&lt;a href=&quot;text-printf#t:PrintfArg&quot;&gt;PrintfArg&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="6bde3b6deb5751130f8fa9aed7708139a05904e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; function reads a single lexeme from the input, discarding initial white space, and returning the characters that constitute the lexeme. If the input string contains only white space, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; returns a single successful `lexeme' consisting of the empty string. (Thus &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt;.) If there is no legal lexeme at the beginning of the input string, &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; fails (i.e. returns &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 函数读取从输入的单个词位，丢弃最初的白色空间，并返回构成词位的字符。如果输入字符串仅包含空格，则 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 返回由空字符串组成的单个成功的'lexeme'。（因此 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt; &quot;&quot; = [(&quot;&quot;,&quot;&quot;)]&lt;/code&gt; 。）如果输入字符串的开头没有合法的词素，则 &lt;code&gt;&lt;a href=&quot;text-read#v:lex&quot;&gt;lex&lt;/a&gt;&lt;/code&gt; 失败（即返回 &lt;code&gt;[]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1a9d5cf956b4aeb4977bd49b0f7c6321ffb9b927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function reads input from a string, which must be completely consumed by the input process. &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; fails with an &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; if the parse is unsuccessful, and it is therefore discouraged from being used in real applications. Use &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; for safe alternatives.</source>
          <target state="translated">的 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 功能从一个字符串，它必须由输入处理被完全消耗读取输入。如果解析不成功，则 &lt;code&gt;&lt;a href=&quot;text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 失败并显示 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; ，因此不建议在实际应用程序中使用它。使用 &lt;code&gt;&lt;a href=&quot;text-read#v:readMaybe&quot;&gt;readMaybe&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-read#v:readEither&quot;&gt;readEither&lt;/a&gt;&lt;/code&gt; 作为安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="7c81f5117934d868bf2254238529c0a48b7fea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; argument controls how many test rounds are performed for determining a &lt;em&gt;probable prime&lt;/em&gt;. For more details, see &lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;GMP documentation for `mpz_probab_prime_p()`&lt;/a&gt;.</source>
          <target state="translated">第 &lt;code&gt;&lt;em&gt;k&lt;/em&gt;&lt;/code&gt; 个参数控制执行多少轮测试以确定&lt;em&gt;可能的素数&lt;/em&gt;。有关更多详细信息，请参见&lt;a href=&quot;http://gmplib.org/manual/Number-Theoretic-Functions.html#index-mpz_005fprobab_005fprime_005fp-360&quot;&gt;`mpz_probab_prime_p（）`的GMP文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bad337d10fc64d5b2ff3dbc6f2bf484df6cb613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BigNat&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;BigNat&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="b24b400b6bb089abd37b81edfb22c9c44a5b28fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Bits&lt;/code&gt; class does not have a &lt;code&gt;Num&lt;/code&gt; superclass. It therefore does not have default methods for the &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;testBit&lt;/code&gt; and &lt;code&gt;popCount&lt;/code&gt; methods.</source>
          <target state="translated">该 &lt;code&gt;Bits&lt;/code&gt; 类没有一个 &lt;code&gt;Num&lt;/code&gt; 超。因此，对于 &lt;code&gt;bit&lt;/code&gt; ， &lt;code&gt;testBit&lt;/code&gt; 和 &lt;code&gt;popCount&lt;/code&gt; 方法，它没有默认方法。</target>
        </trans-unit>
        <trans-unit id="7585bf1c302df16ed91051c8a55f49dac7f27c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ByteString&lt;/code&gt; 型</target>
        </trans-unit>
        <trans-unit id="a4cb78819e2dcf3b038b0fa6fa29d124f961d0aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ByteString&lt;/code&gt; type and representation</source>
          <target state="translated">的 &lt;code&gt;ByteString&lt;/code&gt; 类型和表示</target>
        </trans-unit>
        <trans-unit id="005e2bda030ee8e32664f998432e3befbee14062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CApiFFI&lt;/code&gt; extension allows a calling convention of &lt;code&gt;capi&lt;/code&gt; to be used in foreign declarations, e.g.</source>
          <target state="translated">该 &lt;code&gt;CApiFFI&lt;/code&gt; 扩展允许的调用约定 &lt;code&gt;capi&lt;/code&gt; 在国外报关使用，例如</target>
        </trans-unit>
        <trans-unit id="13b7284405381c1e383cd0d0249cafb8eb623b0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPLETE&lt;/code&gt; pragma is used to inform the pattern match checker that a certain set of patterns is complete and that any function which matches on all the specified patterns is total.</source>
          <target state="translated">的 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示被用来通知模式匹配检查了某种特定的图案是完全的，而且，其上的所有指定的模式匹配的任何功能是总。</target>
        </trans-unit>
        <trans-unit id="97ba5a1df665f08e5746afd5258e9f9bc0483c65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CallStack&lt;/code&gt; will only extend as far as the types allow it, for example</source>
          <target state="translated">例如， &lt;code&gt;CallStack&lt;/code&gt; 只能扩展到类型允许的范围内</target>
        </trans-unit>
        <trans-unit id="b22faafc676f89394f33e91663ca60cabb6bc4b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Chan&lt;/code&gt; type</source>
          <target state="translated">在 &lt;code&gt;Chan&lt;/code&gt; 式</target>
        </trans-unit>
        <trans-unit id="56868895505567b8dd6fa6c19b6bf5118c82d7d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOCTYPE&lt;/code&gt; for XHTML 1.0 Strict.</source>
          <target state="translated">XHTML 1.0严格的 &lt;code&gt;DOCTYPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffc2f173105c8fb1fcbdf98a1d298ce5e8bba858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dynamic&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Dynamic&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="2f473b66e396d89af61f465962bc064a789e33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ErrorT&lt;/code&gt; Monad structure is parameterized over two things:</source>
          <target state="translated">该 &lt;code&gt;ErrorT&lt;/code&gt; 单子结构参数超过两件事情：</target>
        </trans-unit>
        <trans-unit id="f105cba62162d63271c49af7cd9cd8361ee2895b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOO.hp&lt;/code&gt; file produced when you ask for the heap profile of a program &lt;code&gt;FOO&lt;/code&gt; is a text file with a particularly simple structure. Here&amp;rsquo;s a representative example, with much of the actual data omitted:</source>
          <target state="translated">当您要求程序 &lt;code&gt;FOO&lt;/code&gt; 的堆概要文件时生成的 &lt;code&gt;FOO.hp&lt;/code&gt; 文件是具有特别简单结构的文本文件。这是一个有代表性的示例，其中省略了许多实际数据：</target>
        </trans-unit>
        <trans-unit id="48feef81fcfb630b464ad6ce416e6ee040c4f208" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo @k a = a&lt;/code&gt; equation would be represented as follows:</source>
          <target state="translated">所述 &lt;code&gt;Foo @k a = a&lt;/code&gt; 等式可表示为如下：</target>
        </trans-unit>
        <trans-unit id="c992f175532ed7a0887c33f484f4c4856a6f5c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Foo_stub.h&lt;/code&gt; file can be redirected using the &lt;code&gt;-stubdir&lt;/code&gt; option; see &lt;a href=&quot;separate_compilation#options-output&quot;&gt;Redirecting the compilation output(s)&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;Foo_stub.h&lt;/code&gt; 文件，可以使用重定向 &lt;code&gt;-stubdir&lt;/code&gt; 选项; 请参阅&lt;a href=&quot;separate_compilation#options-output&quot;&gt;重定向编译输出&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc9f316a3a267a4b9984d1222e0ad9feb74bf869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; environment variable may be set to a &lt;code&gt;:&lt;/code&gt;-separated (&lt;code&gt;;&lt;/code&gt;-separated on Windows) list of files containing package databases. This list of package databases, used by GHC and ghc-pkg, specifies a stack of package databases from top to bottom. This order was chosen to match the behaviour of the &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; environment variable where entries earlier in the PATH override ones that come later. See &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt; for details on how the package database stack is used.</source>
          <target state="translated">所述 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 环境变量可以被设置为一个 &lt;code&gt;:&lt;/code&gt; -分隔（ &lt;code&gt;;&lt;/code&gt; -分隔视窗上）包含数据库文件的列表。由GHC和ghc-pkg使用的软件包数据库列表从上到下指定了软件包数据库的堆栈。选择此顺序以匹配 &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 环境变量的行为，其中PATH中较早的条目会覆盖后面的条目。有关如何使用软件包数据库堆栈的详细信息，请参见&lt;a href=&quot;#package-databases&quot;&gt;软件包数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f21fc75056d50350516dd52ff5912c872b8b9460" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GenLanguageDef&lt;/code&gt; type is a record that contains all parameterizable features of the &lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt; module. The module &lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt; contains some default definitions.</source>
          <target state="translated">该 &lt;code&gt;GenLanguageDef&lt;/code&gt; 类型是包含所有参数化特征的记录&lt;a href=&quot;text-parsec-token&quot;&gt;Text.Parsec.Token&lt;/a&gt;模块。模块&lt;a href=&quot;text-parsec-language&quot;&gt;Text.Parsec.Language&lt;/a&gt;包含一些默认定义。</target>
        </trans-unit>
        <trans-unit id="c4e050756130eeb11c58b31896ace2ae245341ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic1&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;Generic1&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="b121f20d20404180364bfd43491c63f4245f97f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt; classes mediate between user-defined datatypes and their internal representation as a sum-of-products:</source>
          <target state="translated">的 &lt;code&gt;Generic&lt;/code&gt; 和 &lt;code&gt;Generic1&lt;/code&gt; 类用户定义的数据类型和它们的内部表示作为求和的产品之间进行调解：</target>
        </trans-unit>
        <trans-unit id="7c04d22bf6198b566fefab29ee20c196be128ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSfoo.o&lt;/code&gt; file is built by Cabal automatically; use &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; to disable it. To build one manually, the following GNU &lt;code&gt;ld&lt;/code&gt; command can be used:</source>
          <target state="translated">该 &lt;code&gt;HSfoo.o&lt;/code&gt; 文件由卡瓦尔自动构建; 使用 &lt;code&gt;--disable-library-for-ghci&lt;/code&gt; 将其禁用。要手动构建一个，可以使用以下GNU &lt;code&gt;ld&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="4504a638df2b2b4639ba03e3b6d8a72cdcb6adda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INCLUDE&lt;/code&gt; used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers.</source>
          <target state="translated">当使用FFI并通过C进行编译时， &lt;code&gt;INCLUDE&lt;/code&gt; 曾经是指定要包含的头文件所必需的。GHC不再需要INCLUDE，但是为了与其他编译器兼容，它被接受（并被忽略）。</target>
        </trans-unit>
        <trans-unit id="7e15878bd48bab3818efd590996e87053049c312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INLINABLE&lt;/code&gt; pragma also works with &lt;code&gt;SPECIALISE&lt;/code&gt;: if you mark function &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;INLINABLE&lt;/code&gt;, then you can subsequently &lt;code&gt;SPECIALISE&lt;/code&gt; in another module (see &lt;a href=&quot;#specialize-pragma&quot;&gt;SPECIALIZE pragma&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;INLINABLE&lt;/code&gt; 编译还与 &lt;code&gt;SPECIALISE&lt;/code&gt; ：如果您标记功能 &lt;code&gt;f&lt;/code&gt; 作为 &lt;code&gt;INLINABLE&lt;/code&gt; ，那么你就可以随后 &lt;code&gt;SPECIALISE&lt;/code&gt; 在另一模块（见&lt;a href=&quot;#specialize-pragma&quot;&gt;专门编译&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="011dae688b0bf1afe030126194f5bf145fe1f133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Int&lt;/code&gt; may well fix &lt;code&gt;b&lt;/code&gt; at the call site, so that signature should not be rejected. Moreover, the dependencies might be hidden. Consider</source>
          <target state="translated">该 &lt;code&gt;Int&lt;/code&gt; 可能修复 &lt;code&gt;b&lt;/code&gt; 在调用点，让签名应该不会被拒绝。此外，依赖项可能被隐藏。考虑</target>
        </trans-unit>
        <trans-unit id="be48930496202a998883fb4cafb1527204c88628" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Integer&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Integer&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="fd53ccf97b4fdfd6c001e2465d556a7f859dcf35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IsList&lt;/code&gt; class and its methods are intended to be used in conjunction with the &lt;code&gt;OverloadedLists&lt;/code&gt; extension.</source>
          <target state="translated">的 &lt;code&gt;IsList&lt;/code&gt; 类及其方法意在与所述结合使用 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展。</target>
        </trans-unit>
        <trans-unit id="8673f7079a0b5c433c928ec58cc5f380461b598a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class</source>
          <target state="translated">在 &lt;code&gt;Ix&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="ef3790360f91e6f1db9d6be90c644fd246da75d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ix&lt;/code&gt; class and operations</source>
          <target state="translated">在 &lt;code&gt;Ix&lt;/code&gt; 类和操作</target>
        </trans-unit>
        <trans-unit id="10c3ff8e25753aa68617bfab48822621de668249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Just Refl&lt;/code&gt; case in &lt;code&gt;step2&lt;/code&gt; is inaccessible, because in order for &lt;code&gt;checkTEQ&lt;/code&gt; to be able to produce a &lt;code&gt;Just&lt;/code&gt;, &lt;code&gt;t ~ u&lt;/code&gt; must hold, but since we&amp;rsquo;re passing &lt;code&gt;Foo1&lt;/code&gt; and &lt;code&gt;Foo2&lt;/code&gt; here, it follows that &lt;code&gt;t ~
Char&lt;/code&gt;, and &lt;code&gt;u ~ Int&lt;/code&gt;, and thus &lt;code&gt;t ~ u&lt;/code&gt; cannot hold.</source>
          <target state="translated">在 &lt;code&gt;Just Refl&lt;/code&gt; 情况下， &lt;code&gt;step2&lt;/code&gt; 是无法访问的，因为为了 &lt;code&gt;checkTEQ&lt;/code&gt; 能够产生 &lt;code&gt;Just&lt;/code&gt; ， &lt;code&gt;t ~ u&lt;/code&gt; 必须坚持，但因为我们传递 &lt;code&gt;Foo1&lt;/code&gt; 和 &lt;code&gt;Foo2&lt;/code&gt; 在这里，它遵循 &lt;code&gt;t ~ Char&lt;/code&gt; ，并且 &lt;code&gt;u ~ Int&lt;/code&gt; ，因此 &lt;code&gt;t ~ u&lt;/code&gt; 无法容纳。</target>
        </trans-unit>
        <trans-unit id="50553a5059a245db41faab2319d240eba523fc59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma allows language extensions to be enabled in a portable way. It is the intention that all Haskell compilers support the &lt;code&gt;LANGUAGE&lt;/code&gt; pragma with the same syntax, although not all extensions are supported by all compilers, of course. The &lt;code&gt;LANGUAGE&lt;/code&gt; pragma should be used instead of &lt;code&gt;OPTIONS_GHC&lt;/code&gt;, if possible.</source>
          <target state="translated">该 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译允许语言扩展到一个可移植的方式来实现。意图是所有Haskell编译器都以相同的语法支持 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译指示，尽管当然并非所有编译器都支持所有扩展。该 &lt;code&gt;LANGUAGE&lt;/code&gt; 编译应该用来代替 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; ，如果可能的话。</target>
        </trans-unit>
        <trans-unit id="9db793d0713d9096493ec702152818be66ee6bd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MArray&lt;/code&gt; class is parameterised over both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; (so that instances specialised to certain element types can be defined, in the same way as for &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt;), and also over the type of the monad, &lt;code&gt;m&lt;/code&gt;, in which the mutable array will be manipulated.</source>
          <target state="translated">所述 &lt;code&gt;MArray&lt;/code&gt; 类在两个参数化 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; （使得专用于某些元件类型的实例可以被定义，以同样的方式作为用于 &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:IArray&quot;&gt;IArray&lt;/a&gt;&lt;/code&gt; ），并且还通过单子的类型， &lt;code&gt;m&lt;/code&gt; ，其中，所述可变的阵列将是被操纵。</target>
        </trans-unit>
        <trans-unit id="d9cb8377e96ef4f0bbbfa46420220ebcc273c902" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma can be used to change which combination of methods will be required for instances of a particular class. See &lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;MINIMAL pragma&lt;/a&gt;.</source>
          <target state="translated">的 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示可用于该方法的组合将需要特定的类的实例的变化。参见&lt;a href=&quot;glasgow_exts#minimal-pragma&quot;&gt;最小用法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b804211dca7a6234cc53da8eb6f7ab49bdfebd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MINIMAL&lt;/code&gt; pragma is used to specify the minimal complete definition of a class, i.e. specify which methods must be implemented by all instances. If an instance does not satisfy the minimal complete definition, then a warning is generated. This can be useful when a class has methods with circular defaults. For example</source>
          <target state="translated">该 &lt;code&gt;MINIMAL&lt;/code&gt; 编译用于指定一个类的最小的完整定义，即指定哪些方法必须由所有实例来实现。如果实例不满足最小完整定义，则会生成警告。当类具有循环默认值的方法时，这将很有用。例如</target>
        </trans-unit>
        <trans-unit id="179c9366f2492e385b72cb143e85887902e0ab4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe Dec&lt;/code&gt; field contains &lt;code&gt;Just&lt;/code&gt; the declaration which defined the variable - including the RHS of the declaration - or else &lt;code&gt;Nothing&lt;/code&gt;, in the case where the RHS is unavailable to the compiler. At present, this value is &lt;em&gt;always&lt;/em&gt;&lt;code&gt;Nothing&lt;/code&gt;: returning the RHS has not yet been implemented because of lack of interest.</source>
          <target state="translated">该 &lt;code&gt;Maybe Dec&lt;/code&gt; 字段包含 &lt;code&gt;Just&lt;/code&gt; 其定义的变量的声明-包括声明的RHS -要不然 &lt;code&gt;Nothing&lt;/code&gt; ，在RHS不可用编译器的情况下。目前，此值&lt;em&gt;始终&lt;/em&gt; &lt;code&gt;Nothing&lt;/code&gt; ：由于缺乏兴趣，尚未执行返回RHS的操作。</target>
        </trans-unit>
        <trans-unit id="833a3a82dcaf236e1a22c42275a11a48d6dd026d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Maybe String&lt;/code&gt; argument allows to supply an optional time specification. E.g.:</source>
          <target state="translated">该 &lt;code&gt;Maybe String&lt;/code&gt; 参数允许提供一个可选的时间规范。例如：</target>
        </trans-unit>
        <trans-unit id="c4cf4ef2ad7be84020f5ab8d962e61d9c5230f48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ModSummary&lt;/code&gt; contains useful meta-information about the compiled module. The &lt;code&gt;HsParsedModule&lt;/code&gt; contains the lexical and syntactical information we mentioned before. The result that you return will change the result of the parsing. If you don&amp;rsquo;t want to change the result, just return the &lt;code&gt;HsParsedModule&lt;/code&gt; that you received as the argument.</source>
          <target state="translated">该 &lt;code&gt;ModSummary&lt;/code&gt; 包含有关编译的模块有用的元信息。该 &lt;code&gt;HsParsedModule&lt;/code&gt; 包含了我们之前提到的词汇和句法信息。您返回的结果将更改解析的结果。如果您不想更改结果，只需返回作为参数接收的 &lt;code&gt;HsParsedModule&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2f1b3a94e8148014127a4f07b1372b7725a7bda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Monad&lt;/code&gt; class has an &lt;code&gt;Applicative&lt;/code&gt; superclass. You cannot write &lt;code&gt;Monad&lt;/code&gt; instances that work for GHC and also for a Haskell 2010 implementation that does not define &lt;code&gt;Applicative&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Monad&lt;/code&gt; 类有一个 &lt;code&gt;Applicative&lt;/code&gt; 超。您不能编写适用于GHC的 &lt;code&gt;Monad&lt;/code&gt; 实例，也不能编写未定义 &lt;code&gt;Applicative&lt;/code&gt; 的Haskell 2010实现的实例。</target>
        </trans-unit>
        <trans-unit id="b9a442b1b9dc364891e0d9b2233f04de798d1ec7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOCLDSTOP&lt;/code&gt; flag</source>
          <target state="translated">该 &lt;code&gt;NOCLDSTOP&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="4dd6a67adca1f0f6b2e2bb5d6f4f6be090147329" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOINLINE&lt;/code&gt; pragma tells GHC not to inline &lt;code&gt;foo&lt;/code&gt; until Phase 0; and this property is inherited by the specialisation RULE, which will therefore only fire in Phase 0.</source>
          <target state="translated">该 &lt;code&gt;NOINLINE&lt;/code&gt; 编译告诉GHC不在线 &lt;code&gt;foo&lt;/code&gt; ，直到0期; 并且此属性由专门化规则继承，因此将仅在阶段0触发。</target>
        </trans-unit>
        <trans-unit id="41cd577171aa93daf4a59092425aec6f8da57085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOUNPACK&lt;/code&gt; pragma indicates to the compiler that it should not unpack the contents of a constructor field. Example:</source>
          <target state="translated">该 &lt;code&gt;NOUNPACK&lt;/code&gt; 编译指示编译器，它不应该解压构造字段的内容。例：</target>
        </trans-unit>
        <trans-unit id="02f6d5f3a66723750914b07b17b4152b831881eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Natural&lt;/code&gt; number type</source>
          <target state="translated">在 &lt;code&gt;Natural&lt;/code&gt; 数类型</target>
        </trans-unit>
        <trans-unit id="e90151e467bb879239604777d1625aec0d519783" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Num&lt;/code&gt; class does not have &lt;code&gt;Show&lt;/code&gt; or &lt;code&gt;Eq&lt;/code&gt; superclasses.</source>
          <target state="translated">在 &lt;code&gt;Num&lt;/code&gt; 类没有 &lt;code&gt;Show&lt;/code&gt; 或 &lt;code&gt;Eq&lt;/code&gt; 超。</target>
        </trans-unit>
        <trans-unit id="126dfab84b0966c6acff2a80c6f25e8566d4c2cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS_GHC&lt;/code&gt; pragma is used to specify additional options that are given to the compiler when compiling this source file. See &lt;a href=&quot;using#source-file-options&quot;&gt;Command line options in source files&lt;/a&gt; for details.</source>
          <target state="translated">该 &lt;code&gt;OPTIONS_GHC&lt;/code&gt; 编译用来指定编译这个源文件时给出编译器的附加选项。有关详细信息，请参见&lt;a href=&quot;using#source-file-options&quot;&gt;源文件中的命令行选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88a0fae3e171286c99c8569a8b07482329213991" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Plugin&lt;/code&gt; type has a field &lt;code&gt;tcPlugin&lt;/code&gt; of type &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt;, where the &lt;code&gt;TcPlugin&lt;/code&gt; type is defined thus:</source>
          <target state="translated">该 &lt;code&gt;Plugin&lt;/code&gt; 类型具有一个场 &lt;code&gt;tcPlugin&lt;/code&gt; 类型的 &lt;code&gt;[CommandLineOption] -&amp;gt; Maybe TcPlugin&lt;/code&gt; ，其中 &lt;code&gt;TcPlugin&lt;/code&gt; 类型这样定义：</target>
        </trans-unit>
        <trans-unit id="fffe76b7bf3798c24838442d37709754d1c21fba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PluginRecompile&lt;/code&gt; data type is an enumeration determining how the plugin should affect recompilation.</source>
          <target state="translated">所述 &lt;code&gt;PluginRecompile&lt;/code&gt; 数据类型是枚举确定所述插件应该如何影响重新编译。</target>
        </trans-unit>
        <trans-unit id="e585b3f2d187dee43075f1c6379003eb2f833f55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pointer&lt;/code&gt; field is not used when tag says that it&amp;rsquo;s &lt;code&gt;Nothing&lt;/code&gt;. Otherwise &lt;code&gt;Pointer&lt;/code&gt; points to the value in &lt;code&gt;Just&lt;/code&gt;. As mentioned above, this type is lazy in its lifted field. Therefore, the type</source>
          <target state="translated">该 &lt;code&gt;Pointer&lt;/code&gt; ，当标签说，这是不使用领域 &lt;code&gt;Nothing&lt;/code&gt; 。否则 &lt;code&gt;Pointer&lt;/code&gt; 指向 &lt;code&gt;Just&lt;/code&gt; 中的值。如上所述，这种类型在其提升领域是懒惰的。因此，类型</target>
        </trans-unit>
        <trans-unit id="eb221db19183a2bbc482de37382d307415cceaa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类</target>
        </trans-unit>
        <trans-unit id="c684523d6c7922654f7664f2f15207a387ba8fbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Read&lt;/code&gt; class has two extra methods, &lt;code&gt;readPrec&lt;/code&gt; and &lt;code&gt;readListPrec&lt;/code&gt;, that are not found in the Haskell 2010 since they rely on the &lt;code&gt;ReadPrec&lt;/code&gt; data type, which requires the &lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt;&lt;code&gt;-XRankNTypes&lt;/code&gt;&lt;/a&gt; extension. GHC also derives &lt;code&gt;Read&lt;/code&gt; instances by implementing &lt;code&gt;readPrec&lt;/code&gt; instead of &lt;code&gt;readsPrec&lt;/code&gt;, and relies on a default implementation of &lt;code&gt;readsPrec&lt;/code&gt; that is defined in terms of &lt;code&gt;readPrec&lt;/code&gt;. GHC adds these two extra methods simply because &lt;code&gt;ReadPrec&lt;/code&gt; is more efficient than &lt;code&gt;ReadS&lt;/code&gt; (the type on which &lt;code&gt;readsPrec&lt;/code&gt; is based).</source>
          <target state="translated">在 &lt;code&gt;Read&lt;/code&gt; 类有两个额外的方法， &lt;code&gt;readPrec&lt;/code&gt; 和 &lt;code&gt;readListPrec&lt;/code&gt; ，未在Haskell的2010中，因为它们依赖于 &lt;code&gt;ReadPrec&lt;/code&gt; 数据类型，这就需要&lt;a href=&quot;glasgow_exts#extension-RankNTypes&quot;&gt; &lt;code&gt;-XRankNTypes&lt;/code&gt; &lt;/a&gt;扩展。GHC也派生 &lt;code&gt;Read&lt;/code&gt; 通过实施实例 &lt;code&gt;readPrec&lt;/code&gt; 代替 &lt;code&gt;readsPrec&lt;/code&gt; ，并依靠的默认实现 &lt;code&gt;readsPrec&lt;/code&gt; 是在来定义 &lt;code&gt;readPrec&lt;/code&gt; 。GHC添加了这两个额外的方法，仅是因为 &lt;code&gt;ReadPrec&lt;/code&gt; 比 &lt;code&gt;ReadS&lt;/code&gt; （ &lt;code&gt;readsPrec&lt;/code&gt; 所基于的类型）更有效。</target>
        </trans-unit>
        <trans-unit id="f5a639306682ee2392defbfaca8a0612ce62725a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadP&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ReadP&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="55f87a9866a170596d8c12e14883de0375635cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reader&lt;/code&gt; monad (also called the Environment monad). Represents a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. Using &lt;code&gt;Reader&lt;/code&gt; monad for such computations is often clearer and easier than using the &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">该 &lt;code&gt;Reader&lt;/code&gt; 单子（也称为环境单子）。表示一种计算，该计算可以从共享环境中读取值，在函数之间传递值，以及在修改后的环境中执行子计算。与使用 &lt;code&gt;&lt;a href=&quot;control-monad-state#v:State&quot;&gt;State&lt;/a&gt;&lt;/code&gt; monad 相比，使用 &lt;code&gt;Reader&lt;/code&gt; monad进行这样的计算通常更容易。</target>
        </trans-unit>
        <trans-unit id="138e28c8c2a47ed6154d76f22441ec8c21841137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;R{..}&lt;/code&gt; expands to &lt;code&gt;R{a=a}&lt;/code&gt;, omitting &lt;code&gt;b&lt;/code&gt; since the record field is not in scope, and omitting &lt;code&gt;c&lt;/code&gt; since the variable &lt;code&gt;c&lt;/code&gt; is not in scope (apart from the binding of the record selector &lt;code&gt;c&lt;/code&gt;, of course).</source>
          <target state="translated">所述 &lt;code&gt;R{..}&lt;/code&gt; 扩展为 &lt;code&gt;R{a=a}&lt;/code&gt; ，省略 &lt;code&gt;b&lt;/code&gt; 由于记录字段不在范围内，并省略 &lt;code&gt;c&lt;/code&gt; 因为可变 &lt;code&gt;c&lt;/code&gt; 是在范围（除了记录选择的结合 &lt;code&gt;c&lt;/code&gt; ，当然）。</target>
        </trans-unit>
        <trans-unit id="c6082bbc59601d9a449fcc7ad9a4d5ed12a91d6c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SPARKS&lt;/code&gt; statistic refers to the use of &lt;code&gt;Control.Parallel.par&lt;/code&gt; and related functionality in the program. Each spark represents a call to &lt;code&gt;par&lt;/code&gt;; a spark is &amp;ldquo;converted&amp;rdquo; when it is executed in parallel; and a spark is &amp;ldquo;pruned&amp;rdquo; when it is found to be already evaluated and is discarded from the pool by the garbage collector. Any remaining sparks are discarded at the end of execution, so &amp;ldquo;converted&amp;rdquo; plus &amp;ldquo;pruned&amp;rdquo; does not necessarily add up to the total.</source>
          <target state="translated">该 &lt;code&gt;SPARKS&lt;/code&gt; 统计指的是使用的 &lt;code&gt;Control.Parallel.par&lt;/code&gt; 及相关功能的程序。每一个火花都代表了对 &lt;code&gt;par&lt;/code&gt; 的呼唤; 当火花并行执行时，火花被&amp;ldquo;转换&amp;rdquo;；当发现火花已经被评估并且被垃圾收集器从池中丢弃时，火花被&amp;ldquo;修剪&amp;rdquo;。在执行结束时，将丢弃所有剩余的火花，因此&amp;ldquo;转换&amp;rdquo;加上&amp;ldquo;修剪&amp;rdquo;并不一定总和。</target>
        </trans-unit>
        <trans-unit id="0739f5ccb2bb880c7aac97c76af83b628f8a3a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; Monad</source>
          <target state="translated">在 &lt;code&gt;ST&lt;/code&gt; 单子</target>
        </trans-unit>
        <trans-unit id="f614e141f7715f6c62aa646fdfcc09ca9d7280e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ST&lt;/code&gt; monad</source>
          <target state="translated">在 &lt;code&gt;ST&lt;/code&gt; 单子</target>
        </trans-unit>
        <trans-unit id="95776d621e6e94b966ba5059c98ab385d9187b77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Semigroup&lt;/code&gt; operator &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; will be in &lt;code&gt;Prelude&lt;/code&gt;, which clashes with custom local definitions of such an operator</source>
          <target state="translated">所述 &lt;code&gt;Semigroup&lt;/code&gt; 算子 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 将在 &lt;code&gt;Prelude&lt;/code&gt; ，其与这种操作者自定义局部定义相冲突</target>
        </trans-unit>
        <trans-unit id="8bd15c25ef057d5bb7b4b11090add4deb0ab7363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;ShortByteString&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="42f56d1b1cf13cb62004be77c95ea28a2e463b26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ShortByteString&lt;/code&gt; type and representation</source>
          <target state="translated">的 &lt;code&gt;ShortByteString&lt;/code&gt; 类型和表示</target>
        </trans-unit>
        <trans-unit id="9c01c63bcea3f47012ef7cb8b53521ef2f599690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SomeException&lt;/code&gt; type is the root of the exception type hierarchy. When an exception of type &lt;code&gt;e&lt;/code&gt; is thrown, behind the scenes it is encapsulated in a &lt;code&gt;SomeException&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;SomeException&lt;/code&gt; 类型是异常类型层级的根。当引发 &lt;code&gt;e&lt;/code&gt; 类型的异常时，它会在 &lt;code&gt;SomeException&lt;/code&gt; 封装在SomeException中。</target>
        </trans-unit>
        <trans-unit id="075869aa5abeccc3e82651f71cd0b49cf876a1ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StablePtr&lt;/code&gt; is freed by &lt;code&gt;hs_try_putmvar()&lt;/code&gt;. This is because it would otherwise be difficult to arrange to free the &lt;code&gt;StablePtr&lt;/code&gt; reliably: we can&amp;rsquo;t free it in Haskell, because if the &lt;code&gt;takeMVar&lt;/code&gt; is interrupted by an asynchronous exception, then the callback will fire at a later time. We can&amp;rsquo;t free it in C, because we don&amp;rsquo;t know when to free it (not when &lt;code&gt;hs_try_putmvar()&lt;/code&gt; returns, because that is an async call that uses the &lt;code&gt;StablePtr&lt;/code&gt; at some time in the future).</source>
          <target state="translated">该 &lt;code&gt;StablePtr&lt;/code&gt; 通过释放 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 。这是因为否则很难可靠地释放 &lt;code&gt;StablePtr&lt;/code&gt; ：我们无法在Haskell中释放它，因为如果 &lt;code&gt;takeMVar&lt;/code&gt; 被异步异常中断，则回调将在以后触发。我们无法在C中释放它，因为我们不知道何时释放它（不是 &lt;code&gt;hs_try_putmvar()&lt;/code&gt; 返回时，因为这是一个异步调用， &lt;code&gt;StablePtr&lt;/code&gt; 在将来的某个时间使用StablePtr）。</target>
        </trans-unit>
        <trans-unit id="22a2fd434898f0f6555b4c40eb04ba5061f4dac5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;String&lt;/code&gt; type and associated operations.</source>
          <target state="translated">该 &lt;code&gt;String&lt;/code&gt; 类型和相关的操作。</target>
        </trans-unit>
        <trans-unit id="063a241ae6b100332789afebed90ca2f9db07517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Traversable&lt;/code&gt; class</source>
          <target state="translated">该 &lt;code&gt;Traversable&lt;/code&gt; 的类</target>
        </trans-unit>
        <trans-unit id="f3eb004bc8ea181740ab9d964eca4039846cba0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tree&lt;/code&gt; datatype has two constructors. The representation of individual constructors is combined using the binary type constructor &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Tree&lt;/code&gt; 的数据类型有两个构造。使用二进制类型的构造函数 &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; 组合各个构造函数的表示形式。</target>
        </trans-unit>
        <trans-unit id="ea0e01ff4b10acd1f300e041e7c7d24452a6bcef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Type&lt;/code&gt; 字段包含作为变量基础的类型。目前，它始终是 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; ，但是将来的更改可能允许对此进行改进。</target>
        </trans-unit>
        <trans-unit id="a1c62302915451aa80bfd9fc2cff479b2cf284ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Type&lt;/code&gt; field contains the type which underlies the variable. At present, this is always &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt;, but future changes may permit refinement of this.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Type&lt;/code&gt; 字段包含作为变量基础的类型。目前，它始终是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:VarT&quot;&gt;VarT&lt;/a&gt; theName&lt;/code&gt; ，但是将来的更改可能允许对此进行改进。</target>
        </trans-unit>
        <trans-unit id="027d2a06d103d553d051280a74cf3845d60d411a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UNPACK&lt;/code&gt; indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:</source>
          <target state="translated">该 &lt;code&gt;UNPACK&lt;/code&gt; 指示编译器，它应该解压构造域的内容到构造本身，消除了一个间接层。例如：</target>
        </trans-unit>
        <trans-unit id="33782bed5c646b932004c73abe54633b85489d8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Version&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Version&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="5c935ef40843fda690b92bec23a2da13f0596d70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WARNING&lt;/code&gt; pragma allows you to attach an arbitrary warning to a particular function, class, or type.</source>
          <target state="translated">使用&amp;ldquo; &lt;code&gt;WARNING&lt;/code&gt; 编译指示可以将任意警告附加到特定的函数，类或类型。</target>
        </trans-unit>
        <trans-unit id="4b5cfd9e9013fd4cb9b04f939f4f7787609c1e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Weak&lt;/code&gt; type</source>
          <target state="translated">该 &lt;code&gt;Weak&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="f5d131550d29246afe295414037eda39ef3a4a79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[2]&lt;/code&gt; means that the rule is active in Phase 2 and subsequent phases. The inverse notation &lt;code&gt;[~2]&lt;/code&gt; is also accepted, meaning that the rule is active up to, but not including, Phase 2.</source>
          <target state="translated">在 &lt;code&gt;[2]&lt;/code&gt; 的装置，该规则是在第2阶段和后续阶段的活性。逆符号 &lt;code&gt;[~2]&lt;/code&gt; 也被接受，表示规则在阶段2之前（但不包括阶段2）一直有效。</target>
        </trans-unit>
        <trans-unit id="e762931e5ccd90930535b3ca5e55c6d8c0924233" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binary&lt;/code&gt; package is notable in that it provides both pure, and high performance serialisation.</source>
          <target state="translated">的 &lt;code&gt;binary&lt;/code&gt; 包是显着的，因为它提供两个纯的，并且高性能串行化。</target>
        </trans-unit>
        <trans-unit id="4bd1285d74cbd2d2cbc3ca0932f6094c43b630ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buildExpressionParser&lt;/code&gt; takes care of all the complexity involved in building expression parser. Here is an example of an expression parser that handles prefix signs, postfix increment and basic arithmetic.</source>
          <target state="translated">该 &lt;code&gt;buildExpressionParser&lt;/code&gt; 需要的所有参与建设的表达式解析器的复杂性照顾。这是处理前缀符号，后缀增量和基本算术的表达式解析器的示例。</target>
        </trans-unit>
        <trans-unit id="9dc6c10898dec30b4e5dd6a9520ac4b310a891ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; functions</source>
          <target state="translated">在 &lt;code&gt;catch&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="ce3c62da909521366f0612be95d0d5abc18fd5df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cr&lt;/code&gt; capability, which moves the cursor to the first column of the current line.</source>
          <target state="translated">的 &lt;code&gt;cr&lt;/code&gt; 能力，这将光标移动到当前行的第一列中。</target>
        </trans-unit>
        <trans-unit id="41cac9a191aeb661ca1ba5373f54957c5ae0927f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deriving( Sizable )&lt;/code&gt; is equivalent to saying</source>
          <target state="translated">该 &lt;code&gt;deriving( Sizable )&lt;/code&gt; 相当于说</target>
        </trans-unit>
        <trans-unit id="aecea50617c919f429665961c30499dbecafe248" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; function translates elements of the buffer &lt;code&gt;from&lt;/code&gt; to the buffer &lt;code&gt;to&lt;/code&gt;. It should translate as many elements as possible given the sizes of the buffers, including translating zero elements if there is either not enough room in &lt;code&gt;to&lt;/code&gt;, or &lt;code&gt;from&lt;/code&gt; does not contain a complete multibyte sequence.</source>
          <target state="translated">所述 &lt;code&gt;encode&lt;/code&gt; 函数转换缓冲器的元件 &lt;code&gt;from&lt;/code&gt; 所述缓冲器 &lt;code&gt;to&lt;/code&gt; 。应该翻译为许多元素尽可能给出的缓冲区的大小，包括翻译零个元素，如果有或者没有足够的空间 &lt;code&gt;to&lt;/code&gt; ，或 &lt;code&gt;from&lt;/code&gt; 不包含一个完整的多字节序列。</target>
        </trans-unit>
        <trans-unit id="0a5aa4a69bcc42b7c89b78bde09cb33ccb0cfca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enumFrom&lt;/code&gt;... methods are used in Haskell's translation of arithmetic sequences.</source>
          <target state="translated">该 &lt;code&gt;enumFrom&lt;/code&gt; ...方法在Haskell的等差数列的翻译使用。</target>
        </trans-unit>
        <trans-unit id="ade300f4a813bcee47f07faaadabe78ba37c7979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; function from the Prelude supports printing the call stack that led to the error in addition to the usual error message:</source>
          <target state="translated">除通常的错误消息外，Prelude中的 &lt;code&gt;error&lt;/code&gt; 功能还支持打印导致错误的调用堆栈：</target>
        </trans-unit>
        <trans-unit id="511af374fd1b5b479579f0c30542d54251504918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;evaluate&lt;/code&gt; function</source>
          <target state="translated">该 &lt;code&gt;evaluate&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="597cda7e7f16a0e50cd5f0c4f0416902f5c0363f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromInteger&lt;/code&gt; (and hence also &lt;code&gt;fromIntegral&lt;/code&gt;) is a special case when converting to &lt;code&gt;Int&lt;/code&gt;. The value of &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; is given by taking the lower ⟨n⟩ bits of &lt;code&gt;(abs x)&lt;/code&gt;, multiplied by the sign of &lt;code&gt;x&lt;/code&gt; (in 2&amp;rsquo;s complement ⟨n⟩-bit arithmetic). This behaviour was chosen so that for example writing &lt;code&gt;0xffffffff :: Int&lt;/code&gt; preserves the bit-pattern in the resulting &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">当转换为 &lt;code&gt;Int&lt;/code&gt; 时， &lt;code&gt;fromInteger&lt;/code&gt; （因此也来自 &lt;code&gt;fromIntegral&lt;/code&gt; ）是一种特殊情况。 &lt;code&gt;fromIntegral x :: Int&lt;/code&gt; 的值是通过取 &lt;code&gt;(abs x)&lt;/code&gt; 的低⟨n⟩位乘以 &lt;code&gt;x&lt;/code&gt; 的符号（在2的补码⟨n⟩位算术中）得出的。选择此行为的原因是，例如，写入 &lt;code&gt;0xffffffff :: Int&lt;/code&gt; 保留结果 &lt;code&gt;Int&lt;/code&gt; 中的位模式。</target>
        </trans-unit>
        <trans-unit id="ef0f4a35a1f6d1c258b22e6d87df758fac232791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromIntegral&lt;/code&gt; function also preserves bit-patterns when converting between the sized integral types (&lt;code&gt;Int8&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt; and the unsigned &lt;code&gt;Word&lt;/code&gt; variants), see the modules &lt;code&gt;Data.Int&lt;/code&gt; and &lt;code&gt;Data.Word&lt;/code&gt; in the library documentation.</source>
          <target state="translated">当在大小较大的整数类型（ &lt;code&gt;Int8&lt;/code&gt; ， &lt;code&gt;Int16&lt;/code&gt; ， &lt;code&gt;Int32&lt;/code&gt; ， &lt;code&gt;Int64&lt;/code&gt; 和无符号 &lt;code&gt;Word&lt;/code&gt; 变体）之间进行转换时， &lt;code&gt;fromIntegral&lt;/code&gt; 函数还保留位模式，请参见库文档中的 &lt;code&gt;Data.Int&lt;/code&gt; 和 &lt;code&gt;Data.Word&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="762b16a36e554904d87f2db331ab1542095ebd78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc-pkg&lt;/code&gt; program may be run in the ways listed below. Where a package name is required, the package can be named in full including the version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;), or without the version number. Naming a package without the version number matches all versions of the package; the specified action will be applied to all the matching packages. A package specifier that matches all version of the package can also be written &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt;, to make it clearer that multiple packages are being matched. To match against the installed package ID instead of just package name and version, pass the &lt;code&gt;--ipid&lt;/code&gt; flag.</source>
          <target state="translated">该 &lt;code&gt;ghc-pkg&lt;/code&gt; 程序可以在下面列出的方式运行。在需要软件包名称的情况下，可以使用包含版本号（例如 &lt;code&gt;network-1.0&lt;/code&gt; ）的完整名称，也可以不使用版本号。命名没有版本号的软件包会匹配该软件包的所有版本。指定的操作将应用于所有匹配的软件包。也可以将与所有版本的软件包都匹配的软件包说明符写为 &lt;code&gt;⟨pkg⟩ -*&lt;/code&gt; ，以使多个软件包可以被更清楚地匹配。要与已安装的软件包ID匹配，而不仅仅是软件包名称和版本，请传递 &lt;code&gt;--ipid&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="70e170de84746b93a247accd0e8bc402d6a2ea08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghc&lt;/code&gt; package exposes most of GHC&amp;rsquo;s frontend to users, and thus allows you to write programs that leverage it. This library is actually the same library used by GHC&amp;rsquo;s internal, frontend compilation driver, and thus allows you to write tools that programmatically compile source code and inspect it. Such functionality is useful in order to write things like IDE or refactoring tools. As a simple example, here&amp;rsquo;s a program which compiles a module, much like ghc itself does by default when invoked:</source>
          <target state="translated">该 &lt;code&gt;ghc&lt;/code&gt; 包自曝GHC的前端的最给用户，从而允许你写的程序，充分利用它。该库实际上与GHC的内部前端编译驱动程序使用的库相同，因此，您可以编写以编程方式编译源代码并对其进行检查的工具。为了编写诸如IDE或重构工具之类的东西，此类功能很有用。举一个简单的例子，这是一个编译模块的程序，就像ghc本身在调用时默认情况下一样：</target>
        </trans-unit>
        <trans-unit id="e102bed194230593a0e69925d95b61dfc6e1bb63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ghci.conf&lt;/code&gt; file is most useful for turning on favourite options (e.g. &lt;code&gt;:set +s&lt;/code&gt;), and defining useful macros.</source>
          <target state="translated">该 &lt;code&gt;ghci.conf&lt;/code&gt; 文件是打开的首选项（例如，最有用的 &lt;code&gt;:set +s&lt;/code&gt; ），并定义有用的宏。</target>
        </trans-unit>
        <trans-unit id="2d742d7f4cd29eb0f301c0d47b2cc254469da39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle&lt;/code&gt; functions</source>
          <target state="translated">该 &lt;code&gt;handle&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="34d765516635c10fcdf110fa543c8ace7e8ff1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hi-boot&lt;/code&gt; generated by compiling a &lt;code&gt;hs-boot&lt;/code&gt; file is in the same machine-generated binary format as any other GHC-generated interface file (e.g. &lt;code&gt;B.hi&lt;/code&gt;). You can display its contents with &lt;code&gt;ghc --show-iface&lt;/code&gt;. If you specify a directory for interface files, the &lt;code&gt;-ohidir&lt;/code&gt; flag, then that affects &lt;code&gt;hi-boot&lt;/code&gt; files too.</source>
          <target state="translated">通过编译 &lt;code&gt;hs-boot&lt;/code&gt; 文件生成的 &lt;code&gt;hi-boot&lt;/code&gt; 与任何其他GHC生成的接口文件（例如 &lt;code&gt;B.hi&lt;/code&gt; ）具有相同的机器生成的二进制格式。您可以使用 &lt;code&gt;ghc --show-iface&lt;/code&gt; 显示其内容。如果为接口文件指定目录，则使用 &lt;code&gt;-ohidir&lt;/code&gt; 标志，这也会影响 &lt;code&gt;hi-boot&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="355d829a4b676f5ca653b94b80c9807cda2a9d2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hsc2hs&lt;/code&gt; command can be used to automate some parts of the process of writing Haskell bindings to C code. It reads an almost-Haskell source with embedded special constructs, and outputs a real Haskell file with these constructs processed, based on information taken from some C headers. The extra constructs deal with accessing C data from Haskell.</source>
          <target state="translated">该 &lt;code&gt;hsc2hs&lt;/code&gt; 命令可以被用来自动编写的Haskell绑定到C代码的过程的某些部分。它读取具有嵌入式特殊结构的几乎Haskell的源，并基于从某些C头获取的信息，输出处理了这些结构的真实Haskell文件。额外的构造处理从Haskell访问C数据。</target>
        </trans-unit>
        <trans-unit id="e2823e69f2a65d7ce80b8fd7a101d62eed4e1c66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i2d&lt;/code&gt; function is virtually one machine instruction; the default conversion&amp;mdash;via an intermediate &lt;code&gt;Rational&lt;/code&gt;-is obscenely expensive by comparison.</source>
          <target state="translated">的 &lt;code&gt;i2d&lt;/code&gt; 功能实际上是一个机器指令; 相比之下，通过中间 &lt;code&gt;Rational&lt;/code&gt; 进行默认转换的成本非常高。</target>
        </trans-unit>
        <trans-unit id="7c8dc7d7a696a83968e6e8dd5a58a6b1ef2a23b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of a cost-centre listed in the &lt;code&gt;cost_centres&lt;/code&gt; list.</source>
          <target state="translated">该 &lt;code&gt;id&lt;/code&gt; 在上市成本中心的 &lt;code&gt;cost_centres&lt;/code&gt; 名单。</target>
        </trans-unit>
        <trans-unit id="0f33c5545ef78687d7ec80abf9761102bfc37c4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import A hiding( g )&lt;/code&gt; in module &lt;code&gt;B&lt;/code&gt; is technically an error (&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report, 5.3.1&lt;/a&gt;) because &lt;code&gt;A&lt;/code&gt; does not export &lt;code&gt;g&lt;/code&gt;. However GHC allows it, in the interests of supporting backward compatibility; for example, a newer version of &lt;code&gt;A&lt;/code&gt; might export &lt;code&gt;g&lt;/code&gt;, and you want &lt;code&gt;B&lt;/code&gt; to work in either case.</source>
          <target state="translated">从技术上讲，模块 &lt;code&gt;B&lt;/code&gt; 中的 &lt;code&gt;import A hiding( g )&lt;/code&gt; 是一个错误（&lt;a href=&quot;http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1020005.3.1&quot;&gt;Haskell Report，5.3.1&lt;/a&gt;），因为 &lt;code&gt;A&lt;/code&gt; 不导出 &lt;code&gt;g&lt;/code&gt; 。但是，GHC允许这样做，以支持向后兼容；例如，较新版本的 &lt;code&gt;A&lt;/code&gt; 可能会导出 &lt;code&gt;g&lt;/code&gt; ，并且您希望 &lt;code&gt;B&lt;/code&gt; 在两种情况下均能正常工作。</target>
        </trans-unit>
        <trans-unit id="9f41076a0857a53fdc32d3736b60eb827f4f251e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; declaration (&lt;a href=&quot;#ghci-import-decl&quot;&gt;Controlling what is in scope with import&lt;/a&gt;).</source>
          <target state="translated">在 &lt;code&gt;import&lt;/code&gt; 报关（&lt;a href=&quot;#ghci-import-decl&quot;&gt;控制的是与进口范围&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5ad2ceafe50f168640b42ddfd5b779521b31a687" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;instance&lt;/code&gt; keyword is optional.</source>
          <target state="translated">该 &lt;code&gt;instance&lt;/code&gt; 关键字是可选的。</target>
        </trans-unit>
        <trans-unit id="6290f04db0b506c583506333aeba21e56f7af2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lazyIOExample&lt;/code&gt; uses lazy I/O to read the file from the disk, which is not suitable in all applications, and certainly not if you need to read from a socket which has higher likelihood to fail. To address these needs, use the incremental input method like in &lt;code&gt;incrementalExample&lt;/code&gt;. For an example of how to read incrementally from a Handle, see the implementation of &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;lazyIOExample&lt;/code&gt; 使用懒惰的I / O，以从磁盘读取，它不适合所有应用程序中的文件，当然不是，如果你需要从具有较高可能性不能套接字阅读。为了满足这些需求，请使用增量输入方法（如 &lt;code&gt;incrementalExample&lt;/code&gt; )。有关如何从Handle中进行增量读取的示例，请参见 &lt;code&gt;&lt;a href=&quot;data-binary#v:decodeFileOrFail&quot;&gt;decodeFileOrFail&lt;/a&gt;&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="2176a754f25110a9917a6219e63404e3208eea44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapException&lt;/code&gt; function</source>
          <target state="translated">该 &lt;code&gt;mapException&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="c837f409d9c890ff0cf84a0f23501c248975f873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask_&lt;/code&gt; is to avoid asynchronous exceptions before the &lt;code&gt;scheduleCallback&lt;/code&gt; call, which would leak the &lt;code&gt;StablePtr&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;mask_&lt;/code&gt; 是为了避免之前异步异常 &lt;code&gt;scheduleCallback&lt;/code&gt; 通话，这将泄漏 &lt;code&gt;StablePtr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88156e7be9a84c3b32b21ca9033fb9b40a86fc7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mdo&lt;/code&gt; notation removes the burden of placing explicit &lt;code&gt;rec&lt;/code&gt; blocks in the code. Unlike an ordinary &lt;code&gt;do&lt;/code&gt; expression, in which variables bound by statements are only in scope for later statements, variables bound in an &lt;code&gt;mdo&lt;/code&gt; expression are in scope for all statements of the expression. The compiler then automatically identifies minimal mutually recursively dependent segments of statements, treating them as if the user had wrapped a &lt;code&gt;rec&lt;/code&gt; qualifier around them.</source>
          <target state="translated">该 &lt;code&gt;mdo&lt;/code&gt; 符号删除将明确的负担 &lt;code&gt;rec&lt;/code&gt; 模块中的代码。与普通的 &lt;code&gt;do&lt;/code&gt; 表达式不同，在普通的do表达式中，语句绑定的变量仅在以后的语句的范围内，而 &lt;code&gt;mdo&lt;/code&gt; 表达式中绑定的变量在该表达式的所有语句的范围内。然后，编译器自动识别最小的相互递归相关的语句段，将它们视为用户已将 &lt;code&gt;rec&lt;/code&gt; 限定符环绕在它们周围。</target>
        </trans-unit>
        <trans-unit id="f6a07857e87c25a69a2a85f3c6940b5d3da66364" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;needle&lt;/code&gt; parameter may not be empty.</source>
          <target state="translated">机 &lt;code&gt;needle&lt;/code&gt; 参数不能为空。</target>
        </trans-unit>
        <trans-unit id="03da503ca798d541eacd37351134d51c710473a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nel&lt;/code&gt; capability, which moves the cursor to the first column of the next line. It behaves like a carriage return followed by a line feed.</source>
          <target state="translated">的 &lt;code&gt;nel&lt;/code&gt; 能力，这将光标移动到下一行的第一列中。它的行为就像回车符，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="41854e5bb2dcfb535a78b10a713fbfca69450478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubIntOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype. For example, &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; can be used to nub characters and typical fixed-with numerical types efficiently.</source>
          <target state="translated">所述 &lt;code&gt;nubIntOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。例如， &lt;code&gt;nubIntOn &lt;a href=&quot;../base-4.13.0.0/prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 可用于有效地对字符和典型的固定数字类型进行小数处理。</target>
        </trans-unit>
        <trans-unit id="d601cddbbd9d7126bc0e97c81bf6fdd7871c9080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nubOrdOn&lt;/code&gt; function behaves just like &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; except it performs comparisons not on the original datatype, but a user-specified projection from that datatype.</source>
          <target state="translated">所述 &lt;code&gt;nubOrdOn&lt;/code&gt; 函数的行为就像 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubOrd&quot;&gt;nubOrd&lt;/a&gt;&lt;/code&gt; 除了它不执行对原始数据类型比较，但从数据类型的用户指定的投影。</target>
        </trans-unit>
        <trans-unit id="d367aba8a4bc7af80523df0833dbadc25b08592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87db766c3fcfe957880bc536c8055be89a67ca05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3d76aa425b2c86fc5220b26c112435a53e249f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-intmap-strict-internal#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe60eae85d88c9490c48aade82bc12d2974b6022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-lazy#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapMaybeWithKey&quot;&gt;mapMaybeWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48239e0c803c6ef0e5cd08862ca58810b64b5781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; methods &lt;em&gt;must return a map with a subset (possibly empty) of the keys of the given map&lt;/em&gt;. The values can be modified arbitrarily. Most common variants of &lt;code&gt;only1&lt;/code&gt; and &lt;code&gt;only2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt;, but for example &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; could be used for any &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 方法&lt;em&gt;必须返回一个地图的特定地图的键的子集（可能为空）&lt;/em&gt;。这些值可以任意修改。最常见的变种 &lt;code&gt;only1&lt;/code&gt; 和 &lt;code&gt;only2&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-map-strict#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; ，但例如 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:map&quot;&gt;map&lt;/a&gt; f&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:filterWithKey&quot;&gt;filterWithKey&lt;/a&gt; f&lt;/code&gt; 可用于任何 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46099596c66e9f01cbd3f7bcc5b5f08680659ccd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat_lhs&lt;/code&gt; for explicitly bidirectional construction cannot use Record syntax. (Because the rhs &lt;em&gt;expr&lt;/em&gt; might be constructing different data constructors.) It can use guards with multiple equations.</source>
          <target state="translated">用于显式双向构造的 &lt;code&gt;pat_lhs&lt;/code&gt; 不能使用Record语法。（因为rhs &lt;em&gt;expr&lt;/em&gt;可能构造了不同的数据构造函数。）它可以使用带有多个方程式的守卫。</target>
        </trans-unit>
        <trans-unit id="c77daba6d5e5a119d170e42d9dd4a10538222183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qq&lt;/code&gt; quasiquoter would be able to see the definition of &lt;code&gt;f&lt;/code&gt; from the preceding declaration group, but not the definitions of &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;k&lt;/code&gt;, or any definitions from subsequent declaration groups.</source>
          <target state="translated">该 &lt;code&gt;qq&lt;/code&gt; quasiquoter将能够看到的定义 &lt;code&gt;f&lt;/code&gt; 从前面的声明组，但不定义 &lt;code&gt;h&lt;/code&gt; 或 &lt;code&gt;k&lt;/code&gt; ，或从随后的宣言基团的任何定义。</target>
        </trans-unit>
        <trans-unit id="c466f28061a085d0fe280fa263ce6f774fe3c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recover&lt;/code&gt; function is used to continue decoding in the presence of invalid or unrepresentable sequences. This includes both those detected by &lt;code&gt;encode&lt;/code&gt; returning &lt;code&gt;InvalidSequence&lt;/code&gt; and those that occur because the input byte sequence appears to be truncated.</source>
          <target state="translated">的 &lt;code&gt;recover&lt;/code&gt; 功能被用于继续无效或不可表示的序列的存在进行解码。这既包括通过 &lt;code&gt;encode&lt;/code&gt; 返回 &lt;code&gt;InvalidSequence&lt;/code&gt; 所检测到的那些，也包括由于输入字节序列似乎被截断而发生的那些。</target>
        </trans-unit>
        <trans-unit id="a473a7ced8aa63a52d8a8ae70bef9c494ad7a2e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; function simply creates a continuation which passes the value on.</source>
          <target state="translated">该 &lt;code&gt;return&lt;/code&gt; 功能只需创建一个其传递的价值延续。</target>
        </trans-unit>
        <trans-unit id="81379fa1503519747e0a096e84f164e14f442525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;runghc&lt;/code&gt; command-line looks like:</source>
          <target state="translated">该 &lt;code&gt;runghc&lt;/code&gt; 命令行的样子：</target>
        </trans-unit>
        <trans-unit id="aa8f29d0aba7b46039df62fe50f4c7d9ad9965c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">该 &lt;code&gt;shows&lt;/code&gt; 功能返回预先将输出的函数 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到现有的 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。这允许使用函数组合进行时间常数的级联。</target>
        </trans-unit>
        <trans-unit id="2bfd895a0337bb9829478985b48c54b24e2e9ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shows&lt;/code&gt; functions return a function that prepends the output &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an existing &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. This allows constant-time concatenation of results using function composition.</source>
          <target state="translated">该 &lt;code&gt;shows&lt;/code&gt; 功能返回预先将输出的函数 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到现有的 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。这允许使用函数组合进行时间常数的级联。</target>
        </trans-unit>
        <trans-unit id="8762c6cbedea04c42d6cbeebccb6250ad93ea53a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sprint&lt;/code&gt; function adds an exclamation mark at the end of any printed value. Running GHCi with the command:</source>
          <target state="translated">的 &lt;code&gt;sprint&lt;/code&gt; 功能在任何印刷值的末尾添加一个感叹号。使用以下命令运行GHCi：</target>
        </trans-unit>
        <trans-unit id="b8ab09f95cb11cc6d3321f577cbb4de51fef8004" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state hack&lt;/code&gt; optimization can result in non-obvious changes in evaluation ordering which may hide exceptions, even with &lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt;&lt;code&gt;-fpedantic-bottoms&lt;/code&gt;&lt;/a&gt; (see, e.g., &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;Issue #7411&lt;/a&gt;). For instance,</source>
          <target state="translated">该 &lt;code&gt;state hack&lt;/code&gt; 优化可以导致评价排序不明显的变化，这可能隐藏例外，甚至&lt;a href=&quot;using-optimisation#ghc-flag--fpedantic-bottoms&quot;&gt; &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; &lt;/a&gt;（见，例如，&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/7411&quot;&gt;发出＃7411&lt;/a&gt;）。例如，</target>
        </trans-unit>
        <trans-unit id="3fc26580a12c7237de8bc3feeef150e25e82b7eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;template-haskell&lt;/code&gt; library provides &lt;code&gt;Lift&lt;/code&gt; instances for many common data types. Furthermore, it is possible to derive &lt;code&gt;Lift&lt;/code&gt; instances automatically by using the &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt; language extension. See &lt;a href=&quot;#deriving-lift&quot;&gt;Deriving Lift instances&lt;/a&gt; for more information.</source>
          <target state="translated">该 &lt;code&gt;template-haskell&lt;/code&gt; 库提供 &lt;code&gt;Lift&lt;/code&gt; 情况下，对许多常见的数据类型。此外，可以使用&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;语言扩展自动导出 &lt;code&gt;Lift&lt;/code&gt; 实例。有关更多信息，请参见&lt;a href=&quot;#deriving-lift&quot;&gt;派生Lift实例&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adbf9d076f18bc800a1c0458fc70e137b98ee09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; combinator can for example be used to distinguish identifiers and reserved words. Both reserved words and identifiers are a sequence of letters. Whenever we expect a certain reserved word where we can also expect an identifier we have to use the &lt;code&gt;try&lt;/code&gt; combinator. Suppose we write:</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 组合子可以例如用于区分标识符和保留字。保留字和标识符都是字母序列。每当我们期望某个保留字，也希望标识符的时候，我们都必须使用 &lt;code&gt;try&lt;/code&gt; 组合器。假设我们写：</target>
        </trans-unit>
        <trans-unit id="d03c88b23debcedbc11667e18141e6115f243880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; functions</source>
          <target state="translated">该 &lt;code&gt;try&lt;/code&gt; 功能</target>
        </trans-unit>
        <trans-unit id="9192255b8c683615d80a4ee64628e5e043860b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type role&lt;/code&gt; (enabled with &lt;a href=&quot;#extension-RoleAnnotations&quot;&gt;&lt;code&gt;RoleAnnotations&lt;/code&gt;&lt;/a&gt;) declaration forces the parameter &lt;code&gt;a&lt;/code&gt; to be at role representational, not role phantom. GHC then checks the user-supplied roles to make sure they don&amp;rsquo;t break any promises. It would be bad, for example, if the user could make &lt;code&gt;BadIdea&lt;/code&gt;&amp;lsquo;s role be representational.</source>
          <target state="translated">该 &lt;code&gt;type role&lt;/code&gt; （启用&lt;a href=&quot;#extension-RoleAnnotations&quot;&gt; &lt;code&gt;RoleAnnotations&lt;/code&gt; &lt;/a&gt;）申报力参数 &lt;code&gt;a&lt;/code&gt; 是在角色的代表性，而不是角色幻象。然后，GHC会检查用户提供的角色，以确保它们不会违反任何承诺。例如，如果用户可以使 &lt;code&gt;BadIdea&lt;/code&gt; 的角色具有代表性，那将是不好的。</target>
        </trans-unit>
        <trans-unit id="b020a7d468bfda2ff2309461d916b84feeabc338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma is used only in &lt;code&gt;import&lt;/code&gt; declarations, to break a module loop. It is described in detail in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 编译只用在 &lt;code&gt;import&lt;/code&gt; 报关，打破模块循环。&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中&lt;/a&gt;对此进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="0ee4634b8912c617cc4c956549ecbf5f2fbc8ae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;global package database&lt;/em&gt;, which comes with your GHC installation, e.g. &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt;.</source>
          <target state="translated">GHC安装随附的&lt;em&gt;全局软件包数据库&lt;/em&gt;，例如 &lt;code&gt;/usr/lib/ghc-6.12.1/package.conf.d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a81be10d439420dbf2ec989064392ad08ec7838" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interactive options&lt;/em&gt; apply when evaluating expressions and commands typed at the GHCi prompt.</source>
          <target state="translated">该&lt;em&gt;交互选项&lt;/em&gt;评估在GHCI提示符下输入表达式和命令时适用。</target>
        </trans-unit>
        <trans-unit id="7491cf46ec5e1fbb15f8b7eb9e41d24a24f00f6a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;k&lt;/em&gt;th match, followed by the remainder of the string</source>
          <target state="translated">第&lt;em&gt;k&lt;/em&gt;个匹配项，后跟字符串的其余部分</target>
        </trans-unit>
        <trans-unit id="bc4c2343b61995f2f1a5ec7cbe01528dd89e1ed3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loading options&lt;/em&gt; apply when loading modules</source>
          <target state="translated">该&lt;em&gt;加载选项&lt;/em&gt;加载模块时适用</target>
        </trans-unit>
        <trans-unit id="80049228c8301318bfcd4d99de0d8c4f642d80d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user package database&lt;/em&gt; private to each user. On Unix systems this will be &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt;, and on Windows it will be something like &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt;. The &lt;code&gt;ghc-pkg&lt;/code&gt; tool knows where this file should be located, and will create it if it doesn&amp;rsquo;t exist (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;).</source>
          <target state="translated">每个用户专用的&lt;em&gt;用户软件包数据库&lt;/em&gt;。在Unix系统上，这将是 &lt;code&gt;$HOME/.ghc/arch-os-version/package.conf.d&lt;/code&gt; ，而在Windows上，它将是 &lt;code&gt;C:\Documents&amp;nbsp;And&amp;nbsp;Settings\user\ghc\package.conf.d&lt;/code&gt; 。该 &lt;code&gt;ghc-pkg&lt;/code&gt; 工具知道在哪里这个文件应该被定位，如果不存在，将创建它（请参阅&lt;a href=&quot;#package-management&quot;&gt;包管理（GHC的-PKG命令）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="06291563b1a287d734cf4e445906b8935befc784" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;ghc-pkg&lt;/strong&gt; tool is for querying and modifying package databases. To see what package databases are in use, use &lt;code&gt;ghc-pkg list&lt;/code&gt;. The stack of databases that &lt;strong&gt;ghc-pkg&lt;/strong&gt; knows about can be modified using the &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; environment variable (see &lt;a href=&quot;#ghc-package-path&quot;&gt;The GHC_PACKAGE_PATH environment variable&lt;/a&gt;, and using &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; options on the &lt;strong&gt;ghc-pkg&lt;/strong&gt; command line.</source>
          <target state="translated">的&lt;strong&gt;GHC-PKG&lt;/strong&gt;工具是用于查询和修改包数据库。要查看正在使用的软件包数据库，请使用 &lt;code&gt;ghc-pkg list&lt;/code&gt; 。可以使用&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt;环境变量来修改&lt;strong&gt;ghc-pkg&lt;/strong&gt;知道的数据库堆栈（请参阅&lt;a href=&quot;#ghc-package-path&quot;&gt;GHC_PACKAGE_PATH环境变量&lt;/a&gt;，并在&lt;strong&gt;ghc-pkg&lt;/strong&gt;命令行上使用&lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt;选项。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="21c02a6f4db72c82bb4b16489a1dc3d9f3dcd251" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;gv&lt;/strong&gt; and &lt;strong&gt;ghostview&lt;/strong&gt; programs have a &amp;ldquo;watch file&amp;rdquo; option can be used to view an up-to-date heap profile of your program as it runs. Simply generate an incremental heap profile as described in the previous section. Run &lt;strong&gt;gv&lt;/strong&gt; on your profile:</source>
          <target state="translated">该&lt;strong&gt;GV&lt;/strong&gt;和&lt;strong&gt;Ghostview工具&lt;/strong&gt;程序有一个&amp;ldquo;监视文件&amp;rdquo;选项可以使用，因为它运行到查看程序的跟上时代的堆轮廓。只需生成上一部分中所述的增量堆概要文件即可。在您的个人资料上运行&lt;strong&gt;gv&lt;/strong&gt;：</target>
        </trans-unit>
        <trans-unit id="c2745da38f58a1f51bf9ab0d3486cc161c559b3b" translate="yes" xml:space="preserve">
          <source>The ASCII encoding is a 7-bit encoding. The &lt;em&gt;Char7&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 7-bits, prefixing it with a leading 0, and encoding the resulting 8-bits as a single byte. For the codepoints 0-127 this corresponds the ASCII encoding.</source>
          <target state="translated">ASCII编码是7位编码。此处实现的&lt;em&gt;Char7&lt;/em&gt;编码的工作方式是将Unicode代码点截断为7位，在其前加上0作为前缀，然后将所得的8位编码为单个字节。对于代码点0-127，这对应于ASCII编码。</target>
        </trans-unit>
        <trans-unit id="3335871b5b9fc97a659ecaa26da1b75a25e4dbb8" translate="yes" xml:space="preserve">
          <source>The Accum monad</source>
          <target state="translated">累积单体</target>
        </trans-unit>
        <trans-unit id="54a2a116adb6e3d511623890991b066600f4a837" translate="yes" xml:space="preserve">
          <source>The AccumT monad transformer</source>
          <target state="translated">AccumT单体变压器</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">任何类型</target>
        </trans-unit>
        <trans-unit id="77184a896c809c5987a275354391bcb9afa84715" translate="yes" xml:space="preserve">
          <source>The Binary class</source>
          <target state="translated">二进制类</target>
        </trans-unit>
        <trans-unit id="f21b224c49e198997a984cc9f95eb312adc1246f" translate="yes" xml:space="preserve">
          <source>The Binary instance for ResolvedBCOs.</source>
          <target state="translated">ResolvedBCOs的二进制实例。</target>
        </trans-unit>
        <trans-unit id="1340d1532cd96c08b9077a17a6e5cf354440ec03" translate="yes" xml:space="preserve">
          <source>The Builder monoid</source>
          <target state="translated">建设者单体</target>
        </trans-unit>
        <trans-unit id="66e06b4ddeb35c347cf81033820bf5237468d89f" translate="yes" xml:space="preserve">
          <source>The Builder type</source>
          <target state="translated">建设者类型</target>
        </trans-unit>
        <trans-unit id="6f59e6c207b1a2a380dd7912a6b135a7a6ef6d7e" translate="yes" xml:space="preserve">
          <source>The C call &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; is equivalent to the Haskell call &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt;, except that it is</source>
          <target state="translated">C调用 &lt;code&gt;hs_try_putmvar(cap, mvar)&lt;/code&gt; 等效于Haskell调用 &lt;code&gt;tryPutMVar mvar ()&lt;/code&gt; ，除了它是</target>
        </trans-unit>
        <trans-unit id="930ac2c5a6231d7b293cf2f4934390d97c5dceec" translate="yes" xml:space="preserve">
          <source>The C code generator is only supported when GHC is built in unregisterised mode, a mode where GHC produces &amp;ldquo;portable&amp;rdquo; C code as output to facilitate porting GHC itself to a new platform. This mode produces much slower code though so it&amp;rsquo;s unlikely your version of GHC was built this way. If it has then the native code generator probably won&amp;rsquo;t be available. You can check this information by calling &lt;code&gt;ghc --info&lt;/code&gt; (see &lt;a href=&quot;using#ghc-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">仅当GHC在未注册模式下构建时才支持C代码生成器，该模式下GHC生成&amp;ldquo;便携式&amp;rdquo; C代码作为输出，以便于将GHC自身移植到新平台。但是，此模式会产生慢得多的代码，因此不太可能以这种方式构建GHC版本。如果有，那么本地代码生成器可能将不可用。您可以通过调用 &lt;code&gt;ghc --info&lt;/code&gt; 来查看此信息（请参阅&lt;a href=&quot;using#ghc-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4478e58f6a72e43562ea06bc573417edc1f53b0" translate="yes" xml:space="preserve">
          <source>The C compiler to use (default: &lt;code&gt;gcc&lt;/code&gt;)</source>
          <target state="translated">要使用的C编译器（默认值： &lt;code&gt;gcc&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="01130faef1141c2e4c47f77d4532a52f8115186a" translate="yes" xml:space="preserve">
          <source>The C pre-processor &lt;strong&gt;cpp&lt;/strong&gt; is run over your Haskell code only if the &lt;code&gt;-cpp&lt;/code&gt; option -cpp option is given. Unless you are building a large system with significant doses of conditional compilation, you really shouldn&amp;rsquo;t need it.</source>
          <target state="translated">仅当指定了 &lt;code&gt;-cpp&lt;/code&gt; 选项-cpp选项时，C预处理程序&lt;strong&gt;cpp&lt;/strong&gt;才会在Haskell代码上运行。除非您要构建一个包含大量条件编译的大型系统，否则您确实不需要它。</target>
        </trans-unit>
        <trans-unit id="be8a30e9f725c587f4c42c5c2ac8a566321ce4b5" translate="yes" xml:space="preserve">
          <source>The C program is compiled using the Haskell compiler. This provides the include path to &lt;code&gt;HsFFI.h&lt;/code&gt; which is automatically included into the C program.</source>
          <target state="translated">使用Haskell编译器编译C程序。这提供了 &lt;code&gt;HsFFI.h&lt;/code&gt; 的包含路径，该路径自动包含在C程序中。</target>
        </trans-unit>
        <trans-unit id="e91fc210907e94074bed36ea19e87412c05ed8a0" translate="yes" xml:space="preserve">
          <source>The C-side interface</source>
          <target state="translated">C端接口</target>
        </trans-unit>
        <trans-unit id="7ff7e343e1c6696d97347c4a9cd5a3b43c6bba9e" translate="yes" xml:space="preserve">
          <source>The CPU time used during GC itself</source>
          <target state="translated">GC本身所使用的CPU时间</target>
        </trans-unit>
        <trans-unit id="9b0e04ec6361f33e0d68f7f33f77c1ab233452ad" translate="yes" xml:space="preserve">
          <source>The Chapter does &lt;em&gt;not&lt;/em&gt; require implementations to refrain from doing the same for &lt;code&gt;unsafe&lt;/code&gt; calls, so strictly Haskell 2010-conforming programs cannot pass heap-allocated references to &lt;code&gt;unsafe&lt;/code&gt; FFI calls either.</source>
          <target state="translated">该章并&lt;em&gt;没有&lt;/em&gt;要求实现切莫从做了同样的 &lt;code&gt;unsafe&lt;/code&gt; 调用，因此严格哈斯克尔2010-符合程序无法传递到堆上分配引用 &lt;code&gt;unsafe&lt;/code&gt; FFI电话要么。</target>
        </trans-unit>
        <trans-unit id="7a6d8be9dffe246766e3012760ad26dc58ac76a9" translate="yes" xml:space="preserve">
          <source>The Char type and associated operations.</source>
          <target state="translated">Char类型和相关操作。</target>
        </trans-unit>
        <trans-unit id="34ab3cac27f3b7905cb71f872510098e1f28d42c" translate="yes" xml:space="preserve">
          <source>The Char8 interface to bytestrings provides an instance of IsString for the ByteString type, enabling you to use string literals, and have them implicitly packed to ByteStrings. Use &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; to enable this.</source>
          <target state="translated">字节字符串的Char8接口为ByteString类型提供了一个IsString实例，使您能够使用字符串文字，并将它们隐式打包到ByteStrings中。使用 &lt;code&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/code&gt; 启用此功能。</target>
        </trans-unit>
        <trans-unit id="87a20786956ef56773cf03030aa4cf8ea1fe3cb5" translate="yes" xml:space="preserve">
          <source>The Constraint kind</source>
          <target state="translated">约束类</target>
        </trans-unit>
        <trans-unit id="09ab3e32936ccf9f3bb679b6e68a3e00b45ed452" translate="yes" xml:space="preserve">
          <source>The Cont monad</source>
          <target state="translated">Cont单体</target>
        </trans-unit>
        <trans-unit id="12f452e71f00e2687665dadf2d17184d0289a2e5" translate="yes" xml:space="preserve">
          <source>The ContT monad transformer</source>
          <target state="translated">ContT单体变压器</target>
        </trans-unit>
        <trans-unit id="ca90c83f50ba973fabb4434d084cfad4acdcfc2a" translate="yes" xml:space="preserve">
          <source>The Continuation monad represents computations in continuation-passing style (CPS). In continuation-passing style function result is not returned, but instead is passed to another function, received as a parameter (continuation). Computations are built up from sequences of nested continuations, terminated by a final continuation (often &lt;code&gt;id&lt;/code&gt;) which produces the final result. Since continuations are functions which represent the future of a computation, manipulation of the continuation functions can achieve complex manipulations of the future of the computation, such as interrupting a computation in the middle, aborting a portion of a computation, restarting a computation, and interleaving execution of computations. The Continuation monad adapts CPS to the structure of a monad.</source>
          <target state="translated">Continuation monad以连续传递样式（CPS）表示计算。在continuation-passing样式函数中，不返回结果，而是将其传递给另一个函数，作为参数接收（延续）。计算是根据嵌套的连续序列构建的，这些序列以最终的连续（通常为 &lt;code&gt;id&lt;/code&gt; ）终止，最终的连续产生了最终的结果。由于连续性是代表计算的未来的函数，因此对连续函数的操纵可以实现对计算的未来的复杂操纵，例如中断中间的计算，中止计算的一部分，重新​​开始计算以及交织执行计算。 Continuation monad使CPS适应monad的结构。</target>
        </trans-unit>
        <trans-unit id="b6f5f2130ef6b7cf3dfc8eaaad4cc1b44fc47954" translate="yes" xml:space="preserve">
          <source>The Coverage Condition. For each functional dependency, ⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;, of the class, every type variable in S(⟨tvs⟩&lt;sub&gt;right&lt;/sub&gt;) must appear in S(⟨tvs⟩&lt;sub&gt;left&lt;/sub&gt;), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.</source>
          <target state="translated">覆盖条件。对于每个函数依赖，⟨tvs⟩ &lt;sub&gt;左&lt;/sub&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; ⟨tvs⟩ &lt;sub&gt;右&lt;/sub&gt;，类的，在S（⟨tvs⟩每一种类型的可变&lt;sub&gt;右&lt;/sub&gt;）必须出现在S（⟨tvs⟩ &lt;sub&gt;左&lt;/sub&gt;），其中S是取代映射每个类型将类声明中的变量更改为实例头中的相应类型。</target>
        </trans-unit>
        <trans-unit id="312777d9f2d66605158d20bff22160d55dc26cef" translate="yes" xml:space="preserve">
          <source>The Cygwin tools aim to provide a Unix-style API on top of the windows libraries, to facilitate ports of Unix software to windows. To this end, they introduce a Unix-style directory hierarchy under some root directory (typically &lt;code&gt;/&lt;/code&gt; is &lt;code&gt;C:\cygwin\&lt;/code&gt;). Moreover, everything built against the Cygwin API (including the Cygwin tools and programs compiled with Cygwin&amp;rsquo;s GHC) will see &lt;code&gt;/&lt;/code&gt; as the root of their file system, happily pretending to work in a typical unix environment, and finding things like &lt;code&gt;/bin&lt;/code&gt; and &lt;code&gt;/usr/include&lt;/code&gt; without ever explicitly bothering with their actual location on the windows system (probably &lt;code&gt;C:\cygwin\bin&lt;/code&gt; and &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt;).</source>
          <target state="translated">Cygwin工具旨在在Windows库的顶部提供Unix风格的API，以方便将Unix软件移植到Windows。为此，他们在某个根目录（通常为 &lt;code&gt;/&lt;/code&gt; 是 &lt;code&gt;C:\cygwin\&lt;/code&gt; ）下引入Unix风格的目录层次结构。此外，基于Cygwin API构建的所有内容（包括使用Cygwin的GHC编译的Cygwin工具和程序）都将 &lt;code&gt;/&lt;/code&gt; 作为其文件系统的根，很高兴地假装在典型的unix环境中工作，并找到 &lt;code&gt;/bin&lt;/code&gt; 和 &lt;code&gt;/usr/include&lt;/code&gt; 而不会显式地打扰它们在Windows系统上的实际位置（可能是 &lt;code&gt;C:\cygwin\bin&lt;/code&gt; 和 &lt;code&gt;C:\cygwin\usr\include&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86692a9d897be5d534ba24465eb9de8f931f4ef3" translate="yes" xml:space="preserve">
          <source>The Data class for processing constructor applications</source>
          <target state="translated">处理构造函数应用的数据类</target>
        </trans-unit>
        <trans-unit id="1bf8237029872b5da672f6b7246e84175ba43046" translate="yes" xml:space="preserve">
          <source>The Dynamic interface provides basic support for dynamic types.</source>
          <target state="translated">动态接口提供了对动态类型的基本支持。</target>
        </trans-unit>
        <trans-unit id="42156dbee11df6db43f4c8b1cc0a248822a7d3cd" translate="yes" xml:space="preserve">
          <source>The Either type, and associated operations.</source>
          <target state="translated">Either类型,以及相关操作。</target>
        </trans-unit>
        <trans-unit id="807130fbb4274539dfd3c0eea747aff0499d3550" translate="yes" xml:space="preserve">
          <source>The Error monad (also called the Exception monad).</source>
          <target state="translated">Error单体(也叫Exception单体)。</target>
        </trans-unit>
        <trans-unit id="8a5dc0df0c5ba4b15156469d46e722f494c0f012" translate="yes" xml:space="preserve">
          <source>The ErrorT monad transformer</source>
          <target state="translated">ErrorT单项式变换器</target>
        </trans-unit>
        <trans-unit id="9e8b0fd8b8d2403326182f44dc58f86de4db1bbe" translate="yes" xml:space="preserve">
          <source>The Except monad</source>
          <target state="translated">Except单体</target>
        </trans-unit>
        <trans-unit id="0636fa085801d03d78d892f99e7194b6c4c5113a" translate="yes" xml:space="preserve">
          <source>The ExceptT monad transformer</source>
          <target state="translated">ExceptT单项式变换器</target>
        </trans-unit>
        <trans-unit id="28a34cf6c1c117fe3edc278dd4ce45f5bbb4e2ab" translate="yes" xml:space="preserve">
          <source>The Exception type</source>
          <target state="translated">异常类型</target>
        </trans-unit>
        <trans-unit id="fbddbb39610322fadeb3679edecc1231a3f3fbc0" translate="yes" xml:space="preserve">
          <source>The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</source>
          <target state="translated">本节中描述的FFI特性是针对GHC的。如果你使用这些功能,你的代码将不能移植到其他编译器中。</target>
        </trans-unit>
        <trans-unit id="3efa5246016932362650667f0b2760b9317d9ba9" translate="yes" xml:space="preserve">
          <source>The FFI libraries are documented in the accompanying library documentation; see for example the &lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">FFI库在随附的库文档中进行了记录；参见例如&lt;a href=&quot;../libraries/base-4.13.0.0/foreign&quot;&gt;外部&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="761c07d2fa3147d943f9914eb230698128638338" translate="yes" xml:space="preserve">
          <source>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn&amp;rsquo;t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</source>
          <target state="translated">FFI库提供了几种分配内存以供FFI使用的方法，但始终不清楚哪种方法最好。在给定的编译器/平台上，特定类型的分配的效率可能会影响此决定，因此本节旨在阐明GHC如何执行不同类型的分配。</target>
        </trans-unit>
        <trans-unit id="f6c805c7ce1959f9f4d5c3417b157ba30228b2de" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a &lt;code&gt;newtype&lt;/code&gt;, thus:</source>
          <target state="translated">FFI规范要求IO monad出现在不同的地方，但是有时可以方便地将IO monad包装为 &lt;code&gt;newtype&lt;/code&gt; ，因此：</target>
        </trans-unit>
        <trans-unit id="5f20794bdc28c9aee5608b0c0fc201d96d6b3994" translate="yes" xml:space="preserve">
          <source>The FFI spec requires the implementation to support re-initialising itself after being shut down with &lt;code&gt;hs_exit()&lt;/code&gt;, but GHC does not currently support that. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;Issue #13693&lt;/a&gt;.</source>
          <target state="translated">FFI规范要求实现在通过 &lt;code&gt;hs_exit()&lt;/code&gt; 关闭后支持自身重新初始化，但是GHC当前不支持该初始化。参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13693&quot;&gt;问题＃13693&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d26ec709c2e5283538c1c653d1aa70ca0b33423" translate="yes" xml:space="preserve">
          <source>The GC sync time, along with other GC stats, are available by calling the &lt;code&gt;getRTSStats()&lt;/code&gt; function from C, or &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; from Haskell.</source>
          <target state="translated">所述GC同步时间，与其他GC统计一起可通过调用 &lt;code&gt;getRTSStats()&lt;/code&gt; 从C函数，或 &lt;code&gt;GHC.Stats.getRTSStats&lt;/code&gt; 从Haskell中。</target>
        </trans-unit>
        <trans-unit id="b5021fe9fe3de702f6e9a5d53a92dd7d5114b557" translate="yes" xml:space="preserve">
          <source>The GHC API exposes functions for reading and writing these files.</source>
          <target state="translated">GHC API公开了读取和写入这些文件的功能。</target>
        </trans-unit>
        <trans-unit id="44e336f3335d4bce26ff1489887e65f02d167072" translate="yes" xml:space="preserve">
          <source>The GHC RTS currently can only recover from heap overflow if it detects that an explicit memory limit (set via RTS flags). has been exceeded. Currently, failure to allocate memory from the operating system results in immediate termination of the program.</source>
          <target state="translated">GHC RTS目前只有在检测到明确的内存限制(通过RTS标志设置)被超过时,才能从堆溢出中恢复过来。目前,如果不能从操作系统中分配内存,将导致程序立即终止。</target>
        </trans-unit>
        <trans-unit id="092d6db4a6acf8e0f020ffc8e891aef1e6ec0134" translate="yes" xml:space="preserve">
          <source>The GHC command line options that control packages are:</source>
          <target state="translated">控制包的GHC命令行选项有:。</target>
        </trans-unit>
        <trans-unit id="61df44498694cfca7ad6514a046e11ddd08beac9" translate="yes" xml:space="preserve">
          <source>The GHC developers hang out here. If you are working with the GHC API or have a question about GHC&amp;rsquo;s implementation, feel free to chime in.</source>
          <target state="translated">GHC开发人员在这里闲逛。如果您正在使用GHC API或对GHC的实施有疑问，请随时注意。</target>
        </trans-unit>
        <trans-unit id="99d5e93b8c29504ff8cde4bfb2796cf7747d055b" translate="yes" xml:space="preserve">
          <source>The GHC driver pre-defines several macros when processing Haskell source code (&lt;code&gt;.hs&lt;/code&gt; or &lt;code&gt;.lhs&lt;/code&gt; files).</source>
          <target state="translated">在处理Haskell源代码（ &lt;code&gt;.hs&lt;/code&gt; 或 &lt;code&gt;.lhs&lt;/code&gt; 文件）时，GHC驱动程序会预定义几个宏。</target>
        </trans-unit>
        <trans-unit id="87a5e3c32c7140b14331679393031a63e7e433b2" translate="yes" xml:space="preserve">
          <source>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn&amp;rsquo;t necessary to ensure that the threads have exited first. If you want this fast and loose version of &lt;code&gt;hs_exit()&lt;/code&gt;, you can call:</source>
          <target state="translated">GHC运行时将程序退出视为一种特殊情况，以避免在独立可执行文件退出时等待阻塞的线程。由于该程序及其所有线程将在代码从内存中删除的同时终止，因此不必确保线程先退出。如果要使用此快速松散的 &lt;code&gt;hs_exit()&lt;/code&gt; 版本，可以调用：</target>
        </trans-unit>
        <trans-unit id="657d0403b8cb260dd76b91b660bfb82ac7e59695" translate="yes" xml:space="preserve">
          <source>The GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; command shows pattern types in this format.</source>
          <target state="translated">GHCi &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt; &lt;code&gt;:info&lt;/code&gt; &lt;/a&gt;命令以这种格式显示模式类型。</target>
        </trans-unit>
        <trans-unit id="b98fc3571126a85946312283e8cabf74b5c92953" translate="yes" xml:space="preserve">
          <source>The GHCi Monad lifting interface.</source>
          <target state="translated">GHCi单体升降界面。</target>
        </trans-unit>
        <trans-unit id="ebe9d3dd8c4ab5bd81e3a57040f569e196489a32" translate="yes" xml:space="preserve">
          <source>The GHCi debugger offers a way to hopefully shed some light on these errors quickly and without modifying or recompiling the source code. One way would be to set a breakpoint on the location in the source code that throws the exception, and then use &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt; to establish the context. However, &lt;code&gt;head&lt;/code&gt; is in a library and we can&amp;rsquo;t set a breakpoint on it directly. For this reason, GHCi provides the flags &lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt;&lt;code&gt;-fbreak-on-exception&lt;/code&gt;&lt;/a&gt; which causes the evaluator to stop when an exception is thrown, and &lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt;&lt;code&gt;-fbreak-on-error&lt;/code&gt;&lt;/a&gt;, which works similarly but stops only on uncaught exceptions. When stopping at an exception, GHCi will act just as it does when a breakpoint is hit, with the deviation that it will not show you any source code location. Due to this, these commands are only really useful in conjunction with &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, in order to log the steps leading up to the exception. For example:</source>
          <target state="translated">GHCi调试器提供了一种希望可以快速了解这些错误的方法，而无需修改或重新编译源代码。一种方法是在引发异常的源代码中的位置上设置一个断点，然后使用&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;建立上下文。但是， &lt;code&gt;head&lt;/code&gt; 位于库中，我们不能直接在其上设置断点。因此，GHCi提供了&lt;a href=&quot;#ghc-flag--fbreak-on-exception&quot;&gt; &lt;code&gt;-fbreak-on-exception&lt;/code&gt; &lt;/a&gt;标志，该标志会导致抛出异常时评估程序停止运行，并且&lt;a href=&quot;#ghc-flag--fbreak-on-error&quot;&gt; &lt;code&gt;-fbreak-on-error&lt;/code&gt; 标志&lt;/a&gt;，其工作原理类似，但仅在未捕获的异常时停止。当异常停止时，GHCi的行为将与击中断点时的行为相同，只是它不会向您显示任何源代码位置。因此，这些命令仅与&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;结合使用才真正有用，以便记录导致异常的步骤。例如：</target>
        </trans-unit>
        <trans-unit id="0b891d2a1ce80a9fee00fa3b6d6737a43b10a747" translate="yes" xml:space="preserve">
          <source>The Get and Put monads</source>
          <target state="translated">获取和放单体</target>
        </trans-unit>
        <trans-unit id="b776a2d45a7f2c193506de5827ffca159fdaaa31" translate="yes" xml:space="preserve">
          <source>The Get monad</source>
          <target state="translated">Get单体</target>
        </trans-unit>
        <trans-unit id="881d557edd11af5e9c88e4e2caa565a9b7f16b2b" translate="yes" xml:space="preserve">
          <source>The Handle is closed once the contents have been read, or if an exception is thrown.</source>
          <target state="translated">一旦内容被读取,或者出现异常,该句柄就会被关闭。</target>
        </trans-unit>
        <trans-unit id="9fc6da9c66a23f0d4306adb850fbe34a26d020b4" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 Report specifies that &lt;code&gt;safe&lt;/code&gt; FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that the garbage collector must be able to run while these calls are in progress, moving heap-allocated Haskell values around arbitrarily.</source>
          <target state="translated">Haskell 2010报告指定 &lt;code&gt;safe&lt;/code&gt; FFI调用必须允许外部调用安全地调用Haskell代码。实际上，这意味着垃圾收集器必须能够在这些调用进行时运行，从而随意移动堆分配的Haskell值。</target>
        </trans-unit>
        <trans-unit id="e4f4e3694b9cec057dc91d201d6594fcb8794184" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 definition of &lt;code&gt;Show&lt;/code&gt; stipulates that the rendered string should only include parentheses which are necessary to unambiguously parse the result. For historical reasons, &lt;code&gt;Show&lt;/code&gt; instances derived by GHC include parentheses around records despite the fact that record syntax binds more tightly than function application; e.g.,</source>
          <target state="translated">Haskell 2010对 &lt;code&gt;Show&lt;/code&gt; 的定义规定，呈现的字符串应仅包含圆括号，这是明确解析结果所必需的。由于历史原因，尽管记录语法比函数应用程序更紧密地绑定，但由GHC派生的 &lt;code&gt;Show&lt;/code&gt; 实例在记录周围包含括号。例如，</target>
        </trans-unit>
        <trans-unit id="75b51a038a288722ea47d665ae6b1906f2f2ca30" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="cb081bfa52eb8a4cbf05cd929cfffa397e641c26" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="a99410a64c91a4399b3bdd6ca6ecba63bbee421d" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;ghc-io-exception#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="608a1f6c6546f6329017b0ba471b028aef303e51" translate="yes" xml:space="preserve">
          <source>The Haskell 2010 type for exceptions in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Any I/O operation may raise an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; instead of returning a result. For a more general type of exception, including also those that arise in pure code, see &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中用于例外的Haskell 2010类型。任何I / O操作都可能引发 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 而不是返回结果。有关更一般的异常类型（包括纯代码中出现的 &lt;code&gt;&lt;a href=&quot;control-exception#v:Exception&quot;&gt;Exception&lt;/a&gt;&lt;/code&gt; ，请参见Exception。</target>
        </trans-unit>
        <trans-unit id="cbd1a39cbde2acf402014630435be0c05fcd70ac" translate="yes" xml:space="preserve">
          <source>The Haskell 98 definition of &lt;code&gt;isAlpha&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;isAlpha&lt;/code&gt; 的Haskell 98定义是：</target>
        </trans-unit>
        <trans-unit id="bcc5878839ee58bc74d82cc3033b4e47a4421ec2" translate="yes" xml:space="preserve">
          <source>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an &lt;code&gt;IO&lt;/code&gt; type, GHC will accept any newtype-wrapping of an &lt;code&gt;IO&lt;/code&gt; type. For example, these declarations are OK:</source>
          <target state="translated">Haskell FFI已指定外国进出口的参数和结果如果是新类型，则将自动展开（FFI附录第3.2节）。 GHC通过自动解包包裹IO monad本身的任何新类型来扩展FFI。更确切地说，无论在FFI规范要求的 &lt;code&gt;IO&lt;/code&gt; 类型，GHC将接受任何NEWTYPE裹包 &lt;code&gt;IO&lt;/code&gt; 型。例如，这些声明是可以的：</target>
        </trans-unit>
        <trans-unit id="4680c4ac34e14b7370d55faae60bc019d40c3efc" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常希望 &lt;code&gt;&lt;a href=&quot;data-eq#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 实现等价关系，其中两个比较相等的值不能通过&amp;ldquo; public&amp;rdquo;函数区分，而&amp;ldquo; public&amp;rdquo;函数是一个不允许查看实现细节的函数。例如，对于表示非归一化自然数模100的类型，&amp;ldquo; public&amp;rdquo;函数不会使1和201之间产生差。预期具有以下属性：</target>
        </trans-unit>
        <trans-unit id="b435dd60d544eb355fdb3b5a53612290c22abfda" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;&lt;a href=&quot;data-ord#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 实现非严格的偏序，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="88538894fe954a03ab344dde58ca70fb4af218ac" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-float#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="3149c28629f6ab1e2da394471685318956b0ba8a" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;ghc-num#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;ghc-num#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义一个环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="8d88eda2762d9273ae973553c58bcc0bd71af620" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskell报告没有定义 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义分隔环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="e76164abdc0256cd6250a3085c5fb79d40aac6bd" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell报告未定义 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 法则。但是，通常会期望 &lt;code&gt;&lt;a href=&quot;ghc-real#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 实例定义一个欧几里得域，并且在给定合适的欧几里得函数 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的情况下， &lt;code&gt;&lt;a href=&quot;ghc-real#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;ghc-real#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 对具有以下属性：</target>
        </trans-unit>
        <trans-unit id="9ce7650ff72472c9e39924a0365fbdbae6a3a423" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;numeric#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="8323805ef3fcd8127cc342507191554f2e774a6e" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; is customarily expected to implement an equivalence relationship where two values comparing equal are indistinguishable by &quot;public&quot; functions, with a &quot;public&quot; function being one not allowing to see implementation details. For example, for a type representing non-normalised natural numbers modulo 100, a &quot;public&quot; function doesn't make the difference between 1 and 201. It is expected to have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常希望 &lt;code&gt;&lt;a href=&quot;prelude#v:-61--61-&quot;&gt;==&lt;/a&gt;&lt;/code&gt; 实现等价关系，其中两个比较相等的值不能通过&amp;ldquo; public&amp;rdquo;函数区分，而&amp;ldquo; public&amp;rdquo;函数是一个不允许查看实现细节的函数。例如，对于表示非归一化自然数模100的类型，&amp;ldquo; public&amp;rdquo;函数不会使1和201之间产生差。预期具有以下属性：</target>
        </trans-unit>
        <trans-unit id="b48c329c20a3981396eab2a99555375b78674fa9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; are customarily expected to define an exponential field and have the following properties:</source>
          <target state="translated">Haskell报告未定义任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 定义指数字段，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="1c7fa25d86a0693f27eca0a0ad84f5518dec11cf" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a division ring and have the following properties:</source>
          <target state="translated">Haskell报告没有定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; 法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义分隔环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="813c73ced84a637d883552041de27732ad7f49d9" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; instances are customarily expected to define a Euclidean domain and have the following properties for the &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; pairs, given suitable Euclidean functions &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;:</source>
          <target state="translated">Haskell报告未定义 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 法则。但是，通常会期望 &lt;code&gt;&lt;a href=&quot;prelude#t:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; 实例定义一个欧几里得域，并且在给定合适的欧几里得函数 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 的情况下， &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:quot&quot;&gt;quot&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;prelude#v:rem&quot;&gt;rem&lt;/a&gt;&lt;/code&gt; 对具有以下属性：</target>
        </trans-unit>
        <trans-unit id="04a2d6720afe45625eeed33bd966e63b2869f306" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; and &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; are customarily expected to define a ring and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;(&lt;a href=&quot;prelude#v:-43-&quot;&gt;+&lt;/a&gt;)&lt;/code&gt; 和 &lt;code&gt;(&lt;a href=&quot;prelude#v:-42-&quot;&gt;*&lt;/a&gt;)&lt;/code&gt; 定义一个环并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="79c8c45566ea3ef649482a06f412a05df4a6acfa" translate="yes" xml:space="preserve">
          <source>The Haskell Report defines no laws for &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; is customarily expected to implement a non-strict partial order and have the following properties:</source>
          <target state="translated">Haskell报告没有为 &lt;code&gt;&lt;a href=&quot;prelude#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 定义任何法律。但是，通常期望 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--61-&quot;&gt;&amp;lt;=&lt;/a&gt;&lt;/code&gt; 实现非严格的偏序，并具有以下属性：</target>
        </trans-unit>
        <trans-unit id="d6f54f30ee874469ea4834b2c92a3bff6d9a4e7e" translate="yes" xml:space="preserve">
          <source>The Haskell Report demands that, for infix operators &lt;code&gt;%&lt;/code&gt;, the following identities hold:</source>
          <target state="translated">Haskell报告要求，对于中缀运算符 &lt;code&gt;%&lt;/code&gt; ，必须具有以下标识：</target>
        </trans-unit>
        <trans-unit id="fda99c30e66a8cf02c9c342a9bf010a7836b92f1" translate="yes" xml:space="preserve">
          <source>The Haskell Report describes that &lt;code&gt;*&lt;/code&gt; (spelled &lt;code&gt;Type&lt;/code&gt; and imported from &lt;code&gt;Data.Kind&lt;/code&gt; in the GHC dialect of Haskell) is the kind of ordinary datatypes, such as &lt;code&gt;Int&lt;/code&gt;. Furthermore, type constructors can have kinds with arrows; for example, &lt;code&gt;Maybe&lt;/code&gt; has kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Unboxed types have a kind that specifies their runtime representation. For example, the type &lt;code&gt;Int#&lt;/code&gt; has kind &lt;code&gt;TYPE 'IntRep&lt;/code&gt; and &lt;code&gt;Double#&lt;/code&gt; has kind &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt;. These kinds say that the runtime representation of an &lt;code&gt;Int#&lt;/code&gt; is a machine integer, and the runtime representation of a &lt;code&gt;Double#&lt;/code&gt; is a machine double-precision floating point. In contrast, the kind &lt;code&gt;Type&lt;/code&gt; is actually just a synonym for &lt;code&gt;TYPE
'LiftedRep&lt;/code&gt;. More details of the &lt;code&gt;TYPE&lt;/code&gt; mechanisms appear in the &lt;a href=&quot;#runtime-rep&quot;&gt;section on runtime representation polymorphism&lt;/a&gt;.</source>
          <target state="translated">Haskell报告描述 &lt;code&gt;*&lt;/code&gt; （拼写 &lt;code&gt;Type&lt;/code&gt; 并从Haskell的GHC方言中的 &lt;code&gt;Data.Kind&lt;/code&gt; 导入）是普通数据类型，例如 &lt;code&gt;Int&lt;/code&gt; 。此外，类型构造函数可以带有带箭头的种类。例如， &lt;code&gt;Maybe&lt;/code&gt; 类型 &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 。未装箱的类型具有一种指定其运行时表示形式的类型。例如，类型 &lt;code&gt;Int#&lt;/code&gt; 具有 &lt;code&gt;TYPE 'IntRep&lt;/code&gt; 而 &lt;code&gt;Double#&lt;/code&gt; 具有 &lt;code&gt;TYPE 'DoubleRep&lt;/code&gt; 。这些类型表示 &lt;code&gt;Int#&lt;/code&gt; 的运行时表示形式是机器整数，而 &lt;code&gt;Double#&lt;/code&gt; 的运行时表示形式是机器整数。是机器的双精度浮点数。相反，类型 &lt;code&gt;Type&lt;/code&gt; 实际上只是 &lt;code&gt;TYPE 'LiftedRep&lt;/code&gt; 的同义词。有关 &lt;code&gt;TYPE&lt;/code&gt; 机制的更多详细信息，请参见&lt;a href=&quot;#runtime-rep&quot;&gt;运行时表示多态性一节&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ffc08730dc1e1e7dc18e8e0b58ddcb43b8e6870" translate="yes" xml:space="preserve">
          <source>The Haskell Report is vague about exactly when a &lt;code&gt;deriving&lt;/code&gt; clause is legal. For example:</source>
          <target state="translated">Haskell报告对 &lt;code&gt;deriving&lt;/code&gt; 条款何时合法一事含糊。例如：</target>
        </trans-unit>
        <trans-unit id="5dd54d84f1861492e330313f2bf345ca47769e1b" translate="yes" xml:space="preserve">
          <source>The Haskell Report specifies that a group of bindings (at top level, or in a &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt;) should be sorted into strongly-connected components, and then type-checked in dependency order (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell Report, Section 4.5.1&lt;/a&gt;). As each group is type-checked, any binders of the group that have an explicit type signature are put in the type environment with the specified polymorphic type, and all others are monomorphic until the group is generalised (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell Report, Section 4.5.2&lt;/a&gt;).</source>
          <target state="translated">Haskell报告指定应将一组绑定（在顶层，或在 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;where&lt;/code&gt; 中）分类为强连接的组件，然后按依存关系顺序进行类型检查（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.1&quot;&gt;Haskell报告，第4.5.1节&lt;/a&gt;）。在对每个组进行类型检查时，该组中具有显式类型签名的所有活页夹都将放入具有指定多态类型的类型环境中，而所有其他活页夹都将是单态的，直到对该组进行一般化为止（&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.2&quot;&gt;Haskell报告，第4.5.2节&lt;/a&gt;）。 。</target>
        </trans-unit>
        <trans-unit id="f79c4bbad9a41e128d187b8c2ef86a8f611b12b5" translate="yes" xml:space="preserve">
          <source>The Haskell code in a package may be built into one or more archive libraries (e.g. &lt;code&gt;libHSfoo.a&lt;/code&gt;), or a single shared object (e.g. &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt;). The restriction to a single shared object is because the package system is used to tell the compiler when it should make an inter-shared-object call rather than an intra-shared-object-call call (inter-shared-object calls require an extra indirection).</source>
          <target state="translated">软件包中的Haskell代码可以内置到一个或多个存档库（例如 &lt;code&gt;libHSfoo.a&lt;/code&gt; ）或单个共享库（例如 &lt;code&gt;libHSfoo.dll/.so/.dylib&lt;/code&gt; ）中。对单个共享库的限制是因为程序包系统用于告诉编译器何时应进行共享库间调用而不是共享库内调用（共享库间调用需要额外的时间）间接）。</target>
        </trans-unit>
        <trans-unit id="0c75300a05da2e87e80a93270dd95d3e5ff6d9a5" translate="yes" xml:space="preserve">
          <source>The Haskell implementation with which the program was compiled or is being interpreted.</source>
          <target state="translated">程序被编译或被解释的Haskell实现。</target>
        </trans-unit>
        <trans-unit id="29f87244b686c50c8127fd2dc9c33f53eb1c0ecb" translate="yes" xml:space="preserve">
          <source>The Haskell report &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;defines&lt;/a&gt; the &lt;code&gt;lexp&lt;/code&gt; nonterminal thus (&lt;code&gt;*&lt;/code&gt; indicates a rule of interest):</source>
          <target state="translated">Haskell报告&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003&quot;&gt;定义&lt;/a&gt;了 &lt;code&gt;lexp&lt;/code&gt; 非终结符（ &lt;code&gt;*&lt;/code&gt; 表示感兴趣的规则）：</target>
        </trans-unit>
        <trans-unit id="75d99185af7621d262f47061ebc9fcce26c3d99a" translate="yes" xml:space="preserve">
          <source>The Haskell2010 Report specifies in &amp;lt;&lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt;&amp;gt; that</source>
          <target state="translated">Haskell2010报告在&amp;lt; &lt;a href=&quot;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&quot;&gt;https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1&lt;/a&gt; &amp;gt;中指定</target>
        </trans-unit>
        <trans-unit id="18dcf9c1fa4567e3d746274c7c15cc6b75881bbb" translate="yes" xml:space="preserve">
          <source>The IO monad</source>
          <target state="translated">IO单体</target>
        </trans-unit>
        <trans-unit id="fc0f546679107f369d6f8715d864a3e34b5c091c" translate="yes" xml:space="preserve">
          <source>The IOArray type</source>
          <target state="translated">IOArray类型</target>
        </trans-unit>
        <trans-unit id="737d5b10a286b500beaf74123af646266a400fbd" translate="yes" xml:space="preserve">
          <source>The IOMode type</source>
          <target state="translated">IOMode类型</target>
        </trans-unit>
        <trans-unit id="65b73403a619cdf0ecd51edadceb4eff94590c0c" translate="yes" xml:space="preserve">
          <source>The IORef type</source>
          <target state="translated">IORef类型</target>
        </trans-unit>
        <trans-unit id="558e32d8065fb827c731043184d460a503306a06" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。</target>
        </trans-unit>
        <trans-unit id="54ad98c5ffd0b94e42a9d57326f087c3d7345412" translate="yes" xml:space="preserve">
          <source>The ISO/IEC 8859-1 encoding is an 8-bit encoding often known as Latin-1. The &lt;em&gt;Char8&lt;/em&gt; encoding implemented here works by truncating the Unicode codepoint to 8-bits and encoding them as a single byte. For the codepoints 0-255 this corresponds to the ISO/IEC 8859-1 encoding. Note that the Char8 encoding is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with Char8 encoded characters.</source>
          <target state="translated">ISO / IEC 8859-1编码是8位编码，通常称为Latin-1。此处实现的&lt;em&gt;Char8&lt;/em&gt;编码通过将Unicode代码点截断为8位并将其编码为单个字节来工作。对于代码点0-255，它对应于ISO / IEC 8859-1编码。请注意，Char8编码等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用Char8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="c479ee79f8f50aa3dcf64e97781e845a99daa98d" translate="yes" xml:space="preserve">
          <source>The InputT monad transformer</source>
          <target state="translated">InputT单项式变压器</target>
        </trans-unit>
        <trans-unit id="f02dbfae6923c5fae8b765773db367457b1cef47" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）编码。此编码将字节直接映射到前256个Unicode代码点，因此不是完整的Unicode编码。尝试使用 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 编码将大于 &lt;code&gt;'\255'&lt;/code&gt; 的字符写入到 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将导致错误。</target>
        </trans-unit>
        <trans-unit id="ddf2c2b44bf1b6f9d563c7f3800d62394c65a764" translate="yes" xml:space="preserve">
          <source>The Latin1 (ISO8859-1) encoding. This encoding maps bytes directly to the first 256 Unicode code points, and is thus not a complete Unicode encoding. An attempt to write a character greater than &lt;code&gt;'\255'&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; encoding will result in an error.</source>
          <target state="translated">Latin1（ISO8859-1）编码。此编码将字节直接映射到前256个Unicode代码点，因此不是完整的Unicode编码。尝试使用 &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 编码将大于 &lt;code&gt;'\255'&lt;/code&gt; 的字符写入到 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 将导致错误。</target>
        </trans-unit>
        <trans-unit id="680f8c637bf3c21d4334aa840c68f7b1c0426e80" translate="yes" xml:space="preserve">
          <source>The List data type and its operations</source>
          <target state="translated">列表数据类型及其操作</target>
        </trans-unit>
        <trans-unit id="527e8dadea35f6a4f5c4a4c4be123089c5e69c00" translate="yes" xml:space="preserve">
          <source>The List monad.</source>
          <target state="translated">列表单体。</target>
        </trans-unit>
        <trans-unit id="8aba302b7e58fc590a9afdc1a01080baae6e6ec1" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer</source>
          <target state="translated">ListT单项式变换器</target>
        </trans-unit>
        <trans-unit id="ba07cd406a34170d4f0ecfa83e506b98d6f30534" translate="yes" xml:space="preserve">
          <source>The ListT monad transformer, adding backtracking to a given monad, which must be commutative.</source>
          <target state="translated">ListT单体变换器,对给定的单体增加回溯,必须是换元的。</target>
        </trans-unit>
        <trans-unit id="e0495cc6e831dd99a09b6b22275801501a83fb2b" translate="yes" xml:space="preserve">
          <source>The MVar type</source>
          <target state="translated">MVar类型</target>
        </trans-unit>
        <trans-unit id="46396b237f9d18bcd799cea896a2640dfd6df348" translate="yes" xml:space="preserve">
          <source>The Maybe type, and associated operations.</source>
          <target state="translated">Maybe类型,以及相关的操作。</target>
        </trans-unit>
        <trans-unit id="e744e9e0cfe46515ef9f5bb52e48c6c750bbb1e5" translate="yes" xml:space="preserve">
          <source>The MaybeT monad transformer</source>
          <target state="translated">MaybeT单项式变换器</target>
        </trans-unit>
        <trans-unit id="4126903c0c38cb737f94266782af2c525510b404" translate="yes" xml:space="preserve">
          <source>The Modified Julian Date is the day with the fraction of the day, measured from UT midnight. It's used to represent UT1, which is time as measured by the earth's rotation, adjusted for various wobbles.</source>
          <target state="translated">修改后的朱利安日期是指从UT午夜开始测量的一天的分数。它用来表示UT1,即由地球自转测量的时间,并根据各种晃动进行调整。</target>
        </trans-unit>
        <trans-unit id="d4fd231b0228fbbb56527d9186f84060d50a59d7" translate="yes" xml:space="preserve">
          <source>The Modified Julian Day is a standard count of days, with zero being the day 1858-11-17.</source>
          <target state="translated">修改后的朱利安日是一个标准的天数,0是1858-11-17这一天。</target>
        </trans-unit>
        <trans-unit id="c771c28ba6943eb0fbd701bba8effdfe529aa2b4" translate="yes" xml:space="preserve">
          <source>The MonadException class</source>
          <target state="translated">MonadException类</target>
        </trans-unit>
        <trans-unit id="ad32074e930158647c5d3c0d66a82e352b9530f7" translate="yes" xml:space="preserve">
          <source>The MonadWriter class.</source>
          <target state="translated">MonadWriter类。</target>
        </trans-unit>
        <trans-unit id="b01bbf48e477c92aa3644550cb6f1cc37d1a0b1f" translate="yes" xml:space="preserve">
          <source>The Monomorphism Restriction is disabled (see &lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;Switching off the dreaded Monomorphism Restriction&lt;/a&gt;).</source>
          <target state="translated">Monomorphism Restriction已禁用（请参阅&lt;a href=&quot;glasgow_exts#monomorphism&quot;&gt;关闭可怕的Monomorphism Restriction&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bfaad71abe81d69b989cc169fbd7881a4139c40a" translate="yes" xml:space="preserve">
          <source>The NT kernel however allows you ways to opt out of this path preprocessing by the Win32 APIs. This is done by explicitly using the desired namespace in the path.</source>
          <target state="translated">然而,NT内核允许你选择不使用Win32 API的路径预处理。这可以通过在路径中明确使用所需的命名空间来实现。</target>
        </trans-unit>
        <trans-unit id="c3d1ffc3dd3f40f1c222c841f95386202d3f7d9c" translate="yes" xml:space="preserve">
          <source>The Package Versioning Policy &lt;strong&gt;does not apply&lt;/strong&gt;.</source>
          <target state="translated">软件包版本控制策略&lt;strong&gt;不适用&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7577997f2b7e95327e240c7fc768c6dc92772fe1" translate="yes" xml:space="preserve">
          <source>The Paterson Conditions: for each class constraint &lt;code&gt;(C t1 ... tn)&lt;/code&gt; in the context</source>
          <target state="translated">帕特森条件：对于上下文中的每个类约束 &lt;code&gt;(C t1 ... tn)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7329aa4547685d3c70bea0407e898afb0b679e44" translate="yes" xml:space="preserve">
          <source>The Prelude: a standard module. The Prelude is imported by default into all Haskell modules unless either there is an explicit import statement for it, or the NoImplicitPrelude extension is enabled.</source>
          <target state="translated">Prelude:一个标准模块。除非有明确的导入语句,或者启用了 NoImplicitPrelude 扩展,否则所有 Haskell 模块都会默认导入 Prelude。</target>
        </trans-unit>
        <trans-unit id="0aa2000b932cfb04e1a3bcd9c14b88cf13e1335d" translate="yes" xml:space="preserve">
          <source>The Put monad</source>
          <target state="translated">Put单体</target>
        </trans-unit>
        <trans-unit id="e6d4dd4f8b3be3cd5b857fe2de8ff602061f0af6" translate="yes" xml:space="preserve">
          <source>The Put monad. A monad for efficiently constructing lazy bytestrings.</source>
          <target state="translated">Put单体。一个用于高效构建懒惰字节串的单体。</target>
        </trans-unit>
        <trans-unit id="859037e4eda9b5b2f4fe55e78c68c20d023080cf" translate="yes" xml:space="preserve">
          <source>The Put type</source>
          <target state="translated">认沽型</target>
        </trans-unit>
        <trans-unit id="ab5819377a02005c251c02732e301195c27a0049" translate="yes" xml:space="preserve">
          <source>The PutM type. A Writer monad over the efficient Builder monoid.</source>
          <target state="translated">PutM类型。在高效的 Builder 单体上的 Writer 单体。</target>
        </trans-unit>
        <trans-unit id="2354aa5ff6e1c2d9885153e78ccf38e4f0365e83" translate="yes" xml:space="preserve">
          <source>The RTS has a lot of options to control its behaviour. For example, you can change the context-switch interval, the default size of the heap, and enable heap profiling. These options can be passed to the runtime system in a variety of different ways; the next section (&lt;a href=&quot;#setting-rts-options&quot;&gt;Setting RTS options&lt;/a&gt;) describes the various methods, and the following sections describe the RTS options themselves.</source>
          <target state="translated">RTS有很多选择来控制其行为。例如，您可以更改上下文切换间隔，默认的堆大小并启用堆分析。这些选项可以通过各种不同的方式传递给运行时系统。下一节（&lt;a href=&quot;#setting-rts-options&quot;&gt;设置RTS选项&lt;/a&gt;）描述了各种方法，以下几节描述了RTS选项本身。</target>
        </trans-unit>
        <trans-unit id="80255d167f12c27a3ea54ce8b0bd00039dbf82da" translate="yes" xml:space="preserve">
          <source>The RTS options related to concurrency are described in &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;Using Concurrent Haskell&lt;/a&gt;, and those for parallelism in &lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;RTS options for SMP parallelism&lt;/a&gt;.</source>
          <target state="translated">与并发相关的RTS选项在&amp;ldquo; &lt;a href=&quot;using-concurrent#using-concurrent&quot;&gt;使用并发Haskell&amp;rdquo;中&lt;/a&gt;进行了介绍，而在&lt;a href=&quot;using-concurrent#parallel-options&quot;&gt;STS&lt;/a&gt;并行性的RTS选项中则针对并行性进行了描述。</target>
        </trans-unit>
        <trans-unit id="5bb8ad1fb09a839ecffde8ca34b94bdfdcd8b691" translate="yes" xml:space="preserve">
          <source>The RTS will snaffle &lt;code&gt;-H32m -S&lt;/code&gt; for itself, and the remaining arguments &lt;code&gt;-f -h foo bar&lt;/code&gt; will be available to your program if/when it calls &lt;code&gt;System.Environment.getArgs&lt;/code&gt;.</source>
          <target state="translated">RTS会 &lt;code&gt;-H32m -S&lt;/code&gt; ，如果/在调用 &lt;code&gt;System.Environment.getArgs&lt;/code&gt; 时，其余参数 &lt;code&gt;-f -h foo bar&lt;/code&gt; 将对您的程序可用。</target>
        </trans-unit>
        <trans-unit id="e88b8846d8fe73958229f97485a69a53155ce170" translate="yes" xml:space="preserve">
          <source>The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a &amp;ldquo;good consumer&amp;rdquo; consumes an intermediate list constructed by a &amp;ldquo;good producer&amp;rdquo;, the intermediate list should be eliminated entirely.</source>
          <target state="translated">RULES机制用于实现公用列表功能的融合（砍伐森林）。如果&amp;ldquo;好消费者&amp;rdquo;消费了&amp;ldquo;好生产者&amp;rdquo;构建的中间清单，则应该完全消除中间清单。</target>
        </trans-unit>
        <trans-unit id="91cc01216a24ea0cf70d53ce6831cdfd22c4c1ae" translate="yes" xml:space="preserve">
          <source>The RWS monad</source>
          <target state="translated">RWS单体</target>
        </trans-unit>
        <trans-unit id="3030e059d51b47652080afc1bf3e87a96b72964b" translate="yes" xml:space="preserve">
          <source>The RWST monad transformer</source>
          <target state="translated">RWST单体变压器</target>
        </trans-unit>
        <trans-unit id="17d69ac471ca747fe3aa42940b683d831a9ef452" translate="yes" xml:space="preserve">
          <source>The Reader monad</source>
          <target state="translated">读者单体</target>
        </trans-unit>
        <trans-unit id="3aea66391daa03b9cc14c2b409c118ef8792ac2b" translate="yes" xml:space="preserve">
          <source>The ReaderT monad transformer</source>
          <target state="translated">ReaderT单项式变换器</target>
        </trans-unit>
        <trans-unit id="7b28758084e7661741da61d05acfec540a63dcd6" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM实现将中止已知无效且需要重新启动的事务。这可能发生在 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 的中间，因此请确保您没有获取任何需要释放的资源（中止事务时忽略异常处理程序）。例如，这包括使用Handles进行任何IO。弄错了可能会导致随机死锁。</target>
        </trans-unit>
        <trans-unit id="a93c60619a7c26a3aaea050cc64323b106e6a10f" translate="yes" xml:space="preserve">
          <source>The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt;, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlocks.</source>
          <target state="translated">STM实现将中止已知无效且需要重新启动的事务。这可能发生在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 的中间，因此请确保您没有获取任何需要释放的资源（中止事务时忽略异常处理程序）。例如，这包括使用Handles进行任何IO。弄错了可能会导致随机死锁。</target>
        </trans-unit>
        <trans-unit id="a466c95f7705b8667d496c8cad7e2978bbeba71b" translate="yes" xml:space="preserve">
          <source>The STM implementation will often run transactions multiple times, so you need to be prepared for this if your IO has any side effects.</source>
          <target state="translated">STM的实现经常会多次运行事务,所以如果你的IO有什么副作用,你需要做好准备。</target>
        </trans-unit>
        <trans-unit id="d2c9be55e3be898cad081ed8cc787cc2dc0d8adc" translate="yes" xml:space="preserve">
          <source>The Safe Haskell &lt;em&gt;safe language&lt;/em&gt; (enabled by &lt;code&gt;-XSafe&lt;/code&gt;) guarantees the following properties:</source>
          <target state="translated">Safe Haskell &lt;em&gt;安全语言&lt;/em&gt;（由 &lt;code&gt;-XSafe&lt;/code&gt; 启用）保证了以下属性：</target>
        </trans-unit>
        <trans-unit id="7726729f19e0da000e83c79bcb8c28c6f385ffcb" translate="yes" xml:space="preserve">
          <source>The Safe Haskell checks can be disabled for a module by passing the &lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt;&lt;code&gt;-fno-safe-haskell&lt;/code&gt;&lt;/a&gt; flag. This is useful in particular when compiling with source plugins as running a plugin marks the module as unsafe and can then cause downstream modules to fail the safety checks.</source>
          <target state="translated">可以通过传递&lt;a href=&quot;#ghc-flag--fno-safe-haskell&quot;&gt; &lt;code&gt;-fno-safe-haskell&lt;/code&gt; &lt;/a&gt;标志来禁用模块的Safe Haskell检查。这在使用源插件进行编译时特别有用，因为运行插件会将模块标记为不安全，然后会导致下游模块无法通过安全检查。</target>
        </trans-unit>
        <trans-unit id="6da0062c345ab61160d26f605d07d936e53000f2" translate="yes" xml:space="preserve">
          <source>The Select monad</source>
          <target state="translated">选择单体</target>
        </trans-unit>
        <trans-unit id="14b5bf3a399f4cac6f75470d51a3a0bae35be0f1" translate="yes" xml:space="preserve">
          <source>The SelectT monad transformer</source>
          <target state="translated">SelectT单项式变换器</target>
        </trans-unit>
        <trans-unit id="afb2b6e8a6ae40d8e5e247b3b17b072cba473176" translate="yes" xml:space="preserve">
          <source>The Signal type</source>
          <target state="translated">信号类型</target>
        </trans-unit>
        <trans-unit id="34ca6ab89d0a5929502c3b8fda82f9d7a6d4db86" translate="yes" xml:space="preserve">
          <source>The State monad</source>
          <target state="translated">国家单体</target>
        </trans-unit>
        <trans-unit id="d1d93ac3a4f1be7a558b299c04132f8bd844f80f" translate="yes" xml:space="preserve">
          <source>The StateT monad transformer</source>
          <target state="translated">StateT单项式变换器</target>
        </trans-unit>
        <trans-unit id="38fd4995bb0200714fd098c99380c5ce19be4b0a" translate="yes" xml:space="preserve">
          <source>The TH state, created by &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">TH状态，由 &lt;code&gt;&lt;a href=&quot;ghci-th#v:startTH&quot;&gt;startTH&lt;/a&gt;&lt;/code&gt; 创建</target>
        </trans-unit>
        <trans-unit id="f2544b8736e584c3e40b611d6a80bea3cc2e2d77" translate="yes" xml:space="preserve">
          <source>The Typeable class</source>
          <target state="translated">Typeable类</target>
        </trans-unit>
        <trans-unit id="406c428a778ef7125e193987bbac0237ab0511cd" translate="yes" xml:space="preserve">
          <source>The UTC time zone.</source>
          <target state="translated">UTC时区。</target>
        </trans-unit>
        <trans-unit id="38141e622e2458972c46a5896fe7f4e01687679d" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-16 Unicode 编码(应使用字节顺序标记来表示endianness)。</target>
        </trans-unit>
        <trans-unit id="0cf0e68f8c740d3f43a6e8c8dbc14773e82bf3fb" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-16 Unicode编码(大写字母)。</target>
        </trans-unit>
        <trans-unit id="0e56b9ac4542ba5321237f8287ad2bf793fc3af5" translate="yes" xml:space="preserve">
          <source>The UTF-16 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-16 Unicode编码(litte-endian)</target>
        </trans-unit>
        <trans-unit id="d34bf7d79b70b504d63dce6b7b58a8119636ec3c" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (a byte-order-mark should be used to indicate endianness).</source>
          <target state="translated">UTF-32 Unicode编码(应使用字节顺序标记来表示endianness)。</target>
        </trans-unit>
        <trans-unit id="67dffc3f81adbd2d24a0516022167baf8bc86322" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (big-endian)</source>
          <target state="translated">UTF-32Unicode编码(大写字母)</target>
        </trans-unit>
        <trans-unit id="e1d43f77fb169e84f01193e920df4b983c3368e9" translate="yes" xml:space="preserve">
          <source>The UTF-32 Unicode encoding (litte-endian)</source>
          <target state="translated">UTF-32统一码编码(litte-endian)</target>
        </trans-unit>
        <trans-unit id="52589abf36edd4349a64f7d5395f328f8a947920" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding</source>
          <target state="translated">UTF-8 Unicode编码</target>
        </trans-unit>
        <trans-unit id="a005af9557a056326c8b8d7c97a47bc28391bd3b" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">UTF-8 Unicode编码，带有字节顺序标记（BOM；字节序列0xEF 0xBB 0xBF）。此编码的行为类似于 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; ，只是在输入时，在流的开头忽略BOM序列，而在输出时，在BOM序列的前面。</target>
        </trans-unit>
        <trans-unit id="eaf74031b27da65f642c604ade4f47115637843c" translate="yes" xml:space="preserve">
          <source>The UTF-8 Unicode encoding, with a byte-order-mark (BOM; the byte sequence 0xEF 0xBB 0xBF). This encoding behaves like &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt;, except that on input, the BOM sequence is ignored at the beginning of the stream, and on output, the BOM sequence is prepended.</source>
          <target state="translated">UTF-8 Unicode编码，带有字节顺序标记（BOM；字节序列0xEF 0xBB 0xBF）。此编码的行为类似于 &lt;code&gt;&lt;a href=&quot;system-io#v:utf8&quot;&gt;utf8&lt;/a&gt;&lt;/code&gt; ，只是在输入时，在流的开头忽略BOM序列，而在输出时，在BOM序列的前面。</target>
        </trans-unit>
        <trans-unit id="48a72567fd36d1b77865bf4ea3a5534e90bd33c8" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode &lt;em&gt;all&lt;/em&gt; Unicode codepoints. We recommend using it always for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s unless an application really requires another encoding.</source>
          <target state="translated">UTF-8编码可以编码&lt;em&gt;所有&lt;/em&gt; Unicode代码点。我们建议始终将其用于编码 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ,除非应用程序确实需要另一种编码。</target>
        </trans-unit>
        <trans-unit id="d524833742212d693f8a7a1356f8aab1e3718c22" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding can encode all Unicode codepoints. It is equivalent to the ASCII encoding on the Unicode codepoints 0-127. Hence, functions such as &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; can also be used for encoding &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s as a decimal number with UTF-8 encoded characters.</source>
          <target state="translated">UTF-8编码可以编码所有Unicode代码点。它等效于Unicode代码点0-127上的ASCII编码。因此，诸如 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:intDec&quot;&gt;intDec&lt;/a&gt;&lt;/code&gt; 之类的函数也可以用于使用UTF-8编码字符将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 编码为十进制数字。</target>
        </trans-unit>
        <trans-unit id="09093313f0f91c4b5737ad4a0fbe7d06eea9ee26" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale</source>
          <target state="translated">当前语言环境的Unicode编码。</target>
        </trans-unit>
        <trans-unit id="3f137dd2773a7b21ca2a1977bcffe06a49397773" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but allowing arbitrary undecodable bytes to be round-tripped through it.</source>
          <target state="translated">当前locale的Unicode编码,但允许任意不可解码的字节在其中进行循环播放。</target>
        </trans-unit>
        <trans-unit id="939eaac913afcf37c06343e0dee5a39351f12362" translate="yes" xml:space="preserve">
          <source>The Unicode encoding of the current locale, but where undecodable bytes are replaced with their closest visual match. Used for the &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; marshalling functions in &lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String&lt;/a&gt;</source>
          <target state="translated">当前语言环境的Unicode编码，但无法解码的字节将替换为其最接近的视觉匹配。用于&lt;a href=&quot;foreign-c-string&quot;&gt;Foreign.C.String中&lt;/a&gt;的 &lt;code&gt;&lt;a href=&quot;foreign-c-string#v:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 编组函数</target>
        </trans-unit>
        <trans-unit id="94c16bb05159c06fe3dc812d48c81e471e6e3efb" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">字符的Unicode常规类别。这依赖于 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例，该实例必须与Unicode标准中显示的类别保持相同的顺序。</target>
        </trans-unit>
        <trans-unit id="68e199523a1fa0fa41372e425d662a0ca937ad92" translate="yes" xml:space="preserve">
          <source>The Unicode general category of the character. This relies on the &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;, which must remain in the same order as the categories are presented in the Unicode standard.</source>
          <target state="translated">字符的Unicode常规类别。这依赖于 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;prelude#t:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 实例，该实例必须与Unicode标准中显示的类别保持相同的顺序。</target>
        </trans-unit>
        <trans-unit id="461ca2fc00cd995c7e6980fa43df6ef7503d97ca" translate="yes" xml:space="preserve">
          <source>The Windows directory</source>
          <target state="translated">Windows目录</target>
        </trans-unit>
        <trans-unit id="a88998b1d185995bfddbae32ddd00452270da2ae" translate="yes" xml:space="preserve">
          <source>The Writer monad</source>
          <target state="translated">作家单体</target>
        </trans-unit>
        <trans-unit id="0f31095d17e6be1b28728b97a802ce50d67ad701" translate="yes" xml:space="preserve">
          <source>The WriterT monad transformer</source>
          <target state="translated">WriterT单体变换器</target>
        </trans-unit>
        <trans-unit id="e564641fef849b7748c52b9e3bbf79b098ce5698" translate="yes" xml:space="preserve">
          <source>The ability to &lt;em&gt;inherit&lt;/em&gt; required signatures from packages we depend upon, combining the signatures into a single merged signature which reflects the requirements of any locally defined signature, as well as the requirements of our dependencies.</source>
          <target state="translated">从我们所依赖的包中&lt;em&gt;继承&lt;/em&gt;所需签名的能力，可以将签名组合成一个合并的签名，这可以反映任何本地定义的签名的要求以及我们依赖项的要求。</target>
        </trans-unit>
        <trans-unit id="7dbeb7f19d92db3db611e99643a65e9afeeb3443" translate="yes" xml:space="preserve">
          <source>The ability to define an &lt;code&gt;hsig&lt;/code&gt; file, containing type definitions and type signature for values which can be used by modules that import the signature, and must be provided by the eventual implementing module, and</source>
          <target state="translated">定义 &lt;code&gt;hsig&lt;/code&gt; 文件的能力，其中包含值的类型定义和类型签名，这些值可以由导入签名的模块使用，并且必须由最终的实现模块提供，并且</target>
        </trans-unit>
        <trans-unit id="e18a26f623d4b3d5b0afaeca9ff88864b2448314" translate="yes" xml:space="preserve">
          <source>The ability to set a breakpoint on a function definition or expression in the program. When the function is called, or the expression evaluated, GHCi suspends execution and returns to the prompt, where you can inspect the values of local variables before continuing with the execution.</source>
          <target state="translated">能够在程序中的函数定义或表达式上设置一个断点,当函数被调用,或表达式被评估时,GHCi会暂停执行并返回提示,在这里你可以检查局部变量的值,然后再继续执行。当函数被调用或表达式被评估时,GHCi会暂停执行并返回到提示符,在那里你可以检查局部变量的值,然后继续执行。</target>
        </trans-unit>
        <trans-unit id="310f755673bc29e8cd19bd1e50c2672bd0ba64a5" translate="yes" xml:space="preserve">
          <source>The above code is equivalent to:</source>
          <target state="translated">上述代码相当于:</target>
        </trans-unit>
        <trans-unit id="ceb853b961139ea8a430dce957f73b5c77a03245" translate="yes" xml:space="preserve">
          <source>The above declaration (which requires the language pragma &lt;code&gt;DeriveGeneric&lt;/code&gt;) causes the following representation to be generated:</source>
          <target state="translated">上面的声明（需要使用语言pragma &lt;code&gt;DeriveGeneric&lt;/code&gt; ）导致生成以下表示形式：</target>
        </trans-unit>
        <trans-unit id="124bdbaef2420b9e89592fec3e57e81f0de35ec8" translate="yes" xml:space="preserve">
          <source>The above declaration causes the following representation to be generated:</source>
          <target state="translated">上述声明导致生成以下表示方式:</target>
        </trans-unit>
        <trans-unit id="f76366168215856429247956c4826993833306ed" translate="yes" xml:space="preserve">
          <source>The above definition of trust has an issue. Any module can be compiled with &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and it will be trusted. To control this, there is an additional definition of package trust (enabled with the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag). The point of package trust is to require that the client C explicitly say which packages are allowed to contain trustworthy modules. Trustworthy packages are only trusted if they reside in a package trusted by C.</source>
          <target state="translated">上述信任的定义存在问题。任何模块都可以使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;进行编译，并且将被信任。为了控制这一点，还对程序包信任进行了其他定义（使用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志启用）。程序包信任的重点是要求客户端C明确说明允许哪些程序包包含可信赖的模块。仅当可信程序包位于C信任的程序包中时，它们才会被信任。</target>
        </trans-unit>
        <trans-unit id="2df7fb2c193365ff646472a721e6b7dbe5bf63ae" translate="yes" xml:space="preserve">
          <source>The above function takes a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; supposed to represent Base64 encoded data and the current decoding state. It writes the decoded bytes as the side-effect of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; and returns the new decoding state, if the decoding of all data in the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; was successful. The checking if the strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; represents Base64 encoded data and the actual decoding are fused. This makes the common case, where all data represents Base64 encoded data, more efficient. It also implies that all data must be decoded before the final decoding state can be returned. &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are intended for implementing such fused checking and decoding/encoding, which is reflected in their strictness properties.</source>
          <target state="translated">上面的函数采用一个严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,该字符串应表示Base64编码的数据和当前的解码状态。如果对 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中的所有数据进行了成功的解码，它将已解码的字节写入 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 的副作用，并返回新的解码状态。检查是否严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 表示Base64编码的数据和实际解码融合。这使所有数据都代表Base64编码数据的常见情况更加有效。这也意味着必须在返回最终解码状态之前对所有数据进行解码。 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 旨在实现这种融合的检查和解码/编码，这反映在它们的严格性属性中。</target>
        </trans-unit>
        <trans-unit id="0308489ed1646a7d427f7b348942d76c9c0d5d69" translate="yes" xml:space="preserve">
          <source>The above informal specification is fine for simple situations, but matters can get complicated. In particular, it needs to be clear exactly when a key dies, so that any weak pointers that refer to it can be finalized. Suppose, for example, the value of one weak pointer refers to the key of another...does that keep the key alive?</source>
          <target state="translated">上述非正式的规范对于简单的情况来说是没有问题的,但事情可能会变得复杂。特别是,需要明确一个键何时死亡,这样任何引用它的弱指针都可以被最终确定。举例来说,假设一个弱指针的值引用了另一个弱指针的键......这是否会让这个键保持活力?</target>
        </trans-unit>
        <trans-unit id="2361448fcf86f9607ed9aa3c2d047337ebd0125c" translate="yes" xml:space="preserve">
          <source>The above laws imply:</source>
          <target state="translated">上述规律意味着。</target>
        </trans-unit>
        <trans-unit id="6121e60b6f07d4583d6a2f3988fc1fab1e503635" translate="yes" xml:space="preserve">
          <source>The above will parse a string like &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; and return a successful parse result &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt;. Compare against the below which will produce a result of &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; for the same input:</source>
          <target state="translated">上面将解析一个字符串，例如 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; 并返回成功的解析结果 &lt;code&gt;&quot;aabbb&quot;&lt;/code&gt; 。与下面的比较，对于相同的输入将产生 &lt;code&gt;&quot;bbb&quot;&lt;/code&gt; 的结果：</target>
        </trans-unit>
        <trans-unit id="20d7c122429fa587037c0b158d78237d0e61f8fb" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象数据类型 &lt;code&gt;ParseError&lt;/code&gt; 表示解析错误。它提供了错误的源位置（ &lt;code&gt;&lt;a href=&quot;text-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）和错误消息列表（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）。一个 &lt;code&gt;ParseError&lt;/code&gt; 可以通过函数返回 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="2860dda2765620cbf0f468a55ba7b993da164fe3" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象数据类型 &lt;code&gt;ParseError&lt;/code&gt; 表示解析错误。它提供了错误的源位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）和错误消息列表（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）。一个 &lt;code&gt;ParseError&lt;/code&gt; 可以通过函数返回 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="aab9864f2e792b8ac699847b4dbdbb4a77ea80ac" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象数据类型 &lt;code&gt;ParseError&lt;/code&gt; 表示解析错误。它提供了错误的源位置（ &lt;code&gt;&lt;a href=&quot;text-parsec-pos#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）和错误消息列表（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）。一个 &lt;code&gt;ParseError&lt;/code&gt; 可以通过函数返回 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="510da1eb070dd00ee03ec16a47305698f8cacdd9" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;ParseError&lt;/code&gt; represents parse errors. It provides the source position (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt;) of the error and a list of error messages (&lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;ParseError&lt;/code&gt; can be returned by the function &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;ParseError&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; classes.</source>
          <target state="translated">抽象数据类型 &lt;code&gt;ParseError&lt;/code&gt; 表示解析错误。它提供了错误的源位置（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec#t:SourcePos&quot;&gt;SourcePos&lt;/a&gt;&lt;/code&gt; ）和错误消息列表（ &lt;code&gt;&lt;a href=&quot;text-parsec-error#t:Message&quot;&gt;Message&lt;/a&gt;&lt;/code&gt; ）。一个 &lt;code&gt;ParseError&lt;/code&gt; 可以通过函数返回 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:parse&quot;&gt;parse&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;ParseError&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="de0533afad3f79319b3bf4b1fcb91b9bbdbc0565" translate="yes" xml:space="preserve">
          <source>The abstract data type &lt;code&gt;SourcePos&lt;/code&gt; represents source positions. It contains the name of the source (i.e. file name), a line number and a column number. &lt;code&gt;SourcePos&lt;/code&gt; is an instance of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">抽象数据类型 &lt;code&gt;SourcePos&lt;/code&gt; 表示源位置。它包含源名称（即文件名），行号和列号。 &lt;code&gt;SourcePos&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-show#t:Show&quot;&gt;Show&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-eq#t:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="4896de6a97029ad3c503ab35de30ebe552f9de1c" translate="yes" xml:space="preserve">
          <source>The abstract type of documents. A Doc represents a &lt;em&gt;set&lt;/em&gt; of layouts. A Doc with no occurrences of Union or NoDoc represents just one layout.</source>
          <target state="translated">文件的抽象类型。Doc代表一&lt;em&gt;组&lt;/em&gt;布局。没有出现Union或NoDoc的Doc仅代表一种布局。</target>
        </trans-unit>
        <trans-unit id="a80b0e5c19c356bd9ef420910831b319cf81af79" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">动作 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 导致缓冲处理以便在句柄 &lt;code&gt;hdl&lt;/code&gt; 中输出的所有项目立即发送到操作系统。</target>
        </trans-unit>
        <trans-unit id="ee59ce1aebad5edf7e6e4aaef4677f21c7eefc31" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; flushes all buffered data in &lt;code&gt;hdl&lt;/code&gt;, including any buffered read data. Buffered read data is flushed by seeking the file position back to the point before the bufferred data was read, and hence only works if &lt;code&gt;hdl&lt;/code&gt; is seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">该行动 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hFlushAll&quot;&gt;hFlushAll&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 刷新所有缓冲数据 &lt;code&gt;hdl&lt;/code&gt; ，包括任何缓冲的读取数据。通过将文件位置恢复到读取缓冲的数据之前的位置来刷新缓冲的读取数据，因此，仅在 &lt;code&gt;hdl&lt;/code&gt; 可搜索时才有效（请参见 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a371db2521146387741275550e657dffca505303" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; 操作将句柄 &lt;code&gt;hdl&lt;/code&gt; 的文本编码更改为 &lt;code&gt;encoding&lt;/code&gt; 。创建 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 时的默认编码为 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; ，即当前语言环境的默认编码。</target>
        </trans-unit>
        <trans-unit id="2e5909c7d1c1b470eac7ec2d2a3d5f1c7a3e6b23" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">动作 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 导致缓冲处理以便在句柄 &lt;code&gt;hdl&lt;/code&gt; 中输出的所有项目立即发送到操作系统。</target>
        </trans-unit>
        <trans-unit id="30e8a3b807220ec41770ad1fcda8f8906a927d36" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; causes any items buffered for output in handle &lt;code&gt;hdl&lt;/code&gt; to be sent immediately to the operating system.</source>
          <target state="translated">动作 &lt;code&gt;&lt;a href=&quot;system-io#v:hFlush&quot;&gt;hFlush&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; 导致缓冲处理以便在句柄 &lt;code&gt;hdl&lt;/code&gt; 中输出的所有项目立即发送到操作系统。</target>
        </trans-unit>
        <trans-unit id="9c8d6d26b1ac4ce2c7a317b47737557b2e637055" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt;&lt;code&gt;encoding&lt;/code&gt; changes the text encoding for the handle &lt;code&gt;hdl&lt;/code&gt; to &lt;code&gt;encoding&lt;/code&gt;. The default encoding when a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is created is &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;, namely the default encoding for the current locale.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; &lt;code&gt;encoding&lt;/code&gt; 操作将句柄 &lt;code&gt;hdl&lt;/code&gt; 的文本编码更改为 &lt;code&gt;encoding&lt;/code&gt; 。创建 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 时的默认编码为 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; ，即当前语言环境的默认编码。</target>
        </trans-unit>
        <trans-unit id="88ecb8776a874cfae1e583d670074ac14b0b3b9f" translate="yes" xml:space="preserve">
          <source>The action can handle the interrupt itself; a new &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; exception will be thrown every time Ctrl-C is pressed.</source>
          <target state="translated">该动作可以处理中断本身。每次按Ctrl-C都会抛出一个新的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="7c560f66ad19d0c44deb93f325922bbfa7a14cb7" translate="yes" xml:space="preserve">
          <source>The actions to perform when a signal is received.</source>
          <target state="translated">当收到信号时,要执行的动作。</target>
        </trans-unit>
        <trans-unit id="17c5e604d289acc48a4aeb8ca32b75ead60baded" translate="yes" xml:space="preserve">
          <source>The actual command line arguments (presumably got from &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">实际的命令行参数（大概是从 &lt;code&gt;&lt;a href=&quot;system-environment#v:getArgs&quot;&gt;getArgs&lt;/a&gt;&lt;/code&gt; 获得的）。</target>
        </trans-unit>
        <trans-unit id="51507a88f0049d4973537c6abea3ce2abf60b884" translate="yes" xml:space="preserve">
          <source>The actual meaning of the various columns in the output is:</source>
          <target state="translated">输出中各列的实际意义是:。</target>
        </trans-unit>
        <trans-unit id="8d600203b76ff6ccdd7956053fbe52659d549a35" translate="yes" xml:space="preserve">
          <source>The advantage of smaller stack chunks is that the garbage collector can avoid traversing stack chunks if they are known to be unmodified since the last collection, so reducing the chunk size means that the garbage collector can identify more stack as unmodified, and the GC overhead might be reduced. On the other hand, making stack chunks too small adds some overhead as there will be more overflow/underflow between chunks. The default setting of 32k appears to be a reasonable compromise in most cases.</source>
          <target state="translated">更小的堆栈分块的好处是,如果已知堆栈分块自上次收集后未被修改,垃圾收集器可以避免遍历堆栈分块,所以减小分块大小意味着垃圾收集器可以识别更多的堆栈为未修改的堆栈,GC开销可能会减少。另一方面,把堆栈分块做得太小会增加一些开销,因为分块之间会有更多的溢出/下溢。32k的默认设置在大多数情况下似乎是一个合理的折中方案。</target>
        </trans-unit>
        <trans-unit id="351839425c4046d1ef3e16ab0a651854e611c6da" translate="yes" xml:space="preserve">
          <source>The advantage of this is that the key can be retrieved by &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; in addition to the value.</source>
          <target state="translated">这样做的好处是除值外，还可以通过 &lt;code&gt;&lt;a href=&quot;system-mem-weak#v:deRefWeak&quot;&gt;deRefWeak&lt;/a&gt;&lt;/code&gt; 检索密钥。</target>
        </trans-unit>
        <trans-unit id="51801fd153e97264561ce8060f8815074cf0359c" translate="yes" xml:space="preserve">
          <source>The alarm timer</source>
          <target state="translated">闹钟定时器</target>
        </trans-unit>
        <trans-unit id="e9de65a28b0e1c87c6c42bf35a90ef7382160962" translate="yes" xml:space="preserve">
          <source>The algebraic data types</source>
          <target state="translated">代数数据类型</target>
        </trans-unit>
        <trans-unit id="af0e67390188169e10bce1a919bdd538300c70aa" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates definitions for &lt;code&gt;foldMap&lt;/code&gt;, &lt;code&gt;foldr&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not need to be folded over.</source>
          <target state="translated">该算法&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;从改编&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;算法，但它产生的定义 &lt;code&gt;foldMap&lt;/code&gt; ， &lt;code&gt;foldr&lt;/code&gt; 相似，而 &lt;code&gt;null&lt;/code&gt; ，而不是 &lt;code&gt;fmap&lt;/code&gt; 。另外，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;过滤掉RHS表达式上所有类型不涉及最后一个类型参数的构造函数参数，因为这些参数不需要折叠。</target>
        </trans-unit>
        <trans-unit id="606c23fd4a39d6f5da98fdda576dd31c1413daef" translate="yes" xml:space="preserve">
          <source>The algorithm for &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; is adapted from the &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; algorithm, but it generates a definition for &lt;code&gt;traverse&lt;/code&gt; instead of &lt;code&gt;fmap&lt;/code&gt;. In addition, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; filters out all constructor arguments on the RHS expression whose types do not mention the last type parameter, since those arguments do not produce any effects in a traversal.</source>
          <target state="translated">对于算法&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;从适于&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;算法，但它会产生一个定义 &lt;code&gt;traverse&lt;/code&gt; ，而不是 &lt;code&gt;fmap&lt;/code&gt; 。另外，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;过滤掉RHS表达式上所有类型没有提及最后一个类型参数的构造函数参数，因为这些参数不会在遍历中产生任何影响。</target>
        </trans-unit>
        <trans-unit id="76b01a57a6338aab828a7c6e4ed1bf39e383096b" translate="yes" xml:space="preserve">
          <source>The allowed fields, with their types, are:</source>
          <target state="translated">允许的字段及其类型为:</target>
        </trans-unit>
        <trans-unit id="007ff1d2ad1a216037acaa14b7a1f3887c82c2b0" translate="yes" xml:space="preserve">
          <source>The alternative spelling &lt;code&gt;INLINEABLE&lt;/code&gt; is also accepted by GHC.</source>
          <target state="translated">GHC也接受替代拼写 &lt;code&gt;INLINEABLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="305a13d8f5f537b644a0383d8511ddbfd1c351ee" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; (32 or 64).</source>
          <target state="translated">给出了每个操作的摊销运行时间，其中&lt;em&gt;n&lt;/em&gt;表示映射中的条目数，&lt;em&gt;W&lt;/em&gt;表示 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; （32或64）中的位数。</target>
        </trans-unit>
        <trans-unit id="43383f5e57411cb28bfae33d1e0cb0912284dd35" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map and &lt;em&gt;W&lt;/em&gt; referring to the number of bits in an &lt;code&gt;Int&lt;/code&gt; (32 or 64).</source>
          <target state="translated">给出了每个操作的摊销运行时间，其中&lt;em&gt;n&lt;/em&gt;表示映射中的条目数，&lt;em&gt;W&lt;/em&gt;表示 &lt;code&gt;Int&lt;/code&gt; （32或64）中的位数。</target>
        </trans-unit>
        <trans-unit id="9a366c01859c8d621928b2208d0c7ed30604c01f" translate="yes" xml:space="preserve">
          <source>The amortized running time is given for each operation, with &lt;em&gt;n&lt;/em&gt; referring to the number of entries in the map.</source>
          <target state="translated">给出了每个操作的摊销运行时间，其中&lt;em&gt;n&lt;/em&gt;表示映射中的条目数。</target>
        </trans-unit>
        <trans-unit id="a8bc34451c62ea9fef00489d326317052195ef0d" translate="yes" xml:space="preserve">
          <source>The amount of CPU time and elapsed wall clock time while initialising the runtime system (INIT), running the program itself (MUT, the mutator), and garbage collecting (GC).</source>
          <target state="translated">在初始化运行系统(INIT)、运行程序本身(MUT,突变器)和垃圾收集(GC)时的CPU时间和经过的壁钟时间。</target>
        </trans-unit>
        <trans-unit id="324b96835c11121147eb9632d3d28270b6cd3cf5" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答案是&amp;ldquo;可能会扔掉&amp;rdquo;。选择是不确定的。如果您正在捕获任何类型的异常，则可能会捕获到任何一种。如果您使用 &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 类型调用 &lt;code&gt;catch&lt;/code&gt; ，则处理程序可能以 &lt;code&gt;DivideByZero&lt;/code&gt; 作为参数运行，或者可能进一步传播 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 异常。如果再次调用它，您可能会得到相反的行为。可以，因为 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。</target>
        </trans-unit>
        <trans-unit id="fc2d971716bd2fe11fe8e65858d3f263f32451c4" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答案是&amp;ldquo;可能会扔掉&amp;rdquo;。选择是不确定的。如果您正在捕获任何类型的异常，则可能会捕获到任何一种。如果您使用 &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 类型调用 &lt;code&gt;catch&lt;/code&gt; ，则处理程序可能以 &lt;code&gt;DivideByZero&lt;/code&gt; 作为参数运行，或者可能进一步传播 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 异常。如果再次调用它，您可能会得到相反的行为。可以，因为 &lt;code&gt;&lt;a href=&quot;ghc-io#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。</target>
        </trans-unit>
        <trans-unit id="6636ed331b405e67e4aa7a8f8c1f88ee4738daae" translate="yes" xml:space="preserve">
          <source>The answer is &quot;it might throw either&quot;; the choice is non-deterministic. If you are catching any type of exception then you might catch either. If you are calling &lt;code&gt;catch&lt;/code&gt; with type &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; then the handler may get run with &lt;code&gt;DivideByZero&lt;/code&gt; as an argument, or an &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; exception may be propogated further up. If you call it again, you might get a the opposite behaviour. This is ok, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation.</source>
          <target state="translated">答案是&amp;ldquo;可能会扔掉&amp;rdquo;。选择是不确定的。如果您正在捕获任何类型的异常，则可能会捕获到任何一种。如果您使用 &lt;code&gt;IO Int -&amp;gt; (ArithException -&amp;gt; IO Int) -&amp;gt; IO Int&lt;/code&gt; 类型调用 &lt;code&gt;catch&lt;/code&gt; ，则处理程序可能以 &lt;code&gt;DivideByZero&lt;/code&gt; 作为参数运行，或者可能进一步传播 &lt;code&gt;ErrorCall &quot;urk&quot;&lt;/code&gt; 异常。如果再次调用它，您可能会得到相反的行为。可以，因为 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。</target>
        </trans-unit>
        <trans-unit id="215e7b52176702d87e95e2ce03acf7002f6125af" translate="yes" xml:space="preserve">
          <source>The approximate time when the program finished execution as a UNIX epoch timestamp.</source>
          <target state="translated">程序完成执行的大概时间,作为UNIX时间戳。</target>
        </trans-unit>
        <trans-unit id="bba06a7c745bfe3d2d4d032c0a5307f863b5c408" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数类型。</target>
        </trans-unit>
        <trans-unit id="77f549adbb8c3243a4f421f1caa3469b06d519cd" translate="yes" xml:space="preserve">
          <source>The arbitrary-precision &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; number type.</source>
          <target state="translated">任意精度 &lt;code&gt;&lt;a href=&quot;numeric-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 数类型。</target>
        </trans-unit>
        <trans-unit id="7e4663001ff64b0062c525758c18f678a0b593f7" translate="yes" xml:space="preserve">
          <source>The argument is usually the name of the application. Since it will be integrated into the path, it must consist of valid path characters.</source>
          <target state="translated">参数通常是应用程序的名称。因为它将被整合到路径中,所以必须由有效的路径字符组成。</target>
        </trans-unit>
        <trans-unit id="f7c4f0dc994aa251501707da51ab6248d1b7b620" translate="yes" xml:space="preserve">
          <source>The argument must be strictly positive, that condition is &lt;em&gt;not&lt;/em&gt; checked.</source>
          <target state="translated">该参数必须严格为正，&lt;em&gt;不&lt;/em&gt;检查条件。</target>
        </trans-unit>
        <trans-unit id="bfd85e788b1a4102dc5506f2821063aaee1859f8" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 的参数是一个将另一个函数作为其参数的函数，该函数可用于在蒙版计算的上下文中恢复主要的蒙版状态。例如，使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 一种常见方法是保护资源的获取：</target>
        </trans-unit>
        <trans-unit id="ec41714558fc08d08da55c62fab2fe097c6c6a18" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 的参数是一个将另一个函数作为其参数的函数，该函数可用于在蒙版计算的上下文中恢复主要的蒙版状态。例如，使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 一种常见方法是保护资源的获取：</target>
        </trans-unit>
        <trans-unit id="f8b310556e765050dba6b8aa3221dbec61d539ee" translate="yes" xml:space="preserve">
          <source>The argument passed to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is a function that takes as its argument another function, which can be used to restore the prevailing masking state within the context of the masked computation. For example, a common way to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; is to protect the acquisition of a resource:</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 的参数是一个将另一个函数作为其参数的函数，该函数可用于在蒙版计算的上下文中恢复主要的蒙版状态。例如，使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 一种常见方法是保护资源的获取：</target>
        </trans-unit>
        <trans-unit id="3c1e08fffd8f2b265d44f0c771329303cef101fc" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;runGhc&lt;/code&gt; is a bit tricky. GHC needs this to find its libraries, so the argument must refer to the directory that is printed by &lt;code&gt;ghc --print-libdir&lt;/code&gt; for the same version of GHC that the program is being compiled with. Above we therefore use the &lt;code&gt;ghc-paths&lt;/code&gt; package which provides this for us.</source>
          <target state="translated">&lt;code&gt;runGhc&lt;/code&gt; 的参数有些棘手。GHC需要它来查找其库，因此该参数必须引用 &lt;code&gt;ghc --print-libdir&lt;/code&gt; 打印的目录，该目录与编译该程序所使用的GHC版本相同。因此，在上面我们使用了 &lt;code&gt;ghc-paths&lt;/code&gt; 包，它为我们提供了这一点。</target>
        </trans-unit>
        <trans-unit id="629bfd4051da2fa1a32d9993713c3423b906b41a" translate="yes" xml:space="preserve">
          <source>The arguments are:</source>
          <target state="translated">这些论点是:</target>
        </trans-unit>
        <trans-unit id="af48f7ebb72df2bb8fd591d8c3756cf037769ab7" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的参数按此顺序排列，以便我们可以部分应用它，例如：</target>
        </trans-unit>
        <trans-unit id="9ab336f12a087d2ee8f1cb00edb943f2a0db5354" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-console-getopt#v:Option&quot;&gt;Option&lt;/a&gt;&lt;/code&gt; 的参数为：</target>
        </trans-unit>
        <trans-unit id="a6d74e6182495971a70d15c2958c5a641ef0bc47" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; are in this order so that we can partially apply it, e.g.:</source>
          <target state="translated">方 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的参数按此顺序排列，以便我们可以部分应用它，例如：</target>
        </trans-unit>
        <trans-unit id="ecd5594ea721a5c5b4964510fa025a0ba7161ee7" translate="yes" xml:space="preserve">
          <source>The array is undefined (i.e. bottom) if any index in the list is out of bounds. The Haskell 2010 Report further specifies that if any two associations in the list have the same index, the value at that index is undefined (i.e. bottom). However in GHC's implementation, the value at such an index is the value part of the last association with that index in the list.</source>
          <target state="translated">如果列表中的任何索引出界,则该数组未定义(即底部)。Haskell 2010报告进一步规定,如果列表中的任何两个关联具有相同的索引,则该索引处的值是未定义的(即底层)。然而在GHC的实现中,这种索引处的值是列表中最后一个具有该索引的关联的值部分。</target>
        </trans-unit>
        <trans-unit id="44d43a4b5ab2e55067cf3b1a8adecaad475ca23d" translate="yes" xml:space="preserve">
          <source>The array type</source>
          <target state="translated">阵列类型</target>
        </trans-unit>
        <trans-unit id="f14b40d222c3b195d28ca364c99460ad8aae96cd" translate="yes" xml:space="preserve">
          <source>The arrows web page at &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt;&lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt;&amp;gt;`__.</source>
          <target state="translated">箭头网页位于 &lt;code&gt;http://www.haskell.org/arrows/&lt;/code&gt; &amp;lt; &lt;a href=&quot;http://www.haskell.org/arrows/&quot;&gt;http://www.haskell.org/arrows/&lt;/a&gt; &amp;gt;`__。</target>
        </trans-unit>
        <trans-unit id="5375e79ae4b0bd456d40500fcf8a53d9559263ad" translate="yes" xml:space="preserve">
          <source>The automatic loading of object files can sometimes lead to confusion, because non-exported top-level definitions of a module are only available for use in expressions at the prompt when the module is interpreted (see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). For this reason, you might sometimes want to force GHCi to load a module using the interpreter. This can be done by prefixing a &lt;code&gt;*&lt;/code&gt; to the module name or filename when using &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, for example</source>
          <target state="translated">对象文件的自动加载有时会引起混乱，因为模块的未导出顶级定义仅在解释模块时才在提示下的表达式中使用（请参阅&lt;a href=&quot;#ghci-scope&quot;&gt;提示中的真正范围是什么？&lt;/a&gt;）。因此，您有时可能要强制GHCi使用解释器加载模块。例如，使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; 时&lt;/a&gt;，可以通过在模块名称或文件名前加 &lt;code&gt;*&lt;/code&gt; 来完成此操作。</target>
        </trans-unit>
        <trans-unit id="b8d9c5b3787a7ee0e2557b6cd2dbfe90790c68e2" translate="yes" xml:space="preserve">
          <source>The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt;) should take care of overloaded local and/or unexported functions.</source>
          <target state="translated">The automatic specialisation of overloaded functions (with &lt;code&gt;-O&lt;/code&gt; ) should take care of overloaded local and/or unexported functions.</target>
        </trans-unit>
        <trans-unit id="5b4889f9c5c10822085aef8616f19dbeeab3bf53" translate="yes" xml:space="preserve">
          <source>The available GHCi options are:</source>
          <target state="translated">可用的GHCi选项有:</target>
        </trans-unit>
        <trans-unit id="320cabfd45dc56924b1a16a731023c186da51000" translate="yes" xml:space="preserve">
          <source>The available mode flags are:</source>
          <target state="translated">可用的模式标志有:</target>
        </trans-unit>
        <trans-unit id="7d80beedcca979af44b30619e5e06f25ee652ee4" translate="yes" xml:space="preserve">
          <source>The average and maximum &amp;ldquo;residency&amp;rdquo;, which is the amount of live data in bytes. The runtime can only determine the amount of live data during a major GC, which is why the number of samples corresponds to the number of major GCs (and is usually relatively small). To get a better picture of the heap profile of your program, use the &lt;a href=&quot;#rts-flag--hT&quot;&gt;&lt;code&gt;-hT&lt;/code&gt;&lt;/a&gt; RTS option (&lt;a href=&quot;#rts-profiling&quot;&gt;RTS options for profiling&lt;/a&gt;).</source>
          <target state="translated">平均和最大&amp;ldquo;驻留时间&amp;rdquo;，即以字节为单位的实时数据量。运行时只能确定主要GC期间的实时数据量，这就是为什么样本数量与主要GC数量相对应的原因（通常相对较小）。为了更好地了解程序的堆配置文件，请使用&lt;a href=&quot;#rts-flag--hT&quot;&gt; &lt;code&gt;-hT&lt;/code&gt; &lt;/a&gt; RTS选项（&lt;a href=&quot;#rts-profiling&quot;&gt;用于概要分析的RTS选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a46eb9d9f0c06124eb5d61df6a1e2c54302d74ae" translate="yes" xml:space="preserve">
          <source>The avoided &amp;ldquo;dangerous&amp;rdquo; optimisations are those that can make runtime or space &lt;em&gt;worse&lt;/em&gt; if you&amp;rsquo;re unlucky. They are normally turned on or off individually.</source>
          <target state="translated">避免的&amp;ldquo;危险&amp;rdquo;优化是在您不幸运的&lt;em&gt;情况下&lt;/em&gt;会使运行时或空间&lt;em&gt;变差的&lt;/em&gt;优化。它们通常单独打开或关闭。</target>
        </trans-unit>
        <trans-unit id="eecb19b8afe1b4ff965ad37ca33e048b7e8a4fe6" translate="yes" xml:space="preserve">
          <source>The base must be greater than &lt;code&gt;1&lt;/code&gt;, the second argument, the number whose logarithm is sought, shall be positive, otherwise the result is meaningless.</source>
          <target state="translated">底数必须大于 &lt;code&gt;1&lt;/code&gt; ，第二个自变量（其对数要寻找的数字）应为正，否则结果将毫无意义。</target>
        </trans-unit>
        <trans-unit id="5bc476ce11547136a2a5b9c892017204522ab1a2" translate="yes" xml:space="preserve">
          <source>The basic algorithm for &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; walks the arguments of each constructor of a data type, applying a mapping function depending on the type of each argument. If a plain type variable is found that is syntactically equivalent to the last type parameter of the data type (&lt;code&gt;a&lt;/code&gt; in the above example), then we apply the function &lt;code&gt;f&lt;/code&gt; directly to it. If a type is encountered that is not syntactically equivalent to the last type parameter &lt;em&gt;but does mention&lt;/em&gt; the last type parameter somewhere in it, then a recursive call to &lt;code&gt;fmap&lt;/code&gt; is made. If a type is found which doesn&amp;rsquo;t mention the last type parameter at all, then it is left alone.</source>
          <target state="translated">&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;的基本算法遍历数据类型的每个构造函数的参数，并根据每个参数的类型应用映射函数。如果一个普通类型的变量，发现在语法上等同于数据类型的最后一个类型参数（ &lt;code&gt;a&lt;/code&gt; 在上面的例子中），那么我们应用功能 &lt;code&gt;f&lt;/code&gt; 直接给它。如果遇到的语法在语法上不等同于最后一个类型参数，&lt;em&gt;但确实&lt;/em&gt;在其中某个地方&lt;em&gt;提到&lt;/em&gt;了最后一个类型参数，则对 &lt;code&gt;fmap&lt;/code&gt; 进行递归调用。如果找到一个根本不提及最后一个type参数的类型，则将其保留。</target>
        </trans-unit>
        <trans-unit id="3880ac769d164951235b5160f553818be744abe1" translate="yes" xml:space="preserve">
          <source>The basic arrow class.</source>
          <target state="translated">基本的箭头类。</target>
        </trans-unit>
        <trans-unit id="f8e6230ac47ed9f2f8c9e5c744ea8b38e5723913" translate="yes" xml:space="preserve">
          <source>The basic idea is as follows:</source>
          <target state="translated">基本思路如下:</target>
        </trans-unit>
        <trans-unit id="ba3b2fdca46ebd4f364c251ed8663faaa8ea67c0" translate="yes" xml:space="preserve">
          <source>The basic idea is you render your structure in the form of this tree, and then use treeHtml to turn it into a Html object with the structure explicit.</source>
          <target state="translated">基本的想法是你把你的结构以这个树的形式呈现出来,然后用treeHtml把它变成一个结构显式的Html对象。</target>
        </trans-unit>
        <trans-unit id="ca1a1e0f9e4dd44a7cc3e7b636c0566990b56840" translate="yes" xml:space="preserve">
          <source>The basic syntax is that instead of specifying a package name P to the package flag &lt;code&gt;-package&lt;/code&gt;, instead we specify both a package name and a parenthesized, comma-separated list of module names to import. For example, &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; makes only &lt;code&gt;Data.List&lt;/code&gt; and &lt;code&gt;Data.Bool&lt;/code&gt; visible from package &lt;code&gt;base&lt;/code&gt;. We also support renaming of modules, in case you need to refer to both modules simultaneously; this is supporting by writing &lt;code&gt;OldModName as NewModName&lt;/code&gt;, e.g. &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt;. You can also write &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; to include all of the original bindings (e.g. the renaming is strictly additive). It&amp;rsquo;s important to specify quotes so that your shell passes the package name and thinning/renaming list as a single argument to GHC.</source>
          <target state="translated">基本语法是，我们没有指定包标志 &lt;code&gt;-package&lt;/code&gt; 的包名P ，而是指定了包名和要导入的以逗号分隔的模块名列表。例如， &lt;code&gt;-package &quot;base (Data.List, Data.Bool)&quot;&lt;/code&gt; 使从package &lt;code&gt;base&lt;/code&gt; 中仅可见 &lt;code&gt;Data.List&lt;/code&gt; 和 &lt;code&gt;Data.Bool&lt;/code&gt; 。如果您需要同时引用两个模块，我们还支持模块的重命名。这可以通过将 &lt;code&gt;OldModName as NewModName&lt;/code&gt; 来支持，例如-package &lt;code&gt;-package &quot;base (Data.Bool as Bool)&lt;/code&gt; 。您也可以将 &lt;code&gt;-package &quot;base with (Data.Bool as Bool)&lt;/code&gt; 编写。包括所有原始绑定（例如，重命名是严格加法的）。指定引号很重要，这样您的外壳程序会将软件包名称和细化/重命名列表作为GHC的单个参数传递。</target>
        </trans-unit>
        <trans-unit id="e4d64a56087518fa3e2214a7adad0a68d002b762" translate="yes" xml:space="preserve">
          <source>The batch compiler can be used alongside GHCi: compiled modules can be loaded into an interactive session and used in the same way as interpreted code, and in fact when using GHCi most of the library code will be pre-compiled. This means you get the best of both worlds: fast pre-compiled library code, and fast compile turnaround for the parts of your program being actively developed.</source>
          <target state="translated">批量编译器可以和GHCi一起使用:编译后的模块可以加载到交互式会话中,并以与解释代码相同的方式使用,事实上,当使用GHCi时,大部分的库代码将被预编译。这意味着你可以得到两全其美的东西:快速的预编译库代码,以及快速的编译周转,用于你的程序被积极开发的部分。</target>
        </trans-unit>
        <trans-unit id="8ef12a287f244edad57a058eca9787cf5ada079d" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; using the given search directories and testing each file for executable permissions. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该行为等效于使用给定的搜索目录并测试每个文件的可执行权限的 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="a37ab05f29aa8d1d66f30bee4471417ca0bbd0f1" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;, returning only the first occurrence. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该行为等效于 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; ，仅返回第一个匹配项。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFileWith&quot;&gt;findFileWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="6c8e66257c1f95cca3356ee64f960b20dcb60818" translate="yes" xml:space="preserve">
          <source>The behavior is equivalent to &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该行为等效于 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="eb1e1a3692688caa279ab0329a4e161ca0e7b861" translate="yes" xml:space="preserve">
          <source>The behaviour is simply this:</source>
          <target state="translated">行为就是这样简单。</target>
        </trans-unit>
        <trans-unit id="25a0b28ac23419d2d5d4b31eb8e82eaa74968d1a" translate="yes" xml:space="preserve">
          <source>The behaviour of parallel list comprehensions follows that of zip, in that the resulting list will have the same length as the shortest branch.</source>
          <target state="translated">并行列表理解的行为与zip的行为一致,即产生的列表将与最短的分支具有相同的长度。</target>
        </trans-unit>
        <trans-unit id="4c2566b6e8b4d963d45c5f213c50828df28117fe" translate="yes" xml:space="preserve">
          <source>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of &lt;code&gt;Collects&lt;/code&gt; with a simple dependency:</source>
          <target state="translated">包含依赖项信息的好处在于，它使我们能够定义更通用的多参数类，而不会产生歧义问题，并且具有更准确的类型的好处。为了说明这一点，我们回到集合类实例，和注释的原始定义 &lt;code&gt;Collects&lt;/code&gt; 用一个简单的依赖性：</target>
        </trans-unit>
        <trans-unit id="947bc2cb4d922e45d67175db691e9955f759c4f5" translate="yes" xml:space="preserve">
          <source>The biconnected components of a graph. An undirected graph is biconnected if the deletion of any vertex leaves it connected.</source>
          <target state="translated">图的双连接成分。如果删除任何一个顶点都会使一个非定向图连接起来,那么这个图就是双连接的。</target>
        </trans-unit>
        <trans-unit id="fbd73ac6d922a5bdced0fb605663eb345d894008" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be at the top level (i.e. no nested binders)</source>
          <target state="translated">被注释的文件夹必须在顶层(即没有嵌套的文件夹)。</target>
        </trans-unit>
        <trans-unit id="63969d96d060c4b503447fa167a99cc5d9a634d8" translate="yes" xml:space="preserve">
          <source>The binder being annotated must be declared in the current module</source>
          <target state="translated">被注释的粘结剂必须在当前模块中声明</target>
        </trans-unit>
        <trans-unit id="7e1a540e18890acf0212904549c9082483047e09" translate="yes" xml:space="preserve">
          <source>The binding is lazy, but when either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is evaluated by &lt;code&gt;b&lt;/code&gt; the entire pattern is matched, including forcing the evaluation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">绑定是惰性的，但是当 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 由 &lt;code&gt;b&lt;/code&gt; 求值时，整个模式都会匹配，包括强制对 &lt;code&gt;x&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="5313486dfdead25fb97fb53d215625b3a8e92cb9" translate="yes" xml:space="preserve">
          <source>The body &lt;code&gt;e&lt;/code&gt; of a &lt;code&gt;static e&lt;/code&gt; expression must be a closed expression. Where we say an expression is &lt;em&gt;closed&lt;/em&gt; when all of its free (type) variables are closed. And a variable is &lt;em&gt;closed&lt;/em&gt; if it is let-bound to a &lt;em&gt;closed&lt;/em&gt; expression and its type is &lt;em&gt;closed&lt;/em&gt; as well. And a type is &lt;em&gt;closed&lt;/em&gt; if it has no free variables.</source>
          <target state="translated">主体 &lt;code&gt;e&lt;/code&gt; 一个的 &lt;code&gt;static e&lt;/code&gt; 表达式必须是一个封闭的表达。当我们说一个表达式&lt;em&gt;关闭&lt;/em&gt;时，它的所有免费（类型）变量都被关闭。和一个变量被&lt;em&gt;关闭&lt;/em&gt;如果让结合到一个&lt;em&gt;封闭的&lt;/em&gt;表达和其类型&lt;em&gt;关闭&lt;/em&gt;为好。如果类型没有自由变量，则它是&lt;em&gt;封闭的&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="592ada029a062869cce6e9bab58606be6defb777" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;f&lt;/code&gt; requires a &lt;code&gt;Num Int&lt;/code&gt; instance. We could solve this constraint from the context because we have &lt;code&gt;C Int b&lt;/code&gt; and that provides us a solution for &lt;code&gt;Num Int&lt;/code&gt;. However, we can often produce much better code by directly solving for an available &lt;code&gt;Num Int&lt;/code&gt; dictionary we might have at hand. This removes potentially many layers of indirection and crucially allows other optimisations to fire as the dictionary will be statically known and selector functions can be inlined.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 的主体需要 &lt;code&gt;Num Int&lt;/code&gt; 实例。我们可以从上下文中解决此约束，因为我们有 &lt;code&gt;C Int b&lt;/code&gt; ，这为 &lt;code&gt;Num Int&lt;/code&gt; 提供了解决方案。但是，我们通常可以通过直接求解可用的 &lt;code&gt;Num Int&lt;/code&gt; 词典来产生更好的代码。这将消除潜在的许多间接层，并最终允许触发其他优化，因为该字典将是静态已知的，并且可以内联选择器函数。</target>
        </trans-unit>
        <trans-unit id="6d145adb9d3d5724f47490428e23e3c43d0c8235" translate="yes" xml:space="preserve">
          <source>The body of &lt;code&gt;h&lt;/code&gt;&lt;em&gt;can&lt;/em&gt; refer to the function &lt;code&gt;k&lt;/code&gt; appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</source>
          <target state="translated">的主体 &lt;code&gt;h&lt;/code&gt; &lt;em&gt;可以&lt;/em&gt;参照功能 &lt;code&gt;k&lt;/code&gt; 出现在声明quasiquoter的另一侧，如quasiquoters不会导致被分解的声明组。</target>
        </trans-unit>
        <trans-unit id="8c2a782fcf9cc8cd32d7c6db0f011051b79d7285" translate="yes" xml:space="preserve">
          <source>The bound on the size of sequences of bytes generated by this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 生成的字节序列大小的界限。</target>
        </trans-unit>
        <trans-unit id="efcab014d352f2160b0e056ce4481103488be8c8" translate="yes" xml:space="preserve">
          <source>The bounds are specified as a pair of the lowest and highest bounds in the array respectively. For example, a one-origin vector of length 10 has bounds (1,10), and a one-origin 10 by 10 matrix has bounds ((1,1),(10,10)).</source>
          <target state="translated">边界分别被指定为数组中最低和最高边界的一对。例如,一个长度为10的单源向量的边界为(1,10),一个10乘10的单源矩阵的边界为((1,1),(10,10))。</target>
        </trans-unit>
        <trans-unit id="ba1cb6f6655a10a0c6294b458c9d83470571695d" translate="yes" xml:space="preserve">
          <source>The bounds of an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 的边界。</target>
        </trans-unit>
        <trans-unit id="55a1eeab90b32df97217b33a312a220ee3d8254d" translate="yes" xml:space="preserve">
          <source>The bounds of the array</source>
          <target state="translated">阵列的边界</target>
        </trans-unit>
        <trans-unit id="5e0f777f52cc6d21bfe3b719f3991ded42b0a70a" translate="yes" xml:space="preserve">
          <source>The bounds with which an array was constructed.</source>
          <target state="translated">构建数组的边界。</target>
        </trans-unit>
        <trans-unit id="606c7ca088c78a3f35afe2ec49468115c18dfed0" translate="yes" xml:space="preserve">
          <source>The buffer is represented by a record, where the record contains the raw buffer and the start/end points of the filled portion. The buffer contents itself is mutable, but the rest of the record is immutable. This is a slightly odd mix, but it turns out to be quite practical: by making all the buffer metadata immutable, we can have operations on buffer metadata outside of the IO monad.</source>
          <target state="translated">缓冲区用一条记录来表示,记录中包含原始缓冲区和填充部分的开始/结束点。缓冲区内容本身是可以改变的,但记录的其他部分是不可改变的。这是一个略显奇怪的混合,但事实证明它是相当实用的:通过使所有的缓冲区元数据不可变,我们可以在IO单体之外对缓冲区元数据进行操作。</target>
        </trans-unit>
        <trans-unit id="7e80cbba3a922b5261d972496342488e7c081b28" translate="yes" xml:space="preserve">
          <source>The bug tracker lists bugs that have been reported in GHC but not yet fixed: see the &lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;. In addition to those, GHC also has the following known bugs or infelicities. These bugs are more permanent; it is unlikely that any of them will be fixed in the short term.</source>
          <target state="translated">错误跟踪器列出了GHC中已报告但尚未修复的错误：请参阅&lt;a href=&quot;http://ghc.haskell.org/trac/ghc/&quot;&gt;GHC Trac&lt;/a&gt;。除这些以外，GHC还具有以下已知的错误或遗忘。这些错误更永久。他们中的任何一个都不太可能在短期内得到解决。</target>
        </trans-unit>
        <trans-unit id="7c15ff27610c2478bb9e4d3ab87096d2c276c0af" translate="yes" xml:space="preserve">
          <source>The byte ordering of the target machine.</source>
          <target state="translated">目标机器的字节排序。</target>
        </trans-unit>
        <trans-unit id="9d60877c7df977c480a2e8c741eba795e8186655" translate="yes" xml:space="preserve">
          <source>The byte-order-mark is strictly unnecessary in UTF-8, but is sometimes used to identify the encoding of a file.</source>
          <target state="translated">在UTF-8中,字节顺序标记是严格不必要的,但有时会被用来识别文件的编码。</target>
        </trans-unit>
        <trans-unit id="8e514a824a293915d542219870ba513432dcaf11" translate="yes" xml:space="preserve">
          <source>The bytes read, how many bytes were read.</source>
          <target state="translated">读取的字节数,读取了多少字节。</target>
        </trans-unit>
        <trans-unit id="b6a0060fcedfd8a68377b3d1eb2b5aba06d7d975" translate="yes" xml:space="preserve">
          <source>The call</source>
          <target state="translated">呼叫</target>
        </trans-unit>
        <trans-unit id="39398c8eae38902a5e0ff83f99f6b2f202aad4e7" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;inline f&lt;/code&gt; arranges that &lt;code&gt;f&lt;/code&gt; is inlined, regardless of its size. More precisely, the call &lt;code&gt;inline f&lt;/code&gt; rewrites to the right-hand side of &lt;code&gt;f&lt;/code&gt;'s definition. This allows the programmer to control inlining from a particular call site rather than the definition site of the function (c.f. &lt;code&gt;INLINE&lt;/code&gt; pragmas).</source>
          <target state="translated">调用 &lt;code&gt;inline f&lt;/code&gt; 安排 &lt;code&gt;f&lt;/code&gt; 内联，而不管其大小如何。更准确地说， &lt;code&gt;inline f&lt;/code&gt; 调用f重写为 &lt;code&gt;f&lt;/code&gt; 定义的右侧。这使程序员可以控制从特定调用站点而不是函数的定义站点进行内联（参见 &lt;code&gt;INLINE&lt;/code&gt; 编译指示）。</target>
        </trans-unit>
        <trans-unit id="7b04d6b098bff47077a3361dce7c4b2060070b35" translate="yes" xml:space="preserve">
          <source>The call may block for a long time if a GC is in progress. We can&amp;rsquo;t use this method if the C API we&amp;rsquo;re calling doesn&amp;rsquo;t allow blocking in the callback.</source>
          <target state="translated">如果正在进行GC，则呼叫可能会长时间阻塞。如果我们正在调用的C API不允许在回调中进行阻塞，则无法使用此方法。</target>
        </trans-unit>
        <trans-unit id="0f662e8be9b1e8327dfadad6256f93b3102227e4" translate="yes" xml:space="preserve">
          <source>The call stack</source>
          <target state="translated">呼叫栈</target>
        </trans-unit>
        <trans-unit id="0b95e6d04b2d9db9df511faee23c172fb043db56" translate="yes" xml:space="preserve">
          <source>The call stack here consists of a single entry, pinpointing the source of the call to &lt;code&gt;error&lt;/code&gt;. However, by annotating several computations with &lt;code&gt;HasCallStack&lt;/code&gt;, figuring out the exact circumstances and sequences of calls that lead to a call to &lt;code&gt;error&lt;/code&gt; becomes a lot easier, as demonstrated with the simple example below.</source>
          <target state="translated">此处的调用堆栈由一个条目组成，可精确定位对 &lt;code&gt;error&lt;/code&gt; 的调用源。但是，通过使用 &lt;code&gt;HasCallStack&lt;/code&gt; 注释几个计算，找出导致 &lt;code&gt;error&lt;/code&gt; 调用的确切情况和调用顺序变得容易得多，如下面的简单示例所示。</target>
        </trans-unit>
        <trans-unit id="e65b75e639ba49f45b306162220bcb4b4e376b49" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;hs_init()&lt;/code&gt; initializes GHC&amp;rsquo;s runtime system. Do NOT try to invoke any Haskell functions before calling &lt;code&gt;hs_init()&lt;/code&gt;: bad things will undoubtedly happen.</source>
          <target state="translated">调用 &lt;code&gt;hs_init()&lt;/code&gt; 会初始化GHC的运行时系统。在调用 &lt;code&gt;hs_init()&lt;/code&gt; 之前，请勿尝试调用任何Haskell函数：无疑会发生不好的事情。</target>
        </trans-unit>
        <trans-unit id="b0d2f80290077bea927d89a134d957a184f32cc5" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;ghc-enum#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 会导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="319dd86afb1a88f29e7d25a55be6766bfa4bbc86" translate="yes" xml:space="preserve">
          <source>The calls &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; should result in a runtime error.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt; &lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt; &lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 会导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="82bb223904345033a341142d4c4dc792513b34b0" translate="yes" xml:space="preserve">
          <source>The case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; is rather interesting. Here, we call the final function &lt;code&gt;encode&lt;/code&gt; that we yet have to define, recursively. We will use another type class &lt;code&gt;Encode&lt;/code&gt; for that function:</source>
          <target state="translated">对于此案 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 是相当有趣的。在这里，我们递归地调用最终必须定义的函数 &lt;code&gt;encode&lt;/code&gt; 。我们将对该函数使用另一个类型类 &lt;code&gt;Encode&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="dbeba971901c44630a87f3ab4af1926015f93dc7" translate="yes" xml:space="preserve">
          <source>The channels are implemented with &lt;code&gt;MVar&lt;/code&gt;s and therefore inherit all the caveats that apply to &lt;code&gt;MVar&lt;/code&gt;s (possibility of races, deadlocks etc). The stm (software transactional memory) library has a more robust implementation of channels called &lt;code&gt;TChan&lt;/code&gt;s.</source>
          <target state="translated">这些通道是使用 &lt;code&gt;MVar&lt;/code&gt; 实现的，因此继承了所有适用于 &lt;code&gt;MVar&lt;/code&gt; 的警告（种族，死锁等可能性）。stm（软件事务存储）库对称为 &lt;code&gt;TChan&lt;/code&gt; 的通道具有更强大的实现。</target>
        </trans-unit>
        <trans-unit id="4069bea430852a057890df955f47a154334cab42" translate="yes" xml:space="preserve">
          <source>The character that is used to separate the entries in the $PATH environment variable.</source>
          <target state="translated">用于分隔$PATH环境变量中的条目的字符。</target>
        </trans-unit>
        <trans-unit id="ba11d47bc9956242fbb3ca66e5d4200f63de5f8d" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">分隔目录的字符。在可能有多个字符的情况下， &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo;理想&amp;rdquo;的字符。</target>
        </trans-unit>
        <trans-unit id="0adbd55b5e31c8dee6ffdd25e981917f83978616" translate="yes" xml:space="preserve">
          <source>The character that separates directories. In the case where more than one character is possible, &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; is the 'ideal' one.</source>
          <target state="translated">分隔目录的字符。在可能有多个字符的情况下， &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:pathSeparator&quot;&gt;pathSeparator&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo;理想&amp;rdquo;的字符。</target>
        </trans-unit>
        <trans-unit id="3300c6070d1ff47cc64a9cd4f2a57598bed4fe49" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">字符类型 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 是一个枚举，其值表示Unicode（或等效的ISO / IEC 10646）代码点（即字符，有关详细信息，请参见&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;）。此集扩展了ISO 8859-1（Latin-1）字符集（前256个字符），它本身是ASCII字符集（前128个字符）的扩展。Haskell中的字符文字类型为 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a83bfe2a3131f5d1fa9053b377b2dd8ef00abbee" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">字符类型 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 是一个枚举，其值表示Unicode（或等效的ISO / IEC 10646）代码点（即字符，有关详细信息，请参见&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;）。此集扩展了ISO 8859-1（Latin-1）字符集（前256个字符），它本身是ASCII字符集（前128个字符）的扩展。Haskell中的字符文字类型为 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e57b1fe87f343495401c4e61909f138148056d67" translate="yes" xml:space="preserve">
          <source>The character type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; is an enumeration whose values represent Unicode (or equivalently ISO/IEC 10646) code points (i.e. characters, see &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; for details). This set extends the ISO 8859-1 (Latin-1) character set (the first 256 characters), which is itself an extension of the ASCII character set (the first 128 characters). A character literal in Haskell has type &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">字符类型 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 是一个枚举，其值表示Unicode（或等效的ISO / IEC 10646）代码点（即字符，有关详细信息，请参见&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt;）。此集扩展了ISO 8859-1（Latin-1）字符集（前256个字符），它本身是ASCII字符集（前128个字符）的扩展。Haskell中的字符文字类型为 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47f8f2f2dc9e65ebc1b9adf566bdf62f3dc06201" translate="yes" xml:space="preserve">
          <source>The chunk size used for I/O. Currently set to 32k, less the memory management overhead</source>
          <target state="translated">用于I/O的分块大小,目前设置为32k,减去内存管理开销。目前设置为32k,减去内存管理开销。</target>
        </trans-unit>
        <trans-unit id="c4ebe1e22516dcf7d377102ba02d7a72071fb54c" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-dynamic#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 类允许计算类型的具体表示。</target>
        </trans-unit>
        <trans-unit id="26ec99c0bc5533ce5fa506bf5dd334d666afbabf" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-typeable#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 类允许计算类型的具体表示。</target>
        </trans-unit>
        <trans-unit id="95e5985c3bffdb6706bd6da87ba82bb2b1f9502b" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; allows a concrete representation of a type to be calculated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;type-reflection#t:Typeable&quot;&gt;Typeable&lt;/a&gt;&lt;/code&gt; 类允许计算类型的具体表示。</target>
        </trans-unit>
        <trans-unit id="a0793307c198436ef6cbb2b38d12d842f11f5daa" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsLabel&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsLabel&lt;/code&gt; 类的定义为：</target>
        </trans-unit>
        <trans-unit id="da702fa4f893f1ff84ab94ead774536cedcefc5d" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is defined as:</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; 类的定义为：</target>
        </trans-unit>
        <trans-unit id="314c44e92114b49583eff2b98f5eb8171a7374ef" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;IsString&lt;/code&gt; is not in scope by default. If you want to mention it explicitly (for example, to give an instance declaration for it), you can import it from module &lt;code&gt;Data.String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;IsString&lt;/code&gt; 类默认情况下不在范围内。如果要明确提及它（例如，为其提供实例声明），则可以从 &lt;code&gt;Data.String&lt;/code&gt; 模块中导入它。</target>
        </trans-unit>
        <trans-unit id="46c25aa9d510e6dfd769a86618af627836e67d95" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Lift&lt;/code&gt;, unlike other derivable classes, lives in &lt;code&gt;template-haskell&lt;/code&gt; instead of &lt;code&gt;base&lt;/code&gt;. Having a data type be an instance of &lt;code&gt;Lift&lt;/code&gt; permits its values to be promoted to Template Haskell expressions (of type &lt;code&gt;ExpQ&lt;/code&gt;), which can then be spliced into Haskell source code.</source>
          <target state="translated">该类 &lt;code&gt;Lift&lt;/code&gt; ，不像其他衍生类，居住在 &lt;code&gt;template-haskell&lt;/code&gt; ，而不是 &lt;code&gt;base&lt;/code&gt; 。将数据类型作为 &lt;code&gt;Lift&lt;/code&gt; 的实例允许将其值提升为Template Haskell表达式（类型 &lt;code&gt;ExpQ&lt;/code&gt; ），然后可以将其拼接成Haskell源代码。</target>
        </trans-unit>
        <trans-unit id="cfedc7f27395d9e14f3b5dcae9116c684144dba3" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Typeable&lt;/code&gt; is very special:</source>
          <target state="translated">班上 &lt;code&gt;Typeable&lt;/code&gt; 非常特殊：</target>
        </trans-unit>
        <trans-unit id="a352e3bea5c92259e258192deb3bd391cda34543" translate="yes" xml:space="preserve">
          <source>The class instances for sequences are all based very closely on those for lists.</source>
          <target state="translated">序列的类实例都是非常紧密地基于列表的类实例。</target>
        </trans-unit>
        <trans-unit id="f29fdb13c7afe65c971d977ce119c943fb00e75f" translate="yes" xml:space="preserve">
          <source>The class of contravariant functors.</source>
          <target state="translated">反变漏子的类别。</target>
        </trans-unit>
        <trans-unit id="15b84a81fb0f85cb419535a3a61b9ad1d3da02f7" translate="yes" xml:space="preserve">
          <source>The class of monad transformers.</source>
          <target state="translated">单体变压器类。</target>
        </trans-unit>
        <trans-unit id="1aba4d36676a8723cc042f0ef18005b4207f229e" translate="yes" xml:space="preserve">
          <source>The class of monad transformers. Instances should satisfy the following laws, which state that &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; is a monad transformation:</source>
          <target state="translated">monad变压器类。实例应满足以下法律，其中规定： &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 是monad转换：</target>
        </trans-unit>
        <trans-unit id="968994db3d9c45181b57f61fe4736e2627f5c6a6" translate="yes" xml:space="preserve">
          <source>The class of monoids (types with an associative binary operation that has an identity). Instances should satisfy the following:</source>
          <target state="translated">单元类(具有关联二进制操作的类型,有一个身份)。实例应满足以下条件:</target>
        </trans-unit>
        <trans-unit id="80aae29c2b395ab518f6cbf2867e04f61aabbf53" translate="yes" xml:space="preserve">
          <source>The class of semigroups (types with an associative binary operation).</source>
          <target state="translated">半群(具有关联二进制操作的类型)的类。</target>
        </trans-unit>
        <trans-unit id="ef50832e806510cb4bbe9f9aafa22744526d2ab1" translate="yes" xml:space="preserve">
          <source>The class of the instance declaration is not declared in &lt;code&gt;M&lt;/code&gt;, and</source>
          <target state="translated">实例声明的类未在中声明 &lt;code&gt;M&lt;/code&gt; 中，并且</target>
        </trans-unit>
        <trans-unit id="cc31daa90372a8a474d012704a661ac277d958aa" translate="yes" xml:space="preserve">
          <source>The class of types which can be parsed given a UNIX-style time format string.</source>
          <target state="translated">可以解析给定UNIX风格时间格式字符串的类型类别。</target>
        </trans-unit>
        <trans-unit id="380a9b6da5c050f1cf3fa8febdb6d2797a540fc9" translate="yes" xml:space="preserve">
          <source>The closure of the superclass relation over these local axioms : &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</source>
          <target state="translated">这些局部公理上超类关系的闭合： &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 和 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0848f15a7a4cc86662e9097e3f0cf4b1532d9192" translate="yes" xml:space="preserve">
          <source>The code for the method in the instance declaration is typechecked against the type signature supplied in the instance declaration, as you would expect. So if the instance signature is more polymorphic than required, the code must be too.</source>
          <target state="translated">正如你所期望的那样,实例声明中方法的代码会根据实例声明中提供的类型签名进行类型检查。所以,如果实例签名比要求的多态性更强,代码也必须是多态性的。</target>
        </trans-unit>
        <trans-unit id="e5001edd8f78114b36e24d8f0a44754ee90b2f4d" translate="yes" xml:space="preserve">
          <source>The code generator tries to generate as compact layout as possible for each unboxed sum. In the best case, size of an unboxed sum is size of its biggest alternative plus one word (for a tag). The algorithm for generating the memory layout for a sum type works like this:</source>
          <target state="translated">代码生成器会尝试为每个开箱和生成尽可能紧凑的布局。在最好的情况下,一个未装箱和的大小是其最大的选择加上一个字(标记)的大小。为和类型生成内存布局的算法如下。</target>
        </trans-unit>
        <trans-unit id="3837898dd791b811ea7932889c5130e161088d94" translate="yes" xml:space="preserve">
          <source>The code of the &quot;dominant&quot; language of the webpage.</source>
          <target state="translated">网页的 &quot;主导 &quot;语言的代码。</target>
        </trans-unit>
        <trans-unit id="a45302a43608cfe9a77b37998c0a415b8fef0ffc" translate="yes" xml:space="preserve">
          <source>The code should be mostly self-explanatory. The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time. We also explicitly inline the &lt;code&gt;fixed2&lt;/code&gt; primitive, which encodes a fixed tuple of characters, to ensure that the bound computation happens at compile time. When encoding the following list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s, the optimized implementation of &lt;code&gt;renderString&lt;/code&gt; is two times faster.</source>
          <target state="translated">该代码应该是不言自明的。语法稍显尴尬是因为编写了组合器，使得可以在编译时计算出结果 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 的大小范围。我们还明确内联了 &lt;code&gt;fixed2&lt;/code&gt; 原语，该原语对固定的字符元组进行编码，以确保绑定计算在编译时发生。在对以下 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 列表进行编码时， &lt;code&gt;renderString&lt;/code&gt; 的优化实现快两倍。</target>
        </trans-unit>
        <trans-unit id="4421b2e89d7c073b3eeabb7b626aa07e05c2b134" translate="yes" xml:space="preserve">
          <source>The combinators &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt;, etc are all provided with default definitions in terms of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt;, leaving open the opportunity to provide datatype-specific definitions. (The inclusion of the &lt;code&gt;gmap&lt;/code&gt; combinators as members of class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; allows the programmer or the compiler to derive specialised, and maybe more efficient code per datatype. &lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is more higher-order than the &lt;code&gt;gmap&lt;/code&gt; combinators. This is subject to ongoing benchmarking experiments. It might turn out that the &lt;code&gt;gmap&lt;/code&gt; combinators will be moved out of the class &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">组合器 &lt;code&gt;&lt;a href=&quot;data-data#v:gmapT&quot;&gt;gmapT&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQ&quot;&gt;gmapQ&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-data#v:gmapM&quot;&gt;gmapM&lt;/a&gt;&lt;/code&gt; 等都提供了有关 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的默认定义，这为提供特定于数据类型的定义提供了机会。 （将 &lt;code&gt;gmap&lt;/code&gt; 组合器作为 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 类的成员包含在内，可使程序员或编译器为每个数据类型派生专门的，也许效率更高的代码。&lt;em&gt;注意&lt;/em&gt;： &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 比 &lt;code&gt;gmap&lt;/code&gt; 组合器更高级。这有待进行中的基准测试可能会发现 &lt;code&gt;gmap&lt;/code&gt; 组合器将从 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 类中移出。）</target>
        </trans-unit>
        <trans-unit id="8d6f1f7c8a32c8db29cc4151cc5a6c27c5f31776" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the size of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; can be computed at compile time.</source>
          <target state="translated">实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 的组合器，使得结果的大小 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:BoundedPrim&quot;&gt;BoundedPrim&lt;/a&gt;&lt;/code&gt; 可以在编译时计算 BoundedPrim。</target>
        </trans-unit>
        <trans-unit id="b36fb23ba2c0fd5cf9cc5fbcaa48f3fa3936ed5b" translate="yes" xml:space="preserve">
          <source>The combinators for &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s are implemented such that the &lt;code&gt;size&lt;/code&gt; of the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; is computed at compile time.</source>
          <target state="translated">用于组合子 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; s的实现，使得 &lt;code&gt;size&lt;/code&gt; 由此而来的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; 在编译时计算 FixedPrim。</target>
        </trans-unit>
        <trans-unit id="2acc0788b34136669ccf2620396da51b7563e2c2" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt; will show a summary of which modules contribute to the top-level scope.</source>
          <target state="translated">命令 &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt;将显示哪些模块有助于顶层作用域的摘要。</target>
        </trans-unit>
        <trans-unit id="5fdeb122c09642094fcfc48bef6bdcdff89e8605" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step expr&lt;/code&gt;&lt;/a&gt; begins the evaluation of ⟨expr⟩ in single-stepping mode. If ⟨expr⟩ is omitted, then it single-steps from the current breakpoint. &lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt;&lt;code&gt;:steplocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt;&lt;code&gt;:stepmodule&lt;/code&gt;&lt;/a&gt; commands work similarly.</source>
          <target state="translated">&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step expr&lt;/code&gt; &lt;/a&gt;命令以单步模式开始计算&amp;ldquo; expr&amp;rdquo;。如果省略&amp;ldquo; expr&amp;rdquo;，则它从当前断点开始单步执行。&lt;a href=&quot;#ghci-cmd-:steplocal&quot;&gt; &lt;code&gt;:steplocal&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghci-cmd-:stepmodule&quot;&gt; &lt;code&gt;:stepmodule&lt;/code&gt; &lt;/a&gt;命令的工作原理类似。</target>
        </trans-unit>
        <trans-unit id="a632ebd88f50b8ac78cacda34b5408a0be9ab51c" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:break 2&lt;/code&gt; sets a breakpoint on line 2 of the most recently-loaded module, in this case &lt;code&gt;qsort.hs&lt;/code&gt;. Specifically, it picks the leftmost complete subexpression on that line on which to set the breakpoint, which in this case is the expression &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt;.</source>
          <target state="translated">命令 &lt;code&gt;:break 2&lt;/code&gt; 在最近加载的模块的第2行设置断点，在本例中为 &lt;code&gt;qsort.hs&lt;/code&gt; 。具体来说，它在要设置断点的那一行上选择最左边的完整子表达式，在这种情况下，它是表达式 &lt;code&gt;(qsort left ++ [a] ++ qsort right)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e40dd230e05a9e07fe62ec45624d094d383aa421" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;:info!&lt;/code&gt; works in a similar fashion but it removes restriction (b), showing all instances that are in scope and mention ⟨name⟩ in their head.</source>
          <target state="translated">命令 &lt;code&gt;:info!&lt;/code&gt; 以类似的方式工作，但它消除了限制（b），显示了范围内的所有实例，并在其头部提到了&amp;ldquo;名称&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="db3abb134ad672048db99caf88a85888bde3b864" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; finds the end of every complete sample in &lt;code&gt;FOO.hp&lt;/code&gt;, and labels each sample with its ending line number. We then select the line number of the last complete sample using &lt;strong&gt;tail&lt;/strong&gt; and &lt;strong&gt;cut&lt;/strong&gt;. This is used as a parameter to &lt;strong&gt;head&lt;/strong&gt;; the result is as if we deleted the final incomplete sample from &lt;code&gt;FOO.hp&lt;/code&gt;. This results in a properly-formatted .hp file which we feed directly to &lt;strong&gt;hp2ps&lt;/strong&gt;.</source>
          <target state="translated">命令 &lt;code&gt;fgrep -n END_SAMPLE FOO.hp&lt;/code&gt; 在FOO.hp中查找每个完整样本的 &lt;code&gt;FOO.hp&lt;/code&gt; ，并用其结束行号标记每个样本。然后，我们使用&lt;strong&gt;tail&lt;/strong&gt;和&lt;strong&gt;cut&lt;/strong&gt;选择最后一个完整样本的行号。用作&lt;strong&gt;head&lt;/strong&gt;的参数;结果就像我们从 &lt;code&gt;FOO.hp&lt;/code&gt; 中删除了最终的不完整样本一样。这样会生成格式正确的.hp文件，我们可以直接将其&lt;strong&gt;输入hp2ps&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="270408c21f336615635c1e2a2c6f2941c9ac84d6" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the program</source>
          <target state="translated">传递给程序的命令行参数</target>
        </trans-unit>
        <trans-unit id="e7e794e0f93c2fa925b60afdb7fbdedb64d80c09" translate="yes" xml:space="preserve">
          <source>The command line arguments passed to the runtime system</source>
          <target state="translated">传递给运行时系统的命令行参数。</target>
        </trans-unit>
        <trans-unit id="77b364d49a3dfa5e15b2ed62d447248ab845ef6f" translate="yes" xml:space="preserve">
          <source>The command to run, which must be in the $PATH, or an absolute or relative path</source>
          <target state="translated">要运行的命令,必须在$PATH中,或绝对或相对路径中。</target>
        </trans-unit>
        <trans-unit id="a9eb0075b8efba5d950b353dc2ba8dd18856c0b6" translate="yes" xml:space="preserve">
          <source>The command versions of lambda abstraction and application are analogous to the expression versions. In particular, the beta and eta rules describe equivalences of commands. These three features (operators, lambda abstraction and application) are the core of the notation; everything else can be built using them, though the results would be somewhat clumsy. For example, we could simulate &lt;code&gt;do&lt;/code&gt;-notation by defining</source>
          <target state="translated">lambda抽象和应用程序的命令版本类似于表达式版本。特别是，beta和eta规则描述了命令的等效性。这三个功能（运算符，lambda抽象和应用程序）是符号的核心。可以使用它们构建其他所有内容，尽管结果有些笨拙。例如，我们可以模拟 &lt;code&gt;do&lt;/code&gt; -notation定义</target>
        </trans-unit>
        <trans-unit id="8a1e2c9e679e0ed25e609bb32dccdb1dffa31a77" translate="yes" xml:space="preserve">
          <source>The comparable symbols for other systems are: &lt;code&gt;__HUGS__&lt;/code&gt; for Hugs, &lt;code&gt;__NHC__&lt;/code&gt; for nhc98, and &lt;code&gt;__HBC__&lt;/code&gt; for hbc).</source>
          <target state="translated">其他系统的可比较符号是： &lt;code&gt;__HUGS__&lt;/code&gt; 表示拥抱， &lt;code&gt;__NHC__&lt;/code&gt; 表示nhc98和 &lt;code&gt;__HBC__&lt;/code&gt; 表示hbc）。</target>
        </trans-unit>
        <trans-unit id="b172d1caf74bb5840fcb833db8910b15eee4ccf4" translate="yes" xml:space="preserve">
          <source>The compiler does not overwrite an existing &lt;code&gt;.hi&lt;/code&gt; interface file if the new one is the same as the old one; this is friendly to &lt;strong&gt;make&lt;/strong&gt;. When an interface does change, it is often enlightening to be informed. The &lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt;&lt;code&gt;-ddump-hi-diffs&lt;/code&gt;&lt;/a&gt; option will make GHC report the differences between the old and new &lt;code&gt;.hi&lt;/code&gt; files.</source>
          <target state="translated">如果新的 &lt;code&gt;.hi&lt;/code&gt; 接口文件与旧的.hi接口文件相同，则编译器不会覆盖该文件。这是友好的&lt;strong&gt;制造&lt;/strong&gt;。当界面确实发生变化时，经常会得到启发。该&lt;a href=&quot;#ghc-flag--ddump-hi-diffs&quot;&gt; &lt;code&gt;-ddump-hi-diffs&lt;/code&gt; &lt;/a&gt;选项将使GHC报告新老之间的差异 &lt;code&gt;.hi&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="b50c4e0495b638bc78f832720f50e287f9de7a05" translate="yes" xml:space="preserve">
          <source>The compiler infers that the field is lazy, so it is tagged with &lt;code&gt;'DecidedLazy&lt;/code&gt;. Bear in mind that what the compiler decides may be quite different from what is written in the source. See &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; for a more detailed explanation.</source>
          <target state="translated">编译器推断该字段是惰性的，因此将其标记为 &lt;code&gt;'DecidedLazy&lt;/code&gt; 。请记住，编译器决定的内容可能与源代码中编写的内容完全不同。参见 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:DecidedStrictness&quot;&gt;DecidedStrictness&lt;/a&gt;&lt;/code&gt; 更多详细说明，。</target>
        </trans-unit>
        <trans-unit id="9774a668aa7877058c555311f9fc25aa40959a13" translate="yes" xml:space="preserve">
          <source>The compiler version can be tested within compiled code with the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP macro (defined only when &lt;a href=&quot;phases#extension-CPP&quot;&gt;&lt;code&gt;-XCPP&lt;/code&gt;&lt;/a&gt; is used). See &lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;Standard CPP macros&lt;/a&gt; for details.</source>
          <target state="translated">可以使用 &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; CPP宏（仅在使用&lt;a href=&quot;phases#extension-CPP&quot;&gt; &lt;code&gt;-XCPP&lt;/code&gt; &lt;/a&gt;时定义）在编译的代码中测试编译器版本。有关详情，请参见&lt;a href=&quot;phases#standard-cpp-macros&quot;&gt;标准CPP宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d31425166e0b9b41d209465f54952b68c26f02ba" translate="yes" xml:space="preserve">
          <source>The compiler will avoid reboxing &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt; by inlining &lt;code&gt;+&lt;/code&gt; on floats, but only when &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">编译器将通过在浮点数上内联 &lt;code&gt;+&lt;/code&gt; 来避免对 &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;f2&lt;/code&gt; 重新装箱，但仅当&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;处于打开状态时。</target>
        </trans-unit>
        <trans-unit id="a57eab48089d44200f2aa63903639e1a99c72105" translate="yes" xml:space="preserve">
          <source>The compiler will warn here that the deriving clause doesn&amp;rsquo;t specify a strategy. If the warning is enabled, but &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; is not enabled, the compiler will suggest turning on the &lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; extension. This option is not on by default, having to be turned on manually or with &lt;a href=&quot;#ghc-flag--Weverything&quot;&gt;&lt;code&gt;-Weverything&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">编译器将在此处警告派生子句未指定策略。如果启用了警告，但未启用&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;，则编译器将建议打开&lt;a href=&quot;glasgow_exts#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;扩展。该选项默认情况下未启用，必须手动或使用&lt;a href=&quot;#ghc-flag--Weverything&quot;&gt; &lt;code&gt;-Weverything&lt;/code&gt; 启用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="281ed5525515ea0993e70db30ed197e71b26abff" translate="yes" xml:space="preserve">
          <source>The complete user-supplied kind signature specifies the polymorphic kind for &lt;code&gt;T&lt;/code&gt;, and this signature is used for all the calls to &lt;code&gt;T&lt;/code&gt; including the recursive ones. In particular, the recursive use of &lt;code&gt;T&lt;/code&gt; is at kind &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">用户提供的完整种类签名指定了 &lt;code&gt;T&lt;/code&gt; 的多态种类，并且该签名用于所有对 &lt;code&gt;T&lt;/code&gt; 的调用，包括递归调用。特别地， &lt;code&gt;T&lt;/code&gt; 的递归使用是 &lt;code&gt;Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2bfd3d94f53069effc94df0d648f9c72f750ccc" translate="yes" xml:space="preserve">
          <source>The comprehension should typecheck when its desugaring would typecheck, except that (as discussed in &lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;Generalised (SQL-like) List Comprehensions&lt;/a&gt;) in the &amp;ldquo;then &lt;code&gt;f&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;f&lt;/code&gt;&amp;rdquo; clauses, when the &amp;ldquo;by &lt;code&gt;b&lt;/code&gt;&amp;rdquo; qualifier is omitted, argument &lt;code&gt;f&lt;/code&gt; should have a polymorphic type. In particular, &amp;ldquo;then &lt;code&gt;Data.List.sort&lt;/code&gt;&amp;rdquo; and &amp;ldquo;then group using &lt;code&gt;Data.List.group&lt;/code&gt;&amp;rdquo; are insufficiently polymorphic.</source>
          <target state="translated">理解力应该在进行类型检查时进行类型检查，除了（如在&lt;a href=&quot;#generalised-list-comprehensions&quot;&gt;通用（类似SQL的）列表解释中&lt;/a&gt;所讨论的）&amp;ldquo; then &lt;code&gt;f&lt;/code&gt; &amp;rdquo;和&amp;ldquo; then group using &lt;code&gt;f&lt;/code&gt; &amp;rdquo;子句中所述（当省略&amp;ldquo; by &lt;code&gt;b&lt;/code&gt; &amp;rdquo;限定词时，参数 &lt;code&gt;f&lt;/code&gt; 应该具有多态类型。特别是，&amp;ldquo; then &lt;code&gt;Data.List.sort&lt;/code&gt; &amp;rdquo;和&amp;ldquo; then using &lt;code&gt;Data.List.group&lt;/code&gt; &amp;rdquo;的多态性不足。</target>
        </trans-unit>
        <trans-unit id="e59db8b8873fb6251bff5cd6dfad77bf9b5938cd" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; 的计算与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 相同，只不过它仅在 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 上起作用。</target>
        </trans-unit>
        <trans-unit id="cebda4e55c3afba7a9d7719124e3ada63e52bb27" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;prelude#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 函数将字符串 &lt;code&gt;str&lt;/code&gt; 追加到文件 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46965f614145fd2e0bb961350e8543a37e0dd3ca" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;prelude#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 函数将字符串 &lt;code&gt;str&lt;/code&gt; 写入文件 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4547aaf52f671ee4d0ac2c8d5630bfc87a6e62" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-cmd#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 的方式运行操作系统命令 &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; ，以使其完全按照给定的方式接收 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 字符串作为参数，而不会进行有趣的转义或shell元语法扩展。因此，它在操作系统之间的行为将比 &lt;code&gt;&lt;a href=&quot;system-cmd#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 更可移植。</target>
        </trans-unit>
        <trans-unit id="a9a90ff37849eb4211f81461b5303f42712fea0c" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; ，其中&lt;em&gt;exitfail&lt;/em&gt;与实现有关。</target>
        </trans-unit>
        <trans-unit id="fc29dbc900c1c24c106776b04df9bca05e5cfe6e" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt;&lt;em&gt;exitfail&lt;/em&gt;&lt;code&gt;)&lt;/code&gt;, where &lt;em&gt;exitfail&lt;/em&gt; is implementation-dependent.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt;&lt;/code&gt; &lt;em&gt; exitfail &lt;/em&gt; &lt;code&gt;)&lt;/code&gt; ，其中&lt;em&gt;exitfail&lt;/em&gt;与实现有关。</target>
        </trans-unit>
        <trans-unit id="fb6d36ed658ece003695ded60aa84d344703fa74" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;, It terminates the program successfully.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitSuccess&quot;&gt;exitSuccess&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitWith&quot;&gt;exitWith&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; ，它成功终止程序。</target>
        </trans-unit>
        <trans-unit id="a4d04e67ce9ab76c0bbbdea2ad0f01cd7fcbeeb5" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function appends the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-io#v:appendFile&quot;&gt;appendFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 函数将字符串 &lt;code&gt;str&lt;/code&gt; 追加到文件 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d116851ac5689419eab11fff58738d4aba225b" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; is identical to &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt;, except that it works only on &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system-io#v:isEOF&quot;&gt;isEOF&lt;/a&gt;&lt;/code&gt; 的计算与 &lt;code&gt;&lt;a href=&quot;system-io#v:hIsEOF&quot;&gt;hIsEOF&lt;/a&gt;&lt;/code&gt; 相同，只不过它仅在 &lt;code&gt;&lt;a href=&quot;system-io#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 上起作用。</target>
        </trans-unit>
        <trans-unit id="46ebfbedadd3b348e49908c00c7a136ae0a3b598" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt;&lt;code&gt;file str&lt;/code&gt; function writes the string &lt;code&gt;str&lt;/code&gt;, to the file &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-io#v:writeFile&quot;&gt;writeFile&lt;/a&gt;&lt;/code&gt; &lt;code&gt;file str&lt;/code&gt; 函数将字符串 &lt;code&gt;str&lt;/code&gt; 写入文件 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="beccc8e7666a74c9241e66c916390d713f7e9a28" translate="yes" xml:space="preserve">
          <source>The computation &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; runs the operating system command &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; in such a way that it receives as arguments the &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; strings exactly as given, with no funny escaping or shell meta-syntax expansion. It will therefore behave more portably between operating systems than &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;&lt;a href=&quot;system-process#v:rawSystem&quot;&gt;rawSystem&lt;/a&gt; &lt;em&gt;cmd&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 的方式运行操作系统命令 &lt;code&gt;&lt;em&gt;cmd&lt;/em&gt;&lt;/code&gt; ，以使其完全按照给定的方式接收 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 字符串作为参数，而不会进行有趣的转义或shell元语法扩展。因此，它在操作系统之间的行为将比 &lt;code&gt;&lt;a href=&quot;system-process#v:system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 更可移植。</target>
        </trans-unit>
        <trans-unit id="5f1a05335883c13dae3be1b4a36833b306a5efd1" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该计算可以由不同的线程（可能同时）执行多次。为确保计算仅执行一次，请改用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44b39b2d94fcf4d161bbbadc2ba27b97f45eae93" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To ensure that the computation is performed only once, use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该计算可以由不同的线程（可能同时）执行多次。为确保计算仅执行一次，请改用 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="add1c55634d2623f9699ebad8b5515dd2d17e5c6" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该计算可以由不同的线程（可能同时）执行多次。为防止这种情况，请改用 &lt;code&gt;&lt;a href=&quot;control-monad-st-unsafe#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07d17cfabe3f3fcfca85238e3259375c3de9c784" translate="yes" xml:space="preserve">
          <source>The computation may be performed multiple times by different threads, possibly at the same time. To prevent this, use &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该计算可以由不同的线程（可能同时）执行多次。为防止这种情况，请改用 &lt;code&gt;&lt;a href=&quot;ghc-st#v:unsafeInterleaveST&quot;&gt;unsafeInterleaveST&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52f9695a125810fcb1729c58e4b509090979268c" translate="yes" xml:space="preserve">
          <source>The computation to run</source>
          <target state="translated">要运行的计算</target>
        </trans-unit>
        <trans-unit id="7849b8b63ccfaa0ec4dad86a18080d47939b33fc" translate="yes" xml:space="preserve">
          <source>The concatenation of all the elements of a container of lists.</source>
          <target state="translated">列表容器中所有元素的连接。</target>
        </trans-unit>
        <trans-unit id="511dfe8f476504df65281a958ed6b2922f8e44b9" translate="yes" xml:space="preserve">
          <source>The concurrency extension for Haskell is described in the paper &lt;em&gt;Concurrent Haskell&lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;.</source>
          <target state="translated">Haskell的并发扩展在&lt;em&gt;Concurrent Haskell &lt;/em&gt;&lt;a href=&quot;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&quot;&gt;http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz&lt;/a&gt;中进行了描述。</target>
        </trans-unit>
        <trans-unit id="00393330d59cb21f77b62b7a951195b4749b08f5" translate="yes" xml:space="preserve">
          <source>The conjugate of a complex number.</source>
          <target state="translated">复数的共轭。</target>
        </trans-unit>
        <trans-unit id="7e61d83010032d16fcd6d96bc1ee67e74abc2ee7" translate="yes" xml:space="preserve">
          <source>The connected components of a graph. Two vertices are connected if there is a path between them, traversing edges in either direction.</source>
          <target state="translated">图的连接成分。如果两个顶点之间有一条路径,在任何一个方向上都可以遍历边缘,那么这两个顶点就是相连的。</target>
        </trans-unit>
        <trans-unit id="b5b6ceffe39d0d5eedc736955541b7ffa6430ede" translate="yes" xml:space="preserve">
          <source>The cons constructor (e.g &lt;code&gt;3:4:[]&lt;/code&gt;)</source>
          <target state="translated">缺点构造函数（例如 &lt;code&gt;3:4:[]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8ba3b2a290b55dc2fc0d0d6af5a22e45514ed39e" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">恒定 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; 包含的一个杰出的值 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 不与一个有效的存储器位置相关联。</target>
        </trans-unit>
        <trans-unit id="28d23ff9245e92f331af466af03ff314f5479be2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">常量 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 包含与有效内存位置无关的 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的专有值。</target>
        </trans-unit>
        <trans-unit id="9836a72bb97f8856c19c64a657d43deda4d232f2" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">恒定 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullFunPtr&quot;&gt;nullFunPtr&lt;/a&gt;&lt;/code&gt; 包含的一个杰出的值 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 不与一个有效的存储器位置相关联。</target>
        </trans-unit>
        <trans-unit id="f76a0e137f54f18c3f7ac1708ea489f83a12cf45" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">常量 &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 包含与有效内存位置无关的 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的专有值。</target>
        </trans-unit>
        <trans-unit id="86d0acfb8c600d07e3b3575390f9c70049148847" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">常量 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 包含与有效内存位置无关的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的专有值。</target>
        </trans-unit>
        <trans-unit id="aee9b6f259cc959b36e11590eea5cb4db85f0c33" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; contains a distinguished value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; that is not associated with a valid memory location.</source>
          <target state="translated">常量 &lt;code&gt;&lt;a href=&quot;system-win32-types#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; 包含与有效内存位置无关的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 的专有值。</target>
        </trans-unit>
        <trans-unit id="799dc66320c38ca69a9441401db6bffcbf9eb360" translate="yes" xml:space="preserve">
          <source>The constant functor.</source>
          <target state="translated">常量漏斗。</target>
        </trans-unit>
        <trans-unit id="15ca88cd220e51ba407b106275a1029cb4b766e9" translate="yes" xml:space="preserve">
          <source>The constraint &lt;code&gt;Coercible t1 t2&lt;/code&gt; is similar to &lt;code&gt;t1 ~ t2&lt;/code&gt;, but denotes representational equality between &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; in the sense of Roles (&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;). It is exported by &lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;, which also contains the documentation. More details and discussion can be found in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;Safe Coercions&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">约束 &lt;code&gt;Coercible t1 t2&lt;/code&gt; 类似于 &lt;code&gt;t1 ~ t2&lt;/code&gt; ，但表示之间代表性平等 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; 在角色（感&lt;a href=&quot;#roles&quot;&gt;作用&lt;/a&gt;）。它由&lt;a href=&quot;../libraries/base-4.13.0.0/data-coerce&quot;&gt;Data.Coerce&lt;/a&gt;导出，其中也包含文档。更多细节和讨论可以在论文&lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf&quot;&gt;&amp;ldquo;安全强迫&amp;rdquo;中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b45d0e4831d974f0b76095cef9bc4b87f2ec6bb" translate="yes" xml:space="preserve">
          <source>The constraint has fewer constructors and variables (taken together and counting repetitions) than the head</source>
          <target state="translated">约束的构造函数和变量(合起来算重复)比头部少</target>
        </trans-unit>
        <trans-unit id="a50d755f429fad42bcff479620bc13360a0c4b46" translate="yes" xml:space="preserve">
          <source>The constraint mentions at least one type variable. So this is allowed:</source>
          <target state="translated">约束条件中至少提到了一个类型变量。所以这是允许的。</target>
        </trans-unit>
        <trans-unit id="ce649c6fe844bb02501d53bdc8fcdcf10a388961" translate="yes" xml:space="preserve">
          <source>The constraint mentions no type functions. A type function application can in principle expand to a type of arbitrary size, and so are rejected out of hand</source>
          <target state="translated">该约束没有提到类型函数。原则上,类型函数的应用可以扩展到任意大小的类型,因此被直接拒绝。</target>
        </trans-unit>
        <trans-unit id="e1443e2e18615f60be07422db9598a6ab2679217" translate="yes" xml:space="preserve">
          <source>The constraints: &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</source>
          <target state="translated">约束： &lt;code&gt;(C1, C2, ..)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112775bf1168cc3582de7a46d153e201b0ce10f8" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">构造 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; 公开了在计算中发生的，未完全处理的IO错误。</target>
        </trans-unit>
        <trans-unit id="f2cbf6e1527ac15029debb90371be54661016768" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt;&lt;code&gt;comp&lt;/code&gt; exposes IO errors which occur within a computation, and which are not fully handled.</source>
          <target state="translated">构造 &lt;code&gt;&lt;a href=&quot;system-io-error#v:tryIOError&quot;&gt;tryIOError&lt;/a&gt;&lt;/code&gt; &lt;code&gt;comp&lt;/code&gt; 公开了在计算中发生的，未完全处理的IO错误。</target>
        </trans-unit>
        <trans-unit id="d9cb341bdfdb67d6c8abafd06a4a86c8917f60b5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 的构造函数大致可分为两类：带有&amp;ldquo;香草&amp;rdquo;语法的构造函数（ &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ），以及带有GADT语法的构造函数（ &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。量化其他类型变量和类上下文的 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 构造函数可以围绕两种构造函数。但是，根据使用的构造函数语法，它量化的类型变量是不同的：</target>
        </trans-unit>
        <trans-unit id="96dfdfe1a048f1f49896be9e99d5931a975888f5" translate="yes" xml:space="preserve">
          <source>The constructors for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; can roughly be divided up into two categories: those for constructors with &quot;vanilla&quot; syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt;), and those for constructors with GADT syntax (&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt;). The &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; constructor, which quantifies additional type variables and class contexts, can surround either variety of constructor. However, the type variables that it quantifies are different depending on what constructor syntax is used:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Con&quot;&gt;Con&lt;/a&gt;&lt;/code&gt; 的构造函数大致可分为两类：带有&amp;ldquo;香草&amp;rdquo;语法的构造函数（ &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:NormalC&quot;&gt;NormalC&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecC&quot;&gt;RecC&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:InfixC&quot;&gt;InfixC&lt;/a&gt;&lt;/code&gt; ），以及带有GADT语法的构造函数（ &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:GadtC&quot;&gt;GadtC&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:RecGadtC&quot;&gt;RecGadtC&lt;/a&gt;&lt;/code&gt; ）。量化其他类型变量和类上下文的 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; 构造函数可以围绕两种构造函数。但是，根据使用的构造函数语法，它量化的类型变量是不同的：</target>
        </trans-unit>
        <trans-unit id="d2ef5f16504fcf65ef460021616315706e1e4d2a" translate="yes" xml:space="preserve">
          <source>The constructors have rank-2 types:</source>
          <target state="translated">构造函数有等级2的类型。</target>
        </trans-unit>
        <trans-unit id="f9e51adba83704f5afe34590e66e2249e5965154" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;OPTIONS_GHC&lt;/code&gt; are appended to the command-line options, so options given in the source file override those given on the command-line.</source>
          <target state="translated">&lt;code&gt;OPTIONS_GHC&lt;/code&gt; 的内容被附加到命令行选项中，因此源文件中给定的选项会覆盖命令行上给定的选项。</target>
        </trans-unit>
        <trans-unit id="dff9227ff63668c69518bca492a298e49c135a62" translate="yes" xml:space="preserve">
          <source>The contents of this module is liable to change, or disappear entirely. Please &lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;let me know&lt;/a&gt; if you depend on anything here.</source>
          <target state="translated">该模块的内容可能会更改或完全消失。如果您依赖这里的任何东西，请&lt;a href=&quot;https://github.com/haskell/time/issues/new&quot;&gt;告诉我&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a40246a3e18d1d7e41c15d6857dbf0b4d63fa72" translate="yes" xml:space="preserve">
          <source>The contents of this module may change &lt;strong&gt;in any way whatsoever&lt;/strong&gt; and &lt;strong&gt;without any warning&lt;/strong&gt; between minor versions of this package.</source>
          <target state="translated">&lt;strong&gt;在&lt;/strong&gt;此软件包的次要版本之间，此模块的内容可能会&lt;strong&gt;以任何方式&lt;/strong&gt;更改&lt;strong&gt;，&lt;/strong&gt;而&lt;strong&gt;不会发出任何警告&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="bf37f21b6a3daad2c6c95d66502066032ad944e9" translate="yes" xml:space="preserve">
          <source>The continuation monad transformer. Can be used to add continuation handling to any type constructor: the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; instance and most of the operations do not require &lt;code&gt;m&lt;/code&gt; to be a monad.</source>
          <target state="translated">延续monad变压器。可用于向任何类型构造函数添加连续处理： &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; 实例和大多数操作不需要 &lt;code&gt;m&lt;/code&gt; 成为monad。</target>
        </trans-unit>
        <trans-unit id="f75193e312873c254935fbb8e4b2cdc1397df81b" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;makeAbsolute&lt;/code&gt; function can be found in &lt;code&gt;System.Directory&lt;/code&gt;.</source>
          <target state="translated">可以在 &lt;code&gt;System.Directory&lt;/code&gt; 中找到相应的 &lt;code&gt;makeAbsolute&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="fbffcb96186edf6acc0b855b93198f4a5cdf1151" translate="yes" xml:space="preserve">
          <source>The corresponding translation for an IO-typed &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">对应的翻译为IO类型的 &lt;code&gt;e&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="86d8b09707b93cf768c10a7d141f2453f73455d0" translate="yes" xml:space="preserve">
          <source>The costs of all CAFs in a module are usually attributed to one &amp;ldquo;big&amp;rdquo; CAF cost-centre. With this option, all CAFs get their own cost-centre. An &amp;ldquo;if all else fails&amp;rdquo; option&amp;hellip;</source>
          <target state="translated">模块中所有CAF的成本通常归因于一个&amp;ldquo;大型&amp;rdquo; CAF成本中心。使用此选项，所有CAF都有自己的成本中心。&amp;ldquo;如果其他所有方法都失败&amp;rdquo;的选项&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="7cf65e46a7de9baa89f7b3eb6db073c4649dd328" translate="yes" xml:space="preserve">
          <source>The cumulative allocations of the program in bytes.</source>
          <target state="translated">程序的累计分配量,单位为字节。</target>
        </trans-unit>
        <trans-unit id="7a3b930a34c98c0e41a7bef5730a3bbf42841f7f" translate="yes" xml:space="preserve">
          <source>The current implementation of the &lt;code&gt;OverloadedLists&lt;/code&gt; extension can be improved by handling the lists that are only populated with literals in a special way. More specifically, the compiler could allocate such lists statically using a compact representation and allow &lt;code&gt;IsList&lt;/code&gt; instances to take advantage of the compact representation. Equipped with this capability the &lt;code&gt;OverloadedLists&lt;/code&gt; extension will be in a good position to subsume the &lt;code&gt;OverloadedStrings&lt;/code&gt; extension (currently, as a special case, string literals benefit from statically allocated compact representation).</source>
          <target state="translated">通过处理以特殊方式仅填充文字的列表，可以改进 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展的当前实现。更具体地说，编译器可以使用紧凑表示形式静态分配此类列表，并允许 &lt;code&gt;IsList&lt;/code&gt; 实例利用紧凑表示形式。具备此功能的 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展将很适合使用 &lt;code&gt;OverloadedStrings&lt;/code&gt; 扩展（当前，作为一种特殊情况，字符串文字受益于静态分配的紧凑表示形式）。</target>
        </trans-unit>
        <trans-unit id="1ad91c37c3debcd3611b7e9c0f27ffd87d2d02eb" translate="yes" xml:space="preserve">
          <source>The current notion of when two view pattern expressions are &amp;ldquo;the same&amp;rdquo; is very restricted: it is not even full syntactic equality. However, it does include variables, literals, applications, and tuples; e.g., two instances of &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; will be collected. However, the current implementation does not compare up to alpha-equivalence, so two instances of &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; will not be coalesced.</source>
          <target state="translated">当前的两个视图模式表达式何时&amp;ldquo;相同&amp;rdquo;的概念非常受限制：它甚至不是完全的语法相等。但是，它确实包含变量，文字，应用程序和元组。例如，将收集 &lt;code&gt;view (&quot;hi&quot;, &quot;there&quot;)&lt;/code&gt; 两个实例（&amp;ldquo; hi&amp;rdquo;，&amp;ldquo; there&amp;rdquo;）。但是，当前实现最多不能与alpha等价进行比较，因此 &lt;code&gt;(x, view x -&amp;gt; y)&lt;/code&gt; 两个实例将不会合并。</target>
        </trans-unit>
        <trans-unit id="2a1a29ae3433386a16c919320319cfdd85da4c46" translate="yes" xml:space="preserve">
          <source>The current status of a thread</source>
          <target state="translated">线程的当前状态</target>
        </trans-unit>
        <trans-unit id="82c826fe4c2ec0dd5e2b6732f42c3a1009fa7e05" translate="yes" xml:space="preserve">
          <source>The current thread's stack exceeded its limit. Since an exception has been raised, the thread's stack will certainly be below its limit again, but the programmer should take remedial action immediately.</source>
          <target state="translated">当前线程的堆栈超过了它的极限。既然已经引发了异常,那么线程的堆栈肯定会再次低于其极限,但程序员应该立即采取补救措施。</target>
        </trans-unit>
        <trans-unit id="ed3b026bad78c443d4533994012a8c4a2846cb3c" translate="yes" xml:space="preserve">
          <source>The current value of the &lt;code&gt;-N&lt;/code&gt; option is available to the Haskell program via &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt;, and it may be changed while the program is running by calling &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-N&lt;/code&gt; 选项的当前值可通过 &lt;code&gt;Control.Concurrent.getNumCapabilities&lt;/code&gt; 提供给Haskell程序，并且可以在程序运行时通过调用 &lt;code&gt;Control.Concurrent.setNumCapabilities&lt;/code&gt; 对其进行更改。</target>
        </trans-unit>
        <trans-unit id="9ec8f77a94455e151e4c1a9e7ec7c517542a0b66" translate="yes" xml:space="preserve">
          <source>The cut-down Haskell lexer, used by Text.Read</source>
          <target state="translated">Text.Read使用的缩减版Haskell词典。</target>
        </trans-unit>
        <trans-unit id="00bd3d9662d83ac9ec53f0ae935356d4eabc4566" translate="yes" xml:space="preserve">
          <source>The data family &lt;code&gt;URec&lt;/code&gt; is provided to enable generic programming over datatypes with certain unlifted arguments. There are six instances corresponding to common unlifted types:</source>
          <target state="translated">提供了数据族 &lt;code&gt;URec&lt;/code&gt; 来启用具有某些未提升参数的数据类型的通用编程。有六个实例与常见的非提升类型相对应：</target>
        </trans-unit>
        <trans-unit id="7cc312cbbdd186a59028317a6d6a5545651161f0" translate="yes" xml:space="preserve">
          <source>The data or type family instance for an associated type must follow the rule that the type indexes corresponding to class parameters must have precisely the same as type given in the instance head. For example:</source>
          <target state="translated">关联类型的数据或类型族实例必须遵循这样的规则:类参数对应的类型索引必须与实例头给出的类型完全相同。例如:</target>
        </trans-unit>
        <trans-unit id="5c9753438fba7e9bfbfa96374f6632d59b89893a" translate="yes" xml:space="preserve">
          <source>The data type &lt;code&gt;Foo&lt;/code&gt; has two constructors with types:</source>
          <target state="translated">数据类型 &lt;code&gt;Foo&lt;/code&gt; 具有两个类型的构造函数：</target>
        </trans-unit>
        <trans-unit id="e622f9e9a73471a6364b9efb8251bd756d0f5650" translate="yes" xml:space="preserve">
          <source>The data type invariant for lazy &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;: Every &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; is either &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">惰性 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 的数据类型不变：每个 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 要么为 &lt;code&gt;&lt;a href=&quot;data-text-internal-lazy#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; 要么由非null的 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 组成。所有功能都必须保留这一点，并且QC属性必须对此进行检查。</target>
        </trans-unit>
        <trans-unit id="5d0441bbee470c2143c8f36a2d1679d26b7e70ba" translate="yes" xml:space="preserve">
          <source>The data type invariant: Every ByteString is either &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; or consists of non-null &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. All functions must preserve this, and the QC properties must check this.</source>
          <target state="translated">数据类型不变：每个ByteString要么为 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-internal#v:Empty&quot;&gt;Empty&lt;/a&gt;&lt;/code&gt; 要么由非null的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 组成。所有功能都必须保留这一点，并且QC属性必须对此进行检查。</target>
        </trans-unit>
        <trans-unit id="7d85f04588f07b22aadb87552b730e4cf6174d81" translate="yes" xml:space="preserve">
          <source>The data types and monadic constructor functions for Template Haskell are in the library &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt;.</source>
          <target state="translated">Template Haskell的数据类型和monadic构造函数在库 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="65cb9fa712c4ef1743587a031048fc3377115bf6" translate="yes" xml:space="preserve">
          <source>The datatype below derives the &lt;code&gt;Eq&lt;/code&gt; typeclass, but doesn&amp;rsquo;t specify a strategy. When &lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt;&lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt;&lt;/a&gt; is enabled, the compiler will emit a warning about this.</source>
          <target state="translated">以下数据类型派生 &lt;code&gt;Eq&lt;/code&gt; 类型类，但未指定策略。当&lt;a href=&quot;#ghc-flag--Wmissing-deriving-strategies&quot;&gt; &lt;code&gt;-Wmissing-deriving-strategies&lt;/code&gt; &lt;/a&gt;启用，编译器会发出这个警告。</target>
        </trans-unit>
        <trans-unit id="09ea5a667a11159497b7db70c8ac2393a6a6a569" translate="yes" xml:space="preserve">
          <source>The day of the epoch of &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt;, 1970-01-01</source>
          <target state="translated">的划时代的一天 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#t:SystemTime&quot;&gt;SystemTime&lt;/a&gt;&lt;/code&gt; ，1970-01-01</target>
        </trans-unit>
        <trans-unit id="425505b50ca94bcb223c9489d59b624f0fd02138" translate="yes" xml:space="preserve">
          <source>The debugger provides the following:</source>
          <target state="translated">调试器提供了以下功能。</target>
        </trans-unit>
        <trans-unit id="d008597f45a1f7e417f2daa3afa26ed473de0e47" translate="yes" xml:space="preserve">
          <source>The debugging options &lt;code&gt;-Dx&lt;/code&gt; also generate events which are logged using the tracing framework. By default those events are dumped as text to stdout (&lt;code&gt;-Dx&lt;/code&gt; implies &lt;code&gt;-v&lt;/code&gt;), but they may instead be stored in the binary eventlog file by using the &lt;code&gt;-l&lt;/code&gt; option.</source>
          <target state="translated">调试选项 &lt;code&gt;-Dx&lt;/code&gt; 还会生成使用跟踪框架记录的事件。缺省情况下，这些事件会作为文本转储到stdout（ &lt;code&gt;-Dx&lt;/code&gt; 表示 &lt;code&gt;-v&lt;/code&gt; ），但是可以使用 &lt;code&gt;-l&lt;/code&gt; 选项将其存储在二进制事件日志文件中。</target>
        </trans-unit>
        <trans-unit id="8dbf33fb940a3d9f2a5b57f121f6732a25396c40" translate="yes" xml:space="preserve">
          <source>The declaration</source>
          <target state="translated">宣言</target>
        </trans-unit>
        <trans-unit id="61598f72e2c92204906e453b4899d9c4f265e7a4" translate="yes" xml:space="preserve">
          <source>The declaration for &lt;code&gt;HCons&lt;/code&gt; also requires &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; because of infix type operator &lt;code&gt;(':)&lt;/code&gt;</source>
          <target state="translated">由于中缀类型运算符 &lt;code&gt;(':)&lt;/code&gt; ， &lt;code&gt;HCons&lt;/code&gt; 的声明也需要&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4404a7232bfc86c4b3054c2503dd6ddca4de51d" translate="yes" xml:space="preserve">
          <source>The declaration group containing &lt;code&gt;D&lt;/code&gt; is terminated by the empty top-level declaration splice &lt;code&gt;$(return [])&lt;/code&gt; (recall, &lt;code&gt;Q&lt;/code&gt; is a Monad, so we may simply &lt;code&gt;return&lt;/code&gt; the empty list of declarations).</source>
          <target state="translated">包含 &lt;code&gt;D&lt;/code&gt; 的声明组由空的顶级声明拼接 &lt;code&gt;$(return [])&lt;/code&gt; 终止（回想一下， &lt;code&gt;Q&lt;/code&gt; 是Monad，因此我们可以简单地 &lt;code&gt;return&lt;/code&gt; 空的声明列表）。</target>
        </trans-unit>
        <trans-unit id="4f3eb1e20a19137970a20b350de0e993090c5f42" translate="yes" xml:space="preserve">
          <source>The declarations and types from signatures of dependencies that will be merged in are not in scope when type checking an &lt;code&gt;hsig&lt;/code&gt; file. To refer to any such type, you must declare it yourself:</source>
          <target state="translated">类型检查 &lt;code&gt;hsig&lt;/code&gt; 文件时，合并的依赖项签名中的声明和类型不在范围内。要引用任何此类，必须自己声明：</target>
        </trans-unit>
        <trans-unit id="28bc248b719a26880d510c50487bc9904247476f" translate="yes" xml:space="preserve">
          <source>The decoder has consumed the available input and needs more to continue. Provide &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; if more input is available and &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise, and you will get a new &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解码器已经消耗了可用的输入，并且需要更多才能继续。提供 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 如果有更多的输入可用，并 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，否则，你会得到一个新的 &lt;code&gt;&lt;a href=&quot;data-binary-get#t:Decoder&quot;&gt;Decoder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7be60721ea4767c773d4ff5809e621bbad6d744b" translate="yes" xml:space="preserve">
          <source>The decoder has successfully finished. Except for the output value you also get any unused input as well as the number of bytes consumed.</source>
          <target state="translated">解码器已经成功完成。除了输出值外,你还可以得到任何未使用的输入以及消耗的字节数。</target>
        </trans-unit>
        <trans-unit id="c50453020b64e1b5897a128e6a4b8f6fd0ce71b8" translate="yes" xml:space="preserve">
          <source>The decoder ran into an error. The decoder either used &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; or was not provided enough input. Contains any unconsumed input and the number of bytes consumed.</source>
          <target state="translated">解码器遇到错误。解码器使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-fail#v:fail&quot;&gt;fail&lt;/a&gt;&lt;/code&gt; 或没有提供足够的输入。包含任何未使用的输入和已消耗的字节数。</target>
        </trans-unit>
        <trans-unit id="1106af4463a8221ffa09eb5ef1181409ca7b66ab" translate="yes" xml:space="preserve">
          <source>The decoder to isolate</source>
          <target state="translated">隔离的解码器</target>
        </trans-unit>
        <trans-unit id="9109ffd32c6c50a2b3bbde42b4613b2367726367" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt;, which does no translation on Unix systems, but translates &lt;code&gt;'\r\n'&lt;/code&gt; to &lt;code&gt;'\n'&lt;/code&gt; and back on Windows.</source>
          <target state="translated">默认 &lt;code&gt;&lt;a href=&quot;system-io#t:NewlineMode&quot;&gt;NewlineMode&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;system-io#v:nativeNewlineMode&quot;&gt;nativeNewlineMode&lt;/a&gt;&lt;/code&gt; ，这确实在Unix系统上没有翻译，但翻译 &lt;code&gt;'\r\n'&lt;/code&gt; 到 &lt;code&gt;'\n'&lt;/code&gt; 和背部在Windows上。</target>
        </trans-unit>
        <trans-unit id="e1abf9eda04f648cec0d055b085fe295d921786f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; is the same as the default encoding on your system, which is also available as &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt;. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">默认的 &lt;code&gt;&lt;a href=&quot;system-io#t:TextEncoding&quot;&gt;TextEncoding&lt;/a&gt;&lt;/code&gt; 与系统上的默认编码相同，也可以作为 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 使用。（GHC注意：在Windows上，我们当前不支持双字节编码；如果不支持控制台的代码页，则 &lt;code&gt;&lt;a href=&quot;system-io#v:localeEncoding&quot;&gt;localeEncoding&lt;/a&gt;&lt;/code&gt; 将为 &lt;code&gt;&lt;a href=&quot;system-io#v:latin1&quot;&gt;latin1&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="1f7510baab521b5948629307f9f6f4dc19cd4a03" translate="yes" xml:space="preserve">
          <source>The default backend for GHC. It is a native code generator, compiling Cmm all the way to assembly code. It is the fastest backend and generally produces good performance code. It has the best support for compiling shared libraries. Select it with the &lt;code&gt;-fasm&lt;/code&gt; flag.</source>
          <target state="translated">GHC的默认后端。它是一个本机代码生成器，可以一直编译Cmm到汇编代码。它是最快的后端，通常会产生良好的性能代码。它对编译共享库具有最佳支持。使用 &lt;code&gt;-fasm&lt;/code&gt; 标志选择它。</target>
        </trans-unit>
        <trans-unit id="372a76ca948e47b638039a6cfbc912e969dc50c4" translate="yes" xml:space="preserve">
          <source>The default buffering mode is different in GHCi to GHC.</source>
          <target state="translated">GHCi和GHC中默认的缓冲模式是不同的。</target>
        </trans-unit>
        <trans-unit id="612f5aad425db1f69a9dbdbaaa3947648f24e8cc" translate="yes" xml:space="preserve">
          <source>The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered.</source>
          <target state="translated">当一个句柄被打开时,默认的缓冲模式是依赖于实现的,可能取决于连接到该句柄的文件系统对象。对于大多数实现,物理文件通常是块缓冲,终端通常是行缓冲。</target>
        </trans-unit>
        <trans-unit id="0961e4a3376f291925aa422749fabd42ce25f975" translate="yes" xml:space="preserve">
          <source>The default declaration must mention only type &lt;em&gt;variables&lt;/em&gt; on the left hand side, and the right hand side must mention only type variables that are explicitly bound on the left hand side. This restriction is relaxed for &lt;em&gt;kind&lt;/em&gt; variables, however, as the right hand side is allowed to mention kind variables that are implicitly bound on the left hand side.</source>
          <target state="translated">默认声明必须在左侧仅提及类型&lt;em&gt;变量&lt;/em&gt;，而在右侧必须仅提及在左侧明确绑定的类型变量。对于&lt;em&gt;种类&lt;/em&gt;变量，此限制放宽了，但是，因为允许右侧提到隐式绑定在左侧的种类变量。</target>
        </trans-unit>
        <trans-unit id="e629035dab4042ca2e3774c6dd02fa07a19ca5ba" translate="yes" xml:space="preserve">
          <source>The default definition for &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt;, which is suitable for abstract datatypes with no substructures.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 的默认定义是 &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; ，它适用于没有子结构的抽象数据类型。</target>
        </trans-unit>
        <trans-unit id="b37307a1a8b5c8a76936f7e75a2ac6d6c53b888a" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to an identity datatype constructor, using the isomorphism pair as injection and projection.</source>
          <target state="translated">默认定义使用同构对作为注入和投影，将 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 类型的类型构造函数 &lt;code&gt;c&lt;/code&gt; 实例化为标识数据类型构造函数。</target>
        </trans-unit>
        <trans-unit id="0ebc5859a93e62be528328f3201553481af2edf0" translate="yes" xml:space="preserve">
          <source>The default definition instantiates the type constructor &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; to the monad datatype constructor, defining injection and projection using &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认定义将 &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; 类型的类型构造函数 &lt;code&gt;c&lt;/code&gt; 实例化为 monad数据类型构造函数，并使用 &lt;code&gt;&lt;a href=&quot;control-monad#v:return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 定义注入和投影。</target>
        </trans-unit>
        <trans-unit id="4bd4056577869d6ffa3c25c8d2085ea54f8f3b3d" translate="yes" xml:space="preserve">
          <source>The default definition is</source>
          <target state="translated">默认定义是</target>
        </trans-unit>
        <trans-unit id="0c68a975cf82f38a807abb27f8056b694f43e039" translate="yes" xml:space="preserve">
          <source>The default definition is &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, which is appropriate for instances of other forms.</source>
          <target state="translated">默认定义为 &lt;code&gt;&lt;a href=&quot;data-function#v:const&quot;&gt;const&lt;/a&gt; &lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; ，适用于其他形式的实例。</target>
        </trans-unit>
        <trans-unit id="aa9945acbeccb98293938a8f8c707927dd353e5f" translate="yes" xml:space="preserve">
          <source>The default definition may be overridden with a more efficient version if desired.</source>
          <target state="translated">如果需要,可以用更有效的版本覆盖默认定义。</target>
        </trans-unit>
        <trans-unit id="71589b344fdce3f6d3065162df2b93817e514841" translate="yes" xml:space="preserve">
          <source>The default definition should be sufficient, but this can be overridden for efficiency.</source>
          <target state="translated">默认的定义应该是足够的,但为了效率,可以重写。</target>
        </trans-unit>
        <trans-unit id="b230bf83d4661530a10d60a3a4832bae81967728" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认定义使用 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList&quot;&gt;liftReadList&lt;/a&gt;&lt;/code&gt; 。定义 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec&quot;&gt;liftReadPrec&lt;/a&gt;&lt;/code&gt; 的实例也应该将 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec&quot;&gt;liftReadListPrec&lt;/a&gt;&lt;/code&gt; 定义为 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrecDefault&quot;&gt;liftReadListPrecDefault&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b8f0470f58f998c4d12f0e8356a21d2ca7b5de3" translate="yes" xml:space="preserve">
          <source>The default definition uses &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt;. Instances that define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; should also define &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; as &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">默认定义使用 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadList2&quot;&gt;liftReadList2&lt;/a&gt;&lt;/code&gt; 。定义 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadPrec2&quot;&gt;liftReadPrec2&lt;/a&gt;&lt;/code&gt; 的实例也 &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2&quot;&gt;liftReadListPrec2&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-functor-classes#v:liftReadListPrec2Default&quot;&gt;liftReadListPrec2Default&lt;/a&gt;&lt;/code&gt; 定义为liftReadListPrec2Default。</target>
        </trans-unit>
        <trans-unit id="0c58343eea6290f399d2ab6ad1cadcd380e922e3" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-real#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-real#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-real#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 函数的默认定义是基于 &lt;code&gt;&lt;a href=&quot;ghc-real#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec66529839a9863362b72c24581910fe9d869109" translate="yes" xml:space="preserve">
          <source>The default definitions of the &lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; functions are in terms of &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prelude#v:ceiling&quot;&gt;ceiling&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:floor&quot;&gt;floor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:round&quot;&gt;round&lt;/a&gt;&lt;/code&gt; 函数的默认定义是基于 &lt;code&gt;&lt;a href=&quot;prelude#v:properFraction&quot;&gt;properFraction&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="491d8a12b5fa1e7b0bec380645e2c6e813fe0eda" translate="yes" xml:space="preserve">
          <source>The default method definitions in the &lt;code&gt;Exception&lt;/code&gt; class do what we need in this case. You can now throw and catch &lt;code&gt;ThisException&lt;/code&gt; and &lt;code&gt;ThatException&lt;/code&gt; as exceptions:</source>
          <target state="translated">在这种情况下， &lt;code&gt;Exception&lt;/code&gt; 类中的默认方法定义可以满足我们的需求。现在，您可以抛出 &lt;code&gt;ThisException&lt;/code&gt; 和 &lt;code&gt;ThatException&lt;/code&gt; 作为异常：</target>
        </trans-unit>
        <trans-unit id="06f71be64b1eace75a4676b9f81b6631fa302e4c" translate="yes" xml:space="preserve">
          <source>The default method for &lt;code&gt;put&lt;/code&gt; is then used, corresponding to the generic implementation of serialization. If you are using &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, the same instance is generated by simply attaching a &lt;code&gt;deriving Serialize&lt;/code&gt; clause to the &lt;code&gt;UserTree&lt;/code&gt; datatype declaration. For more examples of generic functions please refer to the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;generic-deriving&lt;/a&gt; package on Hackage.</source>
          <target state="translated">然后使用 &lt;code&gt;put&lt;/code&gt; 的默认方法，该方法对应于序列化的一般实现。如果使用的是&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，则只需将 &lt;code&gt;deriving Serialize&lt;/code&gt; 子句附加到 &lt;code&gt;UserTree&lt;/code&gt; 数据类型声明中，即可生成相同的实例。有关通用功能的更多示例，请参阅Hackage上的&lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;通用派生&lt;/a&gt;包。</target>
        </trans-unit>
        <trans-unit id="84a8076800f1a94cd466a3ca2cb82ca67bed6590" translate="yes" xml:space="preserve">
          <source>The default parallel GC settings are usually suitable for parallel programs (i.e. those using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;, Strategies, or with multiple threads). However, it is sometimes beneficial to enable the parallel GC for a single-threaded sequential program too, especially if the program has a large amount of heap data and GC is a significant fraction of runtime. To use the parallel GC in a sequential program, enable the parallel runtime with a suitable &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option, and additionally it might be beneficial to restrict parallel GC to the old generation with &lt;code&gt;-qg1&lt;/code&gt;.</source>
          <target state="translated">默认的并行GC设置通常适用于并行程序（即，使用&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:par&quot;&gt;GHC.Conc.par&lt;/a&gt;，策略或具有多个线程的程序）。但是，有时也为单线程顺序程序启用并行GC是有益的，特别是在程序具有大量堆数据且GC在运行时中占很大比重的情况下。要在顺序程序中使用并行GC，请使用适当的 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 选项启用并行运行时，此外，使用 &lt;code&gt;-qg1&lt;/code&gt; 将并行GC限制为较早的版本可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="1c469f1e0fe0a399e3c8b4ab9c90096159140285" translate="yes" xml:space="preserve">
          <source>The default preferences which may be overwritten in the &lt;code&gt;.haskeline&lt;/code&gt; file.</source>
          <target state="translated">默认首选项可能会在 &lt;code&gt;.haskeline&lt;/code&gt; 文件中覆盖。</target>
        </trans-unit>
        <trans-unit id="2646b613e6eb1c1c85aa64b66ff2f7d3602d210c" translate="yes" xml:space="preserve">
          <source>The default role for abstract datatype parameters is now representational. (An abstract datatype is one with no constructors listed.) To get another role, use a role annotation. (See &lt;a href=&quot;glasgow_exts#roles&quot;&gt;Roles&lt;/a&gt;.)</source>
          <target state="translated">现在，抽象数据类型参数的默认角色是代表性的。（抽象数据类型是未列出构造函数的数据类型。）要获得另一个角色，请使用角色注释。（请参阅&lt;a href=&quot;glasgow_exts#roles&quot;&gt;角色&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="60620248a38bdba79e7fcf67abe638e2752d6a16" translate="yes" xml:space="preserve">
          <source>The default seems to work well here. If you have plenty of memory, it is usually better to use &lt;code&gt;-H ⟨size⟩&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-H [⟨size⟩]&lt;/code&gt;&lt;/a&gt;) than to increase &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认值似乎在这里很好用。如果您有足够的内存，通常最好使用 &lt;code&gt;-H ⟨size⟩&lt;/code&gt; （请参阅&lt;a href=&quot;#rts-flag--H%20%5B%E2%9F%A8size%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; &lt;/a&gt;），而不是增加&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3395f0bc00fd88ab55e5b4f27b7ed6fe2e944e0a" translate="yes" xml:space="preserve">
          <source>The default style (&lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt;).</source>
          <target state="translated">默认样式（ &lt;code&gt;mode=PageMode, lineLength=100, ribbonsPerLine=1.5&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af2102e497ed3634f45c2fd75b234c6748ca55b8" translate="yes" xml:space="preserve">
          <source>The definition (of a function, variable, struct or typedef) is written to the C file, and its prototype or extern declaration to the C header. Inline functions are handled correctly. struct definitions and typedefs are written to the C program too. The &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;typedef&lt;/code&gt; keyword must come just after &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">将定义（函数，变量，结构或typedef的定义）写入C文件，并将其原型或extern声明写入C标头。内联函数已正确处理。struct定义和typedef也被写入C程序。该 &lt;code&gt;inline&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;typedef&lt;/code&gt; 关键字一定要来刚过 &lt;code&gt;def&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c8661345439bef92de6f21733c68492b49b19b5" translate="yes" xml:space="preserve">
          <source>The definition for &amp;ldquo;compatible&amp;rdquo; uses a notion of &amp;ldquo;apart&amp;rdquo;, whose definition in turn relies on type family reduction. This condition of &amp;ldquo;apartness&amp;rdquo;, as stated, is impossible to check, so we use this conservative approximation: two types are considered to be apart when the two types cannot be unified, even by a potentially infinite unifier. Allowing the unifier to be infinite disallows the following pair of instances:</source>
          <target state="translated">&amp;ldquo;兼容&amp;rdquo;的定义使用&amp;ldquo; apart&amp;rdquo;的概念，而其定义又依赖于类型族简化。如前所述，这种&amp;ldquo;间隔&amp;rdquo;条件是无法检查的，因此我们使用这种保守近似法：当无法将两种类型统一时，即使使用潜在的无限统一者，也将两种类型视为分离。允许unifier无限，则禁止以下实例对：</target>
        </trans-unit>
        <trans-unit id="70f33fa7b9f96d835ab103c50be5ec10b816d10e" translate="yes" xml:space="preserve">
          <source>The definition is syntactic:</source>
          <target state="translated">定义是句法的。</target>
        </trans-unit>
        <trans-unit id="df390321900febf5a604611d2971ac50e861f17b" translate="yes" xml:space="preserve">
          <source>The definition of &quot;math symbol&quot; may be a little counter-intuitive depending on one's background:</source>
          <target state="translated">对于 &quot;数学符号 &quot;的定义,根据个人的背景,可能会有些反常。</target>
        </trans-unit>
        <trans-unit id="9142eae3b3df142878b925196063f3a19a7bf511" translate="yes" xml:space="preserve">
          <source>The definition of (say) &lt;code&gt;build&lt;/code&gt; in &lt;code&gt;GHC/Base.hs&lt;/code&gt; looks like this:</source>
          <target state="translated">该（说）的定义 &lt;code&gt;build&lt;/code&gt; 在 &lt;code&gt;GHC/Base.hs&lt;/code&gt; 看起来是这样的：</target>
        </trans-unit>
        <trans-unit id="c2ee65e9c75aa9258dca0f16a6b10f4fd9a759a9" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;foo&lt;/code&gt; is rejected because one would have to instantiate &lt;code&gt;id&lt;/code&gt;&amp;lsquo;s type with &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt;, and that is not allowed. Instantiating polymorphic type variables with polymorphic types is called &lt;em&gt;impredicative polymorphism&lt;/em&gt;.</source>
          <target state="translated">拒绝 &lt;code&gt;foo&lt;/code&gt; 的定义，因为必须使用 &lt;code&gt;b := (forall s. ST s a) -&amp;gt; a&lt;/code&gt; 实例化 &lt;code&gt;id&lt;/code&gt; 的类型，这是不允许的。用多态类型实例化多态类型变量称为&lt;em&gt;命令性多态&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed024c34bd63c1441cb3695b992556af082202b2" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;inst&lt;/code&gt; is unchanged from the Haskell Report (roughly, just a type). The &lt;code&gt;context =&amp;gt;&lt;/code&gt; part is optional. That is the only syntactic change to the language.</source>
          <target state="translated">在Haskell报告中， &lt;code&gt;inst&lt;/code&gt; 的定义未更改（大致只是一种类型）。所述 &lt;code&gt;context =&amp;gt;&lt;/code&gt; 部分是可选的。这是对语言的唯一语法更改。</target>
        </trans-unit>
        <trans-unit id="0bfdf9f8e4b0cf4d6ac3380a527908a80562e1fe" translate="yes" xml:space="preserve">
          <source>The definition of retainers is designed to reflect a common cause of space leaks: a large structure is retained by an unevaluated computation, and will be released once the computation is forced. A good example is looking up a value in a finite map, where unless the lookup is forced in a timely manner the unevaluated lookup will cause the whole mapping to be retained. These kind of space leaks can often be eliminated by forcing the relevant computations to be performed eagerly, using &lt;code&gt;seq&lt;/code&gt; or strictness annotations on data constructor fields.</source>
          <target state="translated">固定器的定义旨在反映空间泄漏的常见原因：未经评估的计算保留了大型结构，一旦强制执行计算便将其释放。一个很好的例子是在有限映射中查找值，在该映射中，除非及时强制查找，否则未评估的查找将导致整个映射得以保留。通常可以通过在数据构造函数字段上使用 &lt;code&gt;seq&lt;/code&gt; 或strictness批注强制执行相关计算，从而消除此类空间泄漏。</target>
        </trans-unit>
        <trans-unit id="f9455c27066e060f9c4ed319a5e6f962fe125ba2" translate="yes" xml:space="preserve">
          <source>The dependency &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; here specifies that the type &lt;code&gt;e&lt;/code&gt; of elements is uniquely determined by the type of the collection &lt;code&gt;ce&lt;/code&gt;. Note that both parameters of Collects are of kind &lt;code&gt;Type&lt;/code&gt;; there are no constructor classes here. Note too that all of the instances of &lt;code&gt;Collects&lt;/code&gt; that we gave earlier can be used together with this new definition.</source>
          <target state="translated">依存关系 &lt;code&gt;ce -&amp;gt; e&lt;/code&gt; 在这里指定元素的类型 &lt;code&gt;e&lt;/code&gt; 由集合 &lt;code&gt;ce&lt;/code&gt; 的类型唯一地确定。请注意，Collects的两个参数都是 &lt;code&gt;Type&lt;/code&gt; 类型。这里没有构造函数类。还要注意，我们之前给出的 &lt;code&gt;Collects&lt;/code&gt; 的所有实例都可以与此新定义一起使用。</target>
        </trans-unit>
        <trans-unit id="0ed435c3cbe535cb6b31533a151482c8d2a49765" translate="yes" xml:space="preserve">
          <source>The dependency generation phase of GHC can take some additional options, which you may find useful. The options which affect dependency generation are:</source>
          <target state="translated">GHC的依赖关系生成阶段可以使用一些额外的选项,你可能会发现这些选项很有用。影响依赖关系生成的选项有:</target>
        </trans-unit>
        <trans-unit id="b14601aa73f99ec94b5c907467d51ea631241fb4" translate="yes" xml:space="preserve">
          <source>The dependency is based on file content, not a modification time</source>
          <target state="translated">依赖性是基于文件内容,而不是修改时间。</target>
        </trans-unit>
        <trans-unit id="adeb50d906769008b71fc1da461a1b88d5c5394a" translate="yes" xml:space="preserve">
          <source>The derivation mechanism can be used separtely from the data type declaration, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#stand-alone-deriving&quot;&gt;独立的派生机制&lt;/a&gt;将派生机制与数据类型声明分开使用。</target>
        </trans-unit>
        <trans-unit id="b7b9b515a6b382dc8b30446310290e049039607a" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例允许在输入字符串的标记之间使用任意Haskell空格。也可以使用多余的括号。</target>
        </trans-unit>
        <trans-unit id="0df45d847dca83db9351f4d864dd9921bcab85be" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生的 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例允许在输入字符串的标记之间使用任意Haskell空格。也可以使用多余的括号。</target>
        </trans-unit>
        <trans-unit id="827987dc4d21c55f29757d61b2ead342246251b4" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance allows arbitrary Haskell whitespace between tokens of the input string. Extra parentheses are also allowed.</source>
          <target state="translated">派生的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例允许在输入字符串的标记之间使用任意Haskell空格。也可以使用多余的括号。</target>
        </trans-unit>
        <trans-unit id="181a26c0ac10388c1c28e3a4a0bb2c744983c69d" translate="yes" xml:space="preserve">
          <source>The derived &lt;code&gt;HasRing&lt;/code&gt; instance would look like</source>
          <target state="translated">派生的 &lt;code&gt;HasRing&lt;/code&gt; 实例看起来像</target>
        </trans-unit>
        <trans-unit id="4744374c6426f29a0ece90c5038f8bb5efa3725d" translate="yes" xml:space="preserve">
          <source>The derived instance in GHC is equivalent to</source>
          <target state="translated">GHC中的派生实例相当于</target>
        </trans-unit>
        <trans-unit id="2aa9649e650abb1ccfd00ab90d331d7948d62cc4" translate="yes" xml:space="preserve">
          <source>The derived instance is obtained by completing the application of the class to the new type:</source>
          <target state="translated">通过完成类对新类型的应用来获得派生实例。</target>
        </trans-unit>
        <trans-unit id="75901f130a621087c5df4e3c7ff2bcd908627e72" translate="yes" xml:space="preserve">
          <source>The design also relies on &lt;code&gt;Danger&lt;/code&gt; not being able to access the &lt;code&gt;UnsafeRIO&lt;/code&gt; constructor. Unfortunately Template Haskell can be used to subvert module boundaries and so could be used to gain access to this constructor.</source>
          <target state="translated">该设计还依赖于 &lt;code&gt;Danger&lt;/code&gt; 无法访问 &lt;code&gt;UnsafeRIO&lt;/code&gt; 构造函数。不幸的是，模板Haskell可用于颠覆模块边界，因此可用于获取对此构造函数的访问权限。</target>
        </trans-unit>
        <trans-unit id="49cc72101ca9237972311dd03a0fd606151e4195" translate="yes" xml:space="preserve">
          <source>The design attempts to restrict the operations that &lt;code&gt;Danger&lt;/code&gt; can perform by using types, specifically the &lt;code&gt;RIO&lt;/code&gt; type wrapper around &lt;code&gt;IO&lt;/code&gt; . The author of &lt;code&gt;Danger&lt;/code&gt; can subvert this though by simply writing arbitrary &lt;code&gt;IO&lt;/code&gt; actions and using &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; to execute them as pure functions.</source>
          <target state="translated">设计试图通过使用类型（特别是 &lt;code&gt;IO&lt;/code&gt; 周围的 &lt;code&gt;RIO&lt;/code&gt; 类型包装器）来限制 &lt;code&gt;Danger&lt;/code&gt; 可以执行的操作。 &lt;code&gt;Danger&lt;/code&gt; 的作者可以通过简单地编写任意 &lt;code&gt;IO&lt;/code&gt; 操作并使用 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; 来将其作为纯函数执行来颠覆这一点。</target>
        </trans-unit>
        <trans-unit id="cd2da32dc935177290030f66437b8442e648de85" translate="yes" xml:space="preserve">
          <source>The design follows the following principles</source>
          <target state="translated">设计遵循以下原则</target>
        </trans-unit>
        <trans-unit id="8290c7ce1697900c8e40df8ad0fc8ee4040a8ead" translate="yes" xml:space="preserve">
          <source>The design of Safe Haskell covers the following aspects:</source>
          <target state="translated">安全Haskell的设计包括以下几个方面。</target>
        </trans-unit>
        <trans-unit id="db9668c7f3a96172360c5f50287354a3f36ed64a" translate="yes" xml:space="preserve">
          <source>The design of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid is optimized such that</source>
          <target state="translated">优化了 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; monoid 的设计，以便</target>
        </trans-unit>
        <trans-unit id="d69ade52bf3d6bc1c9e9d54294cef3da66243040" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">该组合器的设计遵循以下目标：只要 &lt;code&gt;f&lt;/code&gt; 不 &lt;code&gt;timeout n f&lt;/code&gt; ，超时nf的行为应与 &lt;code&gt;f&lt;/code&gt; 完全相同。这意味着 &lt;code&gt;f&lt;/code&gt; 具有与没有超时包装器时相同的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;f&lt;/code&gt; 可能抛出的任何异常都将取消超时并进一步传播。 &lt;code&gt;f&lt;/code&gt; 也可能接收另一个线程抛出的异常。</target>
        </trans-unit>
        <trans-unit id="ddf2c08a7e7a13b99ab3673124ddb5f1ed0a8e6e" translate="yes" xml:space="preserve">
          <source>The design of this combinator was guided by the objective that &lt;code&gt;timeout n f&lt;/code&gt; should behave exactly the same as &lt;code&gt;f&lt;/code&gt; as long as &lt;code&gt;f&lt;/code&gt; doesn't time out. This means that &lt;code&gt;f&lt;/code&gt; has the same &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; it would have without the timeout wrapper. Any exceptions &lt;code&gt;f&lt;/code&gt; might throw cancel the timeout and propagate further up. It also possible for &lt;code&gt;f&lt;/code&gt; to receive exceptions thrown to it by another thread.</source>
          <target state="translated">该组合器的设计遵循以下目标：只要 &lt;code&gt;f&lt;/code&gt; 不 &lt;code&gt;timeout n f&lt;/code&gt; ，超时nf的行为应与 &lt;code&gt;f&lt;/code&gt; 完全相同。这意味着 &lt;code&gt;f&lt;/code&gt; 具有与没有超时包装器时相同的 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:myThreadId&quot;&gt;myThreadId&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;f&lt;/code&gt; 可能抛出的任何异常都将取消超时并进一步传播。 &lt;code&gt;f&lt;/code&gt; 也可能接收另一个线程抛出的异常。</target>
        </trans-unit>
        <trans-unit id="069d6b594d5ec9b69dd4d93d8ec6094f3feb0544" translate="yes" xml:space="preserve">
          <source>The details of how to create the process are passed in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; record. To make it easier to construct a &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt;, the functions &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; are supplied that fill in the fields with default values which can be overriden as needed.</source>
          <target state="translated">如何创建流程的详细信息在 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 记录中传递。为了 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 构造CreateProcess的过程，提供了 &lt;code&gt;&lt;a href=&quot;system-process#v:proc&quot;&gt;proc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-process#v:shell&quot;&gt;shell&lt;/a&gt;&lt;/code&gt; 函数，这些函数使用默认值填充字段，可以根据需要覆盖这些默认值。</target>
        </trans-unit>
        <trans-unit id="ed02330a1fbdda98a3ba7bccd58b777f6e21c2c1" translate="yes" xml:space="preserve">
          <source>The developer knows that a monad transformer takes a monad &lt;code&gt;m&lt;/code&gt; into a new monad &lt;code&gt;t m&lt;/code&gt;. But this property is not formally specified in the above declaration. This omission becomes an issue when defining monad transformer composition:</source>
          <target state="translated">开发人员知道monad变压器会将monad &lt;code&gt;m&lt;/code&gt; 带入新的monad &lt;code&gt;t m&lt;/code&gt; 。但是此属性未在上面的声明中正式指定。在定义monad变压器组成时，此遗漏成为一个问题：</target>
        </trans-unit>
        <trans-unit id="baaf6bdd8fde5eba43c6847cbbb88e9af95ebd7b" translate="yes" xml:space="preserve">
          <source>The difference between this and &lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is that this one determines if a function definition will be inlined &lt;em&gt;at a call site&lt;/em&gt;. The other option determines if a function definition will be kept around at all for potential inlining.</source>
          <target state="translated">此&lt;a href=&quot;#ghc-flag--funfolding-creation-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-creation-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt;与-funfolding-creation-threshold =⟩n⟩之间的区别在于，此函数确定是否&lt;em&gt;在调用站点上&lt;/em&gt;内联函数定义。另一个选项确定是否为潜在的内联保留功能定义。</target>
        </trans-unit>
        <trans-unit id="7ce598ae08dc7d0d31f3dc6c209cf1408d599371" translate="yes" xml:space="preserve">
          <source>The difference between using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for recovery is that in &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; the handler is inside an implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; (see &quot;Asynchronous Exceptions&quot;) which is important when catching asynchronous exceptions, but when catching other kinds of exception it is unnecessary. Furthermore it is possible to accidentally stay inside the implicit &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; by tail-calling rather than returning from the handler, which is why we recommend using &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; rather than &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; for ordinary exception recovery.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 进行恢复之间的区别在于，在 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 中，处理程序位于隐式 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; （请参见&amp;ldquo;异步异常&amp;rdquo;），这在捕获异步异常时很重要，但是在捕获其他种类的异常时则没有必要。此外，有可能通过尾部调用而不是从处理程序中返回而意外地停留在隐式 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内，这就是为什么我们建议使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-exception#v:catch&quot;&gt;catch&lt;/a&gt;&lt;/code&gt; 进行普通异常恢复的原因。</target>
        </trans-unit>
        <trans-unit id="7baf36ea1c4b3f790ba00b9fa8c653d9d8edc0dc" translate="yes" xml:space="preserve">
          <source>The difference involves the placement of the last type parameter, &lt;code&gt;a&lt;/code&gt;. In the &lt;code&gt;Right&lt;/code&gt; case, &lt;code&gt;a&lt;/code&gt; occurs within the type &lt;code&gt;Either Int a&lt;/code&gt;, and moreover, it appears as the last type argument of &lt;code&gt;Either&lt;/code&gt;. In the &lt;code&gt;Wrong&lt;/code&gt; case, however, &lt;code&gt;a&lt;/code&gt; is not the last type argument to &lt;code&gt;Either&lt;/code&gt;; rather, &lt;code&gt;Int&lt;/code&gt; is.</source>
          <target state="translated">不同之处在于最后一个类型参数 &lt;code&gt;a&lt;/code&gt; 的位置。在 &lt;code&gt;Right&lt;/code&gt; 情况下， &lt;code&gt;a&lt;/code&gt; 出现在 &lt;code&gt;Either Int a&lt;/code&gt; 类型中，而且，它作为 &lt;code&gt;Either&lt;/code&gt; 的最后一个类型参数出现。但是，在 &lt;code&gt;Wrong&lt;/code&gt; 情况下， &lt;code&gt;a&lt;/code&gt; 并不是 &lt;code&gt;Either&lt;/code&gt; 的最后一个类型参数；相反， &lt;code&gt;Int&lt;/code&gt; 是。</target>
        </trans-unit>
        <trans-unit id="7b237dd43561a7048051c81d4534c2c8653cc063" translate="yes" xml:space="preserve">
          <source>The directory returned is expected to be writable by the current user, but note that it isn't generally considered good practice to store application-specific data here; use &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">返回的目录预期是当前用户可写的，但是请注意，通常不认为在此处存储特定于应用程序的数据是一种好习惯。请改用 &lt;code&gt;&lt;a href=&quot;system-directory#v:getXdgDirectory&quot;&gt;getXdgDirectory&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-directory#v:getAppUserDataDirectory&quot;&gt;getAppUserDataDirectory&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d678522b8fbe1bfba9bfaea6f20349fc6c790192" translate="yes" xml:space="preserve">
          <source>The do-notation of Haskell 98 does not allow &lt;em&gt;recursive bindings&lt;/em&gt;, that is, the variables bound in a do-expression are visible only in the textually following code block. Compare this to a let-expression, where bound variables are visible in the entire binding group.</source>
          <target state="translated">Haskell 98的do表示法不允许&lt;em&gt;递归绑定&lt;/em&gt;，也就是说，绑定在do表达式中的变量仅在文本后面的代码块中可见。将其与let表达式进行比较，在该表达式中，绑定变量在整个绑定组中可见。</target>
        </trans-unit>
        <trans-unit id="ed0761a6931cceb4a4d7abb1349cfebd091b9cae" translate="yes" xml:space="preserve">
          <source>The document type</source>
          <target state="translated">文件类型</target>
        </trans-unit>
        <trans-unit id="b44ad1035675a222470b757eea4beb20cf50c47b" translate="yes" xml:space="preserve">
          <source>The document.</source>
          <target state="translated">该文件:</target>
        </trans-unit>
        <trans-unit id="f1cdc66d16588511d035499d8789d0de0a61455f" translate="yes" xml:space="preserve">
          <source>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the &lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">此处的文档描述了GHC中Template Haskell的实现。还不够详细，无法理解Template Haskell；参见&lt;a href=&quot;http://haskell.org/haskellwiki/Template_Haskell&quot;&gt;Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d161d8e5801d84e4bc6cb6d1ba3399418931f1f" translate="yes" xml:space="preserve">
          <source>The down-side is that, if the boilerplate code fails to typecheck, you will get an error message about that code, which you did not write. Whereas, with a &lt;code&gt;deriving&lt;/code&gt; clause the side-conditions are necessarily more conservative, but any error message may be more comprehensible.</source>
          <target state="translated">不利的一面是，如果样板代码无法进行类型检查，您将收到有关该代码的错误消息，而您没有编写。而对于 &lt;code&gt;deriving&lt;/code&gt; 子句，附带条件必然更为保守，但是任何错误消息都可能更易于理解。</target>
        </trans-unit>
        <trans-unit id="0d40a85296a889e2235c05d3e594413e6271c9b0" translate="yes" xml:space="preserve">
          <source>The downside of having lightweight threads is that only one can run at a time, so if one thread blocks in a foreign call, for example, the other threads cannot continue. The GHC runtime works around this by making use of full OS threads where necessary. When the program is built with the &lt;code&gt;-threaded&lt;/code&gt; option (to link against the multithreaded version of the runtime), a thread making a &lt;code&gt;safe&lt;/code&gt; foreign call will not block the other threads in the system; another OS thread will take over running Haskell threads until the original call returns. The runtime maintains a pool of these &lt;em&gt;worker&lt;/em&gt; threads so that multiple Haskell threads can be involved in external calls simultaneously.</source>
          <target state="translated">拥有轻量级线程的缺点是一次只能运行一个线程，因此，例如，如果一个线程在外部调用中阻塞，则其他线程将无法继续。 GHC运行时通过在必要时使用完整的OS线程来解决此问题。当使用 &lt;code&gt;-threaded&lt;/code&gt; 选项构建程序时（用于链接运行时的多线程版本），进行 &lt;code&gt;safe&lt;/code&gt; 外部调用的线程将不会阻塞系统中的其他线程。另一个OS线程将接管正在运行的Haskell线程，直到原始调用返回。运行时维护这些&lt;em&gt;工作&lt;/em&gt;线程的池，以便多个Haskell线程可以同时参与外部调用。</target>
        </trans-unit>
        <trans-unit id="7e1ca2d2eeb59a37201caba0870b3b617ae2b6e7" translate="yes" xml:space="preserve">
          <source>The drag stage, which lasts from the final use until the last reference to the object is dropped.</source>
          <target state="translated">拖动阶段,从最后使用到对象的最后一个引用被删除为止。</target>
        </trans-unit>
        <trans-unit id="5112337835e0aaa1f4501d77e936abde1e9f5833" translate="yes" xml:space="preserve">
          <source>The dual of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, obtained by swapping the arguments of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 的对偶，通过交换 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 的参数获得。</target>
        </trans-unit>
        <trans-unit id="7fab6e06621905edcea476fea0795c21d73fe816" translate="yes" xml:space="preserve">
          <source>The dynamic binding constraints are just a new form of predicate in the type class system.</source>
          <target state="translated">动态绑定约束只是类型类系统中一种新的谓词形式。</target>
        </trans-unit>
        <trans-unit id="c9658faad340c4e37684884e4b4de1d55529e10f" translate="yes" xml:space="preserve">
          <source>The easiest way to see what &lt;code&gt;-O&lt;/code&gt; (etc.) &amp;ldquo;really mean&amp;rdquo; is to run with &lt;a href=&quot;using#ghc-flag--v&quot;&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, then stand back in amazement.</source>
          <target state="translated">了解 &lt;code&gt;-O&lt;/code&gt; （等）&amp;ldquo;真正含义&amp;rdquo; 的最简单方法是与&lt;a href=&quot;using#ghc-flag--v&quot;&gt; &lt;code&gt;-v&lt;/code&gt; &lt;/a&gt;一起运行，然后惊讶地退后一步。</target>
        </trans-unit>
        <trans-unit id="9d5eb6a79829c0b2ad6433410a38b38fee844c58" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac8593ee22b444a0803d2615c08c3ad783eddab" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空的 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffb10a0d9ca8c58bdee511053f10bf4fc11e9fd3" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">空文件，没有高度和宽度。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 的标识，以及参数列表中 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 等的任何地方。</target>
        </trans-unit>
        <trans-unit id="c38333a804d1c05d76e22c031e0de30532f2b0b2" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">空文件，没有高度和宽度。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 的标识，以及参数列表中 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 等的任何地方。</target>
        </trans-unit>
        <trans-unit id="57055327e0a4ff0414ff005dc9f2d958097b63a1" translate="yes" xml:space="preserve">
          <source>The empty document, with no height and no width. &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is the identity for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt;, and anywhere in the argument list for &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">空文件，没有高度和宽度。 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-60--43--62-&quot;&gt;&amp;lt;+&amp;gt;&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--36-&quot;&gt;$$&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:-36--43--36-&quot;&gt;$+$&lt;/a&gt;&lt;/code&gt; 的标识，以及参数列表中 &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:sep&quot;&gt;sep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hcat&quot;&gt;hcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:hsep&quot;&gt;hsep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:vcat&quot;&gt;vcat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-prettyprint-hughespj#v:fcat&quot;&gt;fcat&lt;/a&gt;&lt;/code&gt; 等的任何地方。</target>
        </trans-unit>
        <trans-unit id="322d102fb89074ac997d55fe8155256f83635242" translate="yes" xml:space="preserve">
          <source>The empty stream.</source>
          <target state="translated">的空流。</target>
        </trans-unit>
        <trans-unit id="aaade1a4c344a06009213d97ea6d90338497c9b0" translate="yes" xml:space="preserve">
          <source>The entire string prior to the &lt;em&gt;k&lt;/em&gt;th match (i.e. the prefix)</source>
          <target state="translated">第&lt;em&gt;k&lt;/em&gt;个匹配项之前的整个字符串（即前缀）</target>
        </trans-unit>
        <trans-unit id="7e6880e4680eabaf9b865ccc3e11f4776c77ad73" translate="yes" xml:space="preserve">
          <source>The environment variable can also be set to the magical values &lt;code&gt;never&lt;/code&gt; or &lt;code&gt;always&lt;/code&gt;, which is equivalent to setting the corresponding &lt;code&gt;-fdiagnostics-color&lt;/code&gt; flag but with lower precedence.</source>
          <target state="translated">还可以将环境变量设置为 &lt;code&gt;never&lt;/code&gt; 或 &lt;code&gt;always&lt;/code&gt; 的神奇值，这等效于设置相应的 &lt;code&gt;-fdiagnostics-color&lt;/code&gt; 标志，但优先级较低。</target>
        </trans-unit>
        <trans-unit id="a78af08f35ea577d78dded305fcc5c4e9509b316" translate="yes" xml:space="preserve">
          <source>The epoch of TAI, which is 1858-11-17 00:00:00 TAI.</source>
          <target state="translated">TAI的纪元,是1858-11-17 00:00:00 TAI。</target>
        </trans-unit>
        <trans-unit id="81943c20c210a66a07a8f11e6429a84649f3e7b2" translate="yes" xml:space="preserve">
          <source>The equality test in an overloaded numeric pattern uses whatever &lt;code&gt;(==)&lt;/code&gt; is in scope.</source>
          <target state="translated">重载数字模式中的相等性测试使用范围内的任何 &lt;code&gt;(==)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afd1105a178de8acf9d4f7264289cbff2eca2561" translate="yes" xml:space="preserve">
          <source>The equality types</source>
          <target state="translated">平等类型</target>
        </trans-unit>
        <trans-unit id="1199dfc965e5955380e63499fadc65f9cbd20ac3" translate="yes" xml:space="preserve">
          <source>The equivalent REPL example is:</source>
          <target state="translated">相当于REPL的例子是:</target>
        </trans-unit>
        <trans-unit id="7d39f7dfb145cb81010fc146adcc072a6753c454" translate="yes" xml:space="preserve">
          <source>The error message contains some clues as to the transformation happening internally.</source>
          <target state="translated">错误信息包含了一些关于内部发生转变的线索。</target>
        </trans-unit>
        <trans-unit id="59e467fc1987c039f09f1829c27318997a022a9d" translate="yes" xml:space="preserve">
          <source>The error monad transformer. It can be used to add error handling to other monads.</source>
          <target state="translated">错误单体变换器。它可以用来给其他单体添加错误处理。</target>
        </trans-unit>
        <trans-unit id="584676bca032e15cb39d4d01b07dc527b1765a4e" translate="yes" xml:space="preserve">
          <source>The errors that can be deferred are:</source>
          <target state="translated">可以推迟的错误有:</target>
        </trans-unit>
        <trans-unit id="53caa6a4eadedbc6b469bff64565461d1ccdfebf" translate="yes" xml:space="preserve">
          <source>The event manager state.</source>
          <target state="translated">事件经理状态。</target>
        </trans-unit>
        <trans-unit id="5f9ab52fbe55b01321892b7fd29ab1a98bb7681d" translate="yes" xml:space="preserve">
          <source>The example below shows quasi-quotation in action. The quoter &lt;code&gt;expr&lt;/code&gt; is bound to a value of type &lt;code&gt;QuasiQuoter&lt;/code&gt; defined in module &lt;code&gt;Expr&lt;/code&gt;. The example makes use of an antiquoted variable &lt;code&gt;n&lt;/code&gt;, indicated by the syntax &lt;code&gt;'int:n&lt;/code&gt; (this syntax for anti-quotation was defined by the parser&amp;rsquo;s author, &lt;em&gt;not&lt;/em&gt; by GHC). This binds &lt;code&gt;n&lt;/code&gt; to the integer value argument of the constructor &lt;code&gt;IntExpr&lt;/code&gt; when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type &lt;code&gt;String -&amp;gt; a&lt;/code&gt; to generate both an expression parser that returns a value of type &lt;code&gt;Q Exp&lt;/code&gt; and a pattern parser that returns a value of type &lt;code&gt;Q Pat&lt;/code&gt;.</source>
          <target state="translated">以下示例显示了实际报价。引号 &lt;code&gt;expr&lt;/code&gt; 绑定到模块 &lt;code&gt;Expr&lt;/code&gt; 中定义的 &lt;code&gt;QuasiQuoter&lt;/code&gt; 类型的值。该示例使用反引号变量 &lt;code&gt;n&lt;/code&gt; ，由语法 &lt;code&gt;'int:n&lt;/code&gt; 指示（此反引号的语法由解析器的作者&lt;em&gt;而不是&lt;/em&gt; GHC定义）。模式匹配时，这 &lt;code&gt;IntExpr&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 绑定到构造函数IntExpr的整数值参数。有关反引号的更多详细信息以及使用SYB来利用String- &lt;code&gt;String -&amp;gt; a&lt;/code&gt; 类型的单个解析器的技术的描述，请参见参考文件。&lt;em&gt;&lt;/em&gt;生成返回值类型为 &lt;code&gt;Q Exp&lt;/code&gt; 的表达式解析器和返回值类型为 &lt;code&gt;Q Pat&lt;/code&gt; 的模式解析器。</target>
        </trans-unit>
        <trans-unit id="e130d4a858cd5958b963d63c7fe21940f766b4ef" translate="yes" xml:space="preserve">
          <source>The exception itself is bound to a new variable, &lt;code&gt;_exception&lt;/code&gt;.</source>
          <target state="translated">异常本身绑定到新变量 &lt;code&gt;_exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="988d36edf500c18480e248b3ba03ea83da4d2cbf" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">已执行操作的异常屏蔽状态是继承的（cf &lt;code&gt;forkIO&lt;/code&gt; ），另请参见 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; （&lt;em&gt;因为：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="cc8f732aa9ca323261d4591444f25b148d16268f" translate="yes" xml:space="preserve">
          <source>The exception masking state of the executed action is inherited (c.f. &lt;code&gt;forkIO&lt;/code&gt;), see also &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; (&lt;em&gt;since: 2.7.0.0&lt;/em&gt;).</source>
          <target state="translated">已执行操作的异常屏蔽状态是继承的（cf &lt;code&gt;forkIO&lt;/code&gt; ），另请参见 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcessWithUnmask&quot;&gt;forkProcessWithUnmask&lt;/a&gt;&lt;/code&gt; （&lt;em&gt;因为：2.7.0.0&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebf03146e8f23e21eb8275358c982d6013264e4c" translate="yes" xml:space="preserve">
          <source>The exception thrown by &quot;fail&quot; in the GHCiQ monad</source>
          <target state="translated">GHCiQ单体中的 &quot;fail &quot;引发的异常。</target>
        </trans-unit>
        <trans-unit id="ceefa01748ad0dcbb4f9adc6b0c343de52816f7c" translate="yes" xml:space="preserve">
          <source>The exception thrown when an infinite cycle is detected in &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;system-io#v:fixIO&quot;&gt;fixIO&lt;/a&gt;&lt;/code&gt; 中检测到无限循环时引发的异常。</target>
        </trans-unit>
        <trans-unit id="e73e797f0aaf19c29e3a38b80b61adffd05c8530" translate="yes" xml:space="preserve">
          <source>The exception to this rule is that the context of a standalone deriving declaration can infer its context when a single, extra-wildcards constraint is used as the context, such as in:</source>
          <target state="translated">这个规则的例外是,当一个独立的派生声明的上下文被用作上下文时,可以推断出它的上下文,比如在。</target>
        </trans-unit>
        <trans-unit id="2a9b0765cdd57857b495fa1668f0cbcf42055c10" translate="yes" xml:space="preserve">
          <source>The execution continued at the point it previously stopped, and has now stopped at the breakpoint for a second time.</source>
          <target state="translated">在之前停止的地方继续执行,现在已经第二次停止在断点处。</target>
        </trans-unit>
        <trans-unit id="11953fb00b8ad70bb93132200530ed5421e8c22b" translate="yes" xml:space="preserve">
          <source>The exit status of a process</source>
          <target state="translated">流程的退出状态</target>
        </trans-unit>
        <trans-unit id="927dcdbea9e7b5ba6ac39897b83ff1c61f46b2d3" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the expanded right-hand side expression refers to the nearest enclosing variable that is spelled the same as the field name.</source>
          <target state="translated">扩展是纯粹的语法,所以扩展后的右侧表达式指的是与字段名拼写相同的最近的包围变量。</target>
        </trans-unit>
        <trans-unit id="0bb43782d3d91d6c0cfe9ab486e0facf443af806" translate="yes" xml:space="preserve">
          <source>The expansion is purely syntactic, so the record wildcard expression refers to the nearest enclosing variables that are spelled the same as the omitted field names.</source>
          <target state="translated">扩展是纯粹的语法,所以记录通配符表达式指的是与省略字段名拼写相同的最近的包围变量。</target>
        </trans-unit>
        <trans-unit id="6fa2123bab4a96fc3dff4e1405c75b76df70f413" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;(x `par` y)&lt;/code&gt;&lt;em&gt;sparks&lt;/em&gt; the evaluation of &lt;code&gt;x&lt;/code&gt; (to weak head normal form) and returns &lt;code&gt;y&lt;/code&gt;. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. In this way the available parallelism is spread amongst the real CPUs.</source>
          <target state="translated">表达式 &lt;code&gt;(x `par` y)&lt;/code&gt; &lt;em&gt;引发&lt;/em&gt;对 &lt;code&gt;x&lt;/code&gt; 的求值（以弱头范式形式）并返回 &lt;code&gt;y&lt;/code&gt; 。火花按FIFO顺序排队等待执行，但不会立即执行。如果运行时检测到存在空闲的CPU，则它将火花转换为真实线程，然后在空闲的CPU上运行新线程。通过这种方式，可用的并行性将在实际的CPU之间传播。</target>
        </trans-unit>
        <trans-unit id="60035052d2f9f9dbcb2234d0c35b5862aef3671d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; results in the following lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;encodeUtf8CSV table&lt;/code&gt; 结果为以下惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ec7656c8e0e128b3c718fea844b6924e7c9db92" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">表达式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; 创建一个由解析器 &lt;code&gt;p&lt;/code&gt; 组成的新鲜置换解析器。置换分析器的最终结果是将函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;p&lt;/code&gt; 的返回值。解析器 &lt;code&gt;p&lt;/code&gt; 不允许接受空输入- 而是使用可选的组合器（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="688562a46f3c26c92c14ba3e2ae41abc13cf015e" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead.</source>
          <target state="translated">表达式 &lt;code&gt;f &amp;lt;$$&amp;gt; p&lt;/code&gt; 创建一个由解析器 &lt;code&gt;p&lt;/code&gt; 组成的新鲜置换解析器。置换分析器的最终结果是将函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;p&lt;/code&gt; 的返回值。解析器 &lt;code&gt;p&lt;/code&gt; 不允许接受空输入- 而是使用可选的组合器（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--36--63--62-&quot;&gt;&amp;lt;$?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="133ce73b1396f38f1c484e835e97b17e44814c41" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; creates a fresh permutation parser consisting of parser &lt;code&gt;p&lt;/code&gt;. The the final result of the permutation parser is the function &lt;code&gt;f&lt;/code&gt; applied to the return value of &lt;code&gt;p&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead.</source>
          <target state="translated">表达式 &lt;code&gt;f &amp;lt;$?&amp;gt; (x,p)&lt;/code&gt; 创建一个由解析器 &lt;code&gt;p&lt;/code&gt; 组成的新鲜置换解析器。置换分析器的最终结果是将函数 &lt;code&gt;f&lt;/code&gt; 应用于 &lt;code&gt;p&lt;/code&gt; 的返回值。解析器 &lt;code&gt;p&lt;/code&gt; 是可选的-如果无法应用，则将使用默认值 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8fb79b3e4e6a014a406705b86fa9c5b9e188c8b4" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">表达式 &lt;code&gt;makeTokenParser language&lt;/code&gt; 创建一个 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 记录，该记录包含使用该 &lt;code&gt;language&lt;/code&gt; 记录中的定义定义的词法分析器。</target>
        </trans-unit>
        <trans-unit id="d2c369052f3c05736ed3d0aa835e5b9167fa8ef9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;makeTokenParser language&lt;/code&gt; creates a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; record that contains lexical parsers that are defined using the definitions in the &lt;code&gt;language&lt;/code&gt; record.</source>
          <target state="translated">表达式 &lt;code&gt;makeTokenParser language&lt;/code&gt; 创建一个 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:GenTokenParser&quot;&gt;GenTokenParser&lt;/a&gt;&lt;/code&gt; 记录，该记录包含使用该 &lt;code&gt;language&lt;/code&gt; 记录中的定义定义的词法分析器。</target>
        </trans-unit>
        <trans-unit id="8b086207ac432a47ad80161d4b4db423c87b1bcf" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;parseTest p input&lt;/code&gt; applies a parser &lt;code&gt;p&lt;/code&gt; against input &lt;code&gt;input&lt;/code&gt; and prints the result to stdout. Used for testing parsers.</source>
          <target state="translated">表达式 &lt;code&gt;parseTest p input&lt;/code&gt; 将解析器 &lt;code&gt;p&lt;/code&gt; 应用于输入 &lt;code&gt;input&lt;/code&gt; ，并将结果打印到stdout。用于测试解析器。</target>
        </trans-unit>
        <trans-unit id="7d09630aef55bc10a1cc5f993e20aa9d2c8fa633" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is optional - if it can not be applied, the default value &lt;code&gt;x&lt;/code&gt; will be used instead. Returns a new permutation parser that includes the optional parser &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;perm &amp;lt;||&amp;gt; (x,p)&lt;/code&gt; 将解析器 &lt;code&gt;p&lt;/code&gt; 添加到排列解析器 &lt;code&gt;perm&lt;/code&gt; 中。解析器 &lt;code&gt;p&lt;/code&gt; 是可选的-如果无法应用，则将使用默认值 &lt;code&gt;x&lt;/code&gt; 。返回一个新的排列分析器，其中包括可选的分析器 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9774c66620e8ebb6dc4947bd7a30ad32d4083961" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; 将解析器 &lt;code&gt;p&lt;/code&gt; 添加到排列解析器 &lt;code&gt;perm&lt;/code&gt; 中。解析器 &lt;code&gt;p&lt;/code&gt; 不允许接受空输入- 而是使用可选的组合器（ &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。返回包含 &lt;code&gt;p&lt;/code&gt; 的新排列分析器。</target>
        </trans-unit>
        <trans-unit id="c1eff7acfdc904aa55b95ecd8fd5d523b792b889" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; adds parser &lt;code&gt;p&lt;/code&gt; to the permutation parser &lt;code&gt;perm&lt;/code&gt;. The parser &lt;code&gt;p&lt;/code&gt; is not allowed to accept empty input - use the optional combinator (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt;) instead. Returns a new permutation parser that includes &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;perm &amp;lt;||&amp;gt; p&lt;/code&gt; 将解析器 &lt;code&gt;p&lt;/code&gt; 添加到排列解析器 &lt;code&gt;perm&lt;/code&gt; 中。解析器 &lt;code&gt;p&lt;/code&gt; 不允许接受空输入- 而是使用可选的组合器（ &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--63--62-&quot;&gt;&amp;lt;|?&amp;gt;&lt;/a&gt;&lt;/code&gt; ）。返回包含 &lt;code&gt;p&lt;/code&gt; 的新排列分析器。</target>
        </trans-unit>
        <trans-unit id="5b91ada54b3ba346f8466cd7a2f1f8bea7674bcd" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;s (t xs)&lt;/code&gt; does not match the rule &lt;code&gt;&quot;map/map&quot;&lt;/code&gt;, but GHC will substitute for &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, giving an expression which does match. If &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt; was (a) used more than once, and (b) large or a redex, then it would not be substituted, and the rule would not fire.</source>
          <target state="translated">表达式 &lt;code&gt;s (t xs)&lt;/code&gt; 与规则 &lt;code&gt;&quot;map/map&quot;&lt;/code&gt; 不匹配，但是GHC将替换 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;t&lt;/code&gt; ，从而给出了匹配的表达式。如果 &lt;code&gt;s&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 被（a）多次使用，并且（b）被大号或redex使用，则它将不会被替换，并且该规则将不会触发。</target>
        </trans-unit>
        <trans-unit id="efeb52340545b81120b442152fbbc21924dfa6d1" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;updatePosString pos s&lt;/code&gt; 通过对 &lt;code&gt;s&lt;/code&gt; 中的每个字符调用 &lt;code&gt;&lt;a href=&quot;text-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; 来更新源位置 &lt;code&gt;pos&lt;/code&gt; ，即。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a46b242264f8f265b934b320d1ad118b5d5d70f9" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;updatePosString pos s&lt;/code&gt; updates the source position &lt;code&gt;pos&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; on every character in &lt;code&gt;s&lt;/code&gt;, ie. &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;updatePosString pos s&lt;/code&gt; 通过对 &lt;code&gt;s&lt;/code&gt; 中的每个字符调用 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-pos#v:updatePosChar&quot;&gt;updatePosChar&lt;/a&gt;&lt;/code&gt; 来更新源位置 &lt;code&gt;pos&lt;/code&gt; ，即。 &lt;code&gt;foldl updatePosChar pos string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5483b1f876b299153ecdf0ce5e6d8239b22dcf61" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;. Its value (literal or negated literal) will be output.</source>
          <target state="translated">该表达式必须可以转换为 &lt;code&gt;long&lt;/code&gt; 或 &lt;code&gt;unsigned long&lt;/code&gt; 。将输出其值（文字或否定文字）。</target>
        </trans-unit>
        <trans-unit id="820e3f9e6884aadccb720549e1d4a6de8381de85" translate="yes" xml:space="preserve">
          <source>The expression must be convertible to const char pointer. Its value (string literal) will be output.</source>
          <target state="translated">表达式必须可以转换为const char指针,其值(字符串文字)将被输出。它的值(字符串文字)将被输出。</target>
        </trans-unit>
        <trans-unit id="0a5b6e32463e5a84d94f6198a0b148bf41758e64" translate="yes" xml:space="preserve">
          <source>The expression you are annotating with must have a type with &lt;code&gt;Typeable&lt;/code&gt; and &lt;code&gt;Data&lt;/code&gt; instances</source>
          <target state="translated">您要注释的表达式必须具有 &lt;code&gt;Typeable&lt;/code&gt; 和 &lt;code&gt;Data&lt;/code&gt; 实例的类型</target>
        </trans-unit>
        <trans-unit id="6a2b1973077b8ad117174952fdf79b72f3549905" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt;&lt;code&gt;ExplicitNamespaces&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeOperators&quot;&gt;&lt;code&gt;TypeOperators&lt;/code&gt;&lt;/a&gt; and (for some reason) by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extension-TypeOperators&quot;&gt; &lt;code&gt;TypeOperators&lt;/code&gt; &lt;/a&gt;和（由于某种原因）&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;暗示了&lt;a href=&quot;#extension-ExplicitNamespaces&quot;&gt; &lt;code&gt;ExplicitNamespaces&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="56045ff1bf81ad580973e6c5e5797cb6699258d1" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt;&lt;code&gt;MonoLocalBinds&lt;/code&gt;&lt;/a&gt; is implied by &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. You can switch it off again with &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; but type inference becomes less predictable if you do so. (Read the papers!)</source>
          <target state="translated">扩展&lt;a href=&quot;#extension-MonoLocalBinds&quot;&gt; &lt;code&gt;MonoLocalBinds&lt;/code&gt; &lt;/a&gt;被暗示&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;。您可以使用 &lt;code&gt;NoMonoLocalBinds&lt;/code&gt; 再次将其关闭，但是如果这样做，类型推断就变得难以预测。（阅读论文！）</target>
        </trans-unit>
        <trans-unit id="6edfbf43884f0659ca2c3eed2dacc284530ca4be" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt;&lt;code&gt;QuantifiedConstraints&lt;/code&gt;&lt;/a&gt; introduces &lt;strong&gt;quantified constraints&lt;/strong&gt;, which give a new level of expressiveness in constraints. For example, consider</source>
          <target state="translated">扩展&lt;a href=&quot;#extension-QuantifiedConstraints&quot;&gt; &lt;code&gt;QuantifiedConstraints&lt;/code&gt; &lt;/a&gt;引入了&lt;strong&gt;量化约束&lt;/strong&gt;，这使约束的表达能力达到了新的水平。例如，考虑</target>
        </trans-unit>
        <trans-unit id="5a1fbd6833d7bf7f6b464ba5557bf0f418ef8516" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-RecursiveDo&quot;&gt;&lt;code&gt;RecursiveDo&lt;/code&gt;&lt;/a&gt; also introduces a new keyword &lt;code&gt;rec&lt;/code&gt;, which wraps a mutually-recursive group of monadic statements inside a &lt;code&gt;do&lt;/code&gt; expression, producing a single statement. Similar to a &lt;code&gt;let&lt;/code&gt; statement inside a &lt;code&gt;do&lt;/code&gt;, variables bound in the &lt;code&gt;rec&lt;/code&gt; are visible throughout the &lt;code&gt;rec&lt;/code&gt; group, and below it. For example, compare</source>
          <target state="translated">&lt;a href=&quot;#extension-RecursiveDo&quot;&gt; &lt;code&gt;RecursiveDo&lt;/code&gt; &lt;/a&gt;扩展还引入了一个新的关键字 &lt;code&gt;rec&lt;/code&gt; ，它将一个相互递归的monadic语句组包装在 &lt;code&gt;do&lt;/code&gt; 表达式中，从而生成一个语句。类似于 &lt;code&gt;do&lt;/code&gt; 内的 &lt;code&gt;let&lt;/code&gt; 语句，在 &lt;code&gt;rec&lt;/code&gt; 组中及其下方，可以看到 &lt;code&gt;rec&lt;/code&gt; 中绑定的变量。例如比较</target>
        </trans-unit>
        <trans-unit id="2340bd5004afb06c66885f9f37fdc1ab908eab6d" translate="yes" xml:space="preserve">
          <source>The extension &lt;a href=&quot;#extension-TypeInType&quot;&gt;&lt;code&gt;TypeInType&lt;/code&gt;&lt;/a&gt; is now deprecated: its sole effect is to switch on &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; (and hence &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;) and &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在不赞成使用扩展名&lt;a href=&quot;#extension-TypeInType&quot;&gt; &lt;code&gt;TypeInType&lt;/code&gt; &lt;/a&gt;：它的唯一作用是打开&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;（以及&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;）和&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d7aee131ad6d19c93d8e0e5cef004d81b83103a" translate="yes" xml:space="preserve">
          <source>The extension adds a new kind of expression for defining arrows:</source>
          <target state="translated">该扩展为定义箭头增加了一种新的表达式。</target>
        </trans-unit>
        <trans-unit id="68fc04e40e72e9a26d6e832da587e68cf89dce71" translate="yes" xml:space="preserve">
          <source>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</source>
          <target state="translated">该扩展不能扩展到函数定义的左侧;你必须以前缀形式定义这样的函数。</target>
        </trans-unit>
        <trans-unit id="ad6ad2707106caf932a9bcc6bc55d2c587ffc598" translate="yes" xml:space="preserve">
          <source>The extension is enabled with the extension &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通过扩展&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; &lt;/a&gt;启用扩展。</target>
        </trans-unit>
        <trans-unit id="592f0075b3be7dea40fca2f7b78b5f78b8bee1db" translate="yes" xml:space="preserve">
          <source>The extension only affects definitions in this module.</source>
          <target state="translated">该扩展只影响本模块中的定义。</target>
        </trans-unit>
        <trans-unit id="dbed722a20b0c81708629361d2e36ddb255e740e" translate="yes" xml:space="preserve">
          <source>The fact that as many elements as possible are translated is used by the IO library in order to report translation errors at the point they actually occur, rather than when the buffer is translated.</source>
          <target state="translated">尽可能多的元素被翻译的事实被IO库使用,以便在它们实际发生的时候报告翻译错误,而不是在缓冲区被翻译的时候。</target>
        </trans-unit>
        <trans-unit id="c9688a61970d69ede4ef28783b4cdd7a6fa982ec" translate="yes" xml:space="preserve">
          <source>The field width is a minimum, not a maximum: it will be expanded as needed to avoid mutilating a value.</source>
          <target state="translated">字段宽度是最小值,而不是最大值:它将根据需要扩展,以避免残缺值。</target>
        </trans-unit>
        <trans-unit id="766dc6dc2e472365cee52e53c97df5ee0cb680d9" translate="yes" xml:space="preserve">
          <source>The fields in &lt;code&gt;Trade&lt;/code&gt; are marked as strict (using &lt;code&gt;!&lt;/code&gt;) since we don't need laziness here. In practise, you would probably consider using the UNPACK pragma as well. &lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Trade&lt;/code&gt; 中的字段被标记为严格（使用 &lt;code&gt;!&lt;/code&gt; ），因为我们在这里不需要懒惰。实际上，您可能还会考虑使用UNPACK编译指示。&lt;a href=&quot;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&quot;&gt;https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unpack-pragma&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5972e4dbbb1da0195c707d37fda525d476ee44e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;ExampleConstructor&lt;/code&gt; 的字段分别具有 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceStrictness&quot;&gt;NoSourceStrictness&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceLazy&quot;&gt;SourceLazy&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceStrict&quot;&gt;SourceStrict&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90aff6649fd9e503bb0cd5dab7faab1470bbcfc9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;ExampleConstructor&lt;/code&gt; 的字段分别具有 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:NoSourceUnpackedness&quot;&gt;NoSourceUnpackedness&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceNoUnpack&quot;&gt;SourceNoUnpack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#v:SourceUnpack&quot;&gt;SourceUnpack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="867052d71989ead15b5268bf62e49c7c19eae92d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;A.hs-boot&lt;/code&gt; is a programmer-written source file. It must live in the same directory as its parent source file &lt;code&gt;A.hs&lt;/code&gt;. Currently, if you use a literate source file &lt;code&gt;A.lhs&lt;/code&gt; you must also use a literate boot file, &lt;code&gt;A.lhs-boot&lt;/code&gt;; and vice versa.</source>
          <target state="translated">文件 &lt;code&gt;A.hs-boot&lt;/code&gt; 是程序员编写的源文件。它必须与其父源文件 &lt;code&gt;A.hs&lt;/code&gt; 位于同一目录中。当前，如果您使用识字源文件 &lt;code&gt;A.lhs&lt;/code&gt; ,则还必须使用识字启动文件 &lt;code&gt;A.lhs-boot&lt;/code&gt; ；反之亦然。</target>
        </trans-unit>
        <trans-unit id="9a674c835d28bfb6d72a5275286859913c1e00bf" translate="yes" xml:space="preserve">
          <source>The file contains package IDs and optionally package databases, one directive per line:</source>
          <target state="translated">该文件包含包ID和可选的包数据库,每行一个指令。</target>
        </trans-unit>
        <trans-unit id="d3dad592ba2c56d2ff45ef3e10379f2cd7056cb1" translate="yes" xml:space="preserve">
          <source>The file descriptor is ready to accept a write.</source>
          <target state="translated">文件描述符已经准备好接受写入。</target>
        </trans-unit>
        <trans-unit id="0a87aafdf7c80c25cee8605761116960c822dc15" translate="yes" xml:space="preserve">
          <source>The file is created with permissions such that only the current user can read/write it.</source>
          <target state="translated">创建文件的权限是只有当前用户可以读/写。</target>
        </trans-unit>
        <trans-unit id="cfb39651c9d8c9724affb75edf0166a16b2ab2da" translate="yes" xml:space="preserve">
          <source>The file-header pragmas are: &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt;, &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt;, and &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt;.</source>
          <target state="translated">文件头的编译指示为： &lt;code&gt;{-# LANGUAGE #-}&lt;/code&gt; ， &lt;code&gt;{-# OPTIONS_GHC #-}&lt;/code&gt; 和 &lt;code&gt;{-# INCLUDE #-}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ce398b5e4e0b12caa271926c6711a527e411174" translate="yes" xml:space="preserve">
          <source>The final build step that returns the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal.</source>
          <target state="translated">返回 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号的最后构建步骤。</target>
        </trans-unit>
        <trans-unit id="87005632e427f20e49e6f8bedc0a39a36ece9f40" translate="yes" xml:space="preserve">
          <source>The final bullet (about unifiying instances) makes GHC conservative about committing to an overlapping instance. For example:</source>
          <target state="translated">最后一个子弹(关于统一实例)使得GHC对承诺一个重叠的实例持保守态度。例如:</target>
        </trans-unit>
        <trans-unit id="1913f6cc3ff526a515670ed4f1b49aa9b4f8a2bf" translate="yes" xml:space="preserve">
          <source>The final form is just what we want: a simple case expression.</source>
          <target state="translated">最后的形式正是我们想要的:一个简单的案例表达式。</target>
        </trans-unit>
        <trans-unit id="f7d925c1be71fce63599be5c5644561348c21d6e" translate="yes" xml:space="preserve">
          <source>The final layout will be something like</source>
          <target state="translated">最终的布局将是这样的</target>
        </trans-unit>
        <trans-unit id="509bc33604e7ee8a244ab55cc215005d17244214" translate="yes" xml:space="preserve">
          <source>The finalizer is given the local type environment at the splice point. Thus &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; is able to find the local definitions when executed inside the finalizer.</source>
          <target state="translated">在拼接点为终结器指定了本地类型的环境。因此，当在finalizer中执行时， &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:reify&quot;&gt;reify&lt;/a&gt;&lt;/code&gt; 能够找到局部定义。</target>
        </trans-unit>
        <trans-unit id="147a1899cc99c9241165663b9d1797441102fedd" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">无论程序是否保留对 &lt;code&gt;&lt;a href=&quot;ghc-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 对象的引用，终结器以及键与值之间的关系都存在。</target>
        </trans-unit>
        <trans-unit id="d9f13e14cac52cb8d1ac6c69d4a111452644d3b2" translate="yes" xml:space="preserve">
          <source>The finalizer, and the relationship between the key and the value, exist regardless of whether the program keeps a reference to the &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; object or not.</source>
          <target state="translated">无论程序是否保留对 &lt;code&gt;&lt;a href=&quot;system-mem-weak#t:Weak&quot;&gt;Weak&lt;/a&gt;&lt;/code&gt; 对象的引用，终结器以及键与值之间的关系都存在。</target>
        </trans-unit>
        <trans-unit id="deaaee000865e026093bdaeb2c9fc2020dfc3055" translate="yes" xml:space="preserve">
          <source>The fine distinction between different kinds of parse errors allows the system to generate quite good error messages for the user. It also allows error messages that are formatted in different languages. Each kind of message is generated by different combinators:</source>
          <target state="translated">细致区分不同种类的解析错误,使得系统可以为用户生成相当好的错误信息。它还允许使用不同语言格式的错误信息。每一种信息都是由不同的组合器生成的。</target>
        </trans-unit>
        <trans-unit id="c672354048c81f22453abece53dcb4410b87ec06" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the left of the cursor, reversed. The second &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; argument is the contents of the line to the right of the cursor.</source>
          <target state="translated">第一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 参数是光标左侧行的内容，取反。第二个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 参数是游标右侧行的内容。</target>
        </trans-unit>
        <trans-unit id="e20d358fcdcc868c8bd11a6755028db0bb2e37f3" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Int32&lt;/code&gt; is for the tag. There are two &lt;code&gt;Float32&lt;/code&gt; fields because floating point types can&amp;rsquo;t overlap with other types, because of limitations of the code generator that we&amp;rsquo;re hoping to overcome in the future. The second alternative needs two &lt;code&gt;Float32&lt;/code&gt; fields: The &lt;code&gt;Word32&lt;/code&gt; field is for the &lt;code&gt;Word32#&lt;/code&gt; in the first alternative. The &lt;code&gt;Pointer&lt;/code&gt; field is shared between &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Maybe Int&lt;/code&gt; values of the alternatives.</source>
          <target state="translated">第一个 &lt;code&gt;Int32&lt;/code&gt; 用于标记。有两个 &lt;code&gt;Float32&lt;/code&gt; 字段，因为由于我们希望将来克服的代码生成器的局限性，浮点类型不能与其他类型重叠。第二种选择需要两个 &lt;code&gt;Float32&lt;/code&gt; 字段：第一种选择中的 &lt;code&gt;Word32&lt;/code&gt; 字段用于 &lt;code&gt;Word32#&lt;/code&gt; 。该 &lt;code&gt;Pointer&lt;/code&gt; 域之间共享的 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Maybe Int&lt;/code&gt; 替代的价值。</target>
        </trans-unit>
        <trans-unit id="349930f2f6ac001a1f1d9bc41ac40db08cbf14ec" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;(l,u)&lt;/code&gt; of each of these operations is a pair specifying the lower and upper bounds of a contiguous subrange of values.</source>
          <target state="translated">这些操作中的每一个的第一个参数 &lt;code&gt;(l,u)&lt;/code&gt; 是一对，用于指定值的连续子范围的下限和上限。</target>
        </trans-unit>
        <trans-unit id="da354ca0b85aa26c68bc2b60c29e2527cd434859" translate="yes" xml:space="preserve">
          <source>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC&amp;rsquo;s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that &lt;code&gt;k&lt;/code&gt; must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</source>
          <target state="translated">第一个项目符号只是意味着必须对作用域进行良好的监控。第二点涉及GHC推断依赖性的能力。推断此依赖关系很困难，并且GHC当前要求将依赖关系明确化，这意味着 &lt;code&gt;k&lt;/code&gt; 必须以类型变量的形式出现，这对于GHC来说显然是要依赖的。例如：</target>
        </trans-unit>
        <trans-unit id="5990c2111448ff95032208b84313c09eb4e8e7c7" translate="yes" xml:space="preserve">
          <source>The first clause of &amp;ldquo;compatible&amp;rdquo; is the more straightforward one. It says that the patterns of two distinct type family instances cannot overlap. For example, the following is disallowed:</source>
          <target state="translated">&amp;ldquo;兼容&amp;rdquo;的第一个子句更直接。它说两个不同类型的族实例的模式不能重叠。例如，不允许以下内容：</target>
        </trans-unit>
        <trans-unit id="0d05ff555d4b0984db447de192b3bf9a34809e33" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">的第一组分 &lt;code&gt;&lt;a href=&quot;ghc-float#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; ，在开区间（缩放到谎言 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; ），无论是 &lt;code&gt;0.0&lt;/code&gt; 或的绝对值 &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; ，其中， &lt;code&gt;b&lt;/code&gt; 是浮点基数。该行为在无限值或 &lt;code&gt;NaN&lt;/code&gt; 值上未指定。</target>
        </trans-unit>
        <trans-unit id="f4f7b2948c8c1ae005bcea73d45f0bbfbc9162d6" translate="yes" xml:space="preserve">
          <source>The first component of &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt;, scaled to lie in the open interval (&lt;code&gt;-1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;), either &lt;code&gt;0.0&lt;/code&gt; or of absolute value &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is the floating-point radix. The behaviour is unspecified on infinite or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">的第一组分 &lt;code&gt;&lt;a href=&quot;prelude#v:decodeFloat&quot;&gt;decodeFloat&lt;/a&gt;&lt;/code&gt; ，在开区间（缩放到谎言 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; ），无论是 &lt;code&gt;0.0&lt;/code&gt; 或的绝对值 &lt;code&gt;&amp;gt;= 1/b&lt;/code&gt; ，其中， &lt;code&gt;b&lt;/code&gt; 是浮点基数。该行为在无限值或 &lt;code&gt;NaN&lt;/code&gt; 值上未指定。</target>
        </trans-unit>
        <trans-unit id="7a78b840c5ec7a8bd0522ac73f6d9db7e7f7c6e2" translate="yes" xml:space="preserve">
          <source>The first constructor consists of a single field, which is the parameter &lt;code&gt;a&lt;/code&gt;. This is represented as &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt;.</source>
          <target state="translated">第一个构造函数包含一个字段，即参数 &lt;code&gt;a&lt;/code&gt; 。这表示为 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a491a7e0c75f57c1c82c6779842a217b78376985" translate="yes" xml:space="preserve">
          <source>The first element of the returned tuple is the prefix of &lt;code&gt;haystack&lt;/code&gt; up to and including the last match of &lt;code&gt;needle&lt;/code&gt;. The second is the remainder of &lt;code&gt;haystack&lt;/code&gt;, following the match.</source>
          <target state="translated">返回的元组的第一个元素是 &lt;code&gt;haystack&lt;/code&gt; 的前缀，直到并包括 &lt;code&gt;needle&lt;/code&gt; 的最后一个匹配项。第二个是剩余 &lt;code&gt;haystack&lt;/code&gt; ，跟随比赛。</target>
        </trans-unit>
        <trans-unit id="d48cef11152d7e2e71a8b3fb779c57c59642ed57" translate="yes" xml:space="preserve">
          <source>The first example from that paper is set out below (&lt;a href=&quot;#th-example&quot;&gt;A Template Haskell Worked Example&lt;/a&gt;) as a worked example to help get you started.</source>
          <target state="translated">该论文的第一个示例在下面列出（&lt;a href=&quot;#th-example&quot;&gt;Template Haskell Worked Example&lt;/a&gt;）作为帮助您入门的有效示例。</target>
        </trans-unit>
        <trans-unit id="9f5e8571c06e192e03c26745db1bf9e5167e5bff" translate="yes" xml:space="preserve">
          <source>The first example is a parser monad in the style of</source>
          <target state="translated">第一个例子是一个解析器单体,风格为</target>
        </trans-unit>
        <trans-unit id="0db21633e5e7584a4e85ed5e4b67955d4a3ea721" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将引发异常 &lt;code&gt;e&lt;/code&gt; ，而第二个示例则不会。实际上， &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用它时才会引发异常。该 &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;control-exception#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="7a9264a11b232afb865bd5a70544aaa9c229ee38" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将引发异常 &lt;code&gt;e&lt;/code&gt; ，而第二个示例则不会。实际上， &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用时会引发异常。该 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="00088afbc5cbb44faba064e52d1c85ccc7ca138f" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将引发异常 &lt;code&gt;e&lt;/code&gt; ，而第二个示例则不会。实际上， &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用时会引发异常。该 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="d99c86cee59c7b0e9addd7c9710d9c1d2d607961" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将引发异常 &lt;code&gt;e&lt;/code&gt; ，而第二个示例则不会。实际上， &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad中使用时会引发异常。该 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwSTM&quot;&gt;throwSTM&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="b34efd21f2daa7d49fe1224a63934d829e838b06" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将导致异常 &lt;code&gt;e&lt;/code&gt; ，而第二个则不会。实际上， &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用它时才会引发异常。该 &lt;code&gt;&lt;a href=&quot;ghc-io#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="c46e0719305fcb7afbedd529b28ef7ed1317a3e9" translate="yes" xml:space="preserve">
          <source>The first example will cause the exception &lt;code&gt;e&lt;/code&gt; to be raised, whereas the second one won't. In fact, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; will only cause an exception to be raised when it is used within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. The &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; variant should be used in preference to &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; to raise an exception within the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad because it guarantees ordering with respect to other &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, whereas &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">第一个示例将引发异常 &lt;code&gt;e&lt;/code&gt; ，而第二个示例则不会。事实上， &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 仅在在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中使用它时才会引发异常。该 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; 变种应优先用于 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 到内引发异常 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 单子，因为它保证订货相对于其他 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作，而 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:throw&quot;&gt;throw&lt;/a&gt;&lt;/code&gt; 不。</target>
        </trans-unit>
        <trans-unit id="8377e7f947ca82c2d03b9e96804a9cc74da945a8" translate="yes" xml:space="preserve">
          <source>The first form declares that &lt;code&gt;f&lt;/code&gt; is a (pure) C function that takes no arguments and returns a pointer to a C function with type &lt;code&gt;t&lt;/code&gt;, whereas the second form declares that &lt;code&gt;f&lt;/code&gt; itself is a C function with type &lt;code&gt;t&lt;/code&gt;. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</source>
          <target state="translated">第一种形式声明 &lt;code&gt;f&lt;/code&gt; 是一个（纯）C函数，不带任何参数，并返回指向类型 &lt;code&gt;t&lt;/code&gt; 的C函数的指针，而第二种形式则声明 &lt;code&gt;f&lt;/code&gt; 本身是一个类型 &lt;code&gt;t&lt;/code&gt; 的C函数。第一个声明通常是一个错误，并且一个很难调试的声明，因为它会导致崩溃，因此出现此警告。</target>
        </trans-unit>
        <trans-unit id="b437c04b578dcbe34c5b61a20dafa47889b4aaf9" translate="yes" xml:space="preserve">
          <source>The first four lines (&lt;code&gt;JOB&lt;/code&gt;, &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;SAMPLE_UNIT&lt;/code&gt;, &lt;code&gt;VALUE_UNIT&lt;/code&gt;) form a header. Each block of lines starting with &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; and ending with &lt;code&gt;END_SAMPLE&lt;/code&gt; forms a single sample (you can think of this as a vertical slice of your heap profile). The hp2ps utility should accept any input with a properly-formatted header followed by a series of &lt;em&gt;complete&lt;/em&gt; samples.</source>
          <target state="translated">前四行（ &lt;code&gt;JOB&lt;/code&gt; ， &lt;code&gt;DATE&lt;/code&gt; ， &lt;code&gt;SAMPLE_UNIT&lt;/code&gt; ， &lt;code&gt;VALUE_UNIT&lt;/code&gt; ）形成标题。每行以 &lt;code&gt;BEGIN_SAMPLE&lt;/code&gt; 开始并以 &lt;code&gt;END_SAMPLE&lt;/code&gt; 结尾的行形成一个样本（您可以将其视为堆配置文件的垂直切片）。 hp2ps实用程序应接受带有格式正确的标头的任何输入，然后输入一系列&lt;em&gt;完整的&lt;/em&gt;样本。</target>
        </trans-unit>
        <trans-unit id="c2b82a03029ef67f0b50718409c503eea389a692" translate="yes" xml:space="preserve">
          <source>The first letter of the input is converted to title case, as is every subsequent letter that immediately follows a non-letter. Every letter that immediately follows another letter is converted to lower case.</source>
          <target state="translated">输入的第一个字母被转换为标题大小写,紧跟在非字母后面的每个字母也是如此。紧跟在另一个字母后面的每一个字母都转换成小写。</target>
        </trans-unit>
        <trans-unit id="63efb85344c0aa9c20ebac363da48aba559537ad" translate="yes" xml:space="preserve">
          <source>The first matching axiom we encounter while entailing &lt;code&gt;C a&lt;/code&gt;, is &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt;. We have a local axiom &lt;code&gt;B a&lt;/code&gt; available, so now the program is suddenly accepted. This behaviour, where the ordering of an instance context determines whether or not the program is accepted, seems rather confusing for the developer.</source>
          <target state="translated">我们在要求 &lt;code&gt;C a&lt;/code&gt; 时遇到的第一个匹配公理是 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 。我们有一个本地公理 &lt;code&gt;B a&lt;/code&gt; ，所以现在程序突然被接受了。这种行为（实例上下文的顺序决定了程序是否被接受）对于开发人员来说似乎很混乱。</target>
        </trans-unit>
        <trans-unit id="0123b61d2574afe7df7113981a9973c5d86d2592" translate="yes" xml:space="preserve">
          <source>The first most common step is the concatenation of two &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Internally, concatenation corresponds to function composition. (Note that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s can be seen as difference-lists of buffer-filling functions; cf. &lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;. ) Function composition is a fast O(1) operation. However, we can use bounded primitives to remove some of these function compositions altogether, which is more efficient.</source>
          <target state="translated">最常见的第一步是两个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的串联。在内部，级联对应于功能组合。（请注意， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 可以看作是缓冲区填充功能的差异列表；请参见&lt;a href=&quot;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&quot;&gt;http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist&lt;/a&gt;。）函数组成是一个快速的O（ 1）操作。但是，我们可以使用有界原语来完全删除其中一些功能组合，这样效率更高。</target>
        </trans-unit>
        <trans-unit id="2b6aa4f035d3b73aa4ab4041c788e09ed98100cf" translate="yes" xml:space="preserve">
          <source>The first of the &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; operations, &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt;, is a simple action, so we can lift it through &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;InterpM&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">第一个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 操作操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; ，是一个简单的操作，因此我们可以使用 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 将它通过 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 提升到 &lt;code&gt;InterpM&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2faac1fc5843e8344edfa39159393215c540048a" translate="yes" xml:space="preserve">
          <source>The first of these is obviously fine. The second is still fine, although less obviously. The third is not Haskell 98, and risks losing termination of instances.</source>
          <target state="translated">其中第一种显然是好的。第二种还是可以的,虽然不太明显。第三种不是Haskell 98,并且有可能失去终止实例的风险。</target>
        </trans-unit>
        <trans-unit id="a23c2d18f54a6700ee1bddf4a4ced9e452ae0f90" translate="yes" xml:space="preserve">
          <source>The first option is to compile the program twice:</source>
          <target state="translated">第一种方案是将程序编译两次。</target>
        </trans-unit>
        <trans-unit id="b7637c081a47d73b9bc11cd583b13a110b93646f" translate="yes" xml:space="preserve">
          <source>The first part of the file gives the program name and options, and the total time and total memory allocation measured during the run of the program (note that the total memory allocation figure isn&amp;rsquo;t the same as the amount of &lt;em&gt;live&lt;/em&gt; memory needed by the program at any one time; the latter can be determined using heap profiling, which we will describe later in &lt;a href=&quot;#prof-heap&quot;&gt;Profiling memory usage&lt;/a&gt;).</source>
          <target state="translated">文件的第一部分提供了程序名称和选项，以及在程序运行过程中测得的总时间和总内存分配（请注意，总内存分配数字与主机运行时所需的&lt;em&gt;活动&lt;/em&gt;内存量不同）程序可以在任何时候进行；后者可以使用堆分析来确定，我们将在稍后的&lt;a href=&quot;#prof-heap&quot;&gt;分析内存使用情况中进行介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fef3e13957b592e13b7450a30e6df7cd6f143a71" translate="yes" xml:space="preserve">
          <source>The first phase to run is determined by each input-file suffix, and the last phase is determined by a flag. If no relevant flag is present, then go all the way through to linking. This table summarises:</source>
          <target state="translated">运行的第一个阶段由每个输入文件后缀决定,最后一个阶段由一个标志决定。如果没有相关标志,那么就一直走到链接。这个表总结了一下。</target>
        </trans-unit>
        <trans-unit id="145ee321d09d8f6c8d70bccf9d36b9f9aa7af807" translate="yes" xml:space="preserve">
          <source>The first thing we need is generic representations. The &lt;code&gt;GHC.Generics&lt;/code&gt; module defines a couple of primitive types that are used to represent Haskell datatypes:</source>
          <target state="translated">我们需要的第一件事是通用表示。所述 &lt;code&gt;GHC.Generics&lt;/code&gt; 模块定义一对夫妇的用于表示数据类型的Haskell原始类型：</target>
        </trans-unit>
        <trans-unit id="4a1ecb3ae40da3aae2e8c25cd4cee41373d627e8" translate="yes" xml:space="preserve">
          <source>The fixed point of a monadic computation. &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; executes the action &lt;code&gt;f&lt;/code&gt; only once, with the eventual output fed back as the input. Hence &lt;code&gt;f&lt;/code&gt; should not be strict, for then &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; would diverge.</source>
          <target state="translated">一元计算的固定点。 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 仅执行一次动作 &lt;code&gt;f&lt;/code&gt; ，最终的输出作为输入反馈。因此 &lt;code&gt;f&lt;/code&gt; 不应严格，因为 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt; f&lt;/code&gt; 会发散。</target>
        </trans-unit>
        <trans-unit id="3b861bc9465ad5c567e33d3c5ea5e7f4fe10fe04" translate="yes" xml:space="preserve">
          <source>The fixity of a type operator may be set using the usual fixity declarations but, as in &lt;a href=&quot;#infix-tycons&quot;&gt;Infix type constructors, classes, and type variables&lt;/a&gt;, the function and type constructor share a single fixity.</source>
          <target state="translated">可以使用通常的固定性声明来设置类型运算符的固定性，但是，就像在&lt;a href=&quot;#infix-tycons&quot;&gt;Infix类型构造函数，类和类型变量中一样&lt;/a&gt;，函数和类型构造函数共享一个固定性。</target>
        </trans-unit>
        <trans-unit id="397ad5d952fd5d1bd350537f1bb34e2a9d3464c7" translate="yes" xml:space="preserve">
          <source>The fixity of the constructor</source>
          <target state="translated">构造函数的固定性</target>
        </trans-unit>
        <trans-unit id="0127191c720e27284ab5a66b202e3464fd573afd" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; also lifts the corresponding restriction on class declarations (&lt;a href=&quot;#superclass-rules&quot;&gt;The superclasses of a class declaration&lt;/a&gt;) and instance declarations (&lt;a href=&quot;#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;).</source>
          <target state="translated">旗 &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt;还取消了对类声明（类声明&lt;a href=&quot;#superclass-rules&quot;&gt;的超类&lt;/a&gt;）和实例声明（&lt;a href=&quot;#instance-rules&quot;&gt;实例上下文的宽松规则&lt;/a&gt;）的相应限制。</target>
        </trans-unit>
        <trans-unit id="680d808c4989476cdf108f73531ac73891762a24" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt;&lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt;&lt;/a&gt; is similar to &lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt;, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</source>
          <target state="translated">标志&lt;a href=&quot;#ghc-flag--Wincomplete-uni-patterns&quot;&gt; &lt;code&gt;-Wincomplete-uni-patterns&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;相似，除了它仅适用于lambda表达式和模式绑定（仅允许单个模式的构造）之外：</target>
        </trans-unit>
        <trans-unit id="0b79e0ee85c7165a369baa04cb9639b641623921" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt; warns about user-written orphan rules or instances.</source>
          <target state="translated">标志&lt;a href=&quot;#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt;警告用户编写的孤立规则或实例。</target>
        </trans-unit>
        <trans-unit id="47cb0b5fb9b4f5cbc05ae1ed28f5f328bb28aed6" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; flag (see &lt;a href=&quot;debugging#dumping-output&quot;&gt;Dumping out compiler intermediate structures&lt;/a&gt;. For each file using Template Haskell, this will show the output in a &lt;code&gt;.dump-splices&lt;/code&gt; file.</source>
          <target state="translated">标志&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;显示发生时所有已键入和未键入的顶级声明接合的扩展。与所有转储标志一样，此输出的默认值是发送到stdout。对于非平凡的程序，您可能有兴趣将其与&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;结合使用标志结合使用（请参阅&lt;a href=&quot;debugging#dumping-output&quot;&gt;转储编译器中间结构&lt;/a&gt;。对于使用Template Haskell的每个文件，这将在 &lt;code&gt;.dump-splices&lt;/code&gt; 文件中显示输出。。</target>
        </trans-unit>
        <trans-unit id="4495b2a19abefc172f62863056de3aa383544711" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt;&lt;code&gt;-dth-dec-file&lt;/code&gt;&lt;/a&gt; dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file &lt;code&gt;M.th.hs&lt;/code&gt; for each module &lt;code&gt;M&lt;/code&gt; being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt;&lt;code&gt;-ddump-splices&lt;/code&gt;&lt;/a&gt; but it always generates a file instead of being coupled to &lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</source>
          <target state="translated">标志&lt;a href=&quot;debugging#ghc-flag--dth-dec-file&quot;&gt; &lt;code&gt;-dth-dec-file&lt;/code&gt; &lt;/a&gt;将正在编译的每个模块 &lt;code&gt;M&lt;/code&gt; 的所有顶级TH声明拼接的扩展（包括已键入和未键入）转储到文件 &lt;code&gt;M.th.hs&lt;/code&gt; 中。请注意，未显示其他类型的拼接（表达式，类型和模式）。应用程序开发人员可以将其检入到其存储库中，以便他们可以grep查找模板Haskell中定义的标识符。这类似于将&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;debugging#ghc-flag--ddump-splices&quot;&gt; &lt;code&gt;-ddump-splices&lt;/code&gt; &lt;/a&gt;但是它总是生成文件，而不是耦合到&lt;a href=&quot;debugging#ghc-flag--ddump-to-file&quot;&gt; &lt;code&gt;-ddump-to-file&lt;/code&gt; &lt;/a&gt;。格式也有所不同：它不显示原始文件中的代码，而是仅显示生成的代码，并具有原始文件的拼接位置的注释。</target>
        </trans-unit>
        <trans-unit id="b93b2c7d1b9eda88e393a8f5e74873331f11d482" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; controls whether type errors are deferred to runtime. Type errors will still be emitted as warnings, but will not prevent compilation. You can use &lt;code&gt;-Wno-type-errors&lt;/code&gt; to suppress these warnings.</source>
          <target state="translated">标志&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;控制是否将类型错误推迟到运行时。类型错误仍将作为警告发出，但不会阻止编译。您可以使用 &lt;code&gt;-Wno-type-errors&lt;/code&gt; 禁止显示这些警告。</target>
        </trans-unit>
        <trans-unit id="1b3baa03b1de2ae2d10fcb9504c97b6f24d46a7f" translate="yes" xml:space="preserve">
          <source>The flag &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; works in GHCi as well, with one exception: for &amp;ldquo;naked&amp;rdquo; expressions typed at the prompt, type errors don&amp;rsquo;t get delayed, so for example:</source>
          <target state="translated">标志&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;可以在GHCi中使用，但有一个例外：对于在提示符下键入的&amp;ldquo;裸&amp;rdquo;表达式，类型错误不会延迟，因此例如：</target>
        </trans-unit>
        <trans-unit id="7bc71daa56ee822998e1d64f92a7832d0f7badec" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fglasgow-exts&lt;/code&gt; is equivalent to enabling the following extensions:</source>
          <target state="translated">旗 &lt;code&gt;-fglasgow-exts&lt;/code&gt; 等效于启用以下扩展：</target>
        </trans-unit>
        <trans-unit id="bfe7b59eddf66920c11dffff433c9395a1cc1d4e" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; instructs &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; to reuse available &lt;code&gt;Show&lt;/code&gt; instances when possible. This happens only when the contents of the variable being inspected are completely evaluated.</source>
          <target state="translated">标志 &lt;code&gt;-fprint-evld-with-show&lt;/code&gt; 指示&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;重用可用 &lt;code&gt;Show&lt;/code&gt; 实例。仅当完全检查要检查的变量的内容时，才会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d43a045f4632b27bf091372de67333d21d36a1ae" translate="yes" xml:space="preserve">
          <source>The flag reference tables (&lt;a href=&quot;flags#flag-reference&quot;&gt;Flag reference&lt;/a&gt;) lists the status of each flag.</source>
          <target state="translated">标志参考表（&lt;a href=&quot;flags#flag-reference&quot;&gt; Flag reference&lt;/a&gt;）列出了每个标志的状态。</target>
        </trans-unit>
        <trans-unit id="960b0cead1ab39ce475efd50a401951d0d90317c" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt; control whether the resulting shared object links statically or dynamically to Haskell package libraries given as &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; option. Non-Haskell libraries are linked as gcc would regularly link it on your system, e.g. on most ELF system the linker uses the dynamic libraries when found.</source>
          <target state="translated">标志&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt;控制生成的共享对象是静态链接还是动态链接到作为 &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; 选项提供的Haskell软件包库。链接非Haskell库是因为gcc会定期将其链接到您的系统上，例如，在大多数ELF系统上，链接器会在找到动态库时使用动态库。</target>
        </trans-unit>
        <trans-unit id="7668d5e6fe85390adb7a3ecf19db212413e1eebc" translate="yes" xml:space="preserve">
          <source>The flags &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; have no effect when used with &lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, because they are implemented by changing the definition of &lt;code&gt;main&lt;/code&gt; that GHC generates. See &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt; for how to get the effect of &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt;&lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;&lt;/a&gt; when using your own &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">这些标志&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;与使用时没有任何效果&lt;a href=&quot;#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;，因为他们改变的定义来实现 &lt;code&gt;main&lt;/code&gt; 由GHC产生。请参阅&lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;使用您自己的main（）&lt;/a&gt;以获得使用自己的时如何获得&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9&quot;&gt; &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; &lt;/a&gt;的效果 &lt;code&gt;main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe514827a2bc8cfeb3427c13cc2ba47f6aba7300" translate="yes" xml:space="preserve">
          <source>The flags are:</source>
          <target state="translated">旗帜是:</target>
        </trans-unit>
        <trans-unit id="bcad0a34c93b0b86bbc687fc84b1ffd20b52d6a1" translate="yes" xml:space="preserve">
          <source>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (&lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt;), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</source>
          <target state="translated">浮点环境不会通过普通线程上下文切换保存。因此，如果您在一个线程中修改浮点状态，则那些更改可能在其他线程中可见。此外，测试异常状态是不可靠的，因为上下文切换可能会更改它。如果需要修改或测试浮点状态并使用线程，则必须使用绑定线程（ &lt;code&gt;Control.Concurrent.forkOS&lt;/code&gt; ），因为绑定线程具有自己的OS线程，并且OS线程会保存和还原浮点州。</target>
        </trans-unit>
        <trans-unit id="d84e5b1b19c72a9f2f8e38f56f6835541ed5d999" translate="yes" xml:space="preserve">
          <source>The following RTS option(s) affect the behaviour of Concurrent Haskell programs:</source>
          <target state="translated">以下 RTS 选项会影响并发 Haskell 程序的行为。</target>
        </trans-unit>
        <trans-unit id="52952117f68d88486d7181f97f7977ad0131a484" translate="yes" xml:space="preserve">
          <source>The following are QuickCheck specifications of what the combinators do. These can be seen as formal specifications of the behavior of the combinators.</source>
          <target state="translated">以下是关于组合器功能的QuickCheck规范。这些可以看作是组合器行为的形式化规范。</target>
        </trans-unit>
        <trans-unit id="880afa09746074737763ff34c90d8a824dfb1e1a" translate="yes" xml:space="preserve">
          <source>The following are definitions for &quot;merge&quot; for each of the heaps above. Each takes a comparison function which is used to order the elements.</source>
          <target state="translated">以下是上面每个堆的 &quot;merge &quot;的定义。每个堆都有一个比较函数,用来对元素进行排序。</target>
        </trans-unit>
        <trans-unit id="9031e690866836bd079eb18cd7f2cf6f4a7c0278" translate="yes" xml:space="preserve">
          <source>The following are definitions for &lt;code&gt;popMin&lt;/code&gt;, a function which constructs a stateful action which pops the smallest element from the queue, where &quot;smallest&quot; is according to the supplied comparison function.</source>
          <target state="translated">以下是 &lt;code&gt;popMin&lt;/code&gt; 的定义，该函数构造一个有状态操作，该操作从队列中弹出最小的元素，其中&amp;ldquo;最小&amp;rdquo;是根据所提供的比较函数而定。</target>
        </trans-unit>
        <trans-unit id="853c1b2416dd00409c8f94cbaaab4d500ad921b0" translate="yes" xml:space="preserve">
          <source>The following are definitions for functions to build queues, given a comparison function.</source>
          <target state="translated">下面是给定比较函数,建立队列的函数定义。</target>
        </trans-unit>
        <trans-unit id="00e5f1459a91351f85b76ba47f587250af056d92" translate="yes" xml:space="preserve">
          <source>The following are definitions for various specialized pairing heaps.</source>
          <target state="translated">以下是各种专用配对堆的定义。</target>
        </trans-unit>
        <trans-unit id="bcfac859b1b4efae75f25f72bc0530006c88e6e1" translate="yes" xml:space="preserve">
          <source>The following are good consumers:</source>
          <target state="translated">以下是好的消费者。</target>
        </trans-unit>
        <trans-unit id="415fb3cf16155d23aebc101af30f40f1175a4761" translate="yes" xml:space="preserve">
          <source>The following are good producers:</source>
          <target state="translated">以下是优秀的生产者。</target>
        </trans-unit>
        <trans-unit id="fc2c73f87b7ae21e5d1bff7544c615fae9cb5d03" translate="yes" xml:space="preserve">
          <source>The following behaves as expected:</source>
          <target state="translated">下面的行为符合预期。</target>
        </trans-unit>
        <trans-unit id="0f147698ae3534209b092f6955e20175ff56a36f" translate="yes" xml:space="preserve">
          <source>The following command works to load new packages into a running GHCi:</source>
          <target state="translated">以下命令用于将新的软件包加载到正在运行的GHCi中。</target>
        </trans-unit>
        <trans-unit id="e7ad1243df876884047bbd1cfa2abad6fc2f257e" translate="yes" xml:space="preserve">
          <source>The following commands turn the keypad on/off (&lt;code&gt;smkx&lt;/code&gt; and &lt;code&gt;rmkx&lt;/code&gt;). They have no effect if those capabilities are not defined. For portability between terminals, the keypad should be explicitly turned on before accepting user key input.</source>
          <target state="translated">以下命令打开/关闭键盘（ &lt;code&gt;smkx&lt;/code&gt; 和 &lt;code&gt;rmkx&lt;/code&gt; ）。如果未定义这些功能，则它们无效。为了实现端子之间的可移植性，应在接受用户按键输入之前明确打开键盘。</target>
        </trans-unit>
        <trans-unit id="25f14bebf678b2e0c7df12fa6531f8bc946288ab" translate="yes" xml:space="preserve">
          <source>The following definition is available to C programs inter-operating with Haskell code when including the header &lt;code&gt;HsFFI.h&lt;/code&gt;.</source>
          <target state="translated">当包含标头 &lt;code&gt;HsFFI.h&lt;/code&gt; 时，与Haskell代码进行互操作的C程序可以使用以下定义。</target>
        </trans-unit>
        <trans-unit id="e6d695a5cf6d19ccd0a26b89aff9c95dd12f497b" translate="yes" xml:space="preserve">
          <source>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</source>
          <target state="translated">以下关于功能依赖的动机和使用的描述来自于Hugs用户手册,在Mark Jones的允许下,在此转载(略有改动)。</target>
        </trans-unit>
        <trans-unit id="255eb2a60233998edc485b972b2b920903f06efc" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">以下等式与 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 相关：</target>
        </trans-unit>
        <trans-unit id="713d7c0768135036f33a7e1109e709b8e968874e" translate="yes" xml:space="preserve">
          <source>The following equation relates &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">以下等式与 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldrN&quot;&gt;unfoldrN&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; 相关：</target>
        </trans-unit>
        <trans-unit id="dbc7d38cb4fbd659d01d9a4ef580cbd8a454bdc2" translate="yes" xml:space="preserve">
          <source>The following extra instances are defined:</source>
          <target state="translated">定义了以下额外的实例:</target>
        </trans-unit>
        <trans-unit id="219485ecc6b675dce37eba80ce2494e945235236" translate="yes" xml:space="preserve">
          <source>The following flags are simple ways to select standard &amp;ldquo;packages&amp;rdquo; of warnings:</source>
          <target state="translated">以下标志是选择警告的标准&amp;ldquo;包&amp;rdquo;的简单方法：</target>
        </trans-unit>
        <trans-unit id="9e8f2bd1d4e584f03bc71486665d6449cff997d8" translate="yes" xml:space="preserve">
          <source>The following flags control the way in which GHC displays types in error messages and in GHCi:</source>
          <target state="translated">以下标志控制了GHC在错误信息和GHCi中显示类型的方式。</target>
        </trans-unit>
        <trans-unit id="369fd24532366a269db0dd996324b5e45dfd6c9e" translate="yes" xml:space="preserve">
          <source>The following functions allow a thread to control delivery of asynchronous exceptions during a critical region.</source>
          <target state="translated">以下函数允许线程在临界区域内控制异步异常的传递。</target>
        </trans-unit>
        <trans-unit id="cf919ec9ecd009bd434b357d75af7e1bf8279715" translate="yes" xml:space="preserve">
          <source>The following functions enable cross-platform output of text that may contain Unicode characters.</source>
          <target state="translated">以下功能可以跨平台输出可能包含Unicode字符的文本。</target>
        </trans-unit>
        <trans-unit id="38af53e84d563801f65a6120a4900e75bb8e39ff" translate="yes" xml:space="preserve">
          <source>The following functions for cursor movement will combine the more primitive capabilities. For example, &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; may use either &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; depending on the parameter and which of &lt;code&gt;cud&lt;/code&gt; and &lt;code&gt;cud1&lt;/code&gt; are defined.</source>
          <target state="translated">下列用于光标移动的功能将结合更多原始功能。例如， &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:moveDown&quot;&gt;moveDown&lt;/a&gt;&lt;/code&gt; 可以使用任一 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown&quot;&gt;cursorDown&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:cursorDown1&quot;&gt;cursorDown1&lt;/a&gt;&lt;/code&gt; 根据参数和其中的 &lt;code&gt;cud&lt;/code&gt; 和 &lt;code&gt;cud1&lt;/code&gt; 定义中的。</target>
        </trans-unit>
        <trans-unit id="0b7bd1ee8d2490e346b323a061ee5d6bf4bd98aa" translate="yes" xml:space="preserve">
          <source>The following functions read one line or character of input from the user.</source>
          <target state="translated">以下功能读取用户输入的一行或一个字符。</target>
        </trans-unit>
        <trans-unit id="defeb72fa9fc8defce3095a722d77cd56b0b0897" translate="yes" xml:space="preserve">
          <source>The following holds:</source>
          <target state="translated">下面的情况是:</target>
        </trans-unit>
        <trans-unit id="0e843336042b652d443e731d806dae137491a142" translate="yes" xml:space="preserve">
          <source>The following instances of &lt;code&gt;MonadFix&lt;/code&gt; are automatically provided: List, Maybe, IO. Furthermore, the &lt;code&gt;Control.Monad.ST&lt;/code&gt; and &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; modules provide the instances of the &lt;code&gt;MonadFix&lt;/code&gt; class for Haskell&amp;rsquo;s internal state monad (strict and lazy, respectively).</source>
          <target state="translated">自动提供以下 &lt;code&gt;MonadFix&lt;/code&gt; 实例：List，Maybe，IO。此外， &lt;code&gt;Control.Monad.ST&lt;/code&gt; 和 &lt;code&gt;Control.Monad.ST.Lazy&lt;/code&gt; 模块为Haskell的内部状态monad 提供了 &lt;code&gt;MonadFix&lt;/code&gt; 类的实例（分别为strict和lazy）。</target>
        </trans-unit>
        <trans-unit id="974f2bea79592d4497c7bb6f1878062d29b69e35" translate="yes" xml:space="preserve">
          <source>The following laws ought to hold (for all valid bit indices &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;):</source>
          <target state="translated">应当遵循以下定律（对于所有有效位索引 &lt;code&gt;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3bc96821c04daf88673e5973fb7e13baaeb66bc4" translate="yes" xml:space="preserve">
          <source>The following operations are guaranteed not to be interruptible:</source>
          <target state="translated">以下操作保证不被中断。</target>
        </trans-unit>
        <trans-unit id="740d5fed1fd466547dd8bedbd7c0b84313346d32" translate="yes" xml:space="preserve">
          <source>The following options affect the way the runtime schedules threads on CPUs:</source>
          <target state="translated">以下选项会影响运行时在CPU上调度线程的方式。</target>
        </trans-unit>
        <trans-unit id="2b8d3fdea7e46b30a4c9898c10dbf48da92a4aa0" translate="yes" xml:space="preserve">
          <source>The following options are useful for keeping (or not keeping) certain intermediate files around, when normally GHC would throw these away after compilation:</source>
          <target state="translated">下面的选项对于保留(或不保留)某些中间文件很有用,通常GHC会在编译后把这些文件扔掉。</target>
        </trans-unit>
        <trans-unit id="38c3f1cd516a144b167f804cbad9091a110d7738" translate="yes" xml:space="preserve">
          <source>The following property holds</source>
          <target state="translated">下面的属性成立</target>
        </trans-unit>
        <trans-unit id="c4d20004308e57029d6af08f5d4d162927106726" translate="yes" xml:space="preserve">
          <source>The following relationships hold:</source>
          <target state="translated">以下关系成立:</target>
        </trans-unit>
        <trans-unit id="78400d597f1cd2c8bbeafc9eb8299b783cc0473e" translate="yes" xml:space="preserve">
          <source>The following sections also give some hints and tips on the use of the foreign function interface in GHC.</source>
          <target state="translated">下面的章节也给出了一些关于GHC中外函数接口使用的提示和技巧。</target>
        </trans-unit>
        <trans-unit id="f17c609e8f1c6b37d3130d2dff0e1652b3175021" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">以下应该起作用，因为 &lt;code&gt;'1'&lt;/code&gt; 和 &lt;code&gt;'2'&lt;/code&gt; 都可以解析为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f604ae57c21e961a4347d16a255de560a7918fb" translate="yes" xml:space="preserve">
          <source>The following should work, since both &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'2'&lt;/code&gt; can be parsed as &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">以下应该起作用，因为 &lt;code&gt;'1'&lt;/code&gt; 和 &lt;code&gt;'2'&lt;/code&gt; 都可以解析为 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f68ed3cdb6c1e1e040a389af1a8ea7b8ca3ea19d" translate="yes" xml:space="preserve">
          <source>The following syntax is stolen:</source>
          <target state="translated">下面的语法是偷来的。</target>
        </trans-unit>
        <trans-unit id="f24a325a1df690e88417cf55ef160f4f9b155bda" translate="yes" xml:space="preserve">
          <source>The following unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6): &lt;code&gt;Int#&lt;/code&gt;, &lt;code&gt;Word#&lt;/code&gt;, &lt;code&gt;Char#&lt;/code&gt;, &lt;code&gt;Float#&lt;/code&gt;, &lt;code&gt;Double#&lt;/code&gt;, &lt;code&gt;Addr#&lt;/code&gt;, &lt;code&gt;StablePtr# a&lt;/code&gt;, &lt;code&gt;MutableByteArray#&lt;/code&gt;, &lt;code&gt;ForeignObj#&lt;/code&gt;, and &lt;code&gt;ByteArray#&lt;/code&gt;.</source>
          <target state="translated">以下未装箱的类型可用作基本的外部类型（请参阅FFI章，第8.6节）： &lt;code&gt;Int#&lt;/code&gt; ， &lt;code&gt;Word#&lt;/code&gt; ， &lt;code&gt;Char#&lt;/code&gt; ， &lt;code&gt;Float#&lt;/code&gt; ， &lt;code&gt;Double#&lt;/code&gt; ， &lt;code&gt;Addr#&lt;/code&gt; ， &lt;code&gt;StablePtr# a&lt;/code&gt; ， &lt;code&gt;MutableByteArray#&lt;/code&gt; ， &lt;code&gt;ForeignObj#&lt;/code&gt; 和 &lt;code&gt;ByteArray#&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
