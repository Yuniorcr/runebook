<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="c1d77e21a24f58ed3cfa9fc40fc67b161d6efb10" translate="yes" xml:space="preserve">
          <source>Use the compiler flag &lt;code&gt;-fno-cse&lt;/code&gt; to prevent common sub-expression elimination being performed on the module, which might combine two side effects that were meant to be separate. A good example is using multiple global variables (like &lt;code&gt;test&lt;/code&gt; in the example below).</source>
          <target state="translated">使用编译器标志 &lt;code&gt;-fno-cse&lt;/code&gt; 可以防止在模块上执行常见的子表达式消除，这可能会使原本应该分开的两个副作用结合在一起。一个很好的示例是使用多个全局变量（例如下面的示例中的 &lt;code&gt;test&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="05f98fdb0a464272614c6fe514e416fde94c65c8" translate="yes" xml:space="preserve">
          <source>Use the debug flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt;&lt;code&gt;-ddump-simpl-stats&lt;/code&gt;&lt;/a&gt; to see what rules fired. If you need more information, then &lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt;&lt;code&gt;-ddump-rule-firings&lt;/code&gt;&lt;/a&gt; shows you each individual rule firing and &lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt;&lt;code&gt;-ddump-rule-rewrites&lt;/code&gt;&lt;/a&gt; also shows what the code looks like before and after the rewrite.</source>
          <target state="translated">使用调试标志&lt;a href=&quot;debugging#ghc-flag--ddump-simpl-stats&quot;&gt; &lt;code&gt;-ddump-simpl-stats&lt;/code&gt; &lt;/a&gt;可以查看触发了哪些规则。如果需要更多信息，则&lt;a href=&quot;debugging#ghc-flag--ddump-rule-firings&quot;&gt; &lt;code&gt;-ddump-rule-firings&lt;/code&gt; &lt;/a&gt;显示每个单独的规则触发，&lt;a href=&quot;debugging#ghc-flag--ddump-rule-rewrites&quot;&gt; &lt;code&gt;-ddump-rule-rewrites&lt;/code&gt; &lt;/a&gt;还显示重写前后的代码。</target>
        </trans-unit>
        <trans-unit id="31025e911529ebd63f8206b2d16a61f3669154ce" translate="yes" xml:space="preserve">
          <source>Use the debugging runtime</source>
          <target state="translated">使用调试运行时</target>
        </trans-unit>
        <trans-unit id="144d20ef0b0c9d8763e7b3511495086ba6c61351" translate="yes" xml:space="preserve">
          <source>Use the graph colouring register allocator for register allocation in the native code generator. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用图形着色寄存器分配器在本机代码生成器中分配寄存器。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="f8346b41ccfa200a85cecf48a8e542509566a4d6" translate="yes" xml:space="preserve">
          <source>Use the iterative coalescing graph colouring register allocator in the native code generator.</source>
          <target state="translated">在本机代码生成器中使用迭代凝聚图着色寄存器分配器。</target>
        </trans-unit>
        <trans-unit id="bc6eaa52001219c7a0e89385d4db8d4bec3bd8c1" translate="yes" xml:space="preserve">
          <source>Use the native newline representation on both input and output</source>
          <target state="translated">在输入和输出上使用本机换行表示。</target>
        </trans-unit>
        <trans-unit id="b94051e0d240dec7f44d3ae63663006f51a70e2e" translate="yes" xml:space="preserve">
          <source>Use the new cfg based block layout algorithm.</source>
          <target state="translated">使用新的基于cfg的区块布局算法。</target>
        </trans-unit>
        <trans-unit id="621ad9797959ada9554dba1b4e40103b721856b4" translate="yes" xml:space="preserve">
          <source>Use the package environment in ⟨file⟩, or in &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; If set to &lt;code&gt;-&lt;/code&gt; no package environment is read.</source>
          <target state="translated">在⟨file⟩或 &lt;code&gt;$HOME/.ghc/arch-os-version/environments/⟨name⟩&lt;/code&gt; 软件包环境。如果设置为 &lt;code&gt;-&lt;/code&gt; 不读取软件包环境。</target>
        </trans-unit>
        <trans-unit id="0e928c9363dc2761d919623c37eb23f20043344b" translate="yes" xml:space="preserve">
          <source>Use the private-use escape mechanism to attempt to allow illegal sequences to be roundtripped.</source>
          <target state="translated">使用私用转义机制,试图让非法序列被绕过。</target>
        </trans-unit>
        <trans-unit id="fe223bc5664e0dbbbb86d91d8f8e20115be7c77e" translate="yes" xml:space="preserve">
          <source>Use the runtime flag &lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt;&lt;code&gt;--info&lt;/code&gt;&lt;/a&gt; on the executable program to see the options set with &lt;code&gt;-with-rtsopts&lt;/code&gt;.</source>
          <target state="translated">使用可执行程序上的运行时标志&lt;a href=&quot;runtime_control#rts-flag---info&quot;&gt; &lt;code&gt;--info&lt;/code&gt; &lt;/a&gt;可以查看使用 &lt;code&gt;-with-rtsopts&lt;/code&gt; 设置的选项。</target>
        </trans-unit>
        <trans-unit id="0d0e51d18f065395391915a571efbca349dbf8ff" translate="yes" xml:space="preserve">
          <source>Use the specified package environment.</source>
          <target state="translated">使用指定的包环境。</target>
        </trans-unit>
        <trans-unit id="a4cdd1140930338cd84d92d2d4f03e8bbf83e2f9" translate="yes" xml:space="preserve">
          <source>Use the supplied Handle</source>
          <target state="translated">使用附带的手柄</target>
        </trans-unit>
        <trans-unit id="3c447f3debfd4d77bf363bb22fe9e22b23154955" translate="yes" xml:space="preserve">
          <source>Use the threaded runtime</source>
          <target state="translated">使用线程运行时</target>
        </trans-unit>
        <trans-unit id="5893cdc411d65af273e86691b8f798550a825ef2" translate="yes" xml:space="preserve">
          <source>Use the type being pushed in to the record update, as in the following:</source>
          <target state="translated">使用被推送到记录更新中的类型,如下所示。</target>
        </trans-unit>
        <trans-unit id="8155ca974b5f10eabbc2c9fa6db785cf2b7e95de" translate="yes" xml:space="preserve">
          <source>Use the windows CREATE_NEW_CONSOLE flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">创建进程时使用windows的CREATE_NEW_CONSOLE标志;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="076eeb25f49f7ce0697c6ad0d6b033989c99f7be" translate="yes" xml:space="preserve">
          <source>Use the windows DETACHED_PROCESS flag when creating the process; does nothing on other platforms.</source>
          <target state="translated">创建进程时使用windows的DETACHED_PROCESS标志;在其他平台上不做任何操作。</target>
        </trans-unit>
        <trans-unit id="12dc915cf8e611c4a5bbf96add0aeb690c53aa47" translate="yes" xml:space="preserve">
          <source>Use this function &lt;em&gt;only&lt;/em&gt; in the rare case that you have actually observed a performance loss due to the use of bound threads. A program that doesn't need its main thread to be bound and makes &lt;em&gt;heavy&lt;/em&gt; use of concurrency (e.g. a web server), might want to wrap its &lt;code&gt;main&lt;/code&gt; action in &lt;code&gt;runInUnboundThread&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;仅&lt;/em&gt;在极少数情况下由于使用绑定线程而实际导致性能下降的情况下，&lt;em&gt;才&lt;/em&gt;使用此功能。不需要绑定主线程并&lt;em&gt;大量&lt;/em&gt;使用并发性的程序（例如Web服务器），可能要将其 &lt;code&gt;main&lt;/code&gt; 操作包装在 &lt;code&gt;runInUnboundThread&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="2fbe341ed72c59fb75fa6a4a5047d697d5105b52" translate="yes" xml:space="preserve">
          <source>Use this function is to implement efficient encoders for text-based formats like JSON or HTML.</source>
          <target state="translated">使用该函数是为了实现基于文本格式(如JSON或HTML)的高效编码器。</target>
        </trans-unit>
        <trans-unit id="597699da79003c9f11a8170c1b3b401789da4fea" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此函数从较小的（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 创建 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，或者如果您需要确保 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 不与 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 生成的块共享，则使用此函数。</target>
        </trans-unit>
        <trans-unit id="40d805c5f47d1eda4e3e392efeab020927b7af69" translate="yes" xml:space="preserve">
          <source>Use this function to create &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from smallish (&lt;code&gt;&amp;lt;= 4kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s or if you need to guarantee that the &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; is not shared with the chunks generated by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此函数从较小的（ &lt;code&gt;&amp;lt;= 4kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 创建 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; ，或者如果您需要确保 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 不与 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 生成的块共享，则使用此函数。</target>
        </trans-unit>
        <trans-unit id="b0d21a0c0848e2fe24c35241efc6aba2596b116b" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are discarded right after they are generated. For example, if you just generate them to write them to a network socket.</source>
          <target state="translated">使用此策略来生成惰性 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,其块在生成后立即被丢弃。例如，如果仅生成它们以将它们写入网络套接字。</target>
        </trans-unit>
        <trans-unit id="b3896a54fb513e8f65a867da9dc52309786700cc" translate="yes" xml:space="preserve">
          <source>Use this strategy for generating lazy &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s whose chunks are likely to survive one garbage collection. This strategy trims buffers that are filled less than half in order to avoid spilling too much memory.</source>
          <target state="translated">使用此策略来生成懒惰的 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; ,其块很可能在一个垃圾回收中仍然存在。此策略会修剪填充不足一半的缓冲区，以避免溢出过多的内存。</target>
        </trans-unit>
        <trans-unit id="1939c777b53d41b8b4e7104cff916c96b4a7c053" translate="yes" xml:space="preserve">
          <source>Use unboxed types (a GHC extension):</source>
          <target state="translated">使用未装箱的类型(GHC扩展)。</target>
        </trans-unit>
        <trans-unit id="02c50c019808c45b0dca4dff7fb4c84f4971f171" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">打印表达式，类型和种类时，请使用unicode语法。另请参见&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1217e1edd93d0feba5136f9afad7e849709839fd" translate="yes" xml:space="preserve">
          <source>Use unicode syntax when printing expressions, types and kinds. See also &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a5442d751be61fc485493c3b80caf299427002" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:caseE&quot;&gt;caseE&lt;/a&gt;&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="eb059e8d4d640a98cf37158c3bbc517ef2335d75" translate="yes" xml:space="preserve">
          <source>Use with &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;language-haskell-th-lib-internal#v:funD&quot;&gt;funD&lt;/a&gt;&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="a7c895629df0d08bc454b5180ba8b8f749d5e729" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler</source>
          <target state="translated">使用⟨cmd⟩作为C编译器。</target>
        </trans-unit>
        <trans-unit id="3b19fb7d83e0550bc9d6938909644b80cc44debf" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C compiler.</source>
          <target state="translated">使用⟨cmd⟩作为C编译器。</target>
        </trans-unit>
        <trans-unit id="48e5e2c2e148dc62026ced8a7307093b27049893" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only)</source>
          <target state="translated">将⟨cmd⟩用作C预处理器（仅与 &lt;code&gt;-cpp&lt;/code&gt; 配合使用）</target>
        </trans-unit>
        <trans-unit id="01b0b15ae4e5390c5b9fd9ed11028c5a3806955a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the C pre-processor (with &lt;code&gt;-cpp&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为C预处理程序（仅与 &lt;code&gt;-cpp&lt;/code&gt; 配合使用）。</target>
        </trans-unit>
        <trans-unit id="bd777d1b368559dc8f94f852a03bdd03d5c158b7" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator</source>
          <target state="translated">使用⟨cmd⟩作为DLL生成器。</target>
        </trans-unit>
        <trans-unit id="789f1801d66fb6195efab4aa1b2123da996a8572" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the DLL generator.</source>
          <target state="translated">使用⟨cmd⟩作为DLL生成器。</target>
        </trans-unit>
        <trans-unit id="b27a03dda1cfc10ac7e5c1cd38f3ff58004f4f40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler</source>
          <target state="translated">使用⟨cmd⟩作为LLVM编译器。</target>
        </trans-unit>
        <trans-unit id="1436e09dd97ed0423b0bd42c04ab22ffaac47e27" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM compiler.</source>
          <target state="translated">使用⟨cmd⟩作为LLVM编译器。</target>
        </trans-unit>
        <trans-unit id="53809f0ed5671c0b308870f2ae7256160fc842ef" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser</source>
          <target state="translated">使用⟨cmd⟩作为LLVM优化器。</target>
        </trans-unit>
        <trans-unit id="aaf8f14c77b588ce45629e8618e368236c9a5b16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the LLVM optimiser.</source>
          <target state="translated">使用⟨cmd⟩作为LLVM优化器。</target>
        </trans-unit>
        <trans-unit id="f4353f860ce7ec12fdb2801304532e01df4d8f16" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler</source>
          <target state="translated">使用⟨cmd⟩作为汇编器。</target>
        </trans-unit>
        <trans-unit id="6410b4096f4180f08edab2aa46f3bb1a6e286a5a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the assembler.</source>
          <target state="translated">使用⟨cmd⟩作为汇编器。</target>
        </trans-unit>
        <trans-unit id="bb31dfc0c69b643471fc895b68566295b7824e3e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;a href=&quot;phases#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6eacbfc9012ab6009581fcb6ca48bb6bcb8883" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the command for libtool (with &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool的命令（仅用于 &lt;code&gt;-staticlib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="71a83bd18619d2dc927e0bb5ca8f99a89d38bbb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6db1d3ff7c078c6ed925326bc988128971d3e6a" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command (see: &lt;a href=&quot;ghci#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;). Default: &lt;code&gt;ghc-iserv-prof&lt;/code&gt; if &lt;code&gt;-prof&lt;/code&gt; is enabled, &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; if &lt;code&gt;-dynamic&lt;/code&gt; is enabled, or &lt;code&gt;ghc-iserv&lt;/code&gt; otherwise.</source>
          <target state="translated">使用⟨cmd⟩作为外部解释器命令（请参阅：&lt;a href=&quot;ghci#external-interpreter&quot;&gt;在单独的进程中运行解释器&lt;/a&gt;）。默认值： &lt;code&gt;ghc-iserv-prof&lt;/code&gt; 如果 &lt;code&gt;-prof&lt;/code&gt; 启用， &lt;code&gt;ghc-iserv-dyn&lt;/code&gt; 如果 &lt;code&gt;-dynamic&lt;/code&gt; 启用或 &lt;code&gt;ghc-iserv&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="c4e9da7f5bb3b749e809cd18b20a8233dfd64c38" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the external interpreter command.</source>
          <target state="translated">使用⟨cmd⟩作为外部解释器命令。</target>
        </trans-unit>
        <trans-unit id="481e440a89078b7c2339966f16ab888ce0b1d958" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;a href=&quot;#ghc-flag--staticlib&quot;&gt;&lt;code&gt;-staticlib&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33602c22bf82b32ce392224b8386b32a3918beba" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the libtool command (when using &lt;code&gt;-staticlib&lt;/code&gt; only).</source>
          <target state="translated">使用⟨cmd⟩作为libtool命令（仅当使用 &lt;code&gt;-staticlib&lt;/code&gt; 时）。</target>
        </trans-unit>
        <trans-unit id="8825dbbd517730047c01dd2f1cb0fdf5aecfff1f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker</source>
          <target state="translated">使用⟨cmd⟩作为链接器。</target>
        </trans-unit>
        <trans-unit id="ac711284292bd26e5315cd00ca382caef9435d2c" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8be27c0b9f201fc0c9472f4f8108d93d582bc5" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker when merging object files (e.g. when generating joined objects for loading into GHCi).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044987ff622cf075400b97ce65ad16deaa9afb40" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the linker.</source>
          <target state="translated">使用⟨cmd⟩作为链接器。</target>
        </trans-unit>
        <trans-unit id="b6f0729f199f6bd7daa32c90ed274f3139614300" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor</source>
          <target state="translated">使用⟨cmd⟩作为识字前处理程序。</target>
        </trans-unit>
        <trans-unit id="2261658d2fadf5a466ddd17c0a48d56d1de60076" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the literate pre-processor.</source>
          <target state="translated">使用⟨cmd⟩作为识字前处理程序。</target>
        </trans-unit>
        <trans-unit id="ae3fcd7e913573d0ca98fd73aac79e8ca6510b13" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a29c6934473566c99b28cee4bc5456cde213b21" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;a href=&quot;phases#ghc-flag--F&quot;&gt;&lt;code&gt;-F&lt;/code&gt;&lt;/a&gt; only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cebb98327d9395dab0cb8072c4f8ca1b63e721e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only)</source>
          <target state="translated">使用⟨cmd⟩作为预处理器（仅适用于 &lt;code&gt;-F&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0646cba0fc73865471883ba72a732a857f6b001f" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the pre-processor (with &lt;code&gt;-F&lt;/code&gt; only).</source>
          <target state="translated">使用&amp;ldquo; cmd&amp;rdquo;作为预处理器（仅用于 &lt;code&gt;-F&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d78d3aa183826f09ec39398f8525769841ecfa8" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program for embedding manifests on Windows.</source>
          <target state="translated">使用⟨cmd⟩作为Windows上嵌入清单的程序。</target>
        </trans-unit>
        <trans-unit id="3cdb19e159e8f49ae555412eae549a3cfd049ac9" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the program to use for embedding manifests on Windows. Normally this is the program &lt;code&gt;windres&lt;/code&gt;, which is supplied with a GHC installation. See &lt;code&gt;-fno-embed-manifest&lt;/code&gt; in &lt;a href=&quot;#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">使用&amp;ldquo; cmd&amp;rdquo;作为用于在Windows上嵌入清单的程序。通常，这是GHC安装随附的程序 &lt;code&gt;windres&lt;/code&gt; 。见 &lt;code&gt;-fno-embed-manifest&lt;/code&gt; 的&lt;a href=&quot;#options-linker&quot;&gt;选项链接的影响&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3510499be750179e96b10f06b02b8e4bfde31eb1" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter</source>
          <target state="translated">使用⟨cmd⟩作为分割器。</target>
        </trans-unit>
        <trans-unit id="2ddd654081c3e141217debcdaf12ebb2e94ac63e" translate="yes" xml:space="preserve">
          <source>Use ⟨cmd⟩ as the splitter.</source>
          <target state="translated">用⟨cmd⟩作为分割器。</target>
        </trans-unit>
        <trans-unit id="7c6f4febe792ad114505eb5ec857ff33af060815" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile</source>
          <target state="translated">使用⟨file⟩作为makefile。</target>
        </trans-unit>
        <trans-unit id="fd7c6879b5a5e6c77b73fa449baad133ae5d56cf" translate="yes" xml:space="preserve">
          <source>Use ⟨file⟩ as the makefile, rather than &lt;code&gt;makefile&lt;/code&gt; or &lt;code&gt;Makefile&lt;/code&gt;. If ⟨file⟩ doesn&amp;rsquo;t exist, &lt;code&gt;mkdependHS&lt;/code&gt; creates it. We often use &lt;code&gt;-dep-makefile .depend&lt;/code&gt; to put the dependencies in &lt;code&gt;.depend&lt;/code&gt; and then &lt;code&gt;include&lt;/code&gt; the file &lt;code&gt;.depend&lt;/code&gt; into &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">使用⟨file⟩作为生成文件，而不是 &lt;code&gt;makefile&lt;/code&gt; 或 &lt;code&gt;Makefile&lt;/code&gt; 。如果⟨file⟩不存在，则 &lt;code&gt;mkdependHS&lt;/code&gt; 创建它。我们经常使用 &lt;code&gt;-dep-makefile .depend&lt;/code&gt; 放于依赖 &lt;code&gt;.depend&lt;/code&gt; 然后 &lt;code&gt;include&lt;/code&gt; 文件 &lt;code&gt;.depend&lt;/code&gt; 到 &lt;code&gt;Makefile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="91f7bf56d858ac23099d424e99b3748f4ffa9e6f" translate="yes" xml:space="preserve">
          <source>Use ⟨x⟩ simultaneous threads when running the program.</source>
          <target state="translated">运行程序时使用⟨x⟩同时线程。</target>
        </trans-unit>
        <trans-unit id="50c0ee0a9a8e3c487e2501cb1dcb6572d2d149ee" translate="yes" xml:space="preserve">
          <source>Used by GHCi to add an SPT entry for a set of interactive bindings.</source>
          <target state="translated">由 GHCi 用于为一组交互式绑定添加一个 SPT 条目。</target>
        </trans-unit>
        <trans-unit id="ce78d982417b9cb4deb2ddcc1a484efef31c9e70" translate="yes" xml:space="preserve">
          <source>Used for 'x etc, but not available to the programmer</source>
          <target state="translated">用于'x等,但程序员不能使用。</target>
        </trans-unit>
        <trans-unit id="3847aa787c24cd1d44a17f4805f957dd8caf3458" translate="yes" xml:space="preserve">
          <source>Used for compiler-generated error message; encoding saves bytes of string junk.</source>
          <target state="translated">用于编译器生成的错误信息;编码可节省字符串垃圾的字节。</target>
        </trans-unit>
        <trans-unit id="48f7b38aeba5a7256e7131d8cb8c98f966810900" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="a955f7ae96dd2396e997eaaba64e06e03450d7ce" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="6f585b6f35665233ba6dfd37448fddc289f902eb" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="f78d41a4bcd03ebc472455f23710c4336f3e4510" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="ae4850a6beb132067b0d17bd048ad2ac3b2c4d19" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="ac37eb2d964ae070e77a81603004056ba16fd6c1" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="cbfbb476822c67fb944c2ccc3737c5d876459fac" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="4ca58513d0191a18bd8970f148670b2ac5f22912" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">用于标记 &lt;code&gt;&lt;a href=&quot;ghc-float#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; 的出现</target>
        </trans-unit>
        <trans-unit id="9cd28c49f71c816b7f9ae60ffd4e7c302e1776af" translate="yes" xml:space="preserve">
          <source>Used for marking occurrences of the parameter</source>
          <target state="translated">用于标记参数的出现。</target>
        </trans-unit>
        <trans-unit id="fea1f906365eb90369e6c8aa238cf26f0304a28e" translate="yes" xml:space="preserve">
          <source>Used for overloaded and non-overloaded literals. We don't have a good way to represent non-overloaded literals at the moment. Maybe that doesn't matter?</source>
          <target state="translated">用来表示超载和非超载的字数。我们目前还没有一个很好的方法来表示非过载的字元。也许这并不重要?</target>
        </trans-unit>
        <trans-unit id="238e061ebe06d65547e2bee202766499de802474" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..]&lt;/code&gt; with &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt;, &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; and &lt;code&gt;f n y
     | n &amp;gt; 0 = f (n - 1) (succ y)
     | n &amp;lt; 0 = f (n + 1) (pred y)
     | otherwise = y&lt;/code&gt; For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n,n'..]&lt;/code&gt; 与 &lt;code&gt;[n,n'..] = enumFromThen n n'&lt;/code&gt; 一个可能的实现是 &lt;code&gt;enumFromThen n n' = n : n' : worker (f x) (f x n')&lt;/code&gt; ， &lt;code&gt;worker s v = v : worker s (s v)&lt;/code&gt; ， &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; 和 &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 例如：</target>
        </trans-unit>
        <trans-unit id="ec710c9c70c84a0fa35609489a6b9ef33af6c8b0" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n,n'..m]&lt;/code&gt; with &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt;, &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt;, &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt;&lt;code&gt;f n y
      | n &amp;gt; 0 = f (n - 1) (succ y)
      | n &amp;lt; 0 = f (n + 1) (pred y)
      | otherwise = y&lt;/code&gt; and &lt;code&gt;worker s c v m
      | c v m = v : worker s c (s v) m
      | otherwise = []&lt;/code&gt; For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n,n'..m]&lt;/code&gt; 与 &lt;code&gt;[n,n'..m] = enumFromThenTo n n' m&lt;/code&gt; ，一种可能的实现是 &lt;code&gt;enumFromThenTo n n' m = worker (f x) (c x) n m&lt;/code&gt; ， &lt;code&gt;x = fromEnum n' - fromEnum n&lt;/code&gt; ， &lt;code&gt;c x = bool (&amp;gt;=) (&lt;a href=&quot;=)&quot;&gt;(x&lt;/a&gt; 0)&lt;/code&gt; &lt;code&gt;f n y | n &amp;gt; 0 = f (n - 1) (succ y) | n &amp;lt; 0 = f (n + 1) (pred y) | otherwise = y&lt;/code&gt; 和 &lt;code&gt;worker s c v m | c v m = v : worker s c (s v) m | otherwise = []&lt;/code&gt; 例如：</target>
        </trans-unit>
        <trans-unit id="2376147b4b93f0f0f659194995859c4171be7e97" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..]&lt;/code&gt; with &lt;code&gt;[n..] = enumFrom n&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt;. For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n..]&lt;/code&gt; 与 &lt;code&gt;[n..] = enumFrom n&lt;/code&gt; ，一个可能的实现是 &lt;code&gt;enumFrom n = n : enumFrom (succ n)&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="721ad854036f4864103a86da3e89b972bead0e02" translate="yes" xml:space="preserve">
          <source>Used in Haskell's translation of &lt;code&gt;[n..m]&lt;/code&gt; with &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt;, a possible implementation being &lt;code&gt;enumFromTo n m
      | n &amp;lt;= m = n : enumFromTo (succ n) m
      | otherwise = []&lt;/code&gt;. For example:</source>
          <target state="translated">用于Haskell的翻译 &lt;code&gt;[n..m]&lt;/code&gt; 与 &lt;code&gt;[n..m] = enumFromTo n m&lt;/code&gt; ，一个可能的实现是 &lt;code&gt;enumFromTo n m | n &amp;lt;= m = n : enumFromTo (succ n) m | otherwise = []&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="7ba12a872816eab7cd55766f4e299e6fee8d6fce" translate="yes" xml:space="preserve">
          <source>Used to represent a Fast String fragment but now deprecated and identical to the Str constructor.</source>
          <target state="translated">曾经表示一个Fast String片段,但现在已经废弃,与Str构造函数相同。</target>
        </trans-unit>
        <trans-unit id="a45835be33274394b1b372013bc338e7249d972f" translate="yes" xml:space="preserve">
          <source>Useful combinator for use in conjunction with the &lt;code&gt;xxxBy&lt;/code&gt; family of functions from &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;, for example:</source>
          <target state="translated">用于与结合使用的有用组合子 &lt;code&gt;xxxBy&lt;/code&gt; 家族的从功能&lt;a href=&quot;data-list&quot;&gt;Data.List模块&lt;/a&gt;，例如：</target>
        </trans-unit>
        <trans-unit id="8a579dd6a4399af21a11c4ed52bc9f7f6576690e" translate="yes" xml:space="preserve">
          <source>Useful error handling functions</source>
          <target state="translated">有用的错误处理功能</target>
        </trans-unit>
        <trans-unit id="2edd003dedc171d3ac005a45bdf1c7df9611bd5d" translate="yes" xml:space="preserve">
          <source>Useful for defining &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; for types for which NF=WHNF holds.</source>
          <target state="translated">对于定义NF = WHNF的类型定义 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="682d4409a64a47028acddb1087ca1ca87620ae82" translate="yes" xml:space="preserve">
          <source>Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then &lt;code&gt;mallocForeignPtr&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a good choice, however.</source>
          <target state="translated">对于需要垃圾收集的长期分配很有用。如果您打算将指向内存中存储的数据外资结构，那么 &lt;code&gt;mallocForeignPtr&lt;/code&gt; 是&lt;em&gt;不是&lt;/em&gt;一个很好的选择，但是。</target>
        </trans-unit>
        <trans-unit id="565822cd77b6637c10be116d419e7696260595d2" translate="yes" xml:space="preserve">
          <source>Useful for short-term allocation when the allocation is intended to scope over a given &lt;code&gt;IO&lt;/code&gt; computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</source>
          <target state="translated">当分配打算在给定的 &lt;code&gt;IO&lt;/code&gt; 计算范围内使用时，对于短期分配很有用。在往来于FFI功能的数据中编组数据时，通常使用这种分配。</target>
        </trans-unit>
        <trans-unit id="2af6e52f982f79a13b501af79e093ed843c9514a" translate="yes" xml:space="preserve">
          <source>Useful for:</source>
          <target state="translated">有用的是:</target>
        </trans-unit>
        <trans-unit id="44bd11006ea2446fabab47fc4ab28f60a56d501a" translate="yes" xml:space="preserve">
          <source>Useful functions and combinators.</source>
          <target state="translated">有用的函数和组合器。</target>
        </trans-unit>
        <trans-unit id="4dcc8c5851caf5e6ae38c18983779597f18f22bc" translate="yes" xml:space="preserve">
          <source>Useful functions.</source>
          <target state="translated">有用的功能。</target>
        </trans-unit>
        <trans-unit id="170b3665888bbcbc92df989b316b0344229dd072" translate="yes" xml:space="preserve">
          <source>Useful helper function</source>
          <target state="translated">有用的辅助功能</target>
        </trans-unit>
        <trans-unit id="5654edd09aadece1962526d4e7c8a06e94d88138" translate="yes" xml:space="preserve">
          <source>Useful helpers for writing instances</source>
          <target state="translated">编写实例的有用助手</target>
        </trans-unit>
        <trans-unit id="cf9d2c2460705878a701d0fdfe5bf5da9d8e8c5d" translate="yes" xml:space="preserve">
          <source>Useful properties resulting from the invariants:</source>
          <target state="translated">由不变量产生的有用属性。</target>
        </trans-unit>
        <trans-unit id="1770280560169f702ff9a9b3a4b66731a5e241be" translate="yes" xml:space="preserve">
          <source>User environment</source>
          <target state="translated">用户环境</target>
        </trans-unit>
        <trans-unit id="7f9550c2041ef0abb58791782b9d7bac7d6fb605" translate="yes" xml:space="preserve">
          <source>User interaction functions</source>
          <target state="translated">用户互动功能</target>
        </trans-unit>
        <trans-unit id="542fc71480dec743e60c20434ec6dd5838fc4b52" translate="yes" xml:space="preserve">
          <source>User name</source>
          <target state="translated">用户名称</target>
        </trans-unit>
        <trans-unit id="c3c46a581b46f42100507c50992392d2bb9e3eba" translate="yes" xml:space="preserve">
          <source>User preferences</source>
          <target state="translated">用户偏好</target>
        </trans-unit>
        <trans-unit id="509063363ef89fe8150aab1353f6034852260bd6" translate="yes" xml:space="preserve">
          <source>User-defined operators are flagged with banana brackets instead of a new &lt;code&gt;form&lt;/code&gt; keyword.</source>
          <target state="translated">用户定义的运算符标有香蕉括号，而不是新的 &lt;code&gt;form&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="7514c17314f4300451e6509de3b0c15d464eb52f" translate="yes" xml:space="preserve">
          <source>User-defined type errors</source>
          <target state="translated">用户自定义类型错误</target>
        </trans-unit>
        <trans-unit id="ddaf25ba7d5224155d5c5745dc554102c7d6bedc" translate="yes" xml:space="preserve">
          <source>User-supplied comparison (replacing an &lt;code&gt;Ord&lt;/code&gt; context)</source>
          <target state="translated">用户提供的比较（替换 &lt;code&gt;Ord&lt;/code&gt; 上下文）</target>
        </trans-unit>
        <trans-unit id="3601596f3b23f544013c9df7093000280be41f71" translate="yes" xml:space="preserve">
          <source>User-supplied equality (replacing an &lt;code&gt;Eq&lt;/code&gt; context)</source>
          <target state="translated">用户提供的相等性（替换 &lt;code&gt;Eq&lt;/code&gt; 上下文）</target>
        </trans-unit>
        <trans-unit id="7d0c5b19b57ac836c34ca570d05dfece9b3a3763" translate="yes" xml:space="preserve">
          <source>UserEntry</source>
          <target state="translated">UserEntry</target>
        </trans-unit>
        <trans-unit id="0c60361852b81bf7f9c1d451a3ffea1b382edcfa" translate="yes" xml:space="preserve">
          <source>UserError</source>
          <target state="translated">UserError</target>
        </trans-unit>
        <trans-unit id="6bc00f4e4ce1e79e2aff101eccac581ca84cc9e9" translate="yes" xml:space="preserve">
          <source>UserID</source>
          <target state="translated">UserID</target>
        </trans-unit>
        <trans-unit id="515d8ba663afe12bffe269a5563a1e3be0f09933" translate="yes" xml:space="preserve">
          <source>UserInterrupt</source>
          <target state="translated">UserInterrupt</target>
        </trans-unit>
        <trans-unit id="03a0196d9c0db13aabbd53088348d392ffc363f9" translate="yes" xml:space="preserve">
          <source>Users can use the same functions that GHC uses internally to compute fingerprints. The &lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt; module provides useful functions for constructing fingerprints. For example, combining together &lt;code&gt;fingerprintFingerprints&lt;/code&gt; and &lt;code&gt;fingerprintString&lt;/code&gt; provides an easy to to naively fingerprint the arguments to a plugin.</source>
          <target state="translated">用户可以使用GHC内部用于计算指纹的相同功能。所述&lt;a href=&quot;https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-Fingerprint.html&quot;&gt;GHC.Fingerprint&lt;/a&gt;模块提供有用的功能，用于构建指纹。例如，将 &lt;code&gt;fingerprintFingerprints&lt;/code&gt; 和 &lt;code&gt;fingerprintString&lt;/code&gt; 结合在一起，可以轻松地对插件的参数进行幼稚的指纹识别。</target>
        </trans-unit>
        <trans-unit id="dbc1a454472d7c66c5ba761b635d39b2cf0fa0fb" translate="yes" xml:space="preserve">
          <source>Users may customize the interface with a &lt;code&gt;~/.haskeline&lt;/code&gt; file; see &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt; for more information.</source>
          <target state="translated">用户可以使用 &lt;code&gt;~/.haskeline&lt;/code&gt; 文件来自定义界面；有关更多信息，请参见&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;https://github.com/judah/haskeline/wiki/UserPreferences&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="da092016386ac606886d79c8fb8c43516b7b8c37" translate="yes" xml:space="preserve">
          <source>Users may define their own instances of &lt;code&gt;HasField&lt;/code&gt;, provided they do not conflict with the built-in constraint solving behaviour. This allows &amp;ldquo;virtual&amp;rdquo; record fields to be defined for datatypes that do not otherwise have them.</source>
          <target state="translated">用户可以定义自己的 &lt;code&gt;HasField&lt;/code&gt; 实例，前提是它们与内置的约束求解行为不冲突。这允许为没有虚拟字段的数据类型定义&amp;ldquo;虚拟&amp;rdquo;记录字段。</target>
        </trans-unit>
        <trans-unit id="ad9a5666b2ee0d2dbc3c969b19d7aa3ebfc7d2f9" translate="yes" xml:space="preserve">
          <source>Users may provide custom instances of &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; which are expected to conform the following rules:</source>
          <target state="translated">用户可以提供 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 的自定义实例，这些实例应符合以下规则：</target>
        </trans-unit>
        <trans-unit id="7e560e88292d8b8c47a593e73f19652f4d50d4e3" translate="yes" xml:space="preserve">
          <source>Users of this function should compile with &lt;code&gt;-threaded&lt;/code&gt; if they want other Haskell threads to keep running while waiting on the result of readProcess.</source>
          <target state="translated">这个功能的用户应编译 &lt;code&gt;-threaded&lt;/code&gt; 如果他们想其他的Haskell线程来保持，而在readProcess的结果等待运行。</target>
        </trans-unit>
        <trans-unit id="bf2063f5abd0ca89a61797d833fc04083ed0e2e6" translate="yes" xml:space="preserve">
          <source>Users will most likely want &lt;code&gt;~&lt;/code&gt;, but &lt;code&gt;~~&lt;/code&gt; is available if GHC cannot know, a priori, that the two types of interest have the same kind. Evidence that &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; tells GHC both that &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; are the same and that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same.</source>
          <target state="translated">用户很可能想要 &lt;code&gt;~&lt;/code&gt; ，但如果GHC先验地无法知道这两种类型的兴趣相同，则 &lt;code&gt;~~&lt;/code&gt; 可用。有证据表明 &lt;code&gt;(a :: k1) ~~ (b :: k2)&lt;/code&gt; 告诉GHC都认为 &lt;code&gt;k1&lt;/code&gt; 和 &lt;code&gt;k2&lt;/code&gt; 是相同的，并且 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是相同的。</target>
        </trans-unit>
        <trans-unit id="f6f56533730578a43f251e2c5623e991811d7d26" translate="yes" xml:space="preserve">
          <source>Uses of fields that are always unambiguous because they mention the constructor, including construction and pattern-matching, may freely use duplicated field names. For example, the following are permitted (just as with &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">字段的使用始终是明确的，因为它们提到了构造函数，包括构造和模式匹配，可以自由使用重复的字段名称。例如，以下内容是允许的（就像&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="3581ad6f94790a2bc201861caba85a7f7a678467" translate="yes" xml:space="preserve">
          <source>Uses the generational copying garbage collector for all generations. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612e2184a830c5e8bfb111b212202a249fdd7423" translate="yes" xml:space="preserve">
          <source>Using 8-bit characters</source>
          <target state="translated">使用8位字符</target>
        </trans-unit>
        <trans-unit id="942545b1bade40c96607a6882802a1a540e6738b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#newtype-deriving&quot;&gt;Generalised derived instances for newtypes&lt;/a&gt;), a programmer can take existing instances of classes and &amp;ldquo;lift&amp;rdquo; these into instances of that class for a newtype. However, this is not always safe. For example, consider the following:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#newtype-deriving&quot;&gt;newtype的Generalized派生实例&lt;/a&gt;），程序员可以获取类的现有实例，并将它们&amp;ldquo;提升&amp;rdquo;到该类的实例中以获取新类型。但是，这并不总是安全的。例如，考虑以下内容：</target>
        </trans-unit>
        <trans-unit id="2206acdb3d9d430eddec1b9a13c7b987ec134bee" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; tells GHC to display incompatibilities between closed type families&amp;rsquo; equations, whenever they are printed by &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghc-flag---show-iface%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;--show-iface ⟨file⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0b5d96a3f84293d62fc5945b56c1a2f7dbeabf" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt; tells GHC to distinguish between its equality relations when printing. For example, &lt;code&gt;~&lt;/code&gt; is homogeneous lifted equality (the kinds of its arguments are the same) while &lt;code&gt;~~&lt;/code&gt; is heterogeneous lifted equality (the kinds of its arguments might be different) and &lt;code&gt;~#&lt;/code&gt; is heterogeneous unlifted equality, the internal equality relation used in GHC&amp;rsquo;s solver. Generally, users should not need to worry about the subtleties here; &lt;code&gt;~&lt;/code&gt; is probably what you want. Without &lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt;&lt;code&gt;-fprint-equality-relations&lt;/code&gt;&lt;/a&gt;, GHC prints all of these as &lt;code&gt;~&lt;/code&gt;. See also &lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;Equality constraints&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; 会&lt;/a&gt;告诉GHC在打印时区分其相等关系。例如， &lt;code&gt;~&lt;/code&gt; 是齐次提升的等式（其参数的种类相同），而 &lt;code&gt;~~&lt;/code&gt; 是异构提升的等式（其参数的种类可能不同），而 &lt;code&gt;~#&lt;/code&gt; 是异构的未提升的等式，GHC的内部相等关系解算器。通常，用户无需担心此处的细微差别。 &lt;code&gt;~&lt;/code&gt; 可能就是您想要的。没有&lt;a href=&quot;#ghc-flag--fprint-equality-relations&quot;&gt; &lt;code&gt;-fprint-equality-relations&lt;/code&gt; &lt;/a&gt;，GHC将所有这些都打印为 &lt;code&gt;~&lt;/code&gt; 。另请参阅&lt;a href=&quot;glasgow_exts#equality-constraints&quot;&gt;平等约束&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db31842f72950c064c2c1d80ab6cd7638c74c75a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt;&lt;code&gt;-fprint-explicit-coercions&lt;/code&gt;&lt;/a&gt; makes GHC print coercions in types. When trying to prove the equality between types of different kinds, GHC uses type-level coercions. Users will rarely need to see these, as they are meant to be internal.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-coercions&quot;&gt; &lt;code&gt;-fprint-explicit-coercions&lt;/code&gt; &lt;/a&gt;可以使GHC打印强制类型。当试图证明不同类型的类型之间的相等性时，GHC使用类型级别的强制。用户很少需要看到这些内容，因为它们本来就是内部的。</target>
        </trans-unit>
        <trans-unit id="7a865f6c37f89cedcb8505588d923ee2281de4d2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; makes GHC print explicit &lt;code&gt;forall&lt;/code&gt; quantification at the top level of a type; normally this is suppressed. For example, in GHCi:</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;使得GHC打印明确 &lt;code&gt;forall&lt;/code&gt; 在一个类型的顶层量化; 通常这是被抑制的。例如，在GHCi中：</target>
        </trans-unit>
        <trans-unit id="43ad6734ad17f8262129b4ce1b63135691fef1c2" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; makes GHC print kind arguments in types, which are normally suppressed. This can be important when you are using kind polymorphism. For example:</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;可以使GHC打印类型的实参类型，这些类型通常被抑制。当您使用种类多态性时，这可能很重要。例如：</target>
        </trans-unit>
        <trans-unit id="d6ba5edf2cd7332c5ea401eda291414370405189" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;lsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="translated">使用&lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;可能会导致一个结论，即 &lt;code&gt;myLength1&lt;/code&gt; 的类型签名中的所有类型变量都不可用于类型应用程序。但是，这不是真的！如果您想要有关可见类型应用程序属性的最准确信息，请确保使用&lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt; &lt;code&gt;:type +v&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b75747b0323839514f55b98e3b0763a8b7a1bc59" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;ghci#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt; might lead one to conclude that none of the type variables in &lt;code&gt;myLength1&lt;/code&gt;&amp;rsquo;s type signature are available for type application. This isn&amp;rsquo;t true, however! Be sure to use &lt;a href=&quot;ghci#ghci-cmd-:type%20+v&quot;&gt;&lt;code&gt;:type +v&lt;/code&gt;&lt;/a&gt; if you want the most accurate information with respect to visible type application properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7163ac930661c0cf77d155fe52c3f373ab2481a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; is only really a good idea in conjunction with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, because otherwise the extra packing and unpacking won&amp;rsquo;t be optimised away. In fact, it is possible that &lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt;&lt;code&gt;-funbox-strict-fields&lt;/code&gt;&lt;/a&gt; may worsen performance even &lt;em&gt;with&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, but this is unlikely (let us know if it happens to you).</source>
          <target state="translated">与&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;结合使用&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;确实是一个好主意，因为否则，多余的打包和解包将不会被优化。实际上，即使&lt;em&gt;使用&lt;/em&gt;&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;using-optimisation#ghc-flag--funbox-strict-fields&quot;&gt; &lt;code&gt;-funbox-strict-fields&lt;/code&gt; &lt;/a&gt;可能也会降低性能，但这是不可能的（如果您遇到这种情况，请告诉我们）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff7aa8fda92921d739d127c5d2933e838b7a2f61" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d18768c0ec1399365712ea9b78325eb3b52d261" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c8de2889d8f4c002578848aa975a3d58a7fe14" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; makes no difference at all to the scheduling behaviour of the Haskell runtime system. It is a common misconception that you need to use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the &lt;code&gt;-threaded&lt;/code&gt; option when linking your program, and to make sure the foreign import is not marked &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 对Haskell运行时系统的调度行为没有任何影响。常见的误解是，在进行外部调用时，需要使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 来避免阻塞所有Haskell线程。事实并非如此。为了在不阻塞所有Haskell线程（使用GHC）的情况下进行外部调用，只需在链接程序时使用 &lt;code&gt;-threaded&lt;/code&gt; 选项，并确保未将外部导入标记为 &lt;code&gt;unsafe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0401fcf7d550abc85181d154e59167befc356ffe" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="653b55d8219ef951a3573cfdf98d122082b2dcdc" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e17939a2d4f4e2440854125dad598dc76040ef2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; is a shortcut for &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; in most cases:</source>
          <target state="translated">在大多数情况下，使用 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt; f x&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt; $ &lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt; f x&lt;/code&gt; 的快捷方式：</target>
        </trans-unit>
        <trans-unit id="4a054818c10692dac12322c248296bc64eb19894" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="b09ee4eae40000bfed240eddfae72c34dbbbb367" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside an &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; subverts some of guarantees that STM provides. It makes it possible to run a transaction inside of another transaction, depending on when the thunk is evaluated. If a nested transaction is attempted, an exception is thrown by the runtime. It is possible to safely use &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, but the typechecker does not rule out programs that may attempt nested transactions, meaning that the programmer must take special care to prevent these.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用会破坏STM提供的某些保证。这使得有可能在另一个事务中运行一个事务，这取决于对thunk进行评估的时间。如果尝试嵌套事务，则运行时将引发异常。可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; 内部安全地 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 使用，但是类型检查器并不排除可能尝试嵌套事务的程序，这意味着程序员必须格外小心以防止此类情况。</target>
        </trans-unit>
        <trans-unit id="40b41e20161a45a722c2225074d2b6894f2f36e9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="327764f8188ed7c066bf1aeb35152bb98286d9d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; inside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; is also dangerous but for different reasons. See &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; 内部使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 也是危险的，但是出于不同的原因。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:unsafeIOToSTM&quot;&gt;unsafeIOToSTM&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96ae088c649d5a06c694f9e9ee5ee9dc8687a02" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d111b0d48c558b38badb2c9405749a987627b42" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-applicative#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2172f3ccd962a6ecd9b4cc15ce3cf95a1be7eb5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674202704940c277740f7f4ae49cd37b3a5f78e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:forever&quot;&gt;forever&lt;/a&gt; as&lt;/code&gt;' can be understood as the pseudo-&lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b459af09ae8043d5f7b1a6c9159131c0b0fd22" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:replicateM&quot;&gt;replicateM&lt;/a&gt; 5 as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4087f9008dd31f8281176bc7c8f4d1d90f9e79d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1570094d52e557732c703a05b9b1c145c2dd064a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;control-monad-instances#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f501d2ca81d0c4860698f021f0de3ecdc4a0f4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108f9b97edb22ce149c8927414975f8505b7580d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-functor#v:void&quot;&gt;void&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c837790b7d1462717c4308d600ad3e92eeaf1c9" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;data-void#v:vacuous&quot;&gt;vacuous&lt;/a&gt; theVoid&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c32ccf8b63eb011e4dfda0a4088dddc4bcbb92" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a8dbc4ffe0ccbf1d373d624329159d46946500" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA2&quot;&gt;liftA2&lt;/a&gt; f as bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b865211f58b24998cdf3ed8e08bdcf5e692e5e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;ghc-base#v:liftA3&quot;&gt;liftA3&lt;/a&gt; f as bs cs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a3efcb29a05c36224847d355496627fce12e1f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt; f as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9165dbc2c9969c24f2215ef6972a0880bb8278cb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-applicative#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4a4d9eb30eacc6d2b8ca81bb1bd234ce8594a6" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ccbb1fb2ddb1f53f896c4cc85e9a37ce0b41f0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;control-monad-instances#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fce8cbc36fc6d6dcdd6a6150d8297a2eb75e02c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;data-functor#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1004bfc9a7477fe977e15f814e05ceb1b205da67" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;ghc-base#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cb9307570de629188fffa91efa031876cc2110" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;a &lt;a href=&quot;prelude#v:-60--36-&quot;&gt;&amp;lt;$&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774bbfc5e54c815dbed906d0f74123e150de4f6c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d911e731ca95c1fd9a07c919774126a522e977" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;control-applicative#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84196a31a9d5c8e34d17aa2ef18dc24c40e44aab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;data-functor#v:-36--62-&quot;&gt;$&amp;gt;&lt;/a&gt; b&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b25d8a860bc159c6b22d827207b11014882905b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a06315a7f9f08f9387659d3c5c4197621c13971" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;ghc-base#v:-60--42--42--62-&quot;&gt;&amp;lt;**&amp;gt;&lt;/a&gt; fs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64871c74d2047073bc61343ed982993443145244" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;as &lt;a href=&quot;prelude#v:-60--42-&quot;&gt;&amp;lt;*&lt;/a&gt; bs&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7235239be554865a0935a618eb2b2336543f4705" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6309b1896f5220de1092c0929134f7a07019870d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;ghc-base#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a548000114a6581f99bb89aac62e4c4178082e2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ApplicativeDo&lt;/code&gt;: '&lt;code&gt;fs &lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt; as&lt;/code&gt;' can be understood as the &lt;code&gt;do&lt;/code&gt; expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f60e44e7419f981a24cfdfef3321af38c83c15f" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as &lt;code&gt;CString&lt;/code&gt;s</source>
          <target state="translated">使用字节串为 &lt;code&gt;CString&lt;/code&gt; 的小号</target>
        </trans-unit>
        <trans-unit id="a94cb64e5153c8019b8459af3ab058315f2c3c3a" translate="yes" xml:space="preserve">
          <source>Using ByteStrings as CStrings</source>
          <target state="translated">将ByteStrings作为CStrings使用</target>
        </trans-unit>
        <trans-unit id="b40f94fc1f11dd5c42c861cd8b875e12da7278be" translate="yes" xml:space="preserve">
          <source>Using ByteStrings with functions for CStrings</source>
          <target state="translated">用CStrings的函数来使用ByteStrings。</target>
        </trans-unit>
        <trans-unit id="5c85522eb99bdc899ee747f76772b3a2cff55270" translate="yes" xml:space="preserve">
          <source>Using GHC without the &lt;code&gt;-threaded&lt;/code&gt; option, all foreign calls will block all other Haskell threads in the system, although I/O operations will not. With the &lt;code&gt;-threaded&lt;/code&gt; option, only foreign calls with the &lt;code&gt;unsafe&lt;/code&gt; attribute will block all other threads.</source>
          <target state="translated">使用不带 &lt;code&gt;-threaded&lt;/code&gt; 选项的GHC ，尽管I / O操作不会，所有外部调用都将阻塞系统中的所有其他Haskell线程。使用 &lt;code&gt;-threaded&lt;/code&gt; 选项，只有具有 &lt;code&gt;unsafe&lt;/code&gt; 属性的外部调用才会阻塞所有其他线程。</target>
        </trans-unit>
        <trans-unit id="251592b15ab7216827445436b461897f62f41677" translate="yes" xml:space="preserve">
          <source>Using GHC&amp;rsquo;s version number in the shared object name allows different library versions compiled by different GHC versions to be installed in standard system locations, e.g. under *nix &lt;code&gt;/usr/lib&lt;/code&gt;. To obtain the version number of GHC invoke &lt;code&gt;ghc --numeric-version&lt;/code&gt; and use its output in place of ⟨GHCVersion⟩. See also &lt;a href=&quot;phases#options-codegen&quot;&gt;Options affecting code generation&lt;/a&gt; on how object files must be prepared for shared object linking.</source>
          <target state="translated">在共享库名称中使用GHC的版本号可以将由不同GHC版本编译的不同库版本安装在标准系统位置，例如* nix &lt;code&gt;/usr/lib&lt;/code&gt; 下。要获取GHC的版本号，请调用 &lt;code&gt;ghc --numeric-version&lt;/code&gt; 并使用其输出代替⟨GHCVersion⟩。另请参阅&lt;a href=&quot;phases#options-codegen&quot;&gt;影响代码生成的选项，&lt;/a&gt;以了解如何为共享对象链接准备对象文件。</target>
        </trans-unit>
        <trans-unit id="d44a49d31d530124806f0f14d7c3a25fa4d0e74c" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="translated">结合使用&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#extension-DefaultSignatures&quot;&gt; &lt;code&gt;DefaultSignatures&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt;，可以使用&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt;框架轻松进行数据类型通用编程。本节简要介绍了操作方法。</target>
        </trans-unit>
        <trans-unit id="f8eaede999cdbad9cc93f8d51a7d597d7f74c072" translate="yes" xml:space="preserve">
          <source>Using a combination of &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-DefaultSignatures&quot;&gt;&lt;code&gt;DefaultSignatures&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt;, you can easily do datatype-generic programming using the &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-generics&quot;&gt;GHC.Generics&lt;/a&gt; framework. This section gives a very brief overview of how to do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9d8addfa8df264e573b6a81847a90f2b01a758" translate="yes" xml:space="preserve">
          <source>Using a locale-dependent encoding</source>
          <target state="translated">使用依赖本地的编码</target>
        </trans-unit>
        <trans-unit id="ab506530173fceaff35d888e32b6577ed8bfcdc6" translate="yes" xml:space="preserve">
          <source>Using a package couldn&amp;rsquo;t be simpler: if you&amp;rsquo;re using &lt;code&gt;--make&lt;/code&gt; or GHCi, then most of the installed packages will be automatically available to your program without any further options. The exceptions to this rule are covered below in &lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;.</source>
          <target state="translated">使用软件包并 &lt;code&gt;--make&lt;/code&gt; ：如果您使用--make或GHCi，则大多数已安装的软件包将自动提供给您的程序，而无需任何其他选择。下面的&amp;ldquo; &lt;a href=&quot;#using-packages&quot;&gt;使用软件包&amp;rdquo;&lt;/a&gt;中介绍了此规则的例外情况。</target>
        </trans-unit>
        <trans-unit id="ec49e61de1a6708770ca5ea53d854637f189900e" translate="yes" xml:space="preserve">
          <source>Using a value of zero disables the RTS clock completely, and has the effect of disabling timers that depend on it: the context switch timer and the heap profiling timer. Context switches will still happen, but deterministically and at a rate much faster than normal. Disabling the interval timer is useful for debugging, because it eliminates a source of non-determinism at runtime.</source>
          <target state="translated">使用零的值会完全禁用RTS时钟,并会禁用依赖它的定时器:上下文切换定时器和堆分析定时器。上下文切换仍然会发生,但确定地以比正常速度快得多的速率进行。禁用间隔定时器对调试很有用,因为它消除了运行时非确定性的来源。</target>
        </trans-unit>
        <trans-unit id="6a4a9903244534f370840c1922f33e5fac470a05" translate="yes" xml:space="preserve">
          <source>Using hole-fit plugins, you can extend the behavior of valid hole fit suggestions to use e.g. Hoogle or other external tools to find and/or synthesize valid hole fits, with the same information about the typed-hole that GHC uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32acf51d7f62b559e6f6ac1d8c3d14ffc7ed8b21" translate="yes" xml:space="preserve">
          <source>Using record selectors</source>
          <target state="translated">使用记录选择器</target>
        </trans-unit>
        <trans-unit id="3077d1ef00911ed60eb22f6af1d4962cdd9d8cfb" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-j[⟨n⟩]&lt;/code&gt;&lt;/a&gt; flag, you can compile modules in parallel. Specify &lt;code&gt;-j ⟨n⟩&lt;/code&gt; to compile ⟨n⟩ jobs in parallel. If ⟨n⟩ is omitted, then it defaults to the number of processors.</source>
          <target state="translated">使用&lt;a href=&quot;#ghc-flag--j%5B%E2%9F%A8n%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-j[⟨n⟩]&lt;/code&gt; &lt;/a&gt;标志，可以并行编译模块。指定 &lt;code&gt;-j ⟨n⟩&lt;/code&gt; 以并行编译⟨n⟩个作业。如果省略⟨n⟩，则默认为处理器数量。</target>
        </trans-unit>
        <trans-unit id="858fa87b359c2a8dfa1bed3d7354f1c98c94c937" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;+&lt;/code&gt; form of the &lt;code&gt;module&lt;/code&gt; commands adds modules to the current scope, and &lt;code&gt;-&lt;/code&gt; removes them. Without either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, the current scope is replaced by the set of modules specified. Note that if you use this form and leave out &lt;code&gt;Prelude&lt;/code&gt;, an implicit &lt;code&gt;Prelude&lt;/code&gt; import will be added automatically.</source>
          <target state="translated">使用 &lt;code&gt;module&lt;/code&gt; 命令的 &lt;code&gt;+&lt;/code&gt; 形式将模块添加到当前作用域，并 &lt;code&gt;-&lt;/code&gt; 删除它们。如果没有 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; ，则当前作用域将由指定的模块集替换。请注意，如果您使用此表单并省略 &lt;code&gt;Prelude&lt;/code&gt; ，则会自动添加隐式的 &lt;code&gt;Prelude&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="88ce1fb571afb65c6d0e842b399fa0b1a914f2d0" translate="yes" xml:space="preserve">
          <source>Using this is expected to make the program slightly slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5ef9a787762006bd887ef2118ae12eb3d21b09" translate="yes" xml:space="preserve">
          <source>Usually GHC black-holes a thunk only when it switches threads. This flag makes it do so as soon as the thunk is entered. See &lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;Haskell on a shared-memory multiprocessor&lt;/a&gt;.</source>
          <target state="translated">通常，只有在切换线程时，GHC才会使一个黑洞（thunk）进入黑洞。一旦输入了thunk，该标志便使其生效。请参阅&lt;a href=&quot;http://community.haskell.org/~simonmar/papers/multiproc.pdf&quot;&gt;共享内存多处理器上的Haskell&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="af0f890994f908319ff8d9afb1777b9fcb88bad5" translate="yes" xml:space="preserve">
          <source>Usually the real name for the user (pw_gecos)</source>
          <target state="translated">通常是用户的真实姓名(pw_gecos)</target>
        </trans-unit>
        <trans-unit id="ab2c7549e2b0bdddc9c6bb5863f4c4abcb5e2393" translate="yes" xml:space="preserve">
          <source>Usually, the file should be named after the module name, replacing dots in the module name by directory separators. For example, on a Unix system, the module &lt;code&gt;A.B.C&lt;/code&gt; should be placed in the file &lt;code&gt;A/B/C.hs&lt;/code&gt;, relative to some base directory. If the module is not going to be imported by another module (&lt;code&gt;Main&lt;/code&gt;, for example), then you are free to use any filename for it.</source>
          <target state="translated">通常，该文件应以模块名称命名，并用目录分隔符替换模块名称中的点。例如，在Unix系统上，模块 &lt;code&gt;A.B.C&lt;/code&gt; 应该放置在相对于某些基本目录的文件 &lt;code&gt;A/B/C.hs&lt;/code&gt; 中。如果该模块不打算由另一个模块（例如 &lt;code&gt;Main&lt;/code&gt; ）导入，则可以随意使用任何文件名。</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="9cb298e9034198322f8d610f9cbe52f277fdbbe5" translate="yes" xml:space="preserve">
          <source>Utilities for calling Win32 API</source>
          <target state="translated">调用Win32 API的实用工具</target>
        </trans-unit>
        <trans-unit id="4f53403de824c0a45ffa413d18703d7d05768956" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshaling</source>
          <target state="translated">用于原始码垛的工具</target>
        </trans-unit>
        <trans-unit id="4bc50e97c77d17fd8ac0d95a8e80d0d8b03fc415" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of C strings.</source>
          <target state="translated">用于对C字符串进行初值化处理的工具。</target>
        </trans-unit>
        <trans-unit id="5a3ec9890970dfcee014d906f6083905237f8661" translate="yes" xml:space="preserve">
          <source>Utilities for primitive marshalling of Windows' C strings.</source>
          <target state="translated">用于对Windows的C语言字符串进行原始marshalling的工具。</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">实用功能</target>
        </trans-unit>
        <trans-unit id="3e0867dbafd8a42d911ff54eb5dad6778a1edcbf" translate="yes" xml:space="preserve">
          <source>Utility functions for documents</source>
          <target state="translated">文件的实用功能</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="b88d1ba4914007f59dea7e944d19e43e2ddb7cc5" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitQueue</source>
          <target state="translated">Utils.Containers.Internal.BitQueue</target>
        </trans-unit>
        <trans-unit id="7b70402153c5d56ff512a1212d04b73c0f830ab1" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.BitUtil</source>
          <target state="translated">Utils.Containers.Internal.BitUtil</target>
        </trans-unit>
        <trans-unit id="ad42400973d4932315815a075fb7ef6560156596" translate="yes" xml:space="preserve">
          <source>Utils.Containers.Internal.StrictPair</source>
          <target state="translated">Utils.Containers.Internal.StrictPair</target>
        </trans-unit>
        <trans-unit id="c14e3dde339a29a416ace2e144201e8a61988686" translate="yes" xml:space="preserve">
          <source>V1</source>
          <target state="translated">V1</target>
        </trans-unit>
        <trans-unit id="fdd7168fb33dcc8aadeb03f101642602b4482322" translate="yes" xml:space="preserve">
          <source>VDisableChar</source>
          <target state="translated">VDisableChar</target>
        </trans-unit>
        <trans-unit id="0dd37a83e54442139e4aed5d892a8264e1d1a20d" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import safe&lt;/code&gt; FFI calls: &lt;code&gt;ByteArray#&lt;/code&gt; and &lt;code&gt;MutableByteArray#&lt;/code&gt;. The byte array must be &lt;a href=&quot;#pinned-byte-arrays&quot;&gt;pinned&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89dcf84a837ed25d40e781204368ac37d7aee9e9" translate="yes" xml:space="preserve">
          <source>Valid arguments for &lt;code&gt;foreign import unsafe&lt;/code&gt; FFI calls: &lt;code&gt;Array#&lt;/code&gt;, &lt;code&gt;SmallArray#&lt;/code&gt;, &lt;code&gt;ArrayArray#&lt;/code&gt;, &lt;code&gt;ByteArray#&lt;/code&gt;, and the mutable counterparts of these types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8a9ce75262d79bd93f92191a9bbcb04181578d" translate="yes" xml:space="preserve">
          <source>Valid list of valid refinement hole fits can often grow large when the refinement level is &lt;code&gt;&amp;gt;= 2&lt;/code&gt;, with holes like &lt;code&gt;head _ _&lt;/code&gt; or &lt;code&gt;fst _ _&lt;/code&gt;, which are valid refinements, but which are unlikely to be relevant since one or more of the holes are still completely open, in that neither the type nor kind of those holes are constrained by the proposed identifier at all. By default, such holes are not reported. By turning this flag on, such holes are included in the list of valid refinement hole fits.</source>
          <target state="translated">当细化级别 &lt;code&gt;&amp;gt;= 2&lt;/code&gt; 时，有效细化孔配合的有效列表通常会变大，而诸如 &lt;code&gt;head _ _&lt;/code&gt; 或 &lt;code&gt;fst _ _&lt;/code&gt; 类的孔是有效细化，但由于一个或多个孔不大可能相关它们仍然是完全开放的，因为这些孔的类型和种类都完全不受提议的标识符的约束。默认情况下，不报告此类漏洞。通过打开此标记，这些孔将包含在有效细化孔配合列表中。</target>
        </trans-unit>
        <trans-unit id="06dce05cc030efdb204cf599ff782415e84cde95" translate="yes" xml:space="preserve">
          <source>Validates &lt;code&gt;name&lt;/code&gt;. This approach illustrates advantage of using &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; over &lt;code&gt;return&lt;/code&gt;. We pass the continuation to &lt;code&gt;validateName&lt;/code&gt;, and interrupt execution of the &lt;code&gt;Cont&lt;/code&gt; block from &lt;em&gt;inside&lt;/em&gt; of &lt;code&gt;validateName&lt;/code&gt;.</source>
          <target state="translated">验证 &lt;code&gt;name&lt;/code&gt; 。这种方法说明了使用 &lt;code&gt;&lt;a href=&quot;control-monad-cont#v:callCC&quot;&gt;callCC&lt;/a&gt;&lt;/code&gt; 优于 &lt;code&gt;return&lt;/code&gt; 的优势。我们通过延续 &lt;code&gt;validateName&lt;/code&gt; ，并中断执行 &lt;code&gt;Cont&lt;/code&gt; 从块&lt;em&gt;内&lt;/em&gt;的 &lt;code&gt;validateName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="5a57a1d6fee5b373ae7f22a03bfc92a759af4f09" translate="yes" xml:space="preserve">
          <source>Value computed while filling this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">填充此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 时计算的值。</target>
        </trans-unit>
        <trans-unit id="b73ed1f417d158fcb9b149b9e60cf332e0c47800" translate="yes" xml:space="preserve">
          <source>Values encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class are always encoded in network order (big endian) form, and encoded data should be portable across machine endianness, word size, or compiler version. For example, data encoded using the &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; class could be written on any machine, and read back on any another.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类编码的值始终以网络顺序（大字节序）形式进行编码，并且编码后的数据应在机器字节序，字长或编译器版本之间可移植。例如，使用 &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; 类编码的数据可以写在任何机器上，而可以在任何其他机器上读回。</target>
        </trans-unit>
        <trans-unit id="01add5475921fe7570fa9905256bf6986e326854" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;TExp a&lt;/code&gt; may be converted to values of type &lt;code&gt;Exp&lt;/code&gt; using the function &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt;.</source>
          <target state="translated">使用函数 &lt;code&gt;unType :: TExp a -&amp;gt; Exp&lt;/code&gt; 可以将 &lt;code&gt;TExp a&lt;/code&gt; 类型的值转换为 &lt;code&gt;Exp&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="7c964e3ccb5360d4732d58bfab5d5bef0a8262e7" translate="yes" xml:space="preserve">
          <source>Vanilla type synonym declarations are exactly as in Haskell.</source>
          <target state="translated">香草类型同义词的声明与Haskell中的完全一样。</target>
        </trans-unit>
        <trans-unit id="f5cef75c90dc2e8cbbacdc00ed3a93e598d08c37" translate="yes" xml:space="preserve">
          <source>VarBangType</source>
          <target state="translated">VarBangType</target>
        </trans-unit>
        <trans-unit id="b1ba05716061d4ad4a7067da94c9ed09f99a946c" translate="yes" xml:space="preserve">
          <source>VarBangTypeQ</source>
          <target state="translated">VarBangTypeQ</target>
        </trans-unit>
        <trans-unit id="f123f793dd439ad762f7c51e88cad426181d7814" translate="yes" xml:space="preserve">
          <source>VarName</source>
          <target state="translated">VarName</target>
        </trans-unit>
        <trans-unit id="531a33bcae814983d338572b59b9463ed28fb861" translate="yes" xml:space="preserve">
          <source>VarStrictType</source>
          <target state="translated">VarStrictType</target>
        </trans-unit>
        <trans-unit id="5711069c2082e5c4d77257ab44a6c08571094741" translate="yes" xml:space="preserve">
          <source>VarStrictTypeQ</source>
          <target state="translated">VarStrictTypeQ</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="15c4ecedc500ccfa482669edb2e845eacd4e0e84" translate="yes" xml:space="preserve">
          <source>Variables not available for type application come first.</source>
          <target state="translated">类型应用中不可用的变量优先。</target>
        </trans-unit>
        <trans-unit id="ad3fca5915fe871548a7a02e59688c2946d84dec" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (&lt;a href=&quot;#scopedsort&quot;&gt;Ordering of specified variables&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7890a19f065bc82a225115edf83959ecb868d200" translate="yes" xml:space="preserve">
          <source>Variables not given an explicit ordering by the user are sorted according to ScopedSort (ScopedSort).</source>
          <target state="translated">用户没有给定明确排序的变量,会根据范围排序(ScopedSort)进行排序。</target>
        </trans-unit>
        <trans-unit id="c5051532d560f3e6f1cb25da75aeaa4c6b08bdc0" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; with the &quot;barrier to reordering&quot; property that &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; has.</source>
          <target state="translated">具有 &lt;code&gt;&lt;a href=&quot;data-ioref#v:writeIORef&quot;&gt;writeIORef&lt;/a&gt;&lt;/code&gt; 具有的&amp;ldquo;重新排序的障碍&amp;rdquo;属性的 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 体。</target>
        </trans-unit>
        <trans-unit id="6152289241c94f597f6f430c66fd3bcb3064ef73" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&lt;a href=&quot;system-posix-process#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 样式样式的 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="556bb60fe16c57c50b8543c1c68d9deecb83fe23" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; in the style of &lt;code&gt;forkIOWithUnmask&lt;/code&gt;.</source>
          <target state="translated">以 &lt;code&gt;&lt;a href=&quot;system-posix-process-bytestring#v:forkProcess&quot;&gt;forkProcess&lt;/a&gt;&lt;/code&gt; 样式样式的 &lt;code&gt;forkIOWithUnmask&lt;/code&gt; 变体。</target>
        </trans-unit>
        <trans-unit id="5ab80571e288ed5bbe0be1c8d6716fdd8193ae7b" translate="yes" xml:space="preserve">
          <source>Varieties of allowed instance overlap.</source>
          <target state="translated">允许实例重叠的品种。</target>
        </trans-unit>
        <trans-unit id="835f0ba40d3b282f5ab98f68f598b44f65bc9888" translate="yes" xml:space="preserve">
          <source>Vec16</source>
          <target state="translated">Vec16</target>
        </trans-unit>
        <trans-unit id="540c75a5875243c37fecc6bd16c9d7f6772ae9cf" translate="yes" xml:space="preserve">
          <source>Vec2</source>
          <target state="translated">Vec2</target>
        </trans-unit>
        <trans-unit id="dc943584902ab4bbd002a43d692ce71b9d58f2de" translate="yes" xml:space="preserve">
          <source>Vec32</source>
          <target state="translated">Vec32</target>
        </trans-unit>
        <trans-unit id="f8eca818e08bab8db06cb6f66fc580f204186bc4" translate="yes" xml:space="preserve">
          <source>Vec4</source>
          <target state="translated">Vec4</target>
        </trans-unit>
        <trans-unit id="8ba0e699ad554ce2e474bcde193517e598ba5c05" translate="yes" xml:space="preserve">
          <source>Vec64</source>
          <target state="translated">Vec64</target>
        </trans-unit>
        <trans-unit id="77c1450dba51a2de1b8c2c3dea0bef1c0881e1c4" translate="yes" xml:space="preserve">
          <source>Vec8</source>
          <target state="translated">Vec8</target>
        </trans-unit>
        <trans-unit id="71dc2126c05298594ccc8ee707120167da9301ff" translate="yes" xml:space="preserve">
          <source>VecCount</source>
          <target state="translated">VecCount</target>
        </trans-unit>
        <trans-unit id="0ad1ad8219ee6dfc03f9e55b6d4f4192aec151ef" translate="yes" xml:space="preserve">
          <source>VecElem</source>
          <target state="translated">VecElem</target>
        </trans-unit>
        <trans-unit id="5b8fb03269330bfd03e8a0ef6505dd31cd9aef3b" translate="yes" xml:space="preserve">
          <source>VerNTDomainControler</source>
          <target state="translated">VerNTDomainControler</target>
        </trans-unit>
        <trans-unit id="c615bd07a7c294b1379f8a4f09767f529b9759c0" translate="yes" xml:space="preserve">
          <source>VerNTServer</source>
          <target state="translated">VerNTServer</target>
        </trans-unit>
        <trans-unit id="99b2611bdc2d4621ca6b2a6f13d6c11fd6197f76" translate="yes" xml:space="preserve">
          <source>VerNTWorkStation</source>
          <target state="translated">VerNTWorkStation</target>
        </trans-unit>
        <trans-unit id="9ae538ce2ead84f96e0983545f16a938a86ec050" translate="yes" xml:space="preserve">
          <source>VerboseGCStats</source>
          <target state="translated">VerboseGCStats</target>
        </trans-unit>
        <trans-unit id="c004031cc38b772cc79ef49fac3a30036d52b965" translate="yes" xml:space="preserve">
          <source>Verify OS version</source>
          <target state="translated">确认操作系统版本</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d0560558326cfe0814496b75139ad411b6e5c6d7" translate="yes" xml:space="preserve">
          <source>Version Info</source>
          <target state="translated">版本信息</target>
        </trans-unit>
        <trans-unit id="6392f7e65414938d8f9a4a698376045c9e03b96e" translate="yes" xml:space="preserve">
          <source>Version information about your computer.</source>
          <target state="translated">你的电脑的版本信息。</target>
        </trans-unit>
        <trans-unit id="e16193c9fa0396ab60a71b729b4a04cd813d0d61" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; without any value being passed to the second and third actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d9e02f3589b6f19de666e5b0bee38d7559d42d" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="74c019334e2fff57ca4e39f259c2452610b715a1" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c674b58777219e1075437ed39b3c9108ee08578" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToAddr&quot;&gt;exportIntegerToAddr&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="3f6eda259e7693d3f6bb91c551fe6552272e7401" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="1e7284b212c3e18b15655fd8a93f4230611c203f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6ce8b322b59cc5d8064026a32cbb943fe8545c" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Types.html#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:exportIntegerToMutableByteArray&quot;&gt;exportIntegerToMutableByteArray&lt;/a&gt;&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="832e7e2813641581d62224e801d6ea6e8ce61f6e" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromAddr&quot;&gt;importIntegerFromAddr&lt;/a&gt;&lt;/code&gt; 构建 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15a7e4e675439edfb4791329d53c5140785feffe" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; constructing a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">构造 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:importIntegerFromByteArray&quot;&gt;importIntegerFromByteArray&lt;/a&gt;&lt;/code&gt; 的版本</target>
        </trans-unit>
        <trans-unit id="3383f2c0a3a8b49db2500fd0baa98b81bb0d0957" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f765b17c2a64921c78875b10782b9628b760d848" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:nextPrimeInteger&quot;&gt;nextPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="9d7b173a0dcac34771410bf511deb7fb53172de2" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c801b21720bc581908856b870e17ed49d47664d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;-sized moduli</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 尺度的模</target>
        </trans-unit>
        <trans-unit id="5327d1f9c85d2b9f4ca753101d89eae2dbb8c788" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="bcd38df7c17761d370b1e5803d31bed7f709a369" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5f4af0d958ccbfedde85a3c86cd01593836917" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="b6f1069fce56ce801f8354d107d5e21e6b621ce9" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="1c0304fc532fda6e0a0fb66673b691dbdd8f5987" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd667eefc588b1d250466aacaf85fc27e718fb5f" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:recipModInteger&quot;&gt;recipModInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="a6044e2d3109e70122fc56fdcea3e1d09e656dfa" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22b9c46cdd68688219fc77a7a7a0110bec5346a6" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e828c6392feef9cda9a5abcfda4742e696efb0" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 上运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:sizeInBaseInteger&quot;&gt;sizeInBaseInteger&lt;/a&gt;&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="a536b25d8e167ced3997cbed939d7787c9262c5a" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="e9f8dae2a07adfa71cf9369406dff32b07be5f54" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8f2244600b387515bdab7904923bc126c9eb96" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">版本 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:testPrimeInteger&quot;&gt;testPrimeInteger&lt;/a&gt;&lt;/code&gt; 上操作 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; 小号</target>
        </trans-unit>
        <trans-unit id="8cdbd76fc9bb8d2b3e6d6713ff0d54dc00311cca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;nextPrimeInteger&lt;/code&gt; operating on &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt;s</source>
          <target state="translated">在 &lt;code&gt;nextPrimeInteger&lt;/code&gt; 运行的 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; 的版本</target>
        </trans-unit>
        <trans-unit id="c6de149b153b8aa69634515bd7cf4e2a928766c9" translate="yes" xml:space="preserve">
          <source>Versioning schemes are many and varied, so the version representation provided by this library is intended to be a compromise between complete generality, where almost no common functionality could reasonably be provided, and fixing a particular versioning scheme, which would probably be too restrictive.</source>
          <target state="translated">版本方案是多种多样的,所以这个库提供的版本表示是为了在完全的通用性和固定一个特定的版本方案之间做一个折衷,前者几乎没有合理的通用功能可以提供,后者可能限制性太强。</target>
        </trans-unit>
        <trans-unit id="e5648eccf2ada7509f9293bed38e65578d366748" translate="yes" xml:space="preserve">
          <source>Vertex</source>
          <target state="translated">Vertex</target>
        </trans-unit>
        <trans-unit id="258d739865b4967aba2b35b179e8923c0c132927" translate="yes" xml:space="preserve">
          <source>View of the left end of a sequence.</source>
          <target state="translated">一个序列的左端视图。</target>
        </trans-unit>
        <trans-unit id="e5a2c0c052661af0715d02ca0746b83ffc99ead9" translate="yes" xml:space="preserve">
          <source>View of the right end of a sequence.</source>
          <target state="translated">序列右端视图。</target>
        </trans-unit>
        <trans-unit id="d4429efe2ba08d11709f9a9411ea8bf96035c79f" translate="yes" xml:space="preserve">
          <source>View patterns</source>
          <target state="translated">查看模式</target>
        </trans-unit>
        <trans-unit id="759011cb4b498a00a5d40b985273fec7c69b96d4" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="translated">视图模式由语言扩展&lt;a href=&quot;#extension-ViewPatterns&quot;&gt; &lt;code&gt;ViewPatterns&lt;/code&gt; &lt;/a&gt;启用。可以在&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ViewPatterns&quot;&gt;Wiki页面&lt;/a&gt;上找到更多信息和视图模式示例。</target>
        </trans-unit>
        <trans-unit id="e310bf26720d505a9536f51e809dfeaae92ef176" translate="yes" xml:space="preserve">
          <source>View patterns are enabled by the language extension &lt;a href=&quot;#extension-ViewPatterns&quot;&gt;&lt;code&gt;ViewPatterns&lt;/code&gt;&lt;/a&gt;. More information and examples of view patterns can be found on the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns&quot;&gt;Wiki page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385f30104d7ac03e2ef259bd63000a69f570c213" translate="yes" xml:space="preserve">
          <source>View patterns are somewhat like pattern guards that can be nested inside of other patterns. They are a convenient way of pattern-matching against values of abstract types. For example, in a programming language implementation, we might represent the syntax of the types of the language as follows:</source>
          <target state="translated">视图模式有点像模式卫士,可以嵌套在其他模式中。它们是一种针对抽象类型的值进行模式匹配的便捷方式。例如,在编程语言的实现中,我们可以将语言类型的语法表示如下。</target>
        </trans-unit>
        <trans-unit id="4df943f62e6c8ddc92646e7016412dbb6ea1b50e" translate="yes" xml:space="preserve">
          <source>View patterns permit calling the view function inside the pattern and matching against the result:</source>
          <target state="translated">视图模式允许在模式内调用视图函数并与结果进行匹配。</target>
        </trans-unit>
        <trans-unit id="fb31bc0e3393551ce685fb55bf7120aa72babea6" translate="yes" xml:space="preserve">
          <source>ViewL</source>
          <target state="translated">ViewL</target>
        </trans-unit>
        <trans-unit id="d1991a4d3da871522e2bbc6ec649eb8b2443c06f" translate="yes" xml:space="preserve">
          <source>ViewPatterns</source>
          <target state="translated">ViewPatterns</target>
        </trans-unit>
        <trans-unit id="2b6a45709971580ec2c9bf4fd7edac984b91011b" translate="yes" xml:space="preserve">
          <source>ViewR</source>
          <target state="translated">ViewR</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="0c9512fc7af324680205ac18f56b08c8977ff468" translate="yes" xml:space="preserve">
          <source>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</source>
          <target state="translated">事实上,所有的数据构造函数,甚至是那些具有丰富种类的构造函数,都可以被推广。这个规则只有几个例外。</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="0e6da5d7cf3ddcb038a9cd33f4c9a4ead9f1f224" translate="yes" xml:space="preserve">
          <source>Void#</source>
          <target state="translated">Void#</target>
        </trans-unit>
        <trans-unit id="1744c6671af49183ef1e812a57246c735303f9b9" translate="yes" xml:space="preserve">
          <source>Void: used for datatypes without constructors</source>
          <target state="translated">Void:用于没有构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="fc9b625441892438a2a4e98eb96658b46731cefe" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：此函数可能会生成损坏的地图，其结果可能取决于其输入的内部结构。用户应首选 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f1d631a527f3bd9dc355e39579514f4553de63e" translate="yes" xml:space="preserve">
          <source>WARNING: This function can produce corrupt maps and its results may depend on the internal structures of its inputs. Users should prefer &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">警告：此函数可能会生成损坏的地图，其结果可能取决于其输入的内部结构。用户应首选 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="084fa6805f92e87b6e77edf5f9a630d4cdb4aefc" translate="yes" xml:space="preserve">
          <source>WARNING: weak pointers to ordinary non-primitive Haskell types are particularly fragile, because the compiler is free to optimise away or duplicate the underlying data structure. Therefore attempting to place a finalizer on an ordinary Haskell type may well result in the finalizer running earlier than you expected. This is not a problem for caches and memo tables where early finalization is benign.</source>
          <target state="translated">警告:普通非原始 Haskell 类型的弱指针特别脆弱,因为编译器可以自由地优化或复制底层数据结构。因此,试图在普通的 Haskell 类型上放置一个定型器,很可能导致定型器比你预期的更早运行。对于缓存和备忘录表来说,这并不是一个问题,因为在这些地方,早期的定稿是良性的。</target>
        </trans-unit>
        <trans-unit id="828a0630535cfdfa8da88cbc77494ab9ee052b4d" translate="yes" xml:space="preserve">
          <source>WIN32_FILE_ATTRIBUTE_DATA</source>
          <target state="translated">WIN32_FILE_ATTRIBUTE_DATA</target>
        </trans-unit>
        <trans-unit id="365c8d927f6c55a00833c44920ae5ef485b24497" translate="yes" xml:space="preserve">
          <source>WIN32_FIND_DATA</source>
          <target state="translated">WIN32_FIND_DATA</target>
        </trans-unit>
        <trans-unit id="2902f0e3f68395e4fc65aadd29162468ba35af66" translate="yes" xml:space="preserve">
          <source>WNDCLASS</source>
          <target state="translated">WNDCLASS</target>
        </trans-unit>
        <trans-unit id="986b96d045e3b44c351b49c804df41703506da7c" translate="yes" xml:space="preserve">
          <source>WORD</source>
          <target state="translated">WORD</target>
        </trans-unit>
        <trans-unit id="430f8d35dbcd6de24ccbd7d66bfdb1103a3b3b50" translate="yes" xml:space="preserve">
          <source>WPARAM</source>
          <target state="translated">WPARAM</target>
        </trans-unit>
        <trans-unit id="6bbe857b7c7f17106bc9c59652d265e7579cd9db" translate="yes" xml:space="preserve">
          <source>Wait for a unit to become available</source>
          <target state="translated">等到有单位的时候</target>
        </trans-unit>
        <trans-unit id="6318af48ff9b448ca1d106c8c5f9cb40406a4e18" translate="yes" xml:space="preserve">
          <source>Wait for the specified quantity to become available</source>
          <target state="translated">等待指定数量的产品上市</target>
        </trans-unit>
        <trans-unit id="27f62e224bf5811713a6aa41515c5ce1c138cd54" translate="yes" xml:space="preserve">
          <source>Wait on &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; (aka &lt;strong&gt;P&lt;/strong&gt; operation).</source>
          <target state="translated">等待 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tsem#t:TSem&quot;&gt;TSem&lt;/a&gt;&lt;/code&gt; （又名&lt;strong&gt;P&lt;/strong&gt;操作）。</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="fdee09e1c8568a0971d8797c7eceeb9038bfcbcb" translate="yes" xml:space="preserve">
          <source>Waiting for signals</source>
          <target state="translated">等待信号</target>
        </trans-unit>
        <trans-unit id="572c89962b6ad39f8a6c6c966a575192e24a760d" translate="yes" xml:space="preserve">
          <source>Waits for one key to be pressed, then returns. Ignores the value of the specific key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57389edadcb916db172b6b4efd5296864599035f" translate="yes" xml:space="preserve">
          <source>Waits for the specified process to terminate, and returns its exit code.</source>
          <target state="translated">等待指定的进程终止,并返回其退出代码。</target>
        </trans-unit>
        <trans-unit id="61b5000b8e42614f728bac5368665c9afa541b95" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration.</source>
          <target state="translated">警告类型签名中的类约束,可以使用顶层实例声明来简化。</target>
        </trans-unit>
        <trans-unit id="43078a38014da565cf36b789293d26d37c791bef" translate="yes" xml:space="preserve">
          <source>Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</source>
          <target state="translated">警告类型签名中的类约束,可以使用顶层实例声明来简化。例如:</target>
        </trans-unit>
        <trans-unit id="2f17deafc978e685508816d0d4ac503ec8d814c7" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when none of the bound variables are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a962ab5861876e6eea5477b0e84923e9646bd87f" translate="yes" xml:space="preserve">
          <source>Warn about record wildcard matches when the wildcard binds no patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c0f6e86b2815a92eee0403dbbef1a02e0722d0" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt;).</source>
          <target state="translated">警告如果 &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; 向后定义（即 &lt;code&gt;(&amp;lt;&amp;gt;) = mappend&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="59480446bfa54f329c48448e6528e481181e7868" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;(*&amp;gt;)&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">如果向后定义 &lt;code&gt;(*&amp;gt;)&lt;/code&gt; （即 &lt;code&gt;(*&amp;gt;) = (&amp;gt;&amp;gt;)&lt;/code&gt; ），则发出警告。</target>
        </trans-unit>
        <trans-unit id="29a113dacf30bae34993ef0968692193ceabe83b" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;fail&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt;).</source>
          <target state="translated">如果向后定义了 &lt;code&gt;fail&lt;/code&gt; 则发出警告（即 &lt;code&gt;fail = Control.Monad.fail&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="849b5273d5eb661e6eb5614d0cddf2d6fd432ef3" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;pure&lt;/code&gt; is defined backwards (i.e. &lt;code&gt;pure = return&lt;/code&gt;).</source>
          <target state="translated">警告是否向后定义了 &lt;code&gt;pure&lt;/code&gt; （即 &lt;code&gt;pure = return&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8d0b01e21f7d62ff7ec2fdb8f36e3e14f652bc2a" translate="yes" xml:space="preserve">
          <source>Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</source>
          <target state="translated">如果一个模式绑定根本没有绑定任何变量,则发出警告,除非它是一个孤零零的通配符模式,或者是一个被撞的模式。例如</target>
        </trans-unit>
        <trans-unit id="d1d186912c1ee8144fbf61683a158749e17d0d8e" translate="yes" xml:space="preserve">
          <source>Warn if a promoted data constructor is used without a tick preceding its name.</source>
          <target state="translated">如果使用了一个被推广的数据构造函数,而在其名称前没有打勾,则发出警告。</target>
        </trans-unit>
        <trans-unit id="55515cbed4e1b2f4cafa3830ade353ff4bda2502" translate="yes" xml:space="preserve">
          <source>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See &lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;How rules interact with INLINE/NOINLINE pragmas&lt;/a&gt;.</source>
          <target state="translated">如果重写规则可能无法触发，则发出警告，因为该函数可能在规则触发之前就已内联。请参阅&lt;a href=&quot;glasgow_exts#rules-inline&quot;&gt;规则如何与INLINE / NOINLINE编译指示交互&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1ee84bd31cfd036a652ec43cd7989ce759f8b29" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非规范的 &lt;code&gt;Applicative&lt;/code&gt; 或 &lt;code&gt;Monad&lt;/code&gt; 实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="9cef51bc5727ce621a5f1887fb407974a04d16d0" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Monad&lt;/code&gt; or &lt;code&gt;MonadFail&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非 &lt;code&gt;MonadFail&lt;/code&gt; &lt;code&gt;Monad&lt;/code&gt; 或MonadFail实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="ed48e3c9af6f4e305d15859d8b2f83e1331ef132" translate="yes" xml:space="preserve">
          <source>Warn if noncanonical &lt;code&gt;Semigroup&lt;/code&gt; or &lt;code&gt;Monoid&lt;/code&gt; instances declarations are detected.</source>
          <target state="translated">如果检测到非规范的 &lt;code&gt;Semigroup&lt;/code&gt; 或 &lt;code&gt;Monoid&lt;/code&gt; 实例声明，则发出警告。</target>
        </trans-unit>
        <trans-unit id="68b4c1ca04373000f34260c5d11f4973aeeeccf7" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</source>
          <target state="translated">当GHCi无法加载共享库时发出警告，它推断它应该在加载软件包并分析目标软件包描述的库外节时加载。</target>
        </trans-unit>
        <trans-unit id="9965a9366f3d0595feaae0ce4341dcbef127b246" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can&amp;rsquo;t load a shared lib.</source>
          <target state="translated">GHCi无法加载共享库时发出警告。</target>
        </trans-unit>
        <trans-unit id="6590e9bd34bfc2ad804659f30bd772d752f4af5b" translate="yes" xml:space="preserve">
          <source>Warn when GHCi can't load a shared lib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46390c87741b9706a466b65da731fff3e418560" translate="yes" xml:space="preserve">
          <source>Warn when a deferred out-of-scope variable is encountered.</source>
          <target state="translated">当遇到延迟的范围外变量时发出警告。</target>
        </trans-unit>
        <trans-unit id="96bfc5daceff7e0488089aa570da728cb493edc4" translate="yes" xml:space="preserve">
          <source>Warn when a failable pattern is used in a do-block that does not have a &lt;code&gt;MonadFail&lt;/code&gt; instance.</source>
          <target state="translated">在没有 &lt;code&gt;MonadFail&lt;/code&gt; 实例的do-block中使用可故障模式时发出警告。</target>
        </trans-unit>
        <trans-unit id="3293ac237f66bb3bd8a2afd3f8f8ca5a83dd8162" translate="yes" xml:space="preserve">
          <source>Warn when definitions are in conflict with the future inclusion of &lt;code&gt;Semigroup&lt;/code&gt; into the standard typeclasses.</source>
          <target state="translated">当定义与将来将 &lt;code&gt;Semigroup&lt;/code&gt; 包含到标准类型类中时发生冲突时发出警告。</target>
        </trans-unit>
        <trans-unit id="e2a74af50193828b0a14e324da2adc93937af1a2" translate="yes" xml:space="preserve">
          <source>Warn when using &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; with an unsupported version of LLVM.</source>
          <target state="translated">在将&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;与不支持的LLVM版本一起使用时发出警告。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="c38b084fb6f65e7af1b378de79589e1325e38a54" translate="yes" xml:space="preserve">
          <source>Warning: The &lt;code&gt;nodeFromVertex&lt;/code&gt; function will cause a runtime exception if the given &lt;code&gt;Vertex&lt;/code&gt; does not exist.</source>
          <target state="translated">警告：如果给定的 &lt;code&gt;Vertex&lt;/code&gt; 不存在，则 &lt;code&gt;nodeFromVertex&lt;/code&gt; 函数将导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="f75b5d0e744c785f19b3b4e68a6a3627d41d76ee" translate="yes" xml:space="preserve">
          <source>Warning: This function has several shortcomings (see documentation). Please consider using Control.Concurrent.threadDelay instead.</source>
          <target state="translated">警告:此功能有几个缺点(见文档)。这个函数有几个缺点(见文档)。请考虑使用Control.Concurrent.threadDelay代替。</target>
        </trans-unit>
        <trans-unit id="1fddc0d2254098ec17b8f54408305994aa1d6fcb" translate="yes" xml:space="preserve">
          <source>Warning: This function will cause a runtime exception if a vertex in the edge list is not within the given &lt;code&gt;Bounds&lt;/code&gt;.</source>
          <target state="translated">警告：如果边缘列表中的顶点不在给定的 &lt;code&gt;Bounds&lt;/code&gt; 之内，则此函数将导致运行时异常。</target>
        </trans-unit>
        <trans-unit id="ddc67996032923fb44bbe38302d09be9a107bc9e" translate="yes" xml:space="preserve">
          <source>Warning: This is an unstable interface.</source>
          <target state="translated">警告,这是一个不稳定的接口。这是一个不稳定的接口。</target>
        </trans-unit>
        <trans-unit id="7c32ffe73eb28c83dc7fdc739c17c7f330c7b154" translate="yes" xml:space="preserve">
          <source>Warning: newlines and tab characters are not considered separators.</source>
          <target state="translated">警告:换行符和制表符不被视为分隔符。</target>
        </trans-unit>
        <trans-unit id="629bc586b5e729bb9402698a5fab7a7d389d1585" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*这个模块是内部模块,如果你发现你需要它,请联系维护者,并说明你想做什么,并讨论你在公共API中需要什么。如果你发现你需要它,请联系维护者,解释你正在尝试做什么,并讨论你在公共API中需要什么。这一点很重要,因为该模块可能在未来的版本中根本不会被暴露。</target>
        </trans-unit>
        <trans-unit id="cf088808c116353dbd9751c6832d8f94da7809aa" translate="yes" xml:space="preserve">
          <source>Warning:* this module is internal. If you find that you need it then please contact the maintainers and explain what you are trying to do and discuss what you would need in the public API. It is important that you do this as the module may not be exposed at all in future releases.</source>
          <target state="translated">警告:*这个模块是内部模块,如果你发现你需要它,那么请联系维护者,说明你想做什么,并讨论你在公共API中需要什么。如果你发现你需要它,那么请联系维护者,解释你正在尝试做什么,并讨论你在公共API中需要什么。这一点很重要,因为该模块可能在未来的版本中根本不会被暴露。</target>
        </trans-unit>
        <trans-unit id="26ca8ee92f6bef28fdcc1bef2c38389bdc4002fe" translate="yes" xml:space="preserve">
          <source>Warnings and deprecations are not reported for (a) uses within the defining module, (b) defining a method in a class instance, and (c) uses in an export list. The latter reduces spurious complaints within a library in which one module gathers together and re-exports the exports of several others.</source>
          <target state="translated">对于(a)在定义模块中的使用,(b)在类实例中定义方法,以及(c)在导出列表中的使用,不报告警告和废弃。后者减少了在一个库中,一个模块将其他几个模块的导出集合起来再导出的虚假投诉。</target>
        </trans-unit>
        <trans-unit id="1e250b1caeb20441fd438fd161ae0b14cdfe173a" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">警告仅被视为警告，而不是错误。这是默认设置，但是对否定&lt;a href=&quot;#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;标志很有用。</target>
        </trans-unit>
        <trans-unit id="2494895ad5475179cdf03bf37393c57bb4ffcf96" translate="yes" xml:space="preserve">
          <source>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a &lt;a href=&quot;#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3800447d155c1657cd8727b0981f5edb4c28c0bc" translate="yes" xml:space="preserve">
          <source>Warns on qualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144e9714d0407d7b54e8bc884ed3f1a3e6c89f17" translate="yes" xml:space="preserve">
          <source>Was this program compiled with an &lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;unregistered&amp;rdquo;&lt;/a&gt; version of GHC? (I.e., a version of GHC that has no platform-specific optimisations compiled in, usually because this is a currently unsupported platform.) This value will usually be no, unless you&amp;rsquo;re using an experimental build of GHC.</source>
          <target state="translated">该程序是否使用GHC 的&lt;a href=&quot;codegens#unreg&quot;&gt;&amp;ldquo;未注册&amp;rdquo;&lt;/a&gt;版本进行编译？（即，没有编译特定于平台的优化的GHC版本，通常是因为这是当前不支持的平台。）除非您使用GHC的实验版本，否则该值通常为no。</target>
        </trans-unit>
        <trans-unit id="0ec4a53513a96c37bb1d735df3ccce52d2721a6b" translate="yes" xml:space="preserve">
          <source>We achieve (1) by completely handing over control over writing to the buffer to the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; implementing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. This &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is just told the start and the end of the buffer (represented as a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;). Then, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; can write to as big a prefix of this &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; in any way it desires. If the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; is done, the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; is full, or a long sequence of bytes should be inserted directly, then the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; signals this to its caller using a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过将对缓冲区写入的控制权完全移交给实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ,我们实现了（1）。只是告诉此 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 缓冲区的开始和结束（以 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 表示）。然后， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 可以 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 希望的任何方式写入此BufferRange的前缀。如果 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 完成后， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 是满的，或字节的长序列应该被直接插入，则 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 信号这对使用它的调用者 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildSignal&quot;&gt;BuildSignal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7129f4a3666efd25be6cb12c609b3df9c118e270" translate="yes" xml:space="preserve">
          <source>We achieve (2) by requiring that every &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is implemented by a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; that takes a continuation &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt;, which it calls with the updated &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; after it is done. Therefore, only two pointers have to be passed in a function call to implement concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. Moreover, many &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are completely inlined, which enables the compiler to sequence them without a function call and with no boxing at all.</source>
          <target state="translated">我们通过要求每一个实现（2） &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 由实施 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ，需要一个延续 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; ，它与更新的要求 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 它完成之后。因此，在函数调用中只需传递两个指针即可实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的串联。而且，许多 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 都是完全内联的，这使编译器可以对它们进行排序，而无需调用函数，也无需装箱。</target>
        </trans-unit>
        <trans-unit id="34141d222212ddc97bf14e8cf292ad013e804639" translate="yes" xml:space="preserve">
          <source>We also recommend using &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; for profiling parallel programs; it offers a GUI for visualising parallel execution, and is complementary to the time and space profiling features provided with GHC.</source>
          <target state="translated">我们还建议使用&lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;来分析并行程序。它提供了用于可视化并行执行的GUI，是对GHC随附的时间和空间分析功能的补充。</target>
        </trans-unit>
        <trans-unit id="7b758bcc0523e67b5511af6416e9d11a986e5ca3" translate="yes" xml:space="preserve">
          <source>We also wish to lift the operations of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; through both &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. For the operation &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt;, we know &lt;code&gt;throwE e&lt;/code&gt; is a simple action, so we can lift it through the two monad transformers to &lt;code&gt;InterpM&lt;/code&gt; with two &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s:</source>
          <target state="translated">我们也希望解除的操作 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:ExceptT&quot;&gt;ExceptT&lt;/a&gt;&lt;/code&gt; 通过两个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-reader#v:ReaderT&quot;&gt;ReaderT&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 。对于 &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:throwE&quot;&gt;throwE&lt;/a&gt;&lt;/code&gt; 的操作，我们知道 &lt;code&gt;throwE e&lt;/code&gt; 是一个简单的动作，因此我们可以通过两个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; s 通过两个monad变压器将其提升到 &lt;code&gt;InterpM&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="012374a3782eface8cda6f8176b4f967bdf07645" translate="yes" xml:space="preserve">
          <source>We are actually using &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; here with the more specific type</source>
          <target state="translated">实际上，我们在这里使用 &lt;code&gt;&amp;lt;+&amp;gt;&lt;/code&gt; 和更具体的类型</target>
        </trans-unit>
        <trans-unit id="1364b2ffc98a40ba87a6d1a4baeb267657a77bf2" translate="yes" xml:space="preserve">
          <source>We are not limited to a single module: GHCi can combine scopes from multiple modules, in any mixture of &lt;code&gt;*&lt;/code&gt; and non-&lt;code&gt;*&lt;/code&gt; forms. GHCi combines the scopes from all of these modules to form the scope that is in effect at the prompt.</source>
          <target state="translated">我们不仅限于单个模块：GHCi可以将 &lt;code&gt;*&lt;/code&gt; 和非 &lt;code&gt;*&lt;/code&gt; 形式的任意组合的多个模块合并在一起。GHCi合并了所有这些模块的作用域，以形成在提示时有效的作用域。</target>
        </trans-unit>
        <trans-unit id="505b8bfd5df7cd6941272c5cbc63e2f31a6818f5" translate="yes" xml:space="preserve">
          <source>We call this a procedure or arrow abstraction. As with a lambda expression, the variable &lt;code&gt;x&lt;/code&gt; is a new variable bound within the &lt;code&gt;proc&lt;/code&gt;-expression. It refers to the input to the arrow. In the above example, &lt;code&gt;-&amp;lt;&lt;/code&gt; is not an identifier but a new reserved symbol used for building commands from an expression of arrow type and an expression to be fed as input to that arrow. (The weird look will make more sense later.) It may be read as analogue of application for arrows. The above example is equivalent to the Haskell expression</source>
          <target state="translated">我们称其为过程或箭头抽象。与lambda表达式一样，变量 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;proc&lt;/code&gt; -expression中绑定的新变量。它指的是箭头的输入。在上面的示例中， &lt;code&gt;-&amp;lt;&lt;/code&gt; 不是标识符，而是新的保留符号，用于根据箭头类型的表达式和要作为该箭头的输入提供的表达式来构建命令。（怪异的外观稍后会更有意义。）可以将其视为类似于箭头的应用。上面的示例等效于Haskell表达式</target>
        </trans-unit>
        <trans-unit id="6e5716800a0eaccf2960d2b7a5093cb3ebe30351" translate="yes" xml:space="preserve">
          <source>We can also define a primitive using the Writer:</source>
          <target state="translated">我们也可以使用Writer定义一个基元。</target>
        </trans-unit>
        <trans-unit id="be9121877015a3f7b1808375eae4f4fe67fa8ae2" translate="yes" xml:space="preserve">
          <source>We can also derive instances of constructor classes in a similar way. For example, suppose we have implemented state and failure monad transformers, such that</source>
          <target state="translated">我们也可以用类似的方式导出构造函数类的实例。例如,假设我们已经实现了状态和失败的单体变换器,这样就可以实现</target>
        </trans-unit>
        <trans-unit id="741f9736e016d9e070c0aa7dbe73afecd6f0010b" translate="yes" xml:space="preserve">
          <source>We can also directly serialise a value to and from a Handle, or a file:</source>
          <target state="translated">我们也可以直接将一个值序列化到一个Handle或一个文件,或从一个Handle或文件序列化。</target>
        </trans-unit>
        <trans-unit id="f871cfbc2b7125e2e8dcf75e051bc46571b48be3" translate="yes" xml:space="preserve">
          <source>We can also generate a marked-up version of the source.</source>
          <target state="translated">我们还可以生成源码的标记版本。</target>
        </trans-unit>
        <trans-unit id="22254f055266e4957fe0dec18116c8e64f2caa21" translate="yes" xml:space="preserve">
          <source>We can also quote arguments which contains characters like spaces, and they are treated like Haskell strings, or we can just use Haskell list syntax:</source>
          <target state="translated">我们也可以引用包含空格等字符的参数,它们被当作 Haskell 字符串处理,或者我们可以直接使用 Haskell 列表语法。</target>
        </trans-unit>
        <trans-unit id="aa27fa4197acc4f2720dc6ce9a9707a4f8d1435c" translate="yes" xml:space="preserve">
          <source>We can also use it to hex-encode a strict &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; as shown by the &lt;code&gt;byteStringHex&lt;/code&gt; example above.</source>
          <target state="translated">我们还可以使用它来对严格的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 进行十六进制编码，如上面的 &lt;code&gt;byteStringHex&lt;/code&gt; 示例所示。</target>
        </trans-unit>
        <trans-unit id="babbe24170cb9915e4b398c5539adfe43947f851" translate="yes" xml:space="preserve">
          <source>We can check now that as expected, the type of &lt;code&gt;x&lt;/code&gt; has been reconstructed, and with it the type of &lt;code&gt;f&lt;/code&gt; has been too:</source>
          <target state="translated">现在我们可以检查是否像预期的那样重构了 &lt;code&gt;x&lt;/code&gt; 的类型，并且使用它也重构了 &lt;code&gt;f&lt;/code&gt; 的类型：</target>
        </trans-unit>
        <trans-unit id="04273c99bc18760cd81d4706487c1581b70b8de7" translate="yes" xml:space="preserve">
          <source>We can clearly see that we are converting to a &lt;em&gt;binary&lt;/em&gt; format. The '&amp;lambda;' and '&amp;ouml;' characters, which have a Unicode codepoint above 127, are expanded to their corresponding UTF-8 multi-byte representation.</source>
          <target state="translated">我们可以清楚地看到我们正在转换为&lt;em&gt;二进制&lt;/em&gt;格式。具有127以上的Unicode代码点的'&amp;lambda;'和'&amp;ouml;'字符被扩展为它们对应的UTF-8多字节表示形式。</target>
        </trans-unit>
        <trans-unit id="371d2c63febd96740f02aa9a6938c3c33c947260" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 多次组合多个基元。</target>
        </trans-unit>
        <trans-unit id="d1282c8550fbf06601d51db5aa6d160a69b5d732" translate="yes" xml:space="preserve">
          <source>We can combine multiple primitives using &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; multiple times.</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:-62--42--60-&quot;&gt;&amp;gt;*&amp;lt;&lt;/a&gt;&lt;/code&gt; 多次组合多个基元。</target>
        </trans-unit>
        <trans-unit id="27dcb75f752bffd30cefe5814229f01f2029d702" translate="yes" xml:space="preserve">
          <source>We can combine multiple values in a list into a single value using the &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; function. Note that we have to specify the type here since &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; is a monoid under several different operations:</source>
          <target state="translated">我们可以使用 &lt;code&gt;&lt;a href=&quot;data-monoid#v:mconcat&quot;&gt;mconcat&lt;/a&gt;&lt;/code&gt; 函数将列表中的多个值组合为一个值。请注意，我们必须在此处指定类型，因为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 在几种不同的操作下是一个monoid：</target>
        </trans-unit>
        <trans-unit id="c22fbe2e8acadfba1f70ca18177a9747d7880239" translate="yes" xml:space="preserve">
          <source>We can compile &lt;code&gt;D&lt;/code&gt;, then load the whole program, like this:</source>
          <target state="translated">我们可以编译 &lt;code&gt;D&lt;/code&gt; ，然后加载整个程序，如下所示：</target>
        </trans-unit>
        <trans-unit id="c6b34f628eb0b709631642cca69699daa7f68c06" translate="yes" xml:space="preserve">
          <source>We can define a command that reads GHCi input from a file. This might be useful for creating a set of bindings that we want to repeatedly load into the GHCi session:</source>
          <target state="translated">我们可以定义一个从文件中读取GHCi输入的命令。这对于创建一组我们想要重复加载到 GHCi 会话中的绑定可能很有用。</target>
        </trans-unit>
        <trans-unit id="9716152c7206a19681525bfc80a69323b0c68dff" translate="yes" xml:space="preserve">
          <source>We can define a parser that also counts by adding a &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer:</source>
          <target state="translated">我们可以定义一个解析器，该解析器也可以通过添加 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 转换器来计数：</target>
        </trans-unit>
        <trans-unit id="2e74500104f965816a71f75ad2e503eda1dea427" translate="yes" xml:space="preserve">
          <source>We can define either prefix, infix or record pattern synonyms by modifying the form of &lt;code&gt;pat_lhs&lt;/code&gt;. The syntax for these is as follows:</source>
          <target state="translated">我们可以通过修改 &lt;code&gt;pat_lhs&lt;/code&gt; 的形式来定义前缀，中缀或记录模式同义词。这些的语法如下：</target>
        </trans-unit>
        <trans-unit id="56be7f23e4f4ea2ae4416d0b7ff5efb2b70ee14f" translate="yes" xml:space="preserve">
          <source>We can define parallel list comprehensions by translation to regular comprehensions. Here&amp;rsquo;s the basic idea:</source>
          <target state="translated">我们可以通过转换为常规理解来定义并行列表理解。这是基本思想：</target>
        </trans-unit>
        <trans-unit id="907cdcaa99e2ff41201b2662179ecfa39a9ce78e" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="translated">我们可以通过在 &lt;code&gt;[]&lt;/code&gt; monad上添加一个状态（需要解析的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）来定义这样的解析器monad，它提供了不确定性：</target>
        </trans-unit>
        <trans-unit id="b9c01a3a2622d4196ecfba7e8743aedf0cb3a68d" translate="yes" xml:space="preserve">
          <source>We can define such a parser monad by adding a state (the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; remaining to be parsed) to the &lt;code&gt;[]&lt;/code&gt; monad, which provides non-determinism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc02c0a7e6a16240bcfe1eb3a01240b894592e9" translate="yes" xml:space="preserve">
          <source>We can encode values of this type into bytestrings using the following instance, which proceeds by recursively breaking down the structure to serialise:</source>
          <target state="translated">我们可以使用下面的实例将这种类型的值编码成字节串,它通过递归分解结构来进行序列化。</target>
        </trans-unit>
        <trans-unit id="609bdca8889dc8d6840c848dc0cf9da272df2f46" translate="yes" xml:space="preserve">
          <source>We can even derive instances of multi-parameter classes, provided the newtype is the last class parameter. In this case, a &amp;ldquo;partial application&amp;rdquo; of the class appears in the &lt;code&gt;deriving&lt;/code&gt; clause. For example, given the class</source>
          <target state="translated">如果newtype是最后一个类参数，我们甚至可以派生多参数类的实例。在这种情况下，该类的&amp;ldquo;部分应用程序&amp;rdquo;出现在 &lt;code&gt;deriving&lt;/code&gt; 子句中。例如，给定类</target>
        </trans-unit>
        <trans-unit id="bb904fd56e78dfb6ddf362dca7a6154b196c3889" translate="yes" xml:space="preserve">
          <source>We can instead create a newtype &lt;code&gt;App&lt;/code&gt; (where &lt;code&gt;App f a&lt;/code&gt; and &lt;code&gt;f a&lt;/code&gt; are represented the same in memory) and use &lt;a href=&quot;#extension-DerivingVia&quot;&gt;&lt;code&gt;DerivingVia&lt;/code&gt;&lt;/a&gt; to explicitly enable uses of this pattern:</source>
          <target state="translated">相反，我们可以创建一个新类型的 &lt;code&gt;App&lt;/code&gt; （其中 &lt;code&gt;App f a&lt;/code&gt; 和 &lt;code&gt;f a&lt;/code&gt; 在内存中表示相同），并使用&lt;a href=&quot;#extension-DerivingVia&quot;&gt; &lt;code&gt;DerivingVia&lt;/code&gt; &lt;/a&gt;显式启用此模式的使用：</target>
        </trans-unit>
        <trans-unit id="1b01ed5c6649677e3f37624bba9963e68fbbcb79" translate="yes" xml:space="preserve">
          <source>We can now catch a &lt;code&gt;MismatchedParentheses&lt;/code&gt; exception as &lt;code&gt;MismatchedParentheses&lt;/code&gt;, &lt;code&gt;SomeFrontendException&lt;/code&gt; or &lt;code&gt;SomeCompilerException&lt;/code&gt;, but not other types, e.g. &lt;code&gt;IOException&lt;/code&gt;:</source>
          <target state="translated">现在，我们可以将 &lt;code&gt;MismatchedParentheses&lt;/code&gt; 异常捕获为 &lt;code&gt;MismatchedParentheses&lt;/code&gt; ， &lt;code&gt;SomeFrontendException&lt;/code&gt; 或 &lt;code&gt;SomeCompilerException&lt;/code&gt; ，但不能捕获其他类型，例如 &lt;code&gt;IOException&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8c00c1af4cb249b526b0a337c48983f4e7b424b" translate="yes" xml:space="preserve">
          <source>We can now inspect the history of evaluation steps:</source>
          <target state="translated">我们现在可以检查评估步骤的历史。</target>
        </trans-unit>
        <trans-unit id="a7912bd1416a6837d9fa5e26fca0fe44eeb19351" translate="yes" xml:space="preserve">
          <source>We can pass simple expressions to EvalStmt, consisting of values and application. This allows us to wrap the statement to be executed in another function, which is used by GHCi to implement :set args and :set prog. It might be worthwhile to extend this little language in the future.</source>
          <target state="translated">我们可以向EvalStmt传递简单的表达式,由值和应用组成。这使得我们可以将语句包装到另一个函数中执行,GHCi用它来实现:set args和:set prog。将来可能值得对这个小语言进行扩展。</target>
        </trans-unit>
        <trans-unit id="183a3587dfb7920efd5e1a4cc461e7be30ed0dd2" translate="yes" xml:space="preserve">
          <source>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</source>
          <target state="translated">我们可以通过从类声明中删除空成员来避开这个特殊问题。然而,虽然剩下的成员,插入和成员,没有模棱两可的类型,但当我们尝试使用它们时,仍然会遇到问题。例如,考虑以下两个函数。</target>
        </trans-unit>
        <trans-unit id="c18fae3a664786d2f5921a461ad4addabedf0e5b" translate="yes" xml:space="preserve">
          <source>We can simplify the writing of &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; instances using monadic combinators:</source>
          <target state="translated">我们可以使用单子组合器简化 &lt;code&gt;&lt;a href=&quot;data-binary#v:get&quot;&gt;get&lt;/a&gt;&lt;/code&gt; 实例的编写：</target>
        </trans-unit>
        <trans-unit id="d5bd84c51422d4a14cd362b46283c89cd3c1da6b" translate="yes" xml:space="preserve">
          <source>We can supply the extra input required by commands built with the last two by applying them to ordinary expressions, as in</source>
          <target state="translated">我们可以通过将后两个命令应用于普通表达式,来提供它们所需的额外输入,如在</target>
        </trans-unit>
        <trans-unit id="7790e7c5277fb5ba71b2c08e17c443fb508ca879" translate="yes" xml:space="preserve">
          <source>We can then use &lt;code&gt;HeadC&lt;/code&gt; in both expression and pattern contexts. In a pattern context it will match the head of any list with length at least one. In an expression context it will construct a singleton list.</source>
          <target state="translated">然后我们可以使用 &lt;code&gt;HeadC&lt;/code&gt; 在表达和图案背景。在模式上下文中，它将匹配长度至少为一个的任何列表的头部。在表达式上下文中，它将构造一个单例列表。</target>
        </trans-unit>
        <trans-unit id="b415212c014ea0fcc281b456f186980a0ca3cc80" translate="yes" xml:space="preserve">
          <source>We can thus distinguish the type &lt;code&gt;P&lt;/code&gt; (which has a constructor &lt;code&gt;MkP&lt;/code&gt;) from the promoted data constructor &lt;code&gt;'P&lt;/code&gt; (of kind &lt;code&gt;Prom&lt;/code&gt;).</source>
          <target state="translated">因此，我们可以将类型 &lt;code&gt;P&lt;/code&gt; （具有构造函数 &lt;code&gt;MkP&lt;/code&gt; ）与提升的数据构造器 &lt;code&gt;'P&lt;/code&gt; （类型为 &lt;code&gt;Prom&lt;/code&gt; ）区分开来。</target>
        </trans-unit>
        <trans-unit id="7c213d93934a1e2d831f6660e414061f0c2d9d87" translate="yes" xml:space="preserve">
          <source>We can typecheck &lt;code&gt;A&lt;/code&gt; against this signature, or we can instantiate &lt;code&gt;Str&lt;/code&gt; with a module that provides the following declarations. Refer to Cabal&amp;rsquo;s documentation for a more in-depth discussion on how to instantiate signatures.</source>
          <target state="translated">我们可以对此签名进行类型检查 &lt;code&gt;A&lt;/code&gt; ，也可以使用提供以下声明的模块实例化 &lt;code&gt;Str&lt;/code&gt; 。有关如何实例化签名的更深入的讨论，请参考Cabal的文档。</target>
        </trans-unit>
        <trans-unit id="962ad3b3e4a229cc5ed476afe00f9dbc23ed54ea" translate="yes" xml:space="preserve">
          <source>We can use do-notation with types that are an instance of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, but not &lt;code&gt;Monad&lt;/code&gt;</source>
          <target state="translated">我们可以将do-notation与作为 &lt;code&gt;Applicative&lt;/code&gt; 和 &lt;code&gt;Functor&lt;/code&gt; 实例的类型一起使用，但不能用于 &lt;code&gt;Monad&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1316cac24a8121f893c44f812e970138fc3afa32" translate="yes" xml:space="preserve">
          <source>We can use it for example to prepend and/or append fixed values to an primitive.</source>
          <target state="translated">例如,我们可以使用它将固定值前置和/或追加到基元中。</target>
        </trans-unit>
        <trans-unit id="2059c45fd11e8690d6c4e13b96ba375eeaab04a6" translate="yes" xml:space="preserve">
          <source>We can use levity polymorphism to good effect with &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, whose types are given here:</source>
          <target state="translated">我们可以使用levity多态性来达到有 &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt; 的良好效果，其类型如下：</target>
        </trans-unit>
        <trans-unit id="8383f1aba14acad4a5f9a110e22c1d3c3245bd62" translate="yes" xml:space="preserve">
          <source>We can use the following functions to extract pieces.</source>
          <target state="translated">我们可以使用以下函数来提取碎片。</target>
        </trans-unit>
        <trans-unit id="db9784ff84edea883eaae11308c9b368f4fdfc76" translate="yes" xml:space="preserve">
          <source>We can use the profiler to collect stack traces when using GHCi (see &lt;a href=&quot;#ghci-stack-traces&quot;&gt;Stack Traces in GHCi&lt;/a&gt;).</source>
          <target state="translated">使用GHCi时，我们可以使用探查器来收集堆栈跟踪（请参阅GHCi中的&lt;a href=&quot;#ghci-stack-traces&quot;&gt;堆栈跟踪&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1eb2e3e74cc9a81f662b64cea38f9f0af332774b" translate="yes" xml:space="preserve">
          <source>We can use this to find the longest entry of a list:</source>
          <target state="translated">我们可以用它来寻找一个列表中最长的条目。</target>
        </trans-unit>
        <trans-unit id="571a67745023d8194d2db6b6211b599e037a7e5a" translate="yes" xml:space="preserve">
          <source>We can use this to find the shortest entry of a list:</source>
          <target state="translated">我们可以用它来寻找一个列表中最短的条目。</target>
        </trans-unit>
        <trans-unit id="f381f4d9c2ee9452187bc2d63e1896c154f0679e" translate="yes" xml:space="preserve">
          <source>We cannot define these functions in a module where they might be used (e.g., &lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;), because the magical wired-in type will get confused with what the typechecker figures out.</source>
          <target state="translated">我们无法在可能使用它们的模块中定义这些功能（例如&lt;a href=&quot;ghc-base&quot;&gt;GHC.Base&lt;/a&gt;），因为神奇的有线输入类型将与类型检查器弄清楚的内容混淆。</target>
        </trans-unit>
        <trans-unit id="eb0f870d06595902b343868b42028d552207bac6" translate="yes" xml:space="preserve">
          <source>We could define our own operator</source>
          <target state="translated">我们可以定义自己的运营商</target>
        </trans-unit>
        <trans-unit id="0a7f8355cb86bba1864ad75f7b2c3f6c7ca24357" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="translated">我们可以使用三个 &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; 来将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作提升到 &lt;code&gt;InterpM&lt;/code&gt; ，但是 &lt;code&gt;InterpM&lt;/code&gt; 自动是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt; 的实例，因此我们可以使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="552e222727964454376c689c5337b632f2f7ae47" translate="yes" xml:space="preserve">
          <source>We could lift &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; actions to &lt;code&gt;InterpM&lt;/code&gt; using three &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;s, but &lt;code&gt;InterpM&lt;/code&gt; is automatically an instance of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:MonadIO&quot;&gt;MonadIO&lt;/a&gt;&lt;/code&gt;, so we can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7594ab65e591e1f7cdb2f863210f655104b0f0a" translate="yes" xml:space="preserve">
          <source>We could not give &lt;code&gt;f0&lt;/code&gt; enough input to decode anything, so it returned an empty string. Once we feed our second continuation &lt;code&gt;f1&lt;/code&gt; the last byte of input, it will make progress.</source>
          <target state="translated">我们无法给 &lt;code&gt;f0&lt;/code&gt; 足够的输入来解码任何内容，因此它返回了一个空字符串。一旦我们在输入的最后一个字节中输入第二个延续 &lt;code&gt;f1&lt;/code&gt; ，它将取得进展。</target>
        </trans-unit>
        <trans-unit id="30d395b80b89dae6f0b1dfe707dc1dd3db5f2c33" translate="yes" xml:space="preserve">
          <source>We could simulate &lt;code&gt;if&lt;/code&gt; by defining</source>
          <target state="translated">我们可以模拟 &lt;code&gt;if&lt;/code&gt; 通过定义</target>
        </trans-unit>
        <trans-unit id="88145d1139ce025753cf32ad3ebd398f5e30f0d7" translate="yes" xml:space="preserve">
          <source>We could try applying &lt;code&gt;g&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. This won&amp;rsquo;t work though, as &lt;code&gt;g&lt;/code&gt; expects an argument of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Even worse, we can&amp;rsquo;t turn &lt;code&gt;x&lt;/code&gt; into something of type &lt;code&gt;a&lt;/code&gt;, since &lt;code&gt;f&lt;/code&gt; also needs an argument of type &lt;code&gt;a&lt;/code&gt;! In short, there&amp;rsquo;s no good way to make this work.</source>
          <target state="translated">我们可以尝试将 &lt;code&gt;g&lt;/code&gt; 应用于 &lt;code&gt;x&lt;/code&gt; 。但是，这将不起作用，因为 &lt;code&gt;g&lt;/code&gt; 需要一个类型为 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;x :: b&lt;/code&gt; 。更糟糕的是，我们不能将 &lt;code&gt;x&lt;/code&gt; 转换为类型 &lt;code&gt;a&lt;/code&gt; ，因为 &lt;code&gt;f&lt;/code&gt; 也需要类型 &lt;code&gt;a&lt;/code&gt; 的参数！简而言之，没有好的方法可以使这项工作。</target>
        </trans-unit>
        <trans-unit id="b78e79e9cebc29339a24122d72bf15b41a0e6358" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">我们创建两个类型为 &lt;code&gt;&lt;a href=&quot;data-either#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值，一个使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数，另一个使用 &lt;code&gt;&lt;a href=&quot;data-either#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数。然后，我们应用 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 函数（如果有 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）或&amp;ldquo; times-two&amp;rdquo;函数（如果有 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）&amp;ldquo;要么&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="acdd431f6357c3729418bd46bd62b31425e9ed68" translate="yes" xml:space="preserve">
          <source>We create two values of type &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, one using the &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; constructor and another using the &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; constructor. Then we apply &quot;either&quot; the &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; function (if we have a &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;) or the &quot;times-two&quot; function (if we have an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">我们创建两个类型为 &lt;code&gt;&lt;a href=&quot;prelude#t:Either&quot;&gt;Either&lt;/a&gt; &lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt; &lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 值，一个使用 &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; 构造函数，另一个使用 &lt;code&gt;&lt;a href=&quot;prelude#v:Right&quot;&gt;Right&lt;/a&gt;&lt;/code&gt; 构造函数。然后，我们应用 &lt;code&gt;&lt;a href=&quot;prelude#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 函数（如果有 &lt;code&gt;&lt;a href=&quot;prelude#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; ）或&amp;ldquo; times-two&amp;rdquo;函数（如果有 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; ）&amp;ldquo;要么&amp;rdquo; ：</target>
        </trans-unit>
        <trans-unit id="872adf42a857495035f7402099a48180fad06405" translate="yes" xml:space="preserve">
          <source>We demonstrate our UTF-8 CSV encoding function on the following table.</source>
          <target state="translated">我们在下表中演示我们的UTF-8 CSV编码功能。</target>
        </trans-unit>
        <trans-unit id="953b1d254c2334f50b6823d0ecdbd80d0194eee3" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;lsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="translated">我们没有得到 &lt;code&gt;C&lt;/code&gt; 的编译版本！发生了什么？嗯，在GHCi中，一个已编译的模块可能仅依赖于其他已编译的模块，在这种情况下， &lt;code&gt;C&lt;/code&gt; 依赖于 &lt;code&gt;D&lt;/code&gt; ，后者没有目标文件，因此GHCi也拒绝了 &lt;code&gt;C&lt;/code&gt; 的目标文件。好的，让我们也编译 &lt;code&gt;D&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3b8a8e128dde8f3cc09d2617fe4a012e9ad66250" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t get the compiled version of &lt;code&gt;C&lt;/code&gt;! What happened? Well, in GHCi a compiled module may only depend on other compiled modules, and in this case &lt;code&gt;C&lt;/code&gt; depends on &lt;code&gt;D&lt;/code&gt;, which doesn&amp;rsquo;t have an object file, so GHCi also rejected &lt;code&gt;C&lt;/code&gt;&amp;rsquo;s object file. Ok, so let&amp;rsquo;s also compile &lt;code&gt;D&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bd04af4ad4fdf69f006447ba60f1c3e65c62b6" translate="yes" xml:space="preserve">
          <source>We distinguish three kinds of wildcards.</source>
          <target state="translated">我们区分三种通配符。</target>
        </trans-unit>
        <trans-unit id="cf8979a2d9c164c587d8e4dc4e5509249cbdf0f4" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the argument of &lt;code&gt;E3&lt;/code&gt; because &lt;code&gt;a&lt;/code&gt; is not universally polymorphic. The &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;E3&lt;/code&gt; is (implicitly) existentially quantified, so it is not the same as the last type parameter of &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">我们不会忽略 &lt;code&gt;E3&lt;/code&gt; 的论点，因为 &lt;code&gt;a&lt;/code&gt; 并不是普遍多态的。在 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;E3&lt;/code&gt; （隐含）存在性量化的，所以它是不一样的最后一个类型参数 &lt;code&gt;E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a164bb70c45021b2d0872cd4b8c7acc02624d024" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t fold over the arguments of &lt;code&gt;E1&lt;/code&gt; or &lt;code&gt;E4&lt;/code&gt; because even though &lt;code&gt;(a ~ Int)&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt; is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">我们不会忽略 &lt;code&gt;E1&lt;/code&gt; 或 &lt;code&gt;E4&lt;/code&gt; 的参数，因为即使 &lt;code&gt;(a ~ Int)&lt;/code&gt; ， &lt;code&gt;Int&lt;/code&gt; 在语法上也不等效于 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab798ba88a4ca0a4d0cbf31feb27163ceef28cf8" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend building packages the hard way. Instead, use the &lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt; infrastructure if possible. If your package is particularly complicated or requires a lot of configuration, then you might have to fall back to the low-level mechanisms, so a few hints for those brave souls follow.</source>
          <target state="translated">我们不建议用困难的方式构建软件包。相反，请尽可能使用&lt;a href=&quot;http://www.haskell.org/cabal/users-guide/&quot;&gt;Cabal&lt;/a&gt;基础架构。如果您的程序包特别复杂或需要大量配置，那么您可能不得不退回到低级机制，因此以下是那些勇敢者的一些提示。</target>
        </trans-unit>
        <trans-unit id="bc2113e91a9e6010ff8cf726465f0e888d7a9a27" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t use a &lt;code&gt;-O*&lt;/code&gt; flag for day-to-day work. We use &lt;code&gt;-O&lt;/code&gt; to get respectable speed; e.g., when we want to measure something. When we want to go for broke, we tend to use &lt;code&gt;-O2&lt;/code&gt; (and we go for lots of coffee breaks).</source>
          <target state="translated">我们在日常工作中不使用 &lt;code&gt;-O*&lt;/code&gt; 标志。我们使用 &lt;code&gt;-O&lt;/code&gt; 来获得可观的速度；例如，当我们想要测量某物时。当我们想休息时，我们倾向于使用 &lt;code&gt;-O2&lt;/code&gt; （并且我们会大量喝咖啡休息时间）。</target>
        </trans-unit>
        <trans-unit id="2d08599ef2845ec4c18886d2e05cb517fe66bac5" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level numbers, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们要么得到证据证明该函数已使用相同的类型级别数字实例化，要么得到 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d254f10f035de6db1e618d7d7ad498a649421081" translate="yes" xml:space="preserve">
          <source>We either get evidence that this function was instantiated with the same type-level symbols, or &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们要么得到证据，要么使用相同的类型级别符号或 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 实例化了此函数。</target>
        </trans-unit>
        <trans-unit id="e1eab0389773836a826bac9246539026d3ebc063" translate="yes" xml:space="preserve">
          <source>We evaluated only the &lt;code&gt;_t1&lt;/code&gt; thunk, revealing the head of the list, and the tail is another thunk now bound to &lt;code&gt;_t2&lt;/code&gt;. The &lt;code&gt;seq&lt;/code&gt; function is a little inconvenient to use here, so you might want to use &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; to make a nicer interface (left as an exercise for the reader!).</source>
          <target state="translated">我们只评估了 &lt;code&gt;_t1&lt;/code&gt; 实体，显示了列表的开头，而尾部是另一个绑定到 &lt;code&gt;_t2&lt;/code&gt; 的实体。该 &lt;code&gt;seq&lt;/code&gt; 的功能是有点不方便在这里使用，所以你可能需要使用&lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt;（！作为练习留给读者）做出更好的接口。</target>
        </trans-unit>
        <trans-unit id="13dd6433b391a3acfa1f23e4695a261b1c01ce9e" translate="yes" xml:space="preserve">
          <source>We find out the current capability number and pass it to C. This is passed back to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and helps the RTS to know which capability it should try to perform the &lt;code&gt;tryPutMVar&lt;/code&gt; on. If you don&amp;rsquo;t care, you can pass &lt;code&gt;-1&lt;/code&gt; for the capability to &lt;code&gt;hs_try_putmvar&lt;/code&gt;, and it will pick an arbitrary one.</source>
          <target state="translated">我们找出当前功能编号并将其传递给C。这将传递回 &lt;code&gt;hs_try_putmvar&lt;/code&gt; ，并帮助RTS知道应该尝试对 &lt;code&gt;tryPutMVar&lt;/code&gt; 进行操作的功能。如果您不在乎，则可以将 &lt;code&gt;-1&lt;/code&gt; 作为功​​能传递给 &lt;code&gt;hs_try_putmvar&lt;/code&gt; ，它将选择任意一个。</target>
        </trans-unit>
        <trans-unit id="4cde7d17a1a927283996015f702fc3ec30ac59d9" translate="yes" xml:space="preserve">
          <source>We have &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt;, and &lt;code&gt;x :: b&lt;/code&gt;. Using these, we must somehow fill in the hole (denoted with an underscore) with a value of type &lt;code&gt;Int&lt;/code&gt;. What are our options?</source>
          <target state="translated">我们有 &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt; ， &lt;code&gt;g :: a -&amp;gt; Int&lt;/code&gt; 和 &lt;code&gt;x :: b&lt;/code&gt; 。使用这些，我们必须以某种方式用 &lt;code&gt;Int&lt;/code&gt; 类型的值填充孔（用下划线表示）。我们有什么选择？</target>
        </trans-unit>
        <trans-unit id="09dbbfe5180f316ca6dcabdf80e88644dd24f734" translate="yes" xml:space="preserve">
          <source>We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed. There is more background in &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;Secrets of the GHC inliner&lt;/a&gt;.</source>
          <target state="translated">除了人为设计的程序之外，我们再也没有找到其他可使GHC产生差异的程序，而解决该问题将在每次编译时带来额外的开销。因此，该错误仍未修复。&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/inlining/&quot;&gt;《 GHC内衬的秘密》&lt;/a&gt;还有更多背景知识。</target>
        </trans-unit>
        <trans-unit id="57baa188441448bf100848ab0c3a3c54936d2303" translate="yes" xml:space="preserve">
          <source>We infer these kinds:</source>
          <target state="translated">我们推断这些种类。</target>
        </trans-unit>
        <trans-unit id="069aec79fd852b144f1ab0e04e00d9fe20331d65" translate="yes" xml:space="preserve">
          <source>We internally represent the Cell inside a Table with an object of the type</source>
          <target state="translated">我们在内部用一个类型为</target>
        </trans-unit>
        <trans-unit id="5089f9acc0bbfad470ea9fc8ae47af4cd87aa22b" translate="yes" xml:space="preserve">
          <source>We mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="translated">我们用 &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; 事件标记新样本的开始，</target>
        </trans-unit>
        <trans-unit id="18dab782d675f36855bb63945664409f3d29f932" translate="yes" xml:space="preserve">
          <source>We may also need to signal an invalid character if we detect them when encoding a sequence of &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt;s into &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;s because the &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; mode creates these to round-trip bytes through our internal UTF-16 encoding.</source>
          <target state="translated">我们也需要，如果我们检测到它们的编码序列时信号无效字符 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; s转换 &lt;code&gt;&lt;a href=&quot;data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 是因为该 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding-failure#v:RoundtripFailure&quot;&gt;RoundtripFailure&lt;/a&gt;&lt;/code&gt; 模式创建这些对往返通过我们内部的UTF-16编码字节。</target>
        </trans-unit>
        <trans-unit id="0ec960543391474c6f77e98679f0051008de2792" translate="yes" xml:space="preserve">
          <source>We may change the syntax and semantics of this feature in the future.</source>
          <target state="translated">我们将来可能会改变这个功能的语法和语义。</target>
        </trans-unit>
        <trans-unit id="0b280e9e965a5ce2574a975e02721f8e9dd198f6" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;提供&lt;/a&gt; HEAD的快照版本供下载，而最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ebe98c6a2119e741bdf064584e3db025f6347d2" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the HEAD &lt;a href=&quot;http://www.haskell.org/ghc/dist/current/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627fed2246d090d6133a9e16548caedabebe413b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="translated">我们可能会&lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;提供&lt;/a&gt;当前稳定分支的快照版本供下载，最新的资源可从&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Repositories&quot;&gt;git存储库中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4fb296fd8e8ef0d2da857b55d5e427e6713096b" translate="yes" xml:space="preserve">
          <source>We may make snapshot releases of the current stable branch &lt;a href=&quot;http://www.haskell.org/ghc/dist/stable/dist/&quot;&gt;available for download&lt;/a&gt;, and the latest sources are available from &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/repositories&quot;&gt;the git repositories&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f8df20c6e6b47bd015211c44bf700bb364d39e" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fno-prof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082cfbff49aee1c63c6b424e58fe2b98b5f12765" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that lazy computations, i.e. thunks, capture the current stack when they are created, and restore this stack when they are evaluated. What about top-level thunks? They are &amp;ldquo;created&amp;rdquo; when the program is compiled, so what stack should we give them? The technical name for a top-level thunk is a CAF (&amp;ldquo;Constant Applicative Form&amp;rdquo;). GHC assigns every CAF in a module a stack consisting of the single cost centre &lt;code&gt;M.CAF&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; is the name of the module. It is also possible to give each CAF a different stack, using the option &lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt;&lt;code&gt;-fprof-cafs&lt;/code&gt;&lt;/a&gt;. This is especially useful when compiling with &lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt;&lt;code&gt;-ffull-laziness&lt;/code&gt;&lt;/a&gt; (as is default with &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; and higher), as constants in function bodies will be lifted to the top-level and become CAFs. You will probably need to consult the Core (&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;) in order to determine what these CAFs correspond to.</source>
          <target state="translated">前面我们提到过，惰性计算（即thunk）在创建当前堆栈时会捕获它们，并在对其进行评估时恢复该堆栈。那顶级的混蛋呢？它们是在程序编译时&amp;ldquo;创建&amp;rdquo;的，那么我们应该给它们什么堆栈？顶级thunk的技术名称是CAF（&amp;ldquo;常量申请表&amp;rdquo;）。 GHC为模块中的每个CAF分配一个由单个成本中心 &lt;code&gt;M.CAF&lt;/code&gt; 组成的堆栈，其中 &lt;code&gt;M&lt;/code&gt; 是模块的名称。也可以使用&lt;a href=&quot;#ghc-flag--fprof-cafs&quot;&gt; &lt;code&gt;-fprof-cafs&lt;/code&gt; &lt;/a&gt;选项为每个CAF提供不同的堆栈。当使用&lt;a href=&quot;using-optimisation#ghc-flag--ffull-laziness&quot;&gt; &lt;code&gt;-ffull-laziness&lt;/code&gt; 进行&lt;/a&gt;编译时（这是&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; 的&lt;/a&gt;默认设置，这尤其有用）以及更高版本），因为功能体内的常量将被提升到顶层并成为CAF。您可能需要咨询Core（&lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt;）以确定这些CAF对应什么。</target>
        </trans-unit>
        <trans-unit id="f89173fef21c2ae8f8a6534be41e16813ce12d43" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="translated">我们非常喜欢（B）。为什么？因为GHC可以确定 &lt;code&gt;(True :~: False)&lt;/code&gt; 是空类型。因此（B）没有偏见，GHC可以使用&lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt; &lt;code&gt;-Wincomplete-patterns&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt;进行编译。另一方面，（A）看起来很危险，GHC不会检查以确保实际上永远不会调用该函数。</target>
        </trans-unit>
        <trans-unit id="703530a9bd76b6d41cdef63f80ac7642abb989f8" translate="yes" xml:space="preserve">
          <source>We much prefer (B). Why? Because GHC can figure out that &lt;code&gt;(True :~: False)&lt;/code&gt; is an empty type. So (B) has no partiality and GHC is able to compile with &lt;a href=&quot;using-warnings#ghc-flag--Wincomplete-patterns&quot;&gt;&lt;code&gt;-Wincomplete-patterns&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt;. On the other hand (A) looks dangerous, and GHC doesn&amp;rsquo;t check to make sure that, in fact, the function can never get called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b18525b3456e672ccab92cf738f47ed84e0b770" translate="yes" xml:space="preserve">
          <source>We normally mark the beginning of a new sample with an &lt;code&gt;EVENT_HEAP_PROF_SAMPLE_BEGIN&lt;/code&gt; event,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3ba152883128893cbf6ffdf29a1fd6fe11e834" translate="yes" xml:space="preserve">
          <source>We now define class &lt;code&gt;Encode&lt;/code&gt; for the actual &lt;code&gt;encode&lt;/code&gt; function:</source>
          <target state="translated">现在，我们为实际的 &lt;code&gt;encode&lt;/code&gt; 功能定义 &lt;code&gt;Encode&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="1377e18111b86ccead4e0b186e1c1a556ed53fba" translate="yes" xml:space="preserve">
          <source>We now explain in more details the major modes of hpc.</source>
          <target state="translated">现在我们详细解释一下hpc的主要模式。</target>
        </trans-unit>
        <trans-unit id="35d4fb55ace34add811b7ad430f098cc0cd3b23d" translate="yes" xml:space="preserve">
          <source>We originally provided bindings for all variables in scope, rather than just the free variables of the expression, but found that this affected performance considerably, hence the current restriction to just the free variables.</source>
          <target state="translated">我们最初为作用域中的所有变量提供了绑定,而不是仅仅为表达式的自由变量提供绑定,但我们发现这大大影响了性能,因此目前只对自由变量进行了限制。</target>
        </trans-unit>
        <trans-unit id="4d27d12506ea61f7f54862326a16fa048ca62128" translate="yes" xml:space="preserve">
          <source>We pass references to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; to &lt;code&gt;hs_init()&lt;/code&gt; so that it can separate out any arguments for the RTS (i.e. those arguments between &lt;code&gt;+RTS...-RTS&lt;/code&gt;).</source>
          <target state="translated">我们 &lt;code&gt;hs_init()&lt;/code&gt; &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; 的引用传递给hs_init（），以便它可以分隔出RTS的任何参数（即 &lt;code&gt;+RTS...-RTS&lt;/code&gt; 之间的那些参数）。</target>
        </trans-unit>
        <trans-unit id="724d15d030dde64030cae6581a56f055b565b95a" translate="yes" xml:space="preserve">
          <source>We quit if the file is not found or reading somehow fails. (A convenience routine for haddock or possibly other clients)</source>
          <target state="translated">如果找不到文件或者读取失败,我们就退出。(对haddock或其他客户来说是一个方便的例程)</target>
        </trans-unit>
        <trans-unit id="d18c7f0650c4448b87f6b1933a38ca47b67ffa76" translate="yes" xml:space="preserve">
          <source>We recommend compiling any code that is intended to be run in parallel with the &lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt;&lt;code&gt;-feager-blackholing&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">我们建议编译旨在与&lt;a href=&quot;using-optimisation#ghc-flag--feager-blackholing&quot;&gt; &lt;code&gt;-feager-blackholing&lt;/code&gt; &lt;/a&gt;标志并行运行的任何代码。</target>
        </trans-unit>
        <trans-unit id="dd137eb9f9ef9f1a324bec16b4c37c93cef73a26" translate="yes" xml:space="preserve">
          <source>We recommend running GHCi in a standard Windows console: select the &lt;code&gt;GHCi&lt;/code&gt; option from the start menu item added by the GHC installer, or use &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; to get a Windows console and invoke &lt;code&gt;ghci&lt;/code&gt; from there (as long as it&amp;rsquo;s in your &lt;code&gt;PATH&lt;/code&gt;).</source>
          <target state="translated">我们建议在标准Windows控制台中运行GHCi：从GHC安装程序添加的开始菜单项中选择 &lt;code&gt;GHCi&lt;/code&gt; 选项，或使用 &lt;code&gt;Start-&amp;gt;Run-&amp;gt;cmd&lt;/code&gt; 获取Windows控制台并从那里调用 &lt;code&gt;ghci&lt;/code&gt; （只要它在您的 &lt;code&gt;PATH&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0cc790e21929b801027a2b0bf099d41ea4a4f5c7" translate="yes" xml:space="preserve">
          <source>We represent the branch as a list of &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;, so version 3.2.1 becomes [3,2,1]. Lexicographic ordering (i.e. the default instance of &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;[Int]&lt;/code&gt;) gives the natural ordering of branches.</source>
          <target state="translated">我们将分支表示为 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 的列表，因此版本3.2.1变为[3,2,1]。字典顺序（即的默认实例 &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;[Int]&lt;/code&gt; ）给出分支的自然顺序。</target>
        </trans-unit>
        <trans-unit id="89593894dcf2a0d71f7d1ad6ca489afd099ffae1" translate="yes" xml:space="preserve">
          <source>We reuse the keyword &lt;code&gt;default&lt;/code&gt; to signal that a signature applies to the default method only; when defining instances of the &lt;code&gt;Enum&lt;/code&gt; class, the original type &lt;code&gt;[a]&lt;/code&gt; of &lt;code&gt;enum&lt;/code&gt; still applies. When giving an empty instance, however, the default implementation &lt;code&gt;(map to genum)&lt;/code&gt; is filled-in, and type-checked with the type &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt;.</source>
          <target state="translated">我们重用关键字 &lt;code&gt;default&lt;/code&gt; 来表示签名仅适用于default方法；定义的情况下，当 &lt;code&gt;Enum&lt;/code&gt; 类，原始类型 &lt;code&gt;[a]&lt;/code&gt; 的 &lt;code&gt;enum&lt;/code&gt; 仍然适用。但是，当提供一个空实例时，将填充默认实现 &lt;code&gt;(map to genum)&lt;/code&gt; ，并使用类型 &lt;code&gt;(Generic a, GEnum (Rep a)) =&amp;gt; [a]&lt;/code&gt; 类型检查。</target>
        </trans-unit>
        <trans-unit id="6f9e3f88ef588eea2884342e308084935512f974" translate="yes" xml:space="preserve">
          <source>We rewrite consecutive uses of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; such that the bound-checks are fused. For example,</source>
          <target state="translated">我们重写 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primBounded&quot;&gt;primBounded&lt;/a&gt;&lt;/code&gt; 的连续用法，以使绑定检查融合在一起。例如，</target>
        </trans-unit>
        <trans-unit id="4fd7ec02dbb95e726ccd7b6229d42c6b16b30b10" translate="yes" xml:space="preserve">
          <source>We run the following mailing lists about GHC. We encourage you to join, as you feel is appropriate.</source>
          <target state="translated">我们运行以下关于GHC的邮件列表。我们鼓励你加入,如果你觉得合适的话。</target>
        </trans-unit>
        <trans-unit id="21cff9ed481d8fd83cf7c2afd03d533d1340b407" translate="yes" xml:space="preserve">
          <source>We say that the type variables in &lt;code&gt;f&lt;/code&gt; are &lt;em&gt;specified&lt;/em&gt;, while those in &lt;code&gt;g&lt;/code&gt; are &lt;em&gt;inferred&lt;/em&gt;. The general rule is this: if the user has written a type variable in the source program, it is &lt;em&gt;specified&lt;/em&gt;; if not, it is &lt;em&gt;inferred&lt;/em&gt;.</source>
          <target state="translated">我们说&lt;em&gt;指定&lt;/em&gt;了 &lt;code&gt;f&lt;/code&gt; 中的类型变量，而&lt;em&gt;推断&lt;/em&gt;了 &lt;code&gt;g&lt;/code&gt; 中的类型变量。一般规则是：如果用户在源程序中编写了类型变量，则将其&lt;em&gt;指定&lt;/em&gt;；如果不是，则&lt;em&gt;推断为&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1d876669543ac56e563fe5e0f4a71e0eb3b27cc" translate="yes" xml:space="preserve">
          <source>We set a breakpoint on &lt;code&gt;map&lt;/code&gt;, and call it.</source>
          <target state="translated">我们在 &lt;code&gt;map&lt;/code&gt; 上设置一个断点，并调用它。</target>
        </trans-unit>
        <trans-unit id="024423d139e42844141faa4bae40cb34e8a5e857" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use &lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt;&lt;code&gt;-fno-prof-count-entries&lt;/code&gt;&lt;/a&gt; when compiling a program to be profiled on multiple cores, because the entry counts are also stored in shared memory, and continuously updating them on multiple cores is extremely slow.</source>
          <target state="translated">强烈建议您在编译要在多个内核上进行概要分析的程序时使用&lt;a href=&quot;#ghc-flag--fno-prof-count-entries&quot;&gt; &lt;code&gt;-fno-prof-count-entries&lt;/code&gt; &lt;/a&gt;，因为条目计数也存储在共享内存中，并且在多个内核上连续更新它们的速度非常慢。</target>
        </trans-unit>
        <trans-unit id="d38883454548f1a00020fd8ec4a415f17e5632b2" translate="yes" xml:space="preserve">
          <source>We then compile the &lt;code&gt;Danger&lt;/code&gt; plugin using the new Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; flag:</source>
          <target state="translated">然后，我们使用新的Safe Haskell &lt;code&gt;-XSafe&lt;/code&gt; 标志编译 &lt;code&gt;Danger&lt;/code&gt; 插件：</target>
        </trans-unit>
        <trans-unit id="480a5fe002071f5d9a996045885005b615d7bf0d" translate="yes" xml:space="preserve">
          <source>We to extend &lt;code&gt;class&lt;/code&gt; (warning: this is a rather confusingly named non-terminal symbol) with two extra forms, namely precisely what can appear in an instance declaration</source>
          <target state="translated">我们用两种额外的形式扩展 &lt;code&gt;class&lt;/code&gt; （警告：这是一个相当混乱的命名非终端符号），即恰好可以出现在实例声明中的形式</target>
        </trans-unit>
        <trans-unit id="47d397e8df6bede4d54c1099104c6d4fbbb85e92" translate="yes" xml:space="preserve">
          <source>We use default signatures to simplify generic programming in GHC (&lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;).</source>
          <target state="translated">我们使用默认签名来简化GHC（&lt;a href=&quot;#generic-programming&quot;&gt;通用编程&lt;/a&gt;）中的通用编程。</target>
        </trans-unit>
        <trans-unit id="125a5084123f7c5b39098e8dae224d6228f6152b" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;criterion&lt;/code&gt; library (&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;) to benchmark the efficiency of our encoding function on the following table.</source>
          <target state="translated">我们使用 &lt;code&gt;criterion&lt;/code&gt; 库（&lt;a href=&quot;http://hackage.haskell.org/package/criterion&quot;&gt;http://hackage.haskell.org/package/criterion&lt;/a&gt;）在下表中对我们的编码功能的效率进行基准测试。</target>
        </trans-unit>
        <trans-unit id="651493c4df9c22d796fc7f5135203d8ed9018b48" translate="yes" xml:space="preserve">
          <source>We use the continuation &lt;code&gt;f0&lt;/code&gt; to decode our second packet.</source>
          <target state="translated">我们使用延续 &lt;code&gt;f0&lt;/code&gt; 解码我们的第二个数据包。</target>
        </trans-unit>
        <trans-unit id="0b6335997171de81f090e2683152fed3460a0025" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="translated">我们使用以下导入并缩写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; 来简化阅读。</target>
        </trans-unit>
        <trans-unit id="f22709004a13a3fd94746ba6a021463ab6f37071" translate="yes" xml:space="preserve">
          <source>We use the following imports and abbreviate &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt; to simplify reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7512aaa70635b88b2af47a520c014d401727a75" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d rather you reported such behaviour as a bug, so that we can try to correct it.</source>
          <target state="translated">我们希望您将这种行为报告为错误，以便我们可以尝试纠正它。</target>
        </trans-unit>
        <trans-unit id="cc16631b4890edd93973a20a4f9c5e2d14d862c2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#if defined(__GLASGOW_HASKELL__)&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65acee36cf41a1b7912dd8dd307ffedf598be82e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve surrounded the GHC-specific bits with &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt;; the rest of the code should be portable across Haskell implementations that support the FFI standard.</source>
          <target state="translated">我们已经用 &lt;code&gt;#ifdef __GLASGOW_HASKELL__&lt;/code&gt; 包围了特定于GHC的位；其余代码应可在支持FFI标准的Haskell实现中移植。</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="5a793d25465a65272f23a30bedf1a841c6e93416" translate="yes" xml:space="preserve">
          <source>Weak pointers are particularly useful for caches and memo tables. To build a memo table, you build a data structure mapping from the function argument (the key) to its result (the value). When you apply the function to a new argument you first check whether the key/value pair is already in the memo table. The key point is that the memo table itself should not keep the key and value alive. So the table should contain a weak pointer to the key, not an ordinary pointer. The pointer to the value must not be weak, because the only reference to the value might indeed be from the memo table.</source>
          <target state="translated">弱指针对于缓存和备忘录表特别有用。要建立一个备忘表,你要建立一个从函数参数(键)到其结果(值)的数据结构映射。当你把函数应用到一个新的参数时,你首先要检查键/值对是否已经在备忘录表中。关键的一点是,备忘录表本身不应保持键和值的活力。所以表中应该包含一个指向键的弱指针,而不是一个普通的指针。指向值的指针不能是弱指针,因为对值的唯一引用可能确实来自备忘录表。</target>
        </trans-unit>
        <trans-unit id="faba8c00ffb62bd7028e9f0c9a30a924a7d52926" translate="yes" xml:space="preserve">
          <source>Weak pointers.</source>
          <target state="translated">弱的指针。</target>
        </trans-unit>
        <trans-unit id="2d19b42c89a1ffa7f94dcb2e215670bafea0f235" translate="yes" xml:space="preserve">
          <source>Weak references to ThreadIds</source>
          <target state="translated">弱化对ThreadIds的引用</target>
        </trans-unit>
        <trans-unit id="29bd6c9aa748ebb7965a1af0f607d43846c1eca6" translate="yes" xml:space="preserve">
          <source>Weak#</source>
          <target state="translated">Weak#</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="4738b6db466a17900cde0c392a366f81ee255686" translate="yes" xml:space="preserve">
          <source>Welcome to the GHC User&amp;rsquo;s Guide</source>
          <target state="translated">欢迎使用GHC用户指南</target>
        </trans-unit>
        <trans-unit id="9a43d24919845073d089f519130b6009f44f6465" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b948584445577633b2d886da1cecc0b987ad2b" translate="yes" xml:space="preserve">
          <source>What about recursive functions, and mutually recursive groups of functions? Where are the costs attributed? Well, although GHC does keep information about which groups of functions called each other recursively, this information isn&amp;rsquo;t displayed in the basic time and allocation profile, instead the call-graph is flattened into a tree as follows: a call to a function that occurs elsewhere on the current stack does not push another entry on the stack, instead the costs for this call are aggregated into the caller &lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">递归函数和相互递归的函数组呢？费用归于何处？好的，尽管GHC确实保留有关哪些函数组递归调用的信息，但是该信息不会显示在基本时间和分配配置文件中，而是将调用图按如下所示展平为树：如果发生在当前堆栈的其他位置，则不会将另一个条目压入堆栈，而是将此调用的费用汇总到调用方&lt;a href=&quot;#id6&quot; id=&quot;id3&quot;&gt;[2]中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f7463ff41252948f9a667ff3bc05fd6cfe9f627b" translate="yes" xml:space="preserve">
          <source>What about the ambiguity problems that we encountered with the original definition? The empty function still has type &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt;, but it is no longer necessary to regard that as an ambiguous type: Although the variable &lt;code&gt;e&lt;/code&gt; does not appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol, the dependency for class &lt;code&gt;Collects&lt;/code&gt; tells us that it is uniquely determined by &lt;code&gt;ce&lt;/code&gt;, which does appear on the right of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol. Hence the context in which empty is used can still give enough information to determine types for both &lt;code&gt;ce&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the &lt;code&gt;=&amp;gt;&lt;/code&gt; that is not uniquely determined (either directly or indirectly) by the variables on the right.</source>
          <target state="translated">我们在原始定义中遇到的歧义问题如何处理？空函数的类型仍然为 &lt;code&gt;Collects e ce =&amp;gt; ce&lt;/code&gt; ，但是不再需要将其视为模棱两可的类型：尽管变量 &lt;code&gt;e&lt;/code&gt; 不在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号的右侧，但是 &lt;code&gt;Collects&lt;/code&gt; 类的依赖项告诉我们它由 &lt;code&gt;ce&lt;/code&gt; 唯一确定，它确实出现在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号的右侧。因此，使用空的上下文仍然可以提供足够的信息来确定 &lt;code&gt;ce&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; 的类型，没有歧义。更一般地说，如果类型在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的左侧包含一个变量，而该变量不是由右侧的变量唯一地（直接或间接地）确定的，则只需将其视为模棱两可的。</target>
        </trans-unit>
        <trans-unit id="8c4b747f5f91cbc11d5f22a2bf7469fd4c91ae77" translate="yes" xml:space="preserve">
          <source>What actually happens is that GHCi typechecks the expression, and if it doesn&amp;rsquo;t have an &lt;code&gt;IO&lt;/code&gt; type, then it transforms it as follows: an expression &lt;code&gt;e&lt;/code&gt; turns into</source>
          <target state="translated">实际发生的是GHCi对表达式进行类型检查，如果它没有 &lt;code&gt;IO&lt;/code&gt; 类型，则将其转换为以下形式：表达式 &lt;code&gt;e&lt;/code&gt; 变为</target>
        </trans-unit>
        <trans-unit id="e9043cea2c18dd5a9e4e8750a0588455697b7ca7" translate="yes" xml:space="preserve">
          <source>What can we do with a value of type &lt;code&gt;Foo&lt;/code&gt;? In particular, what happens when we pattern-match on &lt;code&gt;MkFoo&lt;/code&gt;?</source>
          <target state="translated">使用 &lt;code&gt;Foo&lt;/code&gt; 类型的值可以做什么？特别是，当我们在 &lt;code&gt;MkFoo&lt;/code&gt; 上进行模式匹配时会发生什么？</target>
        </trans-unit>
        <trans-unit id="04d6fb868c328fab711283d4e71b610250d64e7f" translate="yes" xml:space="preserve">
          <source>What does it mean to &amp;ldquo;provide&amp;rdquo; an explicit type for x? You can do that by giving a type signature for x directly, using a pattern type signature (&lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;), thus:</source>
          <target state="translated">为x&amp;ldquo;提供&amp;rdquo;显式类型是什么意思？您可以通过使用模式类型签名（&lt;a href=&quot;#scoped-type-variables&quot;&gt;词法作用域类型变量&lt;/a&gt;）直接为x提供类型签名来实现，从而：</target>
        </trans-unit>
        <trans-unit id="65229e46e73bff9547a997f15a9069c14aa568e2" translate="yes" xml:space="preserve">
          <source>What does it mean to be Safe? That importing a module compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; shouldn&amp;rsquo;t change the meaning of code that compiles fine without importing the module. This is the Safe Haskell property known as &lt;em&gt;semantic consistency&lt;/em&gt;.</source>
          <target state="translated">安全是什么意思？导入使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的模块不应更改无需导入模块即可正常编译的代码的含义。这是Safe Haskell属性，称为&lt;em&gt;语义一致性&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="74897f429b64222556ce5fc87639db27ebbf457c" translate="yes" xml:space="preserve">
          <source>What exactly is considered to be a &amp;ldquo;complete user-supplied kind signature&amp;rdquo; for a type constructor? These are the forms:</source>
          <target state="translated">对于类型构造函数，什么才算是&amp;ldquo;完整的用户提供的种类签名&amp;rdquo;？这些是以下形式：</target>
        </trans-unit>
        <trans-unit id="08f17076308c21f263ea9532451d09d88621d62c" translate="yes" xml:space="preserve">
          <source>What has this to do with &lt;em&gt;existential&lt;/em&gt; quantification? Simply that &lt;code&gt;MkFoo&lt;/code&gt; has the (nearly) isomorphic type</source>
          <target state="translated">这与&lt;em&gt;存在&lt;/em&gt;量化有什么关系？简单地说， &lt;code&gt;MkFoo&lt;/code&gt; 具有（几乎）同构类型</target>
        </trans-unit>
        <trans-unit id="881be7a062d2217bf57522931583f797d11f6eff" translate="yes" xml:space="preserve">
          <source>What if we want to define generic classes that range over type constructors (such as &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;)?</source>
          <target state="translated">如果我们要定义范围超过类型构造函数的泛型类（例如 &lt;code&gt;&lt;a href=&quot;data-functor#v:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-traversable#v:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; ），该怎么办？</target>
        </trans-unit>
        <trans-unit id="52d850cf6e82ee71cba430d22124534321d40e28" translate="yes" xml:space="preserve">
          <source>What is the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;? One might say &lt;code&gt;forall k. Type -&amp;gt; k -&amp;gt; Type&lt;/code&gt;, but this isn&amp;rsquo;t quite right, since this would allow incorrect things like &lt;code&gt;ProxyKVis Bool Int&lt;/code&gt;, which should be rejected due to the fact that &lt;code&gt;Int&lt;/code&gt; is not of kind &lt;code&gt;Bool&lt;/code&gt;. The key observation is that the kind of the second argument &lt;em&gt;depend&lt;/em&gt; on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of &lt;code&gt;ProxyKVis&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6156ac418f74ed9ece766ec906a41817dd7888" translate="yes" xml:space="preserve">
          <source>What is this &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; in the result type? Clearly we don&amp;rsquo;t mean this:</source>
          <target state="translated">结果类型中的&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;是什么？显然，我们不是这个意思：</target>
        </trans-unit>
        <trans-unit id="9f3ffd4ecaba0a4fb7ec792f4dfaea484d5b2b16" translate="yes" xml:space="preserve">
          <source>What kind of splice it is</source>
          <target state="translated">它是什么类型的拼接</target>
        </trans-unit>
        <trans-unit id="9ab258d9d72836e598da4742fd3511500e02364b" translate="yes" xml:space="preserve">
          <source>What role should a given type parameter should have? GHC performs role inference to determine the correct role for every parameter. It starts with a few base facts: &lt;code&gt;(-&amp;gt;)&lt;/code&gt; has two representational parameters; &lt;code&gt;(~)&lt;/code&gt; has two nominal parameters; all type families&amp;rsquo; parameters are nominal; and all GADT-like parameters are nominal. Then, these facts are propagated to all places where these types are used. The default role for datatypes and synonyms is phantom; the default role for classes is nominal. Thus, for datatypes and synonyms, any parameters unused in the right-hand side (or used only in other types in phantom positions) will be phantom. Whenever a parameter is used in a representational position (that is, used as a type argument to a constructor whose corresponding variable is at role representational), we raise its role from phantom to representational. Similarly, when a parameter is used in a nominal position, its role is upgraded to nominal. We never downgrade a role from nominal to phantom or representational, or from representational to phantom. In this way, we infer the most-general role for each parameter.</source>
          <target state="translated">给定的类型参数应该扮演什么角色？ GHC执行角色推断，以确定每个参数的正确角色。它从一些基本事实开始： &lt;code&gt;(-&amp;gt;)&lt;/code&gt; 具有两个表示参数； &lt;code&gt;(~)&lt;/code&gt; 有两个标称参数；所有类型族的参数都是标称值；并且所有类似GADT的参数都是标称值。然后，将这些事实传播到使用这些类型的所有地方。数据类型和同义词的默认角色是幻影；类的默认角色是名义角色。因此，对于数据类型和同义词，任何在右侧未使用（或仅在幻像位置的其他类型中使用）的参数都是幻像。每当在代表位置使用参数时（即，将其用作相应变量位于代表角色的构造函数的类型参数时），我们会将其角色从幻像提升为代表角色。同样，在标称位置使用参数时，其作用会升级为标称。我们绝不会将角色从名义降级为幻像或表象，或从表象降级为幻象。这样，我们就可以推断出每个参数的最一般的作用。</target>
        </trans-unit>
        <trans-unit id="5e163d757026398a851a492e27beac64aa80af0b" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;lsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="translated">应该怎样 &lt;code&gt;Tricky&lt;/code&gt; 的角色是什么？乍一看，似乎 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 都应该代表角色，因为两者都在右侧使用，并且都不涉及类型族。但是，这将是错误的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="7201ad0e4b9c4fd0ef63e8c881a6df6e60416a86" translate="yes" xml:space="preserve">
          <source>What should &lt;code&gt;Tricky&lt;/code&gt;&amp;rsquo;s roles be? At first blush, it would seem that both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; should be at role representational, since both are used in the right-hand side and neither is involved in a type family. However, this would be wrong, as the following example shows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f319ebff2240395cf0b480e1f2c12f478863009f" translate="yes" xml:space="preserve">
          <source>What should GHCi do? Strictly speaking, the program is ambiguous. &lt;code&gt;show (reverse [])&lt;/code&gt; (which is what GHCi computes here) has type &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; and how that displays depends on the type &lt;code&gt;a&lt;/code&gt;. For example:</source>
          <target state="translated">GHCi应该怎么做？严格来说，程序是模棱两可的。 &lt;code&gt;show (reverse [])&lt;/code&gt; （这是GHCi在这里计算的）的类型为 &lt;code&gt;Show a =&amp;gt; String&lt;/code&gt; ，其显示方式取决于类型 &lt;code&gt;a&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="36df37661ec67327bae64a89f5fda20d13ff69fa" translate="yes" xml:space="preserve">
          <source>What should happen if there are multiple &lt;code&gt;COMPLETE&lt;/code&gt; sets that apply to a single set of patterns? Consider this example:</source>
          <target state="translated">如果将多个 &lt;code&gt;COMPLETE&lt;/code&gt; 集应用于单个模式集，应该怎么办？考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="648b00f4e347bf90a6a0fb0d972beb792cf753dc" translate="yes" xml:space="preserve">
          <source>What sort of heap profile are we collecting?</source>
          <target state="translated">我们收集的是什么样的堆资料?</target>
        </trans-unit>
        <trans-unit id="8126e143260b66c2fb583df8e9c347a06cdfbd9b" translate="yes" xml:space="preserve">
          <source>What the Haskell compiler proper produces depends on what backend code generator is used. See &lt;a href=&quot;codegens#code-generators&quot;&gt;GHC Backends&lt;/a&gt; for more details.</source>
          <target state="translated">Haskell编译器正确产生什么取决于所使用的后端代码生成器。有关更多详细信息，请参见&lt;a href=&quot;codegens#code-generators&quot;&gt;GHC后端&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="429c385bbd56293e7efc1f03bbf57fcd1117da26" translate="yes" xml:space="preserve">
          <source>What the user explicitly requests when deriving an instance.</source>
          <target state="translated">用户在派生一个实例时明确要求的内容。</target>
        </trans-unit>
        <trans-unit id="b19a3d9cbaa78a6c5a7484da4d4cd12504b118c0" translate="yes" xml:space="preserve">
          <source>What this allows us to do is to package heterogeneous values together with a bunch of functions that manipulate them, and then treat that collection of packages in a uniform manner. You can express quite a bit of object-oriented-like programming this way.</source>
          <target state="translated">这让我们可以做的是把异构的值和一堆操作它们的函数打包在一起,然后以统一的方式处理这个包的集合。你可以用这种方式来表达不少类似面向对象的编程。</target>
        </trans-unit>
        <trans-unit id="24853926c03c1e59ec849769b4f2d90053671dc4" translate="yes" xml:space="preserve">
          <source>What to do at the end.</source>
          <target state="translated">最后该怎么做。</target>
        </trans-unit>
        <trans-unit id="f7686a5c0ed176c27b8cd695136d1f7bed6c4a34" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m1&lt;/code&gt; but not &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">如何处理 &lt;code&gt;m1&lt;/code&gt; 中的键而不是 &lt;code&gt;m2&lt;/code&gt; 中的键</target>
        </trans-unit>
        <trans-unit id="c37ddb3fb337621682dafb8ac0d643b90e215e7c" translate="yes" xml:space="preserve">
          <source>What to do with keys in &lt;code&gt;m2&lt;/code&gt; but not &lt;code&gt;m1&lt;/code&gt;</source>
          <target state="translated">如何处理 &lt;code&gt;m2&lt;/code&gt; 中的键而不是 &lt;code&gt;m1&lt;/code&gt; 中的键</target>
        </trans-unit>
        <trans-unit id="efa2a8fb6db1cfa21819c5147e06d6aefeed8bd0" translate="yes" xml:space="preserve">
          <source>What to do with keys in both &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;m1&lt;/code&gt; 和 &lt;code&gt;m2&lt;/code&gt; 中的键怎么办</target>
        </trans-unit>
        <trans-unit id="73b2b6134413a32046831817687c29ff928ae2e4" translate="yes" xml:space="preserve">
          <source>What to do with options following non-options</source>
          <target state="translated">如何处理非选项后的选项</target>
        </trans-unit>
        <trans-unit id="996e10cf546cff543352df9ce3ef3c87c74174b2" translate="yes" xml:space="preserve">
          <source>What to do with text.</source>
          <target state="translated">该怎么处理文字。</target>
        </trans-unit>
        <trans-unit id="c658b7c4ea121db3dfee7cd15b4b8680dde66f0e" translate="yes" xml:space="preserve">
          <source>What we&amp;rsquo;ve shown should work with any &lt;code&gt;make&lt;/code&gt;.</source>
          <target state="translated">我们展示的内容可以与任何 &lt;code&gt;make&lt;/code&gt; 搭配使用。</target>
        </trans-unit>
        <trans-unit id="1d19139af1e36286bf84856578a8fdfb18aa2232" translate="yes" xml:space="preserve">
          <source>What's different is that we now use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; to refer to the parameter (and that parameter, which used to be &lt;code&gt;a&lt;/code&gt;), is not mentioned explicitly by name anywhere; and we use &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; to refer to a recursive use of &lt;code&gt;Tree a&lt;/code&gt;.</source>
          <target state="translated">不同之处在于，我们现在使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; 来引用参数（该参数以前 &lt;code&gt;a&lt;/code&gt; ），没有在任何地方按名称明确提及。并且我们使用 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; 来引用 &lt;code&gt;Tree a&lt;/code&gt; 的递归使用。</target>
        </trans-unit>
        <trans-unit id="9bb20323ff98b32b6715abf861bfc65712d9780e" translate="yes" xml:space="preserve">
          <source>Whatever work the target thread was doing when the exception was raised is not lost: the computation is suspended until required by another thread.</source>
          <target state="translated">无论目标线程在异常发生时正在做什么工作,都不会丢失:计算被暂停,直到另一个线程需要。</target>
        </trans-unit>
        <trans-unit id="25aaf639f200ab012209ed7c616b7427cf43a690" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8311b798f1a1d8eab7dbb5ae1a94d12113de6b90" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; is enabled, an ambiguous field must be exported as part of its datatype, rather than at the top level. For example, the following is legal:</source>
          <target state="translated">当&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;启用时，一个模糊的领域必须出口作为其数据类型的一部分，而不是在顶层。例如，以下内容合法：</target>
        </trans-unit>
        <trans-unit id="2d6fdf1d7d01ce1777950f2bd094b6b3a91b0824" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables can be explicily bound in associated data or type family instances in the same way (and with the same restrictions) as &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt; or &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;. For example, adapting the above, the following is accepted:</source>
          <target state="translated">当&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，类型和种类变量可以explicily在相关的数据或类型的家庭情况必然以同样的方式（和相同限制）的&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;或&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;。例如，采用以上所述，可以接受以下内容：</target>
        </trans-unit>
        <trans-unit id="dcb444e9dc2c42002165fa1d9f676b2862da1a0d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type and kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c5adf24a15bed78aec999f1b504402cb4c91e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type or kind variables used on the left hand side can be explicitly bound. For example:</source>
          <target state="translated">当&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，在左侧使用种类或类型的变量可以明确的约束。例如：</target>
        </trans-unit>
        <trans-unit id="9b1b787d1263816e3855c7cfe78d8c359b80a2c3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92680fcc9c9c1502de789f18babeedf32dc9462" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt;&lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt;&lt;/a&gt; is enabled, GHC prints &lt;code&gt;RuntimeRep&lt;/code&gt; type variables for levity-polymorphic types. Otherwise GHC will default these to &lt;code&gt;LiftedRep&lt;/code&gt;. For example,</source>
          <target state="translated">当&lt;a href=&quot;#ghc-flag--fprint-explicit-runtime-reps&quot;&gt; &lt;code&gt;-fprint-explicit-runtime-reps&lt;/code&gt; &lt;/a&gt;已启用，GHC打印 &lt;code&gt;RuntimeRep&lt;/code&gt; 类型变量轻浮，多态类型。否则，GHC将默认将它们设置为 &lt;code&gt;LiftedRep&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="eb26b4b9b42719afc5d58080892c87f4e9a4c151" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, explicitly quantified type variables may also be identified as unused. For instance:</source>
          <target state="translated">当&lt;a href=&quot;glasgow_exts#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;启用，明确量化类型变量也可以认定为闲置。例如：</target>
        </trans-unit>
        <trans-unit id="5071f001a427f312da8ff26b7cf483642333afbe" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt;&lt;code&gt;-fprint-explicit-foralls&lt;/code&gt;&lt;/a&gt; is enabled, inferred variables are printed in braces. Thus, the type of the data constructor &lt;code&gt;Proxy&lt;/code&gt; from the previous example would be &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt;. We can observe this behavior in a GHCi session:</source>
          <target state="translated">当&lt;a href=&quot;using#ghc-flag--fprint-explicit-foralls&quot;&gt; &lt;code&gt;-fprint-explicit-foralls&lt;/code&gt; &lt;/a&gt;启用，推断变量打印在括号中。因此，上一个示例中的数据构造函数 &lt;code&gt;Proxy&lt;/code&gt; 的类型将为 &lt;code&gt;forall {k} (a :: k). Proxy a&lt;/code&gt; 。我们可以在GHCi会话中观察到这种行为：</target>
        </trans-unit>
        <trans-unit id="e71fb29e10669e9f7c683566c4b79f1c652a9191" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="4aaaa0ba1a64c3d7d910545fc6c8b5e6446f7b2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="e300aa1722b3687399fefcf98ac7da8e8418a15c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="c0a743c0152059b012ce81ab66c44377dc65ef53" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="5200adccb49ebd80f56d109e8f140d348d18d90e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="afb5f089e5c2d608a63aa2fcae939b3d1365c1ae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="77eb1ded96e8103d67da6e7e333c6b643ba6f717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define your custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，您应仅使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="0fbea4a709338356d9545678b9086385aa33c2c3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，只应使用 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="2ea5acc1eb14546998962c68dd7615633f130bf3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="f8ae3c218cb71994ceee8db4e4426364cb320721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="84bed03b41daf9861ce15e18b2179df7ba9567d7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should typically use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; to define your custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 定义自定义合并函数。</target>
        </trans-unit>
        <trans-unit id="c16b147d6698ce86c3acb9ea6ba2a23828bfe33d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined at the call site. To prevent excessive inlining, you should generally only use &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; to define custom combining functions.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 有三个参数，它在调用点内联。为防止过多的内联，通常应仅使用 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。</target>
        </trans-unit>
        <trans-unit id="c0c6a3e9396c72a350b056e016544d412ca9915e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; is given three arguments, it is inlined to the call site. You should therefore use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; only to define custom combining functions. For example, you could define &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; as</source>
          <target state="translated">当为 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 提供三个参数时，它会内联到调用站点。因此，只应使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt;&lt;/code&gt; 定义自定义组合功能。例如，您可以将 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:unionWithKey&quot;&gt;unionWithKey&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;data-map-strict#v:differenceWithKey&quot;&gt;differenceWithKey&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:intersectionWithKey&quot;&gt;intersectionWithKey&lt;/a&gt;&lt;/code&gt; 定义为</target>
        </trans-unit>
        <trans-unit id="c95a23ce6c159080833a33679d516e40935c6b22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DeriveAnyClass&lt;/code&gt; is enabled, use &lt;code&gt;anyclass&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;DeriveAnyClass&lt;/code&gt; 启用，使用 &lt;code&gt;anyclass&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="810adc9e6879dd7fe2e935cca3b55e9f5f573f98" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; is enabled and we are deriving for a newtype, then use &lt;code&gt;newytype&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; 启用，我们获得了NEWTYPE，然后使用 &lt;code&gt;newytype&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7a40b1f4f80c4569fa2dd79e0cd542dd47e5e1d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n)</source>
          <target state="translated">当 &lt;code&gt;mappend x x = x&lt;/code&gt; ，应该首选此定义，因为它适用于O（1）而不是O（log n）</target>
        </trans-unit>
        <trans-unit id="385ace8105515b932625b88764546dcae18aded8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mappend x x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdb0ef566c72260bf01374c66eaf7ae3a0981fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in O(1) rather than O(log n).</source>
          <target state="translated">当 &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt; ，应该首选此定义，因为它适用于O（1）而不是O（log n）。</target>
        </trans-unit>
        <trans-unit id="01dfa1f0b575553478bb02cbc1f8d40024bd7518" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;x &amp;lt;&amp;gt; x = x&lt;/code&gt;, this definition should be preferred, because it works in \(\mathcal{O}(1)\) rather than \(\mathcal{O}(\log n)\).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcb20f53b723d99a47571b7a2a345b3dff15f37" translate="yes" xml:space="preserve">
          <source>When GHC can&amp;rsquo;t find an instance for a class, it displays a short list of some in the instances it knows about. With this flag it prints &lt;em&gt;all&lt;/em&gt; the instances it knows about.</source>
          <target state="translated">当GHC找不到类的实例时，它将在它知道的实例中显示一些实例的简短列表。使用此标志，它将打印它知道的&lt;em&gt;所有&lt;/em&gt;实例。</target>
        </trans-unit>
        <trans-unit id="9df585e948ef11cac947ef860782290360960880" translate="yes" xml:space="preserve">
          <source>When GHC compiles a module (say &lt;code&gt;M.hs&lt;/code&gt;) which uses &lt;code&gt;foreign export&lt;/code&gt; or &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt;, it generates a &lt;code&gt;M_stub.h&lt;/code&gt; for use by C programs.</source>
          <target state="translated">当GHC编译使用 &lt;code&gt;foreign export&lt;/code&gt; 或 &lt;code&gt;foreign import &quot;wrapper&quot;&lt;/code&gt; 的模块（例如 &lt;code&gt;M.hs&lt;/code&gt; ）时，它将生成 &lt;code&gt;M_stub.h&lt;/code&gt; 供C程序使用。</target>
        </trans-unit>
        <trans-unit id="76692dec9bf0eb7997a4a7c9fc41e4f36ba910c1" translate="yes" xml:space="preserve">
          <source>When GHC is build in unregisterised mode only the LLVM and C code generators will be available. The native code generator won&amp;rsquo;t be. LLVM usually offers a substantial performance benefit over the C backend in unregisterised mode.</source>
          <target state="translated">在未注册模式下构建GHC时，只有LLVM和C代码生成器可用。本机代码生成器不会。在未注册模式下，LLVM通常比C后端具有显着的性能优势。</target>
        </trans-unit>
        <trans-unit id="ff0c3ab52d530bef3e62cb537f1398aa36a4bd69" translate="yes" xml:space="preserve">
          <source>When GHC is used to compile C files, GHC adds package include paths and includes &lt;code&gt;ghcversion.h&lt;/code&gt; directly. The compiler will lookup the path for the &lt;code&gt;ghcversion.h&lt;/code&gt; file from the &lt;code&gt;rts&lt;/code&gt; package in the package database. In some cases, the compiler&amp;rsquo;s package database does not contain the &lt;code&gt;rts&lt;/code&gt; package, or one wants to specify a specific &lt;code&gt;ghcversions.h&lt;/code&gt; to be included. This option can be used to specify the path to the &lt;code&gt;ghcversions.h&lt;/code&gt; file to be included. This is primarily intended to be used by GHC&amp;rsquo;s build system.</source>
          <target state="translated">使用GHC编译C文件时，GHC会添加软件包include路径，并直接包含 &lt;code&gt;ghcversion.h&lt;/code&gt; 。编译器将从包数据库中的 &lt;code&gt;rts&lt;/code&gt; 包中查找 &lt;code&gt;ghcversion.h&lt;/code&gt; 文件的路径。在某些情况下，编译器的软件包数据库不包含 &lt;code&gt;rts&lt;/code&gt; 软件包，或者一个人希望指定要包含的特定 &lt;code&gt;ghcversions.h&lt;/code&gt; 。此选项可用于指定要包括的 &lt;code&gt;ghcversions.h&lt;/code&gt; 文件的路径。这主要是供GHC的构建系统使用。</target>
        </trans-unit>
        <trans-unit id="d585b1370b15f8ee9670ddedfc5ca8f06657ee3c" translate="yes" xml:space="preserve">
          <source>When GHC tries to resolve, say, the constraint &lt;code&gt;C Int Bool&lt;/code&gt;, it tries to match every instance declaration against the constraint, by instantiating the head of the instance declaration. Consider these declarations:</source>
          <target state="translated">当GHC尝试解析约束 &lt;code&gt;C Int Bool&lt;/code&gt; 时，它将通过实例化实例声明的头部来尝试将每个实例声明与该约束进行匹配。考虑以下声明：</target>
        </trans-unit>
        <trans-unit id="7ba40cd30499dab797dc8b69a1a7edf73f98c55d" translate="yes" xml:space="preserve">
          <source>When GHCi is stopped at a breakpoint, and an expression entered at the prompt triggers a second breakpoint, the new breakpoint becomes the &amp;ldquo;current&amp;rdquo; one, and the old one is saved on a stack. An arbitrary number of breakpoint contexts can be built up in this way. For example:</source>
          <target state="translated">当GHCi在断点处停止时，在提示符下输入的表达式触发第二个断点，新的断点成为&amp;ldquo;当前&amp;rdquo;断点，旧的断点保存在堆栈中。通过这种方式可以建立任意数量的断点上下文。例如：</target>
        </trans-unit>
        <trans-unit id="e2807b4cdd5b573f0663b3f0063e179f71e8e348" translate="yes" xml:space="preserve">
          <source>When a GC starts, all the running mutator threads have to stop and synchronise. The period between when the GC is initiated and all the mutator threads are stopped is called the GC synchronisation phase. If this phase is taking a long time (longer than 1ms is considered long), then it can have a severe impact on overall throughput.</source>
          <target state="translated">当GC启动时,所有运行中的突变器线程都必须停止并同步。从GC启动到所有突变器线程停止的这段时间称为GC同步阶段。如果这个阶段耗时较长(超过1ms即为长),那么会严重影响整体的吞吐量。</target>
        </trans-unit>
        <trans-unit id="0f5e06bf8d13808c900903741d2829aeaa0e6a52" translate="yes" xml:space="preserve">
          <source>When a GHC-compiled program is run with the &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt; RTS option, it generates a file called &lt;code&gt;prog.prof&lt;/code&gt;. In this case, the file will contain something like this:</source>
          <target state="translated">当使用&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; RTS选项运行GHC编译的程序时，它将生成一个名为 &lt;code&gt;prog.prof&lt;/code&gt; 的文件。在这种情况下，文件将包含以下内容：</target>
        </trans-unit>
        <trans-unit id="96f4dfb4a41bd7deabd33d8f65708051f0ce3a05" translate="yes" xml:space="preserve">
          <source>When a bare type variable &lt;code&gt;a&lt;/code&gt; is encountered, both &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would generate &lt;code&gt;f a&lt;/code&gt; for an &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;traverse&lt;/code&gt; definition, respectively.</source>
          <target state="translated">当遇到裸类型变量 &lt;code&gt;a&lt;/code&gt; 时，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;都将分别为 &lt;code&gt;fmap&lt;/code&gt; 和 &lt;code&gt;traverse&lt;/code&gt; 定义生成 &lt;code&gt;f a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b37b1bde172716c6f89f77ec86e291afcf8b3f85" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn&amp;rsquo;t match others. The best advice is to avoid tab characters in your source code altogether (see &lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt;&lt;code&gt;-Wtabs&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">在特定的行和列上设置断点时，GHCi会选择包围该断点设置位置的最小子表达式。注意：GHC认为TAB字符的宽度为1，无论它在哪里出现；换句话说，它计算字符，而不是列。这与某些编辑器的功能匹配，而与其他编辑器的功能不匹配。最好的建议是完全避免在源代码中使用制表符（请参见&lt;a href=&quot;using-warnings#ghc-flag--Wtabs&quot;&gt; &lt;code&gt;-Wtabs&lt;/code&gt; &lt;/a&gt;在&lt;a href=&quot;using-warnings#options-sanity&quot;&gt;警告和健全检查&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="eba46e202d52d08c582d450dfdebfb463db929e0" translate="yes" xml:space="preserve">
          <source>When a breakpoint is set on a particular line, GHCi sets the breakpoint on the leftmost subexpression that begins and ends on that line. If two complete subexpressions start at the same column, the longest one is picked. If there is no complete subexpression on the line, then the leftmost expression starting on the line is picked, and failing that the rightmost expression that partially or completely covers the line.</source>
          <target state="translated">当在某一行设置断点时,GHCi将断点设置在该行开始和结束的最左边的子表达式上。如果两个完整的子表达式开始于同一列,则选取最长的一个。如果行上没有完整的子表达式,则选择行上开始的最左边的表达式,如果没有,则选择部分或完全覆盖该行的最右边的表达式。</target>
        </trans-unit>
        <trans-unit id="38d7ea66f715e79c474b0f49e7491b0182dafe13" translate="yes" xml:space="preserve">
          <source>When a datatype &lt;code&gt;T&lt;/code&gt; is imported with all constructors, i.e. &lt;code&gt;T(..)&lt;/code&gt;, but has been exported abstractly, i.e. &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">当数据类型 &lt;code&gt;T&lt;/code&gt; 是进口的所有构造函数，即 &lt;code&gt;T(..)&lt;/code&gt; ，但已被抽象出口，也就是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b214627eb1bf6190595cda2df15ea7905d289bf" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="translated">当调用基础POSIX函数的函数失败时，errno代码将转换为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt; 。有关可能生成的errno代码的列表，请查阅POSIX文档以获取基础功能。</target>
        </trans-unit>
        <trans-unit id="92c15677526f9dbb76cd2897100c19f8390621db" translate="yes" xml:space="preserve">
          <source>When a function that calls an underlying POSIX function fails, the errno code is converted to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-c-error#v:errnoToIOError&quot;&gt;errnoToIOError&lt;/a&gt;&lt;/code&gt;. For a list of which errno codes may be generated, consult the POSIX documentation for the underlying function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3345410ce590ab3d53507fb978e52331be72139e" translate="yes" xml:space="preserve">
          <source>When a hs-boot file &lt;code&gt;A.hs-boot&lt;/code&gt; is compiled, it is checked for scope and type errors. When its parent module &lt;code&gt;A.hs&lt;/code&gt; is compiled, the two are compared, and an error is reported if the two are inconsistent.</source>
          <target state="translated">当hs-boot文件 &lt;code&gt;A.hs-boot&lt;/code&gt; 编译 A.hs-boot时，将检查其范围和类型错误。编译其父模块 &lt;code&gt;A.hs&lt;/code&gt; 时，将对两者进行比较，如果两者不一致，则会报告错误。</target>
        </trans-unit>
        <trans-unit id="b60babd51ec0e1cbeb493e3de8aad4f1dffad035" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and maybe use the result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数,或许在合并后的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="7d10dbc1a05c360ecc51f395b9e6d97d4be5e8be" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values and use the result in the merged map.</source>
          <target state="translated">当在两个地图中找到一个键时,对键和值应用一个函数,并在合并后的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="10c4e809d393f089c060cbb9625043046bb6fc61" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values to produce an action and use its result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数来产生一个动作,并在合并后的地图中使用其结果。</target>
        </trans-unit>
        <trans-unit id="4fc1a67f9ad17df3885babe69bce2badc00cf5a1" translate="yes" xml:space="preserve">
          <source>When a key is found in both maps, apply a function to the key and values, perform the resulting action, and maybe use the result in the merged map.</source>
          <target state="translated">当在两个地图中都找到一个键时,对键和值应用一个函数,执行结果的操作,也许在合并的地图中使用结果。</target>
        </trans-unit>
        <trans-unit id="ba501a01a00f9af977ddc6bb583d3c63698fa694" translate="yes" xml:space="preserve">
          <source>When a module provided by the package currently being compiled (i.e. the &amp;ldquo;home&amp;rdquo; package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won&amp;rsquo;t pick up modules, not listed neither in &lt;code&gt;exposed-modules&lt;/code&gt;, nor in &lt;code&gt;other-modules&lt;/code&gt;.</source>
          <target state="translated">导入当前正在编译的程序包提供的模块（即&amp;ldquo; home&amp;rdquo;程序包）时，但未在命令行中明确列出作为目标。对于Cabal有用，以确保GHC不会拾取模块，该模块也未列出 &lt;code&gt;exposed-modules&lt;/code&gt; 或 &lt;code&gt;other-modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b957c6c9bc5322283d7901210c6040f297df256" translate="yes" xml:space="preserve">
          <source>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</source>
          <target state="translated">当在范围内找不到名称或包时,请为您可能想要的名称或包提出建议。</target>
        </trans-unit>
        <trans-unit id="b68d55a8267a7985c4cece8bc9cb1a362bb795e4" translate="yes" xml:space="preserve">
          <source>When a particular type-class method call is considered unsafe due to overlapping instances, and the module being compiled is using &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;, then compilation will fail. For &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt;, no restriction is applied, and for modules using safe inference, they will be inferred unsafe.</source>
          <target state="translated">如果由于实例重叠而导致特定类型类方法调用被认为不安全，并且正在编译的模块使用&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;，编译将失败。对于&lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;，不应用限制，对于使用安全推断的模块，它们将被推断为不安全。</target>
        </trans-unit>
        <trans-unit id="4cf54feb6ae37d749e194f1af0911ead0a3724c6" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its arguments directly.</source>
          <target state="translated">编译并执行程序时，可以使用 &lt;code&gt;getArgs&lt;/code&gt; 函数访问命令行参数。但是，在ghci中进行测试时，我们不能简单地将参数传递给 &lt;code&gt;main&lt;/code&gt; 函数，因为 &lt;code&gt;main&lt;/code&gt; 函数不会直接接受其参数。</target>
        </trans-unit>
        <trans-unit id="73957c2c06ff4614a64f17e8dd648a86f59dfb46" translate="yes" xml:space="preserve">
          <source>When a program is compiled and executed, it can use the &lt;code&gt;getArgs&lt;/code&gt; function to access the command-line arguments. However, we cannot simply pass the arguments to the &lt;code&gt;main&lt;/code&gt; function while we are testing in ghci, as the &lt;code&gt;main&lt;/code&gt; function doesn&amp;rsquo;t take its directly.</source>
          <target state="translated">编译并执行程序时，可以使用 &lt;code&gt;getArgs&lt;/code&gt; 函数访问命令行参数。但是，我们不能简单地将参数传递给 &lt;code&gt;main&lt;/code&gt; 在ghci中进行测试时 main函数，因为 &lt;code&gt;main&lt;/code&gt; 函数不会直接采用它。</target>
        </trans-unit>
        <trans-unit id="3e757a1c9ca7b7700984de1f023e16480dff961b" translate="yes" xml:space="preserve">
          <source>When a string is passed to this flag we report information about all functions whose name shares a prefix with the string.</source>
          <target state="translated">当一个字符串被传递到这个标志时,我们会报告所有名称与该字符串共享前缀的函数的信息。</target>
        </trans-unit>
        <trans-unit id="48fed1c1d278938955de4ee65cca0fe398075123" translate="yes" xml:space="preserve">
          <source>When a type has no constructors, the derived &lt;code&gt;Functor&lt;/code&gt; instance will simply force the (bottom) value of the argument using &lt;a href=&quot;#extension-EmptyCase&quot;&gt;&lt;code&gt;EmptyCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当类型没有构造函数时，派生的 &lt;code&gt;Functor&lt;/code&gt; 实例将使用&lt;a href=&quot;#extension-EmptyCase&quot;&gt; &lt;code&gt;EmptyCase&lt;/code&gt; 强制&lt;/a&gt;使用参数的（底部）值。</target>
        </trans-unit>
        <trans-unit id="86c6d1d4440535b0cc244bc190cd58bbd3c60032" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;foldr&lt;/code&gt; and &lt;code&gt;foldMap&lt;/code&gt;. Depending on the context, &lt;code&gt;null&lt;/code&gt; may recursively call &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;all null&lt;/code&gt;. For example, given</source>
          <target state="translated">当一个类型，在语法上不等同于 &lt;code&gt;a&lt;/code&gt; ，但确实包含 &lt;code&gt;a&lt;/code&gt; ，当遇到，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;递归调用 &lt;code&gt;fmap&lt;/code&gt; 就可以了。同样，&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;将递归调用 &lt;code&gt;foldr&lt;/code&gt; 和 &lt;code&gt;foldMap&lt;/code&gt; 。根据上下文， &lt;code&gt;null&lt;/code&gt; 可以递归调用 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;all null&lt;/code&gt; 。例如，给定</target>
        </trans-unit>
        <trans-unit id="47ab185242c69810df7e9e7bb246e6539cb4ac11" translate="yes" xml:space="preserve">
          <source>When a type that is not syntactically equivalent to &lt;code&gt;a&lt;/code&gt;, but which does contain &lt;code&gt;a&lt;/code&gt;, is encountered, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; recursively calls &lt;code&gt;fmap&lt;/code&gt; on it. Similarly, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; would recursively call &lt;code&gt;traverse&lt;/code&gt;.</source>
          <target state="translated">当一个类型，在语法上不等同于 &lt;code&gt;a&lt;/code&gt; ，但确实包含 &lt;code&gt;a&lt;/code&gt; ，当遇到，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;递归调用 &lt;code&gt;fmap&lt;/code&gt; 就可以了。同样，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;将递归调用 &lt;code&gt;traverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aa1e8c76778db15803b3222607ae8b483ac8569" translate="yes" xml:space="preserve">
          <source>When a type-level explicit &lt;code&gt;forall&lt;/code&gt; is present, each type/kind variable mentioned must now also be either in scope or bound by the &lt;code&gt;forall&lt;/code&gt;. In particular, unlike some other places in Haskell, this means free kind variables will not be implicitly bound. For example:</source>
          <target state="translated">当存在类型级别的显式 &lt;code&gt;forall&lt;/code&gt; 时，现在提到的每个类型/种类变量也必须在范围内或受 &lt;code&gt;forall&lt;/code&gt; 约束。特别是，与Haskell中的其他地方不同，这意味着自由种类变量不会被隐式绑定。例如：</target>
        </trans-unit>
        <trans-unit id="98c1a1575839b76280712d8d3cbfabdfaec7ae87" translate="yes" xml:space="preserve">
          <source>When a value is bound in &lt;code&gt;do&lt;/code&gt;-notation, the pattern on the left hand side of &lt;code&gt;&amp;lt;-&lt;/code&gt; might not match. In this case, this class provides a function to recover.</source>
          <target state="translated">当值必然会 &lt;code&gt;do&lt;/code&gt; -notation上的左侧的模式 &lt;code&gt;&amp;lt;-&lt;/code&gt; 可能不匹配。在这种情况下，此类提供了恢复功能。</target>
        </trans-unit>
        <trans-unit id="530df58f24e82ee26642343d604d01689238cec4" translate="yes" xml:space="preserve">
          <source>When a warning is emitted, the specific warning flag which controls it is shown.</source>
          <target state="translated">当发出警告时,会显示控制它的特定警告标志。</target>
        </trans-unit>
        <trans-unit id="f3e35bcef57873d7655672b83d21c857743ea583" translate="yes" xml:space="preserve">
          <source>When a wildcard is not instantiated to a monotype, it will be generalised over, i.e. replaced by a fresh type variable, e.g.</source>
          <target state="translated">当一个通配符没有实例化到一个单字型时,它将被泛化,即被一个新的类型变量所取代,例如。</target>
        </trans-unit>
        <trans-unit id="9a3de05e81fe6f8c73b2542e840f3f3184dab4e0" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;import&lt;/code&gt; statement hides an entity that is not exported.</source>
          <target state="translated">当 &lt;code&gt;import&lt;/code&gt; 语句隐藏未导出的实体时。</target>
        </trans-unit>
        <trans-unit id="08ddc8a3993c4523b898a35d23d51eabdca2c820" translate="yes" xml:space="preserve">
          <source>When an associated data or type synonym family instance is declared within a type class instance, we (optionally) may drop the &lt;code&gt;instance&lt;/code&gt; keyword in the family instance:</source>
          <target state="translated">当在类型类实例中声明关联的数据或类型同义词家族实例时，我们（可选）可以将 &lt;code&gt;instance&lt;/code&gt; 关键字放在家族实例中：</target>
        </trans-unit>
        <trans-unit id="fd02e0a0c82f3b9df6a57e7ef64b765a20a8b2d7" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">当异常传播到主程序之外时，Haskell系统将打印关联的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值并退出程序。</target>
        </trans-unit>
        <trans-unit id="326b603f495fea8090c289e5838605d4860b434d" translate="yes" xml:space="preserve">
          <source>When an exception propagates outside the main program, the Haskell system prints the associated &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; value and exits the program.</source>
          <target state="translated">当异常传播到主程序之外时，Haskell系统将打印关联的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 值并退出程序。</target>
        </trans-unit>
        <trans-unit id="93856eacf2fadc4b6b312933a4b87e29fb2a120e" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, &lt;em&gt;all&lt;/em&gt; type and kind variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe070e3196fc51a59549de90027a25c6914f20d" translate="yes" xml:space="preserve">
          <source>When an explicit &lt;code&gt;forall&lt;/code&gt; is present, all &lt;em&gt;type&lt;/em&gt; variables mentioned which are not already in scope must be bound by the &lt;code&gt;forall&lt;/code&gt;. Kind variables will be implicitly bound if necessary, for example:</source>
          <target state="translated">当存在显式的 &lt;code&gt;forall&lt;/code&gt; 时，提到的所有不在范围内的&lt;em&gt;类型&lt;/em&gt;变量必须由 &lt;code&gt;forall&lt;/code&gt; 绑定。如有必要，种类变量将被隐式绑定，例如：</target>
        </trans-unit>
        <trans-unit id="893b9d6c8a2ec1fbfa6e7548e532eec5df7ea955" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the bitwise operation defined by the type class implement the same function as the corresponding bitwise operation in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;CT&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 实例时，由类型类定义的按位运算实现与C on &lt;code&gt;t&lt;/code&gt; 上相应的按位运算相同的功能。</target>
        </trans-unit>
        <trans-unit id="ac0b7c07133d51f8a0c53969a0d48153abf09af4" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; coincide with &lt;code&gt;t_MIN&lt;/code&gt; and &lt;code&gt;t_MAX&lt;/code&gt; in C.</source>
          <target state="translated">当的实例 &lt;code&gt;&lt;a href=&quot;prelude#v:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; 被定义为 &lt;code&gt;CT&lt;/code&gt; ，的值 &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt; 与重合 &lt;code&gt;t_MIN&lt;/code&gt; 和 &lt;code&gt;t_MAX&lt;/code&gt; 中C.</target>
        </trans-unit>
        <trans-unit id="eba43007f1f46687358334420016ae0af8954322" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the predicates defined by the type class implement the same relation as the corresponding predicate in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">当为 &lt;code&gt;CT&lt;/code&gt; 定义 &lt;code&gt;&lt;a href=&quot;prelude#v:Eq&quot;&gt;Eq&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; 的实例时，由类型类定义的谓词实现与C on &lt;code&gt;t&lt;/code&gt; 上的相应谓词相同的关系。</target>
        </trans-unit>
        <trans-unit id="7b3e112f934927c22c80f4ae8df92b2423f16258" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; is defined for &lt;code&gt;CT&lt;/code&gt;, the arithmetic operations defined by the type class implement the same function as the corresponding arithmetic operations (if available) in C on &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">如果为 &lt;code&gt;CT&lt;/code&gt; 定义了 &lt;code&gt;&lt;a href=&quot;prelude#v:Num&quot;&gt;Num&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Integral&quot;&gt;Integral&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Fractional&quot;&gt;Fractional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:Floating&quot;&gt;Floating&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:RealFrac&quot;&gt;RealFrac&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;prelude#v:RealFloat&quot;&gt;RealFloat&lt;/a&gt;&lt;/code&gt; 的实例，则由类型类定义的算术运算将实现与C on &lt;code&gt;t&lt;/code&gt; 上相应的算术运算（如果可用）相同的功能。</target>
        </trans-unit>
        <trans-unit id="66030848096bb3453032ff11924105f8253ad338" translate="yes" xml:space="preserve">
          <source>When applicable, it is almost always better to use &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; instead of this function, although it can be a little worse in certain pathological cases. For example, to nub a list of characters, use</source>
          <target state="translated">如果适用，使用 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubInt&quot;&gt;nubInt&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;data-containers-listutils#v:nubIntOn&quot;&gt;nubIntOn&lt;/a&gt;&lt;/code&gt; 代替此函数几乎总是更好，尽管在某些病理情况下可能会更糟。例如，要微调字符列表，请使用</target>
        </trans-unit>
        <trans-unit id="bef1bc7a1c9575bcf83581250468b4f5edbd2f84" translate="yes" xml:space="preserve">
          <source>When asked to compile a source file, GHC normally generates two files: an object file, and an interface file.</source>
          <target state="translated">当要求编译一个源文件时,GHC通常会生成两个文件:一个对象文件,一个接口文件。</target>
        </trans-unit>
        <trans-unit id="94c5ca33ed1d63d356c6ce1bd3d2050ad9b2dca0" translate="yes" xml:space="preserve">
          <source>When asked to modify a database, &lt;code&gt;ghc-pkg&lt;/code&gt; modifies the global database by default. Specifying &lt;code&gt;--user&lt;/code&gt; causes it to act on the user database, or &lt;code&gt;--package-db&lt;/code&gt; can be used to act on another database entirely. When multiple of these options are given, the rightmost one is used as the database to act upon.</source>
          <target state="translated">当要求修改数据库时， &lt;code&gt;ghc-pkg&lt;/code&gt; 默认会修改全局数据库。指定 &lt;code&gt;--user&lt;/code&gt; 使其作用于用户数据库，或者 &lt;code&gt;--package-db&lt;/code&gt; 可用于完全作用于另一个数据库。当给出多个这些选项时，最右边的一个将用作操作的数据库。</target>
        </trans-unit>
        <trans-unit id="b354c0cb7594650a98ff86480dc8487aeef268a5" translate="yes" xml:space="preserve">
          <source>When both flags are given, &lt;code&gt;-&lt;/code&gt; overrides &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; overrides space. A negative width specifier in a &lt;code&gt;*&lt;/code&gt; conversion is treated as positive but implies the left adjust flag.</source>
          <target state="translated">同时给出两个标志时， &lt;code&gt;-&lt;/code&gt; 覆盖 &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;+&lt;/code&gt; 覆盖空格。 &lt;code&gt;*&lt;/code&gt; 转换中的负宽度说明符被视为正，但表示左调整标志。</target>
        </trans-unit>
        <trans-unit id="c583a2daef55ba93660dab2181971d9c96affcae" translate="yes" xml:space="preserve">
          <source>When bound type/kind variables are needed, both foralls must always be included, though if no pattern variables are needed, the second can be left empty. For example:</source>
          <target state="translated">当需要绑定类型/种类变量时,必须始终包含这两个foralls,不过如果不需要模式变量,第二个可以留空。例如</target>
        </trans-unit>
        <trans-unit id="f50b7073e92588827095ef86d1a93dc5624425e5" translate="yes" xml:space="preserve">
          <source>When building the package as shared library, GHC can be used to perform the link step. This hides some of the details out the underlying linker and provides a common interface to all shared object variants that are supported by GHC (DLLs, ELF DSOs, and Mac OS dylibs). The shared object must be named in specific way for two reasons: (1) the name must contain the GHC compiler version, so that two library variants don&amp;rsquo;t collide that are compiled by different versions of GHC and that therefore are most likely incompatible with respect to calling conventions, (2) it must be different from the static name otherwise we would not be able to control the linker as precisely as necessary to make the &lt;a href=&quot;phases#ghc-flag--static&quot;&gt;&lt;code&gt;-static&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flags work, see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;.</source>
          <target state="translated">将程序包构建为共享库时，可以使用GHC执行链接步骤。这会将一些细节隐藏在底层链接程序之外，并为GHC支持的所有共享对象变体（DLL，ELF DSO和Mac OS dylib）提供了一个通用接口。共享对象必须以特定的方式命名，其原因有两个：（1）名称必须包含GHC编译器版本，以免两个库变体冲突，它们由GHC的不同版本编译，因此很可能与GHC不兼容关于调用约定，（2）它必须与静态名称不同，否则我们将无法精确地控制链接器以使&lt;a href=&quot;phases#ghc-flag--static&quot;&gt; &lt;code&gt;-static&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志起作用，请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="875e6cafbc6d59eb66fc82af9876b4374369334e" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">在外部 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;control-exception#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 内部调用时，此功能无效。</target>
        </trans-unit>
        <trans-unit id="243332589a64a0059680beec8aa0bddae2923848" translate="yes" xml:space="preserve">
          <source>When called outside &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, or inside &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt;, this function has no effect.</source>
          <target state="translated">在外部 &lt;code&gt;&lt;a href=&quot;ghc-io#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-io#v:uninterruptibleMask&quot;&gt;uninterruptibleMask&lt;/a&gt;&lt;/code&gt; 内部调用时，此功能无效。</target>
        </trans-unit>
        <trans-unit id="159d2f6d7ded7efea02ecb9ffcbe5390b4f1604f" translate="yes" xml:space="preserve">
          <source>When called, &lt;a href=&quot;#ghci-cmd-:complete&quot;&gt;&lt;code&gt;:complete&lt;/code&gt;&lt;/a&gt; prints the ⟨n⟩&lt;sup&gt;th&lt;/sup&gt; to ⟨m⟩&lt;sup&gt;th&lt;/sup&gt; completion candidates for the partial input ⟨string-literal⟩ for the completion domain denoted by ⟨type⟩. Currently, only the &lt;code&gt;repl&lt;/code&gt; domain is supported which denotes the kind of completion that would be provided interactively by GHCi at the input prompt.</source>
          <target state="translated">当被调用时，&lt;a href=&quot;#ghci-cmd-:complete&quot;&gt; &lt;code&gt;:complete&lt;/code&gt; 会&lt;/a&gt;为部分输入&amp;ldquo; string-literal&amp;rdquo;（由&amp;ldquo; type&amp;rdquo;表示）的部分输入&amp;ldquo; string-literal &amp;rdquo;输出&lt;sup&gt;第n&lt;/sup&gt;至&lt;sup&gt;第&lt;/sup&gt; m &lt;sup&gt;个&lt;/sup&gt;完成候选词。当前，仅支持 &lt;code&gt;repl&lt;/code&gt; 域，该域表示将由GHCi在输入提示下以交互方式提供的完成类型。</target>
        </trans-unit>
        <trans-unit id="91bfd4202cf7d28182e849d580845ae0414f191c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="48ba12667e3fd1048b009a15a0cd69fde8f3da1f" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="16055e9ff59a612541837d896b39a4a261047d2e" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#t:IntMap&quot;&gt;IntMap&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="3aa713141e54c7f5e7d89cd106fcb760c962439c" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-map-lazy#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="3ad9f040f079657fee9aa2d7959ffd44743ab119" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt;, a function combining two &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;s is created, such that</source>
          <target state="translated">当调用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mergeWithKey&quot;&gt;mergeWithKey&lt;/a&gt; combine only1 only2&lt;/code&gt; ，将创建一个将两个 &lt;code&gt;&lt;a href=&quot;data-map-strict#t:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 组合在一起的函数，这样</target>
        </trans-unit>
        <trans-unit id="d3cab75098ce8f7c8bf1f9d999dc8843f7dd1aac" translate="yes" xml:space="preserve">
          <source>When case converting &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; values, do not use combinators like &lt;code&gt;map toUpper&lt;/code&gt; to case convert each character of a string individually, as this gives incorrect results according to the rules of some writing systems. The whole-string case conversion functions from this module, such as &lt;code&gt;toUpper&lt;/code&gt;, obey the correct case conversion rules. As a result, these functions may map one input character to two or three output characters. For examples, see the documentation of each function.</source>
          <target state="translated">在对 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 值进行大小写转换时，请勿使用诸如 &lt;code&gt;map toUpper&lt;/code&gt; 之类的组合符来分别对字符串的每个字符进行大小写转换，因为这会根据某些书写系统的规则产生不正确的结果。此模块的全字符串大小写转换功能（例如 &lt;code&gt;toUpper&lt;/code&gt; ）遵守正确的大小写转换规则。结果，这些功能可以将一个输入字符映射到两个或三个输出字符。有关示例，请参见每个功能的文档。</target>
        </trans-unit>
        <trans-unit id="36faad4a34745ccf0d9d6721f900aef14f287b9a" translate="yes" xml:space="preserve">
          <source>When checking a pair of closed type family equations GHC tried to unify their RHSs. If they don&amp;rsquo;t unify this pair of equations does not violate injectivity annotation. If the RHSs can be unified under some substitution (possibly empty) then either the LHSs unify under the same substitution or the LHS of the latter equation is subsumed by earlier equations. If neither condition is met GHC reports that a type family is not injective.</source>
          <target state="translated">在检查一对封闭型族方程时，GHC试图统一其RHS。如果它们不统一，则这对方程式不会违反注入性注释。如果RHS可以在某些替换下统一（可能为空），则LHS在相同的替换下统一，或者后一个方程式的LHS包含在较早的方程式中。如果两个条件都不满足，GHC报告类型家族不是内射。</target>
        </trans-unit>
        <trans-unit id="4204f66fa3958025c4499fdd95a271a6773f14df" translate="yes" xml:space="preserve">
          <source>When combined with &lt;a href=&quot;glasgow_exts#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt;, a user can insert wildcards into a query and learn the constraints required of each wildcard for ⟨type⟩ match with an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4e321554d1d4d81d3858e5b7e9944bc86c5ab85" translate="yes" xml:space="preserve">
          <source>When compiling Template Haskell code with &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; we don&amp;rsquo;t need to compile the modules without &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; first (see &lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;Using Template Haskell with Profiling&lt;/a&gt;) because we can run the profiled object code in the interpreter.</source>
          <target state="translated">当使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;编译Template Haskell代码时，我们不需要先编译不使用&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;的模块（请参阅&lt;a href=&quot;glasgow_exts#th-profiling&quot;&gt;将Template Haskell与Profiling一起使用&lt;/a&gt;），因为我们可以在解释器中运行配置文件。</target>
        </trans-unit>
        <trans-unit id="6b1fb89c4dd75cbc344be1dea9bcf6c42f1fedd1" translate="yes" xml:space="preserve">
          <source>When compiling with &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, compile ⟨n⟩ modules in parallel.</source>
          <target state="translated">使用&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;编译时，并行编译⟨n⟩个模块。</target>
        </trans-unit>
        <trans-unit id="ad4dc32c51694cafc5b9d82cef616b8dae524bd0" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="d52b75d2fceb888d77bcc4884a089cb376a2d17a" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5891acd9f507e897d00bc8be861dd19dd98594cc" translate="yes" xml:space="preserve">
          <source>When constructing a list of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; values, &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; can be used to return all of the &quot;success&quot; results (if the list is the result of a &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; would be more appropriate):</source>
          <target state="translated">在构造 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 值列表时，可以使用 &lt;code&gt;&lt;a href=&quot;data-maybe#v:catMaybes&quot;&gt;catMaybes&lt;/a&gt;&lt;/code&gt; 返回所有&amp;ldquo;成功&amp;rdquo;结果（如果列表是 &lt;code&gt;&lt;a href=&quot;ghc-list#v:map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 的结果，则 &lt;code&gt;&lt;a href=&quot;data-maybe#v:mapMaybe&quot;&gt;mapMaybe&lt;/a&gt;&lt;/code&gt; 会更合适）：</target>
        </trans-unit>
        <trans-unit id="267399ee1f750f57effcf0f11fd1c92b5e0ec62a" translate="yes" xml:space="preserve">
          <source>When creating shared objects for Haskell packages, the shared object must be named properly, so that GHC recognizes the shared object when linked against this package. See shared object name mangling.</source>
          <target state="translated">在为Haskell包创建共享对象时,必须对共享对象进行正确的命名,以便GHC在针对该包进行链接时识别共享对象。请看共享对象名称的混杂。</target>
        </trans-unit>
        <trans-unit id="040a24f363515b57cd4d01d198fd54857f6a9010" translate="yes" xml:space="preserve">
          <source>When deciding if this is the correct data structure to use, consider:</source>
          <target state="translated">在决定是否正确使用这种数据结构时,要考虑:</target>
        </trans-unit>
        <trans-unit id="d350986d8cf8f48a23307f79bbc64b78292205fe" translate="yes" xml:space="preserve">
          <source>When defining GHCi macros, there is some important behavior you should be aware of when names may conflict with built-in commands, especially regarding tab completion.</source>
          <target state="translated">在定义GHCi宏时,当名称可能与内置命令冲突时,有一些重要的行为你应该注意,特别是关于标签完成。</target>
        </trans-unit>
        <trans-unit id="619a2fbbfa669a15353775870c1c35941046099c" translate="yes" xml:space="preserve">
          <source>When designing embedded domain specific languages in Haskell, it is useful to have something like &lt;code&gt;error&lt;/code&gt; at the type level. In this way, the EDSL designer may show a type error that is specific to the DSL, rather than the standard GHC type error.</source>
          <target state="translated">在Haskell中设计嵌入式领域特定的语言时，在类型级别 &lt;code&gt;error&lt;/code&gt; 诸如错误之类的东西很有用。这样，EDSL设计人员可能会显示特定于DSL的类型错误，而不是标准的GHC类型错误。</target>
        </trans-unit>
        <trans-unit id="88b14bed4c82c902cd5c2544d56a293033425bc3" translate="yes" xml:space="preserve">
          <source>When desugaring list notation with &lt;a href=&quot;#extension-OverloadedLists&quot;&gt;&lt;code&gt;OverloadedLists&lt;/code&gt;&lt;/a&gt; GHC uses the &lt;code&gt;fromList&lt;/code&gt; (etc) methods from module &lt;code&gt;GHC.Exts&lt;/code&gt;. You do not need to import &lt;code&gt;GHC.Exts&lt;/code&gt; for this to happen.</source>
          <target state="translated">当使用&lt;a href=&quot;#extension-OverloadedLists&quot;&gt; &lt;code&gt;OverloadedLists&lt;/code&gt; &lt;/a&gt;删除列表符号时，GHC使用模块 &lt;code&gt;GHC.Exts&lt;/code&gt; 中的 &lt;code&gt;fromList&lt;/code&gt; （etc）方法。您无需导入 &lt;code&gt;GHC.Exts&lt;/code&gt; 即可实现。</target>
        </trans-unit>
        <trans-unit id="2ed40e3d2f62aa9ef8fd7c6b4edb55d14328dd44" translate="yes" xml:space="preserve">
          <source>When doing so, we (optionally) may drop the &amp;ldquo;&lt;code&gt;family&lt;/code&gt;&amp;rdquo; keyword.</source>
          <target state="translated">这样做时，我们（可选）可以删除&amp;ldquo; &lt;code&gt;family&lt;/code&gt; &amp;rdquo;关键字。</target>
        </trans-unit>
        <trans-unit id="8a186e432e4adac7230287d5161cfc630e85a9b5" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;-XUnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="translated">启用后，GHC使用&lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt; &lt;code&gt;-XUnicodeSyntax&lt;/code&gt; &lt;/a&gt;扩展名中的Unicode符号打印类型签名。例如，</target>
        </trans-unit>
        <trans-unit id="8dbdb2194a992ad2487a00a403a3f21e8db0a4da" translate="yes" xml:space="preserve">
          <source>When enabled GHC prints type signatures using the unicode symbols from the &lt;a href=&quot;glasgow_exts#extension-UnicodeSyntax&quot;&gt;&lt;code&gt;UnicodeSyntax&lt;/code&gt;&lt;/a&gt; extension. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72a37dd4c32f35dac5d3eaebdca05e5df23703d" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints extra information from the typechecker in warnings. For example:</source>
          <target state="translated">当启用时,GHC也会在警告中打印来自类型检查器的额外信息。例如:</target>
        </trans-unit>
        <trans-unit id="ed3c92cede590a141cb0d7244de0138f98c290d7" translate="yes" xml:space="preserve">
          <source>When enabled, GHC also prints type-synonym-expanded types in type errors. For example, with this type synonyms:</source>
          <target state="translated">启用后,GHC还可以在类型错误中打印类型同义词扩展的类型。例如,用这种类型同义词。</target>
        </trans-unit>
        <trans-unit id="8420071eb5dfd7c3926321e6256f4cd3157b3b83" translate="yes" xml:space="preserve">
          <source>When enabled, turn on an extra check for a trustworthy module &lt;code&gt;M&lt;/code&gt;, requiring the package that &lt;code&gt;M&lt;/code&gt; resides in be considered trusted, for &lt;code&gt;M&lt;/code&gt; to be considered trusted.</source>
          <target state="translated">启用后，打开对可信任模块 &lt;code&gt;M&lt;/code&gt; 的额外检查，要求将 &lt;code&gt;M&lt;/code&gt; 所在的程序包视为可信任，以便将 &lt;code&gt;M&lt;/code&gt; 视为可信任。</target>
        </trans-unit>
        <trans-unit id="57af1def6db68d09808377116f22141c44cf705b" translate="yes" xml:space="preserve">
          <source>When generating code, assume that entities imported from a different module might be dynamically linked. This flag is enabled automatically by &lt;a href=&quot;#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生成代码时，假设从其他模块导入的实体可能是动态链接的。该标志由&lt;a href=&quot;#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;自动启用。</target>
        </trans-unit>
        <trans-unit id="ca8d6acd6f8e6b72171a8fd88d9e46614a530faf" translate="yes" xml:space="preserve">
          <source>When giving priority to built-in commands, you can use &lt;a href=&quot;#ghci-cmd-::%20%E2%9F%A8builtin-command%E2%9F%A9&quot;&gt;&lt;code&gt;:: ⟨builtin-command⟩&lt;/code&gt;&lt;/a&gt;, like &lt;code&gt;::type 3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ecfe994a44aa5e06d258f6cbf6baae246ad708" translate="yes" xml:space="preserve">
          <source>When incorporating packages from multiple sources, you may end up in a situation where multiple packages publish modules with the same name. Previously, the only way to distinguish between these modules was to use &lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package-qualified imports&lt;/a&gt;. However, since GHC 7.10, the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; flags (and their variants) have been extended to allow a user to explicitly control what modules a package brings into scope, by analogy to the import lists that users can attach to module imports.</source>
          <target state="translated">当合并来自多个来源的软件包时，您可能最终会遇到多个软件包发布具有相同名称的模块的情况。以前，区分这些模块的唯一方法是使用&lt;a href=&quot;glasgow_exts#package-qualified-imports&quot;&gt;Package限定的import&lt;/a&gt;。但是，自GHC 7.10起，&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;标志（及其变体）已得到扩展，以允许用户类似于用户可以附加到模块导入的导入列表，来明确控制软件包将哪些模块纳入范围。</target>
        </trans-unit>
        <trans-unit id="530606766f1f0e85d14a486b7c77dd90c2bc2263" translate="yes" xml:space="preserve">
          <source>When invoked inside &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt;, this function allows a masked asynchronous exception to be raised, if one exists. It is equivalent to performing an interruptible operation (see #interruptible), but does not involve any actual blocking.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; 内部调用时，此函数允许引发被屏蔽的异步异常（如果存在）。这等效于执行可中断的操作（请参阅#interruptible），但不涉及任何实际的阻塞。</target>
        </trans-unit>
        <trans-unit id="cd4aee3a89a8546aec707d8315157ec69f35ee98" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;a href=&quot;#rts-flag--pj&quot;&gt;&lt;code&gt;-pj&lt;/code&gt;&lt;/a&gt; flag the runtime will emit the cost-centre profile in a machine-readable JSON format. The top-level object of this format has the following properties,</source>
          <target state="translated">当使用&lt;a href=&quot;#rts-flag--pj&quot;&gt; &lt;code&gt;-pj&lt;/code&gt; &lt;/a&gt;标志调用时，运行时将以机器可读的JSON格式发出成本中心配置文件。此格式的顶级对象具有以下属性，</target>
        </trans-unit>
        <trans-unit id="9a02ee031de69293536cc2fb0703b4eb50225310" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;-g&lt;/code&gt; flag GHC will produce standard &lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt; debugging information. This format is used by nearly all POSIX-compliant targets and can be used by debugging and performance tools (e.g. &lt;code&gt;gdb&lt;/code&gt;, &lt;code&gt;lldb&lt;/code&gt;, and &lt;code&gt;perf&lt;/code&gt;) to understand the structure of GHC-compiled programs.</source>
          <target state="translated">当与 &lt;code&gt;-g&lt;/code&gt; 标志一起调用时，GHC将产生标准的&lt;a href=&quot;http://dwarfstd.org/&quot;&gt;DWARF v4&lt;/a&gt;调试信息。几乎所有POSIX兼容目标都使用此格式，调试和性能工具（例如 &lt;code&gt;gdb&lt;/code&gt; ， &lt;code&gt;lldb&lt;/code&gt; 和 &lt;code&gt;perf&lt;/code&gt; ）可以使用此格式来了解GHC编译程序的结构。</target>
        </trans-unit>
        <trans-unit id="7233d6ae06f0af35b8939be05661b21a15c0815e" translate="yes" xml:space="preserve">
          <source>When it starts, unless the &lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt;&lt;code&gt;-ignore-dot-ghci&lt;/code&gt;&lt;/a&gt; flag is given, GHCi reads and executes commands from the following files, in this order, if they exist:</source>
          <target state="translated">当启动时，除非&lt;a href=&quot;#ghc-flag--ignore-dot-ghci&quot;&gt; &lt;code&gt;-ignore-dot-ghci&lt;/code&gt; &lt;/a&gt;标志，否则GHCi将按照以下顺序从以下文件中读取并执行命令（如果存在）：</target>
        </trans-unit>
        <trans-unit id="361cd0a8cf95ef4329a273971c8b2fcd1077e659" translate="yes" xml:space="preserve">
          <source>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type&amp;rsquo;s kind.</source>
          <target state="translated">在对类型进行种类检查时，GHC在弄清楚如何概括类型的种类时仅考虑用该类型写的内容。</target>
        </trans-unit>
        <trans-unit id="7a5ff365d37b7f0259e0661947d106803588e07a" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards</source>
          <target state="translated">当链接一个二进制可执行文件，这就将标志 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 之前的任何 &lt;code&gt;-l&lt;/code&gt; Haskell的图书馆标志和 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 之后</target>
        </trans-unit>
        <trans-unit id="4499b5b873f9dc67b87b2a369d68b43609620e48" translate="yes" xml:space="preserve">
          <source>When linking a binary executable, this inserts the flag &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; before any &lt;code&gt;-l&lt;/code&gt; flags for Haskell libraries, and &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; afterwards (on OS X, the flag is &lt;code&gt;-Wl,-all_load&lt;/code&gt;, there is no equivalent for &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt;). This flag also disables the use of &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; (&lt;code&gt;-Wl,-dead_strip&lt;/code&gt; on OS X).</source>
          <target state="translated">当链接一个二进制可执行文件，这就将标志 &lt;code&gt;-Wl,--whole-archive&lt;/code&gt; 之前的任何 &lt;code&gt;-l&lt;/code&gt; Haskell的图书馆标志和 &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 之后（在OS X上，该标志为 &lt;code&gt;-Wl,-all_load&lt;/code&gt; ，没有-Wl，-no &lt;code&gt;-Wl,--no-whole-archive&lt;/code&gt; 等效项。此标志还禁止使用 &lt;code&gt;-Wl,-dead_strip&lt;/code&gt; &lt;code&gt;-Wl,--gc-sections&lt;/code&gt; （在OS X上为-Wl，-dead_strip）。</target>
        </trans-unit>
        <trans-unit id="6ed1f82a4efde09a8cdc29a10621d1a1e1e89c49" translate="yes" xml:space="preserve">
          <source>When linking the final program, it is normally easiest to do the link using GHC, although this isn&amp;rsquo;t essential. If you do use GHC, then don&amp;rsquo;t forget the flag &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt;, otherwise GHC will try to link to the &lt;code&gt;Main&lt;/code&gt; Haskell module.</source>
          <target state="translated">链接最终程序时，尽管并非必需，但通常最容易使用GHC进行链接。如果您确实使用了GHC，请不要忘记标记&lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;，否则GHC会尝试链接到 &lt;code&gt;Main&lt;/code&gt; Haskell模块。</target>
        </trans-unit>
        <trans-unit id="df717341a67671689dd35a9b3531eb8e0f072f7a" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2dd48f11e6f6c0af801c305aba7a77f6361bb7" translate="yes" xml:space="preserve">
          <source>When linking, the linker can automatically remove all unreferenced sections and thus produce smaller executables. The effect is similar to &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, but somewhat more efficient - the generated library files are about 30% smaller than with &lt;a href=&quot;#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">链接时，链接器可以自动删除所有未引用的节，从而生成较小的可执行文件。效果类似于&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;，但是效率更高-生成的库文件比&lt;a href=&quot;#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt;小约30％。</target>
        </trans-unit>
        <trans-unit id="d37c9bdc0238439f64ffb1b22f8242d5b102af6d" translate="yes" xml:space="preserve">
          <source>When load-balancing, we prefer to migrate threads to another Capability on the same node.</source>
          <target state="translated">负载均衡时,我们更倾向于将线程迁移到同一节点上的另一个Capability。</target>
        </trans-unit>
        <trans-unit id="ca8dc781bc174b3d0ef5f29c63f9d74a9b61565e" translate="yes" xml:space="preserve">
          <source>When loading up source modules with &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt;, GHCi normally looks for any corresponding compiled object files, and will use one in preference to interpreting the source if possible. For example, suppose we have a 4-module program consisting of modules &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;D&lt;/code&gt;. Modules &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; both import &lt;code&gt;D&lt;/code&gt; only, and &lt;code&gt;A&lt;/code&gt; imports both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">当使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;加载源模块时，GHCi通常会查找任何相应的已编译目标文件，并且将尽可能优先使用一个来解释源文件。例如，假设我们有一个由4个模块组成的程序， &lt;code&gt;A&lt;/code&gt; 程序由模块A， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 组成。模块 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 两个进口 &lt;code&gt;D&lt;/code&gt; 只，和 &lt;code&gt;A&lt;/code&gt; 进口既 &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28cbb12931cf68eb7c3de11bf08eef612622ef28" translate="yes" xml:space="preserve">
          <source>When looking at a profile for the execution of a program we often want to be able to mark certain points or phases in the execution and see that visually in the profile.</source>
          <target state="translated">在查看程序执行的剖面图时,我们往往希望能够在执行中标记某些点或阶段,并在剖面图中直观地看到。</target>
        </trans-unit>
        <trans-unit id="6c486537118e35e64b5c334ff7a98297357cb64a" translate="yes" xml:space="preserve">
          <source>When matching, GHC takes no account of the context of the instance declaration (&lt;code&gt;context1&lt;/code&gt; etc).</source>
          <target state="translated">匹配时，GHC不考虑实例声明的上下文（ &lt;code&gt;context1&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="498da4b797c7d9882514545e11b3040398bef3ba" translate="yes" xml:space="preserve">
          <source>When merging class declarations, we require that the superclasses and methods match exactly; however, &lt;code&gt;MINIMAL&lt;/code&gt; pragmas are logically ORed together, and a method with a default signature will merge successfully against one that does not.</source>
          <target state="translated">合并类声明时，我们要求超类和方法完全匹配；但是， &lt;code&gt;MINIMAL&lt;/code&gt; 杂项在逻辑上进行&amp;ldquo;或&amp;rdquo;运算，具有默认签名的方法将与不具有默认签名的方法成功合并。</target>
        </trans-unit>
        <trans-unit id="13d96b4152f2bb41979b050993f6f5cc68827878" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="3653488103c6d86e8420d8068c23cf681e601a0f" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4961ca301e1790a20147cdfe939950a6d33b824b" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="3a0dc1ecac08b0699c48579f51666ce670e2fdc7" translate="yes" xml:space="preserve">
          <source>When multiple threads are blocked on an &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">当多个线程在 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 上被阻塞时，它们将按FIFO顺序唤醒。这对于提供使用 &lt;code&gt;&lt;a href=&quot;ghc-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建的抽象的公平属性很有用。</target>
        </trans-unit>
        <trans-unit id="47d33920b6c7bf0482fcdd6cb94ff91c03b1df6d" translate="yes" xml:space="preserve">
          <source>When not using the cfg based blocklayout layout is determined either by the last jump in a basic block or the heaviest outgoing edge of the block in the cfg.</source>
          <target state="translated">当不使用基于cfg的块状布局时,布局由基本块中的最后一个跳转或cfg中块的最重出边决定。</target>
        </trans-unit>
        <trans-unit id="d68178cc854fde413ac3a61732c2b13bbbbaa425" translate="yes" xml:space="preserve">
          <source>When overloading is involved, the results might be slightly counter intuitive:</source>
          <target state="translated">当涉及到超载时,结果可能会略微反常。</target>
        </trans-unit>
        <trans-unit id="33fd0ba5406a8b9e8e8bedaed530c6c43c6e5581" translate="yes" xml:space="preserve">
          <source>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the &lt;code&gt;StgArrBytes&lt;/code&gt;/&lt;code&gt;StgMutArrPtrs&lt;/code&gt;/&lt;code&gt;StgSmallMutArrPtrs&lt;/code&gt; heap object containing it &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. By contrast, a &lt;a href=&quot;#ffi-prim&quot;&gt;foreign Cmm call&lt;/a&gt;, introduced by &lt;code&gt;foreign import prim&lt;/code&gt;, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a &lt;code&gt;MutableByteArray#&lt;/code&gt;&lt;a href=&quot;#id6&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; without using anything from &lt;code&gt;Rts.h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323e06a5b9b42ca19f61c57b13f1e2cc57762eab" translate="yes" xml:space="preserve">
          <source>When pattern matching, each pattern match introduces a new, distinct, type for each existential type variable. These types cannot be unified with any other type, nor can they escape from the scope of the pattern match. For example, these fragments are incorrect:</source>
          <target state="translated">在模式匹配时,每个模式匹配都会为每个存在型变量引入一个新的、不同的、类型。这些类型不能与其他类型统一,也不能逃出模式匹配的范围。例如,这些片段是不正确的。</target>
        </trans-unit>
        <trans-unit id="76dc38f4da1e115d0fbb72bfc78e7e370e76dc89" translate="yes" xml:space="preserve">
          <source>When pattern matching, these constraints are made available to discharge constraints in the body of the match. For example:</source>
          <target state="translated">在模式匹配时,这些约束条件可用于匹配主体的放电约束。例如:</target>
        </trans-unit>
        <trans-unit id="64f0a5fc186667673c27a1a79ddf49cf4d4d8369" translate="yes" xml:space="preserve">
          <source>When pattern-matching against data constructors drawn from a GADT, for example in a &lt;code&gt;case&lt;/code&gt; expression, the following rules apply:</source>
          <target state="translated">当与从GADT提取的数据构造函数进行模式匹配时（例如在 &lt;code&gt;case&lt;/code&gt; 表达式中），适用以下规则：</target>
        </trans-unit>
        <trans-unit id="cca67ae5710480c8d1d3f3cfa7badc44302acc0c" translate="yes" xml:space="preserve">
          <source>When record wildcards are use in record construction, a field &lt;code&gt;f&lt;/code&gt; is initialised only if &lt;code&gt;f&lt;/code&gt; is in scope, and is not imported or bound at top level. For example, &lt;code&gt;f&lt;/code&gt; can be bound by an enclosing pattern match or let/where-binding. For example</source>
          <target state="translated">当在记录构造中使用记录通配符时，仅当 &lt;code&gt;f&lt;/code&gt; 在作用域内且未在顶级导入或绑定时才初始化字段 &lt;code&gt;f&lt;/code&gt; 。例如， &lt;code&gt;f&lt;/code&gt; 可以由封闭模式匹配或let / where-binding绑定。例如</target>
        </trans-unit>
        <trans-unit id="cd61c8580bf27c284ada1235029433f00550518e" translate="yes" xml:space="preserve">
          <source>When reporting typed holes, also print constraints that are in scope. Example:</source>
          <target state="translated">在报告打孔时,还要打印范围内的约束条件。例如</target>
        </trans-unit>
        <trans-unit id="d5749f7e859387e415e9ea6f2b6fc623916e28fd" translate="yes" xml:space="preserve">
          <source>When retainer profiling is requested by giving the program the &lt;code&gt;-hr&lt;/code&gt; option, a graph is generated which is broken down by retainer set. A retainer set is displayed as a set of cost-centre stacks; because this is usually too large to fit on the profile graph, each retainer set is numbered and shown abbreviated on the graph along with its number, and the full list of retainer sets is dumped into the file &lt;code&gt;prog.prof&lt;/code&gt;.</source>
          <target state="translated">当通过给程序提供 &lt;code&gt;-hr&lt;/code&gt; 选项来请求保持器配置文件时，将生成一个图，该图由保持器集分解。保留集显示为一组成本中心堆栈；因为它通常太大而无法容纳在概要图上，所以每个保留集 &lt;code&gt;prog.prof&lt;/code&gt; 编号并在图表上以缩写形式显示及其编号，并将保留集的完整列表转储到文件prog.prof中。</target>
        </trans-unit>
        <trans-unit id="89e8511fce39457a72254072db29d062a7db7f59" translate="yes" xml:space="preserve">
          <source>When running an interactive console process (such as a shell, console-based text editor or ghci), we typically want that process to be allowed to handle Ctl-C keyboard interrupts how it sees fit. For example, while most programs simply quit on a Ctl-C, some handle it specially. To allow this to happen, use the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; options.</source>
          <target state="translated">当运行交互式控制台进程（例如Shell，基于控制台的文本编辑器或ghci）时，我们通常希望该进程被允许处理Ctl-C键盘中断，使其看起来合适。例如，尽管大多数程序只是在Ctl-C上退出，但有些程序会专门处理它。为了使这种情况发生，请在 &lt;code&gt;&lt;a href=&quot;system-process#t:CreateProcess&quot;&gt;CreateProcess&lt;/a&gt;&lt;/code&gt; 选项中使用 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="69f43c447a73e3737752275138c5384e1a40a563" translate="yes" xml:space="preserve">
          <source>When setting language options in this file it is usually desirable to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">在此文件中设置语言选项时，通常希望使用&lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; &lt;/a&gt;而不是&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#ghci-interactive-options&quot;&gt;仅设置用于交互式评估的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="144cbf9ae1a490f2586ba5f5587390d136c4c35e" translate="yes" xml:space="preserve">
          <source>When should you use Safe Haskell inference and when should you use an explicit &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag? The later case should be used when you have a hard requirement that the module be safe. This is most useful for the &lt;a href=&quot;#safe-use-cases&quot;&gt;Uses of Safe Haskell&lt;/a&gt; of Safe Haskell: running untrusted code. Safe inference is meant to be used by ordinary Haskell programmers. Users who probably don&amp;rsquo;t care about Safe Haskell.</source>
          <target state="translated">什么时候应该使用Safe Haskell推论，什么时候应该使用显式的&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;标志？当您对模块的安全性有严格要求时，应使用后一种情况。对于&lt;a href=&quot;#safe-use-cases&quot;&gt;Safe Haskell&lt;/a&gt;的Safe Haskell 的使用，这是最有用的：运行不受信任的代码。安全推论是由普通的Haskell程序员使用的。可能不关心Safe Haskell的用户。</target>
        </trans-unit>
        <trans-unit id="0b7c2323116f8446304dbf4fd0a9a742ea1905e7" translate="yes" xml:space="preserve">
          <source>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</source>
          <target state="translated">当显示哪个标志控制一个警告时,还要显示该警告所包含的各个警告组标志。</target>
        </trans-unit>
        <trans-unit id="484adaad2c3b5affe28a1f5a91b613a70a51f5c3" translate="yes" xml:space="preserve">
          <source>When solving constraints, try to eagerly solve super classes using available dictionaries.</source>
          <target state="translated">在解决约束条件时,尽量利用现有的字典急于解决超类。</target>
        </trans-unit>
        <trans-unit id="bc168ba3677db9d1bbf4bffe64a2a5d12b06444b" translate="yes" xml:space="preserve">
          <source>When specifying a &lt;code&gt;COMPLETE&lt;/code&gt; pragma, the result types of all patterns must be consistent with each other. This is a sanity check as it would be impossible to match on all the patterns if the types were inconsistent.</source>
          <target state="translated">指定 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示时，所有模式的结果类型必须彼此一致。这是一个健全性检查，因为如果类型不一致，则不可能在所有模式上都匹配。</target>
        </trans-unit>
        <trans-unit id="382241740556b4d601b8fc9660196de5e7b80010" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 明确指定模式同义词的类型时，通用性，存在性或其上下文之一可以保留为空。</target>
        </trans-unit>
        <trans-unit id="c963ac1b0909b2694bee6056b093dd5725327d34" translate="yes" xml:space="preserve">
          <source>When specifying a pattern synonym's type explicitly with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; either one of the universals, the existentials, or their contexts may be left empty.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PatSynSigD&quot;&gt;PatSynSigD&lt;/a&gt;&lt;/code&gt; 明确指定模式同义词的类型时，通用性，存在性或其上下文之一可以保留为空。</target>
        </trans-unit>
        <trans-unit id="553e821cb4749b77832ca21d2824799e9e2ac680" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint or single-step, GHCi binds the variable &lt;code&gt;_result&lt;/code&gt; to the value of the currently active expression. The value of &lt;code&gt;_result&lt;/code&gt; is presumably not available yet, because we stopped its evaluation, but it can be forced: if the type is known and showable, then just entering &lt;code&gt;_result&lt;/code&gt; at the prompt will show it. However, there&amp;rsquo;s one caveat to doing this: evaluating &lt;code&gt;_result&lt;/code&gt; will be likely to trigger further breakpoints, starting with the breakpoint we are currently stopped at (if we stopped at a real breakpoint, rather than due to &lt;a href=&quot;#ghci-cmd-:step&quot;&gt;&lt;code&gt;:step&lt;/code&gt;&lt;/a&gt;). So it will probably be necessary to issue a &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; immediately when evaluating &lt;code&gt;_result&lt;/code&gt;. Alternatively, you can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; which ignores breakpoints.</source>
          <target state="translated">当在断点或单步停止时，GHCi将变量 &lt;code&gt;_result&lt;/code&gt; 绑定到当前活动表达式的值。 &lt;code&gt;_result&lt;/code&gt; 的值可能尚不可用，因为我们已停止对其求值，但是可以强制使用：如果类型已知且可显示，则只需在提示符下输入 &lt;code&gt;_result&lt;/code&gt; 即可显示它。但是，这样做有一个警告：评估 &lt;code&gt;_result&lt;/code&gt; 可能会触发更多的断点，从我们当前停在的断点开始（如果我们停在一个实际的断点，而不是由于&lt;a href=&quot;#ghci-cmd-:step&quot;&gt; &lt;code&gt;:step&lt;/code&gt; &lt;/a&gt;）。因此，在评估 &lt;code&gt;_result&lt;/code&gt; 时可能有必要立即发出&lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt;。另外，您可以使用&lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; &lt;/a&gt;忽略断点。</target>
        </trans-unit>
        <trans-unit id="92d371ad4ee2a8ee6fbafac5f93095a3ab6211e7" translate="yes" xml:space="preserve">
          <source>When stopped at a breakpoint, if you try to evaluate a variable that is already under evaluation, the second evaluation will hang. The reason is that GHC knows the variable is under evaluation, so the new evaluation just waits for the result before continuing, but of course this isn&amp;rsquo;t going to happen because the first evaluation is stopped at a breakpoint. Control-C can interrupt the hung evaluation and return to the prompt.</source>
          <target state="translated">当在断点处停止时，如果尝试评估已经在评估中的变量，则第二次评估将挂起。原因是GHC知道该变量正在评估中，因此新评估只是在继续之前等待结果，但是这当然不会发生，因为第一个评估在断点处停止。Control-C可以中断挂起的评估并返回提示。</target>
        </trans-unit>
        <trans-unit id="899279c904f7b651561dbe3c33126459de151a50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is enabled, whether or not a module is trusted depends on if certain packages are trusted. Package trust is determined by the client C invoking GHC (i.e. you).</source>
          <target state="translated">当&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;启用标志，模块是否被信任的依赖，如果某些包是值得信赖的。包信任度由客户端C调用GHC（即您）决定。</target>
        </trans-unit>
        <trans-unit id="f8b0b48dfee543852c87a9432f359d04272547db" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag is used a &lt;em&gt;module M from package P is trusted by a client C&lt;/em&gt; if and only if:</source>
          <target state="translated">当使用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志时&lt;em&gt;，客户机C信任来自程序包P&lt;/em&gt;的&lt;em&gt;模块M，&lt;/em&gt;并且仅在以下情况下：</target>
        </trans-unit>
        <trans-unit id="e6b906c5413a341dba67df9ee662b85c1be14d71" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;*&lt;/code&gt; is used, GHCi ignores any pre-compiled object code and interprets the module. If you have already loaded a number of modules as object code and decide that you wanted to interpret one of them, instead of re-loading the whole set you can use &lt;code&gt;:add *M&lt;/code&gt; to specify that you want &lt;code&gt;M&lt;/code&gt; to be interpreted (note that this might cause other modules to be interpreted too, because compiled modules cannot depend on interpreted ones).</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 时，GHCi将忽略任何预编译的目标代码并解释该模块。如果您已经加载了许多模块作为目标代码并决定要解释其中的一个模块，则可以使用 &lt;code&gt;:add *M&lt;/code&gt; 指定要解释的 &lt;code&gt;M&lt;/code&gt; （而不是重新加载整个模块）（请注意，这也可能导致其他模块也被解释，因为编译后的模块不能依赖于已解释的模块。</target>
        </trans-unit>
        <trans-unit id="9dab33d1ac192f21684231d4a18e8395567cf5cd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;GADTSyntax&lt;/code&gt; extension is enabled, GHC allows you to declare an algebraic data type by giving the type signatures of constructors explicitly. For example:</source>
          <target state="translated">当 &lt;code&gt;GADTSyntax&lt;/code&gt; 启用扩展，GHC允许你通过给构造函数的类型签名明确地声明一个代数数据类型。例如：</target>
        </trans-unit>
        <trans-unit id="15aff7ea0f1c5a8cd2f5e004afff68e300d36bae" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;OverloadedLists&lt;/code&gt; extension is turned on, the aforementioned seven notations are desugared as follows:</source>
          <target state="translated">当 &lt;code&gt;OverloadedLists&lt;/code&gt; 扩展导通时，上述7分表示法脱糖如下：</target>
        </trans-unit>
        <trans-unit id="5107504007f00763b80324b65c86f28ced5ae53d" translate="yes" xml:space="preserve">
          <source>When the compiler type checks the source code, &lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices and &lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quotation&lt;/a&gt; will be replaced by the syntax tree fragments generated from them. However for tools that operate on the source code the code generator is usually more interesting than the generated code. For this reason we included &lt;code&gt;spliceRunAction&lt;/code&gt;. This field is invoked on each expression before they are evaluated. The input is type checked, so semantic information is available for these syntax tree fragments. If you return a different expression you can change the code that is generated.</source>
          <target state="translated">当编译器类型检查源代码时，&lt;a href=&quot;glasgow_exts#template-haskell&quot;&gt;Template Haskell&lt;/a&gt; Splices和&lt;a href=&quot;glasgow_exts#th-quasiquotation&quot;&gt;Template Haskell Quasi-quote&lt;/a&gt;将替换为从它们生成的语法树片段。但是，对于在源代码上运行的工具，代码生成器通常比生成的代码更有趣。因此，我们包括了 &lt;code&gt;spliceRunAction&lt;/code&gt; 。在评估每个表达式之前，将在每个表达式上调用此字段。输入经过类型检查，因此语义信息可用于这些语法树片段。如果返回其他表达式，则可以更改生成的代码。</target>
        </trans-unit>
        <trans-unit id="5673c7cc6c0224b677cde4de6ae9ae60fb37a6cb" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; is set to an &lt;code&gt;n&lt;/code&gt; larger than &lt;code&gt;0&lt;/code&gt;, GHC will offer up a list of valid refinement hole fits, which are valid hole fits that need up to &lt;code&gt;n&lt;/code&gt; levels of additional refinement to be complete, where each level represents an additional hole in the hole fit that requires filling in. As an example, consider the hole in</source>
          <target state="translated">当标志&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;设置为大于 &lt;code&gt;0&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 时，GHC将提供有效细化孔配合的列表，这些有效细化配合是需要最多 &lt;code&gt;n&lt;/code&gt; 级附加细化的有效孔配合。为完整起见，其中每个层代表孔配合中需要填充的另一个孔。例如，考虑</target>
        </trans-unit>
        <trans-unit id="6a1b7b1389f2a8d3db6d8f6848af2551b694f3c8" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; is enabled, type variables that are mentioned in the patterns on the left hand side, but not used on the right hand side are reported. Variables that occur multiple times on the left hand side are also considered used. To suppress the warnings, unused variables should be either replaced or prefixed with underscores. Type variables starting with an underscore (&lt;code&gt;_x&lt;/code&gt;) are otherwise treated as ordinary type variables.</source>
          <target state="translated">启用标志&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; 时&lt;/a&gt;，将报告左侧模式中提及但右侧未使用的类型变量。左侧多次出现的变量也被视为已使用。为禁止显示警告，未使用的变量应替换为下划线或以下划线开头。以下划线（ &lt;code&gt;_x&lt;/code&gt; ）开头的类型变量被视为普通类型变量。</target>
        </trans-unit>
        <trans-unit id="ac8cb23658125202e8eee2e408fced0dd59ec5d3" translate="yes" xml:space="preserve">
          <source>When the last type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), the derived &lt;code&gt;Functor&lt;/code&gt; instance will not be produced using the usual algorithm. Instead, the entire value will be coerced.</source>
          <target state="translated">当最后一个类型参数具有幻像角色（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;）时，将不会使用通常的算法来生成派生的 &lt;code&gt;Functor&lt;/code&gt; 实例。相反，整个值将被强制。</target>
        </trans-unit>
        <trans-unit id="233c911a4c1131680d9d6db4277baa282cd0f57e" translate="yes" xml:space="preserve">
          <source>When the name of a type argument of a data or type instance declaration doesn&amp;rsquo;t matter, it can be replaced with an underscore (&lt;code&gt;_&lt;/code&gt;). This is the same as writing a type variable with a unique name.</source>
          <target state="translated">当数据或类型实例声明的类型参数的名称无关紧要时，可以将其替换为下划线（ &lt;code&gt;_&lt;/code&gt; ）。这与编写具有唯一名称的类型变量相同。</target>
        </trans-unit>
        <trans-unit id="a1d98d1e2e5c5946da05242e59f1db40d8dcc22d" translate="yes" xml:space="preserve">
          <source>When the program is linked with &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then you may invoke &lt;code&gt;foreign export&lt;/code&gt;ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling &lt;code&gt;hs_init()&lt;/code&gt;, and this call must complete before invoking any &lt;code&gt;foreign export&lt;/code&gt;ed functions.</source>
          <target state="translated">当程序与&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接时，可以同时从多个OS线程调用 &lt;code&gt;foreign export&lt;/code&gt; 函数。必须像往常一样通过调用 &lt;code&gt;hs_init()&lt;/code&gt; 初始化运行时系统，并且此调用必须在调用任何 &lt;code&gt;foreign export&lt;/code&gt; 函数之前完成。</target>
        </trans-unit>
        <trans-unit id="efc7b2d180e7d38567fdcdbc012e317680d9508c" translate="yes" xml:space="preserve">
          <source>When the program is linked with the &lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt;&lt;code&gt;-eventlog&lt;/code&gt;&lt;/a&gt; option (&lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), runtime events can be logged in several ways:</source>
          <target state="translated">当程序与&lt;a href=&quot;phases#ghc-flag--eventlog&quot;&gt; &lt;code&gt;-eventlog&lt;/code&gt; &lt;/a&gt;选项（&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;）链接在一起时，可以通过以下几种方式记录运行时事件：</target>
        </trans-unit>
        <trans-unit id="826464ce54c3e5a3850ddb81e2f3d8a1d2b02b44" translate="yes" xml:space="preserve">
          <source>When the refinement level is not set, it will only offer valid hole fits suggestions:</source>
          <target state="translated">当未设置细化级别时,它将只提供有效的孔洞配合建议。</target>
        </trans-unit>
        <trans-unit id="c53c590a0c640ed8d2a607fb6fb78194785335a9" translate="yes" xml:space="preserve">
          <source>When the statements of a &lt;code&gt;do&lt;/code&gt; expression have dependencies between them, and &lt;code&gt;ApplicativeDo&lt;/code&gt; cannot infer an &lt;code&gt;Applicative&lt;/code&gt; type, it uses a heuristic algorithm to try to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is an algorithm that finds the optimal solution, provided as an option:</source>
          <target state="translated">当 &lt;code&gt;do&lt;/code&gt; 表达式的语句之间具有依赖关系，而 &lt;code&gt;ApplicativeDo&lt;/code&gt; 无法推断出 &lt;code&gt;Applicative&lt;/code&gt; 类型时，它将使用启发式算法尝试尽可能多地使用 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 。该算法通常找到最佳解决方案，但是在极少数复杂的情况下，它可能会错失良机。有一种算法可以找到最佳解决方案，作为一种选择提供：</target>
        </trans-unit>
        <trans-unit id="a5fcf3468d7e17df51198be2fc216a1c5844dbdc" translate="yes" xml:space="preserve">
          <source>When the type has no constructors, &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; will derive the laziest instance it can.</source>
          <target state="translated">当类型没有构造函数时，&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;将派生其可能的最懒实例。</target>
        </trans-unit>
        <trans-unit id="7c0bee958d56b3e080c3491ce660a7fca269d22c" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt; derives a trivial instance. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;派生一个琐碎的实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="6f17641af058acfe98618282bffb569e65067173" translate="yes" xml:space="preserve">
          <source>When the type parameter has a phantom role (see &lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;), &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; coerces its argument. For example, this declaration:</source>
          <target state="translated">当type参数具有幻像角色时（请参见&lt;a href=&quot;#roles&quot;&gt;Roles&lt;/a&gt;），&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; 会强制&lt;/a&gt;其参数。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="9788212883c011680eb4209f913d576d2d5c8c3c" translate="yes" xml:space="preserve">
          <source>When the user writes</source>
          <target state="translated">当用户写入</target>
        </trans-unit>
        <trans-unit id="d4658dfa457302ae34d87b52d74dc90d170ae615" translate="yes" xml:space="preserve">
          <source>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of &amp;ldquo;right hand side&amp;rdquo; is played by the class method signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a4c9d83d847239f439fe4b373aabfc9fb18bb" translate="yes" xml:space="preserve">
          <source>When there is no right hand side, GHC defaults argument and result kinds to &lt;code&gt;Type&lt;/code&gt;, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9d7ebffa3b3c543f8e58090d401c81d6993a95" translate="yes" xml:space="preserve">
          <source>When there&amp;rsquo;s a strict pattern match in a sequence of statements, &lt;code&gt;ApplicativeDo&lt;/code&gt; places a &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; between that statement and the one that follows it. The sequence may be transformed to use &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; elsewhere, but the strict pattern match and the following statement will always be connected with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, to retain the same strictness semantics as the standard do-notation. If you don&amp;rsquo;t want this, simply put a &lt;code&gt;~&lt;/code&gt; on the pattern match to make it lazy.</source>
          <target state="translated">当在一系列语句中存在严格的模式匹配时， &lt;code&gt;ApplicativeDo&lt;/code&gt; 在该语句和其后的语句之间放置 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 。可以将序列转换为在其他地方使用 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; ，但是严格模式匹配和以下语句将始终与 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 连接，以保留与标准do-notation相同的严格语义。如果你不希望这样，干脆把 &lt;code&gt;~&lt;/code&gt; 上的图案搭配，使其懒惰。</target>
        </trans-unit>
        <trans-unit id="6ae2be8897d3fe9efbae676de894f97242cb7ef5" translate="yes" xml:space="preserve">
          <source>When this flag is enabled and &lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt;&lt;code&gt;-fblock-layout-cfg&lt;/code&gt;&lt;/a&gt; is disabled block layout behaves the same as in 8.6 and earlier.</source>
          <target state="translated">启用此标志并&lt;a href=&quot;#ghc-flag--fblock-layout-cfg&quot;&gt; &lt;code&gt;-fblock-layout-cfg&lt;/code&gt; &lt;/a&gt;，块布局的行为与8.6及更早版本中的相同。</target>
        </trans-unit>
        <trans-unit id="8b78a20416217afb6be3164c75c896b3593bddda" translate="yes" xml:space="preserve">
          <source>When this flag is set, the variable &lt;code&gt;it&lt;/code&gt; will no longer be set to the result of the previously evaluated expression.</source>
          <target state="translated">当该标志被设置时，可变 &lt;code&gt;it&lt;/code&gt; 不再被设置为先前计算的表达式的结果。</target>
        </trans-unit>
        <trans-unit id="0abc655f0149b4ea2c31f59034acadba2475e6e1" translate="yes" xml:space="preserve">
          <source>When this optimisation is enabled the code generator will turn all self-recursive saturated tail calls into local jumps rather than function calls.</source>
          <target state="translated">启用此优化后,代码生成器将把所有的自递归饱和尾部调用变成局部跳转,而不是函数调用。</target>
        </trans-unit>
        <trans-unit id="1ff5d9be5ba8ac947e7c18e80de01cc694da8a79" translate="yes" xml:space="preserve">
          <source>When this option is enabled, the OS threads for a capability \(i\) are bound to the CPU core \(i\) using the API provided by the OS for setting thread affinity. e.g. on Linux GHC uses &lt;code&gt;sched_setaffinity()&lt;/code&gt;.</source>
          <target state="translated">启用此选项后，将使用操作系统提供的用于设置线程关联性的API将功能\（i \）的OS线程绑定到CPU内核\（i \）。例如在Linux上，GHC使用 &lt;code&gt;sched_setaffinity()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1ccb4b911221d9c7329a128989a390ffc47505" translate="yes" xml:space="preserve">
          <source>When this option is given, intermediate floating point values can have a &lt;em&gt;greater&lt;/em&gt; precision/range than the final type. Generally this is a good thing, but some programs may rely on the exact precision/range of &lt;code&gt;Float&lt;/code&gt;/&lt;code&gt;Double&lt;/code&gt; values and should not use this option for their compilation.</source>
          <target state="translated">当这个选项被给出，中间浮点值可以具有&lt;em&gt;更大的&lt;/em&gt;精度/范围比最终类型。通常，这是一件好事，但是某些程序可能依赖于 &lt;code&gt;Float&lt;/code&gt; / &lt;code&gt;Double&lt;/code&gt; 值的精确精度/范围，并且不应在编译时使用此选项。</target>
        </trans-unit>
        <trans-unit id="f2c3c3b903ecd57a1f334c05282b926ee70d4dea" translate="yes" xml:space="preserve">
          <source>When this warning is enabled, the following conditions are verified:</source>
          <target state="translated">当启用该警告时,将验证以下条件。</target>
        </trans-unit>
        <trans-unit id="727a43a730bfe3958e333ca1131252729e149501" translate="yes" xml:space="preserve">
          <source>When turning on, you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wno-redundant-constraints&lt;/code&gt;&lt;/a&gt;. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</source>
          <target state="translated">启用时，您可以使用&lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wno-redundant-constraints&lt;/code&gt; &lt;/a&gt;在每个模块的基础上禁止它。有时，您可能特别希望某个函数具有比必要的约束更严格的签名，或者可能使自己留有余地来更改实现而不更改API。在这种情况下，您可以使用无效绑定中的调用按功能禁用警告。例如：</target>
        </trans-unit>
        <trans-unit id="2789e777c1c562054bf526316aec303f93f9c354" translate="yes" xml:space="preserve">
          <source>When type checking a module, GHC calls &lt;code&gt;tcPluginInit&lt;/code&gt; once before constraint solving starts. This allows the plugin to look things up in the context, initialise mutable state or open a connection to an external process (e.g. an external SMT solver). The plugin can return a result of any type it likes, and the result will be passed to the other two fields.</source>
          <target state="translated">在对模块进行类型检查时，GHC会在约束解决方案开始之前调用 &lt;code&gt;tcPluginInit&lt;/code&gt; 。这允许插件在上下文中查找内容，初始化可变状态或打开与外部进程（例如外部SMT求解器）的连接。插件可以返回喜欢的任何类型的结果，该结果将传递到其他两个字段。</target>
        </trans-unit>
        <trans-unit id="bf668c7a62fd75db56f950a9575023a0d559a8d2" translate="yes" xml:space="preserve">
          <source>When type checking the instance declaration for &lt;code&gt;F a&lt;/code&gt;, we need to check that the superclass &lt;code&gt;C&lt;/code&gt; of &lt;code&gt;F&lt;/code&gt; holds. We thus try to entail the constraint &lt;code&gt;C a&lt;/code&gt; under the theory containing:</source>
          <target state="translated">在对 &lt;code&gt;F a&lt;/code&gt; 的实例声明进行类型检查时，我们需要检查 &lt;code&gt;F&lt;/code&gt; 的超类 &lt;code&gt;C&lt;/code&gt; 是否成立。因此，我们尝试在包含以下理论的理论下约束 &lt;code&gt;C a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="923ea57be74cff7960655db8399f3a2e74d426e3" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;#extension-StandaloneDeriving&quot;&gt;&lt;code&gt;StandaloneDeriving&lt;/code&gt;&lt;/a&gt; we swap the order for the instance we base our derivation on and the instance we define e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae17e7f938b74606b4e67defaf4dcc55a0c4896" translate="yes" xml:space="preserve">
          <source>When used, the module being imported with the safe keyword must be a trusted module, otherwise a compilation error will occur. The safe import extension is enabled by either of the &lt;code&gt;-XSafe&lt;/code&gt; , &lt;code&gt;-XTrustworthy&lt;/code&gt; , or &lt;code&gt;-XUnsafe&lt;/code&gt; flags. When the &lt;code&gt;-XSafe&lt;/code&gt; flag is used, the &lt;code&gt;safe&lt;/code&gt; keyword is allowed but meaningless, as every import is treated as a safe import.</source>
          <target state="translated">使用时，使用safe关键字导入的模块必须是受信任的模块，否则将发生编译错误。通过 &lt;code&gt;-XSafe&lt;/code&gt; ， &lt;code&gt;-XTrustworthy&lt;/code&gt; 或 &lt;code&gt;-XUnsafe&lt;/code&gt; 标志之一启用安全导入扩展。使用 &lt;code&gt;-XSafe&lt;/code&gt; 标志时， &lt;code&gt;safe&lt;/code&gt; 关键字是允许的，但没有意义，因为每次导入都被视为安全导入。</target>
        </trans-unit>
        <trans-unit id="351e4a2b6a278723d8e994423d5fff893b44f52c" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; (or other extensions that make use of hash signs) in a &lt;code&gt;.hsc&lt;/code&gt; file (see &lt;a href=&quot;utils#hsc2hs&quot;&gt;Writing Haskell interfaces to C code: hsc2hs&lt;/a&gt;), the hash signs must be doubled (write &lt;code&gt;##foo&lt;/code&gt; instead of &lt;code&gt;#foo&lt;/code&gt;) to avoid them being treated as &lt;code&gt;hsc2hs&lt;/code&gt; directives.</source>
          <target state="translated">在 &lt;code&gt;.hsc&lt;/code&gt; 文件中使用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;（或其他使用哈希符号的扩展名）时（请参阅&lt;a href=&quot;utils#hsc2hs&quot;&gt;将Haskell接口写入C代码：hsc2hs&lt;/a&gt;），必须将哈希符号加倍（用 &lt;code&gt;##foo&lt;/code&gt; 代替 &lt;code&gt;#foo&lt;/code&gt; ）以避免它们。被视为 &lt;code&gt;hsc2hs&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="f7a28bf7dca85f87605cb3929fad07263258561b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;-dynamic-too&lt;/code&gt;, the options &lt;code&gt;-dyno&lt;/code&gt;, &lt;code&gt;-dynosuf&lt;/code&gt;, and &lt;code&gt;-dynhisuf&lt;/code&gt; are the counterparts of &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-osuf&lt;/code&gt;, and &lt;code&gt;-hisuf&lt;/code&gt; respectively, but applying to the dynamic compilation.</source>
          <target state="translated">当使用 &lt;code&gt;-dyno&lt;/code&gt; &lt;code&gt;-dynamic-too&lt;/code&gt; ，选项-dyno， &lt;code&gt;-dynosuf&lt;/code&gt; 和 &lt;code&gt;-dynhisuf&lt;/code&gt; 分别是 &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-osuf&lt;/code&gt; 和 &lt;code&gt;-hisuf&lt;/code&gt; 的对应项，但适用于动态编译。</target>
        </trans-unit>
        <trans-unit id="4050c1e62ccabfa1e4224d9fea523122bdc7bbef" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;capi&lt;/code&gt;, it is also possible to import values, rather than functions. For example,</source>
          <target state="translated">使用 &lt;code&gt;capi&lt;/code&gt; 时，也可以导入值而不是函数。例如，</target>
        </trans-unit>
        <trans-unit id="6f1947dce16cc4521a3138e0d861aacbe13d83fa" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;par&lt;/code&gt;, the general rule of thumb is that the sparked computation should be required at a later time, but not too soon. Also, the sparked computation should not be too small, otherwise the cost of forking it in parallel will be too large relative to the amount of parallelism gained. Getting these factors right is tricky in practice.</source>
          <target state="translated">使用 &lt;code&gt;par&lt;/code&gt; 时，一般的经验法则是应在稍后的时间（而不是太快的时间）内进行触发计算。同样，引发的计算不应太小，否则，相对于所获得的并行度，并行分叉的代价将太大。在实践中弄清这些因素是棘手的。</target>
        </trans-unit>
        <trans-unit id="efbc5f3d8c4bd8684a78d739a99139faa4c47324" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, a newline will be read if it is immediately available after the input character.</source>
          <target state="translated">当使用文件式交互时,如果在输入字符后立即有一个新行,则会被读取。</target>
        </trans-unit>
        <trans-unit id="e3b100300996ccb1d75762df35aa37649891a202" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, consumes a single character from the input which may be non-printable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf1268e3bda92155a087e5326eee4233cb86cbb" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="translated">使用文件样式交互时，如果在读取任何字符之前遇到 &lt;code&gt;EOF&lt;/code&gt; ，则这些函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="4a4385a77afcebb26e3a91b60eea37d30d0eaa80" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if an &lt;code&gt;EOF&lt;/code&gt; was encountered before any characters were read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cfd786fecdbf9e039c0199d5dbe440887961ef" translate="yes" xml:space="preserve">
          <source>When using file-style interaction, this function turns off echoing while reading the line of input.</source>
          <target state="translated">当使用文件式交互时,该功能在读取输入行时关闭回声。</target>
        </trans-unit>
        <trans-unit id="68d3f5856d19d8f966c85910ac0d5666700917bf" translate="yes" xml:space="preserve">
          <source>When using records, it is common to write a pattern that binds a variable with the same name as a record field, such as:</source>
          <target state="translated">在使用记录时,通常会写一个模式,绑定一个与记录字段同名的变量,如:。</target>
        </trans-unit>
        <trans-unit id="9a1fe98bbbe3c08cea8df75fcb7f337dce7e42df" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, the character will be read without waiting for a newline.</source>
          <target state="translated">当使用终端式交互时,将不等待换行而读取字符。</target>
        </trans-unit>
        <trans-unit id="cd853bf83ba1d969da74857a9ebfd7f6908aaf91" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, these functions return &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="translated">使用终端风格的交互时，如果用户在输入文本为空时按下 &lt;code&gt;Ctrl-D&lt;/code&gt; ，则这些函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="bd410ab3f115e8c24b1b1823fdc91cadf6703bb8" translate="yes" xml:space="preserve">
          <source>When using terminal-style interaction, they return &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the user pressed &lt;code&gt;Ctrl-D&lt;/code&gt; when the input text was empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281059d7f6e369f72746883abde7604d2dfc5db0" translate="yes" xml:space="preserve">
          <source>When using the flag &lt;a href=&quot;#ghc-flag--fexternal-interpreter&quot;&gt;&lt;code&gt;-fexternal-interpreter&lt;/code&gt;&lt;/a&gt; GHC will spawn and communicate with the separate process using pipes. There are scenarios (e.g. when cross compiling) where it is favourable to have the communication happen over the network. GHC provides two utilities for this, which can be found in the &lt;code&gt;utils&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd57bd1b21cb371408a146a00b6a306e283b88" translate="yes" xml:space="preserve">
          <source>When value is used as argument to FFI call that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c6027894ef61bcf91124d10e3eef03de412978" translate="yes" xml:space="preserve">
          <source>When values are communicated across different processes running in possibly different machines, though, addresses are no longer useful since each process may use different addresses to store a given value.</source>
          <target state="translated">当值在可能不同的机器上运行的不同进程之间进行通信时,地址不再有用,因为每个进程可能使用不同的地址来存储一个给定的值。</target>
        </trans-unit>
        <trans-unit id="164421b9045a7b0ff2139ae4ebd687298951b8b9" translate="yes" xml:space="preserve">
          <source>When we render it later, we find out how many columns or rows this cell will span over, and can include the correct colspan/rowspan command.</source>
          <target state="translated">当我们稍后渲染时,我们会发现这个单元格将跨越多少列或多少行,并可以包含正确的colspan/rowspan命令。</target>
        </trans-unit>
        <trans-unit id="b8052f24d2eaf1fd5c342df6de26c22ad2b7224c" translate="yes" xml:space="preserve">
          <source>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension makes use of postfix hash signs; if &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; are both enabled then &lt;code&gt;x#y&lt;/code&gt; means &lt;code&gt;x# y&lt;/code&gt;, but if only &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; is enabled then it means &lt;code&gt;x #y&lt;/code&gt;. The &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension makes &lt;code&gt;(#&lt;/code&gt; a single lexeme, so when &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">写入重载标签时，哈希符号和以下标识符之间必须没有空格。该&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;扩展使用的后缀哈希迹象; 如果同时启用了&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;x#y&lt;/code&gt; 表示 &lt;code&gt;x# y&lt;/code&gt; ，但是如果仅启用&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;，则表示 &lt;code&gt;x #y&lt;/code&gt; 。该&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;延伸品牌 &lt;code&gt;(#&lt;/code&gt; 单一语义，所以当&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;启用你必须写一个左括号和一个重载的标签之间的空间，为避免混淆，强烈建议您使用时哈希前加一个空格&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f52e2d04faeecc40cecea586540fae1407e0451" translate="yes" xml:space="preserve">
          <source>When you are &lt;em&gt;really&lt;/em&gt; desperate for speed, and you want to get right down to the &amp;ldquo;raw bits.&amp;rdquo; Please see &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for some information about using unboxed types.</source>
          <target state="translated">当您&lt;em&gt;真的&lt;/em&gt;急于追求速度时，又想直接了解&amp;ldquo;原始数据&amp;rdquo;。请参阅&lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;无盒装类型&lt;/a&gt;有关使用未装箱的类型的一些信息。</target>
        </trans-unit>
        <trans-unit id="8ae25a834e5b9af5625d4c5bdef0679b495c5a68" translate="yes" xml:space="preserve">
          <source>When you call a &lt;code&gt;foreign import&lt;/code&gt;ed function that is annotated as &lt;code&gt;safe&lt;/code&gt; (the default), and the program was linked using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the call will run concurrently with other running Haskell threads. If the program was linked without &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, then the other Haskell threads will be blocked until the call returns.</source>
          <target state="translated">当您调用一个被标注为 &lt;code&gt;safe&lt;/code&gt; （默认）的 &lt;code&gt;foreign import&lt;/code&gt; 函数，并且该程序使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;链接时，该调用将与其他正在运行的Haskell线程同时运行。如果程序链接时没有&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;，则其他Haskell线程将被阻塞，直到调用返回。</target>
        </trans-unit>
        <trans-unit id="c9bec1484ff46ebffcf0d58f51a86286452bad92" translate="yes" xml:space="preserve">
          <source>When you compile a simple module that contains Template Haskell splice</source>
          <target state="translated">当你编译一个包含Template Haskell拼接的简单模块时。</target>
        </trans-unit>
        <trans-unit id="e7650dc240cb434bb030bda401dba4a954a1073e" translate="yes" xml:space="preserve">
          <source>When you compile any module that import &lt;code&gt;Wibble&lt;/code&gt;, GHC will print the specified message.</source>
          <target state="translated">当您编译导入 &lt;code&gt;Wibble&lt;/code&gt; 的任何模块时，GHC将打印指定的消息。</target>
        </trans-unit>
        <trans-unit id="3c9c538e894128d5d4c68b823005c2cf1c3ad137" translate="yes" xml:space="preserve">
          <source>When you compile any module that imports and uses any of the specified entities, GHC will print the specified message.</source>
          <target state="translated">当你编译任何导入和使用任何指定实体的模块时,GHC将打印指定的消息。</target>
        </trans-unit>
        <trans-unit id="567466d774adb8b1c440d181ca9305cf23a350ff" translate="yes" xml:space="preserve">
          <source>When you define an abstract type using &lt;code&gt;newtype&lt;/code&gt;, you may want the new type to inherit some instances from its representation. In Haskell 98, you can inherit instances of &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Bounded&lt;/code&gt; by deriving them, but for any other classes you have to write an explicit instance declaration. For example, if you define</source>
          <target state="translated">当您使用 &lt;code&gt;newtype&lt;/code&gt; 定义抽象类型时，您可能希望新类型从其表示形式继承某些实例。在Haskell 98中，可以通过派生它们继承 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Enum&lt;/code&gt; 和 &lt;code&gt;Bounded&lt;/code&gt; 的实例，但是对于任何其他类，您都必须编写一个显式的实例声明。例如，如果您定义</target>
        </trans-unit>
        <trans-unit id="4db8b4bc778271b762bd25c6d49d66994f97cf55" translate="yes" xml:space="preserve">
          <source>When you load a Haskell source module into GHCi, it is normally converted to byte-code and run using the interpreter. However, interpreted code can also run alongside compiled code in GHCi; indeed, normally when GHCi starts, it loads up a compiled copy of the &lt;code&gt;base&lt;/code&gt; package, which contains the &lt;code&gt;Prelude&lt;/code&gt;.</source>
          <target state="translated">将Haskell源模块加载到GHCi中时，通常会将其转换为字节码并使用解释器运行。但是，解释的代码也可以与GHCi中的编译代码一起运行。实际上，通常在GHCi启动时，它会加载 &lt;code&gt;base&lt;/code&gt; 包的编译副本，其中包含 &lt;code&gt;Prelude&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bae6cc0177e18e9dda3c2fed6840139044a5c6c1" translate="yes" xml:space="preserve">
          <source>When you then compile a module containing the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3559cf1d022bd990f33b1b08c3cafdb8e9afbb" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, GHCi immediately evaluates and prints the result:</source>
          <target state="translated">当你在提示下键入一个表达式时,GHCi会立即评估并打印结果。</target>
        </trans-unit>
        <trans-unit id="64be75cf1ef59b697441b229fe9e2836346d4441" translate="yes" xml:space="preserve">
          <source>When you type an expression at the prompt, what identifiers and types are in scope? GHCi provides a flexible way to control exactly how the context for an expression is constructed:</source>
          <target state="translated">当你在提示下键入一个表达式时,哪些标识符和类型在范围内?GHCi提供了一种灵活的方式来控制表达式的上下文是如何构造的。</target>
        </trans-unit>
        <trans-unit id="300118fcee4db4ed760ae986f630aefbad34e21e" translate="yes" xml:space="preserve">
          <source>When you use pattern matching, the bound variables may now have polymorphic types. For example:</source>
          <target state="translated">当您使用模式匹配时,绑定变量现在可能具有多态类型。例如</target>
        </trans-unit>
        <trans-unit id="6f8d8bb42f16b3da3a349af9c92dad05b06dd2ee" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">当您要获取资源时，请先进行一些处理，然后再释放资源，最好使用方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，因为在发生异常的情况下，方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将安装必要的异常处理程序以释放资源。计算。如果引发异常，则 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将重新引发异常（执行发行后）。</target>
        </trans-unit>
        <trans-unit id="c049dc678d480c76ff954530cdc614fe1ebbe506" translate="yes" xml:space="preserve">
          <source>When you want to acquire a resource, do some work with it, and then release the resource, it is a good idea to use &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;, because &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will install the necessary exception handler to release the resource in the event that an exception is raised during the computation. If an exception is raised, then &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; will re-raise the exception (after performing the release).</source>
          <target state="translated">当您要获取资源时，请先进行一些处理，然后再释放资源，最好使用方 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ，因为在发生异常的情况下，方 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将安装必要的异常处理程序以释放资源。计算。如果引发异常，则 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 将重新引发异常（执行发行后）。</target>
        </trans-unit>
        <trans-unit id="249525af7212f050bf5fdbeb811fdfb4908f2a9d" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that needs semantic information about the source code, use the &lt;code&gt;typeCheckResultAction&lt;/code&gt; field. For example, if your plugin have to decide if two names are referencing the same definition or it has to check the type of a function it is using semantic information. In this case you need to access the renamed or type checked version of the syntax tree with &lt;code&gt;typeCheckResultAction&lt;/code&gt; or &lt;code&gt;renamedResultAction&lt;/code&gt;.</source>
          <target state="translated">当您想要定义需要有关源代码的语义信息的插件时，请使用 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 字段。例如，如果您的插件必须确定两个名称是否引用相同的定义，或者必须检查使用语义信息的函数的类型。在这种情况下，您需要使用 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 或 &lt;code&gt;renamedResultAction&lt;/code&gt; 访问语法树的重命名或类型检查版本。</target>
        </trans-unit>
        <trans-unit id="e8fe30721d6b432965074489bc3726a88917b0e0" translate="yes" xml:space="preserve">
          <source>When you want to define a plugin that uses the syntax tree of the source code, you would like to override the &lt;code&gt;parsedResultAction&lt;/code&gt; field. This access point enables you to get access to information about the lexical tokens and comments in the source code as well as the original syntax tree of the compiled module.</source>
          <target state="translated">当您想要定义使用源代码语法树的插件时，您想覆盖 &lt;code&gt;parsedResultAction&lt;/code&gt; 字段。通过此访问点，您可以访问源代码中有关词法标记和注释以及已编译模块的原始语法树的信息。</target>
        </trans-unit>
        <trans-unit id="e543c374d47b471dbe2efd6078fe8cf550ec9207" translate="yes" xml:space="preserve">
          <source>When your Haskell program starts up, the RTS extracts command-line arguments bracketed between &lt;code&gt;+RTS&lt;/code&gt; and &lt;code&gt;-RTS&lt;/code&gt; as its own. For example:</source>
          <target state="translated">当您的Haskell程序启动时，RTS会提取在 &lt;code&gt;+RTS&lt;/code&gt; 和 &lt;code&gt;-RTS&lt;/code&gt; 之间括起来的命令行参数。例如：</target>
        </trans-unit>
        <trans-unit id="67bf3606d400ce5b177e9762927a5c109ac5e19d" translate="yes" xml:space="preserve">
          <source>WhenDrained</source>
          <target state="translated">WhenDrained</target>
        </trans-unit>
        <trans-unit id="e3a34451dd67f293af2a89a92401a8412dbe43b2" translate="yes" xml:space="preserve">
          <source>WhenFlushed</source>
          <target state="translated">WhenFlushed</target>
        </trans-unit>
        <trans-unit id="b5a830f7421bf6868e75207a0e5bf40a97c9c44a" translate="yes" xml:space="preserve">
          <source>WhenMatched</source>
          <target state="translated">WhenMatched</target>
        </trans-unit>
        <trans-unit id="85837f4ffd7d1be1f725c2bc3996bbc73b76528c" translate="yes" xml:space="preserve">
          <source>WhenMissing</source>
          <target state="translated">WhenMissing</target>
        </trans-unit>
        <trans-unit id="4a8f1834d6ef2353620487d216c7f8343d17ac83" translate="yes" xml:space="preserve">
          <source>Whenever an expression (or a non-binding statement, to be precise) is typed at the prompt, GHCi implicitly binds its value to the variable &lt;code&gt;it&lt;/code&gt;. For example:</source>
          <target state="translated">每当在提示符下键入表达式（准确地说是非绑定语句）时，GHCi就会将其值隐式绑定到变量 &lt;code&gt;it&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="caf48a636e257653f0ce5e287572abc7356459df" translate="yes" xml:space="preserve">
          <source>Whenever there is no export list and a data instance is defined, the corresponding data family type constructor is exported along with the new data constructors, regardless of whether the data family is defined locally or in another module.</source>
          <target state="translated">每当没有导出列表而定义了一个数据实例时,不管数据族是在本地还是在其他模块中定义的,对应的数据族类型构造函数都会和新的数据构造函数一起导出。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="9c8435980d0a28f1bae7f3e146297acca6be6647" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@Int&lt;/code&gt; utilizes visible type application (&lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) to instantiate the &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt;. In order for this type application to work, the default type signature for &lt;code&gt;bar&lt;/code&gt; must have the same type variable order as the non-default signature! But there is no obligation for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;C'&lt;/code&gt; to be the same (see, for instance, the &lt;code&gt;Enum&lt;/code&gt; example above, which relies on this).</source>
          <target state="translated">凡 &lt;code&gt;@Int&lt;/code&gt; 采用可见式应用（&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型的应用程序&lt;/a&gt;），以实例化 &lt;code&gt;b&lt;/code&gt; 在 &lt;code&gt;default bar :: forall b. C' =&amp;gt; a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 。为了使此类型应用程序正常工作， &lt;code&gt;bar&lt;/code&gt; 的默认类型签名必须与非默认签名具有相同的类型变量顺序！但是， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;C'&lt;/code&gt; 不必相同（例如，参见上面依赖此的 &lt;code&gt;Enum&lt;/code&gt; 示例）。</target>
        </trans-unit>
        <trans-unit id="1e0b35957734f5fe542ba29ec49c8ef55e2f5be3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;TypedHole&lt;/code&gt; contains all the information about the hole available to GHC at error generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b355b1ff69acd8ba68909a327dda7911de5cd33" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fromPureHFPlugin :: HoleFitPlugin -&amp;gt; HoleFitPluginR&lt;/code&gt; is a convencience function provided in the &lt;code&gt;TcHoleErrors&lt;/code&gt; module, for defining plugins that do not require internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f17bb63198ef7feb43dac0d61debf172df85e3" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;v&lt;/code&gt; is a binary encoded data structure. To reconstruct the original data, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">其中 &lt;code&gt;v&lt;/code&gt; 是二进制编码的数据结构。为了重建原始数据，我们使用 &lt;code&gt;&lt;a href=&quot;data-binary#v:decode&quot;&gt;decode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a5c9769e817dcef676d11da0257e6662b614a31" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-MultiParamTypeClasses&quot;&gt;&lt;code&gt;MultiParamTypeClasses&lt;/code&gt;&lt;/a&gt; the syntax becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce6492e88d7c0e67ae730fd2da2ff05ab6b8829" translate="yes" xml:space="preserve">
          <source>Where GHC allows extensions instance declarations we allow exactly the same extensions to this new form of &lt;code&gt;class&lt;/code&gt;. Specifically, with &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; the syntax becomes</source>
          <target state="translated">在GHC允许扩展实例声明的地方，我们允许对这种新形式的 &lt;code&gt;class&lt;/code&gt; 进行完全相同的扩展。具体来说，使用&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;MultiParameterTypeClasses&lt;/code&gt; ，语法变为</target>
        </trans-unit>
        <trans-unit id="119b25e4a44f4363c91bab300cb5d3c21159a0c4" translate="yes" xml:space="preserve">
          <source>Where possible application should instead use the functions from the normal public interface modules, such as &lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;. Packages that extend the ByteString system at a low level will need to use this module.</source>
          <target state="translated">在可能的情况下，应用程序应该改用普通公共接口模块中的函数，例如&lt;a href=&quot;data-bytestring-unsafe&quot;&gt;Data.ByteString.Unsafe&lt;/a&gt;。在较低级别扩展ByteString系统的软件包将需要使用此模块。</target>
        </trans-unit>
        <trans-unit id="28a5f2c7899da41cf2b30e3484e32e247011b12b" translate="yes" xml:space="preserve">
          <source>Where to find user-supplied libraries&amp;hellip; Prepend the directory ⟨dir⟩ to the library directories path.</source>
          <target state="translated">在哪里可以找到用户提供的库...在目录dir之前添加库目录路径。</target>
        </trans-unit>
        <trans-unit id="4b69f3cdc8337627a604c112cd01620bf01f90d3" translate="yes" xml:space="preserve">
          <source>Where to read/write the history at the start and end of each line input session.</source>
          <target state="translated">在每个行输入会话的开始和结束时,在哪里读/写历史记录。</target>
        </trans-unit>
        <trans-unit id="1981ad10ebd01a8e615f59e69020850e9ef13f0a" translate="yes" xml:space="preserve">
          <source>Where ⟨identifier⟩ names any top-level function in an interpreted module currently loaded into GHCi (qualified names may be used). The breakpoint will be set on the body of the function, when it is fully applied but before any pattern matching has taken place.</source>
          <target state="translated">其中⟨identifier⟩命名当前加载到GHCi中的解释模块中的任何顶层函数(可以使用限定名)。断点将设置在函数的主体上,当函数完全应用时,但在任何模式匹配发生之前。</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="049fc25e78f6afdbd388cf57a387b11cef31e7dc" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caa47fca8dd3c62f35fc11b01eaa96f882480b71" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;data-functor#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b51f4b74b077d5755f8433714e1f30aa5298123" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; is function application, &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; is function application lifted over a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">而 &lt;code&gt;&lt;a href=&quot;prelude#v:-36-&quot;&gt;$&lt;/a&gt;&lt;/code&gt; 是功能应用， &lt;code&gt;&lt;a href=&quot;prelude#v:-60--36--62-&quot;&gt;&amp;lt;$&amp;gt;&lt;/a&gt;&lt;/code&gt; 是提升在功能应用 &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2391dfe6e87f39cd8831803ba3a82d5d030f016a" translate="yes" xml:space="preserve">
          <source>Whereas in Haskell, one can think of a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; as containing or producing values, a contravariant functor is a functor that can be thought of as &lt;em&gt;consuming&lt;/em&gt; values.</source>
          <target state="translated">在Haskell中，人们可以将 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 视为包含或产生价值的事物，而逆变Functor是可以被视为&lt;em&gt;消费&lt;/em&gt;价值的Functor的事物。</target>
        </trans-unit>
        <trans-unit id="4d016ebb7bdaebeb5306ca5849a24bae4ca1ec80" translate="yes" xml:space="preserve">
          <source>Whereas lists can be either finite or infinite, sequences are always finite. As a result, a sequence is strict in its length. Ignoring efficiency, you can imagine that &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; is defined</source>
          <target state="translated">列表可以是有限的，也可以是无限的，而序列始终是有限的。结果，序列的长度严格。忽略效率，您可以想象定义了 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdc8ec3f7ee56458f260af50693aaac977a201e6" translate="yes" xml:space="preserve">
          <source>Whether hyperthreading cores should be counted or not is an open question; please feel free to experiment and let us know what results you find.</source>
          <target state="translated">超线程核心是否应该被计算,这是一个开放性的问题;请自由实验,让我们知道你发现的结果。</target>
        </trans-unit>
        <trans-unit id="66801e4f80c3b7a16955a237c3bf448183edeab5" translate="yes" xml:space="preserve">
          <source>Whether the cost-centre is a Constant Applicative Form (CAF)</source>
          <target state="translated">成本中心是否为恒定申请表格(CAF)</target>
        </trans-unit>
        <trans-unit id="11104aa4a744d52bd7c0999ec612af4851cf2197" translate="yes" xml:space="preserve">
          <source>Whether the match comes from the original set of data constructors or from a &lt;code&gt;COMPLETE&lt;/code&gt; pragma (prioritizing the former over the latter)</source>
          <target state="translated">匹配是来自原始数据构造函数集还是来自 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示（优先于前者而不是后者）</target>
        </trans-unit>
        <trans-unit id="230a4413de0537cea8d9ec2877c30a55033608d8" translate="yes" xml:space="preserve">
          <source>Whether this will hold depends on the version of GHC you are using, the platform you are working on, the data you are working with, and the encodings you are using, so be sure to test for yourself.</source>
          <target state="translated">这是否成立取决于你所使用的GHC版本,你所使用的平台,你所使用的数据,以及你所使用的编码,所以一定要自己测试。</target>
        </trans-unit>
        <trans-unit id="8aa482f6c9341f17a1a9796f3f02d27bb35a59c2" translate="yes" xml:space="preserve">
          <source>Whether this word should be followed by a space, end quote, etc.</source>
          <target state="translated">这个词后面是否要加空格、尾引号等。</target>
        </trans-unit>
        <trans-unit id="f99bebb47706eeefe9a474724fc618196fe22ef5" translate="yes" xml:space="preserve">
          <source>Whether to insist on a plus sign for positive numbers.</source>
          <target state="translated">是否坚持正数加号。</target>
        </trans-unit>
        <trans-unit id="fe33c801c0417a8767d8d17cfe9ac51b4866f4fc" translate="yes" xml:space="preserve">
          <source>Whether to left-adjust or zero-pad a field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">是将字段左调整还是零填充。这些是互斥的，其中 &lt;code&gt;&lt;a href=&quot;text-printf#v:LeftAdjust&quot;&gt;LeftAdjust&lt;/a&gt;&lt;/code&gt; 优先。</target>
        </trans-unit>
        <trans-unit id="50e1188ad2a43d64fcd2e27a8734973b6df939f0" translate="yes" xml:space="preserve">
          <source>Whether to show snippets of original source code</source>
          <target state="translated">是否显示原始源代码的片段</target>
        </trans-unit>
        <trans-unit id="031f1ff677db72c9b7bb19eb8c07b63bd63186b4" translate="yes" xml:space="preserve">
          <source>Which &lt;code&gt;COMPLETE&lt;/code&gt; pragma should be used when checking the coverage of the patterns in &lt;code&gt;f&lt;/code&gt;? If we pick the &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is exhaustive, but if we pick the other &lt;code&gt;COMPLETE&lt;/code&gt; set that covers &lt;code&gt;MkT1&lt;/code&gt; and &lt;code&gt;MkT2Internal&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exhaustive, since it fails to match &lt;code&gt;MkT2Internal&lt;/code&gt;. An intuitive way to solve this dilemma is to recognize that picking the former &lt;code&gt;COMPLETE&lt;/code&gt; set produces the fewest number of uncovered pattern clauses, and thus is the better choice.</source>
          <target state="translated">检查 &lt;code&gt;f&lt;/code&gt; 中模式的覆盖范围时应使用哪个 &lt;code&gt;COMPLETE&lt;/code&gt; 编译指示？如果我们选择的 &lt;code&gt;COMPLETE&lt;/code&gt; 集合覆盖 &lt;code&gt;MkT1&lt;/code&gt; 和 &lt;code&gt;MkT2&lt;/code&gt; ，然后 &lt;code&gt;f&lt;/code&gt; 是详尽的，但如果我们选择其他 &lt;code&gt;COMPLETE&lt;/code&gt; 集，涵盖 &lt;code&gt;MkT1&lt;/code&gt; 和 &lt;code&gt;MkT2Internal&lt;/code&gt; ，然后 &lt;code&gt;f&lt;/code&gt; 是&lt;em&gt;没有&lt;/em&gt;穷尽的，因为它不能匹配 &lt;code&gt;MkT2Internal&lt;/code&gt; 。解决此难题的一种直观方法是认识到选择前一个 &lt;code&gt;COMPLETE&lt;/code&gt; 集会产生最少数量的未发现模式子句，因此是更好的选择。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a71258173217130f4a9607567a3b31c7a9c9b61" translate="yes" xml:space="preserve">
          <source>Which enables us to rewrite our functions in a much cleaner style:</source>
          <target state="translated">这使得我们能够以更简洁的风格重写我们的函数。</target>
        </trans-unit>
        <trans-unit id="270bd9f0b9fd2ad297b3a040aac947ac8bf09b75" translate="yes" xml:space="preserve">
          <source>Which generation is being garbage collected.</source>
          <target state="translated">哪一代人在收集垃圾。</target>
        </trans-unit>
        <trans-unit id="2916973ac665681d37f869721212befa6a8ea0a2" translate="yes" xml:space="preserve">
          <source>Which shows that the hole could be replaced with e.g. &lt;code&gt;foldl1 _&lt;/code&gt;. While not fixing the hole, this can help users understand what options they have.</source>
          <target state="translated">这表明该孔可以替换为 &lt;code&gt;foldl1 _&lt;/code&gt; 。在不固定孔的同时，这可以帮助用户了解他们有哪些选择。</target>
        </trans-unit>
        <trans-unit id="27f2f23bcde10c66a5f5e9d8aafa47b4840854e9" translate="yes" xml:space="preserve">
          <source>Which will produce the following compile-time error,</source>
          <target state="translated">这将产生以下编译时错误。</target>
        </trans-unit>
        <trans-unit id="7c1db43b33397020a8ed5957fa5d9d38875398ba" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; will force evaluation of all the list elements:</source>
          <target state="translated">虽然 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 将强制评估所有列表元素：</target>
        </trans-unit>
        <trans-unit id="8c332ca7e19d20c8fa57c56fd1a11cc1b3adb5fc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; allows using quoting (i.e., convenient escaping of many characters) by having matching sets of single- or double-quotes,&lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; does not use the quoting mechasnism, and thus will always escape any whitespace, quotes, and backslashes.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:unescapeArgs&quot;&gt;unescapeArgs&lt;/a&gt;&lt;/code&gt; 允许通过具有匹配的单引号或双引号集来使用引号（即，方便地转义多个字符），但 &lt;code&gt;&lt;a href=&quot;ghc-responsefile#v:escapeArgs&quot;&gt;escapeArgs&lt;/a&gt;&lt;/code&gt; 不使用引号机制，因此将始终转义任何空白，引号和反斜杠。</target>
        </trans-unit>
        <trans-unit id="81b625ad3235f180ec5913cc634ab52ecae12b67" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;INLINE&lt;/code&gt; says &amp;ldquo;please inline me&amp;rdquo;, the &lt;code&gt;INLINABLE&lt;/code&gt; says &amp;ldquo;feel free to inline me; use your discretion&amp;rdquo;. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike &lt;code&gt;INLINE&lt;/code&gt;, that decision is made at the &lt;em&gt;call site&lt;/em&gt;, and will therefore be affected by the inlining threshold, optimisation level etc.</source>
          <target state="translated">当 &lt;code&gt;INLINE&lt;/code&gt; 说&amp;ldquo;请向我内联&amp;rdquo;时， &lt;code&gt;INLINABLE&lt;/code&gt; 说&amp;ldquo;请随意向我内联；自行决定&amp;rdquo;。换句话说，选择权留给了GHC，它使用与无编译功能相同的规则。与 &lt;code&gt;INLINE&lt;/code&gt; 不同，该决定是在&lt;em&gt;呼叫站点&lt;/em&gt;做出的，因此会受到内联阈值，优化级别等的影响。</target>
        </trans-unit>
        <trans-unit id="c6ee9afc23b83e42b01663a5ce2d75b90b1d7053" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;a + b&lt;/code&gt; is parsed as &lt;code&gt;(+) a b&lt;/code&gt; and becomes a binding position for the &lt;code&gt;(+)&lt;/code&gt; type operator, &lt;code&gt;a * b&lt;/code&gt; is parsed as &lt;code&gt;a (*) b&lt;/code&gt; and is rejected.</source>
          <target state="translated">当 &lt;code&gt;a + b&lt;/code&gt; 被解析为 &lt;code&gt;(+) a b&lt;/code&gt; 并成为 &lt;code&gt;(+)&lt;/code&gt; 类型运算符的绑定位置时， &lt;code&gt;a * b&lt;/code&gt; 被解析为 &lt;code&gt;a (*) b&lt;/code&gt; 并被拒绝。</target>
        </trans-unit>
        <trans-unit id="dca826ec4b4920b6625508b06645e0892b105a31" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; uses &lt;code&gt;k&lt;/code&gt; without introducing it and thus violates the rule, it is currently accepted. This is because &lt;code&gt;k&lt;/code&gt; in &lt;code&gt;n&lt;/code&gt; is considered a kind variable, as it occurs in a kind signature. In reality, the line between type variables and kind variables is blurry, as the following example demonstrates:</source>
          <target state="translated">尽管 &lt;code&gt;n&lt;/code&gt; 在不引入 &lt;code&gt;k&lt;/code&gt; 的情况下使用k，因此违反了规则，但当前已被接受。这是因为 &lt;code&gt;k&lt;/code&gt; 在 &lt;code&gt;n&lt;/code&gt; 被认为是一种可变的，因为它在一种出现签名。实际上，类型变量和种类变量之间的界线是模糊的，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="89d044abb31d0358bb574168c9340e2f2b315fbc" translate="yes" xml:space="preserve">
          <source>While GHC is keen to inline the function, it does not do so blindly. For example, if you write</source>
          <target state="translated">虽然GHC热衷于内嵌函数,但并不盲目内嵌。例如,如果你写</target>
        </trans-unit>
        <trans-unit id="3add16df5fe36ab800dc2ff2e76070f38ee83e1d" translate="yes" xml:space="preserve">
          <source>While Safe Haskell is an extension, it actually runs in the background for every compilation with GHC. It does this to track the type violations of modules to infer their safety, even when they aren&amp;rsquo;t explicitly using Safe Haskell. Please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details of this.</source>
          <target state="translated">尽管Safe Haskell是扩展，但实际上它在GHC的每次编译中都在后台运行。它这样做是为了跟踪模块的类型冲突，以推断其安全性，即使它们未明确使用Safe Haskell也是如此。有关更多详细信息，请参阅&amp;ldquo; &lt;a href=&quot;#safe-inference&quot;&gt;安全Haskell推论&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="35b0013a13db3b6fdc98ef77d44fddaaca3cc7cb" translate="yes" xml:space="preserve">
          <source>While a primary use case of Safe Haskell is running untrusted code, Safe Haskell doesn&amp;rsquo;t provide this directly. Instead, Safe Haskell provides strict type safety. Without Safe Haskell, GHC allows many exceptions to the type system which can subvert any abstractions. By providing strict type safety, Safe Haskell enables developers to build their own library level sandbox mechanisms to run untrusted code.</source>
          <target state="translated">尽管Safe Haskell的主要用例正在运行不受信任的代码，但Safe Haskell不会直接提供此代码。相反，Safe Haskell提供了严格的类型安全性。没有Safe Haskell，GHC会允许类型系统有许多异常，这些异常可以颠覆任何抽象。通过提供严格的类型安全性，Safe Haskell使开发人员能够构建自己的库级别沙箱机制来运行不受信任的代码。</target>
        </trans-unit>
        <trans-unit id="def095ee0284bcac4322f43e6852c970ad41b290" translate="yes" xml:space="preserve">
          <source>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See &lt;a href=&quot;#type-family-declarations&quot;&gt;Type family declarations&lt;/a&gt; for more information about arity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc21bcd88342a5bb609c83c4f4a251417917aeff" translate="yes" xml:space="preserve">
          <source>While developing, sometimes it is desirable to allow compilation to succeed even if there are type errors in the code. Consider the following case:</source>
          <target state="translated">在开发时,有时即使代码中存在类型错误,也希望允许编译成功。考虑以下情况。</target>
        </trans-unit>
        <trans-unit id="91465cfe2041d24f0183967b4edb1cd4e56225f7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;#12356&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d4576ffb50b0fa9daa17cbe0afb23508da41b7" translate="yes" xml:space="preserve">
          <source>While modules loaded in GHCi with the &lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command may use &lt;a href=&quot;#extension-StaticPointers&quot;&gt;&lt;code&gt;StaticPointers&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;static&lt;/code&gt; expressions, statements entered on the REPL may not. This is a limitation of GHCi; see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;Issue #12356&lt;/a&gt; for details.</source>
          <target state="translated">虽然通过&lt;a href=&quot;ghci#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令在GHCi中加载的模块可以使用&lt;a href=&quot;#extension-StaticPointers&quot;&gt; &lt;code&gt;StaticPointers&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;static&lt;/code&gt; 表达式，但在REPL上输入的语句可能不使用。这是GHCi的局限性；有关详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/12356&quot;&gt;问题＃12356&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97f98250e481ccf0975daf7dab8b3fe176183423" translate="yes" xml:space="preserve">
          <source>While running a program with profiling turned on, GHC maintains a cost-centre stack behind the scenes, and attributes any costs (memory allocation and time) to whatever the current cost-centre stack is at the time the cost is incurred.</source>
          <target state="translated">在运行程序时,如果开启了剖析功能,GHC会在幕后维护一个成本中心堆栈,并将任何成本(内存分配和时间)归因于成本发生时的任何当前成本中心堆栈。</target>
        </trans-unit>
        <trans-unit id="976e206b9026791ffd0e6fb58a4293cf7ea81bb6" translate="yes" xml:space="preserve">
          <source>While stopped at the breakpoint on line 2 that we set earlier, we started a new evaluation with &lt;code&gt;:step qsort [1,3]&lt;/code&gt;. This new evaluation stopped after one step (at the definition of &lt;code&gt;qsort&lt;/code&gt;). The prompt has changed, now prefixed with &lt;code&gt;...&lt;/code&gt;, to indicate that there are saved breakpoints beyond the current one. To see the stack of contexts, use &lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt;&lt;code&gt;:show context&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在我们先前设置的第2行的断点处停止时，我们使用 &lt;code&gt;:step qsort [1,3]&lt;/code&gt; 开始了新的评估。第一步（在 &lt;code&gt;qsort&lt;/code&gt; 的定义下）后，此新评估停止。提示已更改，现在以 &lt;code&gt;...&lt;/code&gt; 开头，以指示存在已保存的断点，超出了当前的断点。要查看上下文堆栈，请使用&lt;a href=&quot;#ghci-cmd-:show%20context&quot;&gt; &lt;code&gt;:show context&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b98a4c50da2ca10fa0d38e9a101fe3f3e6126a79" translate="yes" xml:space="preserve">
          <source>While the following definitions are rejected:</source>
          <target state="translated">虽然下列定义被拒绝:</target>
        </trans-unit>
        <trans-unit id="b1966b6c5939a4035f3d998424b60e02fda159f6" translate="yes" xml:space="preserve">
          <source>While these are flags, they also correspond to Safe Haskell module types that a module can have. You can think of using these as declaring an explicit contract (or type) that a module must have. If it is invalid, then compilation will fail. GHC will also infer the correct type for Safe Haskell, please refer to section &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell Inference&lt;/a&gt; for more details.</source>
          <target state="translated">尽管这些是标志，但它们也对应于模块可以具有的Safe Haskell模块类型。您可以考虑将它们用作声明模块必须具有的显式协定（或类型）。如果无效，则编译将失败。GHC还将为Safe Haskell推断正确的类型，请参阅&amp;ldquo; &lt;a href=&quot;#safe-inference&quot;&gt;Safe Haskell推断&amp;rdquo;&lt;/a&gt;部分以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="022ab35cfa47002a4ebdaca07f6e366ba8988d90" translate="yes" xml:space="preserve">
          <source>While these examples look similar, none of them would successfully compile. This is because all occurrences of the last type parameter &lt;code&gt;a&lt;/code&gt; occur in &lt;em&gt;contravariant&lt;/em&gt; positions, not covariant ones.</source>
          <target state="translated">虽然这些示例看起来很相似，但是没有一个可以成功编译。这是因为最后的类型出现的所有参数， &lt;code&gt;a&lt;/code&gt; 发生在&lt;em&gt;逆变&lt;/em&gt;位置，而不是协变的。</target>
        </trans-unit>
        <trans-unit id="75a5eda6c195abd9046975cac318fe63ebb5499d" translate="yes" xml:space="preserve">
          <source>While these functions have a stable API and you may use these functions in applications, do carefully consider the documented pre-conditions; incorrect use can break referential transparency or worse.</source>
          <target state="translated">虽然这些函数有一个稳定的API,你可以在应用程序中使用这些函数,但请仔细考虑文档中的前提条件;不正确的使用可能会破坏引用的透明度或更糟。</target>
        </trans-unit>
        <trans-unit id="b0aa0a8b0c40d44fe32076b2dde1270dea9d839c" translate="yes" xml:space="preserve">
          <source>While this is rather low level, it provides you with full flexibility in how the data is written out.</source>
          <target state="translated">虽然这是相当低级的,但它为你提供了如何写出数据的充分灵活性。</target>
        </trans-unit>
        <trans-unit id="9187e41f7f9137050f5d28dffbf78dde7c993814" translate="yes" xml:space="preserve">
          <source>Whilst a normal pattern synonym can be used in two ways, there are then seven ways in which to use &lt;code&gt;Point&lt;/code&gt;. Precisely the ways in which a normal record constructor can be used.</source>
          <target state="translated">虽然可以两种方式使用常规模式同义词，但是可以使用 &lt;code&gt;Point&lt;/code&gt; 的七种方式。精确地使用普通记录构造函数的方式。</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="83eb1c09c969cd3e57a811f38dd6447b18c3ead5" translate="yes" xml:space="preserve">
          <source>Why did I get a link error?</source>
          <target state="translated">为什么会出现链接错误?</target>
        </trans-unit>
        <trans-unit id="440e86b8976c4e4796fbf85e0f090b3bc6b09cbc" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;ghc-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;ghc-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="4b3d234dc0251109fb3ebae077fa379bf3b538ac" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;prelude#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;prelude#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="f3e75c0bb579876ee1ae6f6f75f665c7fa512d6b" translate="yes" xml:space="preserve">
          <source>Why do both &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; exist, and why does GHC opt to implement &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; in derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instances instead of &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt;? The reason is that &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; is based on the &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; type, and although &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; is mentioned in the Haskell 2010 Report, it is not a very efficient parser data structure.</source>
          <target state="translated">为什么 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 都存在，为什么GHC选择在派生的 &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; 实例中实现 &lt;code&gt;&lt;a href=&quot;text-read#v:readPrec&quot;&gt;readPrec&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; ？其原因是， &lt;code&gt;&lt;a href=&quot;text-read#v:readsPrec&quot;&gt;readsPrec&lt;/a&gt;&lt;/code&gt; 是根据 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的类型，虽然 &lt;code&gt;&lt;a href=&quot;text-read#t:ReadS&quot;&gt;ReadS&lt;/a&gt;&lt;/code&gt; 的哈斯克尔2010报告中提到，它不是一个非常有效的解析器的数据结构。</target>
        </trans-unit>
        <trans-unit id="86af37585c6c693fdc0ebac6c3d4e275681346c9" translate="yes" xml:space="preserve">
          <source>Why do we need this? Because if a foreign library is called from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;, it won't have access to any &lt;em&gt;thread-local state&lt;/em&gt; - state variables that have specific values for each OS thread (see POSIX's &lt;code&gt;pthread_key_create&lt;/code&gt; or Win32's &lt;code&gt;TlsAlloc&lt;/code&gt;). Therefore, some libraries (OpenGL, for example) will not work from a thread created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;. They work fine in threads created using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; or when called from &lt;code&gt;main&lt;/code&gt; or from a &lt;code&gt;foreign export&lt;/code&gt;.</source>
          <target state="translated">我们为什么需要这个？因为如果从使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程中调用外部库，则它将无法访问任何&lt;em&gt;线程局部状态&lt;/em&gt; -具有每个OS线程特定值的状态变量（请参阅POSIX的 &lt;code&gt;pthread_key_create&lt;/code&gt; 或Win32的 &lt;code&gt;TlsAlloc&lt;/code&gt; ）。因此，某些库（例如OpenGL）将无法通过使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程运行。在使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 创建的线程中，或者从 &lt;code&gt;main&lt;/code&gt; 或从 &lt;code&gt;foreign export&lt;/code&gt; 调用时，它们可以正常工作。</target>
        </trans-unit>
        <trans-unit id="bbbc60c133dcaa45a637190bca0c68db03dab6c1" translate="yes" xml:space="preserve">
          <source>Why might we want to do this? The main reason is that the RTS running the interpreted code can be a different flavour (profiling or dynamically-linked) from GHC itself. So for example:</source>
          <target state="translated">为什么我们要这样做呢?主要原因是运行解释代码的 RTS 可以是与 GHC 本身不同的风格(剖析或动态链接)。因此,举个例子。</target>
        </trans-unit>
        <trans-unit id="47b6a914e21ff5813991e6da748b083baff53cd8" translate="yes" xml:space="preserve">
          <source>Why should we want to run compiled code? Well, compiled code is roughly 10x faster than interpreted code, but takes about 2x longer to produce (perhaps longer if optimisation is on). So it pays to compile the parts of a program that aren&amp;rsquo;t changing very often, and use the interpreter for the code being actively developed.</source>
          <target state="translated">我们为什么要运行已编译的代码？好的，编译后的代码比解释后的代码快大约10倍，但生成时间要长大约2倍（如果启用了优化，则可能会更长）。因此，需要编译不经常更改的程序部分，并对正在积极开发的代码使用解释器，这是值得的。</target>
        </trans-unit>
        <trans-unit id="cc7d6ee8236b5733d37003f374fc603c874165c9" translate="yes" xml:space="preserve">
          <source>Width digits can also be used after any modifiers and before the specifier (here marked as &lt;code&gt;z&lt;/code&gt;), for example:</source>
          <target state="translated">宽度数字也可以在任何修饰符之后和说明符（在此标记为 &lt;code&gt;z&lt;/code&gt; ）之前使用，例如：</target>
        </trans-unit>
        <trans-unit id="6cc81c4740a7ec55686ef91e0c779bca9974a1fc" translate="yes" xml:space="preserve">
          <source>WildCardT</source>
          <target state="translated">WildCardT</target>
        </trans-unit>
        <trans-unit id="9dd4ee310008cd2a0ddc0df60850b2b849a28904" translate="yes" xml:space="preserve">
          <source>WildP</source>
          <target state="translated">WildP</target>
        </trans-unit>
        <trans-unit id="0bad7324dc674391ab667a3facf3ae0df9dc30be" translate="yes" xml:space="preserve">
          <source>Wildcards occurring within the monotype (tau) part of the type signature are &lt;em&gt;type wildcards&lt;/em&gt; (&amp;ldquo;type&amp;rdquo; is often omitted as this is the default kind of wildcard). Type wildcards can be instantiated to any monotype like &lt;code&gt;Bool&lt;/code&gt; or &lt;code&gt;Maybe [Bool]&lt;/code&gt;, including functions and higher-kinded types like &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;.</source>
          <target state="translated">在类型签名的单型（tau）部分中出现的&lt;em&gt;通配符&lt;/em&gt;是&lt;em&gt;类型通配符&lt;/em&gt;（通常会省略&amp;ldquo; type&amp;rdquo;，因为这是默认的通配符类型）。类型通配符可以实例化为任何单型，例如 &lt;code&gt;Bool&lt;/code&gt; 或 &lt;code&gt;Maybe [Bool]&lt;/code&gt; ，包括函数和种类繁多的类型，例如 &lt;code&gt;(Int -&amp;gt; Bool)&lt;/code&gt; Int- &amp;gt; Bool）或 &lt;code&gt;Maybe&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9658cea5793b3d031fa20c655bb68dd4c32b903a" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;#11197&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef392380581e1168eebb15a8a0e18150691c4d57" translate="yes" xml:space="preserve">
          <source>Will emit no output, despite the fact that the ill-typed term appears after the well-typed &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;Issue #11197&lt;/a&gt;.</source>
          <target state="translated">尽管将在正确键入的 &lt;code&gt;putStrLn &quot;Hi there.&quot;&lt;/code&gt; 之后出现错误键入的术语，但将不会输出任何内容。。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11197&quot;&gt;第11197期&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a1662f103a3266468f46e63fa2cf2f0cfd01bbf" translate="yes" xml:space="preserve">
          <source>Will raise two warnings because &lt;code&gt;Zero&lt;/code&gt; and &lt;code&gt;Succ&lt;/code&gt; are not written as &lt;code&gt;'Zero&lt;/code&gt; and &lt;code&gt;'Succ&lt;/code&gt;.</source>
          <target state="translated">将发出两个警告，因为 &lt;code&gt;Zero&lt;/code&gt; 和 &lt;code&gt;Succ&lt;/code&gt; 不会写为 &lt;code&gt;'Zero&lt;/code&gt; 和 &lt;code&gt;'Succ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c5ec9681ce2072b76c270f62f6f9eee48c28bf7" translate="yes" xml:space="preserve">
          <source>WindowClosure</source>
          <target state="translated">WindowClosure</target>
        </trans-unit>
        <trans-unit id="7e26c5824975ae8a63fa3abf0584b4efdb2b248d" translate="yes" xml:space="preserve">
          <source>WindowStyle</source>
          <target state="translated">WindowStyle</target>
        </trans-unit>
        <trans-unit id="9378a46e189b577aaeee3aa3a868039a552854b0" translate="yes" xml:space="preserve">
          <source>WindowStyleEx</source>
          <target state="translated">WindowStyleEx</target>
        </trans-unit>
        <trans-unit id="8a20bdc2dc7d2d8d4e84b9d92b1bb47619b3475f" translate="yes" xml:space="preserve">
          <source>Windows GUI-only programs have no stdin, stdout or stderr so using the ordinary Haskell input/output functions will cause your program to fail with an IO exception, such as:</source>
          <target state="translated">Windows GUI-only程序没有stdin、stdout或stderr,所以使用普通的Haskell输入/输出函数会导致你的程序以IO异常的方式失败,比如。</target>
        </trans-unit>
        <trans-unit id="5d6f840cad39d9a272a9703b68f0d38fb8222f38" translate="yes" xml:space="preserve">
          <source>Windows only: directory link</source>
          <target state="translated">仅限Windows:目录链接</target>
        </trans-unit>
        <trans-unit id="73d40c03f33c4a3de272ded5007d929ac7019282" translate="yes" xml:space="preserve">
          <source>Windows paths are not all the same. The different kinds of paths each have different meanings. The &lt;code&gt;MAX_PATH&lt;/code&gt; limitation is not a limitation of the operating system nor the file system. It is a limitation of the default namespace enforced by the Win32 API for backwards compatibility.</source>
          <target state="translated">Windows路径也不尽相同。不同种类的路径各有不同的含义。该 &lt;code&gt;MAX_PATH&lt;/code&gt; 限制是不是操作系统，也不是文件系统的限制。这是Win32 API为向后兼容而强制使用的默认名称空间的限制。</target>
        </trans-unit>
        <trans-unit id="48c423f5c542bd757cc0d8148840620479fe1d50" translate="yes" xml:space="preserve">
          <source>Windows systems</source>
          <target state="translated">Windows系统</target>
        </trans-unit>
        <trans-unit id="17b0e8d7184831d84e104c44677c17826487591f" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows特定的错误：如果文件系统不支持符号链接，则此操作可能失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae9664fed6d551c4afead4741b8d33a6823b9b7c" translate="yes" xml:space="preserve">
          <source>Windows-specific errors: This operation may fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; if the user lacks the privileges to create symbolic links. It may also fail with &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; if the file system does not support symbolic links.</source>
          <target state="translated">Windows特定的错误：如果用户缺乏创建符号链接的特权，则此操作可能会失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:permissionErrorType&quot;&gt;permissionErrorType&lt;/a&gt;&lt;/code&gt; 。如果文件系统不支持符号链接，它也可能会失败，并带有 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:illegalOperationErrorType&quot;&gt;illegalOperationErrorType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02de5f68b4be14e6f9c02d269cf51b2ebcc4d006" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，GHC自动将每个数据类型提升为一种类型，并将其（值）构造函数提升为类型构造函数。以下类型</target>
        </trans-unit>
        <trans-unit id="66de61afd3dce19c1e8432307fd1a6cdbb984d5b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, Haskell&amp;rsquo;s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，Haskell的列表和元组类型被本地提升为种类，并且在类型级别享受相同的方便语法，尽管前面加上了引号：</target>
        </trans-unit>
        <trans-unit id="ad73cf0a187d7c5263c3ed9059162402b019df7e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, the example above can then be rewritten to:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;，可以将上面的示例重写为：</target>
        </trans-unit>
        <trans-unit id="9694f3dae022beb52b1d2eae44907067122df68b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; you can derive any other class. The compiler will simply generate an instance declaration with no explicitly-defined methods. This is mostly useful in classes whose &lt;a href=&quot;#minimal-pragma&quot;&gt;minimal set&lt;/a&gt; is empty, and especially when writing &lt;a href=&quot;#generic-programming&quot;&gt;generic functions&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; ,&lt;/a&gt;您可以派生任何其他类。编译器将只生成一个没有显式定义的方法的实例声明。这在&lt;a href=&quot;#minimal-pragma&quot;&gt;最小集&lt;/a&gt;为空的类中尤其有用，尤其是在编写&lt;a href=&quot;#generic-programming&quot;&gt;泛型函数时&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05e8935b6c02826df72f7c768e1ec4453e94c14a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt;&lt;code&gt;DeriveDataTypeable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Data&lt;/code&gt;, defined in &lt;code&gt;Data.Data&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveDataTypeable&quot;&gt; &lt;code&gt;DeriveDataTypeable&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Data.Data&lt;/code&gt; 中定义的 &lt;code&gt;Data&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="ad9e3a1e0afdec73dafa2b178a39235fdd9bec14" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Foldable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 数据类型派生 &lt;code&gt;Foldable&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="4864b90fc425d7d78346fd4210a107b2e500fb2e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Foldable&lt;/code&gt;, defined in &lt;code&gt;Data.Foldable&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Data.Foldable&lt;/code&gt; 中定义的 &lt;code&gt;Foldable&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="671954f0f4d9ee0f1430a6541e8fa3672fbee0d2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Functor&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 类型的数据类型派生 &lt;code&gt;Functor&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="8a9d0c586e9f69c6ba34b372f93f09827c90392d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Functor&lt;/code&gt;, defined in &lt;code&gt;GHC.Base&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;，可以派生在 &lt;code&gt;GHC.Base&lt;/code&gt; 中定义的 &lt;code&gt;Functor&lt;/code&gt; 类的实例。</target>
        </trans-unit>
        <trans-unit id="70bde54b16dc89d95935abc8c585ccb864a45328" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveGeneric&quot;&gt;&lt;code&gt;DeriveGeneric&lt;/code&gt;&lt;/a&gt;, you can derive instances of the classes &lt;code&gt;Generic&lt;/code&gt; and &lt;code&gt;Generic1&lt;/code&gt;, defined in &lt;code&gt;GHC.Generics&lt;/code&gt;. You can use these to define generic functions, as described in &lt;a href=&quot;#generic-programming&quot;&gt;Generic programming&lt;/a&gt;.</source>
          <target state="translated">随着&lt;a href=&quot;#extension-DeriveGeneric&quot;&gt; &lt;code&gt;DeriveGeneric&lt;/code&gt; &lt;/a&gt;，可以派生类的实例 &lt;code&gt;Generic&lt;/code&gt; 和 &lt;code&gt;Generic1&lt;/code&gt; ，定义 &lt;code&gt;GHC.Generics&lt;/code&gt; 。您可以使用它们来定义通用函数，如&lt;a href=&quot;#generic-programming&quot;&gt;通用编程中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e5f52e040d0ae2ddbdd82b0a2735b846ecf5083" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveLift&quot;&gt;&lt;code&gt;DeriveLift&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Lift&lt;/code&gt;, defined in the &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; module of the &lt;code&gt;template-haskell&lt;/code&gt; package.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveLift&quot;&gt; &lt;code&gt;DeriveLift&lt;/code&gt; &lt;/a&gt;，您可以派生 &lt;code&gt;Lift&lt;/code&gt; 类的实例，该实例在 &lt;code&gt;template-haskell&lt;/code&gt; 包的 &lt;code&gt;Language.Haskell.TH.Syntax&lt;/code&gt; 模块中定义。</target>
        </trans-unit>
        <trans-unit id="4dc82d6ad448bf5d43bd791bf2a64d65052ded54" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, one can derive &lt;code&gt;Traversable&lt;/code&gt; instances for data types of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example, this declaration:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;，可以为Type- &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; 类型的数据类型派生 &lt;code&gt;Traversable&lt;/code&gt; 实例。例如，此声明：</target>
        </trans-unit>
        <trans-unit id="1bd07f0bfee4349fb82f2d04a2759ee937885c23" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt;, you can derive instances of the class &lt;code&gt;Traversable&lt;/code&gt;, defined in &lt;code&gt;Data.Traversable&lt;/code&gt;. Since the &lt;code&gt;Traversable&lt;/code&gt; instance dictates the instances of &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;, you&amp;rsquo;ll probably want to derive them too, so &lt;a href=&quot;#extension-DeriveTraversable&quot;&gt;&lt;code&gt;DeriveTraversable&lt;/code&gt;&lt;/a&gt; implies &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveFoldable&quot;&gt;&lt;code&gt;DeriveFoldable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;，可以派生在 &lt;code&gt;Data.Traversable&lt;/code&gt; 中定义的 &lt;code&gt;Traversable&lt;/code&gt; 类的实例。由于 &lt;code&gt;Traversable&lt;/code&gt; 实例指示 &lt;code&gt;Functor&lt;/code&gt; 和 &lt;code&gt;Foldable&lt;/code&gt; 的实例，因此您可能也想派生它们，因此&lt;a href=&quot;#extension-DeriveTraversable&quot;&gt; &lt;code&gt;DeriveTraversable&lt;/code&gt; &lt;/a&gt;暗含了&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#extension-DeriveFoldable&quot;&gt; &lt;code&gt;DeriveFoldable&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="559a00aea3f890980a1f984df90a03d7d63d1ade" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; you can use &lt;em&gt;unqualified&lt;/em&gt; field names even if the corresponding selector is only in scope &lt;em&gt;qualified&lt;/em&gt; For example, assuming the same module &lt;code&gt;M&lt;/code&gt; as in our earlier example, this is legal:</source>
          <target state="translated">使用&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;，即使相应的选择器仅在作用域&lt;em&gt;限定的&lt;/em&gt;范围内，您也可以使用&lt;em&gt;不合格的&lt;/em&gt;字段名称。例如，假定与我们前面的示例相同的模块 &lt;code&gt;M&lt;/code&gt; ，这是合法的：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d839e1b384cdeb1b20e6abc8876be37df3ce01a5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#extension-MultiWayIf&quot;&gt;&lt;code&gt;MultiWayIf&lt;/code&gt;&lt;/a&gt; extension GHC accepts conditional expressions with multiple branches:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-MultiWayIf&quot;&gt; &lt;code&gt;MultiWayIf&lt;/code&gt; &lt;/a&gt;扩展，GHC接受具有多个分支的条件表达式：</target>
        </trans-unit>
        <trans-unit id="a0d6333b42a8531a55b6ff2108e890fa59726fab" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-maxN⟨x⟩&lt;/code&gt;, i.e. &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt;, the runtime will choose at most (x), also limited by the number of processors on the system. Omitting (x) is an error, if you need a default use option &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;-maxN⟨x⟩&lt;/code&gt; ，即 &lt;code&gt;+RTS -maxN3 -RTS&lt;/code&gt; ，运行时将最多选择（x），也受系统上处理器数量的限制。如果需要默认的使用选项 &lt;code&gt;-N&lt;/code&gt; ，则省略（x）是一个错误。</target>
        </trans-unit>
        <trans-unit id="bf6c6cd414272ae624ac863540c1eb4369c6d081" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;hpc-tracer&lt;/code&gt;, this is 8 (a tab represents several spaces).</source>
          <target state="translated">对于 &lt;code&gt;hpc-tracer&lt;/code&gt; ，它是8（一个选项卡代表几个空格）。</target>
        </trans-unit>
        <trans-unit id="cec44f01be85a69c1fd7140d01ffa23f751d8ab9" translate="yes" xml:space="preserve">
          <source>With GHC, the &lt;code&gt;ByteString&lt;/code&gt; representation uses &lt;em&gt;pinned&lt;/em&gt; memory, meaning it cannot be moved by the GC. This is usually the right thing to do for larger strings, but for small strings using pinned memory can lead to heap fragmentation which wastes space. The &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; type (and the &lt;code&gt;Text&lt;/code&gt; type from the &lt;code&gt;text&lt;/code&gt; package) use &lt;em&gt;unpinned&lt;/em&gt; memory so they do not contribute to heap fragmentation. In addition, with GHC, small unpinned strings are allocated in the same way as normal heap allocations, rather than in a separate pinned area.</source>
          <target state="translated">对于GHC， &lt;code&gt;ByteString&lt;/code&gt; 表示形式使用&lt;em&gt;固定&lt;/em&gt;内存，这意味着GC无法移动它。对于较大的字符串，通常这样做是正确的，但是对于固定字符串的较小的字符串，可能会导致堆碎片，从而浪费空间。该 &lt;code&gt;&lt;a href=&quot;data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 型（和 &lt;code&gt;Text&lt;/code&gt; 从类型 &lt;code&gt;text&lt;/code&gt; 包）使用的&lt;em&gt;未锁定的&lt;/em&gt;记忆，使他们不至堆碎片贡献。此外，使用GHC时，小的固定字符串以与普通堆分配相同的方式分配，而不是在单独的固定区域中分配。</target>
        </trans-unit>
        <trans-unit id="1b24cdcec5afa4ca8ae04f5f805367b2d6db2d4d" translate="yes" xml:space="preserve">
          <source>With GHC, the memory overheads are as follows, expressed in words and in bytes (words are 4 and 8 bytes on 32 or 64bit machines respectively).</source>
          <target state="translated">对于GHC,内存开销如下,以字数和字节表示(32或64位机器上的字数分别为4和8字节)。</target>
        </trans-unit>
        <trans-unit id="2d06615b16a183cf6330905f8030d63fe75722c8" translate="yes" xml:space="preserve">
          <source>With Unicode text, it is incorrect to use combinators like &lt;code&gt;map
 toUpper&lt;/code&gt; to case convert each character of a string individually. Instead, use the whole-string case conversion functions from this module. For correctness in different writing systems, these functions may map one input character to two or three output characters.</source>
          <target state="translated">对于Unicode文本，使用诸如 &lt;code&gt;map toUpper&lt;/code&gt; 类的组合符来区分字符串的每个字符是不正确的。而是使用此模块中的全字符串大小写转换函数。为了在不同的书写系统中保持正确性，这些功能可以将一个输入字符映射到两个或三个输出字符。</target>
        </trans-unit>
        <trans-unit id="51f3ae84f7608aa013b4484775362a706adc53f0" translate="yes" xml:space="preserve">
          <source>With any luck, &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; will be undefined in all other implementations that support C-style pre-processing.</source>
          <target state="translated">运气好的话， &lt;code&gt;__GLASGOW_HASKELL__&lt;/code&gt; 将在所有其他所有支持C样式预处理的实现中都未定义。</target>
        </trans-unit>
        <trans-unit id="c44ed7fc274ccaa822b5b3ccf3ecc3bf7adbae81" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;#2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107ef4354dd6e452c7d4441a2e93bd2aacde1ddc" translate="yes" xml:space="preserve">
          <source>With dependently-typed features it is more useful (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue #2431&lt;/a&gt;). For example, consider these two candidate definitions of &lt;code&gt;absurd&lt;/code&gt;:</source>
          <target state="translated">使用依赖类型的功能，它会更加有用（请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/2431&quot;&gt;Issue＃2431&lt;/a&gt;）。例如，考虑 &lt;code&gt;absurd&lt;/code&gt; 这两个候选定义：</target>
        </trans-unit>
        <trans-unit id="21e78b74f477258018d7a7870e8af03b21095ae1" translate="yes" xml:space="preserve">
          <source>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the &lt;a href=&quot;using#pretty-printing-types&quot;&gt;discussion of type pretty-printing options&lt;/a&gt; for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially &lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于善良的多态性，Haskell程序员可能看不到幕后发生的很多事情。GHC支持几个标志，这些标志控制如何在错误消息中以及在GHCi提示符下打印类型。有关更多详细信息，请参见&lt;a href=&quot;using#pretty-printing-types&quot;&gt;类型漂亮打印选项&lt;/a&gt;的讨论。如果您使用的是实物多态性，并且对GHC为什么拒绝（或接受）程序感到困惑，我们建议您打开这些标志，尤其是&lt;a href=&quot;using#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69cd37ef3fe1623579439f2a0ea2d08874630d4e" translate="yes" xml:space="preserve">
          <source>With multiple modules in scope, especially multiple &lt;code&gt;*&lt;/code&gt;-form modules, it is likely that name clashes will occur. Haskell specifies that name clashes are only reported when an ambiguous identifier is used, and GHCi behaves in the same way for expressions typed at the prompt.</source>
          <target state="translated">如果作用域中有多个模块，尤其是多个 &lt;code&gt;*&lt;/code&gt; 形式的模块，则可能会发生名称冲突。Haskell指定仅当使用不明确的标识符时才报告名称冲突，并且GHCi对于在提示符下键入的表达式具有相同的行为。</target>
        </trans-unit>
        <trans-unit id="d0493423cb33f94a9da912db9832c18dcdd8ec9d" translate="yes" xml:space="preserve">
          <source>With only 1 generation (e.g. &lt;code&gt;-G1&lt;/code&gt;, see &lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt;&lt;code&gt;-G ⟨generations⟩&lt;/code&gt;&lt;/a&gt;) the &lt;code&gt;-A&lt;/code&gt; option specifies the minimum allocation area, since the actual size of the allocation area will be resized according to the amount of data in the heap (see &lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt;&lt;code&gt;-F ⟨factor⟩&lt;/code&gt;&lt;/a&gt;, below).</source>
          <target state="translated">仅使用1代（例如 &lt;code&gt;-G1&lt;/code&gt; ，请参见&lt;a href=&quot;#rts-flag--G%20%E2%9F%A8generations%E2%9F%A9&quot;&gt; &lt;code&gt;-G ⟨generations⟩&lt;/code&gt; &lt;/a&gt;）， &lt;code&gt;-A&lt;/code&gt; 选项指定最小分配区域，因为分配区域的实际大小将根据堆中的数据量进行调整（请参见&lt;a href=&quot;#rts-flag--F%20%E2%9F%A8factor%E2%9F%A9&quot;&gt; &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; &lt;/a&gt;，如下）。</target>
        </trans-unit>
        <trans-unit id="785aea24bc9e99119b7035e19ac075542c979030" translate="yes" xml:space="preserve">
          <source>With some exceptions (see below), the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials, by putting symbolic links (on Unix) in the place where the temporary file is to be created. On Unix the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags are used to prevent this attack, but note that &lt;code&gt;O_EXCL&lt;/code&gt; is sometimes not supported on NFS filesystems, so if you rely on this behaviour it is best to use local filesystems only.</source>
          <target state="translated">除某些例外情况（请参阅下文）外，安全地创建文件的方式是，攻击者不应使用您的凭据通过将符号链接（在Unix上）放在以下位置，从而导致openTempFile覆盖文件系统上的另一个文件临时文件将被创建。在Unix上，使用 &lt;code&gt;O_CREAT&lt;/code&gt; 和 &lt;code&gt;O_EXCL&lt;/code&gt; 标志来防止这种攻击，但是请注意，NFS文件系统有时不支持 &lt;code&gt;O_EXCL&lt;/code&gt; ，因此，如果您依赖于此行为，则最好仅使用本地文件系统。</target>
        </trans-unit>
        <trans-unit id="a93509c3f999509299ef31391df84499497efcb8" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-Arrows&quot;&gt; &lt;code&gt;Arrows&lt;/code&gt; &lt;/a&gt;扩展，GHC支持本文第二篇中介绍的箭头符号，并使用&lt;a href=&quot;../libraries/base-4.13.0.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt;模块中的组合器对其进行翻译。以下是该符号的简要介绍；除非您阅读过休斯的论文，否则这没有多大意义。</target>
        </trans-unit>
        <trans-unit id="6b570873f02bd59cb3d75af7817ea6c7ba50ea43" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-Arrows&quot;&gt;&lt;code&gt;Arrows&lt;/code&gt;&lt;/a&gt; extension, GHC supports the arrow notation described in the second of these papers, translating it using combinators from the &lt;a href=&quot;../libraries/base-4.14.1.0/control-arrow&quot;&gt;Control.Arrow&lt;/a&gt; module. What follows is a brief introduction to the notation; it won&amp;rsquo;t make much sense unless you&amp;rsquo;ve read Hughes&amp;rsquo;s paper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1c52b5955db050f2c09abaaf8b8f9460a4acba" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-ConstraintKinds&quot;&gt;&lt;code&gt;ConstraintKinds&lt;/code&gt;&lt;/a&gt; extension, GHC becomes more liberal in what it accepts as constraints in your program. To be precise, with this flag any &lt;em&gt;type&lt;/em&gt; of the new kind &lt;code&gt;Constraint&lt;/code&gt; can be used as a constraint. The following things have kind &lt;code&gt;Constraint&lt;/code&gt;:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-ConstraintKinds&quot;&gt; &lt;code&gt;ConstraintKinds&lt;/code&gt; &lt;/a&gt;扩展，GHC可以更自由地接受程序中的约束。确切地说，使用此标志，可以将任何&lt;em&gt;类型&lt;/em&gt;的新 &lt;code&gt;Constraint&lt;/code&gt; 作为约束。以下内容具有 &lt;code&gt;Constraint&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e1664518d009a52644be50176a94b39948aa07fe" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt;&lt;code&gt;EmptyDataDecls&lt;/code&gt;&lt;/a&gt; extension, GHC lets you declare a data type with no constructors.</source>
          <target state="translated">通过&lt;a href=&quot;#extension-EmptyDataDecls&quot;&gt; &lt;code&gt;EmptyDataDecls&lt;/code&gt; &lt;/a&gt;扩展，GHC允许您声明不带构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="86f5c1ba9a946fe63d6ee762808ace202ba1df31" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-PackageImports&quot;&gt;&lt;code&gt;PackageImports&lt;/code&gt;&lt;/a&gt; extension, GHC allows import declarations to be qualified by the package name that the module is intended to be imported from. For example:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-PackageImports&quot;&gt; &lt;code&gt;PackageImports&lt;/code&gt; &lt;/a&gt;扩展，GHC允许使用要从中导入模块的包名称来限定导入声明。例如：</target>
        </trans-unit>
        <trans-unit id="0081b5adf07c359a705bcc01d665e8bd9d05b630" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt; extension (&lt;a href=&quot;#universal-quantification&quot;&gt;Lexically scoped type variables&lt;/a&gt;), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; and then say &lt;code&gt;pair @Bool True @Char&lt;/code&gt; which would have type &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt;扩展（按&lt;a href=&quot;#universal-quantification&quot;&gt;词法定义的类型变量&lt;/a&gt;），可以在类型开头之外的其他地方声明类型参数。例如，我们可以具有 &lt;code&gt;pair :: forall a. a -&amp;gt; forall b. b -&amp;gt; (a, b)&lt;/code&gt; ，然后说 &lt;code&gt;pair @Bool True @Char&lt;/code&gt; ，其类型为 &lt;code&gt;Char -&amp;gt; (Bool, Char)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76eee139e346997f5c9c53bbb31187ae5e3574e1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt;&lt;code&gt;TypeSynonymInstances&lt;/code&gt;&lt;/a&gt; extension, instance heads may use type synonyms. As always, using a type synonym is just shorthand for writing the RHS of the type synonym definition. For example:</source>
          <target state="translated">通过&lt;a href=&quot;#extension-TypeSynonymInstances&quot;&gt; &lt;code&gt;TypeSynonymInstances&lt;/code&gt; &lt;/a&gt;扩展，实例头可以使用类型同义词。与往常一样，使用类型同义词只是编写类型同义词定义的RHS的简写。例如：</target>
        </trans-unit>
        <trans-unit id="dd64afd9c5cd942b81bb03eac59d62ba1c9175a3" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; language flags, GHC extends the import declaration syntax to take an optional &lt;code&gt;safe&lt;/code&gt; keyword after the &lt;code&gt;import&lt;/code&gt; keyword. This feature is part of the Safe Haskell GHC extension. For example:</source>
          <target state="translated">通过使用&lt;a href=&quot;safe_haskell#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;safe_haskell#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;safe_haskell#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt;语言标志，GHC扩展了导入声明语法，以在 &lt;code&gt;import&lt;/code&gt; 关键字之后采用可选的 &lt;code&gt;safe&lt;/code&gt; 关键字。此功能是Safe Haskell GHC扩展的一部分。例如：</target>
        </trans-unit>
        <trans-unit id="86dce2a8a32edb642a5851fc037f97dda0e2a514" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; option, GHC can generate instances of the &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; class automatically. For example, given the declaration</source>
          <target state="translated">使用 &lt;code&gt;-XDeriveDataTypeable&lt;/code&gt; 选项，GHC可以自动生成 &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 类的实例。例如，给定声明</target>
        </trans-unit>
        <trans-unit id="7061af1c2882d04c412d1f683d99f0149d64aa2b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;T&lt;/code&gt; example above, we could bind &lt;code&gt;k&lt;/code&gt;&lt;em&gt;after&lt;/em&gt;&lt;code&gt;a&lt;/code&gt;; doing so would not violate dependency concerns. However, it would violate our general principle, and so &lt;code&gt;k&lt;/code&gt; comes first.</source>
          <target state="translated">与 &lt;code&gt;T&lt;/code&gt; 上面的例子中，我们可以结合 &lt;code&gt;k&lt;/code&gt; &lt;em&gt;后&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; ; 这样做不会违反依赖关系的关注。但是，这将违反我们的一般原则，因此 &lt;code&gt;k&lt;/code&gt; 排在第一位。</target>
        </trans-unit>
        <trans-unit id="95a87e504b0a793e5fd58318fbc965d5cde726b1" translate="yes" xml:space="preserve">
          <source>With the declaration of &lt;code&gt;(:~~:)&lt;/code&gt; above, it gets kind &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt;. Thus, the type &lt;code&gt;(:~~:) a&lt;/code&gt; has kind &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; for some &lt;code&gt;k2&lt;/code&gt;. GHC cannot then &lt;em&gt;regeneralize&lt;/em&gt; this kind to become &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; as desired. Thus, the instance is rejected as ill-kinded.</source>
          <target state="translated">有了上面的 &lt;code&gt;(:~~:)&lt;/code&gt; 声明，它对于所有 &lt;code&gt;forall k1 k2. k1 -&amp;gt; k2 -&amp;gt; Type&lt;/code&gt; 。因此，类型 &lt;code&gt;(:~~:) a&lt;/code&gt; 种类为 &lt;code&gt;k2 -&amp;gt; Type&lt;/code&gt; 某些 &lt;code&gt;k2&lt;/code&gt; 的类型。然后，GHC无法将这种类型的 &lt;code&gt;forall k2. k2 -&amp;gt; Type&lt;/code&gt; &lt;em&gt;重新&lt;/em&gt;合成为永久k2。k2-&amp;gt;根据需要键入。因此，该实例被拒绝为不良实例。</target>
        </trans-unit>
        <trans-unit id="8e9d7ae0964f2c8a37967ebdf7b51ca679bfce71" translate="yes" xml:space="preserve">
          <source>With the extension that adds a &lt;a href=&quot;#constraint-kind&quot;&gt;kind of constraints&lt;/a&gt;, you can write more exotic superclass definitions. The superclass cycle check is even more liberal in these case. For example, this is OK:</source>
          <target state="translated">通过添加&lt;a href=&quot;#constraint-kind&quot;&gt;一种约束&lt;/a&gt;的扩展，您可以编写更多奇特的超类定义。在这种情况下，超类循环检查更加自由。例如，这可以：</target>
        </trans-unit>
        <trans-unit id="c21ffce8c72ae9e80966f7f06bfe16bc1598f575" translate="yes" xml:space="preserve">
          <source>With the goal in mind to make &lt;code&gt;encode&lt;/code&gt; work on &lt;code&gt;Tree&lt;/code&gt; and other datatypes, we now define instances for the representation type constructors &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">考虑到使目标 &lt;code&gt;encode&lt;/code&gt; 工作 &lt;code&gt;Tree&lt;/code&gt; 和其它数据类型，我们现在定义为表示类型构造实例 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-generics#t:M1&quot;&gt;M1&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5302a8fcd7027fe5fed3ca73b8eed7f9ceed1e24" translate="yes" xml:space="preserve">
          <source>With the improved kind of &lt;code&gt;Vec&lt;/code&gt;, things like &lt;code&gt;Vec Int Char&lt;/code&gt; are now ill-kinded, and GHC will report an error.</source>
          <target state="translated">随着 &lt;code&gt;Vec&lt;/code&gt; 种类的改进，像 &lt;code&gt;Vec Int Char&lt;/code&gt; 这样的东西现在已经变种了，GHC将报告错误。</target>
        </trans-unit>
        <trans-unit id="0aed3bcdd45e9d87e9c818064646efdefe64f958" translate="yes" xml:space="preserve">
          <source>With the language extension &lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt;&lt;code&gt;UndecidableSuperClasses&lt;/code&gt;&lt;/a&gt; GHC lifts all restrictions on superclass constraints. If there really &lt;em&gt;is&lt;/em&gt; a loop, GHC will only expand it to finite depth.</source>
          <target state="translated">通过扩展语言&lt;a href=&quot;#extension-UndecidableSuperClasses&quot;&gt; &lt;code&gt;UndecidableSuperClasses&lt;/code&gt; ,&lt;/a&gt; GHC取消了对超类约束的所有限制。如果真的&lt;em&gt;是&lt;/em&gt;一个循环，GHC只会扩大到有限的深度。</target>
        </trans-unit>
        <trans-unit id="881f9aca2cbf94416a15c78d09c89a5e610b3cba" translate="yes" xml:space="preserve">
          <source>With this extension turned on, &lt;code&gt;static&lt;/code&gt; is no longer a valid identifier.</source>
          <target state="translated">启用此扩展名后， &lt;code&gt;static&lt;/code&gt; 不再是有效的标识符。</target>
        </trans-unit>
        <trans-unit id="3eae705dd30aa403e3959eddafb73fb5d53a286c" translate="yes" xml:space="preserve">
          <source>With this flag enabled we use the last jump instruction in blocks. Without this flags the old algorithm also uses the heaviest outgoing edge.</source>
          <target state="translated">启用这个标志后,我们使用块中最后一条跳转指令。如果没有这个标志,老算法也会使用最重的出边。</target>
        </trans-unit>
        <trans-unit id="b16f923b2bccb6268626a56190ac266418d2ee9a" translate="yes" xml:space="preserve">
          <source>With this form of the group statement, f is required to simply have the type &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt;, which will be used to group up the comprehension so far directly. An example of this form is as follows:</source>
          <target state="translated">使用group语句的这种形式，要求f仅具有类型 &lt;code&gt;forall a. [a] -&amp;gt; [[a]]&lt;/code&gt; ，这将直接用于到目前为止的理解。这种形式的示例如下：</target>
        </trans-unit>
        <trans-unit id="c1ca2feeac1b63c8b0e8b5d863d1efdb6417eb61" translate="yes" xml:space="preserve">
          <source>With this macro defined in your &lt;code&gt;.ghci&lt;/code&gt; file, you can use &lt;code&gt;:source file&lt;/code&gt; to read GHCi commands from &lt;code&gt;file&lt;/code&gt;. You can find (and contribute!-) other suggestions for &lt;code&gt;.ghci&lt;/code&gt; files on this Haskell wiki page: &lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC/GHCi&lt;/a&gt;</source>
          <target state="translated">在 &lt;code&gt;.ghci&lt;/code&gt; 文件中定义了此宏之后，您可以使用 &lt;code&gt;:source file&lt;/code&gt; 从 &lt;code&gt;file&lt;/code&gt; 中读取GHCi命令。您可以在此Haskell Wiki页面上找到有关 &lt;code&gt;.ghci&lt;/code&gt; 文件的其他建议（并做出贡献！）：&lt;a href=&quot;http://haskell.org/haskellwiki/GHC/GHCi&quot;&gt;GHC / GHCi&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07b653d1a2bfaa93b0073e542432ee5c0e412c45" translate="yes" xml:space="preserve">
          <source>With typed expressions, the type error occurs when &lt;em&gt;constructing&lt;/em&gt; the Template Haskell expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6c0ef956744d9c2875427c6662b77c5a888414" translate="yes" xml:space="preserve">
          <source>With zig-zag cuts.</source>
          <target state="translated">有曲折的切口。</target>
        </trans-unit>
        <trans-unit id="bc2f9125cc8c7112d9ada66985a127ec0ad4e915" translate="yes" xml:space="preserve">
          <source>Within reason, more memory for heap space means less garbage collection for GHC, which means less compilation time. If you use the &lt;code&gt;-Rghc-timing&lt;/code&gt; option, you&amp;rsquo;ll get a garbage-collector report. (Again, you can use the cheap-and-nasty &lt;code&gt;+RTS -S -RTS&lt;/code&gt; option to send the GC stats straight to standard error.)</source>
          <target state="translated">在一定程度上，堆空间的更多内存意味着GHC的垃圾回收更少，这意味着更少的编译时间。如果使用 &lt;code&gt;-Rghc-timing&lt;/code&gt; 选项，将获得垃圾收集器报告。（同样，您可以使用便宜的 &lt;code&gt;+RTS -S -RTS&lt;/code&gt; 选项将GC统计信息直接发送到标准错误。）</target>
        </trans-unit>
        <trans-unit id="8f47805e05322cd599bf35fe9faf060f5e73efd3" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用无效字符&amp;ldquo;&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="7908234217d5fcd634ff01a732e900f1963d7319" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea0da7408cfec1901b2368ef703f2aecf1f6514" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="translated">在此模块中，许多函数根据一个或多个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值构造一个 &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 。这些函数将用无效字符&amp;ldquo;&amp;rdquo;（U + FFFD）替换不是有效Unicode标量值的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 值。短语&amp;ldquo;执行对无效标量值的替换&amp;rdquo;记录了执行此检查和替换的功能。</target>
        </trans-unit>
        <trans-unit id="d2e478e972382d28cdc4d59b0f5b4e6ab5fe13da" translate="yes" xml:space="preserve">
          <source>Within this module, many functions construct a &lt;code&gt;&lt;a href=&quot;data-text-lazy#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; from one or more &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values. Those functions will substitute &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values that are not valid Unicode scalar values with the replacement character &quot;�&quot; (U+FFFD). Functions that perform this inspection and replacement are documented with the phrase &quot;Performs replacement on invalid scalar values&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dfb1e2314e140fc44280b93e374d8103a6bd88" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt;, an update mentioning &lt;code&gt;foo&lt;/code&gt; will always be ambiguous if all these definitions were in scope. When the extension is enabled, there are several options for disambiguating updates:</source>
          <target state="translated">没有&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;，如果所有这些定义都在范围内，则提及 &lt;code&gt;foo&lt;/code&gt; 的更新将始终是模棱两可的。启用扩展后，可以使用多个选项来消除更新的歧义：</target>
        </trans-unit>
        <trans-unit id="cf558caacc962a4ce5708595b14947064e9202c7" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;, GHC refuses to generalise over kind variables. It thus defaults kind variables to &lt;code&gt;Type&lt;/code&gt; when possible; when this is not possible, an error is issued.</source>
          <target state="translated">没有&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;，GHC拒绝归纳种类变量。因此，在可能的情况下，它会将种类变量默认为 &lt;code&gt;Type&lt;/code&gt; 。当这不可能时，将发出错误。</target>
        </trans-unit>
        <trans-unit id="2a9c3c68ec886ab1a40dbb182885c56e2b6ca831" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;#11679&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5845f382c175f98b7eb91c01c1ee5f311d078978" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a list comprehension. With &lt;a href=&quot;#extension-QuasiQuotes&quot;&gt;&lt;code&gt;QuasiQuotes&lt;/code&gt;&lt;/a&gt; this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing &lt;code&gt;|]&lt;/code&gt;. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;Issue #11679&lt;/a&gt;.</source>
          <target state="translated">如果没有&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; ,则将&lt;/a&gt;其解析为列表理解。使用&lt;a href=&quot;#extension-QuasiQuotes&quot;&gt; &lt;code&gt;QuasiQuotes&lt;/code&gt; 可以&lt;/a&gt;将其解析为准报价。但是，由于缺乏结束 &lt;code&gt;|]&lt;/code&gt; ，因此该解析将失败。请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/11679&quot;&gt;问题＃11679&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f3724a985619b98c0ad7733af9c670b7ea356bd" translate="yes" xml:space="preserve">
          <source>Without a &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option, your &lt;code&gt;SCC&lt;/code&gt;s are ignored; so you can compile &lt;code&gt;SCC&lt;/code&gt;-laden code without changing it.</source>
          <target state="translated">如果没有&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项，则将忽略您的 &lt;code&gt;SCC&lt;/code&gt; ；因此，您无需更改即可编译包含 &lt;code&gt;SCC&lt;/code&gt; 的代码。</target>
        </trans-unit>
        <trans-unit id="7b93607420f6e329b78506ca570d35577aad1878" translate="yes" xml:space="preserve">
          <source>Without any arguments, displays the current set of options that are applied to expressions and commands typed at the prompt.</source>
          <target state="translated">在没有任何参数的情况下,显示应用于在提示符下输入的表达式和命令的当前选项集。</target>
        </trans-unit>
        <trans-unit id="6afd1c5d24d0c6ba28deb9777974788c74c647b1" translate="yes" xml:space="preserve">
          <source>Without lifting a finger, the &lt;code&gt;?cmp&lt;/code&gt; parameter is propagated to become a parameter of &lt;code&gt;least&lt;/code&gt; as well. With explicit parameters, the default is that parameters must always be explicit propagated. With implicit parameters, the default is to always propagate them.</source>
          <target state="translated">在不松开手指的情况下， &lt;code&gt;?cmp&lt;/code&gt; 参数也将传播为 &lt;code&gt;least&lt;/code&gt; 的参数。对于显式参数，默认值是必须始终对参数进行显式传播。使用隐式参数时，默认设置是始终传播它们。</target>
        </trans-unit>
        <trans-unit id="b0f92d9fa8c76be5e794944834d2ec86a2772775" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;MINIMAL&lt;/code&gt; pragma no warning would be generated for an instance that implements neither method.</source>
          <target state="translated">如果没有 &lt;code&gt;MINIMAL&lt;/code&gt; 编译指示，则不会为未实现任何方法的实例生成警告。</target>
        </trans-unit>
        <trans-unit id="50d9f1e1cbc21e6ec9dc165a0f7dae51d3263314" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;forall b&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; would be quantified over the whole instance declaration, which is not what is intended.</source>
          <target state="translated">如果没有 &lt;code&gt;forall b&lt;/code&gt; ，则类型变量 &lt;code&gt;b&lt;/code&gt; 将在整个实例声明中进行量化，这不是预期的。</target>
        </trans-unit>
        <trans-unit id="d93b93f4b6fa3889a10d8fc5065716508c9b410a" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;pattern&lt;/code&gt; prefix, &lt;code&gt;Zero&lt;/code&gt; would be interpreted as a type constructor in the export list.</source>
          <target state="translated">没有 &lt;code&gt;pattern&lt;/code&gt; 前缀， &lt;code&gt;Zero&lt;/code&gt; 将在导出列表中解释为类型构造函数。</target>
        </trans-unit>
        <trans-unit id="8529406902d1abcacd9905fe51002c24837c1b9f" translate="yes" xml:space="preserve">
          <source>Witness for an unboxed &lt;code&gt;Proxy#&lt;/code&gt; value, which has no runtime representation.</source>
          <target state="translated">见证未装箱的 &lt;code&gt;Proxy#&lt;/code&gt; 值，该值没有运行时表示形式。</target>
        </trans-unit>
        <trans-unit id="610f9340ef73da170fe3d746b635b1e322839287" translate="yes" xml:space="preserve">
          <source>Witness the trail of destruction:</source>
          <target state="translated">见证毁灭的痕迹。</target>
        </trans-unit>
        <trans-unit id="44363ccb8230b892c5ab09c35a02a4ea41ff9976" translate="yes" xml:space="preserve">
          <source>Word</source>
          <target state="translated">Word</target>
        </trans-unit>
        <trans-unit id="d5483c905b6d49a4bb959ca289af138ba2e3974b" translate="yes" xml:space="preserve">
          <source>Word completion</source>
          <target state="translated">单词完成</target>
        </trans-unit>
        <trans-unit id="ebec3f021b32b6cc5c3702fa2014aacc63a489c8" translate="yes" xml:space="preserve">
          <source>Word#</source>
          <target state="translated">Word#</target>
        </trans-unit>
        <trans-unit id="6a84434113170dd2196183223a37fdceb55ba2fb" translate="yes" xml:space="preserve">
          <source>Word16</source>
          <target state="translated">Word16</target>
        </trans-unit>
        <trans-unit id="47cfcc5721eb7b6a68e503b7664fe5da8cc042b7" translate="yes" xml:space="preserve">
          <source>Word16#</source>
          <target state="translated">Word16#</target>
        </trans-unit>
        <trans-unit id="c3be769dd2ec4a171cda42ade7fe290e55320847" translate="yes" xml:space="preserve">
          <source>Word16ElemRep</source>
          <target state="translated">Word16ElemRep</target>
        </trans-unit>
        <trans-unit id="6e4a4a97ad2c84568dfc9c970956cd5aea4291f3" translate="yes" xml:space="preserve">
          <source>Word16Rep</source>
          <target state="translated">Word16Rep</target>
        </trans-unit>
        <trans-unit id="27d33d7ad79bddbd9198dbf60544ea0a5922ab2d" translate="yes" xml:space="preserve">
          <source>Word16X16#</source>
          <target state="translated">Word16X16#</target>
        </trans-unit>
        <trans-unit id="581ced5045f9589c18eb6b89774a5edb7cf18907" translate="yes" xml:space="preserve">
          <source>Word16X32#</source>
          <target state="translated">Word16X32#</target>
        </trans-unit>
        <trans-unit id="cb0fa55002540cd66201e78dd2a473b775807583" translate="yes" xml:space="preserve">
          <source>Word16X8#</source>
          <target state="translated">Word16X8#</target>
        </trans-unit>
        <trans-unit id="ca9cf535ecc0d6f9c09f163d1eace0c0b75e14df" translate="yes" xml:space="preserve">
          <source>Word32</source>
          <target state="translated">Word32</target>
        </trans-unit>
        <trans-unit id="a933b159a6b2cb61c00b71e8591eb2ee110f8728" translate="yes" xml:space="preserve">
          <source>Word32#</source>
          <target state="translated">Word32#</target>
        </trans-unit>
        <trans-unit id="399b80b5d6a6df00939198146bfa201fbcfcb514" translate="yes" xml:space="preserve">
          <source>Word32ElemRep</source>
          <target state="translated">Word32ElemRep</target>
        </trans-unit>
        <trans-unit id="70a7003c530361b27dbad2666f3119f63d7aa52c" translate="yes" xml:space="preserve">
          <source>Word32Rep</source>
          <target state="translated">Word32Rep</target>
        </trans-unit>
        <trans-unit id="bb69aca3ee85ff65d670de320b3a0722f77e6a2c" translate="yes" xml:space="preserve">
          <source>Word32X16#</source>
          <target state="translated">Word32X16#</target>
        </trans-unit>
        <trans-unit id="8243c948dcd7f5412910c04096e56d0136dac05a" translate="yes" xml:space="preserve">
          <source>Word32X4#</source>
          <target state="translated">Word32X4#</target>
        </trans-unit>
        <trans-unit id="b142d249e87e96429320d524a3b07bd2246dd820" translate="yes" xml:space="preserve">
          <source>Word32X8#</source>
          <target state="translated">Word32X8#</target>
        </trans-unit>
        <trans-unit id="8a1457858cb6a778826be1ec52c62538bb952ff7" translate="yes" xml:space="preserve">
          <source>Word64</source>
          <target state="translated">Word64</target>
        </trans-unit>
        <trans-unit id="8530200a24dcfbd549467b756af592d29de90c98" translate="yes" xml:space="preserve">
          <source>Word64#</source>
          <target state="translated">Word64#</target>
        </trans-unit>
        <trans-unit id="5346b71b27abd762c16882d8503921d915a9b596" translate="yes" xml:space="preserve">
          <source>Word64ElemRep</source>
          <target state="translated">Word64ElemRep</target>
        </trans-unit>
        <trans-unit id="ad9de82091d9f5be6f70404a7f6ea77db4515661" translate="yes" xml:space="preserve">
          <source>Word64Rep</source>
          <target state="translated">Word64Rep</target>
        </trans-unit>
        <trans-unit id="0bf4e17ceba7b29f9db8d40fc30978cabad5b2e3" translate="yes" xml:space="preserve">
          <source>Word64X2#</source>
          <target state="translated">Word64X2#</target>
        </trans-unit>
        <trans-unit id="f30283a81aeb4836e2239aa4b4f88d036171e15d" translate="yes" xml:space="preserve">
          <source>Word64X4#</source>
          <target state="translated">Word64X4#</target>
        </trans-unit>
        <trans-unit id="6df564da800ea9db332a4e4f70ac3b7baee68108" translate="yes" xml:space="preserve">
          <source>Word64X8#</source>
          <target state="translated">Word64X8#</target>
        </trans-unit>
        <trans-unit id="7d4f09dfc217ef6de83fd0a7817a34a9c524f5f8" translate="yes" xml:space="preserve">
          <source>Word8</source>
          <target state="translated">Word8</target>
        </trans-unit>
        <trans-unit id="1026530b7f2b7d11ceed950f769ae8af9db41c6d" translate="yes" xml:space="preserve">
          <source>Word8#</source>
          <target state="translated">Word8#</target>
        </trans-unit>
        <trans-unit id="46fa1330e06c95858d3c751456971104c43240e6" translate="yes" xml:space="preserve">
          <source>Word8ElemRep</source>
          <target state="translated">Word8ElemRep</target>
        </trans-unit>
        <trans-unit id="bb25378aca5d0bf9417565eddafe0c9955fced88" translate="yes" xml:space="preserve">
          <source>Word8Rep</source>
          <target state="translated">Word8Rep</target>
        </trans-unit>
        <trans-unit id="6d9c171610680a48a7e1adce25e5ef2175c1786b" translate="yes" xml:space="preserve">
          <source>Word8X16#</source>
          <target state="translated">Word8X16#</target>
        </trans-unit>
        <trans-unit id="7d2b3864aa2a328b268de16ec90a676d025166df" translate="yes" xml:space="preserve">
          <source>Word8X32#</source>
          <target state="translated">Word8X32#</target>
        </trans-unit>
        <trans-unit id="420bed9409614065e79233ee278151c88a99c07c" translate="yes" xml:space="preserve">
          <source>Word8X64#</source>
          <target state="translated">Word8X64#</target>
        </trans-unit>
        <trans-unit id="84c6a57a62c9a723bc4c3a3bbe6ffc9a885219d9" translate="yes" xml:space="preserve">
          <source>WordPtr</source>
          <target state="translated">WordPtr</target>
        </trans-unit>
        <trans-unit id="68dc8baeafc9a279622fb5e31be3ed83d95357da" translate="yes" xml:space="preserve">
          <source>WordRep</source>
          <target state="translated">WordRep</target>
        </trans-unit>
        <trans-unit id="7ba9e8f41622b0ccfc835a4f2140ab6eea7b7e9b" translate="yes" xml:space="preserve">
          <source>Work left-to-right through the input list of type variables, with a cursor.</source>
          <target state="translated">用光标从左到右在类型变量的输入列表中工作。</target>
        </trans-unit>
        <trans-unit id="bc1c455e1b31ed1393785a6cdc3045bbb118f243" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">解决方法，以便我们可以使用Haskell 98实例 &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c02809968c5a04b4bf0b6d24112481a63ca6dca" translate="yes" xml:space="preserve">
          <source>Workaround so that we can have a Haskell 98 instance &lt;code&gt;&lt;a href=&quot;control-monad-trans-error#t:Error&quot;&gt;Error&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab49cd9ef02b20b8f0a395f52a3bac5f961ae20" translate="yes" xml:space="preserve">
          <source>Worker-wrapper removes unused arguments, but usually we do not remove them all, lest it turn a function closure into a thunk, thereby perhaps creating a space leak and/or disrupting inlining. This flag allows worker/wrapper to remove &lt;em&gt;all&lt;/em&gt; value lambdas.</source>
          <target state="translated">Worker-wrapper会删除未使用的参数，但是通常我们不会全部删除它们，以免将函数关闭变成笨拙的东西，从而可能造成空间泄漏和/或破坏内联。此标志允许工作程序/包装程序删除&lt;em&gt;所有&lt;/em&gt;值lambda。</target>
        </trans-unit>
        <trans-unit id="61f4d4dd918269bf5a5ff69500737f2e3c652d80" translate="yes" xml:space="preserve">
          <source>Working with equality</source>
          <target state="translated">与平等有关的工作</target>
        </trans-unit>
        <trans-unit id="b7851eadac070ddfea609696fdeb164b7899ebe8" translate="yes" xml:space="preserve">
          <source>Would result in a generated &lt;code&gt;Functor&lt;/code&gt; instance like so:</source>
          <target state="translated">会生成一个如下所示的 &lt;code&gt;Functor&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="6ee562876821329b8991ff4daaadbf4f98ef9b98" translate="yes" xml:space="preserve">
          <source>Wrap a BCO in a &lt;code&gt;AP_UPD&lt;/code&gt; thunk which will be updated with the value of the BCO when evaluated.</source>
          <target state="translated">将BCO包裹在 &lt;code&gt;AP_UPD&lt;/code&gt; 中，将在评估时使用BCO的值进行更新。</target>
        </trans-unit>
        <trans-unit id="16397dd6317efa9c9836ee42453758565f8d25ed" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果在超时之前有结果可用，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="298bd3ed150b3f0eda86e3bd26b9d517dfc0dc76" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769d436eab4aa870cf748d72592199f75a9fdf28" translate="yes" xml:space="preserve">
          <source>Wrap an &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to time out and return &lt;code&gt;Nothing&lt;/code&gt; in case no result is available within &lt;code&gt;n&lt;/code&gt; microseconds (&lt;code&gt;1/10^6&lt;/code&gt; seconds). In case a result is available before the timeout expires, &lt;code&gt;Just a&lt;/code&gt; is returned. A negative timeout interval means &quot;wait indefinitely&quot;. When specifying long timeouts, be careful not to exceed &lt;code&gt;maxBound :: Int&lt;/code&gt;.</source>
          <target state="translated">包装 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算以超时，如果在 &lt;code&gt;n&lt;/code&gt; 微秒（ &lt;code&gt;1/10^6&lt;/code&gt; 秒）内没有结果可用，则返回 &lt;code&gt;Nothing&lt;/code&gt; 。如果在超时之前有结果可用，则 &lt;code&gt;Just a&lt;/code&gt; 返回a。负的超时间隔表示&amp;ldquo;无限期等待&amp;rdquo;。指定长时间超时时，请注意不要超过 &lt;code&gt;maxBound :: Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052e52e2ec601e51ff67cce14d06f664e23dd732" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;&quot;...&quot;&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;&quot;...&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2463a3964a6d5f90893a0cb4a83e415f58109e" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;'...'&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;'...'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e11d85c98f81ceac1c15ffeb3554f6ef50d942c9" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;(...)&lt;/code&gt;</source>
          <target state="translated">将文档包装在 &lt;code&gt;(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fefcdd75b8d3ceac5767fa9ddb3485c2fae7387b" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;[...]&lt;/code&gt;</source>
          <target state="translated">将文件包装在 &lt;code&gt;[...]&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="2d9a81e67b5bd2bc5cede4830f07d4ee5769499a" translate="yes" xml:space="preserve">
          <source>Wrap document in &lt;code&gt;{...}&lt;/code&gt;</source>
          <target state="translated">将文档包装在 &lt;code&gt;{...}&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="b5150dc051fd47e830d39a1a10a0d5cede823b6b" translate="yes" xml:space="preserve">
          <source>WrapArrow</source>
          <target state="translated">WrapArrow</target>
        </trans-unit>
        <trans-unit id="c92147ea0c2b0677b7c09751757b19d07bd7b17c" translate="yes" xml:space="preserve">
          <source>WrapMonad</source>
          <target state="translated">WrapMonad</target>
        </trans-unit>
        <trans-unit id="4069d5a8b2d61fc44c53d1d69a1603e75124fe55" translate="yes" xml:space="preserve">
          <source>WrapMonoid</source>
          <target state="translated">WrapMonoid</target>
        </trans-unit>
        <trans-unit id="f72344941ecf4dbf3a6b05f7d128cba499a51fde" translate="yes" xml:space="preserve">
          <source>WrappedArrow</source>
          <target state="translated">WrappedArrow</target>
        </trans-unit>
        <trans-unit id="5424268dd193f61b9e7843ef4109dc2a12bac7a6" translate="yes" xml:space="preserve">
          <source>WrappedMonad</source>
          <target state="translated">WrappedMonad</target>
        </trans-unit>
        <trans-unit id="459140ee141c9d01be26238b973ae1046e530be2" translate="yes" xml:space="preserve">
          <source>WrappedMonoid</source>
          <target state="translated">WrappedMonoid</target>
        </trans-unit>
        <trans-unit id="fb18f208c8e09b8e152ee97be9d763608b85aabc" translate="yes" xml:space="preserve">
          <source>Wrapper of &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; with faster implementation for GHC</source>
          <target state="translated">具有更快实现GHC 的 &lt;code&gt;mallocForeignPtrBytes&lt;/code&gt; 包装器</target>
        </trans-unit>
        <trans-unit id="f5bae4c947473ab2febca5eb61bfa9da65f60ac7" translate="yes" xml:space="preserve">
          <source>Wrapping an IO action that can throw an error &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">包装可能引发错误 &lt;code&gt;e&lt;/code&gt; 的IO操作：</target>
        </trans-unit>
        <trans-unit id="0d27d9e2d3a2ad251d4892a773947e707db18720" translate="yes" xml:space="preserve">
          <source>Wrapping documents in delimiters</source>
          <target state="translated">用定界符包装文件</target>
        </trans-unit>
        <trans-unit id="48606f4bb9cb6f76c6d45f0aae55cb4f7a999651" translate="yes" xml:space="preserve">
          <source>Write 31-bit character; offset in 4-byte words.</source>
          <target state="translated">写31位字符;偏移量为4字节的字。</target>
        </trans-unit>
        <trans-unit id="132823a14fa0074e9c3549c122a220890e54d9b3" translate="yes" xml:space="preserve">
          <source>Write 8-bit character; offset in bytes.</source>
          <target state="translated">写8位字符;偏移量以字节为单位。</target>
        </trans-unit>
        <trans-unit id="6cfb95525e855d3c2fb90f553acacc9ffd9b1afe" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; to the buffer</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-short#t:ShortByteString&quot;&gt;ShortByteString&lt;/a&gt;&lt;/code&gt; 写入缓冲区</target>
        </trans-unit>
        <trans-unit id="a30ef0a4dea3adbd954b944a856f0d73077a7fef" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;.tix&lt;/code&gt; File.</source>
          <target state="translated">编写一个 &lt;code&gt;.tix&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="2384eda70bde5fbafcdce06c7083ad1f34fba13d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="translated">写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 使用区域设置编码。</target>
        </trans-unit>
        <trans-unit id="641fdc517a3a148a3426445c3e2501afc543647f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19f5831180b0536c875f7fde0710ba2f6b629a3f" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="993b7cc9e4c74d2721eedc685664742cc7c82795" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机端序编写本机 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="025b69c4396276807676b294d74b3b70f46bef94" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="translated">以大端IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="2300f23523bc1b33ccbbebf657381c02dd05c86c" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="translated">以小尾数IEEE-754格式编写 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a6e3e08979b85f7f159802afa8ee51f8a4eedd1" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="translated">以IEEE-754格式和主机字节序编写原生 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="100ddab2dd798658dd4fbb44584d4757dded426e" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; using the locale encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cb939ce09480dcfa16a616504013b186c6decd" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ec2c319cd8c0e2c3a0c3951b37ec1585cee156" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545e766b627e659fd52bff3acf015eb9994ae5c5" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Double&quot;&gt;Double&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65b44a7ea8883932f7651be10c9246fc522dca8" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in big endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead3e3f2656945a589c0165356d2eb079e613140" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in little endian IEEE-754 format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2feadbf9adb1a358b7e0093340ebf583af8879d" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#t:Float&quot;&gt;Float&lt;/a&gt;&lt;/code&gt; in native in IEEE-754 format and host endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed5c3f805685b995398b8616a908c0066ad70a" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="ca463eab69a5fff98e0ab2e75dce7ed014b9ab1b" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="3ad21d75c6a544747e2e36fcec12a87a1aebe727" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="a8e6f690eb143ffdbea5335db0be7244660876a2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to a file.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy-char8#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 写入文件。</target>
        </trans-unit>
        <trans-unit id="244e830bbe30fb0c3258c35cfc26647f07415c80" translate="yes" xml:space="preserve">
          <source>Write a ByteString to a handle, appending a newline byte</source>
          <target state="translated">写一个ByteString到一个句柄,附加一个新行字节。</target>
        </trans-unit>
        <trans-unit id="a70a82a5347cdeed11b696c9567115f30a6a5296" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout</source>
          <target state="translated">写一个ByteString到stdout</target>
        </trans-unit>
        <trans-unit id="e8ad66b8476a9e49cc072f07250605c906e95e94" translate="yes" xml:space="preserve">
          <source>Write a ByteString to stdout, appending a newline byte</source>
          <target state="translated">写一个ByteString到stdout,附加一个新行字节。</target>
        </trans-unit>
        <trans-unit id="c0c3cc8f4573e40e62c43e8422d4118f97ea3fea" translate="yes" xml:space="preserve">
          <source>Write a Int16 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="9d73a70f9f179a81035be58cee26e559014c575a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="7d8b2b4323c44fde9919abbfb9988c387020100a" translate="yes" xml:space="preserve">
          <source>Write a Int16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Int16。将写入2个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="fb3123d3e54a5bdf6aa5b4391bbf7b28df79fb37" translate="yes" xml:space="preserve">
          <source>Write a Int32 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="7e919ad40c1b9ea38485684cbf74d8a9568b9af7" translate="yes" xml:space="preserve">
          <source>Write a Int32 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="c8c3c578503e8e7468915f61ff1fa6751340cce3" translate="yes" xml:space="preserve">
          <source>Write a Int32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Int32。将写入4个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="b4e181d3a02580a355986a71c12d4507242968cf" translate="yes" xml:space="preserve">
          <source>Write a Int64 in big endian format</source>
          <target state="translated">以大恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="6a15b266b9877bbd729c40ccb87aa3db359c9f58" translate="yes" xml:space="preserve">
          <source>Write a Int64 in little endian format</source>
          <target state="translated">用小恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="001b75a9a615fe6648502bcfe94fd2920ba86af5" translate="yes" xml:space="preserve">
          <source>Write a Int64 in native host order. On a 32 bit machine we write two host order Int32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">按原生主机顺序写一个Int64。在32位的机器上,我们以大恩迪安形式写入两个主机顺序的Int32。将写入8个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="50fde014dba0a50360d764d6c2704238d9a9cb90" translate="yes" xml:space="preserve">
          <source>Write a String using UTF-8 encoding.</source>
          <target state="translated">使用UTF-8编码编写一个字符串。</target>
        </trans-unit>
        <trans-unit id="ca1a04969f07426c1e00b1b3766e301003971851" translate="yes" xml:space="preserve">
          <source>Write a Unicode string to the user's standard output.</source>
          <target state="translated">将Unicode字符串写入用户的标准输出。</target>
        </trans-unit>
        <trans-unit id="de13c62099cbcafc759fb5510fbb414e0c611d13" translate="yes" xml:space="preserve">
          <source>Write a Word16 in big endian format</source>
          <target state="translated">用大字报格式写一篇Word16的文章</target>
        </trans-unit>
        <trans-unit id="1d3480abbd86fc7688fd650a23916c935ed2b876" translate="yes" xml:space="preserve">
          <source>Write a Word16 in little endian format</source>
          <target state="translated">写一个Word16的小恩字格式。</target>
        </trans-unit>
        <trans-unit id="374953a98335b9e84fa5e0a4c035b46b2a892799" translate="yes" xml:space="preserve">
          <source>Write a Word16 in native host order and host endianness. 2 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Word16。将写入2个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="b1d543a7902bc6e8e15046b66cf37db05811d00c" translate="yes" xml:space="preserve">
          <source>Write a Word32 in big endian format</source>
          <target state="translated">用大英字型写一个Word32的格式。</target>
        </trans-unit>
        <trans-unit id="426bab66f99e758605e62a76ce97b5ce1321c0e7" translate="yes" xml:space="preserve">
          <source>Write a Word32 in little endian format</source>
          <target state="translated">写一个Word32的小恩迪格式。</target>
        </trans-unit>
        <trans-unit id="22533b04aaf4738c420c7810c743da18ca10d4e0" translate="yes" xml:space="preserve">
          <source>Write a Word32 in native host order and host endianness. 4 bytes will be written, unaligned.</source>
          <target state="translated">按主机顺序和主机字节数写一个Word32。将写入4个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="d00bd933478ce30ee3627449becbce383505e676" translate="yes" xml:space="preserve">
          <source>Write a Word64 in big endian format</source>
          <target state="translated">用大字报格式写一篇Word64的文章</target>
        </trans-unit>
        <trans-unit id="1ccded859c25705e9ae2dccba946964f2b4b599e" translate="yes" xml:space="preserve">
          <source>Write a Word64 in little endian format</source>
          <target state="translated">写一个Word64的小恩迪格式。</target>
        </trans-unit>
        <trans-unit id="fe8b5771af7a4fe3ab30f772b71da7013250ca90" translate="yes" xml:space="preserve">
          <source>Write a Word64 in native host order. On a 32 bit machine we write two host order Word32s, in big endian form. 8 bytes will be written, unaligned.</source>
          <target state="translated">按原生主机顺序写一个Word64。在32位的机器上,我们写两个主机顺序的Word32,以大恩迪亚形式。将写入8个字节,不对齐。</target>
        </trans-unit>
        <trans-unit id="d084d0a0a3ee70356c669bbf84781436e439ab8d" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="translated">将给定偏移量的字符写入数组。返回写入的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的数量。</target>
        </trans-unit>
        <trans-unit id="841f4e3a7f9355477f1154322e4d479f881e0fd9" translate="yes" xml:space="preserve">
          <source>Write a character into the array at the given offset. Returns the number of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;s written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824db4935989674b3e285858238d002d124cd8b6" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="f3d825454d2db1c3d3f226a28bb4ebdfec603097" translate="yes" xml:space="preserve">
          <source>Write a character to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutChar&quot;&gt;hPutChar&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="955d70d1572c0c0ab9646927bdac5ea547ae35f8" translate="yes" xml:space="preserve">
          <source>Write a character using UTF-8 encoding.</source>
          <target state="translated">用UTF-8编码写一个字符。</target>
        </trans-unit>
        <trans-unit id="0a40d25653018769760da200e171fb69042b97ba" translate="yes" xml:space="preserve">
          <source>Write a floating point value to a &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将浮点值写入 &lt;code&gt;&lt;a href=&quot;data-text-lazy-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f0e537457e84f16fbaa39fa0827e8c740824c36" translate="yes" xml:space="preserve">
          <source>Write a lazy ByteString efficiently, simply appending the lazy ByteString chunks to the output buffer</source>
          <target state="translated">高效地写入一个懒惰的ByteString,只需将懒惰的ByteString分块追加到输出缓冲区即可。</target>
        </trans-unit>
        <trans-unit id="4a5a6f538364d52e8d401c4fc9299b67f51eb2c1" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values (like &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt;, but for multiple elements).</source>
          <target state="translated">将可存储元素列表写入一个新分配的，可存储值的连续序列中（类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-utils#v:new&quot;&gt;new&lt;/a&gt;&lt;/code&gt; ，但是用于多个元素）。</target>
        </trans-unit>
        <trans-unit id="cdf3a3bd7d79bb717fec0614e932a3f554e7d129" translate="yes" xml:space="preserve">
          <source>Write a list of storable elements into a newly allocated, consecutive sequence of storable values, where the end is fixed by the given end marker</source>
          <target state="translated">将一个可存储元素列表写入一个新分配的、连续的可存储值序列中,其中结束由给定的结束标记固定下来</target>
        </trans-unit>
        <trans-unit id="46dde6be964e98cc511af24b16c6e57e81e0249e" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ded1b880637c536601d5622865a8ac5bee12d73f" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;data-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b15bee858199106a92ca21868dcf92516cce78a" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-ioarray#t:IOArray&quot;&gt;IOArray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfd1ae109907abef00a2e666c2fb353f397524eb" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0bbd3fd99a0c8ca169dc0a0800f474e5f53bf14" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;ghc-stref#t:STRef&quot;&gt;STRef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a779d08a6f4043a50272816a75acd9ee4cacd4c" translate="yes" xml:space="preserve">
          <source>Write a new value into an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将新值写入 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20f4593948df5a33a2e433f875c4b3f08e697cff" translate="yes" xml:space="preserve">
          <source>Write a string the end of a file.</source>
          <target state="translated">在文件末尾写一个字符串。</target>
        </trans-unit>
        <trans-unit id="c180f2e1d927a73773a56afa0d7e8518dedba44e" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ，后跟换行符。</target>
        </trans-unit>
        <trans-unit id="f7e8eefc7a202ba520c173df9a961b393fa4acc7" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将字符串写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f730ea108860688ef12de2017ea9ad535914f4" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, followed by a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c0c99c259a0bae8a5de169024806ed9278e047" translate="yes" xml:space="preserve">
          <source>Write a string to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7142ba8529e9f3798882070ee18b16fa9830450d" translate="yes" xml:space="preserve">
          <source>Write a string to a file. The file is truncated to zero length before writing begins.</source>
          <target state="translated">将一个字符串写入一个文件。在开始写之前,文件被截断为零长度。</target>
        </trans-unit>
        <trans-unit id="1c2990ff65d290d7bbb87a7564d0e4e76c8f8255" translate="yes" xml:space="preserve">
          <source>Write a string to a handle, followed by a newline.</source>
          <target state="translated">将一个字符串写入一个句柄,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="bd7a02731ecdcdf45341edba546df5ac23933c67" translate="yes" xml:space="preserve">
          <source>Write a string to a handle.</source>
          <target state="translated">将一个字符串写入一个句柄。</target>
        </trans-unit>
        <trans-unit id="ece9511f02a82892ce27b96dda3476e25a7fbdb9" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符串写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="ffa575f023b590cb0185153c4e3bb7bcdf3ca8ca" translate="yes" xml:space="preserve">
          <source>Write a string to the standard output device (same as &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">将字符串写入标准输出设备（与 &lt;code&gt;&lt;a href=&quot;system-io#v:hPutStr&quot;&gt;hPutStr&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:stdout&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="9ddf3308755406ffab4fefd34e1c0f532c36bfca" translate="yes" xml:space="preserve">
          <source>Write a string to the user's standard output, followed by a newline.</source>
          <target state="translated">在用户的标准输出中写入一个字符串,后面加一个换行。</target>
        </trans-unit>
        <trans-unit id="d649865e90fcbff9ffe50b1a59105ee5172bcad2" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">给 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 写价值。</target>
        </trans-unit>
        <trans-unit id="9bb0e77531d8dd5855a5dee42f98bdfb66dea502" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt;; blocks if the queue is full.</source>
          <target state="translated">向 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#t:TBQueue&quot;&gt;TBQueue&lt;/a&gt;&lt;/code&gt; 写一个值；如果队列已满，则阻塞。</target>
        </trans-unit>
        <trans-unit id="9b880d3a6f95fb0643f6f8cb86d9febe4b457c2d" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#t:TChan&quot;&gt;TChan&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="502f2a89fe6ab954ea36d4a5f5ae4da0588aaadf" translate="yes" xml:space="preserve">
          <source>Write a value to a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#t:TQueue&quot;&gt;TQueue&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b003c4b3a259d538a4ba6bcb5c8dd4f54a8c348a" translate="yes" xml:space="preserve">
          <source>Write a value to a memory area regarded as an array of values of the same kind. The following equality holds:</source>
          <target state="translated">将一个值写入一个被视为同类值数组的内存区域。下面的平等关系成立:</target>
        </trans-unit>
        <trans-unit id="2278658d6c531603ea71643e435890480712f25e" translate="yes" xml:space="preserve">
          <source>Write a value to a memory location given by a base address and offset. The following equality holds:</source>
          <target state="translated">将一个值写入由基地址和偏移量给出的内存位置。下面的等价关系成立:</target>
        </trans-unit>
        <trans-unit id="d2bcb5f72dff224c65e70a09f3049dbb8677df2f" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array of scalars; offset is in scalar elements.</source>
          <target state="translated">将一个向量写入标量数组的指定索引,偏移量以标量元素为单位。</target>
        </trans-unit>
        <trans-unit id="47fbcdcf5427d81f8e800b2a3be52a9b2780f1f2" translate="yes" xml:space="preserve">
          <source>Write a vector to specified index of mutable array.</source>
          <target state="translated">向可变数组的指定索引写入一个向量。</target>
        </trans-unit>
        <trans-unit id="2cbdaab506338b440edffc79752d43d3b372babf" translate="yes" xml:space="preserve">
          <source>Write an Int16 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="a4e76ca260148b04e485fd2b3ab9435bef6ca68d" translate="yes" xml:space="preserve">
          <source>Write an Int16 in little endian format</source>
          <target state="translated">用小恩迪恩格式写一个Int16。</target>
        </trans-unit>
        <trans-unit id="04d7dd93d431136691244f8a8060c6f710b4c9c7" translate="yes" xml:space="preserve">
          <source>Write an Int32 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="ac3eecde6710e67b4fbd62fe5faea7085564b9e9" translate="yes" xml:space="preserve">
          <source>Write an Int32 in little endian format</source>
          <target state="translated">用小恩迪亚格式写一个Int32。</target>
        </trans-unit>
        <trans-unit id="4ecb73c918eeb208591574c27bf43973ceabac8a" translate="yes" xml:space="preserve">
          <source>Write an Int64 in big endian format</source>
          <target state="translated">用大恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="062b3fd33b7744aa05c8b488aac57bd5719de134" translate="yes" xml:space="preserve">
          <source>Write an Int64 in little endian format</source>
          <target state="translated">用小恩迪安格式写一个Int64。</target>
        </trans-unit>
        <trans-unit id="f3475a216b60f541f9561999947a42033537d47f" translate="yes" xml:space="preserve">
          <source>Write an element in a mutable array</source>
          <target state="translated">在一个可变数组中写入一个元素</target>
        </trans-unit>
        <trans-unit id="3a6dc8d047fec7b46b0233f24f9a28adcd679e26" translate="yes" xml:space="preserve">
          <source>Write an entire list of items to a &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">把物品的整个清单写到一个 &lt;code&gt;&lt;a href=&quot;control-concurrent-chan#t:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="f9599a175165c39f1f29ddd9bb8c7e18497bf06b" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;MutVar#&lt;/code&gt;.</source>
          <target state="translated">编写 &lt;code&gt;MutVar#&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="842c4baf59de10dbe1f4228d4e89548eb6cfad90" translate="yes" xml:space="preserve">
          <source>Write contents of &lt;code&gt;TVar#&lt;/code&gt;.</source>
          <target state="translated">编写 &lt;code&gt;TVar#&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="a3de1d04f7bf6af5e972546fb7777d6bafc52d88" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="translated">将内存中的数据写入 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt; 。这完全等同于POSIX &lt;code&gt;write&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="3589adf6c850b011d135abac8239e99774d7263d" translate="yes" xml:space="preserve">
          <source>Write data from memory to an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-posix-types#t:Fd&quot;&gt;Fd&lt;/a&gt;&lt;/code&gt;. This is exactly equivalent to the POSIX &lt;code&gt;write&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c15fb50864a59ead622c1afb8db98eae0916f34" translate="yes" xml:space="preserve">
          <source>Write file in UTF-8 encoding. Parent directory will be created if missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7773c80499d5b3f15854fd0b2e72f86ef50f9e8" translate="yes" xml:space="preserve">
          <source>Write given error message to &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; and terminate with &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定的错误消息写入 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:stderr&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 并以 &lt;code&gt;&lt;a href=&quot;system-exit#v:exitFailure&quot;&gt;exitFailure&lt;/a&gt;&lt;/code&gt; 终止。</target>
        </trans-unit>
        <trans-unit id="4355c147f16522d41a43d5a06119aedec6f7144b" translate="yes" xml:space="preserve">
          <source>Write output from main C-\- pipeline passes to files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96bdb27f817c3c1baec26eb6ded0edc44bb3c99" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定值写入给定存储位置。对齐限制可能适用；见 &lt;code&gt;&lt;a href=&quot;foreign-storable#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77655bd9fbe731998656fdcf621486c02b0a375a" translate="yes" xml:space="preserve">
          <source>Write the given value to the given memory location. Alignment restrictions might apply; see &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将给定值写入给定存储位置。对齐限制可能适用；见 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:peek&quot;&gt;peek&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="babfd98df4815040b9b8feaf92e4a373432b470f" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory</source>
          <target state="translated">将列表元素连续写入内存</target>
        </trans-unit>
        <trans-unit id="c13f0a2faae8bb31701cafde84fa1d469581a021" translate="yes" xml:space="preserve">
          <source>Write the list elements consecutive into memory and terminate them with the given marker element</source>
          <target state="translated">将列表元素连续写入内存,并以给定的标记元素结束。</target>
        </trans-unit>
        <trans-unit id="4bfb3401061c515a5bf897d647437c6e727895e8" translate="yes" xml:space="preserve">
          <source>Write the specified number of bytes.</source>
          <target state="translated">写入指定数量的字节。</target>
        </trans-unit>
        <trans-unit id="7948630f19859069bae4a14e2c76f2c7020b9d2a" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8756d20514051c6080e747e02c7172e182a101af" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;ghc-conc#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27a7a93b6c3f65c763bd60036589804bd7bf721" translate="yes" xml:space="preserve">
          <source>Write the supplied value into a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将提供的值写入 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:TVar&quot;&gt;TVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="155f12112f4379352bcdee8335e8ff9abd964e75" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the standard output device.</source>
          <target state="translated">将终端输出写入标准输出设备。</target>
        </trans-unit>
        <trans-unit id="2ffb13840f565fd761a331ddc6dc0237d509420b" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将终端输出写入到由给定 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 管理的终端或文件中。</target>
        </trans-unit>
        <trans-unit id="3cd750e768a4d8f40411b104e6eddf083a4f201a" translate="yes" xml:space="preserve">
          <source>Write the terminal output to the terminal or file managed by the given &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bab7a81286ec426207ad20332db127f5e40c79b" translate="yes" xml:space="preserve">
          <source>Write to specified index of mutable array.</source>
          <target state="translated">写入指定的可变数组索引。</target>
        </trans-unit>
        <trans-unit id="faa64ad5644001c4c4dc3bee878a933e8c8aac0e" translate="yes" xml:space="preserve">
          <source>Write up to the specified number of bytes without blocking. Returns the actual number of bytes written.</source>
          <target state="translated">无阻塞地写入指定的字节数。返回实际写入的字节数。</target>
        </trans-unit>
        <trans-unit id="74120aff54b3ed793ccfa34d37318c6efb458636" translate="yes" xml:space="preserve">
          <source>Write vector; offset in bytes.</source>
          <target state="translated">写入向量;偏移量(字节)。</target>
        </trans-unit>
        <trans-unit id="fd96182628831a4dab0848bbbb0a8a86256945c3" translate="yes" xml:space="preserve">
          <source>Write vector; offset in scalar elements.</source>
          <target state="translated">写入向量;偏移量为标量元素。</target>
        </trans-unit>
        <trans-unit id="e1f97fa6627971c9b0e683428fd5abfab1ecbdb9" translate="yes" xml:space="preserve">
          <source>Write? (False = read-only)</source>
          <target state="translated">写?(False=只读)</target>
        </trans-unit>
        <trans-unit id="09c7377b67eee34defdc1dd0804c879b090650d2" translate="yes" xml:space="preserve">
          <source>WriteBuffer</source>
          <target state="translated">WriteBuffer</target>
        </trans-unit>
        <trans-unit id="3082b1ffe24322eee941ed215c852cffc7410d42" translate="yes" xml:space="preserve">
          <source>WriteHandle</source>
          <target state="translated">WriteHandle</target>
        </trans-unit>
        <trans-unit id="9ee45a046a695fc62952355259c464d3782298a5" translate="yes" xml:space="preserve">
          <source>WriteLock</source>
          <target state="translated">WriteLock</target>
        </trans-unit>
        <trans-unit id="60841bf1ad2d01720515c6eb9b3efbeb2e0f7656" translate="yes" xml:space="preserve">
          <source>WriteMode</source>
          <target state="translated">WriteMode</target>
        </trans-unit>
        <trans-unit id="f5ca54e8210ce7deaf5fa1129a91a1f50f08386a" translate="yes" xml:space="preserve">
          <source>WriteOnly</source>
          <target state="translated">WriteOnly</target>
        </trans-unit>
        <trans-unit id="5f435830a7c07f19c4072a88821b38028c3f69e6" translate="yes" xml:space="preserve">
          <source>Writer</source>
          <target state="translated">Writer</target>
        </trans-unit>
        <trans-unit id="a8f135f9c50f7fe5f7a287362386d791fee8800a" translate="yes" xml:space="preserve">
          <source>Writer operations</source>
          <target state="translated">写字机操作</target>
        </trans-unit>
        <trans-unit id="a123ab5d3541d6386c9d34765c7348e78d2bb09e" translate="yes" xml:space="preserve">
          <source>WriterT</source>
          <target state="translated">WriterT</target>
        </trans-unit>
        <trans-unit id="1cccc800c778fc7aea514948aa922ecafd4399e9" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 数组写入指定的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d30a3e22fd6539c1c9d94fc5b04d15e2c9f7e725" translate="yes" xml:space="preserve">
          <source>Writes an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; to the specified &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2b97a0aaa412174782d8ac6874c3f7cc18e81e9" translate="yes" xml:space="preserve">
          <source>Writes out extended interface files alongisde regular enterface files. Just like regular interface files, GHC has a recompilation check to detect out of date or missing extended interface files.</source>
          <target state="translated">将扩展接口文件与普通的enterface文件一起写出来。就像普通的接口文件一样,GHC有一个重新编译检查,以检测过时或丢失的扩展接口文件。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
