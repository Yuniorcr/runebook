<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="a7fc1755b99d460ddf9637e41ae7dfe1a9d17f2f" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
        <trans-unit id="5ae0796132c03a976f52dda473c00aecb4b90673" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, so the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; does not require a finalizer to free the memory. Use of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; and associated functions is strongly recommended in preference to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; with a finalizer.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。它在垃圾收集堆中使用固定的内存，因此 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 不需要终结器来释放内存。强烈建议使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 和关联的函数，而 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 使用带有终结器的newForeignPtr。</target>
        </trans-unit>
        <trans-unit id="24fb1c4b67d287bddf5427dde444bedfc6f05944" translate="yes" xml:space="preserve">
          <source>GHC notes: &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; has a heavily optimised implementation in GHC. It uses pinned memory in the garbage collected heap, as for mallocForeignPtr. Unlike mallocForeignPtr, a ForeignPtr created with mallocPlainForeignPtr carries no finalizers. It is not possible to add a finalizer to a ForeignPtr created with mallocPlainForeignPtr. This is useful for ForeignPtrs that will live only inside Haskell (such as those created for packed strings). Attempts to add a finalizer to a ForeignPtr created this way, or to finalize such a pointer, will throw an exception.</source>
          <target state="translated">GHC注意： &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocPlainForeignPtr&quot;&gt;mallocPlainForeignPtr&lt;/a&gt;&lt;/code&gt; 在GHC中实现了高度优化的实现。与mallocForeignPtr一样，它在垃圾回收堆中使用固定的内存。与mallocForeignPtr不同，使用mallocPlainForeignPtr创建的ForeignPtr不包含终结器。无法将终结器添加到使用mallocPlainForeignPtr创建的ForeignPtr中。这对于仅存在于Haskell内的ForeignPtr（例如为打包字符串创建的ForeignPtr）很有用。尝试将终结器添加到以此方式创建的ForeignPtr或终结该指针，将引发异常。</target>
        </trans-unit>
        <trans-unit id="d58dcbe271b06625548680cc1dda88780faf7c0e" translate="yes" xml:space="preserve">
          <source>GHC now instead allows you to specify the kind of a type variable directly, wherever a type variable is explicitly bound, with the extension &lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在，GHC允许您直接使用扩展名&lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt;来指定类型变量的种类，无论类型变量是否被显式绑定。</target>
        </trans-unit>
        <trans-unit id="c69341d0b595bd8749c9faf56b39f2a229d74154" translate="yes" xml:space="preserve">
          <source>GHC now permits such instances to be derived instead, using the extension &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;, so one can write</source>
          <target state="translated">GHC现在允许使用扩展&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;派生此类实例，因此可以编写</target>
        </trans-unit>
        <trans-unit id="af2ccd36d80a45d87b36d0a6f6c0151c8a23dc7f" translate="yes" xml:space="preserve">
          <source>GHC now supports a new way to coordinate the activities of Concurrent Haskell threads, called Software Transactional Memory (STM). The &lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM papers&lt;/a&gt; are an excellent introduction to what STM is, and how to use it.</source>
          <target state="translated">GHC现在支持一种用于协调并发Haskell线程活动的新方法，称为软件事务存储（STM）。该&lt;a href=&quot;https://wiki.haskell.org/Research_papers/Parallelism_and_concurrency#Lock_free_data_structures_and_transactional_memory&quot;&gt;STM文件&lt;/a&gt;是一个很好的介绍STM是什么，以及如何使用它。</target>
        </trans-unit>
        <trans-unit id="64f783c1668ce53c92c18c3d1d3894883677132f" translate="yes" xml:space="preserve">
          <source>GHC offers a helping hand here, doing all of this for you. For every use of &lt;code&gt;assert&lt;/code&gt; in the user&amp;rsquo;s source:</source>
          <target state="translated">GHC在这里为您提供帮助。对于用户源中的 &lt;code&gt;assert&lt;/code&gt; 的每次使用：</target>
        </trans-unit>
        <trans-unit id="fcb7a200658d0d266c01f6180b030b6fa3a1603b" translate="yes" xml:space="preserve">
          <source>GHC only knows about packages that are &lt;em&gt;installed&lt;/em&gt;. Installed packages live in package databases. For details on package databases and how to control which package databases or specific set of packages are visible to GHC, see &lt;a href=&quot;#package-databases&quot;&gt;Package Databases&lt;/a&gt;.</source>
          <target state="translated">GHC只知道已&lt;em&gt;安装的&lt;/em&gt;软件包。已安装的软件包位于软件包数据库中。有关软件包数据库以及如何控制GHC可以看到哪些软件包数据库或特定的一组软件包的详细信息，请参见&lt;a href=&quot;#package-databases&quot;&gt;软件包数据库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="044a66191238583d5e4cb81ccc743141923ed216" translate="yes" xml:space="preserve">
          <source>GHC performs implicit quantification as follows. At the outermost level (only) of user-written types, if and only if there is no explicit &lt;code&gt;forall&lt;/code&gt;, GHC finds all the type variables mentioned in the type that are not already in scope, and universally quantifies them. For example, the following pairs are equivalent:</source>
          <target state="translated">GHC如下执行隐式量化。在用户编写的类型的最外层（仅），当且仅当没有显式的 &lt;code&gt;forall&lt;/code&gt; 时，GHC 才会找到该类型中提到的所有不在范围内的类型变量，并对其进行通用量化。例如，以下对等效：</target>
        </trans-unit>
        <trans-unit id="e903f8397c8f5bbb60d7d8d13ff6bba05d63b1b1" translate="yes" xml:space="preserve">
          <source>GHC permits writing kinds with this syntax, provided that the &lt;code&gt;ExplicitForAll&lt;/code&gt; and &lt;code&gt;PolyKinds&lt;/code&gt; language extensions are enabled. Just like the invisible &lt;code&gt;forall&lt;/code&gt;, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</source>
          <target state="translated">如果启用了 &lt;code&gt;ExplicitForAll&lt;/code&gt; 和 &lt;code&gt;PolyKinds&lt;/code&gt; 语言扩展，GHC允许使用这种语法编写类型。就像不可见的 &lt;code&gt;forall&lt;/code&gt; 一样，可以在显式绑定的种类变量上放置显式种类签名，因此以下语句在语法上有效：</target>
        </trans-unit>
        <trans-unit id="d06dacacd81451db2de5b66239661a3e25c08242" translate="yes" xml:space="preserve">
          <source>GHC re-calculates the dependencies each time it is invoked, so the dependencies never get out of sync with the source.</source>
          <target state="translated">GHC在每次调用时都会重新计算依赖关系,所以依赖关系永远不会与源码不同步。</target>
        </trans-unit>
        <trans-unit id="176ba65a9c9ed02539731d0438e0a1ebfea8e580" translate="yes" xml:space="preserve">
          <source>GHC relaxes this rule in two ways:</source>
          <target state="translated">GHC在两个方面放宽了这一规则。</target>
        </trans-unit>
        <trans-unit id="12676104a819fe3298a0f123f390ea42a18a068d" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;lsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC报告错误，说是那种 &lt;code&gt;a&lt;/code&gt; 应该是一种可变 &lt;code&gt;k&lt;/code&gt; ，而不是 &lt;code&gt;Type&lt;/code&gt; 。这是因为，通过查看所有类型的签名 &lt;code&gt;forall a. Proxy a&lt;/code&gt; ，GHC假定 &lt;code&gt;a&lt;/code&gt; 的种类应被概括，而不限于 &lt;code&gt;Type&lt;/code&gt; 。然后，由于功能定义比其类型签名更具体，该功能定义被拒绝。</target>
        </trans-unit>
        <trans-unit id="5c1031c0bc27b3b9bb273d87c196ba3e6cd2a9cd" translate="yes" xml:space="preserve">
          <source>GHC reports an error, saying that the kind of &lt;code&gt;a&lt;/code&gt; should be a kind variable &lt;code&gt;k&lt;/code&gt;, not &lt;code&gt;Type&lt;/code&gt;. This is because, by looking at the type signature &lt;code&gt;forall a. Proxy a&lt;/code&gt;, GHC assumes &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s kind should be generalised, not restricted to be &lt;code&gt;Type&lt;/code&gt;. The function definition is then rejected for being more specific than its type signature.</source>
          <target state="translated">GHC报告错误，说是那种 &lt;code&gt;a&lt;/code&gt; 应该是一种可变 &lt;code&gt;k&lt;/code&gt; ，而不是 &lt;code&gt;Type&lt;/code&gt; 。这是因为，通过查看所有类型的签名 &lt;code&gt;forall a. Proxy a&lt;/code&gt; ，GHC假定 &lt;code&gt;a&lt;/code&gt; 的那种应该一概而论，并不限定为 &lt;code&gt;Type&lt;/code&gt; 。然后，由于功能定义比其类型签名更具体，该功能定义被拒绝。</target>
        </trans-unit>
        <trans-unit id="3372876691ddf4da952bbb863dd592b0bdfda843" translate="yes" xml:space="preserve">
          <source>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</source>
          <target state="translated">GHC要求在存在独立的种类签名的情况下,数据声明必须绑定其所有输入。例如:</target>
        </trans-unit>
        <trans-unit id="8ce6db855a940e9d5cc1b17135bac5edb333da21" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC要求使用 &lt;code&gt;hs-boot&lt;/code&gt; 文件来减少相互递归模块之间的递归循环，如&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中所述&lt;/a&gt;。Haskell报告说（&lt;a href=&quot;http://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;第5.7节&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="4c0df0543846c60d8bf0811b701c64203f4bb433" translate="yes" xml:space="preserve">
          <source>GHC requires the use of &lt;code&gt;hs-boot&lt;/code&gt; files to cut the recursive loops among mutually recursive modules as described in &lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;How to compile mutually recursive modules&lt;/a&gt;. This more of an infelicity than a bug: the Haskell Report says (&lt;a href=&quot;https://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;Section 5.7&lt;/a&gt;)</source>
          <target state="translated">GHC要求使用 &lt;code&gt;hs-boot&lt;/code&gt; 文件来减少相互递归模块之间的递归循环，如&lt;a href=&quot;separate_compilation#mutual-recursion&quot;&gt;如何编译相互递归模块中所述&lt;/a&gt;。 Haskell报告说（这是&lt;a href=&quot;https://haskell.org/onlinereport/modules.html#sect5.7&quot;&gt;第5.7节&lt;/a&gt;），更多的是愚昧而不是错误。</target>
        </trans-unit>
        <trans-unit id="879d61f80d5636605c655dddfca637fdc98e1ecb" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC通过三个步骤解决了 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="d6ca94a0a11ffefc0bfeb9a72c46f7879523913b" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraints in three steps:</source>
          <target state="translated">GHC通过三个步骤解决了 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; 约束：</target>
        </trans-unit>
        <trans-unit id="0af504294df234353ca10b5e8500115149162959" translate="yes" xml:space="preserve">
          <source>GHC solves &lt;code&gt;HasCallStack&lt;/code&gt; constraints in two steps:</source>
          <target state="translated">GHC &lt;code&gt;HasCallStack&lt;/code&gt; 解决了HasCallStack约束：</target>
        </trans-unit>
        <trans-unit id="5fb168dd0c0c05efa3e7b65980a111be49e483f6" translate="yes" xml:space="preserve">
          <source>GHC sometimes suggests valid hole fits for typed holes, which is configurable by a few flags.</source>
          <target state="translated">GHC有时会对类型化的孔提出有效的孔配合,这可以通过一些标志来配置。</target>
        </trans-unit>
        <trans-unit id="bbd754859d95122a24081dbae7deca815e9a4eb6" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;kind-indexed&lt;/em&gt; type families, where the family matches both on the kind and type. GHC will &lt;em&gt;not&lt;/em&gt; infer this behaviour without a complete user-supplied kind signature, as doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</source>
          <target state="translated">GHC支持&lt;em&gt;种类索引的&lt;/em&gt;类型族，其中族在类型和类型上都匹配。没有完整的用户提供的种类签名，GHC &lt;em&gt;不会&lt;/em&gt;推断出这种行为，因为这样做有时会推断出非主要类型。确实，我们可以将种类索引视为一种多态递归形式，其中一种类型在其定义中使用的种类不同于其最一般的种类。</target>
        </trans-unit>
        <trans-unit id="5c3dfb75078d385b6ef1bb4183e0a2d7abc030a2" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;lexically scoped type variables&lt;/em&gt;, without which some type signatures are simply impossible to write. For example:</source>
          <target state="translated">GHC支持按&lt;em&gt;词法作用域定义的类型变量&lt;/em&gt;，没有这些&lt;em&gt;变量&lt;/em&gt;，根本无法编写某些类型签名。例如：</target>
        </trans-unit>
        <trans-unit id="276796f5e524e49d992d91729272ac0e608e0dda" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded labels&lt;/em&gt;, a form of identifier whose interpretation may depend both on its type and on its literal text. When the &lt;a href=&quot;#extension-OverloadedLabels&quot;&gt;&lt;code&gt;OverloadedLabels&lt;/code&gt;&lt;/a&gt; extension is enabled, an overloaded label can be written with a prefix hash, for example &lt;code&gt;#foo&lt;/code&gt;. The type of this expression is &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC支持&lt;em&gt;重载标签&lt;/em&gt;，这是一种标识符形式，其解释可能取决于其类型和文字文本。当&lt;a href=&quot;#extension-OverloadedLabels&quot;&gt; &lt;code&gt;OverloadedLabels&lt;/code&gt; &lt;/a&gt;启用扩展，过载标签可以用前缀的散列被写入，例如 &lt;code&gt;#foo&lt;/code&gt; 。此表达式的类型为 &lt;code&gt;IsLabel &quot;foo&quot; a =&amp;gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6df65e180903b70882d6d577b9e27d68c01ffd47" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloaded string literals&lt;/em&gt;. Normally a string literal has type &lt;code&gt;String&lt;/code&gt;, but with overloaded string literals enabled (with &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt;) a string literal has type &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">GHC支持&lt;em&gt;重载字符串文字&lt;/em&gt;。通常，字符串文字的类型为 &lt;code&gt;String&lt;/code&gt; ，但是启用重载字符串文字（使用&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;）后，字符串文字的类型为 &lt;code&gt;(IsString a) =&amp;gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ef938ede98487b50d238f507d6fb11faed2c901" translate="yes" xml:space="preserve">
          <source>GHC supports &lt;em&gt;overloading of the list notation&lt;/em&gt;. Let us recap the notation for constructing lists. In Haskell, the list notation can be used in the following seven ways:</source>
          <target state="translated">GHC支持&lt;em&gt;列表符号的重载&lt;/em&gt;。让我们回顾一下构造列表的概念。在Haskell中，可以通过以下七种方式使用列表符号：</target>
        </trans-unit>
        <trans-unit id="a03b404046146b764985d1282deeeddd9a94f050" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC默认情况下支持并发Haskell，不需要特殊选项或以某种方式编译的库。要访问并发Haskell支持库，只需导入&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent即可&lt;/a&gt;。该模块的文档中提供了有关并发Haskell的更多信息。</target>
        </trans-unit>
        <trans-unit id="88817a222e891093a054f7b9fd3592132552247b" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC默认情况下支持并发Haskell，不需要特殊选项或以某种方式编译的库。要访问并发Haskell支持库，只需导入&lt;a href=&quot;../libraries/base-4.14.1.0/control-concurrent&quot;&gt;Control.Concurrent即可&lt;/a&gt;。该模块的文档中提供了有关并发Haskell的更多信息。</target>
        </trans-unit>
        <trans-unit id="db233c713810924b12363f8cfb5853ea8a7625d7" translate="yes" xml:space="preserve">
          <source>GHC supports Concurrent Haskell by default, without requiring a special option or libraries compiled in a certain way. To get access to the support libraries for Concurrent Haskell, just import &lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. More information on Concurrent Haskell is provided in the documentation for that module.</source>
          <target state="translated">GHC默认情况下支持并发Haskell，不需要特殊选项或以某种方式编译的库。要访问并发Haskell支持库，只需导入&lt;a href=&quot;../libraries/base-4.15.0.0/control-concurrent&quot;&gt;Control.Concurrent即可&lt;/a&gt;。该模块的文档中提供了有关并发Haskell的更多信息。</target>
        </trans-unit>
        <trans-unit id="87e3cb78467ec8b2b366442091554c58737c171b" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC支持的模式匹配称为扩展&lt;em&gt;爆炸图案&lt;/em&gt;，写 &lt;code&gt;!pat&lt;/code&gt; 。Haskell Prime正在考虑使用爆炸样式。在&lt;a href=&quot;http://ghc.haskell.org/trac/haskell-prime/wiki/BangPatterns&quot;&gt;Haskell的主要特征描述&lt;/a&gt;含有比下面的材料更多讨论和示例。</target>
        </trans-unit>
        <trans-unit id="5ee03e17c3bd4438a62f164c9dbdcc503c5b001f" translate="yes" xml:space="preserve">
          <source>GHC supports an extension of pattern matching called &lt;em&gt;bang patterns&lt;/em&gt;, written &lt;code&gt;!pat&lt;/code&gt;. Bang patterns are under consideration for Haskell Prime. The &lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns&quot;&gt;Haskell prime feature description&lt;/a&gt; contains more discussion and examples than the material below.</source>
          <target state="translated">GHC支持的模式匹配称为扩展&lt;em&gt;爆炸图案&lt;/em&gt;，写 &lt;code&gt;!pat&lt;/code&gt; 。对于Haskell Prime，Bang模式正在考虑中。在&lt;a href=&quot;https://gitlab.haskell.org/haskell/prime/-/wikis/BangPatterns&quot;&gt;Haskell的主要特征描述&lt;/a&gt;含有比下面的材料更多讨论和示例。</target>
        </trans-unit>
        <trans-unit id="1059d9fa9d503ddf0254f07f1659e4736d333d97" translate="yes" xml:space="preserve">
          <source>GHC supports arrays of unboxed elements, for several basic arithmetic element types including &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;: see the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; library for details. These arrays are likely to be much faster than using standard Haskell 98 arrays from the &lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt; library.</source>
          <target state="translated">GHC支持未装箱元素的数组，包括 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;Char&lt;/code&gt; 在内的几种基本算术元素类型：有关详细信息，请参见&lt;a href=&quot;../libraries/array-0.5.4.0/data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt;库。这些数组可能比使用&lt;a href=&quot;../libraries/array-0.5.4.0/data-array&quot;&gt;Data.Array&lt;/a&gt;库中的标准Haskell 98数组快得多。</target>
        </trans-unit>
        <trans-unit id="3948db87d05dfc40c1f63f054a27ea693124c87e" translate="yes" xml:space="preserve">
          <source>GHC supports both concurrency and parallelism.</source>
          <target state="translated">GHC同时支持并发和并行。</target>
        </trans-unit>
        <trans-unit id="a13a7734a043f66e1714f2fd0d2b999f5bd2929a" translate="yes" xml:space="preserve">
          <source>GHC supports multiple backend code generators. This is the part of the compiler responsible for taking the last intermediate representation that GHC uses (a form called Cmm that is a simple, C like language) and compiling it to executable code. The backends that GHC support are described below.</source>
          <target state="translated">GHC支持多个后端代码生成器。这是编译器的一部分,负责将GHC使用的最后一个中间表示法(一种叫做Cmm的形式,是一种简单的、类似于C的语言),编译成可执行代码。下面介绍一下GHC支持的后端。</target>
        </trans-unit>
        <trans-unit id="30f8743edba346dec74c124074534d3915ad7f3b" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC在类型级别支持数字和字符串文字，从而可以方便地访问大量预定义的类型级别常量。数值文字属于 &lt;code&gt;Nat&lt;/code&gt; 类型，字符串文字属于 &lt;code&gt;Symbol&lt;/code&gt; 类型。&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;语言扩展启用了此功能。</target>
        </trans-unit>
        <trans-unit id="460bfe239b04444ab072464eae0903da8dac0035" translate="yes" xml:space="preserve">
          <source>GHC supports numeric and string literals at the type level, giving convenient access to a large number of predefined type-level constants. Numeric literals are of kind &lt;code&gt;Nat&lt;/code&gt;, while string literals are of kind &lt;code&gt;Symbol&lt;/code&gt;. This feature is enabled by the &lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt; language extension.</source>
          <target state="translated">GHC在类型级别支持数字和字符串文字，从而可以方便地访问大量预定义的类型级别常量。数值文字的类型为 &lt;code&gt;Nat&lt;/code&gt; ，字符串文字的类型为 &lt;code&gt;Symbol&lt;/code&gt; 。&lt;a href=&quot;data_kinds#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;语言扩展启用了此功能。</target>
        </trans-unit>
        <trans-unit id="939d5d87113e9124e05b09bd482088142e25e21b" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;exts#ghc-language-features&quot;&gt;Language extensions&lt;/a&gt;.</source>
          <target state="translated">GHC支持多种语言扩展，包括并发，外部函数接口，异常，类型系统扩展（例如多参数类型类，局部通用和存在量化），功能依赖项，作用域类型变量和显式拆箱类型。这些都在&lt;a href=&quot;exts#ghc-language-features&quot;&gt;语言扩展中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="6c771ee603c6b7794f2ea84ef821582ce945de09" translate="yes" xml:space="preserve">
          <source>GHC supports numerous language extensions, including concurrency, a foreign function interface, exceptions, type system extensions such as multi-parameter type classes, local universal and existential quantification, functional dependencies, scoped type variables and explicit unboxed types. These are all described in &lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC Language Features&lt;/a&gt;.</source>
          <target state="translated">GHC支持多种语言扩展，包括并发，外部函数接口，异常，类型系统扩展（例如多参数类型类，局部通用和存在量化），功能依赖项，作用域类型变量和显式拆箱类型。这些都在&lt;a href=&quot;lang#ghc-language-features&quot;&gt;GHC语言功能中&lt;/a&gt;进行了描述。</target>
        </trans-unit>
        <trans-unit id="7dfeb95a50670f1d64eaee09cc2e384aca52156c" translate="yes" xml:space="preserve">
          <source>GHC supports running Haskell programs in parallel on an SMP (symmetric multiprocessor).</source>
          <target state="translated">GHC支持在SMP(对称多处理器)上并行运行Haskell程序。</target>
        </trans-unit>
        <trans-unit id="a087224f52d11f82f5a88e556729ad1748a912eb" translate="yes" xml:space="preserve">
          <source>GHC supports several pragmas, or instructions to the compiler placed in the source code. Pragmas don&amp;rsquo;t normally affect the meaning of the program, but they might affect the efficiency of the generated code.</source>
          <target state="translated">GHC支持多种编译指示，或在源代码中提供给编译器的指令。语法通常不会影响程序的含义，但可能会影响所生成代码的效率。</target>
        </trans-unit>
        <trans-unit id="64c6177d894ac3ebf6c13eb6a39c9b7bbe9fb3b9" translate="yes" xml:space="preserve">
          <source>GHC supports the compilation of mutually recursive modules. This section explains how.</source>
          <target state="translated">GHC支持相互递归模块的编译。本节将解释如何编译。</target>
        </trans-unit>
        <trans-unit id="2f567fb737ad360d88ce9083ecb2968678a51e95" translate="yes" xml:space="preserve">
          <source>GHC supports these language extensions:</source>
          <target state="translated">GHC支持这些语言扩展。</target>
        </trans-unit>
        <trans-unit id="b94800f31025b5e612b01265b145926a94da2a20" translate="yes" xml:space="preserve">
          <source>GHC supports these language options:</source>
          <target state="translated">GHC支持这些语言选项。</target>
        </trans-unit>
        <trans-unit id="376872360d159bedd1e4e2c8ef10c95b85bee963" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">GHC支持类型参数的三种不同角色：名义，代表性和幻像。如果类型参数具有名义上的作用，那么两个不同的类型实际上根本不能完全不同：它们必须是相同的（在减少类型族之后）。如果类型参数具有代表性，则两个类型必须具有相同的代表性。 （如果 &lt;code&gt;T&lt;/code&gt; 的第一个参数的角色是表示性的，则 &lt;code&gt;T Age Bool c&lt;/code&gt; 和 &lt;code&gt;T Int Bool c&lt;/code&gt; 将具有相同的表示形式，因为 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; 具有相同的表示形式。）如果类型参数具有幻像角色，则不需要更多信息。</target>
        </trans-unit>
        <trans-unit id="739585d733fbd90b635381ce1f62b05fe70f7220" translate="yes" xml:space="preserve">
          <source>GHC supports three different roles for type parameters: nominal, representational, and phantom. If a type parameter has a nominal role, then the two types that differ must not actually differ at all: they must be identical (after type family reduction). If a type parameter has a representational role, then the two types must have the same representation. (If &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s first parameter&amp;rsquo;s role is representational, then &lt;code&gt;T Age Bool c&lt;/code&gt; and &lt;code&gt;T Int Bool c&lt;/code&gt; would have the same representation, because &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; have the same representation.) If a type parameter has a phantom role, then we need no further information.</source>
          <target state="translated">对于类型参数，GHC支持三种不同的角色：名义，代表和幻像。如果类型参数具有名义上的作用，那么两个不同的类型实际上根本不能完全不同：它们必须是相同的（在减少类型族之后）。如果类型参数具有代表性，则两个类型必须具有相同的代表性。 （如果 &lt;code&gt;T&lt;/code&gt; 的第一个参数的角色是表示性的，则 &lt;code&gt;T Age Bool c&lt;/code&gt; 和 &lt;code&gt;T Int Bool c&lt;/code&gt; 将具有相同的表示形式，因为 &lt;code&gt;Age&lt;/code&gt; 和 &lt;code&gt;Int&lt;/code&gt; 具有相同的表示形式。）如果类型参数具有幻像角色，则不需要更多信息。</target>
        </trans-unit>
        <trans-unit id="f0d48f22ae2a3222802a96b3a539281e8893f263" translate="yes" xml:space="preserve">
          <source>GHC takes a conservative position: it accepts the first two, but not the third. The rule is this: each constraint in the inferred instance context must consist only of type variables, with no repetitions.</source>
          <target state="translated">GHC采取保守的立场:它接受前两个,但不接受第三个。规则是:推断的实例上下文中的每个约束必须只由类型变量组成,不能重复。</target>
        </trans-unit>
        <trans-unit id="af1345dfc47c5e1308fe80cc43e2e8fda6407651" translate="yes" xml:space="preserve">
          <source>GHC then checks for pattern coverage using each of these sets. If any of these sets passes the pattern coverage checker with no warnings, then we are done. If each set produces at least one warning, then GHC must pick one of the sets of warnings depending on how good the results are. The results are prioritized in this order:</source>
          <target state="translated">然后,GHC使用这些集合中的每一个检查模式覆盖率。如果这些集合中的任何一个都通过了模式覆盖率检查器,没有警告,那么我们就完成了。如果每个集合至少产生一个警告,那么GHC必须根据结果的好坏来选择其中的一个警告集合。结果的优先顺序是这样的。</target>
        </trans-unit>
        <trans-unit id="4f506a7b6cf4858f54fbbea3adb5c9aafc2629c4" translate="yes" xml:space="preserve">
          <source>GHC tracks a distinction between what we call &lt;em&gt;inferred&lt;/em&gt; and &lt;em&gt;specified&lt;/em&gt; type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</source>
          <target state="translated">GHC跟踪我们所谓的&lt;em&gt;推断&lt;/em&gt;类型变量和&lt;em&gt;指定&lt;/em&gt;类型变量之间的区别。仅指定的类型变量可用于可见类型应用程序的实例化。一个例子很好地说明了这一点：</target>
        </trans-unit>
        <trans-unit id="b0056c6884fc97fc67e74fdba9e10f40ad69bfb2" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general &lt;a href=&quot;#generic-programming&quot;&gt;support for generic programming&lt;/a&gt;.</source>
          <target state="translated">GHC曾经有一个通用类的实现，如&amp;ldquo;可派生类型类&amp;rdquo;一书中所定义，Ralf Hinze和Simon Peyton Jones，Haskell Workshop，蒙特利尔，2000年9月，第94-105页。这些已被删除，并由&lt;a href=&quot;#generic-programming&quot;&gt;对通用编程&lt;/a&gt;的更一般的支持代替。</target>
        </trans-unit>
        <trans-unit id="627722a7e95d92b125557fdd357037ba973fedc5" translate="yes" xml:space="preserve">
          <source>GHC used to have an implementation of generic classes as defined in the paper &amp;ldquo;Derivable type classes&amp;rdquo;, Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp. 94-105. These have been removed and replaced by the more general support for generic programming.</source>
          <target state="translated">GHC曾经有一个通用类的实现，如&amp;ldquo;可派生类型类&amp;rdquo;一书中所定义，Ralf Hinze和Simon Peyton Jones，Haskell Workshop，蒙特利尔，2000年9月，第94-105页。这些已被删除，并由对通用编程的更一般的支持所取代。</target>
        </trans-unit>
        <trans-unit id="6146a11d5bcfee2fd36a56319860854e84371c0e" translate="yes" xml:space="preserve">
          <source>GHC uses a copying garbage collector by default. &amp;ldquo;bytes copied during GC&amp;rdquo; tells you how many bytes it had to copy during garbage collection.</source>
          <target state="translated">GHC默认情况下使用复制垃圾收集器。&amp;ldquo; GC期间复制的字节&amp;rdquo;告诉您在垃圾回收期间必须复制多少字节。</target>
        </trans-unit>
        <trans-unit id="b767adcd6d48a9a1db03ff8580662a14fddf6ff9" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC使用&lt;a href=&quot;#instance-termination&quot;&gt;Paterson条件&lt;/a&gt;来确保实例解析终止。这些规则如何针对量化约束进行修改？有两种方式。</target>
        </trans-unit>
        <trans-unit id="2cee95ed1e9454c90ee163ac39effcbe97abffa1" translate="yes" xml:space="preserve">
          <source>GHC uses the &lt;a href=&quot;instances#instance-termination&quot;&gt;Paterson Conditions&lt;/a&gt; to ensure that instance resolution terminates. How are those rules modified for quantified constraints? In two ways.</source>
          <target state="translated">GHC使用&lt;a href=&quot;instances#instance-termination&quot;&gt;Paterson条件&lt;/a&gt;来确保实例解析终止。这些规则如何针对量化约束进行修改？有两种方式。</target>
        </trans-unit>
        <trans-unit id="edb26ddbc1a23bed4068def6c81bd9036a5beb4d" translate="yes" xml:space="preserve">
          <source>GHC uses the function arrows in a &lt;code&gt;prefix_gadt_body&lt;/code&gt; and &lt;code&gt;prefix_gadt_body&lt;/code&gt; to syntactically demarcate the function and result types. Note that GHC does not attempt to be clever about looking through type synonyms here. If you attempt to do this, for instance:</source>
          <target state="translated">GHC使用 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 和 &lt;code&gt;prefix_gadt_body&lt;/code&gt; 中的功能箭头在语法上划分功能和结果类型。请注意，GHC此处并不试图聪明地浏览类型同义词。例如，如果尝试这样做：</target>
        </trans-unit>
        <trans-unit id="ca01e41132644bdb3e286bc222d38e9f775ccd4e" translate="yes" xml:space="preserve">
          <source>GHC versions before 8.8 defined undocumented functions &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; instead of &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; and &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt;. Those names are now deprecated.</source>
          <target state="translated">8.8之前的GHC版本定义了未记录的函数 &lt;code&gt;hs_lock_stable_tables&lt;/code&gt; 和 &lt;code&gt;hs_unlock_stable_tables&lt;/code&gt; ,而不是 &lt;code&gt;hs_lock_stable_ptr_table&lt;/code&gt; 和 &lt;code&gt;hs_unlock_stable_ptr_table&lt;/code&gt; 。这些名称现在已弃用。</target>
        </trans-unit>
        <trans-unit id="5b319fddc0f25cd65725db96966305001e0c7f9c" translate="yes" xml:space="preserve">
          <source>GHC will accept &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt;&amp;lsquo;s type signatures. Note that:</source>
          <target state="translated">GHC将接受 &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 的类型签名。注意：</target>
        </trans-unit>
        <trans-unit id="cacf2f89c573ae5cc451246033c76335e76b2795" translate="yes" xml:space="preserve">
          <source>GHC will accept any combination of &lt;code&gt;!&lt;/code&gt;/&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;{-# UNPACK #-}&lt;/code&gt;/&lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt;, although GHC will ignore some combinations. For example, GHC will produce a warning if you write &lt;code&gt;{-# UNPACK #-} ~Int&lt;/code&gt; and proceed as if you had written &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">GHC将接受 &lt;code&gt;!&lt;/code&gt; 的任何组合！/ &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;{-# UNPACK #-}&lt;/code&gt; / &lt;code&gt;{-# NOUNPACK #-}&lt;/code&gt; ，尽管GHC会忽略某些组合。例如，如果您写 &lt;code&gt;{-# UNPACK #-} ~Int&lt;/code&gt; 并像写 &lt;code&gt;Int&lt;/code&gt; 一样继续进行，GHC将发出警告。</target>
        </trans-unit>
        <trans-unit id="60b8a79c38bec7cc0926fc1ac31c53e115e9aa07" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all exported functions not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC将为所有未标记为INLINE的导出功能自动添加 &lt;code&gt;SCC&lt;/code&gt; 注释。如果要在INLINE函数上建立成本中心，则必须手动添加。</target>
        </trans-unit>
        <trans-unit id="e90ca342877325f438cbed76b283486d9d43d4bf" translate="yes" xml:space="preserve">
          <source>GHC will automatically add &lt;code&gt;SCC&lt;/code&gt; annotations for all top-level bindings not marked INLINE. If you want a cost centre on an INLINE function, you have to add it manually.</source>
          <target state="translated">GHC将为所有未标记为INLINE的顶级绑定自动添加 &lt;code&gt;SCC&lt;/code&gt; 注释。如果要在INLINE函数上建立成本中心，则必须手动添加。</target>
        </trans-unit>
        <trans-unit id="8b91bde5a658ad123b14fffc8376301c68f7acc1" translate="yes" xml:space="preserve">
          <source>GHC will complain about this, because you might later add</source>
          <target state="translated">GHC会抱怨这一点,因为你以后可能会加上</target>
        </trans-unit>
        <trans-unit id="888ad4028beff57dc284f4b0b4cb77697614c65e" translate="yes" xml:space="preserve">
          <source>GHC will generate an instance that is equivalent to</source>
          <target state="translated">GHC将生成一个实例,该实例等同于</target>
        </trans-unit>
        <trans-unit id="fd5d18e4a6d13e92f35cab7d827b6e1c50ef7f4c" translate="yes" xml:space="preserve">
          <source>GHC will rewrite this to also include the source location where the assertion was made,</source>
          <target state="translated">GHC将重写这一点,以包括作出断言的源头位置。</target>
        </trans-unit>
        <trans-unit id="3b8666db2e1c25642043eb4c9311786ee0fbf20e" translate="yes" xml:space="preserve">
          <source>GHC will successfully compile this module with &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt;, because the default export list will include &lt;code&gt;program&lt;/code&gt; rather than &lt;code&gt;main&lt;/code&gt;, as the Haskell Report typically requires.</source>
          <target state="translated">GHC将使用 &lt;code&gt;ghc -main-is Main.program Main.hs&lt;/code&gt; 成功编译该模块，因为默认的导出列表将包括 &lt;code&gt;program&lt;/code&gt; 而不是 &lt;code&gt;main&lt;/code&gt; ，这是Haskell报告通常要求的。</target>
        </trans-unit>
        <trans-unit id="71826e517742bea19038f247c0110ae19fac4e07" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s &lt;code&gt;-main-is&lt;/code&gt; option can be used to change the name of the top-level entry point from &lt;code&gt;main&lt;/code&gt; to any other variable. When compiling the main module and &lt;code&gt;-main-is&lt;/code&gt; has been used to rename the default entry point, GHC will also use the alternate name in the default export list.</source>
          <target state="translated">GHC的 &lt;code&gt;-main-is&lt;/code&gt; 选项可用于将顶级入口点的名称从 &lt;code&gt;main&lt;/code&gt; 更改为任何其他变量。当编译主模块并且使用 &lt;code&gt;-main-is&lt;/code&gt; 重命名默认入口点时，GHC还将在默认导出列表中使用备用名称。</target>
        </trans-unit>
        <trans-unit id="b7940b1f55c055977ec4b26434a6019b2252f161" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is controlled by options, which for historical reasons are also sometimes referred to as command-line flags or arguments. Options can be specified in three ways:</source>
          <target state="translated">GHC的行为由选项控制，由于历史原因，这些选项有时也称为命令行标志或参数。可以通过三种方式指定选项：</target>
        </trans-unit>
        <trans-unit id="8e4a533f14309a808a844f31df8d6cfa4f088440" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s behaviour is firstly controlled by a mode flag. Only one of these flags may be given, but it does not necessarily need to be the first option on the command-line. For instance,</source>
          <target state="translated">GHC的行为首先由模式标志控制。这些标志只能给出一个，但不一定是命令行上的第一个选项。例如，</target>
        </trans-unit>
        <trans-unit id="bf906368ac038f94bf26ce6b52010381e9b9d4b3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s compiled output normally goes into a &lt;code&gt;.hc&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, etc., file, depending on the last-run compilation phase. The option &lt;code&gt;-o file&lt;/code&gt; re-directs the output of that last-run phase to ⟨file⟩.</source>
          <target state="translated">GHC的编译输出通常会进入 &lt;code&gt;.hc&lt;/code&gt; ， &lt;code&gt;.o&lt;/code&gt; 等文件，具体取决于上次运行的编译阶段。选项 &lt;code&gt;-o file&lt;/code&gt; 将最后运行阶段的输出重定向到⟨file⟩。</target>
        </trans-unit>
        <trans-unit id="4eaf5334b602d1dc2d125684f67fbc356d5c1cda" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s default behaviour is that &lt;em&gt;exactly one instance must match the constraint it is trying to resolve&lt;/em&gt;. For example, the constraint &lt;code&gt;C Int Bool&lt;/code&gt; matches instances (A) and (B), and hence would be rejected; while &lt;code&gt;C Int Char&lt;/code&gt; matches only (A) and hence (A) is chosen.</source>
          <target state="translated">GHC的默认行为是，&lt;em&gt;一个实例必须与它要解析的约束完全匹配&lt;/em&gt;。例如，约束 &lt;code&gt;C Int Bool&lt;/code&gt; 与实例（A）和（B）匹配，因此将被拒绝；而 &lt;code&gt;C Int Char&lt;/code&gt; 仅匹配（A），因此选择了（A）。</target>
        </trans-unit>
        <trans-unit id="c8a2481a78caced9f750c28e9ecbbf9c5b39a8d3" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation diverges from the Haskell 98 definition in the sense that Unicode alphabetic characters which are neither upper nor lower case will still be identified as alphabetic by &lt;code&gt;isAlpha&lt;/code&gt;.</source>
          <target state="translated">GHC的实现与Haskell 98定义有所不同，在某种意义上， &lt;code&gt;isAlpha&lt;/code&gt; 仍将不区分大小写的Unicode字母字符识别为字母。</target>
        </trans-unit>
        <trans-unit id="0d8ddddf05368a7d9eeb185f0d525cf13f5ca7e5" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of &lt;code&gt;array&lt;/code&gt; takes the value of an array slot from the last (index,value) pair in the list, and does no checking for duplicates. The reason for this is efficiency, pure and simple.</source>
          <target state="translated">GHC的 &lt;code&gt;array&lt;/code&gt; 实现从列表中的最后一对（索引，值）对中获取一个数组插槽的值，并且不检查重复项。原因是效率，纯净和简单。</target>
        </trans-unit>
        <trans-unit id="681323083d71785f12a1d947d44622299b5d2e3b" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation of the &lt;code&gt;Read&lt;/code&gt; class for integral types accepts hexadecimal and octal literals (the code in the Haskell 98 report doesn&amp;rsquo;t). So, for example,</source>
          <target state="translated">GHC 对整数类型的 &lt;code&gt;Read&lt;/code&gt; 类的实现接受十六进制和八进制文字（Haskell 98报告中的代码不接受）。因此，例如</target>
        </trans-unit>
        <trans-unit id="fa910ad711028cf4d2f6aa78f6b468a6abe9cc47" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHC的mdo表示法的实现紧随原始翻译，如&lt;a href=&quot;http://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell的&lt;/a&gt;&lt;a href=&quot;http://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;递归方法一书中&lt;/a&gt;所述，而Haskell则基于Monadic计算中的Value Recursion。此外，GHC扩展了前一篇论文中描述的语法，并使用了 &lt;code&gt;rec&lt;/code&gt; 关键字标记的较低级语法，如下所述。</target>
        </trans-unit>
        <trans-unit id="fd23acaf9fb3b18e415a0d3277f4326ba07817ca" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s implementation the mdo-notation closely follows the original translation as described in the paper &lt;a href=&quot;https://leventerkok.github.io/papers/recdo.pdf&quot;&gt;A recursive do for Haskell&lt;/a&gt;, which in turn is based on the work &lt;a href=&quot;https://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;Value Recursion in Monadic Computations&lt;/a&gt;. Furthermore, GHC extends the syntax described in the former paper with a lower level syntax flagged by the &lt;code&gt;rec&lt;/code&gt; keyword, as we describe next.</source>
          <target state="translated">GHC的mdo表示法的实现紧随原始翻译，如&lt;a href=&quot;https://leventerkok.github.io/papers/recdo.pdf&quot;&gt;Haskell的&lt;/a&gt;&lt;a href=&quot;https://leventerkok.github.io/papers/erkok-thesis.pdf&quot;&gt;递归方法一书中&lt;/a&gt;所述，而Haskell则基于Monadic计算中的Value Recursion。此外，GHC扩展了前一篇论文中描述的语法，并使用了 &lt;code&gt;rec&lt;/code&gt; 关键字标记的较低级语法，如下所述。</target>
        </trans-unit>
        <trans-unit id="ed1e2dd4714860c447f66e579db44cd5338ed6ec" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:</source>
          <target state="translated">可以使用通过数据类型对递归进行编码的标准方法，来说服GHC的内线不终止：</target>
        </trans-unit>
        <trans-unit id="1e334d1c16129f459bf78c23f3a1da79aafa9734" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;exts/rewrite_rules#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">如果编写不终止的重写规则（&lt;a href=&quot;exts/rewrite_rules#rewrite-rules&quot;&gt;Rewrite Rules&lt;/a&gt;），或者如果通过数据类型对递归进行编码（&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC中的Bug&lt;/a&gt;），则GHC的优化器可能会有所不同。为避免使编译器陷入无限循环，优化器会携带&amp;ldquo;滴答计数&amp;rdquo;，并在超过此计数时停止内联并应用重​​写规则。该限制设置为程序大小的倍数，因此，较大的程序会获得更多滴答声。该 &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; 标志可以让你改变乘数。默认值为100；默认值为100。大于100的数字给出更多的刻度，而小于100的数字给出更少的刻度。</target>
        </trans-unit>
        <trans-unit id="7270364eb5fb9843c4759fc3f49b280307e959e9" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s optimiser can diverge if you write rewrite rules (&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;) that don&amp;rsquo;t terminate, or (less satisfactorily) if you code up recursion through data types (&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;Bugs in GHC&lt;/a&gt;). To avoid making the compiler fall into an infinite loop, the optimiser carries a &amp;ldquo;tick count&amp;rdquo; and stops inlining and applying rewrite rules when this count is exceeded. The limit is set as a multiple of the program size, so bigger programs get more ticks. The &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; flag lets you change the multiplier. The default is 100; numbers larger than 100 give more ticks, and numbers smaller than 100 give fewer.</source>
          <target state="translated">如果您编写不终止的重写规则（&lt;a href=&quot;glasgow_exts#rewrite-rules&quot;&gt;Rewrite规则&lt;/a&gt;），或者如果您通过数据类型对递归进行编码（&lt;a href=&quot;bugs#bugs-ghc&quot;&gt;GHC中的Bug&lt;/a&gt;），则GHC的优化器可能会有所不同。为避免使编译器陷入无限循环，优化器会携带&amp;ldquo;滴答计数&amp;rdquo;，并在超过此计数时停止内联并应用重​​写规则。该限制设置为程序大小的倍数，因此，较大的程序会获得更多滴答声。该 &lt;code&gt;-fsimpl-tick-factor&lt;/code&gt; 标志可以让你改变乘数。默认值为100；默认值为100。大于100的数字给出更多的刻度，而小于100的数字给出更少的刻度。</target>
        </trans-unit>
        <trans-unit id="3978a882c19969786036cd225ec74df6cbf83e05" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s parallelism support has improved in 6.12.1 as a result of much experimentation and tuning in the runtime system. We&amp;rsquo;d still be interested to hear how well it works for you, and we&amp;rsquo;re also interested in collecting parallel programs to add to our benchmarking suite.</source>
          <target state="translated">由于在运行时系统中进行了大量实验和调整，GHC的并行性支持在6.12.1中得到了改进。我们仍然有兴趣了解它对您的运作情况，并且也有兴趣收集并行程序以添加到我们的基准测试套件中。</target>
        </trans-unit>
        <trans-unit id="11e3bdec967fe5a92f92f545009ebde19c94ff56" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system assigns costs to cost centres. A cost is simply the time or space (memory) required to evaluate an expression. Cost centres are program annotations around expressions; all costs incurred by the annotated expression are assigned to the enclosing cost centre. Furthermore, GHC will remember the stack of enclosing cost centres for any given expression at run-time and generate a call-tree of cost attributions.</source>
          <target state="translated">GHC的配置文件系统将成本分配给成本中心。成本只是评估表达式所需的时间或空间（内存）。成本中心是围绕表达式的程序注释；带注释的表达式引起的所有成本都分配给封闭的成本中心。此外，GHC将在运行时记住任何给定表达式的封闭成本中心堆栈，并生成成本归因的调用树。</target>
        </trans-unit>
        <trans-unit id="c44af933474ed5e269dd484ced236e4d2057d778" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s profiling system supports &amp;ldquo;cost centre stacks&amp;rdquo;: a way of seeing the profile of a Haskell program in a call-graph like structure. See &lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt; for more details.</source>
          <target state="translated">GHC的性能分析系统支持&amp;ldquo;成本中心堆栈&amp;rdquo;：一种在类似调用图的结构中查看Haskell程序配置文件的方式。有关更多详细信息，请参见&lt;a href=&quot;profiling#profiling&quot;&gt;分析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8705e16011627590f47ff878b246c3728533b3b6" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system has built-in support for collecting stack trace information from a running Haskell program. This currently requires that the &lt;code&gt;libdw&lt;/code&gt; library from the &lt;code&gt;elfutils&lt;/code&gt; package is available. Of course, the backtrace will be of little use unless debug information is available in the executable and its dependent libraries.</source>
          <target state="translated">GHC的运行时系统具有内置支持，可从运行中的Haskell程序收集堆栈跟踪信息。目前这要求 &lt;code&gt;libdw&lt;/code&gt; 从图书馆 &lt;code&gt;elfutils&lt;/code&gt; 封装。当然，除非在可执行文件及其依赖库中提供了调试信息，否则回溯几乎没有用。</target>
        </trans-unit>
        <trans-unit id="34ecd7773e52e6b1108977b176ca3c2b9e8f2456" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;#367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC的运行时系统实现了协作式多任务处理，仅当程序分配时，上下文切换才可能发生。这意味着未分配的程序可能永远不会进行上下文切换。对于使用STM的程序尤其如此，在观察到不一致的状态后，它们可能会死锁。有关更多讨论，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;＃367&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edf33651c39771e5da51f29e8aae689306e3130d" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s runtime system implements cooperative multitasking, with context switching potentially occurring only when a program allocates. This means that programs that do not allocate may never context switch. This is especially true of programs using STM, which may deadlock after observing inconsistent state. See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;Issue #367&lt;/a&gt; for further discussion.</source>
          <target state="translated">GHC的运行时系统实现了协作式多任务处理，仅当程序分配时，上下文切换才可能发生。这意味着未分配的程序可能永远不会进行上下文切换。对于使用STM的程序尤其如此，在观察到不一致的状态后，它们可能会死锁。有关更多讨论，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/367&quot;&gt;问题＃367&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="495b902a4d269ea40b19611761afea825c104875" translate="yes" xml:space="preserve">
          <source>GHC&amp;rsquo;s type system supports &lt;em&gt;arbitrary-rank&lt;/em&gt; explicit universal quantification in types. For example, all the following types are legal:</source>
          <target state="translated">GHC的类型系统支持类型中的&lt;em&gt;任意等级的&lt;/em&gt;显式通用量化。例如，以下所有类型都是合法的：</target>
        </trans-unit>
        <trans-unit id="82fd95c3a56752e08f77eb38c5bdbdcb6be4a696" translate="yes" xml:space="preserve">
          <source>GHC's &lt;code&gt;DataKinds&lt;/code&gt; language extension lifts data constructors, natural numbers, and strings to the type level. This module provides the primitives needed for working with type-level numbers (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; kind) and strings (the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt;) kind. It also defines the &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; type family, a feature that makes use of type-level strings to support user defined type errors.</source>
          <target state="translated">GHC的 &lt;code&gt;DataKinds&lt;/code&gt; 语言扩展将数据构造函数，自然数和字符串提升到类型级别。该模块提供了使用类型级别数字（ &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Nat&quot;&gt;Nat&lt;/a&gt;&lt;/code&gt; 类型）和字符串（ &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:Symbol&quot;&gt;Symbol&lt;/a&gt;&lt;/code&gt; ）类型所需的原语。它还定义了 &lt;code&gt;&lt;a href=&quot;ghc-typelits#t:TypeError&quot;&gt;TypeError&lt;/a&gt;&lt;/code&gt; 类型系列，该功能利用类型级别的字符串来支持用户定义的类型错误。</target>
        </trans-unit>
        <trans-unit id="364440218c4abb707fa15b5beedbc3d1c2676890" translate="yes" xml:space="preserve">
          <source>GHC's Ix typeclass implementation.</source>
          <target state="translated">GHC的Ix类型类实现。</target>
        </trans-unit>
        <trans-unit id="0afa5da65b91efe9b8ba677184df9d9635364492" translate="yes" xml:space="preserve">
          <source>GHC's array implementation.</source>
          <target state="translated">GHC的数组实现。</target>
        </trans-unit>
        <trans-unit id="76da1a73e21244ea0ab9be4c1d1fee4004005654" translate="yes" xml:space="preserve">
          <source>GHC's implementation of concurrency</source>
          <target state="translated">GHC对并发性的实施</target>
        </trans-unit>
        <trans-unit id="98be7070373a5168f3480205560843e2f04494b4" translate="yes" xml:space="preserve">
          <source>GHC's implementation of the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; data type.</source>
          <target state="translated">GHC对 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 数据类型的实现。</target>
        </trans-unit>
        <trans-unit id="768bc13ad5b2e61fd8fe71e1fff8dfdfc664e459" translate="yes" xml:space="preserve">
          <source>GHC, by default, no longer depends on cygwin, but is a native Windows program. It is built using mingw, and it uses mingw&amp;rsquo;s GHC while compiling your Haskell sources (even if you call it from cygwin&amp;rsquo;s bash), but what matters here is that - just like any other normal windows program - neither GHC nor the executables it produces are aware of Cygwin&amp;rsquo;s pretended unix hierarchy. GHC will happily accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\\&lt;/code&gt; as path separators, but it won&amp;rsquo;t know where to find &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; or &lt;code&gt;/bin/bash&lt;/code&gt; or the like. This causes all kinds of fun when GHC is used from within Cygwin&amp;rsquo;s bash, or in make-sessions running under Cygwin.</source>
          <target state="translated">默认情况下，GHC不再依赖cygwin，而是本地Windows程序。它是使用mingw构建的，并且在编译Haskell源代码时会使用mingw的GHC（即使您从cygwin的bash调用它），但是这里重要的是-就像任何其他普通的Windows程序一样-GHC和它生成的可执行文件都不是了解Cygwin假装的Unix层次结构。 GHC很乐意接受 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\\&lt;/code&gt; 作为路径分隔符，但是它不知道在哪里可以找到 &lt;code&gt;/home/joe/Main.hs&lt;/code&gt; 或 &lt;code&gt;/bin/bash&lt;/code&gt; 等。在Cygwin的bash中或在Cygwin下运行的make-session中使用GHC时，这会带来各种乐趣。</target>
        </trans-unit>
        <trans-unit id="ff816e0b81227e703ddb0dfa383d3a101ea7d725" translate="yes" xml:space="preserve">
          <source>GHC, since version 8.4, &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread. Making it safe to pass heap-allocated objects to unsafe functions.</source>
          <target state="translated">从版本8.4开始，GHC&lt;strong&gt;保证&lt;/strong&gt;即使在字节码解释器中，也不会在 &lt;code&gt;unsafe&lt;/code&gt; 调用期间进行垃圾回收，并且进一步保证了在调用线程中将执行 &lt;code&gt;unsafe&lt;/code&gt; 的调用。确保将堆分配的对象传递给不安全的函数很安全。</target>
        </trans-unit>
        <trans-unit id="6fb0c28210e389deb1f0d69554122e023c56379f" translate="yes" xml:space="preserve">
          <source>GHC.Arr</source>
          <target state="translated">GHC.Arr</target>
        </trans-unit>
        <trans-unit id="da7f85eb75adadb0e3a66f594e581f331c40d7de" translate="yes" xml:space="preserve">
          <source>GHC.Base</source>
          <target state="translated">GHC.Base</target>
        </trans-unit>
        <trans-unit id="44509152f33f388480bcf9fe3d5b92c807be396b" translate="yes" xml:space="preserve">
          <source>GHC.ByteOrder</source>
          <target state="translated">GHC.ByteOrder</target>
        </trans-unit>
        <trans-unit id="f5b98f829355a95c653079b181f31daa126ed048" translate="yes" xml:space="preserve">
          <source>GHC.Char</source>
          <target state="translated">GHC.Char</target>
        </trans-unit>
        <trans-unit id="5e37af3d561ae073b83498872c71cf34be86dde1" translate="yes" xml:space="preserve">
          <source>GHC.Clock</source>
          <target state="translated">GHC.Clock</target>
        </trans-unit>
        <trans-unit id="8ffe6289544c44961284b55760ff10d112e4541c" translate="yes" xml:space="preserve">
          <source>GHC.Conc</source>
          <target state="translated">GHC.Conc</target>
        </trans-unit>
        <trans-unit id="dda0f595676f0ffb55c5548c6bb829dd285e7a06" translate="yes" xml:space="preserve">
          <source>GHC.Conc.IO</source>
          <target state="translated">GHC.Conc.IO</target>
        </trans-unit>
        <trans-unit id="2746731219cdf08f53175830aa9803d04aec4700" translate="yes" xml:space="preserve">
          <source>GHC.Conc.Sync</source>
          <target state="translated">GHC.Conc.Sync</target>
        </trans-unit>
        <trans-unit id="83fb25acb9eec7e0c6a528766737ddb292ac4508" translate="yes" xml:space="preserve">
          <source>GHC.Enum</source>
          <target state="translated">GHC.Enum</target>
        </trans-unit>
        <trans-unit id="9123ccdd7f945599c7fe10322ef603202538a9aa" translate="yes" xml:space="preserve">
          <source>GHC.Environment</source>
          <target state="translated">GHC.Environment</target>
        </trans-unit>
        <trans-unit id="b529524b0f71b0e58a38870afdf56699c7ebc263" translate="yes" xml:space="preserve">
          <source>GHC.Err</source>
          <target state="translated">GHC.Err</target>
        </trans-unit>
        <trans-unit id="8b82280ee98eb05df4a8965fe52566cac340fb84" translate="yes" xml:space="preserve">
          <source>GHC.Event</source>
          <target state="translated">GHC.Event</target>
        </trans-unit>
        <trans-unit id="bfef2613a1eee5e86773b823620ea75105f3fe39" translate="yes" xml:space="preserve">
          <source>GHC.Event.TimeOut</source>
          <target state="translated">GHC.Event.TimeOut</target>
        </trans-unit>
        <trans-unit id="12dc6472d306520b873a5a7a5654adf7b54689d0" translate="yes" xml:space="preserve">
          <source>GHC.Exception</source>
          <target state="translated">GHC.Exception</target>
        </trans-unit>
        <trans-unit id="c96bbd598503766a9fb6318fd8c79f4a71a78f43" translate="yes" xml:space="preserve">
          <source>GHC.Exception.Type</source>
          <target state="translated">GHC.Exception.Type</target>
        </trans-unit>
        <trans-unit id="90ef3784b2d875dcdf89ad8e658a107594b6af29" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack</source>
          <target state="translated">GHC.ExecutionStack</target>
        </trans-unit>
        <trans-unit id="48bff078e8cb052ebe31cac8d746bbc2937065cb" translate="yes" xml:space="preserve">
          <source>GHC.ExecutionStack.Internal</source>
          <target state="translated">GHC.ExecutionStack.Internal</target>
        </trans-unit>
        <trans-unit id="740178902f8692cff1b10349f3d117b77680a7ca" translate="yes" xml:space="preserve">
          <source>GHC.Exts</source>
          <target state="translated">GHC.Exts</target>
        </trans-unit>
        <trans-unit id="7252e677664eb73a80122c6cd32aed07da4dcc79" translate="yes" xml:space="preserve">
          <source>GHC.Fingerprint</source>
          <target state="translated">GHC.Fingerprint</target>
        </trans-unit>
        <trans-unit id="15c984e784209d339e39d4b4707e5f0cefa9a13a" translate="yes" xml:space="preserve">
          <source>GHC.Float</source>
          <target state="translated">GHC.Float</target>
        </trans-unit>
        <trans-unit id="58b89be8337bef1dda3eb53785a12275cdc95c37" translate="yes" xml:space="preserve">
          <source>GHC.Float.RealFracMethods</source>
          <target state="translated">GHC.Float.RealFracMethods</target>
        </trans-unit>
        <trans-unit id="d587f40187b4db2d663256a48f3d1af2342efc78" translate="yes" xml:space="preserve">
          <source>GHC.Foreign</source>
          <target state="translated">GHC.Foreign</target>
        </trans-unit>
        <trans-unit id="3a626e20fa6f4e8f1c340c9eb7363e38c3316f5e" translate="yes" xml:space="preserve">
          <source>GHC.ForeignPtr</source>
          <target state="translated">GHC.ForeignPtr</target>
        </trans-unit>
        <trans-unit id="d71c5bdbb27faa86159462f837dd83ea05d16901" translate="yes" xml:space="preserve">
          <source>GHC.GHCi</source>
          <target state="translated">GHC.GHCi</target>
        </trans-unit>
        <trans-unit id="300f938fef529877e36ee6eaa4a48f9f6ec09c20" translate="yes" xml:space="preserve">
          <source>GHC.Generics</source>
          <target state="translated">GHC.Generics</target>
        </trans-unit>
        <trans-unit id="e588603f44d2b51014250aa9f9d2afcfb672ba1d" translate="yes" xml:space="preserve">
          <source>GHC.IO</source>
          <target state="translated">GHC.IO</target>
        </trans-unit>
        <trans-unit id="a7741f8875636325e2148da2b4d2c46725337155" translate="yes" xml:space="preserve">
          <source>GHC.IO.Buffer</source>
          <target state="translated">GHC.IO.Buffer</target>
        </trans-unit>
        <trans-unit id="8823ff4de4c4340532b0cfa4463cf1fbb930f4a4" translate="yes" xml:space="preserve">
          <source>GHC.IO.BufferedIO</source>
          <target state="translated">GHC.IO.BufferedIO</target>
        </trans-unit>
        <trans-unit id="cb68556602bb0930005cd834412eb8de48905349" translate="yes" xml:space="preserve">
          <source>GHC.IO.Device</source>
          <target state="translated">GHC.IO.Device</target>
        </trans-unit>
        <trans-unit id="fbb7b69e98746b76a700b33f458ce5eedeb38078" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding</source>
          <target state="translated">GHC.IO.Encoding</target>
        </trans-unit>
        <trans-unit id="075bca53a743a5950f147684fa2c43f7f4ca0a1b" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Failure</source>
          <target state="translated">GHC.IO.Encoding.Failure</target>
        </trans-unit>
        <trans-unit id="fd2256eb1195a9c0458ef61c670f8ce80ea2ddb6" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Iconv</source>
          <target state="translated">GHC.IO.Encoding.Iconv</target>
        </trans-unit>
        <trans-unit id="00ded5a18e213f9805bc47d5e3787e0e350eb295" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.Latin1</source>
          <target state="translated">GHC.IO.Encoding.Latin1</target>
        </trans-unit>
        <trans-unit id="ed9f709b9190c0954fa475c593069d81ded2a81f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF16</source>
          <target state="translated">GHC.IO.Encoding.UTF16</target>
        </trans-unit>
        <trans-unit id="1400abe49cf09bd1d336af6fdf075939f1efe75a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF32</source>
          <target state="translated">GHC.IO.Encoding.UTF32</target>
        </trans-unit>
        <trans-unit id="d878692ff2f4d831a32544a843c5acdc396b31f1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Encoding.UTF8</source>
          <target state="translated">GHC.IO.Encoding.UTF8</target>
        </trans-unit>
        <trans-unit id="a84fd41659f18777189c7604f42de55b37d600dc" translate="yes" xml:space="preserve">
          <source>GHC.IO.Exception</source>
          <target state="translated">GHC.IO.Exception</target>
        </trans-unit>
        <trans-unit id="3664164a0a9f493250d7fca47e9c76fc73868ad4" translate="yes" xml:space="preserve">
          <source>GHC.IO.FD</source>
          <target state="translated">GHC.IO.FD</target>
        </trans-unit>
        <trans-unit id="707404689126a6d53ef5f85fb2bd01c00e0a6591" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle</source>
          <target state="translated">GHC.IO.Handle</target>
        </trans-unit>
        <trans-unit id="c4329ea977d1ffef67c80fe9b38f4268fbeb38ba" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.FD</source>
          <target state="translated">GHC.IO.Handle.FD</target>
        </trans-unit>
        <trans-unit id="923ccd81fee0632b161ee012f081f9bec1732ce1" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Internals</source>
          <target state="translated">GHC.IO.Handle.Internals</target>
        </trans-unit>
        <trans-unit id="5f3751921c284354cc2714892e3de0248f4d7485" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Lock</source>
          <target state="translated">GHC.IO.Handle.Lock</target>
        </trans-unit>
        <trans-unit id="e9353efafa30350ec1b9fe2d5006dfa9d249cb1f" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Text</source>
          <target state="translated">GHC.IO.Handle.Text</target>
        </trans-unit>
        <trans-unit id="0f48b5ff0fc29f2510c5ce2cd8ffb3341bb5b961" translate="yes" xml:space="preserve">
          <source>GHC.IO.Handle.Types</source>
          <target state="translated">GHC.IO.Handle.Types</target>
        </trans-unit>
        <trans-unit id="ccc52eccb2a6780a1feac3b140e02e5ed802441c" translate="yes" xml:space="preserve">
          <source>GHC.IO.IOMode</source>
          <target state="translated">GHC.IO.IOMode</target>
        </trans-unit>
        <trans-unit id="f55b7c8fc75ee721b32bf010f775ce66afba9060" translate="yes" xml:space="preserve">
          <source>GHC.IO.SubSystem</source>
          <target state="translated">GHC.IO.SubSystem</target>
        </trans-unit>
        <trans-unit id="24072f4819afbd54c776518117a1b6955ba52e5a" translate="yes" xml:space="preserve">
          <source>GHC.IO.Unsafe</source>
          <target state="translated">GHC.IO.Unsafe</target>
        </trans-unit>
        <trans-unit id="f02420ddb4478ea0713456e578325339787566cf" translate="yes" xml:space="preserve">
          <source>GHC.IOArray</source>
          <target state="translated">GHC.IOArray</target>
        </trans-unit>
        <trans-unit id="b099c579304d78700a56073579e16c9fb676186b" translate="yes" xml:space="preserve">
          <source>GHC.IORef</source>
          <target state="translated">GHC.IORef</target>
        </trans-unit>
        <trans-unit id="eb37a2aa23ca64e584c27fb9ac978b06a058cc51" translate="yes" xml:space="preserve">
          <source>GHC.Int</source>
          <target state="translated">GHC.Int</target>
        </trans-unit>
        <trans-unit id="0316241109fb8335149365d396b185cfa3658769" translate="yes" xml:space="preserve">
          <source>GHC.Integer</source>
          <target state="translated">GHC.Integer</target>
        </trans-unit>
        <trans-unit id="e484f5e76ac61e9bf4935aeb1f0f874dbb1c3a03" translate="yes" xml:space="preserve">
          <source>GHC.Integer.GMP.Internals</source>
          <target state="translated">GHC.Integer.GMP.Internals</target>
        </trans-unit>
        <trans-unit id="9edc8b73c4df17cdf1c86c03183217a78388cfe5" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms</source>
          <target state="translated">GHC.Integer.Logarithms</target>
        </trans-unit>
        <trans-unit id="788a99d5f2c3235b7c75ab1d70542647afac52ac" translate="yes" xml:space="preserve">
          <source>GHC.Integer.Logarithms.Internals</source>
          <target state="translated">GHC.Integer.Logarithms.Internals</target>
        </trans-unit>
        <trans-unit id="cb20764f134c9f093388b799d6edb5c287e142c7" translate="yes" xml:space="preserve">
          <source>GHC.Ix</source>
          <target state="translated">GHC.Ix</target>
        </trans-unit>
        <trans-unit id="ead6a709bdc7b877770a207b97e68a4689718427" translate="yes" xml:space="preserve">
          <source>GHC.List</source>
          <target state="translated">GHC.List</target>
        </trans-unit>
        <trans-unit id="3d57cef545987da93a04e0d694042818f1a1bb34" translate="yes" xml:space="preserve">
          <source>GHC.MVar</source>
          <target state="translated">GHC.MVar</target>
        </trans-unit>
        <trans-unit id="023c57f0497f42e3b02a80cf9d26961f9f6b6620" translate="yes" xml:space="preserve">
          <source>GHC.Maybe</source>
          <target state="translated">GHC.Maybe</target>
        </trans-unit>
        <trans-unit id="164e6fbb161369078c402583c719d0b484bd9cd0" translate="yes" xml:space="preserve">
          <source>GHC.Natural</source>
          <target state="translated">GHC.Natural</target>
        </trans-unit>
        <trans-unit id="ae65dd69d6e330d710167ceb0ad3a94a6e56becc" translate="yes" xml:space="preserve">
          <source>GHC.Num</source>
          <target state="translated">GHC.Num</target>
        </trans-unit>
        <trans-unit id="5f7fc148c0a98a886a6a3bc6e44459e890a898b5" translate="yes" xml:space="preserve">
          <source>GHC.OldList</source>
          <target state="translated">GHC.OldList</target>
        </trans-unit>
        <trans-unit id="219f66845e1b6ccbde2aed8e298fc6202552996a" translate="yes" xml:space="preserve">
          <source>GHC.Profiling</source>
          <target state="translated">GHC.Profiling</target>
        </trans-unit>
        <trans-unit id="5b41899d682d90939969cd71598e1a3c11e49f01" translate="yes" xml:space="preserve">
          <source>GHC.Ptr</source>
          <target state="translated">GHC.Ptr</target>
        </trans-unit>
        <trans-unit id="6c493d68cbbd0903b98d07ddd334636ef44bbad5" translate="yes" xml:space="preserve">
          <source>GHC.RTS.Flags</source>
          <target state="translated">GHC.RTS.Flags</target>
        </trans-unit>
        <trans-unit id="c73e800dcd91edda6a6064deafb3d149d5c87f67" translate="yes" xml:space="preserve">
          <source>GHC.Read</source>
          <target state="translated">GHC.Read</target>
        </trans-unit>
        <trans-unit id="adc72ff9dcbbbacc479bcf7a5fc93c1182110918" translate="yes" xml:space="preserve">
          <source>GHC.Real</source>
          <target state="translated">GHC.Real</target>
        </trans-unit>
        <trans-unit id="6e5b89f9359d5a8bfd2c995515e3c8e2b55f3d6f" translate="yes" xml:space="preserve">
          <source>GHC.Records</source>
          <target state="translated">GHC.Records</target>
        </trans-unit>
        <trans-unit id="0b8521cdcc8c1ef2fd7980f6838d4055504ad2f4" translate="yes" xml:space="preserve">
          <source>GHC.ResponseFile</source>
          <target state="translated">GHC.ResponseFile</target>
        </trans-unit>
        <trans-unit id="3a165be025ea55dd62132f6d49a476a3baddb4bc" translate="yes" xml:space="preserve">
          <source>GHC.ST</source>
          <target state="translated">GHC.ST</target>
        </trans-unit>
        <trans-unit id="592556288d1e596e190164182dec84105b7b17e3" translate="yes" xml:space="preserve">
          <source>GHC.STRef</source>
          <target state="translated">GHC.STRef</target>
        </trans-unit>
        <trans-unit id="c812e3b66e96d4c9aea90e1021417aa178911a2a" translate="yes" xml:space="preserve">
          <source>GHC.Show</source>
          <target state="translated">GHC.Show</target>
        </trans-unit>
        <trans-unit id="22ed618911df1208a7b9b442d70898fc766ec074" translate="yes" xml:space="preserve">
          <source>GHC.Stable</source>
          <target state="translated">GHC.Stable</target>
        </trans-unit>
        <trans-unit id="a20386e520454f3f0f4eb16c34205fd57a4fcb9d" translate="yes" xml:space="preserve">
          <source>GHC.StableName</source>
          <target state="translated">GHC.StableName</target>
        </trans-unit>
        <trans-unit id="d96d568a6576a1e6aecb421974f05a14305bd684" translate="yes" xml:space="preserve">
          <source>GHC.Stack</source>
          <target state="translated">GHC.Stack</target>
        </trans-unit>
        <trans-unit id="021dc0f948747311677c43f8e4143154b011d4e0" translate="yes" xml:space="preserve">
          <source>GHC.Stack.CCS</source>
          <target state="translated">GHC.Stack.CCS</target>
        </trans-unit>
        <trans-unit id="679e7a678858657deeca5fb088d20447dbea9966" translate="yes" xml:space="preserve">
          <source>GHC.Stack.Types</source>
          <target state="translated">GHC.Stack.Types</target>
        </trans-unit>
        <trans-unit id="53710d33b34d9d6d31c7ecc3d9f9075270dc3145" translate="yes" xml:space="preserve">
          <source>GHC.StaticPtr</source>
          <target state="translated">GHC.StaticPtr</target>
        </trans-unit>
        <trans-unit id="7aca1996a3eb2739ab68b28f09387d1bdeef97de" translate="yes" xml:space="preserve">
          <source>GHC.Stats</source>
          <target state="translated">GHC.Stats</target>
        </trans-unit>
        <trans-unit id="52b6bdf52e6d2e6b85bf9394f21a48cc173b0453" translate="yes" xml:space="preserve">
          <source>GHC.TopHandler</source>
          <target state="translated">GHC.TopHandler</target>
        </trans-unit>
        <trans-unit id="a3585409158ac22303c455ac2f18bcd1f244ee48" translate="yes" xml:space="preserve">
          <source>GHC.TypeLits</source>
          <target state="translated">GHC.TypeLits</target>
        </trans-unit>
        <trans-unit id="5f4a237ca09fe1e39f1f4f57427500e3d5dde282" translate="yes" xml:space="preserve">
          <source>GHC.TypeNats</source>
          <target state="translated">GHC.TypeNats</target>
        </trans-unit>
        <trans-unit id="13937217117037ac8a14c5edc72c2b6bb8c575fd" translate="yes" xml:space="preserve">
          <source>GHC.Unicode</source>
          <target state="translated">GHC.Unicode</target>
        </trans-unit>
        <trans-unit id="1fdf724e37267fb3fb33f0dc048df4cee704bb65" translate="yes" xml:space="preserve">
          <source>GHC.Weak</source>
          <target state="translated">GHC.Weak</target>
        </trans-unit>
        <trans-unit id="ad4252ce69afb4d732c694779c89b861201a0b0c" translate="yes" xml:space="preserve">
          <source>GHC.Word</source>
          <target state="translated">GHC.Word</target>
        </trans-unit>
        <trans-unit id="4024a57753a6b7a3c40980a3cd0d4c49ca032099" translate="yes" xml:space="preserve">
          <source>GHCForeignImportPrim</source>
          <target state="translated">GHCForeignImportPrim</target>
        </trans-unit>
        <trans-unit id="f2f693f86b66430c4306b15c72b79c14a03a02ab" translate="yes" xml:space="preserve">
          <source>GHCi</source>
          <target state="translated">GHCi</target>
        </trans-unit>
        <trans-unit id="086bf1fe5e3015b86afe632794f66fe9ce567107" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment that includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;是GHC的交互式环境，其中包括一个交互式调试器（请参见&lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b49fe46f1283625854f08ffa7ba78c6c9050030" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;是GHC的交互式环境，在其中可以交互评估Haskell表达式并可以解释程序。如果您熟悉&lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;，那么GHCi就是您的家。但是，GHCi还支持以交互方式加载已编译的代码，并支持GHC提供的所有&lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;两种&lt;/a&gt;语言扩展。 GHCi还包括一个交互式调试器（请参阅&lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cdb6d8296bb43f9daf1bdf2b77da4db467b8f4d7" translate="yes" xml:space="preserve">
          <source>GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is GHC&amp;rsquo;s interactive environment, in which Haskell expressions can be interactively evaluated and programs can be interpreted. If you&amp;rsquo;re familiar with &lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;, then you&amp;rsquo;ll be right at home with GHCi. However, GHCi also has support for interactively loading compiled code, as well as supporting all &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; the language extensions that GHC provides. GHCi also includes an interactive debugger (see &lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;).</source>
          <target state="translated">GHCi &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;是GHC的交互式环境，在其中可以交互评估Haskell表达式并可以解释程序。如果您熟悉&lt;a href=&quot;http://www.haskell.org/hugs/&quot;&gt;Hugs&lt;/a&gt;，那么GHCi 就是您的家。但是，GHCi还支持以交互方式加载已编译的代码，并支持GHC提供的所有&lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;语言扩展。GHCi还包括一个交互式调试器（请参阅&lt;a href=&quot;#ghci-debugger&quot;&gt;The GHCi Debugger&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c594049ce431e4e83a8bbd749ab3a0ead79c69f9" translate="yes" xml:space="preserve">
          <source>GHCi actually accepts statements rather than just expressions at the prompt. This means you can bind values and functions to names, and use them in future expressions or statements.</source>
          <target state="translated">实际上,GHCi 接受的是语句,而不仅仅是提示中的表达式,这意味着你可以将值和函数绑定到名称上,并在未来的表达式或语句中使用。这意味着你可以将值和函数绑定到名称上,并在未来的表达式或语句中使用它们。</target>
        </trans-unit>
        <trans-unit id="7854b19af27cbb06e171f164ce43770bc4a0b097" translate="yes" xml:space="preserve">
          <source>GHCi actually maintains &lt;em&gt;two&lt;/em&gt; sets of options:</source>
          <target state="translated">GHCi实际上维护着&lt;em&gt;两种&lt;/em&gt;选择：</target>
        </trans-unit>
        <trans-unit id="7d2a258c616352d17542ccf20713b90940918e9c" translate="yes" xml:space="preserve">
          <source>GHCi can</source>
          <target state="translated">GHCi可</target>
        </trans-unit>
        <trans-unit id="61c86bc68706119b7609650a914602b052655cdc" translate="yes" xml:space="preserve">
          <source>GHCi can also load plain object files (&lt;code&gt;.o&lt;/code&gt; or &lt;code&gt;.obj&lt;/code&gt; depending on your platform) or static archives (&lt;code&gt;.a&lt;/code&gt;) from the command-line. Just add the name the object file or library to the command line. On Windows GHCi also supports the &lt;code&gt;big-obj&lt;/code&gt; format.</source>
          <target state="translated">GHCi还可以从命令行加载普通目标文件（ &lt;code&gt;.o&lt;/code&gt; 或 &lt;code&gt;.obj&lt;/code&gt; ,具体取决于您的平台）或静态归档文件（ &lt;code&gt;.a&lt;/code&gt; ）。只需将名称对象文件或库添加到命令行即可。在Windows上，GHCi还支持 &lt;code&gt;big-obj&lt;/code&gt; 格式。</target>
        </trans-unit>
        <trans-unit id="07b8d7c354ee687c28dd2a23b15bfd5ced9be453" translate="yes" xml:space="preserve">
          <source>GHCi can use the profiling system to collect stack trace information when running interpreted code. To gain access to stack traces, start GHCi like this:</source>
          <target state="translated">当运行解释代码时,GHCi可以使用剖析系统收集堆栈跟踪信息。要获得堆栈跟踪信息,请像这样启动GHCi。</target>
        </trans-unit>
        <trans-unit id="189a0097746c2e6bf3ec19ebcd1ad676e7ea5b91" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCi以某种保守的方式检查未装箱的元组和总和的存在：它只是检查模块是否启用了&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;语言扩展。启用&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; 的&lt;/a&gt;代码并不总是需要&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;，因此，如果您&lt;em&gt;真的&lt;/em&gt;要使用代码将&lt;a href=&quot;exts/primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;exts/primitives#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;编译为字节码，则可以通过启用&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt;标志来明确地做到这一点。如果这样做，请注意，如果字节码解释器遇到无法处理的未装箱的元组/总和相关代码，则会抛出错误。</target>
        </trans-unit>
        <trans-unit id="b50b888b5a01174ea88ffe286c7e481b07e9ce3d" translate="yes" xml:space="preserve">
          <source>GHCi checks for the presence of unboxed tuples and sums in a somewhat conservative fashion: it simply checks to see if a module enables the &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; language extensions. It is not always the case that code which enables &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt; requires &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;, so if you &lt;em&gt;really&lt;/em&gt; want to compile &lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt;&lt;code&gt;UnboxedSums&lt;/code&gt;&lt;/a&gt;-using code to bytecode, you can do so explicitly by enabling the &lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt;&lt;code&gt;-fbyte-code&lt;/code&gt;&lt;/a&gt; flag. If you do this, do note that bytecode interpreter will throw an error if it encounters unboxed tuple/sum&amp;ndash;related code that it cannot handle.</source>
          <target state="translated">GHCi以某种保守的方式检查未装箱的元组和总和的存在：它只是检查模块是否启用了&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;语言扩展。启用&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; 的&lt;/a&gt;代码并不总是需要&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;，因此，如果您&lt;em&gt;真的&lt;/em&gt;要使用代码将&lt;a href=&quot;glasgow_exts#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;glasgow_exts#extension-UnboxedSums&quot;&gt; &lt;code&gt;UnboxedSums&lt;/code&gt; &lt;/a&gt;编译为字节码，则可以通过启用&lt;a href=&quot;phases#ghc-flag--fbyte-code&quot;&gt; &lt;code&gt;-fbyte-code&lt;/code&gt; &lt;/a&gt;标志来明确地做到这一点。如果这样做，请注意，如果字节码解释器遇到无法处理的未装箱的元组/总和相关代码，则会抛出错误。</target>
        </trans-unit>
        <trans-unit id="f211d1e24170f67686b938b7af0ca37f8a56b146" translate="yes" xml:space="preserve">
          <source>GHCi commands all begin with &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; and consist of a single command name followed by zero or more parameters. The command name may be abbreviated, with ambiguities being resolved in favour of the more commonly used commands.</source>
          <target state="translated">GHCi命令全部以&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo; 开头，并由单个命令名和零个或多个参数组成。可以缩写命令名称，并解决歧义以支持更常用的命令。</target>
        </trans-unit>
        <trans-unit id="6d0bc0eb39d119d862e834a6402052d747742eb9" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id14&quot; id=&quot;id8&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi包含一个简单的命令式调试器，您可以在其中停止运行的计算以检查变量的值。该调试器已集成到GHCi中，并且默认情况下处于打开状态：不需要任何标志即可启用调试功能。有一个主要限制：断点和单步仅在解释模块中可用；调试器看不到已编译的代码&lt;a href=&quot;#id14&quot; id=&quot;id8&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cdeb81402d6c2b81eaa4ac1ca68fa6f4bf53dc3f" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;.</source>
          <target state="translated">GHCi包含一个简单的命令式调试器，您可以在其中停止运行的计算以检查变量的值。该调试器已集成到GHCi中，并且默认情况下处于打开状态：不需要任何标志即可启用调试功能。有一个主要限制：断点和单步仅在解释模块中可用；调试器看不到已编译的代码&lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2a469d965ea434ea6094be9ac79416520cda211" translate="yes" xml:space="preserve">
          <source>GHCi contains a simple imperative-style debugger in which you can stop a running computation in order to examine the values of variables. The debugger is integrated into GHCi, and is turned on by default: no flags are required to enable the debugging facilities. There is one major restriction: breakpoints and single-stepping are only available in interpreted modules; compiled code is invisible to the debugger &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;.</source>
          <target state="translated">GHCi包含一个简单的命令式调试器，您可以在其中停止运行的计算以检查变量的值。该调试器已集成到GHCi中，并且默认情况下处于打开状态：不需要任何标志即可启用调试功能。有一个主要限制：断点和单步仅在解释模块中可用；调试器看不到已编译的代码&lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;[5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="431b343589f64d92b46f202b4777afcb250c044a" translate="yes" xml:space="preserve">
          <source>GHCi does more than simple expression evaluation at the prompt. If you enter an expression of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then GHCi &lt;em&gt;executes&lt;/em&gt; it as an IO-computation.</source>
          <target state="translated">GHCi不仅可以立即执行简单的表达式评估。如果为某些 &lt;code&gt;a&lt;/code&gt; 输入 &lt;code&gt;IO a&lt;/code&gt; 类型的表达式，则GHCi将其作为IO计算&lt;em&gt;执行&lt;/em&gt;。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8c6bf6320b5a1d66ecb2b14b4d8bbf578afbaf4" translate="yes" xml:space="preserve">
          <source>GHCi does not respect the &lt;code&gt;default&lt;/code&gt; declaration in the module whose scope you are in. Instead, for expressions typed at the command line, you always get the default default-type behaviour; that is, &lt;code&gt;default(Int,Double)&lt;/code&gt;.</source>
          <target state="translated">GHCi不遵守您所在范围的模块中的 &lt;code&gt;default&lt;/code&gt; 声明。相反，对于在命令行中键入的表达式，您始终会获得默认的默认类型行为。即 &lt;code&gt;default(Int,Double)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a337aefb4df415fd5ebe89389f3ec26434d221e1" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*Main&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi已加载 &lt;code&gt;Main&lt;/code&gt; 模块，并且提示符已更改为 &lt;code&gt;*Main&amp;gt;&lt;/code&gt; ,以指示在提示符下键入的表达式的当前上下文是我们刚刚加载的 &lt;code&gt;Main&lt;/code&gt; 模块（我们将在稍后&lt;a href=&quot;#ghci-scope&quot;&gt;的真正作用域中&lt;/a&gt;解释 &lt;code&gt;*&lt;/code&gt; 的含义）在提示符下？）。因此，我们现在可以键入涉及 &lt;code&gt;Main.hs&lt;/code&gt; 中的函数的表达式：</target>
        </trans-unit>
        <trans-unit id="6c07ada5308e7781c1c642740ac4e5f0109c7e27" translate="yes" xml:space="preserve">
          <source>GHCi has loaded the &lt;code&gt;Main&lt;/code&gt; module, and the prompt has changed to &lt;code&gt;*ghci&amp;gt;&lt;/code&gt; to indicate that the current context for expressions typed at the prompt is the &lt;code&gt;Main&lt;/code&gt; module we just loaded (we&amp;rsquo;ll explain what the &lt;code&gt;*&lt;/code&gt; means later in &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;). So we can now type expressions involving the functions from &lt;code&gt;Main.hs&lt;/code&gt;:</source>
          <target state="translated">GHCi已加载了 &lt;code&gt;Main&lt;/code&gt; 模块，并且提示符已更改为 &lt;code&gt;*ghci&amp;gt;&lt;/code&gt; ,以指示在提示符下键入的表达式的当前上下文是我们刚刚加载的 &lt;code&gt;Main&lt;/code&gt; 模块（我们将在稍后&lt;a href=&quot;#ghci-scope&quot;&gt;的真正作用域中&lt;/a&gt;解释 &lt;code&gt;*&lt;/code&gt; 的含义）在提示符下？）。因此，我们现在可以键入涉及 &lt;code&gt;Main.hs&lt;/code&gt; 中的函数的表达式：</target>
        </trans-unit>
        <trans-unit id="097ef3e6fe8251975966ddc7eaf61adb8ce1daf4" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id15&quot; id=&quot;id9&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi提供了对放置断点的表达式的自由变量&lt;a href=&quot;#id15&quot; id=&quot;id9&quot;&gt;[6]&lt;/a&gt;的绑定（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ），此外还为表达式的结果提供了绑定（ &lt;code&gt;_result&lt;/code&gt; ）。这些变量就像您可能在GHCi中定义的其他变量一样。您可以在提示符下键入的表达式中使用它们，也可以使用&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;来询问它们的类型，依此类推。但是，有一个重要的区别：这些变量只能具有部分类型。例如，如果我们尝试显示 &lt;code&gt;left&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="7e7e52195cfae2c519c03e23e784d7a20ae2e810" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi提供了对放置了断点的表达式的自由变量&lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;6&lt;/a&gt;的绑定（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ），此外还为表达式的结果提供了绑定（ &lt;code&gt;_result&lt;/code&gt; ）。这些变量就像您可能在GHCi中定义的其他变量一样。您可以在提示符下键入的表达式中使用它们，也可以使用&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;来询问它们的类型，依此类推。但是，有一个重要的区别：这些变量只能具有部分类型。例如，如果我们尝试显示 &lt;code&gt;left&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="4760f6a58d8645892518b92f9d2d0455de2f6de1" translate="yes" xml:space="preserve">
          <source>GHCi has provided bindings for the free variables &lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt; of the expression on which the breakpoint was placed (&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;), and additionally a binding for the result of the expression (&lt;code&gt;_result&lt;/code&gt;). These variables are just like other variables that you might define in GHCi; you can use them in expressions that you type at the prompt, you can ask for their types with &lt;a href=&quot;#ghci-cmd-:type&quot;&gt;&lt;code&gt;:type&lt;/code&gt;&lt;/a&gt;, and so on. There is one important difference though: these variables may only have partial types. For example, if we try to display the value of &lt;code&gt;left&lt;/code&gt;:</source>
          <target state="translated">GHCi提供了对放置断点的表达式的自由变量&lt;a href=&quot;#id17&quot; id=&quot;id11&quot;&gt;[6]&lt;/a&gt;的绑定（ &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ），此外还为表达式的结果提供了绑定（ &lt;code&gt;_result&lt;/code&gt; ）。这些变量就像您可能在GHCi中定义的其他变量一样。您可以在提示符下键入的表达式中使用它们，也可以使用&lt;a href=&quot;#ghci-cmd-:type&quot;&gt; &lt;code&gt;:type&lt;/code&gt; &lt;/a&gt;询问它们的类型，依此类推。但是，有一个重要的区别：这些变量只能具有部分类型。例如，如果我们尝试显示 &lt;code&gt;left&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="d52ffb5498f59a8fef6a199eb895dfb10991a53d" translate="yes" xml:space="preserve">
          <source>GHCi interprets the whole line as an expression to evaluate. The expression may not span several lines - as soon as you press enter, GHCi will attempt to evaluate it.</source>
          <target state="translated">GHCi 将整行解释为一个表达式来评估。该表达式可能不会跨越好几行--只要你按下回车键,GHCi就会尝试评估它。</target>
        </trans-unit>
        <trans-unit id="d000c11f6d43ecae04979b2322aedc62f59206e3" translate="yes" xml:space="preserve">
          <source>GHCi is invoked with the command &lt;code&gt;ghci&lt;/code&gt; or &lt;code&gt;ghc --interactive&lt;/code&gt;. One or more modules or filenames can also be specified on the command line; this instructs GHCi to load the specified modules or filenames (and all the modules they depend on), just as if you had said &lt;code&gt;:load modules&lt;/code&gt; at the GHCi prompt (see &lt;a href=&quot;#ghci-commands&quot;&gt;GHCi commands&lt;/a&gt;). For example, to start GHCi and load the program whose topmost module is in the file &lt;code&gt;Main.hs&lt;/code&gt;, we could say:</source>
          <target state="translated">使用命令 &lt;code&gt;ghci&lt;/code&gt; 或 &lt;code&gt;ghc --interactive&lt;/code&gt; 调用GHCi 。也可以在命令行上指定一个或多个模块或文件名。这指示GHCi加载指定的模块或文件名（以及它们依赖的所有模块），就像您在GHCi提示符下说过 &lt;code&gt;:load modules&lt;/code&gt; 一样（请参阅&lt;a href=&quot;#ghci-commands&quot;&gt;GHCi命令&lt;/a&gt;）。例如，要启动GHCi并加载其最顶层模块位于文件 &lt;code&gt;Main.hs&lt;/code&gt; 中的程序，我们可以说：</target>
        </trans-unit>
        <trans-unit id="02cd23e6d70f664fac3cadb490523ec73e9c61c9" translate="yes" xml:space="preserve">
          <source>GHCi options may be set using &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt; and unset using &lt;a href=&quot;#ghci-cmd-:unset&quot;&gt;&lt;code&gt;:unset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; 设置&lt;/a&gt; GHCi选项，而使用&lt;a href=&quot;#ghci-cmd-:unset&quot;&gt; &lt;code&gt;:unset&lt;/code&gt; 取消设置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23865ba11579e59cab852eaf50893d8f8310f50d" translate="yes" xml:space="preserve">
          <source>GHCi tells us that, among other bindings, &lt;code&gt;f&lt;/code&gt; is in scope. However, its type is not fully known yet, and thus it is not possible to apply it to any arguments. Nevertheless, observe that the type of its first argument is the same as the type of &lt;code&gt;x&lt;/code&gt;, and its result type is shared with &lt;code&gt;_result&lt;/code&gt;.</source>
          <target state="translated">GHCi告诉我们，在其他绑定中， &lt;code&gt;f&lt;/code&gt; 在范围内。但是，尚不完全了解其类型，因此无法将其应用于任何参数。但是，请注意其第一个参数的类型与 &lt;code&gt;x&lt;/code&gt; 的类型相同，并且其结果类型与 &lt;code&gt;_result&lt;/code&gt; 共享。</target>
        </trans-unit>
        <trans-unit id="3c860feb5ec1b15da2c58750a623feabad614260" translate="yes" xml:space="preserve">
          <source>GHCi uses &lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt; under the hood. You can configure it to, among other things, prune duplicates from GHCi history. See: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline user preferences&lt;/a&gt;.</source>
          <target state="translated">GHCi 在引擎盖下使用&lt;a href=&quot;https://hackage.haskell.org/package/haskeline&quot;&gt;Haskeline&lt;/a&gt;。您可以将其配置为除其他外，从GHCi历史记录中删除副本。请参阅：&lt;a href=&quot;https://github.com/judah/haskeline/wiki/UserPreferences&quot;&gt;Haskeline用户首选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27b5ae81e5a8c6380c3ff5286cbd9fbd01c0708a" translate="yes" xml:space="preserve">
          <source>GHCi will tab-complete names that are in scope; for example, if you run GHCi and type &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; then GHCi will expand it to &lt;code&gt;Just&lt;/code&gt;.</source>
          <target state="translated">GHCi将制表完整范围内的名称；例如，如果您运行GHCi并键入 &lt;code&gt;J&amp;lt;tab&amp;gt;&lt;/code&gt; 那么GHCi会将其扩展为 &lt;code&gt;Just&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="912aae042df048a72c9945fa25dfdd84648ce03f" translate="yes" xml:space="preserve">
          <source>GHCi.BinaryArray</source>
          <target state="translated">GHCi.BinaryArray</target>
        </trans-unit>
        <trans-unit id="ebc86550d6d8c6805a075e4ee82223ab44c22f1b" translate="yes" xml:space="preserve">
          <source>GHCi.Message</source>
          <target state="translated">GHCi.Message</target>
        </trans-unit>
        <trans-unit id="b7f4cbe61fcbdf53e726dde698f6d8427d6f6967" translate="yes" xml:space="preserve">
          <source>GHCi.ObjLink</source>
          <target state="translated">GHCi.ObjLink</target>
        </trans-unit>
        <trans-unit id="ef375e610fc95f4a10dd98a324ea900410775563" translate="yes" xml:space="preserve">
          <source>GHCi.RemoteTypes</source>
          <target state="translated">GHCi.RemoteTypes</target>
        </trans-unit>
        <trans-unit id="546802906c4994371bd7abbe6ba80eda19818ed8" translate="yes" xml:space="preserve">
          <source>GHCi.ResolvedBCO</source>
          <target state="translated">GHCi.ResolvedBCO</target>
        </trans-unit>
        <trans-unit id="f0b490ca46daa8f25bfa4855b33e28ba0663f27e" translate="yes" xml:space="preserve">
          <source>GHCi.Signals</source>
          <target state="translated">GHCi.Signals</target>
        </trans-unit>
        <trans-unit id="7899287feb51f897b8a19c276da822182ac21af9" translate="yes" xml:space="preserve">
          <source>GHCi.StaticPtrTable</source>
          <target state="translated">GHCi.StaticPtrTable</target>
        </trans-unit>
        <trans-unit id="bb3d877b385e2643cf85046824f0351addc9a45b" translate="yes" xml:space="preserve">
          <source>GHCi.TH</source>
          <target state="translated">GHCi.TH</target>
        </trans-unit>
        <trans-unit id="1d7f50c80144815a35dcdd8cead270f10c32bacd" translate="yes" xml:space="preserve">
          <source>GHCi.Utils</source>
          <target state="translated">GHCi.Utils</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="84841ccacb20efbdee1996b961b9cb5573918289" translate="yes" xml:space="preserve">
          <source>Garbage collection</source>
          <target state="translated">垃圾收集</target>
        </trans-unit>
        <trans-unit id="9adb6994755f905f75af8a5e2ea3803352181ba0" translate="yes" xml:space="preserve">
          <source>Garbage collection requires more memory than the actual residency. The factor depends on the kind of garbage collection algorithm in use: a major GC in the standard generation copying collector will usually require \(3L\) bytes of memory, where \(L\) is the amount of live data. This is because by default (see the RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; option) we allow the old generation to grow to twice its size (\(2L\)) before collecting it, and we require additionally \(L\) bytes to copy the live data into. When using compacting collection (see the &lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option), this is reduced to \(2L\), and can further be reduced by tweaking the &lt;code&gt;-F
⟨factor⟩&lt;/code&gt; option. Also add the size of the allocation area (see &lt;code&gt;-A
⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">垃圾回收需要比实际驻留更多的内存。该因素取决于所使用的垃圾收集算法的类型：标准世代复制收集器中的主要GC通常将需要\（3L \）个字节的内存，其中\（L \）是活动数据量。这是因为默认情况下（请参阅RTS &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 选项），我们允许旧一代在收集之前增长到其大小的两倍（\（2L \）），并且还需要复制\（L \）个字节将实时数据导入。使用压缩收集（请参阅&lt;a href=&quot;runtime_control#rts-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt;选项）时，它减少为\（2L \），并且可以通过调整 &lt;code&gt;-F ⟨factor⟩&lt;/code&gt; 选项来进一步减少。同时添加分配区域的大小（请参见 &lt;code&gt;-A ⟨size⟩&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ef3a23ff5d0585af5a5a4d93589e0f9057a7a61" translate="yes" xml:space="preserve">
          <source>GenLanguageDef</source>
          <target state="translated">GenLanguageDef</target>
        </trans-unit>
        <trans-unit id="54007d0d2b9f177a727f3b24f2d943df20b8deca" translate="yes" xml:space="preserve">
          <source>GenParser</source>
          <target state="translated">GenParser</target>
        </trans-unit>
        <trans-unit id="9cebabfd017fca2459439f2cdddbfa91800ffe40" translate="yes" xml:space="preserve">
          <source>GenTokenParser</source>
          <target state="translated">GenTokenParser</target>
        </trans-unit>
        <trans-unit id="11d4fb3475a101d8c9ae85b42e237a2007bc5294" translate="yes" xml:space="preserve">
          <source>General Quantity Semaphores</source>
          <target state="translated">一般数量 Semaphores</target>
        </trans-unit>
        <trans-unit id="5c4940d2f6feb1f80aee808047b0cd3c6532766b" translate="yes" xml:space="preserve">
          <source>General combining function</source>
          <target state="translated">一般组合功能</target>
        </trans-unit>
        <trans-unit id="3571f6a92057b6b6050f2f5c27ff1f749bf598bf" translate="yes" xml:space="preserve">
          <source>General combining functions</source>
          <target state="translated">一般组合功能</target>
        </trans-unit>
        <trans-unit id="d43b7ab00d837792990ac04a2a3ceeb8dca84942" translate="yes" xml:space="preserve">
          <source>General definitions for superclass methods</source>
          <target state="translated">超级类方法的一般定义</target>
        </trans-unit>
        <trans-unit id="51482529c6677f2a5e1536e3abbc044e55d04df8" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得常规折叠。</target>
        </trans-unit>
        <trans-unit id="2cb698a6fdef53a2047596be60a1e1ba2d67960a" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得常规折叠。</target>
        </trans-unit>
        <trans-unit id="96299832bc0e4cdb2afa17e640eff0b72082e4dd" translate="yes" xml:space="preserve">
          <source>General folds are available via the &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可通过 &lt;code&gt;&lt;a href=&quot;data-sequence#t:Seq&quot;&gt;Seq&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例获得常规折叠。</target>
        </trans-unit>
        <trans-unit id="4da0f615e29aa775c1b4d14d76dc1ab67db6f413" translate="yes" xml:space="preserve">
          <source>General marshalling utilities</source>
          <target state="translated">一般调度设施</target>
        </trans-unit>
        <trans-unit id="3e8d2ea2ea48695ac53dc1175beaebda38571966" translate="yes" xml:space="preserve">
          <source>General rendering</source>
          <target state="translated">一般渲染</target>
        </trans-unit>
        <trans-unit id="b5c117841ab98d064d9ec4fdda7883c977e283c9" translate="yes" xml:space="preserve">
          <source>General-purpose finite sequences.</source>
          <target state="translated">通用有限序列。</target>
        </trans-unit>
        <trans-unit id="95e3e92034cf70ddc1aa314c5db463429c48b08c" translate="yes" xml:space="preserve">
          <source>GeneralCategory</source>
          <target state="translated">GeneralCategory</target>
        </trans-unit>
        <trans-unit id="588fb85f0da12d2db4af030769a3fe542d141ec2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; 推广到 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 的任何实例</target>
        </trans-unit>
        <trans-unit id="2828c3cdd240b29b7adddd99ced6ba83ae84c8d8" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; 推广到 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 的任何实例</target>
        </trans-unit>
        <trans-unit id="e61a01cc59f938a5a2397118a9603bef23b0e4c2" translate="yes" xml:space="preserve">
          <source>Generalisation of &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; to any instance of &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 推广到 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 的任何实例</target>
        </trans-unit>
        <trans-unit id="483a67423e4f02af497f083df740c06f787f15ed" translate="yes" xml:space="preserve">
          <source>Generalisations of list functions</source>
          <target state="translated">列表函数的一般化</target>
        </trans-unit>
        <trans-unit id="9eac298b6aa11d6f17eff26f7546fc361e27b466" translate="yes" xml:space="preserve">
          <source>Generalised Algebraic Data Types generalise ordinary algebraic data types by allowing constructors to have richer return types. Here is an example:</source>
          <target state="translated">广义代数数据类型通过允许构造函数具有更丰富的返回类型来广义普通代数数据类型。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="82396ff476196b610167e5598629b6fdb9407c80" translate="yes" xml:space="preserve">
          <source>Generalised list comprehensions are a further enhancement to the list comprehension syntactic sugar to allow operations such as sorting and grouping which are familiar from SQL. They are fully described in the paper &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;Comprehensive comprehensions: comprehensions with &amp;ldquo;order by&amp;rdquo; and &amp;ldquo;group by&amp;rdquo;&lt;/a&gt;, except that the syntax we use differs slightly from the paper.</source>
          <target state="translated">广义列表理解是对列表理解语法糖的进一步增强，可以进行SQL熟悉的排序和分组等操作。它们在&amp;ldquo; &lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/2007/09/list-comp.pdf&quot;&gt;综合理解：使用&amp;rdquo;排序依据&amp;rdquo;和&amp;ldquo;分组依据&amp;rdquo;的理解中&lt;/a&gt;得到了充分的描述，只是我们使用的语法与本文略有不同。</target>
        </trans-unit>
        <trans-unit id="573d76545cf52f17a400f8d78e7b0bd044b970f2" translate="yes" xml:space="preserve">
          <source>Generalizations of Control.Exception</source>
          <target state="translated">Control.Exception的一般化</target>
        </trans-unit>
        <trans-unit id="f1955dbc970386d87459b85c65d5689fcd0a3342" translate="yes" xml:space="preserve">
          <source>Generalized abstracted pattern of safe resource acquisition and release in the face of errors. The first action &quot;acquires&quot; some value, which is &quot;released&quot; by the second action at the end. The third action &quot;uses&quot; the value and its result is the result of the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">遇到错误时，安全资源获取和释放的通用抽象模式。第一个动作&amp;ldquo;获取&amp;rdquo;某些值，第二个动作最后&amp;ldquo;释放&amp;rdquo;该值。第三个动作&amp;ldquo;使用&amp;rdquo;该值，其结果是方 &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="dce773570cb4c3e2d017c427de373025af29832e" translate="yes" xml:space="preserve">
          <source>Generalized casts for higher-order kinds</source>
          <target state="translated">高阶种类的泛化铸造</target>
        </trans-unit>
        <trans-unit id="3389ef31a5ee4e0a49d994e2e340b2c46172d24e" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using propositional equality</source>
          <target state="translated">使用命题平等的类型安全浇注的通用形式。</target>
        </trans-unit>
        <trans-unit id="60044df19e927ec8addc3d0c22ff3af4bc023cc2" translate="yes" xml:space="preserve">
          <source>Generalized form of type-safe cast using representational equality</source>
          <target state="translated">使用表征平等的类型安全投递的通用形式</target>
        </trans-unit>
        <trans-unit id="cdde5c558c7ac937fc8c98638e3ae4ebfda3b764" translate="yes" xml:space="preserve">
          <source>Generalized functions</source>
          <target state="translated">归一化职能</target>
        </trans-unit>
        <trans-unit id="c4d66c566123a657ae808a9a54c61c6f61296e8e" translate="yes" xml:space="preserve">
          <source>Generalized insertion/deletion</source>
          <target state="translated">笼统的插入/删除</target>
        </trans-unit>
        <trans-unit id="5d04310694030c511391766d6d01208fdf93d744" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt; 通用版本</target>
        </trans-unit>
        <trans-unit id="e85d5742bf4b934078e0af2ccc4ec3350c42aa66" translate="yes" xml:space="preserve">
          <source>Generalized version of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-exception#t:Handler&quot;&gt;Handler&lt;/a&gt;&lt;/code&gt; 通用版本</target>
        </trans-unit>
        <trans-unit id="c694cfeb74e8c5c7ea7a993e0762b168e17f097b" translate="yes" xml:space="preserve">
          <source>GeneralizedNewtypeDeriving</source>
          <target state="translated">GeneralizedNewtypeDeriving</target>
        </trans-unit>
        <trans-unit id="8bba990109118772a7f157201f4852b56a93e1e4" translate="yes" xml:space="preserve">
          <source>Generally speaking, when &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</source>
          <target state="translated">一般来说，&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;时，GHC会尝试推断最通用的声明类型。在许多情况下（例如，在数据类型声明中），该定义在右侧可以告知种类推断。但这并非总是如此。考虑</target>
        </trans-unit>
        <trans-unit id="6d38b600df6d5f10e2c48ed50d09c245ecf3d220" translate="yes" xml:space="preserve">
          <source>Generally, you can only give a &lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt;&lt;code&gt;SPECIALIZE&lt;/code&gt;&lt;/a&gt; pragma for a function defined in the same module. However if a function &lt;code&gt;f&lt;/code&gt; is given an &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt; pragma at its definition site, then it can subsequently be specialised by importing modules (see &lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;). For example</source>
          <target state="translated">通常，您只能为同一模块中定义的功能提供&lt;a href=&quot;#pragma-SPECIALIZE&quot;&gt; &lt;code&gt;SPECIALIZE&lt;/code&gt; &lt;/a&gt;编译指示。但是，如果在函数 &lt;code&gt;f&lt;/code&gt; 的定义位置为函数f赋予了&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt; pragma，则可以随后通过导入模块对其进行特殊化（请参阅&lt;a href=&quot;#inlinable-pragma&quot;&gt;INLINABLE pragma&lt;/a&gt;）。例如</target>
        </trans-unit>
        <trans-unit id="d08cc5e55e4bb93f6a515a38b1f75c093fe6e0b3" translate="yes" xml:space="preserve">
          <source>Generate a capturable name. Occurrences of such names will be resolved according to the Haskell scoping rules at the occurrence site.</source>
          <target state="translated">生成一个可捕获的名称。这种名称的出现将根据发生地的 Haskell 范围规则进行解析。</target>
        </trans-unit>
        <trans-unit id="aeed47864f8a7339cdf8be33e82f7d412fe366b8" translate="yes" xml:space="preserve">
          <source>Generate a fresh name, which cannot be captured.</source>
          <target state="translated">生成一个新鲜的名字,无法捕捉。</target>
        </trans-unit>
        <trans-unit id="745ffd8ce042664827fc6bde881b37f864469beb" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">以适合&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;工具输入的形式生成包依赖关系图。例如，生成依赖图的PDF：</target>
        </trans-unit>
        <trans-unit id="d21a0134adc8de08a084ff41a1de99d42f5f474c" translate="yes" xml:space="preserve">
          <source>Generate a graph of the package dependencies in a form suitable for input for the &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt; tools. For example, to generate a PDF of the dependency graph:</source>
          <target state="translated">以适合&lt;a href=&quot;https://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;工具输入的形式生成包依赖关系图。例如，生成依赖图的PDF：</target>
        </trans-unit>
        <trans-unit id="4920f76f167528645c1fe9c22d2dcaa6a089bd0a" translate="yes" xml:space="preserve">
          <source>Generate a shared library (as opposed to an executable)</source>
          <target state="translated">生成一个共享库(相对于可执行文件)。</target>
        </trans-unit>
        <trans-unit id="0e4ae4a96f85bdbccc43169fe49910079cdbd8ff" translate="yes" xml:space="preserve">
          <source>Generate a standalone static library (as opposed to an executable). This is useful when cross compiling. The library together with all its dependencies ends up in in a single static library that can be linked against.</source>
          <target state="translated">生成一个独立的静态库(相对于可执行文件)。这在交叉编译时很有用。该库和它的所有依赖关系最终会被整合到一个单一的静态库中,可以与之链接。</target>
        </trans-unit>
        <trans-unit id="48fa807100bcd28bd53cce9c992b8ed46f5f86ef" translate="yes" xml:space="preserve">
          <source>Generate byte-code</source>
          <target state="translated">生成字节码</target>
        </trans-unit>
        <trans-unit id="545a23517098db1358fda76a5894abc504c8e13a" translate="yes" xml:space="preserve">
          <source>Generate byte-code instead of object-code. This is the default in GHCi. Byte-code can currently only be used in the interactive interpreter, not saved to disk. This option is only useful for reversing the effect of &lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">生成字节码而不是目标码。这是GHCi中的默认设置。字节码当前只能在交互式解释器中使用，不能保存到磁盘。该选项仅对反转&lt;a href=&quot;#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;的效果有用。</target>
        </trans-unit>
        <trans-unit id="3e361635a833ea10d7f04f532a6187549e8cd183" translate="yes" xml:space="preserve">
          <source>Generate code for a position-independent executable (where available)</source>
          <target state="translated">生成与位置无关的可执行文件的代码(如有)。</target>
        </trans-unit>
        <trans-unit id="4be18defb8001300394d722f2553ae2882459ebd" translate="yes" xml:space="preserve">
          <source>Generate code for linking against dynamic libraries</source>
          <target state="translated">生成与动态库链接的代码</target>
        </trans-unit>
        <trans-unit id="d7e41ba37b4936caed0d16b2edacb4f90c82806d" translate="yes" xml:space="preserve">
          <source>Generate code in such a way to be linkable into a position-independent executable This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform. To link the final executable use &lt;a href=&quot;#ghc-flag--pie&quot;&gt;&lt;code&gt;-pie&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以可链接到与位置无关的可执行文件的方式生成代码。该代码当前在Linux x86和x86-64上有效。在Windows上，从不使用与位置无关的代码，因此该标志在该平台上为空。要链接最终的可执行文件，请使用&lt;a href=&quot;#ghc-flag--pie&quot;&gt; &lt;code&gt;-pie&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6b34021a0cac78d62ed0e9e10bda04e18b425e" translate="yes" xml:space="preserve">
          <source>Generate colour output.</source>
          <target state="translated">生成彩色输出。</target>
        </trans-unit>
        <trans-unit id="0951be6b0579ecfa709ec3e3d4e23d98d9697421" translate="yes" xml:space="preserve">
          <source>Generate encapsulated PostScript suitable for inclusion in LaTeX documents. Usually, the PostScript graph is drawn in landscape mode in an area 9 inches wide by 6 inches high, and &lt;code&gt;hp2ps&lt;/code&gt; arranges for this area to be approximately centred on a sheet of a4 paper. This format is convenient of studying the graph in detail, but it is unsuitable for inclusion in LaTeX documents. The &lt;code&gt;-e&lt;/code&gt; option causes the graph to be drawn in portrait mode, with float specifying the width in inches, millimetres or points (the default). The resulting PostScript file conforms to the Encapsulated PostScript (EPS) convention, and it can be included in a LaTeX document using Rokicki&amp;rsquo;s dvi-to-PostScript converter &lt;code&gt;dvips&lt;/code&gt;.</source>
          <target state="translated">生成适合包含在LaTeX文档中的封装PostScript。通常，以横向模式在9英寸宽乘6英寸高的区域中绘制PostScript图形，并且 &lt;code&gt;hp2ps&lt;/code&gt; 将该区域安排为大约在a4纸上居中。此格式便于详细研究图形，但不适合包含在LaTeX文档中。所述 &lt;code&gt;-e&lt;/code&gt; 选项使得在纵向模式下要绘制的曲线图，与浮子指定以英寸，毫米或点（默认值）的宽度。生成的PostScript文件符合Encapsulated PostScript（EPS）约定，并且可以使用Rokicki的dvi-to-PostScript转换器 &lt;code&gt;dvips&lt;/code&gt; 将其包含在LaTeX文档中。</target>
        </trans-unit>
        <trans-unit id="2af2316bd5693a2c95e9b58e4d09197236c735b7" translate="yes" xml:space="preserve">
          <source>Generate object code</source>
          <target state="translated">生成对象代码</target>
        </trans-unit>
        <trans-unit id="a0c3e54eb051234ea1cd507d92e6426c516da62b" translate="yes" xml:space="preserve">
          <source>Generate object code. This is the default outside of GHCi, and can be used with GHCi to cause object code to be generated in preference to bytecode.</source>
          <target state="translated">生成对象代码。这是在GHCi之外的默认值,可以与GHCi一起使用,使对象代码优先于字节码生成。</target>
        </trans-unit>
        <trans-unit id="9b5f95dcb03ea38c6a355f6b7e37726ccf839b63" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (code that can be put into shared libraries). This currently works on Linux x86 and x86-64. On Windows, position-independent code is never used so the flag is a no-op on that platform.</source>
          <target state="translated">生成与位置无关的代码(可放入共享库的代码)。目前在Linux x86和x86-64上工作。在Windows上,位置无关的代码从来不会被使用,所以这个标志在该平台上是不可行的。</target>
        </trans-unit>
        <trans-unit id="6cf6f42463945c51e0a71346f97c9c182c3bb40d" translate="yes" xml:space="preserve">
          <source>Generate position-independent code (where available)</source>
          <target state="translated">生成与位置无关的代码(如有)</target>
        </trans-unit>
        <trans-unit id="7b85081d19a7d760ce6025f60cc20a50bec6fa8f" translate="yes" xml:space="preserve">
          <source>Generate warnings for Template Haskell splices</source>
          <target state="translated">为模板Haskell拼接生成警告。</target>
        </trans-unit>
        <trans-unit id="e379c504cb4385507060a36357b57f5b6a5617c5" translate="yes" xml:space="preserve">
          <source>Generated by preprocessors to convey source line numbers of the original source.</source>
          <target state="translated">由预处理器生成,以传达原始源的源行号。</target>
        </trans-unit>
        <trans-unit id="0ab5544c727327bbc41b60d8a2cb8ebc8ae7d766" translate="yes" xml:space="preserve">
          <source>Generates a &amp;ldquo;tags&amp;rdquo; file for Vi-style editors (&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt;&lt;code&gt;:ctags&lt;/code&gt;&lt;/a&gt;) or Emacs-style editors (&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt;&lt;code&gt;:etags&lt;/code&gt;&lt;/a&gt;). If no filename is specified, the default &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;TAGS&lt;/code&gt; is used, respectively. Tags for all the functions, constructors and types in the currently loaded modules are created. All modules must be interpreted for these commands to work.</source>
          <target state="translated">为Vi风格的编辑器（&lt;a href=&quot;#ghci-cmd-:ctags&quot;&gt; &lt;code&gt;:ctags&lt;/code&gt; &lt;/a&gt;）或Emacs风格的编辑器（&lt;a href=&quot;#ghci-cmd-:etags&quot;&gt; &lt;code&gt;:etags&lt;/code&gt; &lt;/a&gt;）生成一个&amp;ldquo;标签&amp;rdquo;文件。如果未指定文件名，则分别使用默认 &lt;code&gt;tags&lt;/code&gt; 或 &lt;code&gt;TAGS&lt;/code&gt; 。创建当前加载模块中所有功能，构造函数和类型的标记。必须解释所有模块，这些命令才能起作用。</target>
        </trans-unit>
        <trans-unit id="a1bd17d2e723ab01d0f385c562085a77dec9c6bb" translate="yes" xml:space="preserve">
          <source>Generates a basic heap profile, in the file &lt;code&gt;prog.hp&lt;/code&gt;. To produce the heap profile graph, use &lt;strong&gt;hp2ps&lt;/strong&gt; (see &lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash; Rendering heap profiles to PostScript&lt;/a&gt;). The basic heap profile is broken down by data constructor, with other types of closures (functions, thunks, etc.) grouped into broad categories (e.g. &lt;code&gt;FUN&lt;/code&gt;, &lt;code&gt;THUNK&lt;/code&gt;). To get a more detailed profile, use the full profiling support (&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;). Can be shortened to &lt;a href=&quot;#rts-flag--h&quot;&gt;&lt;code&gt;-h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在文件 &lt;code&gt;prog.hp&lt;/code&gt; 中生成一个基本的堆配置文件。要生&lt;strong&gt;成堆&lt;/strong&gt;配置文件图，请使用&lt;strong&gt;hp2ps&lt;/strong&gt;（请参阅&lt;a href=&quot;profiling#hp2ps&quot;&gt;hp2ps &amp;ndash;将堆配置文件呈现到PostScript&lt;/a&gt;）。基本堆配置文件由数据构造函数分解，而其他类型的闭包（函数，thunk等）则分为大类（例如 &lt;code&gt;FUN&lt;/code&gt; ， &lt;code&gt;THUNK&lt;/code&gt; ）。要获得更详细的配置文件，请使用完整的分析支持（&lt;a href=&quot;profiling#profiling&quot;&gt;Profiling&lt;/a&gt;）。可以缩短为&lt;a href=&quot;#rts-flag--h&quot;&gt; &lt;code&gt;-h&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0c21738d6aa19fd6331a752c61d756e4c5d1e2" translate="yes" xml:space="preserve">
          <source>Generates both dynamic and static object files in a single run of GHC. This option is functionally equivalent to running GHC twice, the second time adding &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt;.</source>
          <target state="translated">在一次GHC中生成动态和静态目标文件。此选项在功能上等同于运行GHC两次，第二次添加 &lt;code&gt;-dynamic -osuf dyn_o -hisuf dyn_hi&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8bac696a293ef57322d908f3d774edadb0d2504" translate="yes" xml:space="preserve">
          <source>Generates the following instance</source>
          <target state="translated">生成以下实例</target>
        </trans-unit>
        <trans-unit id="b291fccbb185f31ef661a2c06451e129d98c552c" translate="yes" xml:space="preserve">
          <source>Generating and unfolding ByteStrings</source>
          <target state="translated">生成和展开ByteStrings</target>
        </trans-unit>
        <trans-unit id="09707d339d82aeb457a3844716013ddd13f46175" translate="yes" xml:space="preserve">
          <source>Generation and unfolding</source>
          <target state="translated">生成和展开</target>
        </trans-unit>
        <trans-unit id="03ba3f9ceb4ba004160e258a483f5fc398019ac0" translate="yes" xml:space="preserve">
          <source>Generative Recursion</source>
          <target state="translated">生成式递归</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="8bf59fb56a7fbc2509919ea5d6c04c72c7dbee3a" translate="yes" xml:space="preserve">
          <source>Generic constructor classes</source>
          <target state="translated">通用构造函数类</target>
        </trans-unit>
        <trans-unit id="7d2bc27114c5d7ad7c30dc9b313f1b4d989a4929" translate="yes" xml:space="preserve">
          <source>Generic instances</source>
          <target state="translated">通用实例</target>
        </trans-unit>
        <trans-unit id="edd1e9ecd70c1b3bcef6a000b5ca8391176387c6" translate="yes" xml:space="preserve">
          <source>Generic operations defined in terms of &lt;code&gt;gunfold&lt;/code&gt;</source>
          <target state="translated">通用操作定义为 &lt;code&gt;gunfold&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62cabccddee103de78ef3b1f3cad602975680931" translate="yes" xml:space="preserve">
          <source>Generic programming support in GHC allows defining classes with methods that do not need a user specification when instantiating: the method body is automatically derived by GHC. This is similar to what happens for standard classes such as &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;Show&lt;/code&gt;, for instance, but now for user-defined classes.</source>
          <target state="translated">GHC中的通用编程支持允许实例化时使用不需要用户指定的方法来定义类：方法主体由GHC自动派生。例如，这类似于标准类（例如 &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; ）的情况，但是现在用户定义的类会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="e9bcfe34f539771b337b3c156114a2353174cdfa" translate="yes" xml:space="preserve">
          <source>Generic representation type</source>
          <target state="translated">通用代表类型</target>
        </trans-unit>
        <trans-unit id="f4695d8314afc3c9511e416fc10b8ff8fb7380b0" translate="yes" xml:space="preserve">
          <source>Generic representation types</source>
          <target state="translated">通用表示类型</target>
        </trans-unit>
        <trans-unit id="f51bcf3a7bcfa796b47cb80453f8bc18c1267d2f" translate="yes" xml:space="preserve">
          <source>Generic support</source>
          <target state="translated">通用支持</target>
        </trans-unit>
        <trans-unit id="0331b125fb4cfaa359feb76babfc239c8fc6a530" translate="yes" xml:space="preserve">
          <source>Generic type classes</source>
          <target state="translated">通用类型类</target>
        </trans-unit>
        <trans-unit id="5cbb5c3303885c08bc437203ebbbcd41ffc5bbf1" translate="yes" xml:space="preserve">
          <source>Generic1</source>
          <target state="translated">Generic1</target>
        </trans-unit>
        <trans-unit id="bfffd736cddd08a4eee689949c3399cb61da773b" translate="yes" xml:space="preserve">
          <source>Get</source>
          <target state="translated">Get</target>
        </trans-unit>
        <trans-unit id="6f167df17b817244e8d92e3121badbef21fa27f9" translate="yes" xml:space="preserve">
          <source>Get a lazy ByteString that is terminated with a NUL byte. The returned string does not contain the NUL byte. Fails if it reaches the end of input without finding a NUL.</source>
          <target state="translated">获取一个以NUL字节结束的懒惰ByteString。返回的字符串不包含NUL字节。如果到了输入端没有找到NUL,则失败。</target>
        </trans-unit>
        <trans-unit id="c239d3b622f7fd565781d4f4dcab4e09927edb9e" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">在$ PATH变量中获取 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="1f1899930b9569e10c6cfc88a4f4b7498dee068a" translate="yes" xml:space="preserve">
          <source>Get a list of &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;s in the $PATH variable.</source>
          <target state="translated">在$ PATH变量中获取 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; 的列表。</target>
        </trans-unit>
        <trans-unit id="af251c391320051e268fa05c67fd1aedca208ee5" translate="yes" xml:space="preserve">
          <source>Get a reference to a free variable at a breakpoint</source>
          <target state="translated">在断点处获取对自由变量的引用。</target>
        </trans-unit>
        <trans-unit id="57078d0a3c8b109b1f4379a4aa38d26dc7512eab" translate="yes" xml:space="preserve">
          <source>Get a specific component of the state, using a projection function supplied.</source>
          <target state="translated">使用提供的投影函数,获取状态的特定分量。</target>
        </trans-unit>
        <trans-unit id="2662cd1869f4ae3db82467978d3f7b0019412bbe" translate="yes" xml:space="preserve">
          <source>Get a string representation of the current execution stack state.</source>
          <target state="translated">获取当前执行栈状态的字符串表示。</target>
        </trans-unit>
        <trans-unit id="6c31e11b823050ba2cea2c8460aec3b4022e12b5" translate="yes" xml:space="preserve">
          <source>Get a trace of the current execution stack state.</source>
          <target state="translated">获取当前执行栈状态的跟踪。</target>
        </trans-unit>
        <trans-unit id="c2e76620f050a66a8250541fdce2ec4f919515c5" translate="yes" xml:space="preserve">
          <source>Get all extensions.</source>
          <target state="translated">获取所有的分机。</target>
        </trans-unit>
        <trans-unit id="42372be9103fc691ad731746a614a19b7f331cb5" translate="yes" xml:space="preserve">
          <source>Get an environment value or a default value.</source>
          <target state="translated">获取一个环境值或默认值。</target>
        </trans-unit>
        <trans-unit id="dbb6b436eb32ee410eebe762e1c62025718fa179" translate="yes" xml:space="preserve">
          <source>Get an execution stack.</source>
          <target state="translated">获得一个执行堆栈。</target>
        </trans-unit>
        <trans-unit id="a8196f1a388937eb3c1622a100e017f856c9eea6" translate="yes" xml:space="preserve">
          <source>Get current runtime system statistics.</source>
          <target state="translated">获取当前运行时的系统统计数据。</target>
        </trans-unit>
        <trans-unit id="4e715c7dae3e98783c9bdf9c4e4ab64aac77cb14" translate="yes" xml:space="preserve">
          <source>Get state from the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad. Note that the state is local to the Haskell module in which the Template Haskell expression is executed.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Q&quot;&gt;Q&lt;/a&gt;&lt;/code&gt; monad 获取状态。请注意，状态是在其中执行模板Haskell表达式的Haskell模块本地的。</target>
        </trans-unit>
        <trans-unit id="3aeb2eca8a488b50abdc7a58183f5262c45f8bd7" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 放在 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="2e515f15bea5855df5eb0cbb2b2918fe8e0d835d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">获取与给定值关联的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="add5e999e95e74780d3f395fb32f6bda146264c9" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; at the head of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 放在 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="b4cb72e96eed05217967ca7009b90c06b60dd3df" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; associated with the given value.</source>
          <target state="translated">获取与给定值关联的 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be4742313ddbe2b9ab325b82b61b955b5264d92" translate="yes" xml:space="preserve">
          <source>Get the UT1 time of a local time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">获取某地时间在某一子午线上的UT1时间(单位:度,正数为东)。</target>
        </trans-unit>
        <trans-unit id="72efa4e3276ea481268ea1bf73cc2a94fbd81a20" translate="yes" xml:space="preserve">
          <source>Get the UTC time of a local time in a time zone.</source>
          <target state="translated">获取一个时区的当地时间的UTC时间。</target>
        </trans-unit>
        <trans-unit id="7f011efdea73fd8590a82ad76b2135b1a44dfcb1" translate="yes" xml:space="preserve">
          <source>Get the base name, without an extension or path.</source>
          <target state="translated">获取基本名称,不含扩展名或路径。</target>
        </trans-unit>
        <trans-unit id="98b9a6f135af51d0129f1689a0b25dbe177eead3" translate="yes" xml:space="preserve">
          <source>Get the contents of the &lt;code&gt;PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">获取 &lt;code&gt;PATH&lt;/code&gt; 环境变量的内容。</target>
        </trans-unit>
        <trans-unit id="0b700626a66522b75396b422eaadb24213066b7c" translate="yes" xml:space="preserve">
          <source>Get the current &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; from the system clock.</source>
          <target state="translated">从系统时钟获取当前 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0270de0567bc90a30e367bf358f647b2ce50ddaa" translate="yes" xml:space="preserve">
          <source>Get the current POSIX time from the system clock.</source>
          <target state="translated">从系统时钟获取当前POSIX时间。</target>
        </trans-unit>
        <trans-unit id="cfadd67e7a7e19604994f22e158522395dbaf06e" translate="yes" xml:space="preserve">
          <source>Get the current line input history.</source>
          <target state="translated">获取当前行输入历史。</target>
        </trans-unit>
        <trans-unit id="66262b55256050223b751d7abe957f7eec02fd90" translate="yes" xml:space="preserve">
          <source>Get the current time-zone.</source>
          <target state="translated">获取当前时区。</target>
        </trans-unit>
        <trans-unit id="e7163ecf6dc60dacacf312a4e68e048ac45e8b8b" translate="yes" xml:space="preserve">
          <source>Get the current value of &lt;code&gt;errno&lt;/code&gt; in the current thread.</source>
          <target state="translated">获取当前线程中 &lt;code&gt;errno&lt;/code&gt; 的当前值。</target>
        </trans-unit>
        <trans-unit id="d1d2b0b9bd8a9db6da9a73ad6ce4498757df48e6" translate="yes" xml:space="preserve">
          <source>Get the default size of the terminal. For resizeable terminals (e.g., &lt;code&gt;xterm&lt;/code&gt;), these may not correspond to the actual dimensions.</source>
          <target state="translated">获取终端的默认大小。对于可调整大小的终端（例如 &lt;code&gt;xterm&lt;/code&gt; ），这些可能与实际尺寸不符。</target>
        </trans-unit>
        <trans-unit id="229fedca2524f6589d1fa7505416425ee29197a8" translate="yes" xml:space="preserve">
          <source>Get the directory name, move up one level.</source>
          <target state="translated">获取目录名,上移一级。</target>
        </trans-unit>
        <trans-unit id="8db9a8dd60cf3b1a36fa15f815b60c5ad67c15ec" translate="yes" xml:space="preserve">
          <source>Get the drive from a filepath.</source>
          <target state="translated">从文件路径中获取驱动器。</target>
        </trans-unit>
        <trans-unit id="61a15789e89a9c4b730cbee22dba43d0dca29efe" translate="yes" xml:space="preserve">
          <source>Get the echoing status of a handle connected to a terminal.</source>
          <target state="translated">获取连接到终端的手柄的呼应状态。</target>
        </trans-unit>
        <trans-unit id="e4b0de19671fd4212da0915b4b88fb238c175abf" translate="yes" xml:space="preserve">
          <source>Get the extension of a file, returns &lt;code&gt;&quot;&quot;&lt;/code&gt; for no extension, &lt;code&gt;.ext&lt;/code&gt; otherwise.</source>
          <target state="translated">获取文件的扩展名， &lt;code&gt;.ext&lt;/code&gt; 没有扩展名，则返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，否则返回.ext。</target>
        </trans-unit>
        <trans-unit id="b728f0791284fd67656c0aa4feb4d641406bdcd3" translate="yes" xml:space="preserve">
          <source>Get the file name.</source>
          <target state="translated">获取文件名。</target>
        </trans-unit>
        <trans-unit id="49ee7152dd7f669fc2d1e6f53b094147b3cae76a" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">获取另一个字符串中子字符串的第一个索引，如果找不到该字符串，则为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;findSubstring p s&lt;/code&gt; 等同于 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f14dd66fb1e3670e1835aac5f144235035b8e6b1" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">获取另一个字符串中子字符串的第一个索引，如果找不到该字符串，则为 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;findSubstring p s&lt;/code&gt; 等同于 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00312e6da40cecc61aba8aa333ef44ff0591b478" translate="yes" xml:space="preserve">
          <source>Get the first index of a substring in another string, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if the string is not found. &lt;code&gt;findSubstring p s&lt;/code&gt; is equivalent to &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt;.</source>
          <target state="translated">获取另一个字符串中子字符串的第一个索引，如果找不到该字符串，则为 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;findSubstring p s&lt;/code&gt; 等同于 &lt;code&gt;listToMaybe (findSubstrings p s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee775ce9d7b994986c62951bb94f01d85eb44d2c" translate="yes" xml:space="preserve">
          <source>Get the fraction of a day since midnight given a time of day.</source>
          <target state="translated">获取一天中给定时间的午夜后的分数。</target>
        </trans-unit>
        <trans-unit id="a2a3573464388922e250a7eb45275992553e7757" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">通过使用窗口的标题获取当前控制台窗口的句柄。请参阅：&lt;a href=&quot;http://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt; : //support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="960fe0a37606fd52b1bf4fbbc6af3101d8d8466b" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window by using window's title. See: &lt;a href=&quot;https://support.microsoft.com/kb/124103&quot;&gt;http://support.microsoft.com/kb/124103&lt;/a&gt;</source>
          <target state="translated">通过使用窗口的标题获取当前控制台窗口的句柄。请参阅：&lt;a href=&quot;https://support.microsoft.com/kb/124103&quot;&gt;http&lt;/a&gt; : //support.microsoft.com/kb/124103</target>
        </trans-unit>
        <trans-unit id="8c5f2319e438a4baa014695b30ce229379a38b83" translate="yes" xml:space="preserve">
          <source>Get the handle of the current console window.</source>
          <target state="translated">获取当前控制台窗口的句柄。</target>
        </trans-unit>
        <trans-unit id="0a7f4400d930923897bb54c841a6213ed68644f4" translate="yes" xml:space="preserve">
          <source>Get the label for a given key.</source>
          <target state="translated">获取给定钥匙的标签。</target>
        </trans-unit>
        <trans-unit id="5aeda20685c51fc6abcd2b337403dbbcd7923a16" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的标签。</target>
        </trans-unit>
        <trans-unit id="fa9be9ab91ef24c2b81729a5316d49813c0c3129" translate="yes" xml:space="preserve">
          <source>Get the label of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的标签。</target>
        </trans-unit>
        <trans-unit id="9e900e82bce3a84192ef0492d0d7a7d7cc15cf88" translate="yes" xml:space="preserve">
          <source>Get the local time of a UT1 time on a particular meridian (in degrees, positive is East).</source>
          <target state="translated">获取UT1时间在某一子午线上的当地时间(以度为单位,正数为东)。</target>
        </trans-unit>
        <trans-unit id="a833157a0c1508bf9bcfd2a53e5dcc6026df288f" translate="yes" xml:space="preserve">
          <source>Get the local time of a UTC time in a time zone.</source>
          <target state="translated">获取一个时区的UTC时间的当地时间。</target>
        </trans-unit>
        <trans-unit id="d2cb2c2ac1383013616533e9898eff073620487a" translate="yes" xml:space="preserve">
          <source>Get the local time-zone for a given time (varying as per summertime adjustments).</source>
          <target state="translated">获取给定时间的当地时区(根据夏季调整而变化)。</target>
        </trans-unit>
        <trans-unit id="6114c6996f47966af81f9bc3720926a914d7721e" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="195b1279f51510a869c9ae7e93ef77f8d07cfcaf" translate="yes" xml:space="preserve">
          <source>Get the module of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的模块。</target>
        </trans-unit>
        <trans-unit id="dfd8ea5bc6022f728ddbfd7c123fbf615d9688aa" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TBQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TBQueue&lt;/code&gt; 中获取下一个值而不删除它，如果通道为空，则重试。</target>
        </trans-unit>
        <trans-unit id="ea4da6389ff2053f72d8e6ce3d12629df113a35f" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TChan&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TChan&lt;/code&gt; 获取下一个值而不删除它，如果通道为空则重试。</target>
        </trans-unit>
        <trans-unit id="12978c3ca4699ea4b74cf23abc51101451dfa99c" translate="yes" xml:space="preserve">
          <source>Get the next value from the &lt;code&gt;TQueue&lt;/code&gt; without removing it, retrying if the channel is empty.</source>
          <target state="translated">从 &lt;code&gt;TQueue&lt;/code&gt; 获取下一个值而不删除它，如果通道为空，则重试。</target>
        </trans-unit>
        <trans-unit id="bf9180c869cf2ed71dc13f9fcb1eb1c6e3205b73" translate="yes" xml:space="preserve">
          <source>Get the number of picoseconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:DiffTime&quot;&gt;DiffTime&lt;/a&gt;&lt;/code&gt; 中的皮秒数。</target>
        </trans-unit>
        <trans-unit id="c41d9abbda9d142fc31fefd829bb6067eeb4ce90" translate="yes" xml:space="preserve">
          <source>Get the number of the Monday-starting week in the year and the day of the week. The first Monday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%W&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Monday is 1, Sunday is 7 (as &lt;code&gt;%u&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">获取一年中的星期一开始的星期几和星期几。第一个星期一为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%W&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。星期一是1，星期日是7（在 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; 中为 &lt;code&gt;%u&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0df1f5547dc8aa7816f6fad31fb426c23b895b69" translate="yes" xml:space="preserve">
          <source>Get the number of the Sunday-starting week in the year and the day of the week. The first Sunday is the first day of week 1, any earlier days in the year are week 0 (as &lt;code&gt;%U&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;). Sunday is 0, Saturday is 6 (as &lt;code&gt;%w&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">获取一年中的星期天开始的星期几。第一个星期天为第一周的第一天，在今年早些时候的任何天为0周（如 &lt;code&gt;%U&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。周日是0，星期六是6（如 &lt;code&gt;%w&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-time-format#v:formatTime&quot;&gt;formatTime&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="121d46ceb7a963cb07f940143c37c6199a392894" translate="yes" xml:space="preserve">
          <source>Get the permissions of a file or directory.</source>
          <target state="translated">获取文件或目录的权限。</target>
        </trans-unit>
        <trans-unit id="0b02102ad5781ec349c4ebacac0f7e53440d1227" translate="yes" xml:space="preserve">
          <source>Get the precedence of a fixity value.</source>
          <target state="translated">获取固定值的优先级。</target>
        </trans-unit>
        <trans-unit id="e7143c5b76253904c07ab35abe499b891a12912e" translate="yes" xml:space="preserve">
          <source>Get the remaining bytes as a lazy ByteString. Note that this can be an expensive function to use as it forces reading all input and keeping the string in-memory.</source>
          <target state="translated">获取剩余的字节作为一个懒惰的ByteString。请注意,这可能是一个昂贵的函数,因为它强制读取所有的输入并将字符串保存在内存中。</target>
        </trans-unit>
        <trans-unit id="1304ab12c0cdd21150623c6715f63616fbbb4e78" translate="yes" xml:space="preserve">
          <source>Get the seconds in a &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;data-time-clock#t:NominalDiffTime&quot;&gt;NominalDiffTime&lt;/a&gt;&lt;/code&gt; 中获取秒数。</target>
        </trans-unit>
        <trans-unit id="934367e164393d0463e93c43a0ab568d78bce4aa" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的源范围。</target>
        </trans-unit>
        <trans-unit id="3c3cbce66b5c2a88daa26c2b44a8fd7660727935" translate="yes" xml:space="preserve">
          <source>Get the source span of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentre&quot;&gt;CostCentre&lt;/a&gt;&lt;/code&gt; 的源范围。</target>
        </trans-unit>
        <trans-unit id="d92d0722c9103f5297ca98c8e8cc4cdf409d235d" translate="yes" xml:space="preserve">
          <source>Get the stack trace attached to an object.</source>
          <target state="translated">获取连接到对象的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="ef4ec76b2d57cdc855102b78c7d2aacd5eb5df5f" translate="yes" xml:space="preserve">
          <source>Get the string corresponding to the given format specifier.</source>
          <target state="translated">获取对应于给定格式指定器的字符串。</target>
        </trans-unit>
        <trans-unit id="87aef325e766ce9f4d00515df7046505bd4518cc" translate="yes" xml:space="preserve">
          <source>Get the system time, epoch start of 1970 UTC, leap-seconds ignored. &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; is typically much faster than &lt;code&gt;getCurrentTime&lt;/code&gt;.</source>
          <target state="translated">获取系统时间，以1970年UTC为起始时间，忽略leap秒。 &lt;code&gt;&lt;a href=&quot;data-time-clock-system#v:getSystemTime&quot;&gt;getSystemTime&lt;/a&gt;&lt;/code&gt; 通常比 &lt;code&gt;getCurrentTime&lt;/code&gt; 快得多。</target>
        </trans-unit>
        <trans-unit id="7079387e20d5a7e77408141907d7b3e57605a870" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的尾部。</target>
        </trans-unit>
        <trans-unit id="0d673419acfa57ddfd2386504b1ce9ad7e3752ee" translate="yes" xml:space="preserve">
          <source>Get the tail of a &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;&lt;a href=&quot;ghc-stack-ccs#t:CostCentreStack&quot;&gt;CostCentreStack&lt;/a&gt;&lt;/code&gt; 的尾部。</target>
        </trans-unit>
        <trans-unit id="9fd6f0d6fca981e6ab4e6521490eddb2c5712dc5" translate="yes" xml:space="preserve">
          <source>Get the time of day given a time since midnight. Time more than 24h will be converted to leap-seconds.</source>
          <target state="translated">获取从午夜开始的一天的时间。超过24小时的时间将被转换为闰秒。</target>
        </trans-unit>
        <trans-unit id="8502401c97ea5b01798883d629ca915252c4bb4a" translate="yes" xml:space="preserve">
          <source>Get the time of day given the fraction of a day since midnight.</source>
          <target state="translated">获取一天的时间,给定从午夜起一天的分数。</target>
        </trans-unit>
        <trans-unit id="87868e820d0672f58ddcfe614c42c8b0983a793a" translate="yes" xml:space="preserve">
          <source>Get the time since midnight for a given time of day.</source>
          <target state="translated">获取一天中某一时间的午夜后的时间。</target>
        </trans-unit>
        <trans-unit id="1b78fe6cc806943f6f8e66a65db6ae9cfdb7e198" translate="yes" xml:space="preserve">
          <source>Get the total number of bytes read to this point.</source>
          <target state="translated">获取至此读取的总字节数。</target>
        </trans-unit>
        <trans-unit id="b2759c7b05c76b086373cf3cd5862282e5c13612" translate="yes" xml:space="preserve">
          <source>Get user name. See: &lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https://github.com/haskell/win32/issues/8&lt;/a&gt;, &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;http://lpaste.net/41521&lt;/a&gt;</source>
          <target state="translated">获取用户名。参见：&lt;a href=&quot;https://github.com/haskell/win32/issues/8&quot;&gt;https&lt;/a&gt; : //github.com/haskell/win32/issues/8，http : &lt;a href=&quot;http://lpaste.net/41521&quot;&gt;//lpaste.net/41521&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5c8a83eb7ab72a3dc65bc027d0f4aa047843fc7" translate="yes" xml:space="preserve">
          <source>Get/Set Foreground Window.</source>
          <target state="translated">获取/设置前景窗口。</target>
        </trans-unit>
        <trans-unit id="903bf1d323eabebea6c98315f978de0785ae607a" translate="yes" xml:space="preserve">
          <source>GetDCExFlags</source>
          <target state="translated">GetDCExFlags</target>
        </trans-unit>
        <trans-unit id="89693458149c776750a29304631c344bbe585ec6" translate="yes" xml:space="preserve">
          <source>GetOpt</source>
          <target state="translated">GetOpt</target>
        </trans-unit>
        <trans-unit id="bebb9ee2bec563ef922802bc58d46f783e690375" translate="yes" xml:space="preserve">
          <source>Gets a GHC Handle File description from the given OS Handle or POSIX fd.</source>
          <target state="translated">从给定的操作系统手柄或POSIX fd中获取一个GHC手柄文件描述。</target>
        </trans-unit>
        <trans-unit id="391454aac39ac02e0b6599b94000d8e1ad34b74e" translate="yes" xml:space="preserve">
          <source>Gets specific component of the state, using a projection function supplied.</source>
          <target state="translated">使用所提供的投影函数,获取状态的特定组成部分。</target>
        </trans-unit>
        <trans-unit id="6061427a31c5db7d197b3782356bc17d6f9846c4" translate="yes" xml:space="preserve">
          <source>Gets the constructor for an index (algebraic datatypes only)</source>
          <target state="translated">获取索引的构造函数(仅代数数据类型)。</target>
        </trans-unit>
        <trans-unit id="d48574aaa6a44f8bb266db4ad641f32e96c244ee" translate="yes" xml:space="preserve">
          <source>Gets the constructors of an algebraic datatype</source>
          <target state="translated">获取一个代数数据类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="30d18e2f7f8f2762c44e631f431574183f3d5e0a" translate="yes" xml:space="preserve">
          <source>Gets the datatype of a constructor</source>
          <target state="translated">获取构造函数的数据类型。</target>
        </trans-unit>
        <trans-unit id="d4dc76f4469b81893c0ae2bc88486f930017fb3d" translate="yes" xml:space="preserve">
          <source>Gets the field labels of a constructor. The list of labels is returned in the same order as they were given in the original constructor declaration.</source>
          <target state="translated">获取构造函数的字段标签。标签列表的返回顺序与原始构造函数声明中给出的顺序相同。</target>
        </trans-unit>
        <trans-unit id="e7a5b1389209d807faab0ae733fe92f6a6a0918a" translate="yes" xml:space="preserve">
          <source>Gets the fixity of a constructor</source>
          <target state="translated">获取构造函数的固定性</target>
        </trans-unit>
        <trans-unit id="2aeda0e99dcc18340bc33ab99d623627ed797ffd" translate="yes" xml:space="preserve">
          <source>Gets the index of a constructor (algebraic datatypes only)</source>
          <target state="translated">获取构造函数的索引(仅代数数据类型)。</target>
        </trans-unit>
        <trans-unit id="24b5a11d77af890b85eeec066f5550cfcba9c2d2" translate="yes" xml:space="preserve">
          <source>Gets the maximum constructor index of an algebraic datatype</source>
          <target state="translated">获取一个代数数据类型的最大构造函数索引。</target>
        </trans-unit>
        <trans-unit id="63208cbec1942c64c7945f85554d64b17e167933" translate="yes" xml:space="preserve">
          <source>Gets the module of a type constructor: take *.*.*... before name</source>
          <target state="translated">获取类型构造函数的模块:在name前取*.*.*...。</target>
        </trans-unit>
        <trans-unit id="a14644b47cefa2fe7b14baa4f1e18f50cba475e7" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of a datatype</source>
          <target state="translated">获取一个数据类型的公开展示。</target>
        </trans-unit>
        <trans-unit id="aa6153842db5ae726fc9aeb6bbb6b9011dfbc619" translate="yes" xml:space="preserve">
          <source>Gets the public presentation of constructors</source>
          <target state="translated">获取建造者的公开展示</target>
        </trans-unit>
        <trans-unit id="703cb827ba9bdd1f867b291abff6c22c30e6a5e1" translate="yes" xml:space="preserve">
          <source>Gets the string for a constructor</source>
          <target state="translated">获取构造函数的字符串</target>
        </trans-unit>
        <trans-unit id="073e5a617058affe4e3dd60346b258d7e3ada99f" translate="yes" xml:space="preserve">
          <source>Gets the type constructor including the module</source>
          <target state="translated">获取包括模块在内的类型构造函数</target>
        </trans-unit>
        <trans-unit id="878dc6c0dba59b9499bd6c7cb41176237f1830f2" translate="yes" xml:space="preserve">
          <source>Gets the unqualified type constructor: drop *.*.*... before name</source>
          <target state="translated">获取非限定类型构造函数:在name前丢弃*.*.*...。</target>
        </trans-unit>
        <trans-unit id="eae1640c76d18f7f4e0493ecb26f076efc1608f6" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">给插件模块提供参数；必须使用&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;指定模块。</target>
        </trans-unit>
        <trans-unit id="e2007c872e45e146dace044ab7de7d8433373895" translate="yes" xml:space="preserve">
          <source>Give arguments to a plugin module; module must be specified with &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;</source>
          <target state="translated">给插件模块提供参数；必须使用 &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; 指定模块</target>
        </trans-unit>
        <trans-unit id="df37476f32c9a34e20351ac98761daee0a7c8824" translate="yes" xml:space="preserve">
          <source>Give explicit type signatures:</source>
          <target state="translated">给予明确的类型签名。</target>
        </trans-unit>
        <trans-unit id="b1486578eb7ad0f6181dbd9aee1d050053d73d85" translate="yes" xml:space="preserve">
          <source>GiveGCStats</source>
          <target state="translated">GiveGCStats</target>
        </trans-unit>
        <trans-unit id="76d11fa818460b917132ef39c92a210ad06313c6" translate="yes" xml:space="preserve">
          <source>Given a CNF and the address of one its compact blocks, returns the next compact block and its utilized size, or &lt;code&gt;nullAddr#&lt;/code&gt; if the argument was the last compact block in the CNF.</source>
          <target state="translated">给定一个CNF及其压缩块的地址，则返回下一个压缩块及其使用的大小；如果参数是CNF中的最后一个压缩块，则返回 &lt;code&gt;nullAddr#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94191c500f1483bd7efa1a2a99e51782da6743c9" translate="yes" xml:space="preserve">
          <source>Given a compact and the address of one its blocks, returns the next block and its size, or #nullAddr if the argument was the last block in the compact.</source>
          <target state="translated">给定一个压缩包和它的一个块的地址,返回下一个块和它的大小,如果参数是压缩包中的最后一个块,则返回#nullAddr。</target>
        </trans-unit>
        <trans-unit id="3a80b2cab78c4d18e4e971d00e535e51ca962e1e" translate="yes" xml:space="preserve">
          <source>Given a list of path segments, expand &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt;. The path segments must not contain path separators.</source>
          <target state="translated">给定路径段列表，请展开 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;..&lt;/code&gt; 。路径段不得包含路径分隔符。</target>
        </trans-unit>
        <trans-unit id="c3c7188c588c63ac10069c82a4b6f332a946f2d2" translate="yes" xml:space="preserve">
          <source>Given a list of strings, concatenate them into a single string with escaping of certain characters, and the addition of a newline between each string. The escaping is done by adding a single backslash character before any whitespace, single quote, double quote, or backslash character, so this escaping character must be removed. Unescaped whitespace (in this case, newline) is part of this &quot;transport&quot; format to indicate the end of the previous string and the start of a new string.</source>
          <target state="translated">给定一个字符串列表,将它们连接成一个单一的字符串,并对某些字符进行转义,在每个字符串之间添加一个换行符。转义是通过在任何空格、单引号、双引号或反斜杠字符前添加一个反斜杠字符来完成的,因此必须删除这个转义字符。未转码的空白字符(在本例中是新行)是这种 &quot;传输 &quot;格式的一部分,用于表示前一个字符串的结束和新字符串的开始。</target>
        </trans-unit>
        <trans-unit id="95bb9fa5760cd6c7244418378ad672bd58d5c738" translate="yes" xml:space="preserve">
          <source>Given a maximum size &lt;code&gt;l&lt;/code&gt; and an action &lt;code&gt;f&lt;/code&gt; that fills the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; starting at the given &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; and returns the actual utilized length, &lt;code&gt;createUpToN` l f&lt;/code&gt; returns the filled &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">给定最大大小 &lt;code&gt;l&lt;/code&gt; 和从给定 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 开始填充 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 并返回实际使用长度的操作 &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;createUpToN` l f&lt;/code&gt; 返回填充的 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16da4c70b81333f0df3ff68a48df5f83b45f827d" translate="yes" xml:space="preserve">
          <source>Given a means of mapping the elements of a structure to lists, computes the concatenation of all such lists in order.</source>
          <target state="translated">给定一个结构元素映射到列表的方法,计算所有这些列表的顺序连接。</target>
        </trans-unit>
        <trans-unit id="3a801cbb38fd452cebffd80bbe0ff104534670f0" translate="yes" xml:space="preserve">
          <source>Given a name or path, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; appends the &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; to the query and searches for executable files in the list of given search directories and returns all occurrences.</source>
          <target state="translated">给定一个名称或路径， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 追加 &lt;code&gt;&lt;a href=&quot;system-directory#v:exeExtension&quot;&gt;exeExtension&lt;/a&gt;&lt;/code&gt; 的查询和搜索在给定的搜索目录列表中的可执行文件，并返回所有出现。</target>
        </trans-unit>
        <trans-unit id="f60a5850abfa409415094c2e4639245bcd5e4453" translate="yes" xml:space="preserve">
          <source>Given a parallel comprehension of the form:</source>
          <target state="translated">鉴于形式的平行理解。</target>
        </trans-unit>
        <trans-unit id="7f7b64d5937cb8bf270b46af60debea6611cd0d2" translate="yes" xml:space="preserve">
          <source>Given a pattern synonym definition of the form</source>
          <target state="translated">给定形式的模式同义词定义</target>
        </trans-unit>
        <trans-unit id="965f2d8e8f9362b4a99f9e5b536b6cb970cf61ea" translate="yes" xml:space="preserve">
          <source>Given a program &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; and arguments &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; returns a string suitable for pasting into &lt;code&gt;/bin/sh&lt;/code&gt; (on Unix systems) or &lt;code&gt;CMD.EXE&lt;/code&gt; (on Windows).</source>
          <target state="translated">给定程序 &lt;code&gt;&lt;em&gt;p&lt;/em&gt;&lt;/code&gt; 和参数 &lt;code&gt;&lt;em&gt;args&lt;/em&gt;&lt;/code&gt; ， &lt;code&gt;showCommandForUser &lt;em&gt;p&lt;/em&gt; &lt;em&gt;args&lt;/em&gt;&lt;/code&gt; 返回适合粘贴到 &lt;code&gt;/bin/sh&lt;/code&gt; （在Unix系统上）或 &lt;code&gt;CMD.EXE&lt;/code&gt; （在Windows上）的字符串。</target>
        </trans-unit>
        <trans-unit id="3eb5e163812056919d8a8728f088bc84becbf489" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. In the case where the source and destination are the same array the source and destination regions may overlap.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将源数组中的元素复制到目的数组中。两个数组都必须完全包含指定的范围,但这并不被检查。在源数组和目的数组是同一个数组的情况下,源数组和目的数组的区域可能会重叠。</target>
        </trans-unit>
        <trans-unit id="397134dbcf199297b7dfe8e0847122e69780ab05" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. Both arrays must fully contain the specified ranges, but this is not checked. The two arrays must not be the same array in different states, but this is not checked either.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将源数组中的元素复制到目的数组中。两个数组必须完全包含指定的范围,但这并不被检查。两个数组在不同状态下必须不是同一个数组,但这也不被选中。</target>
        </trans-unit>
        <trans-unit id="7b650bc9b9dd959ede9c56caf5b27fbb08e9b7a5" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, a destination array, an offset into the destination array, and a number of elements to copy, copy the elements from the source array to the destination array. The source and destination arrays can refer to the same array. Both arrays must fully contain the specified ranges, but this is not checked. The regions are allowed to overlap, although this is only possible when the same array is provided as both the source and the destination.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量,一个目的数组,一个目的数组的偏移量,以及要复制的元素数,将元素从源数组复制到目的数组。源数组和目的数组可以指同一个数组。两个数组必须完全包含指定的范围,但这并不被检查。允许区域重叠,但这只有在源数组和目的数组都是同一个数组时才有可能。</target>
        </trans-unit>
        <trans-unit id="e9806083ebd16a3822ef2b68e8b1fdca151f0e70" translate="yes" xml:space="preserve">
          <source>Given a source array, an offset into the source array, and a number of elements to copy, create a new array with the elements from the source array. The provided array must fully contain the specified range, but this is not checked.</source>
          <target state="translated">给定一个源数组,一个源数组的偏移量和要复制的元素数量,用源数组中的元素创建一个新的数组。所提供的数组必须完全包含指定的范围,但这并不被检查。</target>
        </trans-unit>
        <trans-unit id="969049b655813db2b900482374a384fed3209666" translate="yes" xml:space="preserve">
          <source>Given a string of concatenated strings, separate each by removing a layer of &lt;em&gt;quoting&lt;/em&gt; and/or &lt;em&gt;escaping&lt;/em&gt; of certain characters.</source>
          <target state="translated">给定一串串接的字符串，请通过除去某些字符的&lt;em&gt;引号&lt;/em&gt;和/或&lt;em&gt;转义&lt;/em&gt;符来分隔每个字符串。</target>
        </trans-unit>
        <trans-unit id="db80bf9064baa22164cf6760944ac2e09d91e904" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, ..., w, x, y)&lt;/code&gt;, the result of a fold with an operator function &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">给定具有元素 &lt;code&gt;(a, b, ..., w, x, y)&lt;/code&gt; 的结构 &lt;code&gt;t&lt;/code&gt; ，具有运算符函数 &lt;code&gt;f&lt;/code&gt; 的折叠结果等同于：</target>
        </trans-unit>
        <trans-unit id="92ca9d8fe607bde8e742ea61d114d46004740856" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, ..., x, y)&lt;/code&gt;, the result of a fold with operator &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">给定具有元素 &lt;code&gt;(a, b, ..., x, y)&lt;/code&gt; 的结构 &lt;code&gt;t&lt;/code&gt; ，使用运算符 &lt;code&gt;f&lt;/code&gt; 进行折叠的结果等同于：</target>
        </trans-unit>
        <trans-unit id="36e71f3e73c2028c2e375c33d2e51213ee17970d" translate="yes" xml:space="preserve">
          <source>Given a structure &lt;code&gt;t&lt;/code&gt; with elements &lt;code&gt;(a, b, c, ..., x, y)&lt;/code&gt;, the result of a fold with an operator function &lt;code&gt;f&lt;/code&gt; is equivalent to:</source>
          <target state="translated">给定具有元素 &lt;code&gt;(a, b, c, ..., x, y)&lt;/code&gt; 的结构 &lt;code&gt;t&lt;/code&gt; ，具有运算符函数 &lt;code&gt;f&lt;/code&gt; 的折叠结果等同于：</target>
        </trans-unit>
        <trans-unit id="c3bf1d8801ada8745b533a3c230200cb9cb7fd62" translate="yes" xml:space="preserve">
          <source>Given a structure with elements whose type is a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;, combine them via the monoid's &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; operator. This fold is right-associative and lazy in the accumulator. When you need a strict left-associative fold, use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt;` instead, with &lt;code&gt;&lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; as the map.</source>
          <target state="translated">给定具有类型为 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 的元素的结构，请通过monoid的 &lt;code&gt;(&lt;a href=&quot;data-monoid#v:-60--62-&quot;&gt;&amp;lt;&amp;gt;&lt;/a&gt;)&lt;/code&gt; 运算符将它们组合。该折叠在累加器中是右关联的并且是惰性的。当您需要严格的左关联折叠时，请改用 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; `，将 &lt;code&gt;&lt;a href=&quot;data-function#v:id&quot;&gt;id&lt;/a&gt;&lt;/code&gt; 作为地图。</target>
        </trans-unit>
        <trans-unit id="03e6b879d2b54e40963864600799d0ff4945f213" translate="yes" xml:space="preserve">
          <source>Given a value of type &lt;code&gt;Right a&lt;/code&gt;, GHC must produce a value of type &lt;code&gt;Right b&lt;/code&gt;. Since the argument to the &lt;code&gt;Right&lt;/code&gt; constructor has type &lt;code&gt;Either Int a&lt;/code&gt;, the code recursively calls &lt;code&gt;fmap&lt;/code&gt; on it to produce a value of type &lt;code&gt;Either Int b&lt;/code&gt;, which is used in turn to construct a final value of type &lt;code&gt;Right b&lt;/code&gt;.</source>
          <target state="translated">给定类型为 &lt;code&gt;Right a&lt;/code&gt; 的值，GHC必须产生类型为 &lt;code&gt;Right b&lt;/code&gt; 的值。由于 &lt;code&gt;Right&lt;/code&gt; 构造函数的参数的类型为 &lt;code&gt;Either Int a&lt;/code&gt; ，因此代码对它进行递归调用 &lt;code&gt;fmap&lt;/code&gt; ，以生成 &lt;code&gt;Either Int b&lt;/code&gt; 类型的值，该值又用于构造 &lt;code&gt;Right b&lt;/code&gt; 类型的最终值。</target>
        </trans-unit>
        <trans-unit id="7aaad46966fd2f7a4a7364b632ff8275c3c05bbf" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to Orthodox Christian tradition</source>
          <target state="translated">给定年份,根据东正教传统找到复活节。</target>
        </trans-unit>
        <trans-unit id="4140020fabc63460d4c747a4e5f0b417d3732e7f" translate="yes" xml:space="preserve">
          <source>Given a year, find Easter according to the Gregorian method</source>
          <target state="translated">给定一个年份,根据格里高利年法找出复活节</target>
        </trans-unit>
        <trans-unit id="a90b9b7c80eb2a84b94bea4951e31b81448a4a8d" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to Orthodox Christian tradition</source>
          <target state="translated">给定一年,根据东正教的传统,找出受难节满月的日子</target>
        </trans-unit>
        <trans-unit id="db828b10c64e473910ca6113376ab95106d563c4" translate="yes" xml:space="preserve">
          <source>Given a year, find the Paschal full moon according to the Gregorian method</source>
          <target state="translated">给定一个年份,根据格里高利法找出受难节满月。</target>
        </trans-unit>
        <trans-unit id="230679363978006fa3682de32adc84e8302aac8e" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">给定一个任意地址和一个对齐约束， &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 产生下一个满足对齐约束的更高地址。对齐约束 &lt;code&gt;x&lt;/code&gt; 由 &lt;code&gt;x&lt;/code&gt; 整除的任何地址都可以满足。此操作是幂等的。</target>
        </trans-unit>
        <trans-unit id="273674e552deb353cd1f1485d7f784e9fb5ab934" translate="yes" xml:space="preserve">
          <source>Given an arbitrary address and an alignment constraint, &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; yields the next higher address that fulfills the alignment constraint. An alignment constraint &lt;code&gt;x&lt;/code&gt; is fulfilled by any address divisible by &lt;code&gt;x&lt;/code&gt;. This operation is idempotent.</source>
          <target state="translated">给定一个任意地址和一个对齐约束， &lt;code&gt;&lt;a href=&quot;ghc-ptr#v:alignPtr&quot;&gt;alignPtr&lt;/a&gt;&lt;/code&gt; 产生下一个满足对齐约束的更高地址。对齐约束 &lt;code&gt;x&lt;/code&gt; 由 &lt;code&gt;x&lt;/code&gt; 整除的任何地址都可以满足。此操作是幂等的。</target>
        </trans-unit>
        <trans-unit id="94a3648c0f213883825b8c965009fc57ba6053ee" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个Int单位的偏移量,读取一个元素。假设索引在边界内。意味着有一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="c8a17c8b3ab79de903cc8400da257eb8e7123d8d" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in Int units, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个Int单位的偏移量,写一个元素。假设索引在边界内。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="92bd8db55a8df2cebbe00df902cea1d4c45498b3" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, read an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个偏移量(机器字),读取一个元素。假设索引在边界内。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="0feba2d471191afd123d35121507798423702da8" translate="yes" xml:space="preserve">
          <source>Given an array and an offset in machine words, write an element. The index is assumed to be in bounds. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和一个偏移量,用机器字写一个元素。假设索引在边界内。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="5d1f573275c2dbc9e7b212c54458e83eb9b94330" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in Int units, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,一个Int单位的偏移量,预期的旧值和新值,如果当前值与提供的旧值匹配,则执行原子比较和交换,即写入新值。返回操作前元素的值。意味着有一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="abab7f85bdf29364faddd13dc4b78d374fc5dda4" translate="yes" xml:space="preserve">
          <source>Given an array, an offset in machine words, the expected old value, and the new value, perform an atomic compare and swap i.e. write the new value if the current value matches the provided old value. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,一个偏移量(用机器字表示),预期的旧值和新值,执行原子比较和交换,即如果当前值与提供的旧值相匹配,则写入新值。返回操作前元素的值。意味着有一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="f0a4380d626de6e7a7cb655bd3acb03a426c4955" translate="yes" xml:space="preserve">
          <source>Given an array, an offset, the expected old value, and the new value, perform an atomic compare and swap (i.e. write the new value if the current value and the old value are the same pointer). Returns 0 if the swap succeeds and 1 if it fails. Additionally, returns the element at the offset after the operation completes. This means that on a success the new value is returned, and on a failure the actual old value (not the expected one) is returned. Implies a full memory barrier. The use of a pointer equality on a lifted value makes this function harder to use correctly than &lt;code&gt;casIntArray#&lt;/code&gt;. All of the difficulties of using &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; correctly apply to &lt;code&gt;casArray#&lt;/code&gt; as well.</source>
          <target state="translated">给定一个数组，一个偏移量，预期的旧值和新值，执行原子比较和交换（即，如果当前值和旧值是相同的指针，则写入新值）。如果交换成功，则返回0；如果交换失败，则返回1。此外，在操作完成后，以偏移量返回元素。这意味着成功时将返回新值，而失败时将返回实际的旧值（而不是预期值）。表示内存已满。在提升值上使用指针相等性比 &lt;code&gt;casIntArray#&lt;/code&gt; 更加难于正确使用此函数。正确使用 &lt;code&gt;reallyUnsafePtrEquality#&lt;/code&gt; 所有困难也同样适用于 &lt;code&gt;casArray#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="146fbb7f3f09edd6ae4d6b2a239b5ce5de075b01" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(单位为Int),以及一个AND值,原子地AND元素的值。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="49755d03cb750cc282b1378fdb97b26101b9cc3a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,和偏移量(Int单位),以及一个NAND值,原子地将该值NAND到元素上。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="ea6fdeeb52e6775a8f40a257cda009b7a5a4220c" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(单位为Int),以及一个要OR的值,原子性地对元素进行OR操作。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="4777b0fe2da60d417590241fa61d0ccc6e0bb4b4" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要XOR的值,原子地对元素的值进行XOR。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="29c06c151d779aa5995efae3b3901f99e551b9c5" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要添加的值,原子地将其添加到元素中。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="20a058f6323b50073951b1b5f3f5e171eb991d2b" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in Int units, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(Int单位),以及一个要减去的值,原子地减去元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="a30e79c6cce3e1df46121660ce9f45643cc0eeab" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to AND, atomically AND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,和偏移量(用机器字表示),以及一个要AND的值,原子地AND元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="b1a9ceb938d8f49b5b2ea5c52e2126a50123f314" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to NAND, atomically NAND the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(用机器字表示),以及一个NAND值,将该值原子地NAND到元素上。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="0e005649850d5d7a3f7b482df99d3f3969f5374d" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to OR, atomically OR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,和偏移量(用机器字表示),以及一个要OR的值,原子地OR元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="71007d72dc6db74da700d9af9cc75f192be2766a" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to XOR, atomically XOR the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组,和偏移量(用机器字表示),以及一个要XOR的值,原子地对元素的值进行XOR。返回操作前元素的值。意味着一个完整的内存屏障。</target>
        </trans-unit>
        <trans-unit id="a20812dbea90228bd71715ad0ffda8d1cecc9bc0" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to add, atomically add the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(用机器字表示),以及一个要添加的值,原子地将该值添加到元素中。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="b8efe4a9e8663db39594eab24695687808cdd1d9" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically substract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(用机器字表示),以及一个要减去的值,原子地减去元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="a7a09dd75dcd4a6e149b222b65e998985f3f11b1" translate="yes" xml:space="preserve">
          <source>Given an array, and offset in machine words, and a value to subtract, atomically subtract the value to the element. Returns the value of the element before the operation. Implies a full memory barrier.</source>
          <target state="translated">给定一个数组和偏移量(用机器字表示),以及一个要减去的值,原子地减去元素的值。返回操作前元素的值。意味着一个完整的内存障碍。</target>
        </trans-unit>
        <trans-unit id="1133d340ebaabdb6f3a72cccae83fbf1b0c933cc" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">假设 &lt;code&gt;Int#&lt;/code&gt; 的类型不是 &lt;code&gt;Type&lt;/code&gt; ，则 &lt;code&gt;Maybe Int#&lt;/code&gt; 是禁止了Int＃。同样，由于类型变量倾向于是 &lt;code&gt;Type&lt;/code&gt; 类型（例如，在 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; ，所有类型变量的类型都为 &lt;code&gt;Type&lt;/code&gt; ） ，多态性倾向于不适用于原始类型。退后一步是有道理的，因为多态函数需要操纵指向其数据的指针，并且大多数基本类型都未装箱。</target>
        </trans-unit>
        <trans-unit id="b7d26f3c3355ef99d3c40e122cda9ae2f46a3685" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;lsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">假定 &lt;code&gt;Int#&lt;/code&gt; 的类型不是 &lt;code&gt;Type&lt;/code&gt; ，则 &lt;code&gt;Maybe Int#&lt;/code&gt; 是禁止了Int＃。同样，由于类型变量倾向于是 &lt;code&gt;Type&lt;/code&gt; 类型（例如，在 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; ，所有类型变量的类型都为 &lt;code&gt;Type&lt;/code&gt; ） ，多态性倾向于不适用于原始类型。退后一步是有道理的，因为多态函数需要操纵指向其数据的指针，并且大多数基本类型都未装箱。</target>
        </trans-unit>
        <trans-unit id="997d69bcb3242b4498d781fc27199701d0a45530" translate="yes" xml:space="preserve">
          <source>Given that &lt;code&gt;Int#&lt;/code&gt;&amp;rsquo;s kind is not &lt;code&gt;Type&lt;/code&gt;, it then it follows that &lt;code&gt;Maybe
Int#&lt;/code&gt; is disallowed. Similarly, because type variables tend to be of kind &lt;code&gt;Type&lt;/code&gt; (for example, in &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt;, all the type variables have kind &lt;code&gt;Type&lt;/code&gt;), polymorphism tends not to work over primitive types. Stepping back, this makes some sense, because a polymorphic function needs to manipulate the pointers to its data, and most primitive types are unboxed.</source>
          <target state="translated">假定 &lt;code&gt;Int#&lt;/code&gt; 的类型不是 &lt;code&gt;Type&lt;/code&gt; ，则 &lt;code&gt;Maybe Int#&lt;/code&gt; 是禁止了Int＃。同样，由于类型变量倾向于是 &lt;code&gt;Type&lt;/code&gt; 类型（例如，在 &lt;code&gt;(.) :: (b -&amp;gt; c) -&amp;gt; (a -&amp;gt; b) -&amp;gt; a -&amp;gt; c&lt;/code&gt; ，所有类型变量的类型都为 &lt;code&gt;Type&lt;/code&gt; ） ，多态性倾向于不适用于原始类型。退后一步是有道理的，因为多态函数需要操纵指向其数据的指针，并且大多数基本类型都未装箱。</target>
        </trans-unit>
        <trans-unit id="83affa710671002c026d340422ac4f2dacd5da78" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">鉴于此方法适用于 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ,因此如果您请求0或更少的重复，则允许失败，默认定义将这样做。</target>
        </trans-unit>
        <trans-unit id="5eaccc9b609fc135977a1c7db325f9c1b56135cd" translate="yes" xml:space="preserve">
          <source>Given that this works on a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; it is allowed to fail if you request 0 or fewer repetitions, and the default definition will do so.</source>
          <target state="translated">鉴于此方法适用于 &lt;code&gt;&lt;a href=&quot;ghc-base#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ,因此如果您请求0或更少的重复，则允许失败，默认定义将这样做。</target>
        </trans-unit>
        <trans-unit id="3f88a1db5338e0d53c15325042511dce1cff7e31" translate="yes" xml:space="preserve">
          <source>Given the dependency information that we have for &lt;code&gt;Collects&lt;/code&gt;, however, we can deduce that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be equal because they both appear as the second parameter in a &lt;code&gt;Collects&lt;/code&gt; constraint with the same first parameter &lt;code&gt;c&lt;/code&gt;. Hence we can infer a shorter and more accurate type for &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">但是，考虑到我们具有 &lt;code&gt;Collects&lt;/code&gt; 的依赖项信息，我们可以推论 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 必须相等，因为它们在具有相同第一个参数 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;Collects&lt;/code&gt; 约束中都作为第二个参数出现。因此，我们可以为 &lt;code&gt;f&lt;/code&gt; 推断一个更短，更准确的类型：</target>
        </trans-unit>
        <trans-unit id="ac01c957b2153efeefd66d648f6d151ec2182d8f" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">给定示例 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18d2d272bdc4a0484a15d052c32887610cf8fa0a" translate="yes" xml:space="preserve">
          <source>Given the example &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;/directory/file.ext&lt;/code&gt;</source>
          <target state="translated">给定示例 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#t:FilePath&quot;&gt;FilePath&lt;/a&gt;&lt;/code&gt; ： &lt;code&gt;/directory/file.ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cab47cf0c2da762f2cc7ef137cb437446a0f551" translate="yes" xml:space="preserve">
          <source>Given the functionality provided by GADTs (Generalised Algebraic Data Types), it might seem as if a definition, such as the above, should be feasible. However, type families - in contrast to GADTs - are &lt;em&gt;open;&lt;/em&gt; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct.</source>
          <target state="translated">鉴于GADT（通用代数数据类型）提供的功能，似乎上述定义似乎是可行的。但是，与GADT相反，类型族是&lt;em&gt;开放的。&lt;/em&gt;也就是说，总是可以在其他模块中添加新实例。支持跨不同数据实例的模式匹配将需要一种可扩展的案例构造形式。</target>
        </trans-unit>
        <trans-unit id="a67b69f19a4f3217074f6e6525e405d47da97d1b" translate="yes" xml:space="preserve">
          <source>Given the maximum size needed and a function to make the contents of a ByteString, createAndTrim makes the &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. The generating function is required to return the actual final size (&amp;lt;= the maximum size), and the resulting byte array is realloced to this size.</source>
          <target state="translated">给定所需的最大大小和一个用于生成ByteString内容的函数，createAndTrim生成 &lt;code&gt;&lt;a href=&quot;data-bytestring-internal#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 。需要生成函数返回实际的最终大小（&amp;lt;=最大大小），然后将结果字节数组重新分配给该大小。</target>
        </trans-unit>
        <trans-unit id="c2632edc2edf21e0a0a8e5fc487c9aa010583290" translate="yes" xml:space="preserve">
          <source>Given the name or path of an executable file, &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; searches for such a file in a list of system-defined locations, which generally includes &lt;code&gt;PATH&lt;/code&gt; and possibly more. The full path to the executable is returned if found. For example, &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; would normally give you the path to GHC.</source>
          <target state="translated">给定可执行文件的名称或路径后， &lt;code&gt;&lt;a href=&quot;system-directory#v:findExecutable&quot;&gt;findExecutable&lt;/a&gt;&lt;/code&gt; 会在系统定义的位置列表中搜索此类文件，该位置通常包括 &lt;code&gt;PATH&lt;/code&gt; 以及可能的更多内容。如果找到，则返回可执行文件的完整路径。例如， &lt;code&gt;(findExecutable &quot;ghc&quot;)&lt;/code&gt; 通常会为您提供GHC的路径。</target>
        </trans-unit>
        <trans-unit id="779a07f028388c39babdff239bfbe6bdbccb0d49" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a CNF and the address of the root object in the old address space, fix up the internal pointers inside the CNF to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized CNF. It returns the new CNF and the new adjusted root address.</source>
          <target state="translated">给定CNF的第一个块的指针和根对象在旧的地址空间中的地址,修正CNF内部的指针,使其在内存中的位置与序列化时不同。在导入一个序列化的CNF后,这个方法必须准确地被调用一次。它返回新的CNF和新的调整后的根地址。</target>
        </trans-unit>
        <trans-unit id="2966883e0811760b82984a872c8146237c738512" translate="yes" xml:space="preserve">
          <source>Given the pointer to the first block of a compact, and the address of the root object in the old address space, fix up the internal pointers inside the compact to account for a different position in memory than when it was serialized. This method must be called exactly once after importing a serialized compact, and returns the new compact and the new adjusted root address.</source>
          <target state="translated">给定一个契约的第一个块的指针,以及根对象在旧的地址空间中的地址,修正契约内部的指针,使其在内存中的位置与序列化时不同。在导入一个序列化的契约后,这个方法必须准确调用一次,并返回新的契约和新的调整后的根地址。</target>
        </trans-unit>
        <trans-unit id="137079684701bb7548bd7c488c5563dff2fd8425" translate="yes" xml:space="preserve">
          <source>Given this declaration the following are examples of well-formed and malformed types:</source>
          <target state="translated">考虑到这个声明,下面是形式良好和形式不良类型的例子。</target>
        </trans-unit>
        <trans-unit id="873940b25d330c24756f020ef03429c4416f9796" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">提供 &lt;code&gt;+RTS -?&lt;/code&gt; RTS选项选项将打印出程序中实际可用的RTS选项（具体取决于您的编译方式）。</target>
        </trans-unit>
        <trans-unit id="5f413ad57cecf7d60a42e57127f29fc85e597553" translate="yes" xml:space="preserve">
          <source>Giving a &lt;code&gt;+RTS -?&lt;/code&gt; RTS option will print out the RTS options actually available in your program (which vary, depending on how you compiled).</source>
          <target state="translated">提供 &lt;code&gt;+RTS -?&lt;/code&gt; RTS选项将打印出程序中实际可用的RTS选项（具体取决于您的编译方式）。</target>
        </trans-unit>
        <trans-unit id="be7adce77c3e4198098a2e71503600194529aaa3" translate="yes" xml:space="preserve">
          <source>Giving a RULE for a class method is a bad idea:</source>
          <target state="translated">为一个类方法提供一个rule是个坏主意。</target>
        </trans-unit>
        <trans-unit id="8d25ca6db124879efd114f19378aa116f6113a87" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">格拉斯哥Haskell是一个不断变化的系统，因此肯定会有错误。如果找到一个，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/ReportABug&quot;&gt;此Wiki页面&lt;/a&gt;以获取有关如何报告它的信息。</target>
        </trans-unit>
        <trans-unit id="9429e6f82d8b0009815227447cf86510d9540831" translate="yes" xml:space="preserve">
          <source>Glasgow Haskell is a changing system so there are sure to be bugs in it. If you find one, please see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;this wiki page&lt;/a&gt; for information on how to report it.</source>
          <target state="translated">格拉斯哥Haskell是一个不断变化的系统，因此肯定会有错误。如果找到一个，请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/report-a-bug&quot;&gt;此Wiki页面&lt;/a&gt;以获取有关如何报告它的信息。</target>
        </trans-unit>
        <trans-unit id="49faa083913d16c0e2a54c17a0448d08510853d6" translate="yes" xml:space="preserve">
          <source>Global name bound outside of the TH AST: An original name (occurrences only, not binders) Need the namespace too to be sure which thing we are naming</source>
          <target state="translated">绑定在TH AST之外的全局名。一个原始的名字(只出现,不绑定)也需要命名空间来确定我们命名的是什么东西</target>
        </trans-unit>
        <trans-unit id="01f513a4447d5115abfb616f7ec10f25746d29b6" translate="yes" xml:space="preserve">
          <source>GmpLimb</source>
          <target state="translated">GmpLimb</target>
        </trans-unit>
        <trans-unit id="aa3cc86bd45eeace37c215b8088bc77246462145" translate="yes" xml:space="preserve">
          <source>GmpLimb#</source>
          <target state="translated">GmpLimb#</target>
        </trans-unit>
        <trans-unit id="e3f4ca0fa20ec8fe55958aea64bc1f20ad3d5908" translate="yes" xml:space="preserve">
          <source>GmpSize</source>
          <target state="translated">GmpSize</target>
        </trans-unit>
        <trans-unit id="f9096f37d45d4b60dbfdaece3f6a53686498ed20" translate="yes" xml:space="preserve">
          <source>GmpSize#</source>
          <target state="translated">GmpSize#</target>
        </trans-unit>
        <trans-unit id="047ca4adf26df35e0e106b392ff26750f40b42ad" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">转到&lt;a href=&quot;http://www.haskell.org/ghc/&quot;&gt;GHC主页&lt;/a&gt;，然后单击 &amp;ldquo;下载&amp;rdquo;链接为您的平台下载GHC。</target>
        </trans-unit>
        <trans-unit id="08e8e9b3019ee086e1029ecba77f974f0254d0ac" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.haskell.org/ghc/&quot;&gt;GHC home page&lt;/a&gt; and follow the &amp;ldquo;download&amp;rdquo; link to download GHC for your platform.</source>
          <target state="translated">转到&lt;a href=&quot;https://www.haskell.org/ghc/&quot;&gt;GHC主页&lt;/a&gt;，然后单击&amp;ldquo;下载&amp;rdquo;链接以为您的平台下载GHC。</target>
        </trans-unit>
        <trans-unit id="33a4ab0ac66bca29f2e473fa3c763622fc606b83" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">除了&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;）之外，&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;扩展允许在单个模块中使用相同的字段名称声明多个数据类型。例如，它允许：</target>
        </trans-unit>
        <trans-unit id="fd8103b3ca57eba7600e389128ef13b441bfa079" translate="yes" xml:space="preserve">
          <source>Going beyond &lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;disambiguate_record_fields#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;), the &lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt;&lt;code&gt;DuplicateRecordFields&lt;/code&gt;&lt;/a&gt; extension allows multiple datatypes to be declared using the same field names in a single module. For example, it allows this:</source>
          <target state="translated">除了&lt;a href=&quot;disambiguate_record_fields#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;（请参见&lt;a href=&quot;disambiguate_record_fields#disambiguate-fields&quot;&gt;Record field disambiguation&lt;/a&gt;）之外，&lt;a href=&quot;#extension-DuplicateRecordFields&quot;&gt; &lt;code&gt;DuplicateRecordFields&lt;/code&gt; &lt;/a&gt;扩展允许在单个模块中使用相同的字段名称声明多个数据类型。例如，它允许这样做：</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="83c45b6127df9cef6499283275e95f71b0480b90" translate="yes" xml:space="preserve">
          <source>Governs the maximum size that GHC will allow a function unfolding to be. (An unfolding has a &amp;ldquo;size&amp;rdquo; that reflects the cost in terms of &amp;ldquo;code bloat&amp;rdquo; of expanding (aka inlining) that unfolding at a call site. A bigger function would be assigned a bigger cost.)</source>
          <target state="translated">控制GHC允许功能展开的最大大小。（展开的&amp;ldquo;大小&amp;rdquo;以在呼叫站点展开（又称内联）的&amp;ldquo;代码膨胀&amp;rdquo;反映了成本。较大的功能将被分配较高的成本。）</target>
        </trans-unit>
        <trans-unit id="9a7405ebcedde5be8d095a986ea8794e19ee84e2" translate="yes" xml:space="preserve">
          <source>Graph</source>
          <target state="translated">Graph</target>
        </trans-unit>
        <trans-unit id="6e7c6bbc4315ba0876f76436ec1b10c7c4900224" translate="yes" xml:space="preserve">
          <source>Graph Algorithms</source>
          <target state="translated">图形算法</target>
        </trans-unit>
        <trans-unit id="13a49a7899b38d84a4d5a0dc4d03c8c74c885e97" translate="yes" xml:space="preserve">
          <source>Graph Construction</source>
          <target state="translated">图形结构</target>
        </trans-unit>
        <trans-unit id="49a0417afd89473041a3a240cc4fdf45ab515a14" translate="yes" xml:space="preserve">
          <source>Graph Properties</source>
          <target state="translated">图形属性</target>
        </trans-unit>
        <trans-unit id="56cffb9f02e2f33c7ba6c576362663ee3a363685" translate="yes" xml:space="preserve">
          <source>Graph Transformations</source>
          <target state="translated">图形变换</target>
        </trans-unit>
        <trans-unit id="ab255c27aec8dfb7cbe347babe25d68cec1ce7a6" translate="yes" xml:space="preserve">
          <source>Graphics</source>
          <target state="translated">Graphics</target>
        </trans-unit>
        <trans-unit id="97dd933a2545d2eb99d8307684e2d9b87677156f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window</source>
          <target state="translated">Graphics.Win32.Window</target>
        </trans-unit>
        <trans-unit id="ee1004fcc1994df1683067a7bfd7341361dfb44a" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.ForegroundWindow</source>
          <target state="translated">Graphics.Win32.Window.ForegroundWindow</target>
        </trans-unit>
        <trans-unit id="d1bc1481fd09f7ee3129f3e57f9838dbb896968f" translate="yes" xml:space="preserve">
          <source>Graphics.Win32.Window.HotKey</source>
          <target state="translated">Graphics.Win32.Window.HotKey</target>
        </trans-unit>
        <trans-unit id="78399476ef1665a7b5a92cf906aaca4e5a94e9a0" translate="yes" xml:space="preserve">
          <source>Graphs</source>
          <target state="translated">Graphs</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="b48836bd60f1a3a7305ae4aec52e094503f42798" translate="yes" xml:space="preserve">
          <source>Gregorian calendar</source>
          <target state="translated">公历</target>
        </trans-unit>
        <trans-unit id="f6735a5ee92cee7bdb9905cfbf3933c275bf1379" translate="yes" xml:space="preserve">
          <source>Group has execute permission.</source>
          <target state="translated">组有执行权限。</target>
        </trans-unit>
        <trans-unit id="8475ab1269f38d6db9942d6f399693e2156d4e54" translate="yes" xml:space="preserve">
          <source>Group has read permission.</source>
          <target state="translated">组有阅读权限。</target>
        </trans-unit>
        <trans-unit id="79d8e1e9bb326b307875f64fd38768b5f6c5819e" translate="yes" xml:space="preserve">
          <source>Group has read, write and execute permission.</source>
          <target state="translated">组有读、写和执行权限。</target>
        </trans-unit>
        <trans-unit id="c53ff78e371c1a2b8d488e2fc1d060ea6dec5848" translate="yes" xml:space="preserve">
          <source>Group has write permission.</source>
          <target state="translated">组有写权限。</target>
        </trans-unit>
        <trans-unit id="2eee03f5a54518b4c420cc3f8e3597ce16394ed9" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">组语句（与&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="cac48410fc258274c557fde5ca4a451b62496d73" translate="yes" xml:space="preserve">
          <source>Group statements (as with &lt;a href=&quot;generalised_list_comprehensions#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">组语句（与&lt;a href=&quot;generalised_list_comprehensions#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="8c256d9ea28df636c9ea97e0bd7bc8b310405f3a" translate="yes" xml:space="preserve">
          <source>GroupEntry</source>
          <target state="translated">GroupEntry</target>
        </trans-unit>
        <trans-unit id="db7b9205a31d4756e235da565a7056d8dfe9976e" translate="yes" xml:space="preserve">
          <source>GroupID</source>
          <target state="translated">GroupID</target>
        </trans-unit>
        <trans-unit id="0fa12c8aef8520289b3fda84e17c7ecf08c5916b" translate="yes" xml:space="preserve">
          <source>GroupLimit</source>
          <target state="translated">GroupLimit</target>
        </trans-unit>
        <trans-unit id="6e66568583d15b8f37bae367b73bca77f4f263a2" translate="yes" xml:space="preserve">
          <source>Guard</source>
          <target state="translated">Guard</target>
        </trans-unit>
        <trans-unit id="a34b607e9430e338b04442f386b47b4fa716604d" translate="yes" xml:space="preserve">
          <source>GuardBinBox</source>
          <target state="translated">GuardBinBox</target>
        </trans-unit>
        <trans-unit id="ffe2108ae6d15e93e23a98471348ba5a1ca19ad1" translate="yes" xml:space="preserve">
          <source>GuardQ</source>
          <target state="translated">GuardQ</target>
        </trans-unit>
        <trans-unit id="9d4e8921b3246a85e29c8e15986569808f47530a" translate="yes" xml:space="preserve">
          <source>Guards against negative result values</source>
          <target state="translated">防止负结果值</target>
        </trans-unit>
        <trans-unit id="2c496671c5aeaa700e44bad718187d2166004827" translate="yes" xml:space="preserve">
          <source>Guards against null pointers</source>
          <target state="translated">防范空指针</target>
        </trans-unit>
        <trans-unit id="164f197e970b9a4693e48dec5f9fde7a61f1e29f" translate="yes" xml:space="preserve">
          <source>Guards are translated with the &lt;code&gt;guard&lt;/code&gt; function, which requires a &lt;code&gt;MonadPlus&lt;/code&gt; instance:</source>
          <target state="translated">警卫使用 &lt;code&gt;guard&lt;/code&gt; 功能翻译，该功能需要 &lt;code&gt;MonadPlus&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="e62fe40c3c7f3f2deb0de6c6043dabd4db714129" translate="yes" xml:space="preserve">
          <source>Guards for IO operations that may fail</source>
          <target state="translated">为可能失败的IO操作提供保护</target>
        </trans-unit>
        <trans-unit id="a43bb729fa241f8f31f96c2a898f1cc684df64fc" translate="yes" xml:space="preserve">
          <source>Guards:</source>
          <target state="translated">Guards:</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1903ce5d09493a6a7499083e60f2b56bf4b0c409" translate="yes" xml:space="preserve">
          <source>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, &quot;&lt;em&gt;Just Join for Parallel Ordered Sets&lt;/em&gt;&quot;, &lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https://arxiv.org/abs/1602.02120v3&lt;/a&gt;.</source>
          <target state="translated">Guy Blelloch，Daniel Ferizovic和Yihan Sun，&amp;ldquo; &lt;em&gt;只需加入并行有序集&lt;/em&gt; &amp;rdquo;，&lt;a href=&quot;https://arxiv.org/abs/1602.02120v3&quot;&gt;https：&lt;/a&gt; //arxiv.org/abs/1602.02120v3 。</target>
        </trans-unit>
        <trans-unit id="6e55b9d60fb7a6cf6f7ce67a80dbe3d9177b3561" translate="yes" xml:space="preserve">
          <source>HACKER TERRITORY. HACKER TERRITORY. (You were warned.)</source>
          <target state="translated">HACKER TERRITORY.HACKER TERRITORY.黑客栈。(你被警告。 )</target>
        </trans-unit>
        <trans-unit id="acd811416f69270a003e4a499661392fc925bc40" translate="yes" xml:space="preserve">
          <source>HALF_PTR</source>
          <target state="translated">HALF_PTR</target>
        </trans-unit>
        <trans-unit id="0b19d1e1b8a5918571f9c9d135638b9f04547d8f" translate="yes" xml:space="preserve">
          <source>HANDLE</source>
          <target state="translated">HANDLE</target>
        </trans-unit>
        <trans-unit id="6ed004a7b7a1c11f9e4775140206605dc080f051" translate="yes" xml:space="preserve">
          <source>HARDWAREINPUT</source>
          <target state="translated">HARDWAREINPUT</target>
        </trans-unit>
        <trans-unit id="f5cfba667f7d2beb3b73c3b20abeade23152bb66" translate="yes" xml:space="preserve">
          <source>HINSTANCE</source>
          <target state="translated">HINSTANCE</target>
        </trans-unit>
        <trans-unit id="8a62310d9f9283fd8fa6380ec446bd6f54f73354" translate="yes" xml:space="preserve">
          <source>HKEY</source>
          <target state="translated">HKEY</target>
        </trans-unit>
        <trans-unit id="5791388c5a16d4f31ae65db03aaa4f3178f401a8" translate="yes" xml:space="preserve">
          <source>HMODULE</source>
          <target state="translated">HMODULE</target>
        </trans-unit>
        <trans-unit id="2fcf51d2569194bb43ab5be7b0476126449060b3" translate="yes" xml:space="preserve">
          <source>HOWEVER, this is normally not what you want to do!</source>
          <target state="translated">然而,这通常不是你想做的!</target>
        </trans-unit>
        <trans-unit id="7b153a8b1b4a64b4d58ebc99748e1fdb8bb2ce66" translate="yes" xml:space="preserve">
          <source>HPC displays both kinds of information in two primary ways: textual reports with summary statistics (&lt;code&gt;hpc report&lt;/code&gt;) and sources with color mark-up (&lt;code&gt;hpc markup&lt;/code&gt;). For boolean coverage, there are four possible outcomes for each guard, condition or qualifier: both True and False values occur; only True; only False; never evaluated. In hpc-markup output, highlighting with a yellow background indicates a part of the program that was never evaluated; a green background indicates an always-True expression and a red background indicates an always-False one.</source>
          <target state="translated">HPC以两种主要方式显示两种信息：带有摘要统计信息的文本报告（ &lt;code&gt;hpc report&lt;/code&gt; ）和带有颜色标记的源（ &lt;code&gt;hpc markup&lt;/code&gt; ）。对于布尔覆盖率，每个警卫，条件或限定词都有四种可能的结果：出现True和False值；只有真；只有错误；从未评估。在hpc-markup输出中，以黄色背景突出显示表示该程序的一部分从未被评估过。绿色背景表示始终为True表达式，红色背景表示始终为False。</target>
        </trans-unit>
        <trans-unit id="47ed5ab5211983547bd7d8aabed6ed2c5abe106e" translate="yes" xml:space="preserve">
          <source>HPC does not attempt to lock the &lt;code&gt;.tix&lt;/code&gt; file, so multiple concurrently running binaries in the same directory will exhibit a race condition. At compile time, there is no way to change the name of the &lt;code&gt;.tix&lt;/code&gt; file generated; at runtime, the name of the generated &lt;code&gt;.tix&lt;/code&gt; file can be changed using &lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt;&lt;code&gt;HPCTIXFILE&lt;/code&gt;&lt;/a&gt;; the name of the &lt;code&gt;.tix&lt;/code&gt; file will also change if you rename the binary. HPC does not work with GHCi.</source>
          <target state="translated">HPC不会尝试锁定 &lt;code&gt;.tix&lt;/code&gt; 文件，因此同一目录中同时运行的多个二进制文件将显示竞争状态。在编译时，无法更改生成的 &lt;code&gt;.tix&lt;/code&gt; 文件的名称。在运行时，可以使用&lt;a href=&quot;#envvar-HPCTIXFILE&quot; id=&quot;index-10&quot;&gt; &lt;code&gt;HPCTIXFILE&lt;/code&gt; &lt;/a&gt;更改生成的 &lt;code&gt;.tix&lt;/code&gt; 文件的名称。如果重命名二进制文件，则 &lt;code&gt;.tix&lt;/code&gt; 文件的名称也将更改。HPC不适用于GHCi。</target>
        </trans-unit>
        <trans-unit id="febecd78643af3bbe821cd38f1706523b419bad4" translate="yes" xml:space="preserve">
          <source>HPC instrumentation is enabled with the &lt;a href=&quot;#ghc-flag--fhpc&quot;&gt;&lt;code&gt;-fhpc&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">HPC检测通过&lt;a href=&quot;#ghc-flag--fhpc&quot;&gt; &lt;code&gt;-fhpc&lt;/code&gt; &lt;/a&gt;标志启用：</target>
        </trans-unit>
        <trans-unit id="1ad412bd3c8b51f7888829d92fba476811cbd227" translate="yes" xml:space="preserve">
          <source>HPrintfType</source>
          <target state="translated">HPrintfType</target>
        </trans-unit>
        <trans-unit id="968ef45f0adcb52b1756f92401b8ae3c14068ab8" translate="yes" xml:space="preserve">
          <source>HRESULT</source>
          <target state="translated">HRESULT</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="24c886a7fc41f29ab0b6c49144b140aa92eedda1" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac1ac628be09ebd8c6adfbc13285eba17cc52c5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9f958a5f1fbb1d0920397e7b609d3075db90fac" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-frameset#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e7921313c83d0f9960cb8d909e3d6ec7f554cae" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="845da765199169e6dfadc88839ff4b7a816e8285" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="068b852767faab1bbf8c4dbe2494bdadf3a152aa" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-strict#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d5fa3003a8ccf9ca70c73c5cd9675cec2a1610" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a95c580c1b1d21bdccf222c58c09aa34cf85bae5" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29c2e8bc1076e2f1cd73c7f4ca38e5a05845ffbf" translate="yes" xml:space="preserve">
          <source>HTML is the class of things that can be validly put inside an HTML tag. So this can be one or more &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; elements, or a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, for example.</source>
          <target state="translated">HTML是可以有效放入HTML标记内的一类事物。因此，这可以是一个或多个 &lt;code&gt;&lt;a href=&quot;text-xhtml-transitional#t:Html&quot;&gt;Html&lt;/a&gt;&lt;/code&gt; 元素，或者是一个 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f9cd56b1730d21793c75a28009298dbbbcdaebf" translate="yes" xml:space="preserve">
          <source>HTMLTABLE</source>
          <target state="translated">HTMLTABLE</target>
        </trans-unit>
        <trans-unit id="5d9e357312135edfa3b6c194ceac1b283c40f259" translate="yes" xml:space="preserve">
          <source>HValue</source>
          <target state="translated">HValue</target>
        </trans-unit>
        <trans-unit id="2f065fef793ed1d56fb008208ad8eb240a319915" translate="yes" xml:space="preserve">
          <source>HValueRef</source>
          <target state="translated">HValueRef</target>
        </trans-unit>
        <trans-unit id="f2e94df7fe8d889e38c12294978e8d4127ac2604" translate="yes" xml:space="preserve">
          <source>Had we omitted &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt;, we would have ended up with this error:</source>
          <target state="translated">如果我们省略了 &lt;code&gt;&lt;a href=&quot;control-monad-io-class#v:liftIO&quot;&gt;liftIO&lt;/a&gt;&lt;/code&gt; ，我们将最终遇到以下错误：</target>
        </trans-unit>
        <trans-unit id="c0392b2b1c472815ba8d1a1e3b20f4a279bf6c50" translate="yes" xml:space="preserve">
          <source>Handle</source>
          <target state="translated">Handle</target>
        </trans-unit>
        <trans-unit id="393fb1d92f907d4faa4bc03c878b793a3ae03095" translate="yes" xml:space="preserve">
          <source>Handle an error.</source>
          <target state="translated">处理一个错误。</target>
        </trans-unit>
        <trans-unit id="9adc28e5d73e222c9d3f7a1f421808c2f422d355" translate="yes" xml:space="preserve">
          <source>Handle an exception.</source>
          <target state="translated">处理一个异常。</target>
        </trans-unit>
        <trans-unit id="a865e149a9130ddafd312446888b46b4743e1256" translate="yes" xml:space="preserve">
          <source>Handle operations implemented by file descriptors (FDs)</source>
          <target state="translated">处理由文件描述符(FD)实现的操作。</target>
        </trans-unit>
        <trans-unit id="e01aaadb8e09dac1ef68d5f980b78d216f59db96" translate="yes" xml:space="preserve">
          <source>Handle properties</source>
          <target state="translated">处理属性</target>
        </trans-unit>
        <trans-unit id="4e5478f1470187011e4c429f38a2f668e2221916" translate="yes" xml:space="preserve">
          <source>Handle to read from</source>
          <target state="translated">读取的手柄</target>
        </trans-unit>
        <trans-unit id="cfa84d65d44fe1cfe4fde201cc224ca2ba61ea4b" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stderr&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stderr&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stderr&lt;/code&gt; 的句柄（无=&amp;gt;使用现有的 &lt;code&gt;stderr&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0c0b0ea87bc2047414b75a0418c93c0c73335c5f" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdin&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdin&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stdin&lt;/code&gt; 的句柄（无=&amp;gt;使用现有的 &lt;code&gt;stdin&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f3660bc26cde8292b8f071aaeac565d95442b6df" translate="yes" xml:space="preserve">
          <source>Handle to use for &lt;code&gt;stdout&lt;/code&gt; (Nothing =&amp;gt; use existing &lt;code&gt;stdout&lt;/code&gt;)</source>
          <target state="translated">用于 &lt;code&gt;stdout&lt;/code&gt; 的句柄（无=&amp;gt;使用现有 &lt;code&gt;stdout&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="91dfd9b7d2ac9eea27abf91b17116f0a194d5836" translate="yes" xml:space="preserve">
          <source>Handle to write to</source>
          <target state="translated">要写给的手柄</target>
        </trans-unit>
        <trans-unit id="4fc8f4ac4ee90b96880236742e3ee6972ce929c5" translate="yes" xml:space="preserve">
          <source>HandleFinalizer</source>
          <target state="translated">HandleFinalizer</target>
        </trans-unit>
        <trans-unit id="2f9893d29577c61dae5b7756f8892a181b356a13" translate="yes" xml:space="preserve">
          <source>HandlePosition</source>
          <target state="translated">HandlePosition</target>
        </trans-unit>
        <trans-unit id="02cd2075a6637789c42ae7bd6b7089a7e6d77028" translate="yes" xml:space="preserve">
          <source>HandlePosn</source>
          <target state="translated">HandlePosn</target>
        </trans-unit>
        <trans-unit id="8669a86e97e301f504a17c89995da4d28985c624" translate="yes" xml:space="preserve">
          <source>HandleType</source>
          <target state="translated">HandleType</target>
        </trans-unit>
        <trans-unit id="4af10b83952cbc0eefb09be94c848941cb2f60f3" translate="yes" xml:space="preserve">
          <source>Handle__</source>
          <target state="translated">Handle__</target>
        </trans-unit>
        <trans-unit id="be0212bf33313087973171061ef96d564becfb55" translate="yes" xml:space="preserve">
          <source>Handler</source>
          <target state="translated">Handler</target>
        </trans-unit>
        <trans-unit id="5286415fae901d21b38c1d749f8ab46e4728bc6e" translate="yes" xml:space="preserve">
          <source>Handler to invoke if an exception is raised</source>
          <target state="translated">当发生异常时要调用的处理程序</target>
        </trans-unit>
        <trans-unit id="14535b564a9d5d580a5ef44e0cc03f73609cf431" translate="yes" xml:space="preserve">
          <source>HandlerFun</source>
          <target state="translated">HandlerFun</target>
        </trans-unit>
        <trans-unit id="fc9575096055be030a95175a15be095262410643" translate="yes" xml:space="preserve">
          <source>Handling Type-specific Modifiers</source>
          <target state="translated">处理特定类型修饰符</target>
        </trans-unit>
        <trans-unit id="3b82b9585c9008b66d22e6f407dfa6cdeb89a2db" translate="yes" xml:space="preserve">
          <source>Handling hard link using Win32 API. [NTFS only]</source>
          <target state="translated">使用Win32 API处理硬链接。[仅NTFS]</target>
        </trans-unit>
        <trans-unit id="0721f48d368df7f5160916c0069bca6f821d3701" translate="yes" xml:space="preserve">
          <source>Handling signals</source>
          <target state="translated">处理信号</target>
        </trans-unit>
        <trans-unit id="824156b97fa215b3e57f4c35b718839b27b32f4a" translate="yes" xml:space="preserve">
          <source>Handling symbolic link using Win32 API. [Vista of later and desktop app only]</source>
          <target state="translated">使用Win32 API处理符号链接。[仅适用于Vista及以后的桌面应用程序]</target>
        </trans-unit>
        <trans-unit id="89aab9f219783f5483f9c8a2f555018716574e03" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:bufferFull&quot;&gt;bufferFull&lt;/a&gt;&lt;/code&gt; 信号</target>
        </trans-unit>
        <trans-unit id="3ad2b4d3875aa4ad0be9d5cb9d1098c6ae4770cb" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:done&quot;&gt;done&lt;/a&gt;&lt;/code&gt; 信号</target>
        </trans-unit>
        <trans-unit id="993d612407c57078184116f64cae6bcafc5ebc5a" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; signal</source>
          <target state="translated">处理 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:insertChunk&quot;&gt;insertChunk&lt;/a&gt;&lt;/code&gt; 信号</target>
        </trans-unit>
        <trans-unit id="048292f565b5b22828fa076edbb58a73e8cfd5b8" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将缓冲的事件日志数据移交给事件日志编写器。自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; &lt;/a&gt;必需。</target>
        </trans-unit>
        <trans-unit id="a2180742f74260bd275e7151aa4ebb625f061aec" translate="yes" xml:space="preserve">
          <source>Hands buffered event log data to your event log writer. Return true on success. Required for a custom &lt;a href=&quot;#c.EventLogWriter&quot;&gt;&lt;code&gt;EventLogWriter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将缓冲的事件日志数据移交给事件日志编写器。成功返回true。对于自定义&lt;a href=&quot;#c.EventLogWriter&quot;&gt; &lt;code&gt;EventLogWriter&lt;/code&gt; 是&lt;/a&gt;必需的。</target>
        </trans-unit>
        <trans-unit id="3affea459771f35ab73628ef32521d013f015828" translate="yes" xml:space="preserve">
          <source>HangupOnClose</source>
          <target state="translated">HangupOnClose</target>
        </trans-unit>
        <trans-unit id="6bfec95216610c8923fdb3b58c6820e2638d7012" translate="yes" xml:space="preserve">
          <source>Hard link name</source>
          <target state="translated">硬链接名称</target>
        </trans-unit>
        <trans-unit id="151f3938abe034f9943c5ceef0c5082df3ebe59c" translate="yes" xml:space="preserve">
          <source>Hard links</source>
          <target state="translated">硬链接</target>
        </trans-unit>
        <trans-unit id="cfda26ce9011e1d31a770fb6f43ec4f97f72200e" translate="yes" xml:space="preserve">
          <source>HardwareFault</source>
          <target state="translated">HardwareFault</target>
        </trans-unit>
        <trans-unit id="a40e006669de268a9bb2acc2447224d0f6c74cbc" translate="yes" xml:space="preserve">
          <source>HasCallStack</source>
          <target state="translated">HasCallStack</target>
        </trans-unit>
        <trans-unit id="d5a8afb8c704edab0aaea5d1e5ddc323a689f7a5" translate="yes" xml:space="preserve">
          <source>HasCallStack call stacks</source>
          <target state="translated">HasCallStack呼叫堆栈</target>
        </trans-unit>
        <trans-unit id="d56fbf4c5db38163d687f59e194a828baa7c9bd2" translate="yes" xml:space="preserve">
          <source>HasField</source>
          <target state="translated">HasField</target>
        </trans-unit>
        <trans-unit id="20dd461a479f96766729c9d640324e99a0d215cb" translate="yes" xml:space="preserve">
          <source>HasJobControl</source>
          <target state="translated">HasJobControl</target>
        </trans-unit>
        <trans-unit id="4932242cd8f456e18307629642a2aa4a2f8e249e" translate="yes" xml:space="preserve">
          <source>HasResolution</source>
          <target state="translated">HasResolution</target>
        </trans-unit>
        <trans-unit id="19eda78b3bcf5dc9a7065d2ad4cee793b2e7eef4" translate="yes" xml:space="preserve">
          <source>HasSavedIDs</source>
          <target state="translated">HasSavedIDs</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="0229c5fae78a9965d4f45ca37d03dc1236ff8fa7" translate="yes" xml:space="preserve">
          <source>Hashes a &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;. Two &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt;s may hash to the same value, although in practice this is unlikely. The &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; returned makes a good hash key.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 哈希化为一个 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 。两个 &lt;code&gt;&lt;a href=&quot;data-unique#t:Unique&quot;&gt;Unique&lt;/a&gt;&lt;/code&gt; 可能会散列为相同的值，尽管实际上这不太可能。返回的 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 是一个很好的哈希键。</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="5901d3877bf9e737aa3e94d79bb4ea0286df3607" translate="yes" xml:space="preserve">
          <source>Haskeline has two ways of interacting with the user:</source>
          <target state="translated">Haskeline有两种与用户互动的方式。</target>
        </trans-unit>
        <trans-unit id="5d92a7b159921baa977febb12420c1df0529b818" translate="yes" xml:space="preserve">
          <source>Haskeline's behavior may be modified by editing your &lt;code&gt;~/.haskeline&lt;/code&gt; file. For details, see: &lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https://github.com/judah/haskeline/wiki/CustomKeyBindings&lt;/a&gt;</source>
          <target state="translated">通过编辑 &lt;code&gt;~/.haskeline&lt;/code&gt; 文件，可以修改Haskeline的行为。有关详细信息，请参见：&lt;a href=&quot;https://github.com/judah/haskeline/wiki/CustomKeyBindings&quot;&gt;https&lt;/a&gt; : //github.com/judah/haskeline/wiki/CustomKeyBindings</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="065908ba2e214305b72d700a33ff216d049eb661" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 allows for integer literals to be given in decimal, octal (prefixed by &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or hexadecimal notation (prefixed by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">Haskell 2010和Haskell 98允许以十进制，八进制（以 &lt;code&gt;0o&lt;/code&gt; 或 &lt;code&gt;0O&lt;/code&gt; 前缀）或十六进制表示法（以 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; 前缀）给出整数文字。</target>
        </trans-unit>
        <trans-unit id="6da42c988c0cf83b43592a40a36bf805281eb533" translate="yes" xml:space="preserve">
          <source>Haskell 2010 and Haskell 98 define floating literals with the syntax &lt;code&gt;1.2e6&lt;/code&gt;. These literals have the type &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt;.</source>
          <target state="translated">Haskell 2010和Haskell 98使用语法 &lt;code&gt;1.2e6&lt;/code&gt; 定义了浮动文字。这些文字的类型为 &lt;code&gt;Fractional a =&amp;gt; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0aef0b7881ddce0846355a38d3d56808bc487369" translate="yes" xml:space="preserve">
          <source>Haskell 2010 functions</source>
          <target state="translated">Haskell 2010函数</target>
        </trans-unit>
        <trans-unit id="c2dfdff50d43589a65e10f3de801e5cd1f3481ad" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add &amp;ldquo;&lt;code&gt;deriving( Eq, Ord )&lt;/code&gt;&amp;rdquo; to a data type declaration, to generate a standard instance declaration for classes specified in the &lt;code&gt;deriving&lt;/code&gt; clause. In Haskell 98, the only classes that may appear in the &lt;code&gt;deriving&lt;/code&gt; clause are the standard classes &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;.</source>
          <target state="translated">Haskell 98允许程序员将&amp;ldquo; &lt;code&gt;deriving( Eq, Ord )&lt;/code&gt; &amp;rdquo;添加到数据类型声明中，以为 &lt;code&gt;deriving&lt;/code&gt; 子句中指定的类生成标准实例声明。在Haskell 98中，可能在 &lt;code&gt;deriving&lt;/code&gt; 子句中出现的唯一类是标准类 &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Enum&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; ， &lt;code&gt;Bounded&lt;/code&gt; ， &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c13a83f3c36a18ef798acce46700a669fd2d9a2f" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows the programmer to add a deriving clause to a data type declaration, to generate a standard instance declaration for specified class. GHC extends this mechanism along several axes:</source>
          <target state="translated">Haskell 98 允许程序员在数据类型声明中添加一个派生子句,为指定的类生成一个标准的实例声明。GHC沿着几个轴线扩展了这个机制。</target>
        </trans-unit>
        <trans-unit id="9fc350c1e6daa1d0a99b5e176fd6627f03f073af" translate="yes" xml:space="preserve">
          <source>Haskell 98 allows you to define a default implementation when declaring a class:</source>
          <target state="translated">Haskell 98 允许你在声明一个类时定义一个默认实现。</target>
        </trans-unit>
        <trans-unit id="bdbe3cc69c9d59fa9c998d2ffb90eaf9b74ed7ed" translate="yes" xml:space="preserve">
          <source>Haskell 98 prohibits class method types to mention constraints on the class type variable, thus:</source>
          <target state="translated">Haskell 98禁止类方法类型提及对类类型变量的约束,因此。</target>
        </trans-unit>
        <trans-unit id="1da9fcbc717e278cc072c704bc0fb1543efb67d0" translate="yes" xml:space="preserve">
          <source>Haskell 98 regards all four as ambiguous, but with the &lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt;&lt;code&gt;DisambiguateRecordFields&lt;/code&gt;&lt;/a&gt; extension, GHC will accept the former two. The rules are precisely the same as those for instance declarations in Haskell 98, where the method names on the left-hand side of the method bindings in an instance declaration refer unambiguously to the method of that class (provided they are in scope at all), even if there are other variables in scope with the same name. This reduces the clutter of qualified names when you import two records from different modules that use the same field name.</source>
          <target state="translated">Haskell 98认为这四个都是模棱两可的，但是通过&lt;a href=&quot;#extension-DisambiguateRecordFields&quot;&gt; &lt;code&gt;DisambiguateRecordFields&lt;/code&gt; &lt;/a&gt;扩展，GHC将接受前两个。这些规则与Haskell 98中的实例声明完全相同，其中实例声明中方法绑定左侧的方法名称明确指向该类的方法（只要它们在范围内）。 ，即使作用域中还有其他具有相同名称的变量。当您从使用相同字段名称的不同模块中导入两个记录时，这可以减少限定名称的混乱情况。</target>
        </trans-unit>
        <trans-unit id="3e37b99ac7bc7b32576c5a86ef921f839207b134" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; never uses the default &quot;6-digit&quot; precision used by C printf.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 从未使用C printf使用的默认&amp;ldquo; 6位数&amp;rdquo;精度。</target>
        </trans-unit>
        <trans-unit id="803931392d9e7f7a42786baf24bd3acbb21d2297" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; prints the exponent of e-format numbers without a gratuitous plus sign, and with the minimum possible number of digits.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 可打印无格式加号且数字位数尽可能少的电子格式指数。</target>
        </trans-unit>
        <trans-unit id="5a988b88b57fc6a5015c3bdce6eced1db2e93fb3" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; treats the &quot;precision&quot; specifier as indicating the number of digits after the decimal point.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 将&amp;ldquo;精度&amp;rdquo;说明符视为指示小数点后的位数。</target>
        </trans-unit>
        <trans-unit id="de5a761278ad7995ae6ea10eb54d7d46a18911b2" translate="yes" xml:space="preserve">
          <source>Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; will place a zero after a decimal point when possible.</source>
          <target state="translated">Haskell &lt;code&gt;&lt;a href=&quot;text-printf#v:printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 将在可能的情况下在小数点后放置零。</target>
        </trans-unit>
        <trans-unit id="5db5bb3ecf93ed4bf68c234dce9b122cc069d4fc" translate="yes" xml:space="preserve">
          <source>Haskell allows datatypes to be given contexts, e.g.</source>
          <target state="translated">Haskell 允许给定数据类型的上下文,例如。</target>
        </trans-unit>
        <trans-unit id="3ba63f358f6ed0e157b0d31998c471fd73b1c809" translate="yes" xml:space="preserve">
          <source>Haskell compiler</source>
          <target state="translated">Haskell编译器</target>
        </trans-unit>
        <trans-unit id="c96570b066116767adb53a9bedbb0995cb0718ff" translate="yes" xml:space="preserve">
          <source>Haskell defines operations to read and write characters from and to files, represented by values of type &lt;code&gt;Handle&lt;/code&gt;. Each value of this type is a &lt;em&gt;handle&lt;/em&gt;: a record used by the Haskell run-time system to &lt;em&gt;manage&lt;/em&gt; I/O with file system objects. A handle has at least the following properties:</source>
          <target state="translated">Haskell定义了从文件读写字符的操作，这些操作由 &lt;code&gt;Handle&lt;/code&gt; 类型的值表示。此类型的每个值都是一个&lt;em&gt;handle&lt;/em&gt;：Haskell运行时系统用于通过文件系统对象&lt;em&gt;管理&lt;/em&gt; I / O的记录。句柄至少具有以下属性：</target>
        </trans-unit>
        <trans-unit id="57185b2c62d4c8656c31d0f4760835255a021285" translate="yes" xml:space="preserve">
          <source>Haskell expressions can be typed at the prompt:</source>
          <target state="translated">可以在提示符下输入Haskell表达式。</target>
        </trans-unit>
        <trans-unit id="36b350cda5fbb367cf839d60b51cc0cd72d5f14c" translate="yes" xml:space="preserve">
          <source>Haskell file</source>
          <target state="translated">Haskell文件</target>
        </trans-unit>
        <trans-unit id="c9588bea707a1b459133b5d157a94371293bfcc8" translate="yes" xml:space="preserve">
          <source>Haskell identifier, e.g. &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt;</source>
          <target state="translated">Haskell标识符，例如 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;Baz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8864d7903427f164a617a184e73202acec74086a" translate="yes" xml:space="preserve">
          <source>Haskell infers the kind of each type variable. Sometimes it is nice to be able to give the kind explicitly as (machine-checked) documentation, just as it is nice to give a type signature for a function. On some occasions, it is essential to do so. For example, in his paper &amp;ldquo;Restricted Data Types in Haskell&amp;rdquo; (Haskell Workshop 1999) John Hughes had to define the data type:</source>
          <target state="translated">Haskell推断每种类型变量的种类。有时候，能够以（机器检查的）文档的形式明确地提供种类，就像为函数提供类型签名一样，也很不错。在某些情况下，这样做至关重要。例如，约翰&amp;middot;休斯（John Hughes）在他的论文&amp;ldquo; Haskell中的受限数据类型&amp;rdquo;（Haskell Workshop 1999）中必须定义数据类型：</target>
        </trans-unit>
        <trans-unit id="03044d4dffb5ba6961d6c201b79e6123773d3291" translate="yes" xml:space="preserve">
          <source>Haskell lexer: returns the lexed string, rather than the lexeme</source>
          <target state="translated">Haskell lexer:返回已拼写的字符串,而不是lexeme。</target>
        </trans-unit>
        <trans-unit id="3a6fb7995adcbbff55a20ec28fb0709de06184c0" translate="yes" xml:space="preserve">
          <source>Haskell library authors have a choice. Most should just use Safe inference. Assuming you avoid any unsafe features of the language then your modules will be marked safe. Inferred vs. Explicit has the following trade-offs:</source>
          <target state="translated">Haskell库的作者有一个选择。大多数人应该只使用安全推理。假设你避免了语言的任何不安全特性,那么你的模块将被标记为安全。推断与显式有以下权衡。</target>
        </trans-unit>
        <trans-unit id="cc3010148ab07280017396fcfee70d4ee8ced651" translate="yes" xml:space="preserve">
          <source>Haskell offers a powerful type system and separation of pure and effectual functions through the &lt;code&gt;IO&lt;/code&gt; monad. However, there are several loop holes in the type system, the most obvious being the &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; function. The safe language dialect of Safe Haskell disallows the use of such functions. This can be useful restriction as it makes Haskell code easier to analyse and reason about. It also codifies the existing culture in the Haskell community of trying to avoid unsafe functions unless absolutely necessary. As such, using the safe language (through the &lt;code&gt;-XSafe&lt;/code&gt; flag) can be thought of as a way of enforcing good style, similar to the function of &lt;code&gt;-Wall&lt;/code&gt;.</source>
          <target state="translated">Haskell提供了强大的类型系统，并通过 &lt;code&gt;IO&lt;/code&gt; monad 分离了纯功能和有效功能。但是，类型系统中存在多个漏洞，最明显的是 &lt;code&gt;unsafePerformIO :: IO a -&amp;gt; a&lt;/code&gt; 函数。 Safe Haskell的安全语言方言禁止使用此类功能。这可能是有用的限制，因为它使Haskell代码更易于分析和推理。它还将Haskell社区中的现有文化编纂为试图避免不安全的功能，除非绝对必要。这样，可以将使用安全语言（通过 &lt;code&gt;-XSafe&lt;/code&gt; 标志）视为一种强制执行良好样式的方式，类似于 &lt;code&gt;-Wall&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="3bc620cd7bebfbd449c887c8393ef71a9cb0048a" translate="yes" xml:space="preserve">
          <source>Haskell provides indexable &lt;em&gt;arrays&lt;/em&gt;, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers. Functions restricted in this way can be implemented efficiently; in particular, a programmer may reasonably expect rapid access to the components. To ensure the possibility of such an implementation, arrays are treated as data, not as general functions.</source>
          <target state="translated">Haskell提供可索引&lt;em&gt;数组&lt;/em&gt;，可以将其视为函数，其域与整数的连续子集同构。这样限制的功能可以有效地实现；特别地，程序员可以合理地期望快速访问组件。为了确保实现这种可能性，将数组视为数据，而不是常规函数。</target>
        </trans-unit>
        <trans-unit id="7368b5caa5272a65112545054af26ecf77386013" translate="yes" xml:space="preserve">
          <source>Haskell representation for &lt;code&gt;errno&lt;/code&gt; values. The implementation is deliberately exposed, to allow users to add their own definitions of &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">Haskell表示 &lt;code&gt;errno&lt;/code&gt; 值。故意公开实现，以允许用户添加自己的 &lt;code&gt;&lt;a href=&quot;foreign-c-error#t:Errno&quot;&gt;Errno&lt;/a&gt;&lt;/code&gt; 值定义。</target>
        </trans-unit>
        <trans-unit id="ccc207680c476b314f16992dfd19a9a9a258a751" translate="yes" xml:space="preserve">
          <source>Haskell representations of &lt;code&gt;errno&lt;/code&gt; values</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 值的Haskell表示</target>
        </trans-unit>
        <trans-unit id="5341eea214941c8fa9b89302f00f8e694f12278b" translate="yes" xml:space="preserve">
          <source>Haskell source files may be named on the command line, and they will be loaded exactly as in interactive mode. The expression is evaluated in the context of the loaded modules.</source>
          <target state="translated">Haskell 源文件可以在命令行中命名,它们将被完全加载,就像在交互模式下一样。表达式是在加载模块的上下文中评估的。</target>
        </trans-unit>
        <trans-unit id="ae2da82a38cbe99fd9ff682badbaaec111364bd4" translate="yes" xml:space="preserve">
          <source>Haskell specifies that when compiling module &lt;code&gt;M&lt;/code&gt;, any instance declaration in any module &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; is visible. (Module &lt;code&gt;A&lt;/code&gt; is &amp;ldquo;below&amp;rdquo; &lt;code&gt;M&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is imported directly by &lt;code&gt;M&lt;/code&gt;, or if &lt;code&gt;A&lt;/code&gt; is below a module that &lt;code&gt;M&lt;/code&gt; imports directly.) In principle, GHC must therefore read the interface files of every module below &lt;code&gt;M&lt;/code&gt;, just in case they contain an instance declaration that matters to &lt;code&gt;M&lt;/code&gt;. This would be a disaster in practice, so GHC tries to be clever.</source>
          <target state="translated">Haskell指定在编译模块 &lt;code&gt;M&lt;/code&gt; 时，&amp;ldquo; &lt;code&gt;M&lt;/code&gt; 以下&amp;rdquo;任何模块中的任何实例声明都是可见的。（如果 &lt;code&gt;A&lt;/code&gt; 是由 &lt;code&gt;M&lt;/code&gt; 直接导入的，或者 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 直接导入的模块的下方，则模块 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;M&lt;/code&gt; 的 &amp;ldquo;下方&amp;rdquo; 。）原则上，GHC必须读取 &lt;code&gt;M&lt;/code&gt; 下方的每个模块的接口文件，以防它们包含对 &lt;code&gt;M&lt;/code&gt; 重要的实例声明。实际上这将是一场灾难，因此GHC会变得更加聪明。</target>
        </trans-unit>
        <trans-unit id="78504a490dcd1a405c09c255b59b6c836880bb83" translate="yes" xml:space="preserve">
          <source>Haskell symbol, e.g. &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:%&lt;/code&gt;</source>
          <target state="translated">Haskell符号，例如 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;:%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df367f209bd79c811db4b993c1f851b5f670ca59" translate="yes" xml:space="preserve">
          <source>Haskell threads and Operating System threads</source>
          <target state="translated">Haskell线程和操作系统线程。</target>
        </trans-unit>
        <trans-unit id="b5e4d1115a8c2e36e70d3db1df85b3ba04c82997" translate="yes" xml:space="preserve">
          <source>Haskell threads can communicate via &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, a kind of synchronised mutable variable (see &lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;). Several common concurrency abstractions can be built from &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s, and these are provided by the &lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; library. In GHC, threads may also communicate via exceptions.</source>
          <target state="translated">Haskell线程可以通过 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 进行通信，MVar是一种同步的可变变量（请参见&lt;a href=&quot;control-concurrent-mvar&quot;&gt;Control.Concurrent.MVar&lt;/a&gt;）。可以从 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 构建几个常见的并发抽象，而这些是由&lt;a href=&quot;control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;库提供的。在GHC中，线程也可以通过异常进行通信。</target>
        </trans-unit>
        <trans-unit id="eb1152cd8067628adcb5244f0c52d2f1ebdecd3c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;FILE&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="c52c7986de5b1f1002d0a36e02ab2dcd634cb9aa" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;FILE&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;FILE&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="419c0d47d2c63155c445b3a35a04cad638377266" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;bool&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="79c49075305812472dc2df8b13ecac0efe944296" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;bool&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;bool&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="054a037a3aeec17395419134ad5d32666e879988" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f25580ef2a6155308670fc91ba09e1731599c485" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;char&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdab6efef7ff3df329d3bbc78a8616b4cb3989a6" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;clock_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="be18749c4ec22337441649343d257d0370d5f71d" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;clock_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;clock_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e86270c6c52b37291a4f83ecf2067e3d22c57c6e" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;double&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="b2d34f9c0e00a8d1af686c82fb43c8d820dc5922" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;double&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;double&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0598f733099fb128ae47c1c3166b704c545480c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;float&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="1c49950cb050a7da15661bd7e456a284ef08804b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;float&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;float&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9783270eb36d4323f4eecfe9fe711bc1dd549c60" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;fpos_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ebe2bccc8d0a138a668828ba79fe80867499c2cf" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;fpos_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;fpos_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3828a73b928783c1ab6b138f30ed4a7fd77963fd" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;int&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="0c7bc99c01a214a0469bc841c3db1a8545153961" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;int&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3f56417f539bd18bca6bfc77eae899aa9f4a159" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;int&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ecaafcc8282e441e1b10f5ce390edc54ce196b7b" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;int&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="123f078eb33cc5f8ac71fcc1a58b2e7c9744c67a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;jmp_buf&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="9f0b2e804cd5163bf59ec18f25ed125a68b853e7" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;jmp_buf&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;jmp_buf&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a09db76fc4cf39e52e96e84ca7eceffcb2dc6cb" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long long&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="5e4fc6d51b08d08bf0bcba3ee05d06de32a72f6f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8bc0cd5923376a1c5f20498ef35d8c0014b53573" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="050743a39470101ce4c3aaee27cdf563c19fb3e4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c697d88169811a5419d372898d0902231691a627" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b7d113d99751c0327aea4d8129f5aed9f4e0a54" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e280e77ea88a2a6aea1fcccbe66210a18677d7c4" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;ptrdiff_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="dbd3c68fb579759e59f8406834e1d8e6ff601638" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;ptrdiff_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;ptrdiff_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c33de586ddf7a29484efc41926b3029b29a9d4f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;short&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="5b8524f5a4f304e126b6b8a367dfaecb35880702" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;short&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6814ce0babdcf6409207c9d5c62a5d21549d670" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;sig_atomic_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="f3fa5599c0fc034cd4f240400ef25ab1428a1102" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;sig_atomic_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;sig_atomic_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc79efb4536a8d15f8e47bcacf02aad5c789afda" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;signed char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="81af0438927840f3b83280a00faeb91e716cbe5a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;signed char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;signed char&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1e53c7ba3862ff8361e9698b99ceeef6ee695ac" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;size_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="178d1b8d5a62b7a3369b736f6da7852035c7e2ba" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;size_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;size_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34b7b2f84ee34dce910b692ae6d7694070d1eec8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;suseconds_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="fe2ceebfe4035ae5db79a948b4348c1b6a632760" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;suseconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;suseconds_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da77000fdb42bf1ac5567a3f5f38306a7b9ce31a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;time_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="47fddfc3c7f8cfce68e214eb884c6dbf75a02426" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;time_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d3fb605ae26da7c3d0a135bfcd2f78e6e2034da" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;time_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13ec168e35067e10a3716ba2d1e66444d65a0d79" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;time_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;time_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51aa5d4ba2ad63bf1d5b193a1d5d1d64e9d7c6d8" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;unsigned char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="ba250403e40dc5a5fe395ae550e60698ea8a63db" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;unsigned char&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9eb8343caaab2beb4ac0d546b8d967b0cf6d7e9" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;unsigned char&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba16416656c8c1c9c85455bf689f834b7cb3e7a3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned char&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型代表C &lt;code&gt;unsigned char&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa56d97929c4f9c0dd6851175b77e5a237a45c9f" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned int&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="61828b7780ff4e1e0e7f03ddf27e366de45f4b08" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned int&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned int&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7478eb320307f22ab3f106029e32684ea1826e3" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long long&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="180a5fcc065de54f77fac57594eab1aba819d926" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="095152341382e5cc99a0893c334b897d9021c542" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8e9fa8fbdf77f67a6bcf25da092f95906229af86" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dd0ef50fe966caf58fdafd5fd9a2a9f2c9ca774" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="388c8c93c58b5915ed0bbd05b942d6bcdbd88ea2" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned long&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned long&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="482e4215906c2a0c84b2e998c4bb04b882601162" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned short&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="0a6c68ad3241c76347c98ebc10b0631bbe19f4b1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned short&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03ce92d4eb17447ddbcf73101965e50898bc48e1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned short&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d9d916e0cff4b8f444a4bb2b23b5595b6e4e0a" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;unsigned short&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;unsigned short&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26c48c6e42125f2dcb7f39d4c8e9601abc37dca1" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;useconds_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="7b0bee0937b5c01758b70e929129631f1bb26b33" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;useconds_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;useconds_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c47e3f97a5805a43b017fd566e8e3a0455b50952" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type.</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;wchar_t&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="1342a24a0d486add6662622e572d9396963bb62c" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;wchar_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.14.1.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f93ae47678063b8a45836d467ebed96592553f99" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;wchar_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;../base-4.15.0.0/foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f95906d00942f31be1d4b6bbf300429b06aed957" translate="yes" xml:space="preserve">
          <source>Haskell type representing the C &lt;code&gt;wchar_t&lt;/code&gt; type. &lt;em&gt;(The concrete types of &lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt; are platform-specific.)&lt;/em&gt;</source>
          <target state="translated">Haskell类型表示C &lt;code&gt;wchar_t&lt;/code&gt; 类型。&lt;em&gt;（&lt;a href=&quot;foreign-c-types#platform&quot;&gt;Foreign.C.Types&lt;/a&gt;的具体类型是特定于平台的。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40d7a20dd1cef70b191b1919721181f45bec4aa1" translate="yes" xml:space="preserve">
          <source>Haskell type signatures are implicitly quantified. When the language option &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is used, the keyword &lt;code&gt;forall&lt;/code&gt; allows us to say exactly what this means. For example:</source>
          <target state="translated">Haskell类型签名被隐式量化。当使用语言选项&lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; 时&lt;/a&gt;，关键字 &lt;code&gt;forall&lt;/code&gt; 允许我们确切地说出这是什么意思。例如：</target>
        </trans-unit>
        <trans-unit id="312958a763351ecbecd34417b742da475b01a5b7" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt; (list), &lt;code&gt;ST&lt;/code&gt; (both strict and lazy versions), &lt;code&gt;IO&lt;/code&gt;, and many other monads have &lt;code&gt;MonadFix&lt;/code&gt; instances. On the negative side, the continuation monad, with the signature &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt;, does not.</source>
          <target state="translated">Haskell的 &lt;code&gt;Maybe&lt;/code&gt; ， &lt;code&gt;[]&lt;/code&gt; （列表）， &lt;code&gt;ST&lt;/code&gt; （严格和惰性版本）， &lt;code&gt;IO&lt;/code&gt; 和许多其他monad具有 &lt;code&gt;MonadFix&lt;/code&gt; 实例。在消极方面，具有签名 &lt;code&gt;(a -&amp;gt; r) -&amp;gt; r&lt;/code&gt; a- &amp;gt; r）-&amp;gt; r的延续单子不存在。</target>
        </trans-unit>
        <trans-unit id="286ac067159c9b8667979c69f2ab39f042776595" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">当指定&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;，&lt;/a&gt; Haskell的默认机制（Haskell报告，第4.3.4节）已扩展为涵盖字符串文字。特别：</target>
        </trans-unit>
        <trans-unit id="c1f77f60f386e1b60cf61287fb2f0557f2270da6" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s defaulting mechanism (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;Haskell Report, Section 4.3.4&lt;/a&gt;) is extended to cover string literals, when &lt;a href=&quot;#extension-OverloadedStrings&quot;&gt;&lt;code&gt;OverloadedStrings&lt;/code&gt;&lt;/a&gt; is specified. Specifically:</source>
          <target state="translated">当指定&lt;a href=&quot;#extension-OverloadedStrings&quot;&gt; &lt;code&gt;OverloadedStrings&lt;/code&gt; &lt;/a&gt;时&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.3.4&quot;&gt;，&lt;/a&gt; Haskell的默认机制（Haskell Report，第4.3.4节）已扩展为涵盖字符串文字。具体来说：</target>
        </trans-unit>
        <trans-unit id="5c360d83894c7aaa51597c83bb2ca4c5910f6876" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">通过&lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt;可以完全关闭Haskell的单态性限制（请参见Haskell报告的&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;4.5.5节&lt;/a&gt;）。从GHC 7.8.1开始，默认情况下，GHCi的交互选项中的同质限制已关闭（请参阅&lt;a href=&quot;ghci#ghci-interactive-options&quot;&gt;仅设置用于交互评估的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5d1fdf6d2d3b7d2e00bf3ab7baeeeb13e6c14542" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s monomorphism restriction (see &lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;Section 4.5.5&lt;/a&gt; of the Haskell Report) can be completely switched off by &lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt;&lt;code&gt;NoMonomorphismRestriction&lt;/code&gt;&lt;/a&gt;. Since GHC 7.8.1, the monomorphism restriction is switched off by default in GHCi&amp;rsquo;s interactive options (see &lt;a href=&quot;../ghci#ghci-interactive-options&quot;&gt;Setting options for interactive evaluation only&lt;/a&gt;).</source>
          <target state="translated">通过&lt;a href=&quot;#extension-NoMonomorphismRestriction&quot;&gt; &lt;code&gt;NoMonomorphismRestriction&lt;/code&gt; &lt;/a&gt;可以完全关闭Haskell的单态性限制（请参见Haskell报告的&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.5.5&quot;&gt;4.5.5节&lt;/a&gt;）。从GHC 7.8.1开始，默认情况下，GHCi的交互选项中的同态限制处于关闭状态（请参阅&lt;a href=&quot;../ghci#ghci-interactive-options&quot;&gt;仅设置用于交互评估的选项&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1a141ab08d985dedb9f98957467226e86a2237bf" translate="yes" xml:space="preserve">
          <source>Haskell&amp;rsquo;s overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance if left to linger in an inner loop. How can you squash it?</source>
          <target state="translated">Haskell的重载（使用类型类）很优雅，很整洁，等等，但是如果在内部循环中徘徊，则会降低性能。你怎么能压它？</target>
        </trans-unit>
        <trans-unit id="6dcc270971fff7841b459ba1100736aab53d82ce" translate="yes" xml:space="preserve">
          <source>Haskell2010</source>
          <target state="translated">Haskell2010</target>
        </trans-unit>
        <trans-unit id="8611224d67199ccb4a7a8d4b25bc635c1cfc3a48" translate="yes" xml:space="preserve">
          <source>Haskell98</source>
          <target state="translated">Haskell98</target>
        </trans-unit>
        <trans-unit id="b3c55f7ef7d356d7c9a7ac63331871b50a302e38" translate="yes" xml:space="preserve">
          <source>Haskellish interface to memcpy and memmove</source>
          <target state="translated">memcpy和memmove的Haskellish接口。</target>
        </trans-unit>
        <trans-unit id="b408395f7a6c9ad5cc0948fe6c746bdc2863b6c4" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate constraints in a type signature. For example</source>
          <target state="translated">让编译器警告类型签名中的重复约束。例如</target>
        </trans-unit>
        <trans-unit id="bb44315e3933ae78ec7b2d4c76e749754a530e44" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you&amp;rsquo;ve deleted (one) mention of it in the export list.</source>
          <target state="translated">让编译器警告导出列表中的重复条目。如果您维护较大的导出列表，并且想要避免在删除导出列表中的一个定义后再继续导出定义，这是有用的信息。</target>
        </trans-unit>
        <trans-unit id="fc7ae11dc5a0a8877bcb29fcbae185b9eb38ee9a" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in a type signature. In particular:</source>
          <target state="translated">让编译器警告类型签名中的冗余约束。特别是:</target>
        </trans-unit>
        <trans-unit id="83f4f4e6d95b4c6cd8400d7a4c53dd54d2cb85e3" translate="yes" xml:space="preserve">
          <source>Have the compiler warn about redundant constraints in type signatures.</source>
          <target state="translated">让编译器警告类型签名中的冗余约束。</target>
        </trans-unit>
        <trans-unit id="624af9c99c0374959007cf34d186babd80bc825f" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</source>
          <target state="translated">如果一个种类变量没有被显式量化,编译器会发出警告。例如,下面会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="ab484e4e512db8b5ca27e756ef1e8419b9d72451" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">让编译器警告是否隐式导入了Prelude。除非通过使用 &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行显式导入Prelude模块，或者禁用此隐式导入（通过&lt;a href=&quot;exts/rebindable_syntax#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; 编译指示），否则将发生这种情况。</target>
        </trans-unit>
        <trans-unit id="9ba1acc7c9ce9a9b091d8587b0cb7dcc3c4e1695" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;-XNoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">让编译器警告是否隐式导入了Prelude。除非通过使用 &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行显式导入Prelude模块，或者禁用此隐式导入（通过&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;-XNoImplicitPrelude&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; 编译指示），否则将发生这种情况。</target>
        </trans-unit>
        <trans-unit id="27968fc346539074eff95309c304b2956773d765" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an &lt;code&gt;import
... Prelude ...&lt;/code&gt; line, or this implicit import is disabled (either by &lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt;&lt;code&gt;NoImplicitPrelude&lt;/code&gt;&lt;/a&gt; or a &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; pragma).</source>
          <target state="translated">让编译器警告是否隐式导入了Prelude。除非通过使用 &lt;code&gt;import ... Prelude ...&lt;/code&gt; 行显式导入Prelude模块，或者禁用此隐式导入（通过&lt;a href=&quot;glasgow_exts#extension-NoImplicitPrelude&quot;&gt; &lt;code&gt;NoImplicitPrelude&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;LANGUAGE NoImplicitPrelude&lt;/code&gt; 编译指示），否则将发生这种情况。</target>
        </trans-unit>
        <trans-unit id="9b28e1b8588f425f51c4575626ab47cf2ecc0796" translate="yes" xml:space="preserve">
          <source>Have the compiler warn if there are tabs in your source file.</source>
          <target state="translated">如果你的源文件中有标签,让编译器发出警告。</target>
        </trans-unit>
        <trans-unit id="70054c2390d77cf46a86a1147ea85118a1ef3f99" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</source>
          <target state="translated">让编译器警告/通知你在你的源码中哪里应用了Haskell单形限制。如果默默地应用MR,可能会引起意想不到的行为,所以明确地警告正在应用MR是有帮助的。</target>
        </trans-unit>
        <trans-unit id="d2afe399bfaedad9702ee7fd70b7b7244f971386" translate="yes" xml:space="preserve">
          <source>Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the &amp;lsquo;default default&amp;rsquo; for Haskell 1.4 caused the otherwise unconstrained value &lt;code&gt;1&lt;/code&gt; to be given the type &lt;code&gt;Int&lt;/code&gt;, whereas Haskell 98 and later defaults it to &lt;code&gt;Integer&lt;/code&gt;. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</source>
          <target state="translated">让编译器警告/通知您源代码中Haskell默认类型机制在您的源代码中的插入位置。当从假定一个默认值与另一个默认值的上下文中转换代码时，这是有用的信息，例如，Haskell 1.4的&amp;ldquo;默认默认值&amp;rdquo;导致原本不受限制的值 &lt;code&gt;1&lt;/code&gt; 赋予类型 &lt;code&gt;Int&lt;/code&gt; ，而Haskell 98及更高版本将其默认为 &lt;code&gt;Integer&lt;/code&gt; 。这可能会导致性能和行为上的差异，因此，对此保持沉默是有用的。</target>
        </trans-unit>
        <trans-unit id="5498abf9bbeb2f58bbb844fe2ccb526cf856d105" translate="yes" xml:space="preserve">
          <source>Having compiled the program for profiling, you now need to run it to generate the profile. For example, a simple time profile can be generated by running the program with &lt;code&gt;+RTS -p&lt;/code&gt; (see &lt;a href=&quot;#rts-flag--p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;), which generates a file named &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; where ⟨prog⟩ is the name of your program (without the &lt;code&gt;.exe&lt;/code&gt; extension, if you are on Windows).</source>
          <target state="translated">编译好程序以进行概要分析后，您现在需要运行它来生成概要文件。例如，可以通过使用 &lt;code&gt;+RTS -p&lt;/code&gt; （请参阅&lt;a href=&quot;#rts-flag--p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt;）运行程序来生成简单的时间配置文件，该程序将生成名为 &lt;code&gt;&lt;em&gt;prog&lt;/em&gt;.prof&lt;/code&gt; 的文件，其中⟨prog⟩是程序的名称（不带 &lt;code&gt;.exe&lt;/code&gt; 扩展名，如果您使用的是Windows）。</target>
        </trans-unit>
        <trans-unit id="9c5b0196dfa158a640e0507548062ffac1c9509d" translate="yes" xml:space="preserve">
          <source>Having run the program, we can generate a textual summary of coverage:</source>
          <target state="translated">运行该程序后,我们可以生成一个覆盖范围的文字摘要。</target>
        </trans-unit>
        <trans-unit id="8e7c42bd3113b21fb94871ff334499b878d14a0e" translate="yes" xml:space="preserve">
          <source>Having said that, we &lt;em&gt;can&lt;/em&gt; document exactly what GHC does with respect to the floating point state, so that if you really need to use &lt;code&gt;fenv.h&lt;/code&gt; then you can do so with full knowledge of the pitfalls:</source>
          <target state="translated">话虽如此，我们&lt;em&gt;可以&lt;/em&gt;准确地记录GHC在浮点状态方面所做的工作，因此，如果您确实需要使用 &lt;code&gt;fenv.h&lt;/code&gt; ,则可以在充分了解陷阱的情况下进行操作：</target>
        </trans-unit>
        <trans-unit id="3bf4aec16734a9e97669c90f0df9d922bc22aee2" translate="yes" xml:space="preserve">
          <source>Head and tail of string broken at substring</source>
          <target state="translated">字符串的首尾在子串处断开</target>
        </trans-unit>
        <trans-unit id="d1d7ca754b0a092c3e57740e0999c3698d86bf13" translate="yes" xml:space="preserve">
          <source>Heap fragmentation</source>
          <target state="translated">堆的碎片化</target>
        </trans-unit>
        <trans-unit id="572f0f8bd257503295a21f9d80fde910db01c38c" translate="yes" xml:space="preserve">
          <source>HeapByCCS</source>
          <target state="translated">HeapByCCS</target>
        </trans-unit>
        <trans-unit id="8c6ad9c60a037be60f4d12e9727ec1dd6fb58d15" translate="yes" xml:space="preserve">
          <source>HeapByClosureType</source>
          <target state="translated">HeapByClosureType</target>
        </trans-unit>
        <trans-unit id="67189d744bb418e35b57f2c375c2f70ffcda9c38" translate="yes" xml:space="preserve">
          <source>HeapByDescr</source>
          <target state="translated">HeapByDescr</target>
        </trans-unit>
        <trans-unit id="ac2ddc42c46684b8a60b44d593d3341dc156883c" translate="yes" xml:space="preserve">
          <source>HeapByLDV</source>
          <target state="translated">HeapByLDV</target>
        </trans-unit>
        <trans-unit id="ab2990dbf6d95e591ed5d567962d304a62d73db5" translate="yes" xml:space="preserve">
          <source>HeapByMod</source>
          <target state="translated">HeapByMod</target>
        </trans-unit>
        <trans-unit id="c5860308e2043941209f92548c297cda091fbd26" translate="yes" xml:space="preserve">
          <source>HeapByRetainer</source>
          <target state="translated">HeapByRetainer</target>
        </trans-unit>
        <trans-unit id="449a4bf1c2c9b0156bb827447b1b70399b9a2bbe" translate="yes" xml:space="preserve">
          <source>HeapByType</source>
          <target state="translated">HeapByType</target>
        </trans-unit>
        <trans-unit id="0a4f1a75f10d18da48ca6030d1af26f2b38bc7d5" translate="yes" xml:space="preserve">
          <source>HeapOverflow</source>
          <target state="translated">HeapOverflow</target>
        </trans-unit>
        <trans-unit id="fba6d5e717ea526f849b6efdaf8193417b738a9d" translate="yes" xml:space="preserve">
          <source>Heaps</source>
          <target state="translated">Heaps</target>
        </trans-unit>
        <trans-unit id="91941c1b4095a524d9c0188d1f8462dec66fa124" translate="yes" xml:space="preserve">
          <source>Helper function for use with &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;system-win32#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-win32#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 一起使用的辅助函数。请参见 &lt;code&gt;&lt;a href=&quot;system-win32#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41f533117fa2d214d2d4af0738714b822a616f1a" translate="yes" xml:space="preserve">
          <source>Helper function for use with &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetUserDefaultLocaleName&quot;&gt;c_GetUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:c_GetSystemDefaultLocaleName&quot;&gt;c_GetSystemDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 一起使用的辅助函数。请参见 &lt;code&gt;&lt;a href=&quot;system-win32-nls#v:getUserDefaultLocaleName&quot;&gt;getUserDefaultLocaleName&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;getSystemUserDefaultLocaleName&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">辅助功能</target>
        </trans-unit>
        <trans-unit id="5b912a2c5bb90bae872b79adf45f16133c4fd255" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">帮助程序全面评估 &lt;code&gt;&lt;a href=&quot;type-reflection#t:SomeTypeRep&quot;&gt;SomeTypeRep&lt;/a&gt;&lt;/code&gt; 以用作 &lt;code&gt;NFData(rnf)&lt;/code&gt; 实现</target>
        </trans-unit>
        <trans-unit id="aa871229f3037dd5b17c54f9bd6a24abf6b10e89" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">帮助程序全面评估 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TyCon&quot;&gt;TyCon&lt;/a&gt;&lt;/code&gt; 以用作 &lt;code&gt;NFData(rnf)&lt;/code&gt; 实现</target>
        </trans-unit>
        <trans-unit id="01aa287a9e6ccd271de097c45912c21c3a884f7b" translate="yes" xml:space="preserve">
          <source>Helper to fully evaluate &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; for use as &lt;code&gt;NFData(rnf)&lt;/code&gt; implementation</source>
          <target state="translated">帮助程序全面评估 &lt;code&gt;&lt;a href=&quot;type-reflection#t:TypeRep&quot;&gt;TypeRep&lt;/a&gt;&lt;/code&gt; 以用作 &lt;code&gt;NFData(rnf)&lt;/code&gt; 实现</target>
        </trans-unit>
        <trans-unit id="42aad862bc90fff6991f6294f9c9fa7c57b05312" translate="yes" xml:space="preserve">
          <source>Helpers for &lt;code&gt;RealFloat&lt;/code&gt; type-class operations</source>
          <target state="translated">&lt;code&gt;RealFloat&lt;/code&gt; 类型类操作的助手</target>
        </trans-unit>
        <trans-unit id="96b3626fe3abd6dd061729bf2a8d1e0b63df13e7" translate="yes" xml:space="preserve">
          <source>Helpers for defining &quot;wrapper&quot; functions</source>
          <target state="translated">用于定义 &quot;包装 &quot;函数的帮助程序</target>
        </trans-unit>
        <trans-unit id="33e68482b8b4a3fe1a21b55aefcc8006aa58be9d" translate="yes" xml:space="preserve">
          <source>Hence the linearity of type constructors is invisible when &lt;code&gt;-XLinearTypes&lt;/code&gt; is off.</source>
          <target state="translated">因此，当 &lt;code&gt;-XLinearTypes&lt;/code&gt; 关闭时，类型构造函数的线性不可见。</target>
        </trans-unit>
        <trans-unit id="9b312d08020a7a266d812110fde12a2a83862f68" translate="yes" xml:space="preserve">
          <source>Hence, the original expression must have a type which is an instance of the &lt;code&gt;Show&lt;/code&gt; class, or GHCi will complain:</source>
          <target state="translated">因此，原始表达式必须具有 &lt;code&gt;Show&lt;/code&gt; 类实例的类型，否则GHCi会抱怨：</target>
        </trans-unit>
        <trans-unit id="ecbcb0e424c40d9931c2c7c8b44c33c5f4e12465" translate="yes" xml:space="preserve">
          <source>Here</source>
          <target state="translated">Here</target>
        </trans-unit>
        <trans-unit id="fbb03ee11c282574e4295542c0218f98b1aad7d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;A&lt;/code&gt; imports &lt;code&gt;B&lt;/code&gt;, but &lt;code&gt;B&lt;/code&gt; imports &lt;code&gt;A&lt;/code&gt; with a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; pragma, which breaks the circular dependency. Every loop in the module import graph must be broken by a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import; or, equivalently, the module import graph must be acyclic if &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; imports are ignored.</source>
          <target state="translated">这里 &lt;code&gt;A&lt;/code&gt; 进口 &lt;code&gt;B&lt;/code&gt; ，但 &lt;code&gt;B&lt;/code&gt; 进口 &lt;code&gt;A&lt;/code&gt; 用 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 编译，它打破了循环依赖。必须通过 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 导入来打破模块导入图中的每个循环；或者等效地，如果忽略 &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; 导入，则模块导入图必须是非循环的。</target>
        </trans-unit>
        <trans-unit id="f8399ef26432f55f6e29dace236362d3bda6f8aa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;a&lt;/code&gt; is ambiguous in the definition of &lt;code&gt;D&lt;/code&gt; but later specified to be &lt;code&gt;Int&lt;/code&gt; using type applications.</source>
          <target state="translated">此处 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;D&lt;/code&gt; 的定义中不明确，但后来使用类型应用程序指定为 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84d964c9cfca665c8adcbfb18e361180bdc190f2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are class parameters, but the type is also indexed on a third parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 是类参数，但是类型也被索引在第三个参数 &lt;code&gt;x&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="a83c105689c8fd61a7dfc1566a878cd9f0c4ca65" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;lsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;lsquo;s type), and so all is well.</source>
          <target state="translated">这里 &lt;code&gt;f1&lt;/code&gt; 不使用模式同义词。要与数字模式 &lt;code&gt;42&lt;/code&gt; 匹配，&lt;em&gt;要求&lt;/em&gt;调用者满足约束条件 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; ，因此它们以 &lt;code&gt;f1&lt;/code&gt; 的类型出现。对 &lt;code&gt;show&lt;/code&gt; 的调用生成一个 &lt;code&gt;(Show b)&lt;/code&gt; 约束，其中 &lt;code&gt;b&lt;/code&gt; 是一个存在类型变量，受 &lt;code&gt;MkT&lt;/code&gt; 上的模式匹配限制。但是相同的模式匹配也&lt;em&gt;提供&lt;/em&gt;了约束 &lt;code&gt;(Show b)&lt;/code&gt; （请参见 &lt;code&gt;MkT&lt;/code&gt; 的类型），因此一切都很好。</target>
        </trans-unit>
        <trans-unit id="4b59b8aee2721ff8de102981e018fa8f69756fd0" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f1&lt;/code&gt; does not use pattern synonyms. To match against the numeric pattern &lt;code&gt;42&lt;/code&gt;&lt;em&gt;requires&lt;/em&gt; the caller to satisfy the constraints &lt;code&gt;(Num a, Eq a)&lt;/code&gt;, so they appear in &lt;code&gt;f1&lt;/code&gt;&amp;rsquo;s type. The call to &lt;code&gt;show&lt;/code&gt; generates a &lt;code&gt;(Show b)&lt;/code&gt; constraint, where &lt;code&gt;b&lt;/code&gt; is an existentially type variable bound by the pattern match on &lt;code&gt;MkT&lt;/code&gt;. But the same pattern match also &lt;em&gt;provides&lt;/em&gt; the constraint &lt;code&gt;(Show b)&lt;/code&gt; (see &lt;code&gt;MkT&lt;/code&gt;&amp;rsquo;s type), and so all is well.</source>
          <target state="translated">在此， &lt;code&gt;f1&lt;/code&gt; 不使用模式同义词。要与数字模式 &lt;code&gt;42&lt;/code&gt; 匹配，&lt;em&gt;要求&lt;/em&gt;调用者满足约束条件 &lt;code&gt;(Num a, Eq a)&lt;/code&gt; ，因此它们以 &lt;code&gt;f1&lt;/code&gt; 的类型出现。对 &lt;code&gt;show&lt;/code&gt; 的调用会生成一个 &lt;code&gt;(Show b)&lt;/code&gt; 约束，其中 &lt;code&gt;b&lt;/code&gt; 是存在类型变量，受 &lt;code&gt;MkT&lt;/code&gt; 上的模式匹配限制。但是相同的模式匹配也&lt;em&gt;提供&lt;/em&gt;了约束 &lt;code&gt;(Show b)&lt;/code&gt; （请参见 &lt;code&gt;MkT&lt;/code&gt; 的类型），因此一切都很好。</target>
        </trans-unit>
        <trans-unit id="c6ef93a85414044a6743aade675856cb8b2404a3" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; is generalised because it has no free variables; and its binding group is unaffected by the monomorphism restriction; and hence &lt;code&gt;f&lt;/code&gt; is closed. The same reasoning applies to &lt;code&gt;g&lt;/code&gt;, except that it has one closed free variable, namely &lt;code&gt;f&lt;/code&gt;. Similarly &lt;code&gt;h&lt;/code&gt; is closed, &lt;em&gt;even though it is not bound at top level&lt;/em&gt;, because its only free variable &lt;code&gt;f&lt;/code&gt; is closed. But &lt;code&gt;k&lt;/code&gt; is not closed, because it mentions &lt;code&gt;x&lt;/code&gt; which is not closed (because it is not let-bound).</source>
          <target state="translated">这里 &lt;code&gt;f&lt;/code&gt; 是广义的，因为它没有自由变量; 其结合基不受单晶性限制的影响；因此， &lt;code&gt;f&lt;/code&gt; 是封闭的。除了 &lt;code&gt;g&lt;/code&gt; 具有一个封闭的自由变量，即 &lt;code&gt;f&lt;/code&gt; 之外，g的推理也相同。类似地， &lt;code&gt;h&lt;/code&gt; &lt;em&gt;即使没有在顶级绑定&lt;/em&gt;，&lt;em&gt;也&lt;/em&gt;被关闭，因为它唯一的自由变量 &lt;code&gt;f&lt;/code&gt; 被关闭。但是 &lt;code&gt;k&lt;/code&gt; 未封闭，因为它提到 &lt;code&gt;x&lt;/code&gt; 未封闭（因为它不是束缚的）。</target>
        </trans-unit>
        <trans-unit id="6b823e1758b1c0ce3297af5a6572a41579e18c99" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;f&lt;/code&gt; must be updating &lt;code&gt;T&lt;/code&gt; because neither &lt;code&gt;S&lt;/code&gt; nor &lt;code&gt;U&lt;/code&gt; have both fields.</source>
          <target state="translated">在此 &lt;code&gt;f&lt;/code&gt; 必须更新 &lt;code&gt;T&lt;/code&gt; ,因为 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 都没有两个字段。</target>
        </trans-unit>
        <trans-unit id="b44e1be2ff74797a08ba2e1197bb693a802bcebd" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;lsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">这里 &lt;code&gt;h&lt;/code&gt; 的类型看起来暧昧 &lt;code&gt;b&lt;/code&gt; ，但这里有一个合法的电话：</target>
        </trans-unit>
        <trans-unit id="b246caf870407f889ea8871b1250446e1716fa4c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;h&lt;/code&gt;&amp;rsquo;s type looks ambiguous in &lt;code&gt;b&lt;/code&gt;, but here&amp;rsquo;s a legal call:</source>
          <target state="translated">这里 &lt;code&gt;h&lt;/code&gt; 的类型看起来暧昧 &lt;code&gt;b&lt;/code&gt; ，但这里有一个合法的电话：</target>
        </trans-unit>
        <trans-unit id="5580273dadf2edf4e8b3e5d2e96253462581e863" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;lsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">在这里， &lt;code&gt;strange&lt;/code&gt; 的类型是模棱两可的，但是在 &lt;code&gt;foo&lt;/code&gt; 中的调用是可以的，因为它产生了一个约束 &lt;code&gt;(D Bool beta)&lt;/code&gt; ，该约束可由 &lt;code&gt;(D Bool b)&lt;/code&gt; 实例溶解。</target>
        </trans-unit>
        <trans-unit id="49cd73f3d29efb220092644a24b1f6c41bca4225" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;strange&lt;/code&gt;&amp;rsquo;s type is ambiguous, but the call in &lt;code&gt;foo&lt;/code&gt; is OK because it gives rise to a constraint &lt;code&gt;(D Bool beta)&lt;/code&gt;, which is soluble by the &lt;code&gt;(D Bool b)&lt;/code&gt; instance.</source>
          <target state="translated">在这里， &lt;code&gt;strange&lt;/code&gt; 的类型是模棱两可的，但是在 &lt;code&gt;foo&lt;/code&gt; 中的调用是可以的，因为它产生了一个约束 &lt;code&gt;(D Bool beta)&lt;/code&gt; ，该约束可由 &lt;code&gt;(D Bool b)&lt;/code&gt; 实例溶解。</target>
        </trans-unit>
        <trans-unit id="b6ba1a7dafa5579565589aa356bfba3be0d761be" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. See &lt;a href=&quot;field_selectors_and_type_applications#field-selectors-and-type-applications&quot;&gt;Field selectors and TypeApplications&lt;/a&gt; for a full description of how the types of top-level field selectors are determined.</source>
          <target state="translated">这里的 &lt;code&gt;tag&lt;/code&gt; 是一个公共字段，带有一个类型明确的选择器功能 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; 。有关如何确定顶级字段选择器的类型的完整说明，请参见&lt;a href=&quot;field_selectors_and_type_applications#field-selectors-and-type-applications&quot;&gt;字段选择器和TypeApplications&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7e74f35f734a03f3bce931bb0f5d5375f57de25" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;tag&lt;/code&gt; is a public field, with a well-typed selector function &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt;. The &lt;code&gt;self&lt;/code&gt; type is hidden from the outside; any attempt to apply &lt;code&gt;_this&lt;/code&gt;, &lt;code&gt;_inc&lt;/code&gt; or &lt;code&gt;_display&lt;/code&gt; as functions will raise a compile-time error. In other words, &lt;em&gt;GHC defines a record selector function only for fields whose type does not mention the existentially-quantified variables&lt;/em&gt;. (This example used an underscore in the fields for which record selectors will not be defined, but that is only programming style; GHC ignores them.)</source>
          <target state="translated">这里的 &lt;code&gt;tag&lt;/code&gt; 是一个公共字段，带有一个类型明确的选择器功能 &lt;code&gt;tag :: Counter a -&amp;gt; a&lt;/code&gt; 。所述 &lt;code&gt;self&lt;/code&gt; 式从外部隐藏; 任何企图申请 &lt;code&gt;_this&lt;/code&gt; ， &lt;code&gt;_inc&lt;/code&gt; 或 &lt;code&gt;_display&lt;/code&gt; 的功能将引发编译时错误。换句话说，&lt;em&gt;GHC仅针对其类型未提及存在量化变量的字段定义记录选择器函数&lt;/em&gt;。（此示例在字段中使用了下划线，但将不会为其定义记录选择器，但这只是编程风格； GHC会忽略它们。）</target>
        </trans-unit>
        <trans-unit id="de5848d57cf456303e6aaae0111187f76226179d" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; and the pattern binding &lt;code&gt;(y,z)&lt;/code&gt; remain lazy. Reason: there is no good moment to force them, until first use.</source>
          <target state="translated">在这里， &lt;code&gt;x&lt;/code&gt; 和模式绑定 &lt;code&gt;(y,z)&lt;/code&gt; 保持惰性。原因：在第一次使用之前，没有好时机强加它们。</target>
        </trans-unit>
        <trans-unit id="98c889417053878657fe2e9a8e21f6e33d087297" translate="yes" xml:space="preserve">
          <source>Here GHC has translated the expression into</source>
          <target state="translated">在这里,GHC将这一表达方式翻译为</target>
        </trans-unit>
        <trans-unit id="8aae455f693e348fa5efeaf4591aa259e2a42cf5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;../using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">在这里，GHC不会从顶级实例中求解约束 &lt;code&gt;(C c Int)&lt;/code&gt; ，因为对 &lt;code&gt;g&lt;/code&gt; 的特定调用可能会将 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 实例化为相同类型，这将允许以不同的方式求解约束。后一个限制原则上是使约束求解器完整。 （感兴趣的人们可以在 &lt;code&gt;TcInteract&lt;/code&gt; 中阅读 &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; overlay ]。）很容易避免：在类型签名中，请避免与顶级实例匹配的约束。标志&lt;a href=&quot;../using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt;警告有关此类签名的信息。</target>
        </trans-unit>
        <trans-unit id="4200822fb94b0bfc0d0b0fd94e6cf82c6d349ff5" translate="yes" xml:space="preserve">
          <source>Here GHC will not solve the constraint &lt;code&gt;(C c Int)&lt;/code&gt; from the top-level instance, because a particular call of &lt;code&gt;g&lt;/code&gt; might instantiate both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; to the same type, which would allow the constraint to be solved in a different way. This latter restriction is principally to make the constraint-solver complete. (Interested folk can read &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; in &lt;code&gt;TcInteract&lt;/code&gt;.) It is easy to avoid: in a type signature avoid a constraint that matches a top-level instance. The flag &lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt;&lt;/a&gt; warns about such signatures.</source>
          <target state="translated">在这里，GHC不会从顶级实例中求解约束 &lt;code&gt;(C c Int)&lt;/code&gt; ，因为对 &lt;code&gt;g&lt;/code&gt; 的特定调用可能会将 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 实例化为相同的类型，这将允许以不同的方式求解约束。后一个限制原则上是使约束求解器完整。（有兴趣的人们可以在 &lt;code&gt;TcInteract&lt;/code&gt; 中阅读 &lt;code&gt;Note [Instance and Given overlap]&lt;/code&gt; overlay ]。）很容易避免：在类型签名中，请避免与顶级实例匹配的约束。标志&lt;a href=&quot;using-warnings#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wsimplifiable-class-constraints&lt;/code&gt; &lt;/a&gt;警告有关此类签名的信息。</target>
        </trans-unit>
        <trans-unit id="9bff69b808219fe13e775152f4fa8840242e7911" translate="yes" xml:space="preserve">
          <source>Here again, the &lt;code&gt;unsafeCoerce HRefl&lt;/code&gt; is safe, because the two types really are the same -- but the proof of that relies on the complex, trusted implementation of &lt;code&gt;Typeable&lt;/code&gt;.</source>
          <target state="translated">再说一遍， &lt;code&gt;unsafeCoerce HRefl&lt;/code&gt; 是安全的，因为这两种类型实际上是相同的-但证明依赖于 &lt;code&gt;Typeable&lt;/code&gt; 的复杂，受信任的实现。</target>
        </trans-unit>
        <trans-unit id="c0cb08091788d9276ad005df64a62df2471916ac" translate="yes" xml:space="preserve">
          <source>Here are a few examples of using the &lt;code&gt;filepath&lt;/code&gt; functions together:</source>
          <target state="translated">这是一起使用文件 &lt;code&gt;filepath&lt;/code&gt; 功能的一些示例：</target>
        </trans-unit>
        <trans-unit id="8a79e773a9d37344cccecd1e6b27389b6ae9d630" translate="yes" xml:space="preserve">
          <source>Here are some examples of admissible and illegal type instances:</source>
          <target state="translated">下面是一些可接受和非法类型实例的例子。</target>
        </trans-unit>
        <trans-unit id="25023bd7f5466b38299a82f7530be3c8c581e9e8" translate="yes" xml:space="preserve">
          <source>Here are some examples of how this translation works. The first expression of each sequence is Haskell source; the subsequent ones are Core.</source>
          <target state="translated">下面是一些关于这种翻译工作的例子。每个序列的第一个表达式是Haskell源码,后面的是Core。</target>
        </trans-unit>
        <trans-unit id="a53d0f1e137d9d27c69f2dc138fdd7c31d405ef3" translate="yes" xml:space="preserve">
          <source>Here are some examples of using said representation. Consider a few types of the &lt;code&gt;Type&lt;/code&gt; universe encoded like this:</source>
          <target state="translated">以下是使用上述表示形式的一些示例。考虑以下几种类型的 &lt;code&gt;Type&lt;/code&gt; Universe编码：</target>
        </trans-unit>
        <trans-unit id="1938696280e6b5bf3660612c2408006d76611c9a" translate="yes" xml:space="preserve">
          <source>Here are some examples that illustrate the property:</source>
          <target state="translated">下面是一些例子来说明这个特性。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="7e3cfeff552447efcf37ae18b5959e5301027734" translate="yes" xml:space="preserve">
          <source>Here are some export lists and their meaning:</source>
          <target state="translated">以下是一些出口清单及其意义。</target>
        </trans-unit>
        <trans-unit id="757e98b8dc27b605d3ba22a718bc090780c91f60" translate="yes" xml:space="preserve">
          <source>Here are some more details:</source>
          <target state="translated">下面是一些细节。</target>
        </trans-unit>
        <trans-unit id="fef4a6f74860fdc9aa02bdcc17602e952e06fa44" translate="yes" xml:space="preserve">
          <source>Here are some other important points in using the recursive-do notation:</source>
          <target state="translated">下面是使用递归do符号的其他一些重要要点。</target>
        </trans-unit>
        <trans-unit id="7acccdf9bd48aabe31c92ed0d7e8b5709c940249" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code for &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Foldable&lt;/code&gt;:</source>
          <target state="translated">这是为 &lt;code&gt;Functor&lt;/code&gt; 和 &lt;code&gt;Foldable&lt;/code&gt; 生成的代码之间的区别：</target>
        </trans-unit>
        <trans-unit id="17ba5c6ad5fee6c15536c72e587bdaba386e2b34" translate="yes" xml:space="preserve">
          <source>Here are the differences between the generated code in each extension:</source>
          <target state="translated">以下是各扩展中生成代码的差异。</target>
        </trans-unit>
        <trans-unit id="75d0fd5666cf351f1559a1cb0f0f5ec8ec9e925e" translate="yes" xml:space="preserve">
          <source>Here are the key definitions, all available from &lt;code&gt;GHC.Exts&lt;/code&gt;:</source>
          <target state="translated">以下是关键定义，所有这些定义都可以从 &lt;code&gt;GHC.Exts&lt;/code&gt; 获得：</target>
        </trans-unit>
        <trans-unit id="06158caf9a087d2325d1d35545027e3560435152" translate="yes" xml:space="preserve">
          <source>Here are the salient features</source>
          <target state="translated">以下是突出的特点</target>
        </trans-unit>
        <trans-unit id="5858cb273a5f386866d01967e86562b0221422f8" translate="yes" xml:space="preserve">
          <source>Here follow the properties:</source>
          <target state="translated">这里按照属性。</target>
        </trans-unit>
        <trans-unit id="06ba49b7a3494e39c5e9ac6930fb642d56cb237a" translate="yes" xml:space="preserve">
          <source>Here is a brief description of the syntax of this file:</source>
          <target state="translated">下面简单介绍一下这个文件的语法。</target>
        </trans-unit>
        <trans-unit id="5105a9eca2c2d760c9113cca77cea941a304a915" translate="yes" xml:space="preserve">
          <source>Here is a recursive case</source>
          <target state="translated">下面是一个递归的案例</target>
        </trans-unit>
        <trans-unit id="18950c0f655cc85f7d1a80526879f141a4d6d368" translate="yes" xml:space="preserve">
          <source>Here is a reduced representation for &lt;code&gt;Tree&lt;/code&gt; with nearly all meta-information removed, for now keeping only the most essential aspects:</source>
          <target state="translated">这是 &lt;code&gt;Tree&lt;/code&gt; 的简化表示，几乎删除了所有元信息，现在仅保留最重要的方面：</target>
        </trans-unit>
        <trans-unit id="28fb01aed2be37a9164cef272d31b4a46e6c1038" translate="yes" xml:space="preserve">
          <source>Here is a simple (albeit contrived) example:</source>
          <target state="translated">下面是一个简单的(虽然是人为的)例子。</target>
        </trans-unit>
        <trans-unit id="d4e51f8f8c6252d41c390512eb60cd71252079ee" translate="yes" xml:space="preserve">
          <source>Here is a simple non-recursive case:</source>
          <target state="translated">这里是一个简单的非递归案例。</target>
        </trans-unit>
        <trans-unit id="f5d55f3cbfa08c1d6611de1d00732137a0861eda" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;mdo&lt;/code&gt;-expression, and its translation to &lt;code&gt;rec&lt;/code&gt; blocks:</source>
          <target state="translated">这是 &lt;code&gt;mdo&lt;/code&gt; -expression 的示例，并将其转换为 &lt;code&gt;rec&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="0b2a7e6f45cd62f2ccce2503e6f62a2ed13efd54" translate="yes" xml:space="preserve">
          <source>Here is an example of a constrained kind:</source>
          <target state="translated">这里是一个约束类的例子。</target>
        </trans-unit>
        <trans-unit id="2a3922bbc09781ebd37624e0cd064a9ad42e44e9" translate="yes" xml:space="preserve">
          <source>Here is an example of a program with a couple of SCCs:</source>
          <target state="translated">下面是一个有几个SCC的程序的例子。</target>
        </trans-unit>
        <trans-unit id="afe44385b028eb6afad10373c4fd9bacc89b3246" translate="yes" xml:space="preserve">
          <source>Here is an example of how one can derive &lt;code&gt;Lift&lt;/code&gt;:</source>
          <target state="translated">这是一个如何推导 &lt;code&gt;Lift&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="c1c0fbe0a0af6bebfb37d12467531a81c8a76ffa" translate="yes" xml:space="preserve">
          <source>Here is an example of this in action:</source>
          <target state="translated">下面是一个实际的例子。</target>
        </trans-unit>
        <trans-unit id="5870318040b4cbc35ef0a6a189cf2b6b2009b5dc" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level numeric literals to provide a safe interface to a low-level function:</source>
          <target state="translated">这里是一个使用类型级数字字元为一个低级函数提供安全接口的例子。</target>
        </trans-unit>
        <trans-unit id="cae619abf546c35dc2c1fbfcf0f55d35804f8535" translate="yes" xml:space="preserve">
          <source>Here is an example of using type-level string literals to simulate simple record operations:</source>
          <target state="translated">这里是一个使用类型级字符串字元来模拟简单记录操作的例子。</target>
        </trans-unit>
        <trans-unit id="0ff9206b7ffb5ba70efe3f04ba78d877b18348c4" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; data type with the &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">这是一个示例，演示了如何将自定义 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:Error&quot;&gt;Error&lt;/a&gt;&lt;/code&gt; 数据类型与 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-monad-error#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 和catchError异常机制 &lt;code&gt;&lt;a href=&quot;control-monad-error#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 。如果用户输入一个空字符串或超过5个字符的字符串，该示例将引发异常。否则，它将打印字符串的长度。</target>
        </trans-unit>
        <trans-unit id="43b381c025413f1d67c38ee5f2502e185d0fb7d3" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates the use of a custom error data type with the &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; exception mechanism from &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt;. The example throws an exception if the user enters an empty string or a string longer than 5 characters. Otherwise it prints length of the string.</source>
          <target state="translated">这是一个示例，演示了如何将自定义错误数据类型与 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:catchError&quot;&gt;catchError&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;control-monad-except#v:throwError&quot;&gt;throwError&lt;/a&gt;&lt;/code&gt; 和catchError异常机制 &lt;code&gt;&lt;a href=&quot;control-monad-except#t:MonadError&quot;&gt;MonadError&lt;/a&gt;&lt;/code&gt; 。如果用户输入一个空字符串或超过5个字符的字符串，该示例将引发异常。否则，它将打印字符串的长度。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="535dae368fdcd63238ee3ab417dc08f09f956a7e" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">这是&lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals中&lt;/a&gt;记录访问示例的扩展，其中显示了如何将重载标签用作记录选择器：</target>
        </trans-unit>
        <trans-unit id="b0f4ccad59f2861039a9d7d73c030287198bf734" translate="yes" xml:space="preserve">
          <source>Here is an extension of the record access example in &lt;a href=&quot;type_literals#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt; showing how an overloaded label can be used as a record selector:</source>
          <target state="translated">这是&lt;a href=&quot;type_literals#type-level-literals&quot;&gt;Type-Level Literals中&lt;/a&gt;记录访问示例的扩展，显示了如何将重载标签用作记录选择器：</target>
        </trans-unit>
        <trans-unit id="784d5081f398d0ca7b17da03a0bb36a22a2ccb4a" translate="yes" xml:space="preserve">
          <source>Here is what this example does:</source>
          <target state="translated">下面是这个例子的作用。</target>
        </trans-unit>
        <trans-unit id="578112844f2ecfeb7d7b37c0671697fae621d8a3" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;Eq [a]&lt;/code&gt; in the signature overlaps with the top-level instance for &lt;code&gt;Eq [a]&lt;/code&gt;. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble &lt;code&gt;Eq a&lt;/code&gt; constraint. Best avoided by instead writing:</source>
          <target state="translated">在这里， &lt;code&gt;Eq [a]&lt;/code&gt; 与用于顶层实例的签名重叠 &lt;code&gt;Eq [a]&lt;/code&gt; 。GHC努力使用前者，但如果应使用后者，则它将具有不可溶的 &lt;code&gt;Eq a&lt;/code&gt; 约束。最好通过写以下代码来避免：</target>
        </trans-unit>
        <trans-unit id="c371834414978339130daf2ead6f2a828c5e1113" translate="yes" xml:space="preserve">
          <source>Here the call to &lt;code&gt;(==)&lt;/code&gt; makes GHC think that the &lt;code&gt;(Eq a)&lt;/code&gt; constraint is needed, so no warning is issued.</source>
          <target state="translated">在此，对 &lt;code&gt;(==)&lt;/code&gt; 的调用使GHC认为需要 &lt;code&gt;(Eq a)&lt;/code&gt; 约束，因此不会发出警告。</target>
        </trans-unit>
        <trans-unit id="0780d7d3b68e7e37a7a3d46a9b887e1652449c4c" translate="yes" xml:space="preserve">
          <source>Here the definition of &lt;code&gt;id&lt;/code&gt; will be rejected because type variable &lt;code&gt;t&lt;/code&gt; appears only under type family applications and is thus ambiguous. But this code will be accepted if we tell GHC that &lt;code&gt;Id&lt;/code&gt; is injective, which means it will be possible to infer &lt;code&gt;t&lt;/code&gt; at call sites from the type of the argument:</source>
          <target state="translated">在这里， &lt;code&gt;id&lt;/code&gt; 的定义将被拒绝，因为类型变量 &lt;code&gt;t&lt;/code&gt; 仅在类型族应用程序下出现，因此模棱两可。但是，如果我们告诉GHC该 &lt;code&gt;Id&lt;/code&gt; 是内射性的，则该代码将被接受，这意味着可以根据参数的类型在调用位置推断 &lt;code&gt;t&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb28975e9efa83a5c3e0e5ff9c5c0721160939d1" translate="yes" xml:space="preserve">
          <source>Here the signature in the instance declaration is more polymorphic than that required by the instantiated class method.</source>
          <target state="translated">这里实例声明中的签名比实例化类方法所要求的签名更加多态。</target>
        </trans-unit>
        <trans-unit id="a63289520236e8e709917ef260fdeb154c06ebad" translate="yes" xml:space="preserve">
          <source>Here the superclass cycle does terminate but it&amp;rsquo;s not entirely straightforward to see that it does.</source>
          <target state="translated">在这里，超类循环确实终止了，但要观察它确实并非完全简单。</target>
        </trans-unit>
        <trans-unit id="4b4dc560bdf4032142e8540022e116649150a8cf" translate="yes" xml:space="preserve">
          <source>Here the type signature on the expression can be pushed inwards to give a type signature for f. Similarly, and more commonly, one can give a type signature for the function itself:</source>
          <target state="translated">这里,表达式上的类型签名可以向内推,给出f的类型签名。同样,更常见的是,可以给出函数本身的类型签名。</target>
        </trans-unit>
        <trans-unit id="b36ee31bac07794278327e4cd5b5ef2a73c1d649" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">在这里，类型变量 &lt;code&gt;a&lt;/code&gt; 不会出现在任何一个构造函数的结果类型中。尽管通常用构造函数的类型来量化它，但是这样的类型变量通常被称为&amp;ldquo;存在的&amp;rdquo;。事实上，上述声明声明正是由于同一类型的 &lt;code&gt;data Foo&lt;/code&gt; 的&lt;a href=&quot;#existential-quantification&quot;&gt;存在性量化的数据构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23c5e15c682df3cf657d8a315cea937ab5938c48" translate="yes" xml:space="preserve">
          <source>Here the type variable &lt;code&gt;a&lt;/code&gt; does not appear in the result type of either constructor. Although it is universally quantified in the type of the constructor, such a type variable is often called &amp;ldquo;existential&amp;rdquo;. Indeed, the above declaration declares precisely the same type as the &lt;code&gt;data Foo&lt;/code&gt; in &lt;a href=&quot;existential_quantification#existential-quantification&quot;&gt;Existentially quantified data constructors&lt;/a&gt;.</source>
          <target state="translated">此处，类型变量 &lt;code&gt;a&lt;/code&gt; 不会出现在任一构造函数的结果类型中。尽管通常用构造函数的类型来量化它，但是这样的类型变量通常被称为&amp;ldquo;存在的&amp;rdquo;。事实上，上述声明声明正是由于同一类型的 &lt;code&gt;data Foo&lt;/code&gt; 的&lt;a href=&quot;existential_quantification#existential-quantification&quot;&gt;存在性量化的数据构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7055c1ade07b4400baffd8a9bc31bf6ec6a1358e" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on #14998.)</source>
          <target state="translated">此处，通用类型变量 &lt;code&gt;a&lt;/code&gt; 的作用域为 &lt;code&gt;P&lt;/code&gt; ，而存在性 &lt;code&gt;b&lt;/code&gt; 则不行。（请参阅有关＃14998的讨论。）</target>
        </trans-unit>
        <trans-unit id="871671537306449b461ce4b0a7359a84ae8901b9" translate="yes" xml:space="preserve">
          <source>Here the universal type variable &lt;code&gt;a&lt;/code&gt; scopes over the definition of &lt;code&gt;P&lt;/code&gt;, but the existential &lt;code&gt;b&lt;/code&gt; does not. (c.f. discussion on Trac #14998.)</source>
          <target state="translated">此处，通用类型变量 &lt;code&gt;a&lt;/code&gt; 的作用域为 &lt;code&gt;P&lt;/code&gt; ，而存在性 &lt;code&gt;b&lt;/code&gt; 则不行。（请参阅关于Trac＃14998的讨论。）</target>
        </trans-unit>
        <trans-unit id="2389ab12d149719f8b2ae9fd37c6e9f5221e6a85" translate="yes" xml:space="preserve">
          <source>Here we cannot derive the instance</source>
          <target state="translated">在这里,我们无法导出实例</target>
        </trans-unit>
        <trans-unit id="62ae36999c62764581c349a16fd30283eb606e25" translate="yes" xml:space="preserve">
          <source>Here we do not need to give a type signature to &lt;code&gt;w&lt;/code&gt;, because it is an argument of constructor &lt;code&gt;T1&lt;/code&gt; and that tells GHC all it needs to know.</source>
          <target state="translated">在这里，我们不需要为 &lt;code&gt;w&lt;/code&gt; 赋予类型签名，因为它是构造函数 &lt;code&gt;T1&lt;/code&gt; 的参数，它告诉GHC它需要知道的所有信息。</target>
        </trans-unit>
        <trans-unit id="ec7e465fc20c2c4537d95dc677ec8ee61bfb8cc2" translate="yes" xml:space="preserve">
          <source>Here we give two data instance declarations, one in which the last parameter is &lt;code&gt;[v]&lt;/code&gt;, and one for which it is &lt;code&gt;Int&lt;/code&gt;. Since you cannot give any &lt;em&gt;subsequent&lt;/em&gt; instances for &lt;code&gt;(GMap Flob ...)&lt;/code&gt;, this facility is most useful when the free indexed parameter is of a kind with a finite number of alternatives (unlike &lt;code&gt;Type&lt;/code&gt;).</source>
          <target state="translated">在这里，我们给出两个数据实例声明，一个声明的最后一个参数为 &lt;code&gt;[v]&lt;/code&gt; ，另一个声明为 &lt;code&gt;Int&lt;/code&gt; 。由于您不能为 &lt;code&gt;(GMap Flob ...)&lt;/code&gt; 提供任何&lt;em&gt;后续&lt;/em&gt;实例，因此当自由索引参数属于具有有限数目的替代项的 &lt;code&gt;Type&lt;/code&gt; （不同于Type）时，此功能最有用。</target>
        </trans-unit>
        <trans-unit id="3bb8ea8d6762e5ffea3bc702011bc02d989b8554" translate="yes" xml:space="preserve">
          <source>Here we have used the runtime system&amp;rsquo;s &lt;code&gt;-V0&lt;/code&gt; option to disable the RTS&amp;rsquo;s periodic timer which may interfere with our debugging session. Upon breaking into the program &lt;code&gt;gdb&lt;/code&gt; shows us a location in our source program corresponding to the current point of execution.</source>
          <target state="translated">在这里，我们使用了运行时系统的 &lt;code&gt;-V0&lt;/code&gt; 选项来禁用RTS的定期计时器，这可能会干扰我们的调试会话。进入程序后， &lt;code&gt;gdb&lt;/code&gt; 向我们显示了源程序中与当前执行点相对应的位置。</target>
        </trans-unit>
        <trans-unit id="a3afdf03ab0d6bca83111ae2999d98d94e34ee27" translate="yes" xml:space="preserve">
          <source>Here we make use of the &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; instance.</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;Monoid ((-&amp;gt;) a)&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1a886cd62bbad757f26446c67a18256a063af6b3" translate="yes" xml:space="preserve">
          <source>Here we notice the first bit of the stack trace has many unidentified stack frames at address &lt;code&gt;0x006eb0c0&lt;/code&gt;. If we ask &lt;code&gt;gdb&lt;/code&gt; about this location, we find that these frames are actually STG update closures,</source>
          <target state="translated">在这里，我们注意到堆栈跟踪的第一位在地址 &lt;code&gt;0x006eb0c0&lt;/code&gt; 处有许多未识别的堆栈帧。如果我们向 &lt;code&gt;gdb&lt;/code&gt; 询问此位置，我们会发现这些帧实际上是STG更新闭包，</target>
        </trans-unit>
        <trans-unit id="488b44824899a32a3b4c8c755fe86357e03b142e" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;calculateLength&lt;/code&gt; by making it to pass its result to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">在这里，我们通过将 &lt;code&gt;calculateLength&lt;/code&gt; 的结果传递给 &lt;code&gt;print&lt;/code&gt; 来使用它：</target>
        </trans-unit>
        <trans-unit id="05ec54bf728aec9e4101e212b40848364c009d88" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;a href=&quot;#class-default-signatures&quot;&gt;default signature&lt;/a&gt; to specify that the user does not have to provide an implementation for &lt;code&gt;put&lt;/code&gt;, as long as there is a &lt;code&gt;Generic&lt;/code&gt; instance for the type to instantiate. For the &lt;code&gt;UserTree&lt;/code&gt; type, for instance, the user can just write:</source>
          <target state="translated">在这里，我们使用&lt;a href=&quot;#class-default-signatures&quot;&gt;默认签名&lt;/a&gt;来指定用户不必为 &lt;code&gt;put&lt;/code&gt; 提供实现，只要存在要实例化类型的 &lt;code&gt;Generic&lt;/code&gt; 实例即可。例如，对于 &lt;code&gt;UserTree&lt;/code&gt; 类型，用户可以只写：</target>
        </trans-unit>
        <trans-unit id="bbee547f7180c83e7a6749bef178b8c2b89e5ea0" translate="yes" xml:space="preserve">
          <source>Here we used the &lt;code&gt;-g&lt;/code&gt; option to inform GHC that it should add debugging information in the produced binary. There are three levels of debugging output: &lt;code&gt;-g0&lt;/code&gt; (no debugging information, the default), &lt;code&gt;-g1&lt;/code&gt; (sufficient for basic backtraces), &lt;code&gt;-g2&lt;/code&gt; (or just &lt;code&gt;-g&lt;/code&gt; for short; emitting everything GHC knows). Note that this debugging information does not affect the optimizations performed by GHC.</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;-g&lt;/code&gt; 选项通知GHC它应在生成的二进制文件中添加调试信息。调试输出分为三个级别： &lt;code&gt;-g0&lt;/code&gt; （无调试信息，缺省值），- &lt;code&gt;-g1&lt;/code&gt; （足以满足基本回溯），- &lt;code&gt;-g2&lt;/code&gt; （或简称为 &lt;code&gt;-g&lt;/code&gt; ；发出GHC知道的所有信息）。请注意，此调试信息不​​会影响GHC执行的优化。</target>
        </trans-unit>
        <trans-unit id="01e42929be7de1f61c123076ae26c4541b6debae" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a command that takes an argument. It&amp;rsquo;s a re-implementation of &lt;a href=&quot;#ghci-cmd-:cd&quot;&gt;&lt;code&gt;:cd&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这是带有参数的命令的示例。这是&lt;a href=&quot;#ghci-cmd-:cd&quot;&gt; &lt;code&gt;:cd&lt;/code&gt; &lt;/a&gt;的重新实现：</target>
        </trans-unit>
        <trans-unit id="4acf1f68d1ec65b2583dd0678b0010301a2d55c6" translate="yes" xml:space="preserve">
          <source>Here's a rule of thumb for deciding which catch-style function to use:</source>
          <target state="translated">这里有一个经验法则,用来决定使用哪种捕捉式函数。</target>
        </trans-unit>
        <trans-unit id="95a4a684360c29ba16a972e43ea2e7da727acaed" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(!:)&lt;/code&gt; is a recursive function that indexes arrays of type &lt;code&gt;Arr e&lt;/code&gt;. Consider a call to &lt;code&gt;(!:)&lt;/code&gt; at type &lt;code&gt;(Int,Int)&lt;/code&gt;. The second specialisation will fire, and the specialised function will be inlined. It has two calls to &lt;code&gt;(!:)&lt;/code&gt;, both at type &lt;code&gt;Int&lt;/code&gt;. Both these calls fire the first specialisation, whose body is also inlined. The result is a type-based unrolling of the indexing function.</source>
          <target state="translated">在这里， &lt;code&gt;(!:)&lt;/code&gt; 是一个递归函数，它为 &lt;code&gt;Arr e&lt;/code&gt; 类型的数组建立索引。考虑以 &lt;code&gt;(Int,Int)&lt;/code&gt; 类型调用 &lt;code&gt;(!:)&lt;/code&gt; 。将触发第二个专业化，并将内联该专业化功能。它有两个对 &lt;code&gt;(!:)&lt;/code&gt; 的调用，都在 &lt;code&gt;Int&lt;/code&gt; 类型。这两个调用都触发了第一个专业化课程，该专业化课程的主体也内联。结果是建立基于类型的索引功能。</target>
        </trans-unit>
        <trans-unit id="2d758383a9a92043fe5183bea22cf4899f5af4a1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; packages an integer with a function &lt;code&gt;even&lt;/code&gt; that maps an integer to &lt;code&gt;Bool&lt;/code&gt;; and &lt;code&gt;MkFoo 'c'
isUpper&lt;/code&gt; packages a character with a compatible function. These two things are each of type &lt;code&gt;Foo&lt;/code&gt; and can be put in a list.</source>
          <target state="translated">在这里， &lt;code&gt;(MkFoo 3 even)&lt;/code&gt; 打包了一个整数，该函数带有一个 &lt;code&gt;even&lt;/code&gt; 将整数映射到 &lt;code&gt;Bool&lt;/code&gt; 的函数；和 &lt;code&gt;MkFoo 'c' isUpper&lt;/code&gt; 包具有兼容功能的字符。这两件事都是 &lt;code&gt;Foo&lt;/code&gt; 类型，可以放在列表中。</target>
        </trans-unit>
        <trans-unit id="5517fa5111843903c7c77f59041df2d9a2ca820f" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; is a type-level proxy that does not have any associated values.</source>
          <target state="translated">在此， &lt;code&gt;&lt;a href=&quot;ghc-generics#t:R&quot;&gt;R&lt;/a&gt;&lt;/code&gt; 是没有任何关联值的类型级别代理。</target>
        </trans-unit>
        <trans-unit id="8f15a44a2381b42f996544079219567c930d6553" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Adder&lt;/code&gt; is the name of the root module in the module tree (as mentioned above, there must be a single root module, and hence a single module tree in the DLL). Compile everything up:</source>
          <target state="translated">在这里， &lt;code&gt;Adder&lt;/code&gt; 是模块树中根模块的名称（如上所述，必须有一个根模块，因此DLL中必须有一个模块树）。编译所有内容：</target>
        </trans-unit>
        <trans-unit id="b53104e9ecb02cbdb4ecf1e67b8e325444d3f1eb" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;C&lt;/code&gt; is a superclass of &lt;code&gt;D&lt;/code&gt;, but it&amp;rsquo;s OK for a class operation &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;C&lt;/code&gt; to mention &lt;code&gt;D&lt;/code&gt;. (It would not be OK for &lt;code&gt;D&lt;/code&gt; to be a superclass of &lt;code&gt;C&lt;/code&gt;.)</source>
          <target state="translated">在这里， &lt;code&gt;C&lt;/code&gt; 是的超 &lt;code&gt;D&lt;/code&gt; ，但它是确定的一类操作 &lt;code&gt;op&lt;/code&gt; 的 &lt;code&gt;C&lt;/code&gt; 提 &lt;code&gt;D&lt;/code&gt; 。（ &lt;code&gt;D&lt;/code&gt; 不能成为 &lt;code&gt;C&lt;/code&gt; 的超类。）</target>
        </trans-unit>
        <trans-unit id="525ca7533aa751d8d94cbfeb12f8015edba62f9e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;a&lt;/code&gt; is imported, and &lt;code&gt;c&lt;/code&gt; is bound at top level, so neither contribute to the expansion of the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo;. The motivation here is that it should be easy for the reader to figure out what the &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; expands to.</source>
          <target state="translated">在这里， &lt;code&gt;a&lt;/code&gt; 被导入，而 &lt;code&gt;c&lt;/code&gt; 被绑定在顶层，因此它们都不会对&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo; 的扩展做出贡献。这里的动机是让读者容易理解&amp;ldquo; &lt;code&gt;..&lt;/code&gt; &amp;rdquo;扩展到什么。</target>
        </trans-unit>
        <trans-unit id="822db033e370efbb31959c405529a4c4c05b2667" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;g1&lt;/code&gt; are rank-1 types, and can be written in standard Haskell (e.g. &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt;). The &lt;code&gt;forall&lt;/code&gt; makes explicit the universal quantification that is implicitly added by Haskell.</source>
          <target state="translated">在这里， &lt;code&gt;f1&lt;/code&gt; 和 &lt;code&gt;g1&lt;/code&gt; 是等级1类型，可以用标准的Haskell编写（例如 &lt;code&gt;f1 :: a-&amp;gt;b-&amp;gt;a&lt;/code&gt; ）。该 &lt;code&gt;forall&lt;/code&gt; 做明确的是隐含的Haskell加入通用量化。</target>
        </trans-unit>
        <trans-unit id="d071a90d49169c0a3e8d456b4967a92a718fd1e4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f2&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt; but not in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">此处， &lt;code&gt;f2&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 中严格，但在 &lt;code&gt;y&lt;/code&gt; 中不严格。</target>
        </trans-unit>
        <trans-unit id="86a370b87ed8c118346ca1a94d53f0f726f6b04d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;f3&lt;/code&gt; and &lt;code&gt;f4&lt;/code&gt; are identical; putting a bang before a pattern that forces evaluation anyway does nothing.</source>
          <target state="translated">在此， &lt;code&gt;f3&lt;/code&gt; 和 &lt;code&gt;f4&lt;/code&gt; 相同；在仍然迫使评估的模式之前放一个爆炸没有任何作用。</target>
        </trans-unit>
        <trans-unit id="c65a0ece61fefd2d00d0da0d24e0dfd8498a8191" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;g&lt;/code&gt; 具有歧义类型，并且被拒绝，但是 &lt;code&gt;f&lt;/code&gt; 是可以的。对于结合 &lt;code&gt;?x&lt;/code&gt; 在 &lt;code&gt;f&lt;/code&gt; 的调用的位置是相当明确的，并且修复类型 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bce2925ca8d4f31f00ac8bdae65f0eb431772ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;g&lt;/code&gt; has an ambiguous type, and is rejected, but &lt;code&gt;f&lt;/code&gt; is fine. The binding for &lt;code&gt;?x&lt;/code&gt; at &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s call site is quite unambiguous, and fixes the type &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;g&lt;/code&gt; 具有歧义类型，并且被拒绝，但是 &lt;code&gt;f&lt;/code&gt; 是可以的。对于结合 &lt;code&gt;?x&lt;/code&gt; 在 &lt;code&gt;f&lt;/code&gt; 的调用的位置是相当明确的，并且修复类型 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c00320ffe8585a72819af79238d88877a38e42" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;k&lt;/code&gt; is brought into scope by &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt;.</source>
          <target state="translated">在这里，通过 &lt;code&gt;:: Maybe (Maybe k)&lt;/code&gt; 将 &lt;code&gt;k&lt;/code&gt; 纳入范围。</target>
        </trans-unit>
        <trans-unit id="2d9559bc1d51eb924585ebc31815ff13fbf5ec88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;lookup&lt;/code&gt; is declared &lt;a href=&quot;#pragma-INLINABLE&quot;&gt;&lt;code&gt;INLINABLE&lt;/code&gt;&lt;/a&gt;, but it cannot be specialised for type &lt;code&gt;T&lt;/code&gt; at its definition site, because that type does not exist yet. Instead a client module can define &lt;code&gt;T&lt;/code&gt; and then specialise &lt;code&gt;lookup&lt;/code&gt; at that type.</source>
          <target state="translated">在这里， &lt;code&gt;lookup&lt;/code&gt; 被声明为&lt;a href=&quot;#pragma-INLINABLE&quot;&gt; &lt;code&gt;INLINABLE&lt;/code&gt; &lt;/a&gt;，但是它不能在其定义站点专用于类型 &lt;code&gt;T&lt;/code&gt; ，因为该类型尚不存在。相反，客户端模块可以定义 &lt;code&gt;T&lt;/code&gt; ，然后专门针对该类型进行 &lt;code&gt;lookup&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34766b2e0766ed22f1c9cb7f203525612e940b47" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;m x&lt;/code&gt; depends on the value of &lt;code&gt;x&lt;/code&gt; produced by the first statement, so the expression cannot be translated using &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在此， &lt;code&gt;m x&lt;/code&gt; 取决于第一条语句产生的 &lt;code&gt;x&lt;/code&gt; 的值，因此无法使用 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; 转换表达式。</target>
        </trans-unit>
        <trans-unit id="34b4a2ef77ba3c50370d37583f31a5be57b46894" translate="yes" xml:space="preserve">
          <source>Here, a value of type &lt;code&gt;NumInst a&lt;/code&gt; is equivalent to an explicit &lt;code&gt;(Num a)&lt;/code&gt; dictionary.</source>
          <target state="translated">在这里，类型 &lt;code&gt;NumInst a&lt;/code&gt; 的值等效于显式 &lt;code&gt;(Num a)&lt;/code&gt; 字典。</target>
        </trans-unit>
        <trans-unit id="1fb49fc1ba82e874567baa5a0ecc23830d8c61be" translate="yes" xml:space="preserve">
          <source>Here, after GHC inlines the body of &lt;code&gt;foldl&lt;/code&gt; to a call site, it will perform call-pattern specialisation very aggressively on &lt;code&gt;foldl_loop&lt;/code&gt; due to the use of &lt;code&gt;SPEC&lt;/code&gt; in the argument of the loop body. &lt;code&gt;SPEC&lt;/code&gt; from &lt;code&gt;GHC.Types&lt;/code&gt; is specifically recognised by the compiler.</source>
          <target state="translated">在这里，在GHC将 &lt;code&gt;foldl&lt;/code&gt; 的主体内联到调用站点之后，由于在循环主体的参数中使用了 &lt;code&gt;SPEC&lt;/code&gt; ，它将在 &lt;code&gt;foldl_loop&lt;/code&gt; 上非常积极地执行调用模式专门化。来自 &lt;code&gt;GHC.Types&lt;/code&gt; 的 &lt;code&gt;SPEC&lt;/code&gt; 被编译器明确识别。</target>
        </trans-unit>
        <trans-unit id="16a46da6469aa7d877a4dc019b4026c861a1827c" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;lsquo;s kind pattern.</source>
          <target state="translated">在这里，尽管右侧 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 提到了 &lt;code&gt;a&lt;/code&gt; 不会在左侧出现的种类变量a，但这是可以接受的，因为 &lt;code&gt;a&lt;/code&gt; 被 &lt;code&gt;T&lt;/code&gt; 的种类模式&lt;em&gt;隐式&lt;/em&gt;绑定。</target>
        </trans-unit>
        <trans-unit id="3f03837283c8b527b9aef380941c96008f2bd16a" translate="yes" xml:space="preserve">
          <source>Here, although the right-hand side &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; mentions a kind variable &lt;code&gt;a&lt;/code&gt; which does not occur on the left-hand side, this is acceptable, because &lt;code&gt;a&lt;/code&gt; is &lt;em&gt;implicitly&lt;/em&gt; bound by &lt;code&gt;T&lt;/code&gt;&amp;rsquo;s kind pattern.</source>
          <target state="translated">这里，虽然右手侧 &lt;code&gt;(Nothing :: Maybe a)&lt;/code&gt; 提到一种可变 &lt;code&gt;a&lt;/code&gt; 不上左手侧发生，这是可以接受的，因为 &lt;code&gt;a&lt;/code&gt; 被&lt;em&gt;隐式地&lt;/em&gt;通过键合 &lt;code&gt;T&lt;/code&gt; 的一种模式。</target>
        </trans-unit>
        <trans-unit id="7c488bb6442c8bfe3891b456a0f20d4c493678b2" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">在这里，很明显，尝试使用类型 &lt;code&gt;T Loop&lt;/code&gt; 将把类型检查器置于无限循环中，因为其定义不断循环。在其他情况下，即使生成的代码不会将类型检查器放入循环中，您也可能需要启用&lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="3aa5a0145374631657afb97bb375856b1234f1ba" translate="yes" xml:space="preserve">
          <source>Here, it is evident that attempting to use the type &lt;code&gt;T Loop&lt;/code&gt; will throw the typechecker into an infinite loop, as its definition recurses endlessly. In other cases, you might need to enable &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; even if the generated code won&amp;rsquo;t put the typechecker into a loop. For example:</source>
          <target state="translated">在这里，很明显，尝试使用 &lt;code&gt;T Loop&lt;/code&gt; 类型会将类型检查器置于无限循环中，因为其定义会不断循环。在其他情况下，即使生成的代码不会将类型检查器放入循环中，您也可能需要启用&lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="c5c4e32b86bb284d5a60b6c3cdd6f27f34dd9bca" translate="yes" xml:space="preserve">
          <source>Here, neither &lt;code&gt;D&lt;/code&gt; nor &lt;code&gt;T&lt;/code&gt; is declared in module &lt;code&gt;Orphan&lt;/code&gt;. We call such modules &amp;ldquo;orphan modules&amp;rdquo;. GHC identifies orphan modules, and visits the interface file of every orphan module below the module being compiled. This is usually wasted work, but there is no avoiding it. You should therefore do your best to have as few orphan modules as possible.</source>
          <target state="translated">在这里， &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 都没有在 &lt;code&gt;Orphan&lt;/code&gt; 模块中声明。我们称此类模块为&amp;ldquo;孤立模块&amp;rdquo;。GHC识别孤立模块，并访问正在编译的模块下面的每个孤立模块的接口文件。这通常是浪费的工作，但无法避免。因此，您应该尽最大可能减少孤儿模块。</target>
        </trans-unit>
        <trans-unit id="8e284f329aaa0b1d6c1613a8401892863365a886" translate="yes" xml:space="preserve">
          <source>Here, only &lt;code&gt;b&lt;/code&gt; is levity polymorphic. There are no variables with a levity-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC&amp;rsquo;s &lt;code&gt;$&lt;/code&gt; operator, slightly more general than the Haskell 98 version.</source>
          <target state="translated">在此，只有 &lt;code&gt;b&lt;/code&gt; 是高度多态性。没有变量为多态性类型。代码生成器对此没有任何问题。确实，这是GHC的 &lt;code&gt;$&lt;/code&gt; 运算符的真实类型，比Haskell 98版本更通用。</target>
        </trans-unit>
        <trans-unit id="e4fa6e7e82de32b187a53fa81558ae736ecfa4c2" translate="yes" xml:space="preserve">
          <source>Here, the kind signature is hidden inside &lt;code&gt;'Just&lt;/code&gt;, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</source>
          <target state="translated">在这里，种类签名隐藏在 &lt;code&gt;'Just&lt;/code&gt; 内，并且没有最外面的种类签名。我们可以通过提供最外层的签名来解决此示例：</target>
        </trans-unit>
        <trans-unit id="a6b5d58882f8e59923897d88bfc5d873faefaaa3" translate="yes" xml:space="preserve">
          <source>Here, the pattern signatures for &lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;zs&lt;/code&gt; are fine, but the one for &lt;code&gt;v&lt;/code&gt; is not because &lt;code&gt;b&lt;/code&gt; is not in scope.</source>
          <target state="translated">此处， &lt;code&gt;ys&lt;/code&gt; 和 &lt;code&gt;zs&lt;/code&gt; 的模式签名很好，但 &lt;code&gt;v&lt;/code&gt; 的模式签名不是因为 &lt;code&gt;b&lt;/code&gt; 不在范围内。</target>
        </trans-unit>
        <trans-unit id="f4fd0ff1134c3450c4876a8a1789e7f8711d1446" translate="yes" xml:space="preserve">
          <source>Here, the pattern type signature &lt;code&gt;[t::a]&lt;/code&gt; mentions a lexical type variable that is not already in scope. Indeed, it &lt;em&gt;must not&lt;/em&gt; already be in scope, because it is bound by the pattern match. The effect is to bring it into scope, standing for the existentially-bound type variable.</source>
          <target state="translated">在此，模式类型签名 &lt;code&gt;[t::a]&lt;/code&gt; 提到了不在范围内的词法类型变量。实际上，它&lt;em&gt;一定不在&lt;/em&gt;范围内，因为它受模式匹配约束。效果是将其带入范围，代表存在绑定类型变量。</target>
        </trans-unit>
        <trans-unit id="8bdce5ce5dbc2679c8b93240f55e76cb9b685ca9" translate="yes" xml:space="preserve">
          <source>Here, the quantified constraint &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; behaves a bit like a local instance declaration, and makes the instance typeable.</source>
          <target state="translated">这里，对所有 &lt;code&gt;forall b. (Eq b) =&amp;gt; Eq (f b)&lt;/code&gt; 的量化约束。（Eq b）=&amp;gt; Eq（fb）的行为有点像本地实例声明，并使该实例可键入。</target>
        </trans-unit>
        <trans-unit id="c090bb2c03f8b4d1d81b664c6c433e2433be0999" translate="yes" xml:space="preserve">
          <source>Here, the right-hand side of the data instance mentions the type variable &lt;code&gt;d&lt;/code&gt; that does not occur in its left-hand side. We cannot admit such data instances as they would compromise type safety.</source>
          <target state="translated">在此，数据实例的右侧提到类型变量 &lt;code&gt;d&lt;/code&gt; ，它不在其左侧出现。我们不能接受此类数据实例，因为它们会损害类型安全性。</target>
        </trans-unit>
        <trans-unit id="b4418932eacd33c51523f80d662c6aae5a1a8913" translate="yes" xml:space="preserve">
          <source>Here, the type bound by &lt;code&gt;MkFoo&lt;/code&gt; &amp;ldquo;escapes&amp;rdquo;, because &lt;code&gt;a&lt;/code&gt; is the result of &lt;code&gt;f1&lt;/code&gt;. One way to see why this is wrong is to ask what type &lt;code&gt;f1&lt;/code&gt; has:</source>
          <target state="translated">在此，由 &lt;code&gt;MkFoo&lt;/code&gt; 绑定的类型&amp;ldquo;转义&amp;rdquo;，因为 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;f1&lt;/code&gt; 的结果。弄清楚为什么这是错误的一种方法是询问 &lt;code&gt;f1&lt;/code&gt; 具有什么类型：</target>
        </trans-unit>
        <trans-unit id="d4ced41f435896f3835e3f3db385a593236b5ec7" translate="yes" xml:space="preserve">
          <source>Here, the type signature &lt;code&gt;forall s. ST s Bool&lt;/code&gt; brings the type variable &lt;code&gt;s&lt;/code&gt; into scope, in the annotated expression &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt;.</source>
          <target state="translated">在这里，类型签名为 &lt;code&gt;forall s. ST s Bool&lt;/code&gt; 在带注释的表达式 &lt;code&gt;(op &amp;gt;&amp;gt;= \(x :: STRef s Int) -&amp;gt; g x)&lt;/code&gt; 中将类型变量 &lt;code&gt;s&lt;/code&gt; 纳入范围。</target>
        </trans-unit>
        <trans-unit id="1f4651a64ece58d66fdaa4f04e3c286eafc03da8" translate="yes" xml:space="preserve">
          <source>HexFloatLiterals</source>
          <target state="translated">HexFloatLiterals</target>
        </trans-unit>
        <trans-unit id="11a841be90249e5ae1849d3a9dba8043e7e8343e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="a09789d874bf0321af31ee0c488ee82ce979a4fc" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="676e2bd2392778df9648ce9b835686f2ab072c23" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="f3393a2a683412902536f7d98b83a3d288d91c93" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="accee792a95e9e1c8fe72eb8b06937ee9369fa1e" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="2f2e79d74e1610058532c363754e327e415fd68b" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="bd739f1c73011a1d448318bcfa789ba656618089" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="91d7f9927e5a55d877174d8d404732deead30952" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="807a40d7e8f0a1f48786149c90e1e7c0cd76acce" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="b74ea0e4e3ddeac5ecbd3ecbed85a2f70045728a" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="86634275ef317fd3fe952799b1bb3df615c7ddc1" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="1edcf669da9e6fb06ad045baef462cf32a3c26a6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="8c8afb214d0c0a6607affe28247998085762d4c8" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word32&quot;&gt;Word32&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="0d621456539c621761dd4c63fca78f9b42a61fd6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word64&quot;&gt;Word64&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="9c7acd6abb2dd44172bbfe5d9b17a04fe120a9e6" translate="yes" xml:space="preserve">
          <source>Hexadecimal encoding of a &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word8&quot;&gt;Word8&lt;/a&gt;&lt;/code&gt; 的十六进制编码。</target>
        </trans-unit>
        <trans-unit id="25ad5ace69a8a8ba3fb3a937ad28617759385a28" translate="yes" xml:space="preserve">
          <source>Hexadecimal numbers</source>
          <target state="translated">十六进制数</target>
        </trans-unit>
        <trans-unit id="03b3e0f65de320839723c279978dd47f65d6150a" translate="yes" xml:space="preserve">
          <source>Hidden packages (those for which the &lt;code&gt;exposed&lt;/code&gt; flag is &lt;code&gt;False&lt;/code&gt;) are shown in parentheses in the list of packages.</source>
          <target state="translated">隐藏的软件包（ &lt;code&gt;exposed&lt;/code&gt; 标志为 &lt;code&gt;False&lt;/code&gt; 的那些软件包）显示在软件包列表的括号中。</target>
        </trans-unit>
        <trans-unit id="a918c16fef0fbb900dc7f98f2cd8d6d81c7d52c8" translate="yes" xml:space="preserve">
          <source>Hidden:</source>
          <target state="translated">Hidden:</target>
        </trans-unit>
        <trans-unit id="2c6062001c6bab0163b0a4b2529719b8bde4b508" translate="yes" xml:space="preserve">
          <source>Hide all packages by default</source>
          <target state="translated">默认隐藏所有软件包</target>
        </trans-unit>
        <trans-unit id="feef4327e8cde9c994f26b136ddb595802f03d1c" translate="yes" xml:space="preserve">
          <source>Hide all packages for plugins by default</source>
          <target state="translated">默认隐藏所有插件包</target>
        </trans-unit>
        <trans-unit id="ec916c3e8ddb513e159b7a5e33949a183f39cac6" translate="yes" xml:space="preserve">
          <source>Hide package ⟨pkg⟩</source>
          <target state="translated">隐藏包⟨pkg⟩。</target>
        </trans-unit>
        <trans-unit id="7bd735044c33670955e5379d6a592895b1193122" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 构造函数允许的最高运算符优先级（答案：9）</target>
        </trans-unit>
        <trans-unit id="7f2e4337cf1098bf05ffcad5c2206b7483c99a77" translate="yes" xml:space="preserve">
          <source>Highest allowed operator precedence for &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; constructor (answer: 9)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 构造函数允许的最高运算符优先级（答案：9）</target>
        </trans-unit>
        <trans-unit id="e0b0bb84453552196a9b41ee3bcc312c62a89de7" translate="yes" xml:space="preserve">
          <source>Highly, terribly dangerous coercion from one representation type to another. Misuse of this function can invite the garbage collector to trounce upon your data and then laugh in your face. You don't want this function. Really.</source>
          <target state="translated">从一种表示类型到另一种表示类型的高度,非常危险的胁迫。滥用这个函数会招致垃圾收集器对你的数据大加挞伐,然后嘲笑你。你不会想要这个函数的。真的,你不会想要这个函数的。</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="31865f8541bac972726284192e08ce45f0bca25b" translate="yes" xml:space="preserve">
          <source>Historical note. Earlier versions of GHC allowed these now-rejected applications, by inserting automatic eta-expansions, as described in Section 4.6 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/&quot;&gt;Practical type inference for arbitrary-aank types&lt;/a&gt;, where it is called &amp;ldquo;deep skolemisation&amp;rdquo;. But these automatic eta-expansions may silently change the semantics of the user&amp;rsquo;s program, and deep skolemisation was removed from the language by &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst&quot;&gt;GHC Proposal #287&lt;/a&gt;. This proposal has many more examples.</source>
          <target state="translated">历史记录。较早版本的GHC通过插入自动eta扩展来允许这些现在被拒绝的应用程序，如&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/&quot;&gt;针对任意ank类型&lt;/a&gt;的实用类型推断的4.6节中所述，在此称为&amp;ldquo;深度伪扩展&amp;rdquo;。但是这些自动的eta扩展可能会悄无声息地改变用户程序的语义，并且&lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst&quot;&gt;GHC提案＃287&lt;/a&gt;从该语言中删除了深层次的kolelemisation 。该提案还有更多示例。</target>
        </trans-unit>
        <trans-unit id="2d84546cb2321a589250e0442876d448b09183af" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">从历史上看， &lt;code&gt;&lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-proxy#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 成语的一种更安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="a7e46fa97c09f5c0c83b2e88f3881c7a3e4f4f7c" translate="yes" xml:space="preserve">
          <source>Historically, &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; is a safer alternative to the &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; idiom.</source>
          <target state="translated">从历史上看， &lt;code&gt;&lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; :: &lt;a href=&quot;data-typeable#t:Proxy&quot;&gt;Proxy&lt;/a&gt; a&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;prelude#v:undefined&quot;&gt;undefined&lt;/a&gt; :: a&lt;/code&gt; 成语的一种更安全的替代方法。</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="807422feeeae1e65868373709a1281920ada2d92" translate="yes" xml:space="preserve">
          <source>Holding a &lt;code&gt;Weak ThreadId&lt;/code&gt;, on the other hand, will not prevent the thread from receiving &lt;code&gt;BlockedIndefinitely&lt;/code&gt; exceptions. It is still possible to throw an exception to a &lt;code&gt;Weak ThreadId&lt;/code&gt;, but the caller must use &lt;code&gt;deRefWeak&lt;/code&gt; first to determine whether the thread still exists.</source>
          <target state="translated">另一方面，持有 &lt;code&gt;Weak ThreadId&lt;/code&gt; 不会阻止线程接收 &lt;code&gt;BlockedIndefinitely&lt;/code&gt; 异常。仍然可以向 &lt;code&gt;Weak ThreadId&lt;/code&gt; 抛出异常，但是调用者必须首先使用 &lt;code&gt;deRefWeak&lt;/code&gt; 来确定线程是否仍然存在。</target>
        </trans-unit>
        <trans-unit id="3a0d96a8a98d1e4dce5ef0782487ab394c743475" translate="yes" xml:space="preserve">
          <source>Hole-fit plugins are plugins that are called when a typed-hole error message is being generated, and allows you to access information about the typed-hole at compile time, and allows you to customize valid hole fit suggestions.</source>
          <target state="translated">孔洞拟合插件是指在产生排版孔洞错误信息时调用的插件,允许你在编译时获取排版孔洞的信息,并允许你自定义有效的孔洞拟合建议。</target>
        </trans-unit>
        <trans-unit id="d098c08c4ae6f34d5c4821e087cb66e14f878118" translate="yes" xml:space="preserve">
          <source>Home directory (pw_dir)</source>
          <target state="translated">主目录 (pw_dir)</target>
        </trans-unit>
        <trans-unit id="aca79641b581fd367113ced98f70f47d0abeb2c8" translate="yes" xml:space="preserve">
          <source>Homomorphism</source>
          <target state="translated">Homomorphism</target>
        </trans-unit>
        <trans-unit id="78abe60fa7d802d62efa64043a705bae7407a631" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned decoding</source>
          <target state="translated">主码,不对齐解码。</target>
        </trans-unit>
        <trans-unit id="c639806398d26813e0fb48c1ebdba5cd82bf177b" translate="yes" xml:space="preserve">
          <source>Host-endian, unaligned writes</source>
          <target state="translated">Host-endian,unaligned writes.</target>
        </trans-unit>
        <trans-unit id="72a0f916e4e9bfcfeeae189f694538c5874f3603" translate="yes" xml:space="preserve">
          <source>Host-specific binary encodings</source>
          <target state="translated">主机专用二进制编码</target>
        </trans-unit>
        <trans-unit id="6c7fcd531348b3bb6fd008f425ab3f45a52aad77" translate="yes" xml:space="preserve">
          <source>HotLink</source>
          <target state="translated">HotLink</target>
        </trans-unit>
        <trans-unit id="f9cb8d909445ac44cd2fd5ac585df15ae8f92ebf" translate="yes" xml:space="preserve">
          <source>Hotlinks</source>
          <target state="translated">Hotlinks</target>
        </trans-unit>
        <trans-unit id="24af6649766c375876b6b100497556d3aa591028" translate="yes" xml:space="preserve">
          <source>Hour twelve</source>
          <target state="translated">第十二小时</target>
        </trans-unit>
        <trans-unit id="08b758819da040d3f055ca34119b72fa2b2d6747" translate="yes" xml:space="preserve">
          <source>Hour zero</source>
          <target state="translated">0小时</target>
        </trans-unit>
        <trans-unit id="a818d61d2efd55899d957cbb2415e5325cda9990" translate="yes" xml:space="preserve">
          <source>How can these goals be accomplished? Goal 1 suggests that weak references and finalizers (via &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Weak-35-&quot;&gt;Weak#&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-exts#v:mkWeak-35-&quot;&gt;mkWeak#&lt;/a&gt;&lt;/code&gt;) are necessary. But how should they be used and what should their key be? Certainly not &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtrContents&quot;&gt;ForeignPtrContents&lt;/a&gt;&lt;/code&gt;. See the warning in &lt;a href=&quot;ghc-weak&quot;&gt;GHC.Weak&lt;/a&gt; about weak pointers with lifted (non-primitive) keys. The two finalizer-supporting data constructors of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; have an &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt; &lt;a href=&quot;ghc-foreignptr#t:Finalizers&quot;&gt;Finalizers&lt;/a&gt;&lt;/code&gt; (backed by &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutVar-35-&quot;&gt;MutVar#&lt;/a&gt;&lt;/code&gt;) field. This gets used in two different ways depending on the kind of finalizer:</source>
          <target state="translated">如何实现这些目标？目标1建议弱引用和终结器（通过 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Weak-35-&quot;&gt;Weak#&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:mkWeak-35-&quot;&gt;mkWeak#&lt;/a&gt;&lt;/code&gt; ）是必要的。但是，应该如何使用它们以及它们的密钥应该是什么？当然不是 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtrContents&quot;&gt;ForeignPtrContents&lt;/a&gt;&lt;/code&gt; 。请参阅&lt;a href=&quot;ghc-weak&quot;&gt;GHC中&lt;/a&gt;的警告。有关使用提升键（非原始键）的弱指针的信息较弱。的两个终结支撑数据构造 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 具有 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt; &lt;a href=&quot;ghc-foreignptr#t:Finalizers&quot;&gt;Finalizers&lt;/a&gt;&lt;/code&gt; （由支持 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:MutVar-35-&quot;&gt;MutVar#&lt;/a&gt;&lt;/code&gt; 字段）。根据终结器的种类，有两种不同的用法：</target>
        </trans-unit>
        <trans-unit id="15c0121c842d34d2a7ecde10e9dc07dbbc682c4a" translate="yes" xml:space="preserve">
          <source>How do &lt;code&gt;Traversable&lt;/code&gt; functors manage to construct a new container of the same shape by sequencing effects over their elements? Well, left-to-right traversal with sequencing of effects suggests induction from a base case, so the first question is what is the base case? A &lt;code&gt;Traversable&lt;/code&gt; container with elements of type &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt; generally has some minimal form that is either &quot;empty&quot; or has just a single element (think &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt; vs. &lt;a href=&quot;data-list-nonempty&quot;&gt;Data.List.Nonempty&lt;/a&gt;).</source>
          <target state="translated">可 &lt;code&gt;Traversable&lt;/code&gt; 函子如何通过对元素的顺序进行排序来构造一个形状相同的新容器？好吧，从左到右遍历效果的顺序表明是从一个基本案例中得出的，所以第一个问题是什么是基本案例？甲 &lt;code&gt;Traversable&lt;/code&gt; 的类型的元素的容器&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;/strong&gt;通常具有一些最小形式要么是&amp;ldquo;空&amp;rdquo;或具有仅单个元件（认为&lt;a href=&quot;data-list&quot;&gt;Data.List模块&lt;/a&gt;与&lt;a href=&quot;data-list-nonempty&quot;&gt;Data.List.Nonempty&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e21e7b28bb4ec8bce45d51234ba921345ac168b2" translate="yes" xml:space="preserve">
          <source>How does the heap residency reported by the heap profiler relate to the actual memory residency of your program when you run it? You might see a large discrepancy between the residency reported by the heap profiler, and the residency reported by tools on your system (eg. &lt;code&gt;ps&lt;/code&gt; or &lt;code&gt;top&lt;/code&gt; on Unix, or the Task Manager on Windows). There are several reasons for this:</source>
          <target state="translated">运行程序时，堆探查器报告的堆驻留时间与程序的实际内存驻留情况有何关系？您可能会看到堆分析器报告的驻留时间和系统上的工具（例如 &lt;code&gt;ps&lt;/code&gt; 或Unix上的 &lt;code&gt;top&lt;/code&gt; 或Windows上的任务管理器）上的工具报告的驻留时间之间存在很大差异。有几个原因：</target>
        </trans-unit>
        <trans-unit id="1927f75bb049c830748f2729f0038bde12efc0c1" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline dictionaries?</source>
          <target state="translated">编译器应该多么渴望内联字典?</target>
        </trans-unit>
        <trans-unit id="e0a1c6fc2034630838e97a64d94b3af46c9319cd" translate="yes" xml:space="preserve">
          <source>How eager should the compiler be to inline functions?</source>
          <target state="translated">编译器应该多么渴望内联函数?</target>
        </trans-unit>
        <trans-unit id="a4fb79d40430db562ab3ac45f29bc78e66d5fe1c" translate="yes" xml:space="preserve">
          <source>How long the program has been running (CPU time and elapsed wall clock time).</source>
          <target state="translated">程序运行了多长时间(CPU时间和墙钟时间)。</target>
        </trans-unit>
        <trans-unit id="917d1059c1e62cf270bb88e3227c70dfbd432932" translate="yes" xml:space="preserve">
          <source>How long this garbage collection took (CPU time and elapsed wall clock time).</source>
          <target state="translated">这次垃圾收集花了多长时间(CPU时间和经过的墙钟时间)。</target>
        </trans-unit>
        <trans-unit id="36c6b03bfc8f9cb787a541e4b6548f8ac93d5025" translate="yes" xml:space="preserve">
          <source>How many bytes are currently live.</source>
          <target state="translated">目前有多少个字节是活的。</target>
        </trans-unit>
        <trans-unit id="01af7076602466fb2dd0d00c85e7ba87a68dda6f" translate="yes" xml:space="preserve">
          <source>How many bytes did the program allocate while inside of this cost-centre? This does not include allocations while in child cost-centres.</source>
          <target state="translated">在这个成本中心内,程序分配了多少个字节?这不包括在子成本中心的分配。</target>
        </trans-unit>
        <trans-unit id="b7ee2b37aca604bce9e3efa4a6ecb13d165e0be0" translate="yes" xml:space="preserve">
          <source>How many bytes to read</source>
          <target state="translated">读取多少个字节</target>
        </trans-unit>
        <trans-unit id="4ce115a90f4bba549deae5cc5d88db46fb3644d7" translate="yes" xml:space="preserve">
          <source>How many bytes we allocated this garbage collection.</source>
          <target state="translated">我们分配了多少字节的垃圾收集。</target>
        </trans-unit>
        <trans-unit id="8b589f57e5f67f3a65c8a115f4df2b5dfeb110e4" translate="yes" xml:space="preserve">
          <source>How many bytes we copied this garbage collection.</source>
          <target state="translated">我们复制了多少字节的这个垃圾收集。</target>
        </trans-unit>
        <trans-unit id="ff3e1b1a1b256a5e6dd2b8ae3a5665856b88bb55" translate="yes" xml:space="preserve">
          <source>How many capabilities the program was started with (e.g. using the &lt;code&gt;-N ⟨x⟩&lt;/code&gt; option). Note that the number of capabilities may change during execution due to the &lt;code&gt;setNumCapabilities&lt;/code&gt; function.</source>
          <target state="translated">程序具有多少功能（例如，使用 &lt;code&gt;-N ⟨x⟩&lt;/code&gt; 选项）。请注意，由于 &lt;code&gt;setNumCapabilities&lt;/code&gt; 函数，功能的数量可能会在执行期间改变。</target>
        </trans-unit>
        <trans-unit id="dd9b9ae41e95b919cfc203a74328458cee852026" translate="yes" xml:space="preserve">
          <source>How many page faults occurred since the end of the last garbage collection.</source>
          <target state="translated">自上次垃圾收集结束后,有多少次页面故障发生。</target>
        </trans-unit>
        <trans-unit id="7e0ec711a7a2aca8bf80c57d5b99771cc152f07c" translate="yes" xml:space="preserve">
          <source>How many page faults occurred this garbage collection.</source>
          <target state="translated">这次垃圾回收发生了多少次页面故障。</target>
        </trans-unit>
        <trans-unit id="ee49e11e7b07eb02b05621505c38a7360c70468d" translate="yes" xml:space="preserve">
          <source>How many profiler &amp;ldquo;ticks&amp;rdquo; elapsed over the course of the program&amp;rsquo;s execution.</source>
          <target state="translated">在程序执行过程中经过了多少个探查器&amp;ldquo;滴答声&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9d0f356fd0d39a80e2dc0473264e53a3f5be1255" translate="yes" xml:space="preserve">
          <source>How many stack frames in the given &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">给定 &lt;code&gt;&lt;a href=&quot;ghc-executionstack-internal#t:StackTrace&quot;&gt;StackTrace&lt;/a&gt;&lt;/code&gt; 中有多少个堆栈帧</target>
        </trans-unit>
        <trans-unit id="4ff13443abfdd5f6196035361c4d9c8b1b84e9e8" translate="yes" xml:space="preserve">
          <source>How many ticks was the program&amp;rsquo;s execution inside of this cost-centre? This does not include child cost-centres.</source>
          <target state="translated">在此成本中心内，程序的执行次数是多少？这不包括儿童成本中心。</target>
        </trans-unit>
        <trans-unit id="ab8938746f1911b57d597b21fb5c265320965f8d" translate="yes" xml:space="preserve">
          <source>How many times was this cost-centre entered?</source>
          <target state="translated">这个成本中心被输入了多少次?</target>
        </trans-unit>
        <trans-unit id="6758180b138745f6df61fe36255468b563201977" translate="yes" xml:space="preserve">
          <source>How much time between profiler ticks.</source>
          <target state="translated">剖析师间隔多少时间。</target>
        </trans-unit>
        <trans-unit id="fc67db788a397c6ce747c2f5326f08e707314b58" translate="yes" xml:space="preserve">
          <source>How to determine stderr</source>
          <target state="translated">如何确定stderr</target>
        </trans-unit>
        <trans-unit id="6dec927eb4441c4b466135f3fe2523a9b41513ff" translate="yes" xml:space="preserve">
          <source>How to determine stdin</source>
          <target state="translated">如何确定stdin</target>
        </trans-unit>
        <trans-unit id="83c69a711aceee10fc43cfaec8ddc771d114f1fc" translate="yes" xml:space="preserve">
          <source>How to determine stdout</source>
          <target state="translated">如何确定stdout</target>
        </trans-unit>
        <trans-unit id="12e3b28c9f66467f3782a09db7380eb03a095bea" translate="yes" xml:space="preserve">
          <source>How to handle the sign of a numeric field. These are mutually exclusive, with &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; taking precedence.</source>
          <target state="translated">如何处理数字字段的符号。这些是互斥的， &lt;code&gt;&lt;a href=&quot;text-printf#v:SignPlus&quot;&gt;SignPlus&lt;/a&gt;&lt;/code&gt; 优先。</target>
        </trans-unit>
        <trans-unit id="b5d91c4a03978824020eb2d8b5470646f57802ab" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">但是，如果您使用&lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;，那么GHC会改用范围为 &lt;code&gt;toList&lt;/code&gt; ， &lt;code&gt;fromList&lt;/code&gt; 和 &lt;code&gt;fromListN&lt;/code&gt; 的名称中的任何内容。也就是说，这些功能是可重新绑定的。cf可重&lt;a href=&quot;#rebindable-syntax&quot;&gt;绑定语法和隐式Prelude导入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ae296daca1b508d7fb4c3a47911474c376befa0" translate="yes" xml:space="preserve">
          <source>However if you use &lt;a href=&quot;rebindable_syntax#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt;, then GHC instead uses whatever is in scope with the names of &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt;. That is, these functions are rebindable; c.f. &lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;Rebindable syntax and the implicit Prelude import&lt;/a&gt;.</source>
          <target state="translated">但是，如果您使用&lt;a href=&quot;rebindable_syntax#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt;，则GHC会改用范围为 &lt;code&gt;toList&lt;/code&gt; ， &lt;code&gt;fromList&lt;/code&gt; 和 &lt;code&gt;fromListN&lt;/code&gt; 的名称中的任何内容。也就是说，这些功能是可重新绑定的。cf可&lt;a href=&quot;rebindable_syntax#rebindable-syntax&quot;&gt;重新绑定的语法和隐式的Prelude导入&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="702dc86214fe1989c12ea91b2f8f3061394aa70f" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;../ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">但是，请参阅GHCi中的重叠规则的&lt;a href=&quot;../ghci#ghci-decls&quot;&gt;类型，类和其他声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6040c9b47e1b3417452306269aaf1ff946d1bdd0" translate="yes" xml:space="preserve">
          <source>However see &lt;a href=&quot;ghci#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt; for the overlap rules in GHCi.</source>
          <target state="translated">但是，请参阅GHCi中重叠规则的&lt;a href=&quot;ghci#ghci-decls&quot;&gt;类型，类和其他声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27d3f3db18b261148fadac31985fc664c11dd948" translate="yes" xml:space="preserve">
          <source>However take care that the generated definitions are still in the input of &lt;code&gt;typeCheckResultAction&lt;/code&gt;. If your don&amp;rsquo;t take care to filter the typechecked input, the behavior of your tool might be inconsistent.</source>
          <target state="translated">但是请注意，生成的定义仍在 &lt;code&gt;typeCheckResultAction&lt;/code&gt; 的输入中。如果您不注意过滤经过类型检查的输入，则工具的行为可能会不一致。</target>
        </trans-unit>
        <trans-unit id="d170d05fd2a443fae748aa5bc3ef7be0adca547e" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">但是，monad &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 不是：</target>
        </trans-unit>
        <trans-unit id="75d85dddd307adff786f4e64b0c8bb94a7e37fed" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">但是，monad &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 不是：</target>
        </trans-unit>
        <trans-unit id="02bc960b7c0ef000cda26acf0b2dd0c7e0c24942" translate="yes" xml:space="preserve">
          <source>However the monad &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; is not:</source>
          <target state="translated">但是，monad &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-functor-identity#v:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 不是：</target>
        </trans-unit>
        <trans-unit id="fc54057c2f535150522eb952fec80397f100d689" translate="yes" xml:space="preserve">
          <source>However using Debug.Trace.trace is alright because it uses Windows debugging output support rather than &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">但是，使用Debug.Trace.trace可以，因为它使用Windows调试输出支持而不是 &lt;code&gt;stderr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8025ea24ecfecdd0f3e045637833ba460a0d7ea" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; creates a &lt;em&gt;bound&lt;/em&gt; thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL (see &lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;).</source>
          <target state="translated">但是， &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 创建一个&lt;em&gt;绑定&lt;/em&gt;线程，如果您需要调用利用线程局部状态的外部（非Haskell）库（例如OpenGL ），则这是必需的（请参见&lt;a href=&quot;control-concurrent#boundthreads&quot;&gt;Control.Concurrent&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e98e07fdef4dfe8b0cb3689c59c1f96f6cc38a2e" translate="yes" xml:space="preserve">
          <source>However, &lt;em&gt;nested&lt;/em&gt; bangs in a let/where pattern binding behave uniformly with all other forms of pattern matching. For example</source>
          <target state="translated">但是，let / where模式绑定中的&lt;em&gt;嵌套&lt;/em&gt;刘海与所有其他形式的模式匹配一​​致。例如</target>
        </trans-unit>
        <trans-unit id="e5f527eafccf9b322040b38f8d30b103c69e2e35" translate="yes" xml:space="preserve">
          <source>However, apart from these restrictions, many things are allowed, including expressions which are not fully evaluated! Annotation expressions will be evaluated by the compiler just like Template Haskell splices are. So, this annotation is fine:</source>
          <target state="translated">然而,除了这些限制之外,很多东西都是被允许的,包括没有被完全评估的表达式!注解表达式将被编译器评估,就像Template Haskell拼接一样。注释表达式将被编译器评估,就像模板 Haskell 拼接一样。所以,这个注解是可以的。</target>
        </trans-unit>
        <trans-unit id="8194ed59efdaf1498fbfe96f3c1af7f347e02a51" translate="yes" xml:space="preserve">
          <source>However, because GHC must &lt;em&gt;infer&lt;/em&gt; the type when part of a type is left out, it is unable to use polymorphic recursion. The same restriction takes place when the type signature is omitted completely.</source>
          <target state="translated">但是，由于GHC必须在忽略一部分类型时&lt;em&gt;推断出&lt;/em&gt;该类型，因此无法使用多态递归。当完全省略类型签名时，会发生相同的限制。</target>
        </trans-unit>
        <trans-unit id="5fc0cb9f7adb2ad4d1a50c3ef7d1d89e881714f8" translate="yes" xml:space="preserve">
          <source>However, by a simple extension to the type class system of Haskell, we can support dynamic binding. Basically, we express the use of a dynamically bound variable as a constraint on the type. These constraints lead to types of the form &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt;, which says &amp;ldquo;this function uses a dynamically-bound variable &lt;code&gt;?x&lt;/code&gt; of type &lt;code&gt;t'&lt;/code&gt;&amp;rdquo;. For example, the following expresses the type of a sort function, implicitly parameterised by a comparison function named &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">但是，通过简单扩展Haskell的类型类系统，我们可以支持动态绑定。基本上，我们表示使用动态绑定变量作为对类型的约束。这些约束导致类型为 &lt;code&gt;(?x::t') =&amp;gt; t&lt;/code&gt; ，表示&amp;ldquo;此函数使用类型为 &lt;code&gt;t'&lt;/code&gt; 的动态绑定变量 &lt;code&gt;?x&lt;/code&gt; &amp;rdquo;。例如，以下内容表示排序函数的类型，该排序函数由名为 &lt;code&gt;cmp&lt;/code&gt; 的比较函数隐式参数化。</target>
        </trans-unit>
        <trans-unit id="a905a90165b9acad9dcb4130ba63d5758f8a8d3c" translate="yes" xml:space="preserve">
          <source>However, consider the following example:</source>
          <target state="translated">然而,考虑到下面的例子。</target>
        </trans-unit>
        <trans-unit id="e08e1079e26d8ee5d64f16ab7646e745157e03bd" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">但是，启用&lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;扩展允许模块进行编译。各种扩展可能会发生类似的错误，包括：</target>
        </trans-unit>
        <trans-unit id="71c8649194e9a3d90eb4aa0b5d79e25f92dac745" translate="yes" xml:space="preserve">
          <source>However, enabling the &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt; extension allows the module to compile. Similar errors may occur with a variety of extensions, including:</source>
          <target state="translated">但是，启用&lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt;扩展允许模块进行编译。各种扩展可能会发生类似的错误，包括：</target>
        </trans-unit>
        <trans-unit id="0b8273c78a4e8dc99cc6fb13390e41af1c9b00ab" translate="yes" xml:space="preserve">
          <source>However, for GADTs there is the following additional constraint: every constructor that has a field &lt;code&gt;f&lt;/code&gt; must have the same result type (modulo alpha conversion) Hence, in the above example, we cannot merge the &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt; fields above into a single name. Although their field types are both &lt;code&gt;Term Int&lt;/code&gt;, their selector functions actually have different types:</source>
          <target state="translated">但是，对于GADT，还存在以下附加约束：每个具有字段 &lt;code&gt;f&lt;/code&gt; 的构造函数都必须具有相同的结果类型（模Alpha转换）。因此，在以上示例中，我们无法将上面的 &lt;code&gt;num&lt;/code&gt; 和 &lt;code&gt;arg&lt;/code&gt; 字段合并为一个名称。尽管它们的字段类型都是 &lt;code&gt;Term Int&lt;/code&gt; ，但是它们的选择器函数实际上具有不同的类型：</target>
        </trans-unit>
        <trans-unit id="bda4519b4ae553699a88736ad05de49408b09efc" translate="yes" xml:space="preserve">
          <source>However, for most applications, it should suffice to just use the &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; flags.</source>
          <target state="translated">但是，对于大多数应用程序，仅使用 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:historyFile&quot;&gt;historyFile&lt;/a&gt;&lt;/code&gt; 标志就足够了。</target>
        </trans-unit>
        <trans-unit id="ad986013ad68059837a38c8bd173d49d68173827" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;CProv&lt;/code&gt; is non-empty, while &lt;code&gt;CReq&lt;/code&gt; is, the above pattern type signature for &lt;code&gt;P&lt;/code&gt; must be specified as</source>
          <target state="translated">但是，如果 &lt;code&gt;CProv&lt;/code&gt; 为非空而 &lt;code&gt;CReq&lt;/code&gt; 为非空，则必须将上述 &lt;code&gt;P&lt;/code&gt; 的模式类型签名指定为</target>
        </trans-unit>
        <trans-unit id="d463e6d4a25197f32ed78eb56a6036ea10aebfec" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; ends in a separator, the default databases (i.e. the user and global package databases, in that order) are appended to the path. For example, to augment the usual set of packages with a database of your own, you could say (on Unix):</source>
          <target state="translated">但是，如果 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 以分隔符结尾，则默认数据库（即，用户数据库和全局包数据库，按该顺序）将附加到路径。例如，要用您自己的数据库扩充通常的软件包集，您可以说（在Unix上）：</target>
        </trans-unit>
        <trans-unit id="967aa81a898dabc9a0655eae4604ccf80453bdf1" translate="yes" xml:space="preserve">
          <source>However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，如果要与希望您的程序使用操作系统提供的线程包的外部库进行交互，则可以使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 进行操作。</target>
        </trans-unit>
        <trans-unit id="48f6dfd00eff21ddfaf5b9214e0d18073ac349d6" translate="yes" xml:space="preserve">
          <source>However, in all patterns &lt;em&gt;other&lt;/em&gt; than pattern bindings, a pattern type signature may mention a type variable that is not in scope; in this case, &lt;em&gt;the signature brings that type variable into scope&lt;/em&gt;. For example:</source>
          <target state="translated">然而，在所有模式&lt;em&gt;其他&lt;/em&gt;比图案绑定，图案类型签名可以提到一种类型的变量，是不是在范围; 在这种情况下，&lt;em&gt;签名将类型变量带入scope&lt;/em&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="84c24910fabe3813ad18d23c698dd48a88899c66" translate="yes" xml:space="preserve">
          <source>However, it appears that if you add a space at the end of the line, then &lt;code&gt;cpp&lt;/code&gt; (at least GNU &lt;code&gt;cpp&lt;/code&gt; and possibly other &lt;code&gt;cpp&lt;/code&gt;s) leaves the backslash-space pairs alone and the string gap works as expected.</source>
          <target state="translated">但是，似乎如果在行尾添加空格，则 &lt;code&gt;cpp&lt;/code&gt; （至少是GNU &lt;code&gt;cpp&lt;/code&gt; ，可能还有其他 &lt;code&gt;cpp&lt;/code&gt; ）将仅留下反斜杠对，并且字符串间隙按预期工作。</target>
        </trans-unit>
        <trans-unit id="28c91a74d73602f60fc3e23aaa16816234c03e5d" translate="yes" xml:space="preserve">
          <source>However, it is possible to perform a bit of &amp;ldquo;backwards&amp;rdquo; evaluation. For example, here is how we could get GHC to compute arbitrary logarithms at the type level:</source>
          <target state="translated">但是，可以执行一些&amp;ldquo;向后&amp;rdquo;评估。例如，这是我们如何使GHC在类型级别计算任意对数的方法：</target>
        </trans-unit>
        <trans-unit id="1f3a4b89e8199e4d733ca299842a306ab859485c" translate="yes" xml:space="preserve">
          <source>However, it is tiresome for the user to have to specify the type, so GHCi extends Haskell&amp;rsquo;s type-defaulting rules (Section 4.3.4 of the Haskell 2010 Report) as follows. The standard rules take each group of constraints &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; for each type variable &lt;code&gt;a&lt;/code&gt;, and defaults the type variable if</source>
          <target state="translated">但是，用户必须指定类型很麻烦，因此GHCi扩展了Haskell的类型默认规则（Haskell 2010报告的第4.3.4节），如下所示。标准规则为每个类型变量 &lt;code&gt;a&lt;/code&gt; 接受每组约束 &lt;code&gt;(C1 a, C2 a, ..., Cn a)&lt;/code&gt; ，并在以下情况下默认类型变量</target>
        </trans-unit>
        <trans-unit id="4a41cd61107bf2e5acee8876cf3ea899f304dcd8" translate="yes" xml:space="preserve">
          <source>However, not all is lost. We can still do this:</source>
          <target state="translated">然而,也并非一无所有。我们仍然可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="7187323d3950a28b28f87b9f4c602a2796f69d8b" translate="yes" xml:space="preserve">
          <source>However, note that it is reasonable to have a module &lt;code&gt;Main&lt;/code&gt; in a file named &lt;code&gt;foo.hs&lt;/code&gt;, but this only works because GHC never needs to search for the interface for module &lt;code&gt;Main&lt;/code&gt; (because it is never imported). It is therefore possible to have several &lt;code&gt;Main&lt;/code&gt; modules in separate source files in the same directory, and GHC will not get confused.</source>
          <target state="translated">但是，请注意在名为 &lt;code&gt;foo.hs&lt;/code&gt; 的文件中包含模块 &lt;code&gt;Main&lt;/code&gt; 是合理的，但这仅适用于GHC 无需搜索模块 &lt;code&gt;Main&lt;/code&gt; 的接口（因为它从未被导入）。因此，可以在同一目录的单独源文件中包含多个 &lt;code&gt;Main&lt;/code&gt; 模块，并且GHC不会混淆。</target>
        </trans-unit>
        <trans-unit id="fcbd4b2fd1492cb8e585fb78fb46502a8ccda050" translate="yes" xml:space="preserve">
          <source>However, regardless of the flag setting, the quantifiers are printed under these circumstances:</source>
          <target state="translated">然而,无论标志如何设置,在这种情况下,定量器都会被打印出来。</target>
        </trans-unit>
        <trans-unit id="90b773fc14f9910a6800428a873985b0da62bdbd" translate="yes" xml:space="preserve">
          <source>However, reuse of an &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; obtained in this way will typically memoise the underlying element sequence. Instead, we can define &lt;strong&gt;&lt;code&gt;FRList&lt;/code&gt;&lt;/strong&gt; terms directly:</source>
          <target state="translated">但是，以这种方式获得的&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; 的&lt;/strong&gt;重用通常会记住基础元素序列。相反，我们可以直接定义&lt;strong&gt; &lt;code&gt;FRList&lt;/code&gt; &lt;/strong&gt;术语：</target>
        </trans-unit>
        <trans-unit id="35326ee19484ea5250a5955bf9162649c5ce6743" translate="yes" xml:space="preserve">
          <source>However, since version 8.4 this is no longer the case: GHC &lt;strong&gt;guarantees&lt;/strong&gt; that garbage collection will never occur during an &lt;code&gt;unsafe&lt;/code&gt; call, even in the bytecode interpreter, and further guarantees that &lt;code&gt;unsafe&lt;/code&gt; calls will be performed in the calling thread.</source>
          <target state="translated">但是，从8.4版开始，情况就不再如此：GHC &lt;strong&gt;保证&lt;/strong&gt;即使在字节码解释器中，在 &lt;code&gt;unsafe&lt;/code&gt; 调用期间也不会发生垃圾回收，并且进一步保证了在调用线程中将执行 &lt;code&gt;unsafe&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="3168a5cfff35597637af368edcde71624cd723d0" translate="yes" xml:space="preserve">
          <source>However, sometimes there are no such calls, in which case the pragma can be useful.</source>
          <target state="translated">然而,有时并没有这样的调用,在这种情况下,pragma是有用的。</target>
        </trans-unit>
        <trans-unit id="5f1896001a515ea20b3107b6872d509be571c338" translate="yes" xml:space="preserve">
          <source>However, standalone deriving differs from a &lt;code&gt;deriving&lt;/code&gt; clause in a number of important ways:</source>
          <target state="translated">但是，独立派生与 &lt;code&gt;deriving&lt;/code&gt; 子句在许多重要方面有所不同：</target>
        </trans-unit>
        <trans-unit id="d2ba9a199527bbadec33a09879e817a0f6de5758" translate="yes" xml:space="preserve">
          <source>However, starting with &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt;, the default implementation is based on &lt;code&gt;DefaultSignatures&lt;/code&gt; allowing for more accurate auto-derived &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; instances. If you need the previously used exact default &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; method implementation semantics, use</source>
          <target state="translated">但是，从 &lt;code&gt;deepseq-1.4.0.0&lt;/code&gt; 开始，默认实现基于 &lt;code&gt;DefaultSignatures&lt;/code&gt; ,允许更准确地自动派生 &lt;code&gt;&lt;a href=&quot;control-deepseq#t:NFData&quot;&gt;NFData&lt;/a&gt;&lt;/code&gt; 实例。如果需要以前使用的确切默认 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; 方法实现语义，请使用</target>
        </trans-unit>
        <trans-unit id="7024ade898249c07bcf841caece72369d63586b1" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; and &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; axioms both match the wanted constraint &lt;code&gt;C a&lt;/code&gt;. There are several possible approaches for handling these overlapping local axioms:</source>
          <target state="translated">但是， &lt;code&gt;A a =&amp;gt; C a&lt;/code&gt; 和 &lt;code&gt;B a =&amp;gt; C a&lt;/code&gt; 公理都与所需约束 &lt;code&gt;C a&lt;/code&gt; 匹配。处理这些重叠的局部公理有几种可能的方法：</target>
        </trans-unit>
        <trans-unit id="cf8981ad8f62f6891902d31a96ee844f6c284310" translate="yes" xml:space="preserve">
          <source>However, the instance declaration must still conform to the rules for instance termination: see &lt;a href=&quot;#instance-termination&quot;&gt;Instance termination rules&lt;/a&gt;.</source>
          <target state="translated">但是，实例声明必须仍然符合&lt;a href=&quot;#instance-termination&quot;&gt;实例终止规则&lt;/a&gt;：请参阅实例终止规则。</target>
        </trans-unit>
        <trans-unit id="f0881e26d84cd12d8c7fd2b522507d9075fd4696" translate="yes" xml:space="preserve">
          <source>However, the real implemenation uses memcmp to compare the end of the string only, with no reverse required..</source>
          <target state="translated">然而,真正的实现只用memcmp来比较字符串的末端,而不需要反向。</target>
        </trans-unit>
        <trans-unit id="06134ece72c951c7d7c727c39885e4d66b957bb6" translate="yes" xml:space="preserve">
          <source>However, the second law is violated in the presence of undefined operators,</source>
          <target state="translated">但是,在未定义的运算符存在的情况下,就违反了第二条规律。</target>
        </trans-unit>
        <trans-unit id="63bdcc6dcc86cc03d19b2829a81c1ef6b447e031" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;exts/parallel#lang-parallel&quot;&gt;Parallel and Concurrent&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">但是，这两个术语肯定是相关的。通过使用多个CPU，可以并行运行并发线程，而这正是GHC的SMP并行性支持所做的。但是，也可以在不使用并发的程序上通过并行性来提高性能。本节介绍如何使用GHC编译和运行并行程序，在&amp;ldquo;&lt;a href=&quot;exts/parallel#lang-parallel&quot;&gt;并行和并行&amp;rdquo;中，&lt;/a&gt;我们描述了影响并行性的语言功能。</target>
        </trans-unit>
        <trans-unit id="a72bbc3e10475e3349a7633255fe25a94534717f" translate="yes" xml:space="preserve">
          <source>However, the two terms are certainly related. By making use of multiple CPUs it is possible to run concurrent threads in parallel, and this is exactly what GHC&amp;rsquo;s SMP parallelism support does. But it is also possible to obtain performance improvements with parallelism on programs that do not use concurrency. This section describes how to use GHC to compile and run parallel programs, in &lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent and Parallel Haskell&lt;/a&gt; we describe the language features that affect parallelism.</source>
          <target state="translated">但是，这两个术语肯定是相关的。通过使用多个CPU，可以并行运行并发线程，而这正是GHC的SMP并行性支持所做的。但是，也可以在不使用并发的程序上通过并行性获得性能改进。本节介绍如何使用GHC编译和运行并行程序，在&lt;a href=&quot;parallel#lang-parallel&quot;&gt;Concurrent和Parallel Haskell中，&lt;/a&gt;我们描述了影响并行性的语言功能。</target>
        </trans-unit>
        <trans-unit id="d0d7fb9afd1affd6fb2291bb8b2736b5c57061fb" translate="yes" xml:space="preserve">
          <source>However, the unrestricted use of &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; is a problem as an arbitrary module can use it to mark themselves as trusted, yet &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t offer any guarantees about the module, unlike &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. To control the use of trustworthy modules it is recommended to use the &lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt;&lt;code&gt;-fpackage-trust&lt;/code&gt;&lt;/a&gt; flag. This flag adds an extra requirement to the trust check for trustworthy modules. It requires that for a trustworthy modules to be considered trusted, and allowed to be used in &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; compiled code, the client C compiling the code must tell GHC that they trust the package the trustworthy module resides in. This is essentially a way of for C to say, while this package contains trustworthy modules that can be used by untrusted modules compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, I trust the author(s) of this package and trust the modules only expose a safe API. The trust of a package can be changed at any time, so if a vulnerability found in a package, C can declare that package untrusted so that any future compilation against that package would fail. For a more detailed overview of this mechanism see &lt;a href=&quot;#safe-trust&quot;&gt;Trust and Safe Haskell Modes&lt;/a&gt;.</source>
          <target state="translated">但是，不受限制地使用&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;是一个问题，因为任意模块都可以使用它来标记自己为受信任的模块，但与&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;不同，&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;不能提供有关该模块的任何保证。要控制可信任模块的使用，建议使用&lt;a href=&quot;#ghc-flag--fpackage-trust&quot;&gt; &lt;code&gt;-fpackage-trust&lt;/code&gt; &lt;/a&gt;标志。该标志为可信任模块的信任检查增加了一个额外要求。它要求将可信赖的模块视为可信的，并允许在&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译后的代码，客户端C编译代码时必须告诉GHC，他们信任可信任模块所在的包。这实质上是C的一种说法，而此包包含可信任模块，可以使用&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;编译的不信任模块可以使用该包。，我相信这个软件包的作者，并且相信这些模块只会公开一个安全的API。程序包的信任可以随时更改，因此，如果在程序包中发现漏洞，C可以声明该程序包不受信任，以便将来对该程序包进行的任何编译都会失败。有关此机制的更详细概述，请参阅&amp;ldquo; &lt;a href=&quot;#safe-trust&quot;&gt;信任模式&amp;rdquo;和&amp;ldquo;安全Haskell模式&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b532bdc7013089e7dc2ea095365363430246167b" translate="yes" xml:space="preserve">
          <source>However, there are a couple of problems with this approach. The first is that having two exception handlers is inefficient. However, the more serious issue is that the second exception handler will catch exceptions in the first, e.g. in the example above, if &lt;code&gt;handleArith&lt;/code&gt; throws an &lt;code&gt;IOException&lt;/code&gt; then the second exception handler will catch it.</source>
          <target state="translated">但是，这种方法存在两个问题。首先是拥有两个异常处理程序效率低下。但是，更严重的问题是第二个异常处理程序将在第一个异常处理程序中捕获异常，例如在上面的示例中，如果 &lt;code&gt;handleArith&lt;/code&gt; 抛出 &lt;code&gt;IOException&lt;/code&gt; ,则第二个异常处理程序将捕获它。</target>
        </trans-unit>
        <trans-unit id="d9ee23f1fd11c8d62aeb9eeee086197709f0be7d" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，有一些用于创建事务变量的函数，这些函数始终可以在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 中安全地调用。请参阅： &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22293f9f5fdf9be0f89ee2fe6ac2c9f85e6c4fa" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，有一些用于创建事务变量的函数，这些函数始终可以在 &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 中安全地调用。请参阅： &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37661dc7c27dbb41dea8ca8af0a138bd14b9b454" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，有一些用于创建事务变量的函数，这些函数始终可以在 &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 中安全地调用。请参阅： &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tvar#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c11995af9963ba10b5fec5e359b15b835f98697" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，有一些用于创建事务变量的函数，这些函数始终可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 中安全地调用。请参阅： &lt;code&gt;&lt;a href=&quot;ghc-conc#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef09da657ffc9d4af89d0f416150551e096de936" translate="yes" xml:space="preserve">
          <source>However, there are functions for creating transactional variables that can always be safely called in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. See: &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是，有一些用于创建事务变量的函数，这些函数始终可以在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 中安全地调用。请参阅： &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:newTVarIO&quot;&gt;newTVarIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newTChanIO&quot;&gt;newTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tchan#v:newBroadcastTChanIO&quot;&gt;newBroadcastTChanIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tqueue#v:newTQueueIO&quot;&gt;newTQueueIO&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tbqueue#v:newTBQueueIO&quot;&gt;newTBQueueIO&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:newTMVarIO&quot;&gt;newTMVarIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36debdedc3fc8b9fe245012b3b2d0f8a8b3e2720" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">但是，这在某些非Unix OS上很难实现，因此，为了获得最大的可移植性，我们只返回被调用程序的叶子名称。即使那样，平台之间也存在一些差异：例如，在Windows上，以foo调用的程序可能实际上是 &lt;code&gt;FOO.EXE&lt;/code&gt; ，这就是 &lt;code&gt;&lt;a href=&quot;system-environment#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 将返回的内容。</target>
        </trans-unit>
        <trans-unit id="04e5a60e9a91ca4a5044b3e556c3f51ba02637a2" translate="yes" xml:space="preserve">
          <source>However, this is hard-to-impossible to implement on some non-Unix OSes, so instead, for maximum portability, we just return the leafname of the program as invoked. Even then there are some differences between platforms: on Windows, for example, a program invoked as foo is probably really &lt;code&gt;FOO.EXE&lt;/code&gt;, and that is what &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; will return.</source>
          <target state="translated">但是，这在某些非Unix OS上很难实现，因此，为了获得最大的可移植性，我们只返回被调用程序的叶子名称。即使那样，平台之间也存在一些差异：例如，在Windows上，以foo调用的程序可能实际上是 &lt;code&gt;FOO.EXE&lt;/code&gt; ，这就是 &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:getProgName&quot;&gt;getProgName&lt;/a&gt;&lt;/code&gt; 将返回的内容。</target>
        </trans-unit>
        <trans-unit id="6557c18e96aa511c7a8a12a0376a7cadff35e893" translate="yes" xml:space="preserve">
          <source>However, this is not terribly efficient, because we pay the cost of reconstructing the entire structure as a side effect of validation. It is generally cheaper to just check all the elements and then use the original structure if it is valid. This can be done via the methods of the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; superclass, which perform only the side effects without generating a new structure:</source>
          <target state="translated">但是，这并不是十分有效，因为我们付出了重建整个结构的费用作为验证的副作用。通常，仅检查所有元素然后使用原始结构（如果有效）会更便宜。这可以通过 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 超类的方法完成，该方法仅执行副作用而不生成新的结构：</target>
        </trans-unit>
        <trans-unit id="1658f0cedb643d19abc9a3eb383bd3c50a7ac313" translate="yes" xml:space="preserve">
          <source>However, this is not true. On the contrary, similarly to the above implementations of &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; has a &quot;step size&quot; of &lt;code&gt;10^-12&lt;/code&gt;. Hence, the list &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; has the form</source>
          <target state="translated">但是，这是不正确的。相反，类似于 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; 的上述实现， &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; 的&amp;ldquo;步长&amp;rdquo;为 &lt;code&gt;10^-12&lt;/code&gt; 。因此，列表 &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; 的形式为</target>
        </trans-unit>
        <trans-unit id="f86459604cdb799db006c4886698519f85f63218" translate="yes" xml:space="preserve">
          <source>However, this is not true. On the contrary, similarly to the above implementations of &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; has a &quot;step size&quot; of &lt;code&gt;10^-12&lt;/code&gt;. Hence, the list &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; has the form</source>
          <target state="translated">但是，这是不正确的。相反，类似于 &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; 的上述实现， &lt;code&gt;enumFromTo :: Pico -&amp;gt; Pico -&amp;gt; [Pico]&lt;/code&gt; 的&amp;ldquo;步长&amp;rdquo;为 &lt;code&gt;10^-12&lt;/code&gt; 。因此，列表 &lt;code&gt;[1..10] :: [Pico]&lt;/code&gt; 的形式为</target>
        </trans-unit>
        <trans-unit id="cd5fe8ac3752b514477ab6da6483511ccc949a4e" translate="yes" xml:space="preserve">
          <source>However, this quickly gets tedious when defining functions with multiple clauses, or groups of mutually recursive functions, because the complete definition has to be given on a single line, using explicit semicolons instead of layout:</source>
          <target state="translated">然而,当定义具有多个子句的函数,或相互递归的函数组时,这很快就会变得乏味,因为必须在一行中给出完整的定义,使用显式分号而不是布局。</target>
        </trans-unit>
        <trans-unit id="321449b209a4a3d9b8a213d15a63e5983b737e5b" translate="yes" xml:space="preserve">
          <source>However, this restriction can be relaxed by enabling &lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unlifted-newtypes&quot;&gt;section on unlifted newtypes&lt;/a&gt; details the behavior of such types.</source>
          <target state="translated">但是，可以通过启用&lt;a href=&quot;#extension-UnliftedNewtypes&quot;&gt; &lt;code&gt;UnliftedNewtypes&lt;/code&gt; &lt;/a&gt;来放宽此限制。未&lt;a href=&quot;#unlifted-newtypes&quot;&gt;提升&lt;/a&gt;的新类型部分详细介绍了此类类型的行为。</target>
        </trans-unit>
        <trans-unit id="8c072dae816d58a4bbbf3253aaac2ff2d7bee49e" translate="yes" xml:space="preserve">
          <source>However, this would not be permitted, because &lt;code&gt;x&lt;/code&gt; is ambiguous:</source>
          <target state="translated">但是，这是不允许的，因为 &lt;code&gt;x&lt;/code&gt; 不明确：</target>
        </trans-unit>
        <trans-unit id="cc6a6176295d69c876f06979d7fd1959a45e1552" translate="yes" xml:space="preserve">
          <source>However, type class instances of instances of data families can be defined much like any other data type. For example, we can say</source>
          <target state="translated">然而,数据族实例的类型类实例可以像其他数据类型一样被定义。例如,我们可以说</target>
        </trans-unit>
        <trans-unit id="67eb60c225421062cda3e126bd114e249c145db9" translate="yes" xml:space="preserve">
          <source>However, we do not infer the type of the argument to determine the datatype, or have any way of deferring the choice to the constraint solver. Thus the following is ambiguous:</source>
          <target state="translated">然而,我们并没有推断出参数的类型来确定数据类型,也没有任何办法将选择权交给约束求解器。因此,下面的内容是模棱两可的。</target>
        </trans-unit>
        <trans-unit id="2d46b3249f71b533cad63e9708c9fb1563db8ccc" translate="yes" xml:space="preserve">
          <source>However, with &lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt;&lt;/a&gt; set to e.g. &lt;code&gt;1&lt;/code&gt;, it will additionally offer up a list of refinement hole fits, in this case:</source>
          <target state="translated">但是，如果将&lt;a href=&quot;#ghc-flag--frefinement-level-hole-fits=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-frefinement-level-hole-fits=⟨n⟩&lt;/code&gt; &lt;/a&gt;设置为例如 &lt;code&gt;1&lt;/code&gt; ，则在这种情况下，它将另外提供一个细化孔配合的列表：</target>
        </trans-unit>
        <trans-unit id="2c1c33bc1108d9b6ddb6ca92ba69a2740518cc11" translate="yes" xml:space="preserve">
          <source>HpcHash</source>
          <target state="translated">HpcHash</target>
        </trans-unit>
        <trans-unit id="a360e1a8abea3420612de3ead3619643eba9cb5b" translate="yes" xml:space="preserve">
          <source>HpcPos</source>
          <target state="translated">HpcPos</target>
        </trans-unit>
        <trans-unit id="e4d5ebe01dfadab7c70f17122ef7cd34dd84d2c8" translate="yes" xml:space="preserve">
          <source>Html</source>
          <target state="translated">Html</target>
        </trans-unit>
        <trans-unit id="124fd6e6c83b9f6fb819bac633416da6be7be061" translate="yes" xml:space="preserve">
          <source>Html abbreviations</source>
          <target state="translated">Html缩略语</target>
        </trans-unit>
        <trans-unit id="e52dad2394901ae9e2d9331b3f2acf8d98f94c3d" translate="yes" xml:space="preserve">
          <source>Html colors</source>
          <target state="translated">Html颜色</target>
        </trans-unit>
        <trans-unit id="61902ef6ccfb44a18ca2dc1621601009523e9eaa" translate="yes" xml:space="preserve">
          <source>HtmlAttr</source>
          <target state="translated">HtmlAttr</target>
        </trans-unit>
        <trans-unit id="1a8747bf93f58314ba9284567291634cad2df306" translate="yes" xml:space="preserve">
          <source>HtmlTable</source>
          <target state="translated">HtmlTable</target>
        </trans-unit>
        <trans-unit id="869a30d95c70a8d903e6df744e122731cf7e1681" translate="yes" xml:space="preserve">
          <source>HtmlTree</source>
          <target state="translated">HtmlTree</target>
        </trans-unit>
        <trans-unit id="f5351a72db878f5f365bfd63650ac9345f429fc2" translate="yes" xml:space="preserve">
          <source>Hybrid folds</source>
          <target state="translated">混合型折叠</target>
        </trans-unit>
        <trans-unit id="2f70612bc16437d395e71287782bb6fd9cb7cf34" translate="yes" xml:space="preserve">
          <source>I can&amp;rsquo;t use</source>
          <target state="translated">我不能用</target>
        </trans-unit>
        <trans-unit id="67e7f16393df9e1a3f34effee9614b452216e036" translate="yes" xml:space="preserve">
          <source>I/O error that is programmer-defined.</source>
          <target state="translated">程序员定义的I/O错误。</target>
        </trans-unit>
        <trans-unit id="be281ef8dae874dacda5f49b4225eb1d24483701" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments already exists.</source>
          <target state="translated">I/O错误,操作失败是因为其中一个参数已经存在。</target>
        </trans-unit>
        <trans-unit id="aa1a6c7e94bc5323e2b6ac2224ee418279aeb634" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments does not exist.</source>
          <target state="translated">I/O错误,因为其中一个参数不存在而导致操作失败。</target>
        </trans-unit>
        <trans-unit id="cf116efd8157c9a3bd761c2360aee94f0bc67d1a" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because one of its arguments is a single-use resource, which is already being used.</source>
          <target state="translated">I/O错误,操作失败的原因是其参数之一是一个已经被使用的一次性资源。</target>
        </trans-unit>
        <trans-unit id="cc128e1a7374671fae3700b7cd3ca03b1ae3b58e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the device is full.</source>
          <target state="translated">I/O错误,由于设备已满,操作失败。</target>
        </trans-unit>
        <trans-unit id="d8f8e3fdaff7cb3366cae3acc6a3cd527d98dbd3" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the end of file has been reached.</source>
          <target state="translated">I/O错误,操作失败,因为已经到达文件的终点。</target>
        </trans-unit>
        <trans-unit id="82239ba587720ead23fb3ec489cdc8f072db7a33" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. See &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">由于资源消失而导致操作失败的I / O错误。参见 &lt;code&gt;&lt;a href=&quot;system-io-error#v:resourceVanishedErrorType&quot;&gt;resourceVanishedErrorType&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53e0ff159cdede7a57ee03fa0daa909d8ace6979" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the resource vanished. This happens when, for example, attempting to write to a closed socket or attempting to write to a named pipe that was deleted.</source>
          <target state="translated">I/O错误,由于资源消失,操作失败。例如,当试图向一个封闭的套接字写入或试图向一个被删除的命名管道写入时,就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="23225f523b6fe0da8418987860224d2674cecc83" translate="yes" xml:space="preserve">
          <source>I/O error where the operation failed because the user does not have sufficient operating system privilege to perform that operation.</source>
          <target state="translated">I/O错误,由于用户没有足够的操作系统权限来执行该操作,导致操作失败。</target>
        </trans-unit>
        <trans-unit id="4923b264f73fffadc5e3e140e95a5e90f4234f9e" translate="yes" xml:space="preserve">
          <source>I/O error where the operation is not possible.</source>
          <target state="translated">不能进行操作的I/O错误。</target>
        </trans-unit>
        <trans-unit id="9f2341b3a2667883fa17fd8660410d5080e25605" translate="yes" xml:space="preserve">
          <source>I/O errors</source>
          <target state="translated">I/O错误</target>
        </trans-unit>
        <trans-unit id="893f42dbf3b6c3880cae0f711ab5e68ed55c84da" translate="yes" xml:space="preserve">
          <source>I/O operations required for implementing a &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">实现 &lt;code&gt;&lt;a href=&quot;system-io#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 所需的I / O操作。</target>
        </trans-unit>
        <trans-unit id="010704f655d5ffc0ec746349b6abc0e90227f6a7" translate="yes" xml:space="preserve">
          <source>I/O with &lt;code&gt;ByteString&lt;/code&gt;s</source>
          <target state="translated">具有 &lt;code&gt;ByteString&lt;/code&gt; 的I / O</target>
        </trans-unit>
        <trans-unit id="ad04b3f0bd847573f914feec3f998fe1fbf5895a" translate="yes" xml:space="preserve">
          <source>I/O with Handles</source>
          <target state="translated">带手柄的I/O</target>
        </trans-unit>
        <trans-unit id="acc124dc3f9258dc88e844ea4ab0c049f8122496" translate="yes" xml:space="preserve">
          <source>I16</source>
          <target state="translated">I16</target>
        </trans-unit>
        <trans-unit id="eee5fb69722aeae0ef4402237b3281ea912a11ad" translate="yes" xml:space="preserve">
          <source>ID of group.</source>
          <target state="translated">组的ID。</target>
        </trans-unit>
        <trans-unit id="34a94d7992e803328c642d1ab3fa274462915c38" translate="yes" xml:space="preserve">
          <source>ID of owner.</source>
          <target state="translated">业主的身份证。</target>
        </trans-unit>
        <trans-unit id="6fb496c44e36ef77af848cbdb3f2ef6feaf4502e" translate="yes" xml:space="preserve">
          <source>ID of the device on which this file resides.</source>
          <target state="translated">该文件所在设备的ID。</target>
        </trans-unit>
        <trans-unit id="bb2fe63e5a32cb2596d9f60d2ae271ae4d1c1787" translate="yes" xml:space="preserve">
          <source>INPUT</source>
          <target state="translated">INPUT</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="556d134b3ad4c3f832238864ee9ed1a9fff795e3" translate="yes" xml:space="preserve">
          <source>INT32</source>
          <target state="translated">INT32</target>
        </trans-unit>
        <trans-unit id="c35391cc7b82f6ccca4793a8e8e896ee6abb21d2" translate="yes" xml:space="preserve">
          <source>INT64</source>
          <target state="translated">INT64</target>
        </trans-unit>
        <trans-unit id="68e53a5693c9fc9b9b1250288b7552cd0ff0e2f9" translate="yes" xml:space="preserve">
          <source>INT_PTR</source>
          <target state="translated">INT_PTR</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="221a35a7e847cc97cca77325d3f3ad369c03402f" translate="yes" xml:space="preserve">
          <source>IO functions for serialisation</source>
          <target state="translated">用于序列化的IO功能</target>
        </trans-unit>
        <trans-unit id="cc004908b1b2245fb78beda6015345ffd34734b1" translate="yes" xml:space="preserve">
          <source>IO-related Exception types and functions</source>
          <target state="translated">与IO相关的异常类型和功能</target>
        </trans-unit>
        <trans-unit id="39e51b2fc5f7179682d0416f025521af63af3bff" translate="yes" xml:space="preserve">
          <source>IOArray</source>
          <target state="translated">IOArray</target>
        </trans-unit>
        <trans-unit id="c6a99f18754ec17dc03dabc42173c7669bade008" translate="yes" xml:space="preserve">
          <source>IOCallback</source>
          <target state="translated">IOCallback</target>
        </trans-unit>
        <trans-unit id="e37f3b10503e6237389797302777a6702097cc50" translate="yes" xml:space="preserve">
          <source>IODevice</source>
          <target state="translated">IODevice</target>
        </trans-unit>
        <trans-unit id="de20e3fa4c9228ace3c0f6bf748ad0bbf5c271d9" translate="yes" xml:space="preserve">
          <source>IODeviceType</source>
          <target state="translated">IODeviceType</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="08d5912d3126b1dfb78f32fc53ee4cb092bb66d6" translate="yes" xml:space="preserve">
          <source>IOErrorType</source>
          <target state="translated">IOErrorType</target>
        </trans-unit>
        <trans-unit id="319a21ad8b671794467e4935946062d4d1e04338" translate="yes" xml:space="preserve">
          <source>IOException</source>
          <target state="translated">IOException</target>
        </trans-unit>
        <trans-unit id="6eeb7a443b8d1cc8717295647ffb6fceb48316d4" translate="yes" xml:space="preserve">
          <source>IOMode</source>
          <target state="translated">IOMode</target>
        </trans-unit>
        <trans-unit id="b772fdda8de2d1e1a2fcd9af43fda137f1082681" translate="yes" xml:space="preserve">
          <source>IORef</source>
          <target state="translated">IORef</target>
        </trans-unit>
        <trans-unit id="268db2ac8f4f524b89d42b5ab6cac600af62f822" translate="yes" xml:space="preserve">
          <source>IORefs</source>
          <target state="translated">IORefs</target>
        </trans-unit>
        <trans-unit id="4c3aab79c94196e8852e03490d73a55b7f5049e7" translate="yes" xml:space="preserve">
          <source>IOUArray</source>
          <target state="translated">IOUArray</target>
        </trans-unit>
        <trans-unit id="e10a87d05825ac01e14764ed94abba63697418fb" translate="yes" xml:space="preserve">
          <source>IQList</source>
          <target state="translated">IQList</target>
        </trans-unit>
        <trans-unit id="820a25194dff0d9c02f82ba8b6ba428cf8fc6422" translate="yes" xml:space="preserve">
          <source>IQNil</source>
          <target state="translated">IQNil</target>
        </trans-unit>
        <trans-unit id="7567d31e648220ce233abc256ecdab6241e5ddca" translate="yes" xml:space="preserve">
          <source>ISO 8601 Ordinal Date format</source>
          <target state="translated">ISO 8601 顺序日期格式</target>
        </trans-unit>
        <trans-unit id="f822119fe2f0a8362181618c06cbbe9eb1102060" translate="yes" xml:space="preserve">
          <source>ISO 8601 Week Date format</source>
          <target state="translated">ISO 8601 周日期格式</target>
        </trans-unit>
        <trans-unit id="ce553dbefd4b35500c8adfaf562f347bd1cffaf1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.3. Omit hyphens and colons. &quot;The basic format should be avoided in plain text.&quot;</source>
          <target state="translated">ISO 8601:2004(E)第2.3.3节。省略连字符和冒号。&quot;在纯文本中应避免使用基本格式&quot;。</target>
        </trans-unit>
        <trans-unit id="5b73e3fe248bf6961ea567329e7f53034196b781" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 2.3.4. Use hyphens and colons.</source>
          <target state="translated">ISO 8601:2004(E)sec.2.3.4.使用连字符和冒号。</target>
        </trans-unit>
        <trans-unit id="ea6af556d4876a2b89f040fff7abb59f4dd0f4c1" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.2</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.2节。</target>
        </trans-unit>
        <trans-unit id="65fa90d60515a8ea4b8b6bba5111ddac2a89a577" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(a)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.3(a)节。</target>
        </trans-unit>
        <trans-unit id="b8e6c45635e6a6c7b99751a00199842c95a39f56" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(b)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.3(b)节。</target>
        </trans-unit>
        <trans-unit id="9b6b8fd39d751d5c0fc381e79557a67b538bd22a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.3(c)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.3(c)节。</target>
        </trans-unit>
        <trans-unit id="c7d58b1b77840944ae450aa457ab0e6e3c750344" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.4(a)节。</target>
        </trans-unit>
        <trans-unit id="50049f60c0a8e8cd5b1d15d9787aba4c4ae639f0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.4(b)节。</target>
        </trans-unit>
        <trans-unit id="d06f9cca67b57ce453f249d30d73e9c7f581681a" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.4(c)节。</target>
        </trans-unit>
        <trans-unit id="813aaac22f2045f777c991dc639bff2d89abd533" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.2.4(d)</source>
          <target state="translated">ISO 8601:2004(E)第4.1.2.4(d)节。</target>
        </trans-unit>
        <trans-unit id="72acd19bfc93f68e206e6c0d34917114a1fccd3e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.2</source>
          <target state="translated">ISO 8601:2004(E)第4.1.3.2节。</target>
        </trans-unit>
        <trans-unit id="3f13144d5ece5d74d8b6f96aa24edc61eeacd8ad" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.3.3</source>
          <target state="translated">ISO 8601:2004(E)第4.1.3.3节。</target>
        </trans-unit>
        <trans-unit id="9b6b94afc9edd9404ea266217015cf416121eae0" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.2</source>
          <target state="translated">ISO 8601:2004(E)第4.1.4.2节。</target>
        </trans-unit>
        <trans-unit id="a87736cb0c925b16cdeae6f6fe9b3e015c30590f" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.1.4.3</source>
          <target state="translated">ISO 8601:2004(E)第4.1.4.3节。</target>
        </trans-unit>
        <trans-unit id="bbcf342f586bebce46006d4c12d16ad8863024f4" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.2, 4.2.2.4(a)</source>
          <target state="translated">ISO 8601:2004(E)第4.2.2.2、4.2.2.4(a)节。</target>
        </trans-unit>
        <trans-unit id="b6b37624da200ed73cebb71eb0a89339f3a4fba3" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(a), 4.2.2.4(b)</source>
          <target state="translated">ISO 8601:2004(E)第4.2.2.3(a)、4.2.2.4(b)节。</target>
        </trans-unit>
        <trans-unit id="c55ad86d1327285d355a307898cd0bcedc64b2e7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.3(b), 4.2.2.4(c)</source>
          <target state="translated">ISO 8601:2004(E)秒。4.2.2.3(b)、4.2.2.4(c)</target>
        </trans-unit>
        <trans-unit id="8f67d771cf395b85785ef48de67f6dffa701c036" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.2.5</source>
          <target state="translated">ISO 8601:2004(E)秒。4.2.2.5</target>
        </trans-unit>
        <trans-unit id="07b435b23d42540df0b1bc985f1fa5204e769f0b" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.4</source>
          <target state="translated">ISO 8601:2004(E)秒。4.2.4</target>
        </trans-unit>
        <trans-unit id="4fcc52df4b38af082287f6513b315a63598a3982" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.1</source>
          <target state="translated">ISO 8601:2004(E)4.2.5.1节。</target>
        </trans-unit>
        <trans-unit id="5787fbc9eed85c23b6ba6c14fc91c92443851aa7" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.2.5.2</source>
          <target state="translated">ISO 8601:2004(E)4.2.5.2节。</target>
        </trans-unit>
        <trans-unit id="12305998507260debe9c8d6034797acfcba06193" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.2</source>
          <target state="translated">ISO 8601:2004(E)第4.3.2节。</target>
        </trans-unit>
        <trans-unit id="c5f903f7dfa61fd47c40e96852ca4df55e2a3b30" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.3.3</source>
          <target state="translated">ISO 8601:2004(E)第4.3.3节。</target>
        </trans-unit>
        <trans-unit id="9bfa7627b1b505b0fc50fefcc1d485389c084e49" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.2</source>
          <target state="translated">ISO 8601:2004(E)4.4.3.2节。</target>
        </trans-unit>
        <trans-unit id="2f0c4ca61d383b42003623a59e3a979e5caa4b98" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.3.3</source>
          <target state="translated">ISO 8601:2004(E)4.4.3.3节。</target>
        </trans-unit>
        <trans-unit id="fafc36b5bb91f4fa0ee5d27ebce4e786ca51d48d" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.4.4.1</source>
          <target state="translated">ISO 8601:2004(E)节4.4.4.1</target>
        </trans-unit>
        <trans-unit id="bbb017422d2f8d4d41f4efb11d499f43cec2368e" translate="yes" xml:space="preserve">
          <source>ISO 8601:2004(E) sec. 4.5</source>
          <target state="translated">ISO 8601:2004(E)秒。4.5</target>
        </trans-unit>
        <trans-unit id="0844a2bf2289652fa3443d5285683e93680df727" translate="yes" xml:space="preserve">
          <source>ISO/IEC 8859-1 (Char8)</source>
          <target state="translated">ISO/IEC 8859-1 (Char8)</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="c9cf1dd8147dc5d22c7365bdaa07b0903f6de420" translate="yes" xml:space="preserve">
          <source>ITQList</source>
          <target state="translated">ITQList</target>
        </trans-unit>
        <trans-unit id="45da9c6dee9536772c435a75e794212cc011b4e4" translate="yes" xml:space="preserve">
          <source>ITQNil</source>
          <target state="translated">ITQNil</target>
        </trans-unit>
        <trans-unit id="9a1703cf287a1d482c0b2abbe3bb64675ffdbe02" translate="yes" xml:space="preserve">
          <source>Ideally, this type would not exist at all and we would just fix the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance of &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">理想情况下，这种类型将根本不存在，我们只需修复 &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="ce1ef819f32725331a936d8af228a9ef343e2ecc" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt;, except that the return value does not include the function which maps keys to vertices. This version of &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; is for backwards compatibility.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; 相同，除了返回值不包括将键映射到顶点的函数。此版本的 &lt;code&gt;&lt;a href=&quot;data-graph#v:graphFromEdges&quot;&gt;graphFromEdges&lt;/a&gt;&lt;/code&gt; 用于向后兼容。</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">身份功能。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
