<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="ec7860e1d5ebe8e9fc316526773dd3897969d972" translate="yes" xml:space="preserve">
          <source>This adjusts all column numbers immediately after the pragma to start at 42. The presence of this pragma only affects the quality of the diagnostics and does not change the syntax of the code itself.</source>
          <target state="translated">这将调整所有列号,从42开始。这个参数的存在只影响诊断的质量,并不改变代码本身的语法。</target>
        </trans-unit>
        <trans-unit id="7a12a7ca1e45d66acaa328bb08f3c374962eb4c1" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;deriving&lt;/code&gt; a class instance for a type by specifying another type of equal runtime representation (such that there exists a &lt;code&gt;Coercible&lt;/code&gt; instance between the two: see &lt;a href=&quot;#coercible&quot;&gt;The Coercible constraint&lt;/a&gt;) that is already an instance of the that class.</source>
          <target state="translated">这允许通过指定另一种相等的运行时表示形式来 &lt;code&gt;deriving&lt;/code&gt; 类型的类实例（例如，在两者之间存在一个 &lt;code&gt;Coercible&lt;/code&gt; 实例：请参阅&lt;a href=&quot;#coercible&quot;&gt;Coercible约束&lt;/a&gt;），该已经是这个类的一个实例。</target>
        </trans-unit>
        <trans-unit id="1fb2d1ad05ed875ea28b9cb5da5c11c1ce3bedd9" translate="yes" xml:space="preserve">
          <source>This allows definitions that are polymorphic over record types with a specified field. For example, the following works with any record type that has a field &lt;code&gt;name :: String&lt;/code&gt;:</source>
          <target state="translated">这允许具有指定字段的记录类型具有多态的定义。例如，以下内容适用于任何具有字段 &lt;code&gt;name :: String&lt;/code&gt; 记录类型：</target>
        </trans-unit>
        <trans-unit id="ba36681397794a5e83833dc68b57c1526f4be113" translate="yes" xml:space="preserve">
          <source>This allows you to write shorter signatures:</source>
          <target state="translated">这允许你写更短的签名。</target>
        </trans-unit>
        <trans-unit id="7c38964da27b045ec2be9894b1df29221a7ceb88" translate="yes" xml:space="preserve">
          <source>This assumes that the library &lt;code&gt;libfoo.so&lt;/code&gt; is in the current directory and will be able to be found in the same directory as the executable &lt;code&gt;main&lt;/code&gt; once the program is deployed. Similarly it would be possible to use a subdirectory relative to the executable e.g. &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt;.</source>
          <target state="translated">这假定库 &lt;code&gt;libfoo.so&lt;/code&gt; 位于当前目录中，并且一旦部署了程序，便可以在与可执行文件 &lt;code&gt;main&lt;/code&gt; 所在的目录中找到该库。同样，可以使用相对于可执行文件的子目录，例如 &lt;code&gt;-optl-Wl,-rpath,'$ORIGIN/lib'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b85692b8edaa0b39863dc7b24b15416769ea56cf" translate="yes" xml:space="preserve">
          <source>This behaves as &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt;, except that a decimal point is always guaranteed, even if not needed.</source>
          <target state="translated">表现为 &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt;&lt;/code&gt; ，除了始终保证小数点（即使不需要）外。</target>
        </trans-unit>
        <trans-unit id="04fbb2fc7bba349478476c0924ff7c8bb5aaa853" translate="yes" xml:space="preserve">
          <source>This behavior differs from GHC's built-in Ctrl-C handling, which may immediately terminate the program after the second time that the user presses Ctrl-C.</source>
          <target state="translated">这种行为不同于GHC内置的Ctrl-C处理方式,它可能在用户第二次按下Ctrl-C后立即终止程序。</target>
        </trans-unit>
        <trans-unit id="13f6564d560839ab1b11893b1d1b1073914eb3f0" translate="yes" xml:space="preserve">
          <source>This behavior should suffice for most applications.</source>
          <target state="translated">这种行为对大多数应用来说应该是足够的。</target>
        </trans-unit>
        <trans-unit id="c633ca838f3fb91b35f5e358bad2a899b13f6caf" translate="yes" xml:space="preserve">
          <source>This behaviour depends on what it means for a key to be reachable. Informally, something is reachable if it can be reached by following ordinary pointers from the root set, but not following weak pointers. We define reachability more precisely as follows.</source>
          <target state="translated">这种行为取决于一个键的可到达性是什么意思。在非正式的情况下,如果某个东西可以通过根集的普通指针到达,但不能通过弱指针到达,那么它就是可到达的。我们将可到达性更精确地定义如下。</target>
        </trans-unit>
        <trans-unit id="be474662b261fe4c0cfb08eb9d9746ac9b512af6" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the &lt;code&gt;NondecreasingIndentation&lt;/code&gt; extension.</source>
          <target state="translated">此行为由 &lt;code&gt;NondecreasingIndentation&lt;/code&gt; 扩展控制。</target>
        </trans-unit>
        <trans-unit id="6a0488f978e785c4f8524e21bec6ad7590261c4c" translate="yes" xml:space="preserve">
          <source>This behaviour is implemented by &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt;) when the &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; option is set. In particular, the &lt;code&gt;SIGINT&lt;/code&gt; signal will be ignored until &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; returns (or &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; returns a non-Nothing result), so it becomes especially important to use &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; for every processes created.</source>
          <target state="translated">当设置了 &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt; = True&lt;/code&gt; = True选项时，此行为由 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; （和 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; ）实现。特别是， &lt;code&gt;SIGINT&lt;/code&gt; 信号将被忽略，直到 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 返回（或 &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; 返回非Nothing结果）为止，因此对每个创建的进程使用 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 变得尤为重要。</target>
        </trans-unit>
        <trans-unit id="551a466ddf545f274fdf0a190213c9133fda55d9" translate="yes" xml:space="preserve">
          <source>This behaviour is occasionally useful when controlling evaluation order. Notably, &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; is used in the library definition of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">在控制评估顺序时，此行为有时很有用。值得注意的是，在 &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; 的库定义中使用了 &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57d598a924d78189a09779d74b1038fed36775fe" translate="yes" xml:space="preserve">
          <source>This can all be encapsulated in a little script:</source>
          <target state="translated">这些都可以用一个小脚本来封装。</target>
        </trans-unit>
        <trans-unit id="416311d652a99e1b78b7cc2405506ab6d471421e" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="c52286f7e89bb4fb4f3c0e5035332585166c4a33" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="4751eaff9e7b3787ad6b9d21b46ac7636adad9a8" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="e7d4ce9fe92bac780f0fa78aae700d3bbb629ea6" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="621efad2402b4456bcde1c01e463d327dcf9db65" translate="yes" xml:space="preserve">
          <source>This can be an asymptotically faster than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; for some monoids.</source>
          <target state="translated">对于某些类 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldlWithKey&quot;&gt;foldlWithKey&lt;/a&gt;&lt;/code&gt; ，这可能比 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 或foldlWithKey渐近地更快。</target>
        </trans-unit>
        <trans-unit id="32f5dfbe5ae69f119a2bb8aa1f207219df30a02e" translate="yes" xml:space="preserve">
          <source>This can be compiled and run with:</source>
          <target state="translated">这可以用以下方法编译和运行。</target>
        </trans-unit>
        <trans-unit id="9115da4e5d66f067d2eb0a134175d944d3ff0263" translate="yes" xml:space="preserve">
          <source>This can be particularly useful for debugging: if your program is complaining about a &lt;code&gt;head []&lt;/code&gt; error and you haven&amp;rsquo;t got a clue which bit of code is causing it, compiling with &lt;code&gt;-prof -fprof-auto&lt;/code&gt; (see &lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt;) and running with &lt;code&gt;+RTS -xc
-RTS&lt;/code&gt; will tell you exactly the call stack at the point the error was raised.</source>
          <target state="translated">这对于调试特别有用：如果您的程序抱怨出现 &lt;code&gt;head []&lt;/code&gt; 错误，并且您不知道是哪段代码引起它， &lt;code&gt;-prof -fprof-auto&lt;/code&gt; 使用-prof -fprof-auto（请参阅&lt;a href=&quot;profiling#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;）进行编译并运行使用 &lt;code&gt;+RTS -xc -RTS&lt;/code&gt; 将在发生错误时准确地告诉您调用堆栈。</target>
        </trans-unit>
        <trans-unit id="96def13c000ed8fdbd0d21e559c3990a32470604" translate="yes" xml:space="preserve">
          <source>This can be used to retarget the standard Handles, for example:</source>
          <target state="translated">例如,这可以用来重新定位标准手柄。</target>
        </trans-unit>
        <trans-unit id="19cecadc905b14f14f3e42e92f83eba13e2b4315" translate="yes" xml:space="preserve">
          <source>This can be useful when you know that the expression being scrutinised has no non-bottom values. For example:</source>
          <target state="translated">当你知道被审查的表达式没有非底值时,这就很有用。例如</target>
        </trans-unit>
        <trans-unit id="d47b1d234066b1655177b94f7c3a67f89c058734" translate="yes" xml:space="preserve">
          <source>This can make a difference when the positive and negative range of a numeric data type don&amp;rsquo;t match up. For example, in 8-bit arithmetic -128 is representable, but +128 is not. So &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; will elicit an unexpected integer-literal-overflow message.</source>
          <target state="translated">当数值数据类型的正负范围不匹配时，这可能会有所不同。例如，在8位算术中，-128是可表示的，但+128不是。因此 &lt;code&gt;negate (fromInteger 128)&lt;/code&gt; 将引发意外的整数字面溢出消息。</target>
        </trans-unit>
        <trans-unit id="affbea3b51b202a931e180ff5123d3de0aa30798" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's background color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的背景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="7049fed78ee7c9e2705eacdcfa8deafff39f6093" translate="yes" xml:space="preserve">
          <source>This capability temporarily sets the terminal's foreground color while outputting the given text, and then restores the terminal to its default foreground and background colors.</source>
          <target state="translated">该功能在输出给定文本时临时设置终端的前景色,然后将终端恢复为默认的前景色和背景色。</target>
        </trans-unit>
        <trans-unit id="89a02b3d5ef05f9fc3fd28e4eec451dc3ff86763" translate="yes" xml:space="preserve">
          <source>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</source>
          <target state="translated">如果你有一个包含Template Haskell代码的多模块程序,并且你需要编译它进行剖析,这就会造成困难,因为GHC不能加载剖析过的对象代码并在执行拼接时使用它。</target>
        </trans-unit>
        <trans-unit id="3f1a7d74333974f609c76b0ab40dd62ceeaf6cfb" translate="yes" xml:space="preserve">
          <source>This change only applies to the main module. Other modules will still export &lt;code&gt;main&lt;/code&gt; from a default export list, regardless of the &lt;code&gt;-main-is&lt;/code&gt; flag. This allows use of &lt;code&gt;-main-is&lt;/code&gt; with existing modules that export &lt;code&gt;main&lt;/code&gt; via a default export list, even when &lt;code&gt;-main-is&lt;/code&gt; points to a different entry point, as in this example (compiled with &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt;).</source>
          <target state="translated">此更改仅适用于主模块。无论 &lt;code&gt;-main-is&lt;/code&gt; 标志如何，其他模块仍将从默认的导出列表中导出 &lt;code&gt;main&lt;/code&gt; 。这允许将 &lt;code&gt;-main-is&lt;/code&gt; 与通过默认导出列表导出 &lt;code&gt;main&lt;/code&gt; 的现有模块一起使用，即使 &lt;code&gt;-main-is&lt;/code&gt; 指向不同的入口点（如本示例中所述）（与 &lt;code&gt;-main-is MainWrapper.program&lt;/code&gt; 编译）也是如此。</target>
        </trans-unit>
        <trans-unit id="01542d372736818f19cef9c2f686e2c378bf0120" translate="yes" xml:space="preserve">
          <source>This class contains types where you can learn the equality of two types from information contained in &lt;em&gt;terms&lt;/em&gt;. Typically, only singleton types should inhabit this class.</source>
          <target state="translated">此类包含一些类型，您可以从&lt;em&gt;术语中&lt;/em&gt;包含的信息中学习两种类型的相等性。通常，只有单例类型可以居住在此类中。</target>
        </trans-unit>
        <trans-unit id="7d25d36771e3335063cfda8a370569be262e46f9" translate="yes" xml:space="preserve">
          <source>This class gives the integer associated with a type-level natural. There are instances of the class for every concrete literal: 0, 1, 2, etc.</source>
          <target state="translated">这个类给出了与类型级自然相关的整数。每一个具体的文字都有这个类的实例:0,1,2,等等。</target>
        </trans-unit>
        <trans-unit id="6cd7c40ac16e5fc8bee6ac08be5d6891bedfd9f7" translate="yes" xml:space="preserve">
          <source>This class gives the string associated with a type-level symbol. There are instances of the class for every concrete literal: &quot;hello&quot;, etc.</source>
          <target state="translated">这个类给出了与类型级符号相关联的字符串。每一个具体的文字符号都有该类的实例。&quot;hello&quot;,等等。</target>
        </trans-unit>
        <trans-unit id="4bb95279b9a76f4eb7b8bef88cb4f615842b9abb" translate="yes" xml:space="preserve">
          <source>This class is needed as a Haskell98 compatibility workaround for the lack of FlexibleInstances.</source>
          <target state="translated">这个类是作为缺乏FlexibleInstances的Haskell98兼容的变通方法而需要的。</target>
        </trans-unit>
        <trans-unit id="8618fe865486683e2da5d2b5c39277afb92c383b" translate="yes" xml:space="preserve">
          <source>This class is used in the translation of the recursive &lt;code&gt;do&lt;/code&gt; notation supported by GHC and Hugs.</source>
          <target state="translated">此类在GHC和Hugs支持的递归 &lt;code&gt;do&lt;/code&gt; 表示法的翻译中使用。</target>
        </trans-unit>
        <trans-unit id="ea1509b29993b854979a76c88a19d8658f8c383f" translate="yes" xml:space="preserve">
          <source>This class, with only the one instance, is used as a workaround for the fact that &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;, as a concrete type, is not allowable as a typeclass instance. &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; is exported for backward-compatibility.</source>
          <target state="translated">该类仅具有一个实例，被用作一种变通方法，以解决 &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 作为具体类型不允许作为typeclass实例的事实。导出 &lt;code&gt;&lt;a href=&quot;text-printf#t:IsChar&quot;&gt;IsChar&lt;/a&gt;&lt;/code&gt; 是为了向后兼容。</target>
        </trans-unit>
        <trans-unit id="3d0cfa10f6122f9ea4569e9917dc09cd908362b9" translate="yes" xml:space="preserve">
          <source>This code fragment should elicit a fatal error, but it does not:</source>
          <target state="translated">这个代码片段应该引起一个致命的错误,但它没有。</target>
        </trans-unit>
        <trans-unit id="307c94db0a4948761aff0e27f917047627954f03" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ed92185c6cf0333916ffd9559563724620e4e31" translate="yes" xml:space="preserve">
          <source>This code guarantees that &lt;code&gt;acquire&lt;/code&gt; is paired with &lt;code&gt;release&lt;/code&gt;, by masking asynchronous exceptions for the critical parts. (Rather than write this code yourself, it would be better to use &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; which abstracts the general pattern).</source>
          <target state="translated">此代码可以保证 &lt;code&gt;acquire&lt;/code&gt; 是搭配 &lt;code&gt;release&lt;/code&gt; ，通过屏蔽的关键部件异步异常。（而不是自己编写此代码，最好使用抽象一般模式的方 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fd2a2c6d2e7fd86b8c1811514153b5f08f749cfb" translate="yes" xml:space="preserve">
          <source>This combinator implements choice. The parser &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; first applies &lt;code&gt;p&lt;/code&gt;. If it succeeds, the value of &lt;code&gt;p&lt;/code&gt; is returned. If &lt;code&gt;p&lt;/code&gt; fails &lt;em&gt;without consuming any input&lt;/em&gt;, parser &lt;code&gt;q&lt;/code&gt; is tried. This combinator is defined equal to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; member of the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; class and the (&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) member of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该组合器实现选择。解析器 &lt;code&gt;p &amp;lt;|&amp;gt; q&lt;/code&gt; 首先应用 &lt;code&gt;p&lt;/code&gt; 。如果成功，则返回 &lt;code&gt;p&lt;/code&gt; 的值。如果 &lt;code&gt;p&lt;/code&gt; 失败&lt;em&gt;而不消耗任何输入&lt;/em&gt;，则尝试解析器 &lt;code&gt;q&lt;/code&gt; 。此组合子被定义等于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#v:mplus&quot;&gt;mplus&lt;/a&gt;&lt;/code&gt; 所述的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; 类和（ &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）的构件 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-applicative#v:Alternative&quot;&gt;Alternative&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f3ee763a42040e9ccebad9a7f214fbd1d7c3467" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="14c01988af41cdde7e895b21be33747a7bdbcf4f" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="89de4bf966a367ce5c9388562fe4c9b4408f046d" translate="yes" xml:space="preserve">
          <source>This combinator is expressed in terms of &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt;. It is used to accept user defined token streams. For example, suppose that we have a stream of basic tokens tupled with source positions. We can then define a parser that accepts single tokens as:</source>
          <target state="translated">该组合 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-prim#v:tokenPrim&quot;&gt;tokenPrim&lt;/a&gt;&lt;/code&gt; 表示。它用于接受用户定义的令牌流。例如，假设我们有一个带有源位置元组的基本令牌流。然后，我们可以定义一个接受单个标记的解析器，如下所示：</target>
        </trans-unit>
        <trans-unit id="1e5ad5170254164643045a2e82513b691609b5d4" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="333f51ec0b70600290728e38bbadbef215e2a2e6" translate="yes" xml:space="preserve">
          <source>This combinator is used whenever arbitrary look ahead is needed. Since it pretends that it hasn't consumed any input when &lt;code&gt;p&lt;/code&gt; fails, the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator will try its second alternative even when the first parser failed while consuming input.</source>
          <target state="translated">每当需要任意向前看时，都使用此组合器。因为它假装在 &lt;code&gt;p&lt;/code&gt; 失败时没有消耗任何输入，所以（ &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ）组合器将尝试第二种选择，即使第一个解析器在使用输入时失败了。</target>
        </trans-unit>
        <trans-unit id="28f1613af5414b6dfb871503c19a4aa1ba30ec6d" translate="yes" xml:space="preserve">
          <source>This command allows to request command completions from GHCi even when interacting over a pipe instead of a proper terminal and is designed for integrating GHCi&amp;rsquo;s completion with text editors and IDEs.</source>
          <target state="translated">即使通过管道而不是通过适当的终端进行交互，此命令也允许从GHCi请求命令完成，并且该命令旨在将GHCi的完成与文本编辑器和IDE集成在一起。</target>
        </trans-unit>
        <trans-unit id="2c0c68fd4f51cfec53bb7b1385354a15a0e4ce3f" translate="yes" xml:space="preserve">
          <source>This command is useful for highlighting and navigating all uses of an identifier in editors and IDEs.</source>
          <target state="translated">这条命令对于高亮显示和导航编辑器和IDE中标识符的所有用途非常有用。</target>
        </trans-unit>
        <trans-unit id="7b545a39643db7cee8ec309e9e67a7d52b03abd6" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a goto-definition facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个goto-definition设施。</target>
        </trans-unit>
        <trans-unit id="2eacd64caa5b6273684b41b06c7d8af5e0723ce8" translate="yes" xml:space="preserve">
          <source>This command is useful when integrating GHCi with text editors and IDEs for providing a show-type-under-point facility.</source>
          <target state="translated">当将GHCi与文本编辑器和IDE集成时,这个命令很有用,可以提供一个show-type-under-point设施。</target>
        </trans-unit>
        <trans-unit id="d47d493f7e230cc635856f431e77061767e3368c" translate="yes" xml:space="preserve">
          <source>This computation may fail with one of the following &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; exceptions:</source>
          <target state="translated">由于以下 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#v:IOErrorType&quot;&gt;IOErrorType&lt;/a&gt;&lt;/code&gt; 异常之一，此计算可能会失败：</target>
        </trans-unit>
        <trans-unit id="8b19a2ae0aec8ddd136b17fb7f698c57606d4262" translate="yes" xml:space="preserve">
          <source>This computation may fail with:</source>
          <target state="translated">这个计算可能会失败,因为:</target>
        </trans-unit>
        <trans-unit id="a67c6a10dac4821f810551e23532552de30c4f14" translate="yes" xml:space="preserve">
          <source>This concerns the interaction of foreign calls with &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt;. Normally when the target of a &lt;code&gt;throwTo&lt;/code&gt; is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (&lt;code&gt;SIGINT&lt;/code&gt; on Unix) is to raise the &lt;code&gt;UserInterrupt&lt;/code&gt; exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</source>
          <target state="translated">这涉及到外部呼叫与 &lt;code&gt;Control.Concurrent.throwTo&lt;/code&gt; 的交互。通常，当外部调用涉及 &lt;code&gt;throwTo&lt;/code&gt; 的目标时，在调用返回之前不会引发异常，与此同时，调用者也将被阻止。这可能会导致无响应，这在用户中断（例如Control-C）的情况下尤其不希望出现。当收到Control-C信号时（在Unix上为 &lt;code&gt;SIGINT&lt;/code&gt; ），默认行为是在主线程中引发 &lt;code&gt;UserInterrupt&lt;/code&gt; 异常；如果此时主线程在外部调用中被阻塞，则程序将不会响应用户中断。</target>
        </trans-unit>
        <trans-unit id="5007b6d693d171da9771256dfe1ecb2e1e3b194d" translate="yes" xml:space="preserve">
          <source>This condition is not checked by the types. You must ensure that the supplied values are valid total orderings yourself.</source>
          <target state="translated">这个条件不被类型检查。您必须确保所提供的值是自己有效的总订单。</target>
        </trans-unit>
        <trans-unit id="0e7153ef74e9b4f2ea52b3a0b09f27ad6452a548" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable, and adds line breaks between each of the strings in the input list.</source>
          <target state="translated">这将转换一个字符串,但保留了不可换行的空格,并在输入列表中的每个字符串之间添加换行符。</target>
        </trans-unit>
        <trans-unit id="c8e81237f627f581509f60a710986526096f03c3" translate="yes" xml:space="preserve">
          <source>This converts a string, but keeps spaces as non-line-breakable.</source>
          <target state="translated">这将转换一个字符串,但保留了不可断行的空格。</target>
        </trans-unit>
        <trans-unit id="20813c69f6fd04e90a0e74330c0f84f24f6a5905" translate="yes" xml:space="preserve">
          <source>This corresponds to the &lt;code&gt;show{E,F,G}Float&lt;/code&gt; operations provided by &lt;code&gt;base&lt;/code&gt;'s &lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt; module.</source>
          <target state="translated">这对应于 &lt;code&gt;base&lt;/code&gt; 的&lt;a href=&quot;../base-4.13.0.0/numeric&quot;&gt;Numeric&lt;/a&gt;模块提供的 &lt;code&gt;show{E,F,G}Float&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="307f56846d6abe441d853a9f036164d709972336" translate="yes" xml:space="preserve">
          <source>This currently enables</source>
          <target state="translated">目前,这使</target>
        </trans-unit>
        <trans-unit id="c40cef262ba41e4930517342a01fdf1bf324d546" translate="yes" xml:space="preserve">
          <source>This data type represents an equivalence relation.</source>
          <target state="translated">这种数据类型表示一个等价关系。</target>
        </trans-unit>
        <trans-unit id="403740310732ed8ffbeeeb04a65618a78cfc1a3e" translate="yes" xml:space="preserve">
          <source>This data type specifies operators that work on values of type &lt;code&gt;a&lt;/code&gt;. An operator is either binary infix or unary prefix or postfix. A binary operator has also an associated associativity.</source>
          <target state="translated">此数据类型指定可处理类型为 &lt;code&gt;a&lt;/code&gt; 的值的运算符。运算符可以是二进制中缀，也可以是一元前缀或后缀。二元运算符也具有关联性。</target>
        </trans-unit>
        <trans-unit id="854ccb088ba1be0b06f8e075236eff1e9da46cb3" translate="yes" xml:space="preserve">
          <source>This data type specifies the associativity of operators: left, right or none.</source>
          <target state="translated">此数据类型指定运算符的关联性:左、右或无。</target>
        </trans-unit>
        <trans-unit id="fd2eec063b807dbd9460c324b818af96f45fa26c" translate="yes" xml:space="preserve">
          <source>This data type witnesses the lifting of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; into an &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; pointwise.</source>
          <target state="translated">此数据类型见证了 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 向点 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Applicative&quot;&gt;Applicative&lt;/a&gt;&lt;/code&gt; 的提升。</target>
        </trans-unit>
        <trans-unit id="5d9cbd7fa738ca0ed212ab2c49dfe0d0e34fe8be" translate="yes" xml:space="preserve">
          <source>This datatype &lt;code&gt;G&lt;/code&gt; is GADT-like in both its kind and its type. Suppose you have &lt;code&gt;g :: G a&lt;/code&gt;, where &lt;code&gt;a :: k&lt;/code&gt;. Then pattern matching to discover that &lt;code&gt;g&lt;/code&gt; is in fact &lt;code&gt;GMaybe&lt;/code&gt; tells you both that &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; and &lt;code&gt;a ~ Maybe&lt;/code&gt;. The definition for &lt;code&gt;G&lt;/code&gt; requires that &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; be in effect, but pattern-matching on &lt;code&gt;G&lt;/code&gt; requires no extension beyond &lt;a href=&quot;#extension-GADTs&quot;&gt;&lt;code&gt;GADTs&lt;/code&gt;&lt;/a&gt;. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</source>
          <target state="translated">数据类型 &lt;code&gt;G&lt;/code&gt; 的类型和类型均类似于GADT。假设您有 &lt;code&gt;g :: G a&lt;/code&gt; ，其中 &lt;code&gt;a :: k&lt;/code&gt; 。然后，模式匹配，以发现 &lt;code&gt;g&lt;/code&gt; 其实 &lt;code&gt;GMaybe&lt;/code&gt; 告诉你们的是 &lt;code&gt;k ~ (Type -&amp;gt; Type)&lt;/code&gt; 和 &lt;code&gt;a ~ Maybe&lt;/code&gt; 。 &lt;code&gt;G&lt;/code&gt; 的定义要求&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;有效，但是 &lt;code&gt;G&lt;/code&gt; 上的模式匹配不需要扩展到&lt;a href=&quot;#extension-GADTs&quot;&gt; &lt;code&gt;GADTs&lt;/code&gt; &lt;/a&gt;之外。这项工作实际上是常规GADT的直接扩展，并且是种类和类型相同的事实的结果。</target>
        </trans-unit>
        <trans-unit id="fddbbdd897e55b76318f9d1cca047654361c5bf3" translate="yes" xml:space="preserve">
          <source>This datatype serves as the common interface for the buffer-by-buffer execution of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt;. Typical users of this interface are &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; or iteratee-style libraries like &lt;code&gt;enumerator&lt;/code&gt;.</source>
          <target state="translated">此数据类型作为用于缓冲器逐缓冲器执行的共同界面 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BuildStep&quot;&gt;BuildStep&lt;/a&gt;&lt;/code&gt; 通过 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:buildStepToCIOS&quot;&gt;buildStepToCIOS&lt;/a&gt;&lt;/code&gt; 。该接口的典型用户是 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:ciosToLazyByteString&quot;&gt;ciosToLazyByteString&lt;/a&gt;&lt;/code&gt; 或iteratee风格的库，例如 &lt;code&gt;enumerator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56687acac81b9ead68435c4a4dee9d86beae2f2f" translate="yes" xml:space="preserve">
          <source>This decoder has the downside that it will need to read all the input before it can return. On the other hand, it will not return anything until it knows it could decode without any decoder errors.</source>
          <target state="translated">这个解码器的缺点是,它需要在返回之前读取所有的输入。另一方面,它不会返回任何东西,直到它知道它可以在没有任何解码器错误的情况下进行解码。</target>
        </trans-unit>
        <trans-unit id="f05d3a9d17ae615893a0ee3e31137b4c35f2e2de" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the Operating System, where⟨os⟩ is the name of the current Operating System (eg. &lt;code&gt;linux&lt;/code&gt;, &lt;code&gt;mingw32&lt;/code&gt; for Windows, &lt;code&gt;solaris&lt;/code&gt;, etc.).</source>
          <target state="translated">该定义允许基于操作系统的条件编译，其中&amp;ldquo; os&amp;rdquo;是当前操作系统的名称（例如 &lt;code&gt;linux&lt;/code&gt; ，Windows的 &lt;code&gt;mingw32&lt;/code&gt; ， &lt;code&gt;solaris&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="b4bacbb553c9e44a0d9bbcbb895a594cbb329d2a" translate="yes" xml:space="preserve">
          <source>This define allows conditional compilation based on the host architecture, where⟨arch⟩ is the name of the current architecture (eg. &lt;code&gt;i386&lt;/code&gt;, &lt;code&gt;x86_64&lt;/code&gt;, &lt;code&gt;powerpc&lt;/code&gt;, &lt;code&gt;sparc&lt;/code&gt;, etc.).</source>
          <target state="translated">此定义允许基于主机体系结构进行条件编译，其中&amp;ldquo; arch&amp;rdquo;是当前体系结构的名称（例如 &lt;code&gt;i386&lt;/code&gt; ， &lt;code&gt;x86_64&lt;/code&gt; ， &lt;code&gt;powerpc&lt;/code&gt; ， &lt;code&gt;sparc&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="8da376069bf24510d754fbbf6944b4e0d8d617a3" translate="yes" xml:space="preserve">
          <source>This definition makes &lt;code&gt;f1&lt;/code&gt; is strict in &lt;code&gt;x&lt;/code&gt;, whereas without the bang it would be lazy. Bang patterns can be nested of course:</source>
          <target state="translated">这个定义使 &lt;code&gt;f1&lt;/code&gt; 在 &lt;code&gt;x&lt;/code&gt; 中严格，而如果没有爆炸声，它将是懒惰的。爆炸模式当然可以嵌套：</target>
        </trans-unit>
        <trans-unit id="7f1aeb089f33575b8e31f8c208c2176e6aae7a5d" translate="yes" xml:space="preserve">
          <source>This denotes a derived &lt;code&gt;Eq (Foo a)&lt;/code&gt; instance where the context is inferred, in much the same way that ordinary &lt;code&gt;deriving&lt;/code&gt; clauses do. Any other use of wildcards in a standalone &lt;code&gt;deriving&lt;/code&gt; declaration is prohibited.</source>
          <target state="translated">这表示在其中派生上下文的派生 &lt;code&gt;Eq (Foo a)&lt;/code&gt; 实例，其方式与普通 &lt;code&gt;deriving&lt;/code&gt; 子句相同。禁止在独立 &lt;code&gt;deriving&lt;/code&gt; 声明中使用通配符。</target>
        </trans-unit>
        <trans-unit id="f318c04181cccb638a071c5edca74556bdc192e3" translate="yes" xml:space="preserve">
          <source>This design gives the implementation of a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; full access to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. Therefore, utmost care has to be taken to not overwrite anything outside the given &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s. Moreover, further care has to be taken to ensure that &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s are referentially transparent. See the comments of the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; functions for further information. Note that there are &lt;em&gt;no safety belts&lt;/em&gt; at all, when implementing a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; using an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action: you are writing code that might enable the next buffer-overflow attack on a Haskell server!</source>
          <target state="translated">这种设计使 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的实现可以完全访问 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad。因此，必须 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 小心，不要覆盖给定BufferRange之外的任何内容。此外，还必须格外小心，以确保 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 是参照透明的。请参阅 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:builder&quot;&gt;builder&lt;/a&gt;&lt;/code&gt; 的注释并 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:put&quot;&gt;put&lt;/a&gt;&lt;/code&gt; 函数以获取更多信息。请注意，使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作实现 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 时&lt;em&gt;根本没有安全带&lt;/em&gt;：您正在编写代码，可能会在Haskell服务器上启用下一个缓冲区溢出攻击！</target>
        </trans-unit>
        <trans-unit id="b6e67cc35f8aec8824496322b8ea64c460e216a8" translate="yes" xml:space="preserve">
          <source>This distinction is important because of the way &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; works. The derived &lt;code&gt;Functor Right&lt;/code&gt; instance would be:</source>
          <target state="translated">由于&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; 的&lt;/a&gt;工作方式，这种区别很重要。派生的 &lt;code&gt;Functor Right&lt;/code&gt; 实例将是：</target>
        </trans-unit>
        <trans-unit id="e419b1a95765157bd22e384184d54ccedeb6347e" translate="yes" xml:space="preserve">
          <source>This does not embed any runtime paths. It relies on the shared libraries being available in a standard location or in a directory given by the &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">这不会嵌入任何运行时路径。它依赖于共享库在标准位置或 &lt;code id=&quot;index-3&quot;&gt;LD_LIBRARY_PATH&lt;/code&gt; 环境变量给定的目录中可用。</target>
        </trans-unit>
        <trans-unit id="5cb3f563b2d6d060f313310954206b9eb4d91af0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t work any more. Suppose module &lt;code&gt;C&lt;/code&gt; imports module &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;B&lt;/code&gt; imports module &lt;code&gt;A&lt;/code&gt;. So changes to module &lt;code&gt;A&lt;/code&gt; might require module &lt;code&gt;C&lt;/code&gt; to be recompiled, and hence when &lt;code&gt;A.hi&lt;/code&gt; changes we should check whether &lt;code&gt;C&lt;/code&gt; should be recompiled. However, the dependencies of &lt;code&gt;C&lt;/code&gt; will only list &lt;code&gt;B.hi&lt;/code&gt;, not &lt;code&gt;A.hi&lt;/code&gt;, and some changes to &lt;code&gt;A&lt;/code&gt; (changing the definition of a function that appears in an inlining of a function exported by &lt;code&gt;B&lt;/code&gt;, say) may conceivably not change &lt;code&gt;B.hi&lt;/code&gt; one jot. So now&amp;hellip;</source>
          <target state="translated">这不再起作用了。假设模块 &lt;code&gt;C&lt;/code&gt; 进口模块 &lt;code&gt;B&lt;/code&gt; ，和 &lt;code&gt;B&lt;/code&gt; 进口模块 &lt;code&gt;A&lt;/code&gt; 。因此，对模块 &lt;code&gt;A&lt;/code&gt; 的更改可能需要重新编译模块 &lt;code&gt;C&lt;/code&gt; ，因此，在 &lt;code&gt;A.hi&lt;/code&gt; 更改时，我们应检查是否应重新编译 &lt;code&gt;C&lt;/code&gt; 。但是， &lt;code&gt;C&lt;/code&gt; 的依存关系只会列出 &lt;code&gt;B.hi&lt;/code&gt; ，而不 &lt;code&gt;A.hi&lt;/code&gt; ，并且可以想到，对 &lt;code&gt;A&lt;/code&gt; 的某些更改（更改出现在 &lt;code&gt;B&lt;/code&gt; 导出的函数的内联中的函数的定义）可能不会更改 &lt;code&gt;B.hi&lt;/code&gt; 一个记号。所以现在</target>
        </trans-unit>
        <trans-unit id="7bfd4c3de51cf005d444a055edf0fb4db0a787bb" translate="yes" xml:space="preserve">
          <source>This eliminates &lt;code&gt;bad&lt;/code&gt; because the variable &lt;code&gt;x&lt;/code&gt; would have a representation-polymorphic type.</source>
          <target state="translated">由于变量 &lt;code&gt;x&lt;/code&gt; 具有表示多态类型，因此消除了 &lt;code&gt;bad&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e073b87018c69ace3578175d2672805f9075ec44" translate="yes" xml:space="preserve">
          <source>This enables shortcutting at the assembly stage of the code generator. In simpler terms shortcutting means if a block of instructions A only consists of a unconditionally jump, we replace all jumps to A by jumps to the successor of A.</source>
          <target state="translated">这样就可以在代码生成器的汇编阶段实现快捷化。简单来说,捷径的意思是,如果一个指令块A只由一个无条件跳转组成,我们就用跳转到A的后继者来代替所有对A的跳转。</target>
        </trans-unit>
        <trans-unit id="165be7ce8b109bfbd86d5610feedbc506b067e28" translate="yes" xml:space="preserve">
          <source>This encoding never fails in either direction. However, encoding discards information, so encode followed by decode is not the identity.</source>
          <target state="translated">这种编码在任何一个方向上都不会失败。但是,编码会丢弃信息,所以编码之后的解码不是身份。</target>
        </trans-unit>
        <trans-unit id="a1d32279f371041a8dc0b3cfd88d94711705ab4d" translate="yes" xml:space="preserve">
          <source>This encoding uses the byte sequence &quot;xc0x80&quot; to represent NUL, and the string is NUL-terminated.</source>
          <target state="translated">该编码使用字节序列 &quot;xc0x80 &quot;表示NUL,字符串以NUL结尾。</target>
        </trans-unit>
        <trans-unit id="c979726ef060735bb7539760a55f4154c415c6fd" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the bifold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite structure to a single, monolithic result (e.g., &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用双折前的每一步之前将其强制转换为弱头正常形态，避免了否则会发生的团块聚集。这通常是您要严格将有限结构简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-bifoldable#v:bilength&quot;&gt;bilength&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="2d4057c16cbbf5083f061bdfcc0ac611c77fa920" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="b511b54734619f44cd095a6055d529fe732da6b9" translate="yes" xml:space="preserve">
          <source>This ensures that each step of the fold is forced to weak head normal form before being applied, avoiding the collection of thunks that would otherwise occur. This is often what you want to strictly reduce a finite list to a single, monolithic result (e.g. &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">这样可确保在应用折叠之前，将折痕的每一步都强制设为弱头正常形式，避免了否则会发生的团块堆积。这通常是您要严格将有限列表简化为单个整体结果（例如， &lt;code&gt;&lt;a href=&quot;data-list#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ）的原因。</target>
        </trans-unit>
        <trans-unit id="4d5075d0d48f60bf2df55fbf25ddfe3d362f68e5" translate="yes" xml:space="preserve">
          <source>This error message:</source>
          <target state="translated">这个错误信息。</target>
        </trans-unit>
        <trans-unit id="d57971845f914fc8e7952a0c50d5f61958617a4b" translate="yes" xml:space="preserve">
          <source>This establishes that the module is trusted, but the guarantee is provided by the module&amp;rsquo;s author. A client of this module then specifies that they trust the module author by specifying they trust the package containing the module. &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t restrict the module to the safe language. It does however restrict the resolution of overlapping instances to only allow &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;. It also allows the use of the safe import keyword.</source>
          <target state="translated">这样可以确定模块是受信任的，但是保证由模块的作者提供。然后，该模块的客户端通过指定他们信任包含该模块的程序包来指定他们信任该模块的作者。&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;并不将模块限制在安全语言范围内。但是，它确实限制了重叠实例的分辨率，只允许&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全重叠实例&lt;/a&gt;。它还允许使用安全导入关键字。</target>
        </trans-unit>
        <trans-unit id="098bdcff45c78b22c043ada54d082f7fb8d47c1f" translate="yes" xml:space="preserve">
          <source>This example gives a taste of how escape continuations work, shows a typical pattern for their usage.</source>
          <target state="translated">这个例子让我们了解了转义延续的工作原理,展示了它们的典型使用模式。</target>
        </trans-unit>
        <trans-unit id="84fa0b5a218eb5e7191af54121c7d7b565fbc4a1" translate="yes" xml:space="preserve">
          <source>This example is a cut-down version of the one in</source>
          <target state="translated">这个例子是一个缩减版的,在</target>
        </trans-unit>
        <trans-unit id="506546e36bb8f56d349ab946238c7fb79ce340a0" translate="yes" xml:space="preserve">
          <source>This example is equivalent to the much more complicated construction if we had directly used the &lt;code&gt;Type&lt;/code&gt; constructors.</source>
          <target state="translated">如果直接使用 &lt;code&gt;Type&lt;/code&gt; 构造函数，则此示例等效于复杂得多的构造。</target>
        </trans-unit>
        <trans-unit id="6c043be7b75a2841250a60e497debd443150f6b5" translate="yes" xml:space="preserve">
          <source>This example only requires &lt;code&gt;Functor&lt;/code&gt;, because it is translated into &lt;code&gt;(\x -&amp;gt;
not x) &amp;lt;$&amp;gt; m&lt;/code&gt;. A more complex example requires &lt;code&gt;Applicative&lt;/code&gt;,</source>
          <target state="translated">此示例仅需要 &lt;code&gt;Functor&lt;/code&gt; ，因为它被转换为 &lt;code&gt;(\x -&amp;gt; not x) &amp;lt;$&amp;gt; m&lt;/code&gt; 。一个更复杂的示例需要 &lt;code&gt;Applicative&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a94eb0f120e8bdc111cd5385f435ab44e125aa39" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isLeft&quot;&gt;isLeft&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="0c94687d5da90e34bfb3927839e9bbd9388dc2fe" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; might be used to avoid pattern matching when one does not care about the value contained in the constructor:</source>
          <target state="translated">此示例显示了当不关心构造函数中包含的值时，如何使用 &lt;code&gt;&lt;a href=&quot;data-either#v:isRight&quot;&gt;isRight&lt;/a&gt;&lt;/code&gt; 避免模​​式匹配：</target>
        </trans-unit>
        <trans-unit id="62177d27a7a3e8ceeabacc9aa7dc05774276f074" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;Document_Open&lt;/code&gt;/&lt;code&gt;Close&lt;/code&gt; functions of Microsoft Word, but provided &lt;code&gt;HsStart&lt;/code&gt; is called before the first function, and &lt;code&gt;HsEnd&lt;/code&gt; after the last, then it will work fine.</source>
          <target state="translated">本例使用 &lt;code&gt;Document_Open&lt;/code&gt; / &lt;code&gt;Close&lt;/code&gt; 的Microsoft Word的功能，但提供 &lt;code&gt;HsStart&lt;/code&gt; 是第一个函数之前调用， &lt;code&gt;HsEnd&lt;/code&gt; 在最后，那么它会正常工作。</target>
        </trans-unit>
        <trans-unit id="3f669b13481ffa255adda9955123bc437e201059" translate="yes" xml:space="preserve">
          <source>This example was adapted from the original Concurrent Haskell paper. For more examples of &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s being used to build higher-level synchronization primitives, see &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此示例改编自原始的Concurrent Haskell论文。有关用于构建高级同步原语的 &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; 的更多示例，请参见 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:Chan&quot;&gt;Chan&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:QSem&quot;&gt;QSem&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dc923a7a79fc9be19231d8ba524edadbe4be72c" translate="yes" xml:space="preserve">
          <source>This exception doesn&amp;rsquo;t apply to statements, as the following example demonstrates:</source>
          <target state="translated">此异常不适用于语句，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="9cc4ef0f0e328db3ea146385deedff51e66652da" translate="yes" xml:space="preserve">
          <source>This exception is raised by another thread calling &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt;, or by the system if it needs to terminate the thread for some reason.</source>
          <target state="translated">另一个调用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:killThread&quot;&gt;killThread&lt;/a&gt;&lt;/code&gt; 的线程会引发此异常，如果系统由于某种原因需要终止该线程，则会引发该异常。</target>
        </trans-unit>
        <trans-unit id="88b1b0d0ae7fe196ea09d9cc1c250ca0eba66f4e" translate="yes" xml:space="preserve">
          <source>This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console).</source>
          <target state="translated">当用户通过通常的机制(例如控制台中的Control-C)请求终止程序时,程序的主线程会默认引发这个异常。</target>
        </trans-unit>
        <trans-unit id="eebf4adb6b800334ed146e927debde78229a6d82" translate="yes" xml:space="preserve">
          <source>This extension allows programmers to use the list notation for construction of structures like: &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;IntMap&lt;/code&gt;, &lt;code&gt;Vector&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt;. The following code listing gives a few examples:</source>
          <target state="translated">此扩展允许程序员使用列表符号构造结构，例如： &lt;code&gt;Set&lt;/code&gt; ， &lt;code&gt;Map&lt;/code&gt; ， &lt;code&gt;IntMap&lt;/code&gt; ， &lt;code&gt;Vector&lt;/code&gt; ， &lt;code&gt;Text&lt;/code&gt; 和 &lt;code&gt;Array&lt;/code&gt; 。下面的代码清单给出了一些示例：</target>
        </trans-unit>
        <trans-unit id="63b44c441eed758583d814d0941c5ed9943a1a63" translate="yes" xml:space="preserve">
          <source>This extension allows us to write constraints of the form &lt;code&gt;forall b. Eq b =&amp;gt;
Eq (f b)&lt;/code&gt;, which is needed to solve the &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; constraint arising from the second usage of the &lt;code&gt;(==)&lt;/code&gt; method.</source>
          <target state="translated">此扩展名使我们可以编写形式为 &lt;code&gt;forall b. Eq b =&amp;gt; Eq (f b)&lt;/code&gt; 约束。Eq b =&amp;gt; Eq（fb），这是解决因 &lt;code&gt;(==)&lt;/code&gt; 方法的第二次使用而引起的 &lt;code&gt;Eq (f (Rose f x))&lt;/code&gt; 约束所必需的。</target>
        </trans-unit>
        <trans-unit id="b0185c0a43dd28be6c507c23e1072cce8239ed47" translate="yes" xml:space="preserve">
          <source>This extension also enables explicit quantification of type and kind variables in &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;, &lt;a href=&quot;#type-instance-declarations&quot;&gt;Type instance declarations&lt;/a&gt;, &lt;a href=&quot;#closed-type-families&quot;&gt;Closed type families&lt;/a&gt;, &lt;a href=&quot;#assoc-inst&quot;&gt;Associated instances&lt;/a&gt;, and &lt;a href=&quot;#rewrite-rules&quot;&gt;Rewrite rules&lt;/a&gt;.</source>
          <target state="translated">此扩展还可以显式量化&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明&lt;/a&gt;，&lt;a href=&quot;#type-instance-declarations&quot;&gt;类型实例声明&lt;/a&gt;，&lt;a href=&quot;#closed-type-families&quot;&gt;封闭类型系列&lt;/a&gt;，&lt;a href=&quot;#assoc-inst&quot;&gt;关联实例&lt;/a&gt;和&lt;a href=&quot;#rewrite-rules&quot;&gt;重写规则中&lt;/a&gt;的类型和种类变量。</target>
        </trans-unit>
        <trans-unit id="f57565b543c045853c70ad6371daaf2f3c3e748c" translate="yes" xml:space="preserve">
          <source>This extension enables kind signatures in the following places:</source>
          <target state="translated">该扩展可以在以下地方进行种类签名:</target>
        </trans-unit>
        <trans-unit id="0b01b463ed5cbb063609e83a7f4a0cd2c9f0773a" translate="yes" xml:space="preserve">
          <source>This extension generalizes &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt;. To derive &lt;code&gt;Num Unicode&lt;/code&gt; with GND (&lt;code&gt;deriving newtype Num&lt;/code&gt;) it must reuse the &lt;code&gt;Num Int&lt;/code&gt; instance. With &lt;code&gt;DerivingVia&lt;/code&gt;, we can explicitly specify the representation type &lt;code&gt;Int&lt;/code&gt;:</source>
          <target state="translated">此扩展概括了&lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt;。要使用GND 派生 &lt;code&gt;Num Unicode&lt;/code&gt; （ &lt;code&gt;deriving newtype Num&lt;/code&gt; ），它必须重用 &lt;code&gt;Num Int&lt;/code&gt; 实例。使用 &lt;code&gt;DerivingVia&lt;/code&gt; ，我们可以显式指定表示类型 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9ff362e6ce2b0d8092c35b1a623732b4842ee02e" translate="yes" xml:space="preserve">
          <source>This extension is enabled by default since GHC 8.6.1, under the &lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail Proposal (MFP)&lt;/a&gt;.</source>
          <target state="translated">自GHC 8.6.1起，在&lt;a href=&quot;https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail&quot;&gt;MonadFail提案（MFP）&lt;/a&gt;下默认启用此扩展。</target>
        </trans-unit>
        <trans-unit id="db2c878062f2c6f99bf839e6b59f2f657c40d838" translate="yes" xml:space="preserve">
          <source>This extension is temporary, and will be deprecated in a future release.</source>
          <target state="translated">这个扩展是暂时的,并将在未来的版本中被废弃。</target>
        </trans-unit>
        <trans-unit id="51aed31ab5dc37f8c4c608df090d56016afc9279" translate="yes" xml:space="preserve">
          <source>This feature is experimental in GHC 8.0.x, but it may become the default in future releases.</source>
          <target state="translated">这个功能在GHC 8.0.x中是试验性的,但在未来的版本中可能会成为默认的。</target>
        </trans-unit>
        <trans-unit id="248986ebd9528e7c25e52eb6e4b4dede26b21415" translate="yes" xml:space="preserve">
          <source>This feature is no longer in GHC, but rewrite rules let you do the same thing:</source>
          <target state="translated">这个功能在GHC中已经没有了,但是重写规则可以让你做同样的事情。</target>
        </trans-unit>
        <trans-unit id="53f2d728a4138ae527fa096fa51af75f94d85b2c" translate="yes" xml:space="preserve">
          <source>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC developer wiki&lt;/a&gt;.</source>
          <target state="translated">此功能不适用于GHC随附的核心库之外。有关更多详细信息，请参见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/Commentary/PrimOps&quot;&gt;GHC开发人员Wiki&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2a0010dea23f4d2c3a5e18529c4edce4ab678e9" translate="yes" xml:space="preserve">
          <source>This feature was added in GHC 7.4.1.</source>
          <target state="translated">这个功能是在GHC 7.4.1中加入的。</target>
        </trans-unit>
        <trans-unit id="55b7950f0dfe4e76a8ae330af2ece8c8a531dce2" translate="yes" xml:space="preserve">
          <source>This flag also enables the printing of &lt;em&gt;inferred&lt;/em&gt; type variables inside braces. See &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;.</source>
          <target state="translated">此标志还允许在括号内打印&lt;em&gt;推断的&lt;/em&gt;类型变量。请参阅&lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;推断类型变量与指定类型变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b07b2f670bc045df573c1ececcdcb07736068e4d" translate="yes" xml:space="preserve">
          <source>This flag appends a colon-separated list of &lt;code&gt;dirs&lt;/code&gt; to the search path.</source>
          <target state="translated">该标志将以冒号分隔的 &lt;code&gt;dirs&lt;/code&gt; 列表附加到搜索路径。</target>
        </trans-unit>
        <trans-unit id="b10d8784b554d32814d37717727898e2e17029f6" translate="yes" xml:space="preserve">
          <source>This flag can be enabled to override any declared safety property of the module (Safe, Unsafe, Trustworthy) so compilation proceeds as if none of these flags were specified. This is particularly useful when compiling using plugins, which usually results in the compiled modules being marked as unsafe.</source>
          <target state="translated">这个标志可以被启用,以覆盖模块的任何声明的安全属性(Safe,Unsafe,Trustworthy),这样编译就会像没有指定这些标志一样进行。这在使用插件编译时特别有用,因为这通常会导致编译后的模块被标记为不安全。</target>
        </trans-unit>
        <trans-unit id="24dac7bf8e47224079c398a6d277a8612ab70ec9" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to decrease the verbosity of the valid hole fit suggestions by not showing the provenance nor type application of the suggestions.</source>
          <target state="translated">这个标志可以被切换,通过不显示建议的出处或类型应用来降低有效孔配合建议的啰嗦程度。</target>
        </trans-unit>
        <trans-unit id="65ce608eee3aba6eebf0d253b9eec2e8fe86f19e" translate="yes" xml:space="preserve">
          <source>This flag can be toggled to turn off the display of valid hole fits entirely.</source>
          <target state="translated">这个标志可以被切换到完全关闭有效孔配合的显示。</target>
        </trans-unit>
        <trans-unit id="090f73c78c09543d9d38b2c5a37d696699bd497f" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; flags, which enables this behaviour for &lt;a href=&quot;#typed-holes&quot;&gt;typed holes&lt;/a&gt; and variables. Should you so wish, it is possible to enable &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; without enabling &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;, by explicitly specifying &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fno-defer-typed-holes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt; on the command-line after the &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">该标志暗示&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;标志，这使&lt;a href=&quot;#typed-holes&quot;&gt;键入孔&lt;/a&gt;和变量具有此行为。如果您愿意，可以通过显式指定&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fno-defer-typed-holes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fno-defer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;来启用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;而不启用&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;-fdefer- &lt;a href=&quot;using-warnings#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt;标志后，在命令行上将-defer-out-of-scope-variables放在命令行上。</target>
        </trans-unit>
        <trans-unit id="8a419a9746c4cf7f690ae762b4c975fdd0783957" translate="yes" xml:space="preserve">
          <source>This flag is hacker territory. The main purpose of this flag is to make it easy to debug and tune the new code layout algorithm. There is no guarantee that values giving better results now won&amp;rsquo;t be worse with the next release.</source>
          <target state="translated">该标志是黑客的领土。该标志的主要目的是使调试和调试新代码布局算法变得容易。无法保证在下一个发行版中提供更好结果的值现在不会变差。</target>
        </trans-unit>
        <trans-unit id="4f00c8bb7e27cc51ca8b0f0d3dba471e43e3c711" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a definition is not inlined.</source>
          <target state="translated">这个标志对于调试为什么定义没有内联很有用。</target>
        </trans-unit>
        <trans-unit id="259f9f5ba8da11cbb10f0d1540dcc3a2d81b3b63" translate="yes" xml:space="preserve">
          <source>This flag is useful for debugging why a rule you expect to be firing isn&amp;rsquo;t.</source>
          <target state="translated">该标志对于调试为什么不希望触发的规则很有用。</target>
        </trans-unit>
        <trans-unit id="0d8510f05be6657462af6908558e01f9535cc7df" translate="yes" xml:space="preserve">
          <source>This flag passes &lt;code&gt;-Wundef&lt;/code&gt; to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the &lt;code&gt;#if&lt;/code&gt; directive on undefined identifiers.</source>
          <target state="translated">该标志将 &lt;code&gt;-Wundef&lt;/code&gt; 传递给C预处理器（如果正在使用它），这会导致预处理器警告在未定义标识符上使用 &lt;code&gt;#if&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="1da039cc7b4dc5b7877656e448f679fa2aaf620b" translate="yes" xml:space="preserve">
          <source>This flag selects one of a number of modes for finding shared libraries at runtime. See &lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;Finding shared libraries at runtime&lt;/a&gt; for a description of each mode.</source>
          <target state="translated">该标志选择多种模式之一，以在运行时查找共享库。有关每种模式的说明，请参见&lt;a href=&quot;shared_libs#finding-shared-libs&quot;&gt;在运行时查找共享库&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd5e5d63941b332238370339bd4abcd493f7faf1" translate="yes" xml:space="preserve">
          <source>This flag specifies that a backspace at column 0 wraps the cursor to the last column of the previous line.</source>
          <target state="translated">这个标志指定在第0列的退格将光标包到前一行的最后一列。</target>
        </trans-unit>
        <trans-unit id="03626a7094edacd615db3da035980eaa87b66cfc" translate="yes" xml:space="preserve">
          <source>This flag specifies that the cursor wraps automatically from the last column of one line to the first column of the next.</source>
          <target state="translated">这个标志指定光标从一行的最后一列自动缠绕到下一行的第一列。</target>
        </trans-unit>
        <trans-unit id="152fd56bf497fbd287fadf04927a68a1b45161ca" translate="yes" xml:space="preserve">
          <source>This flag specifies that the terminal does not perform &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt;-style wrapping when the character which would cause the wraparound is a control character. This is also known as the &quot;newline glitch&quot; or &quot;magic wrap&quot;.</source>
          <target state="translated">当可能导致环绕的字符是控制字符时，此标志指定终端不执行 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-cursor#v:autoRightMargin&quot;&gt;autoRightMargin&lt;/a&gt;&lt;/code&gt; 样式的环绕。这也称为&amp;ldquo;换行故障&amp;rdquo;或&amp;ldquo;魔术包&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="237ea7657c0749769ad0460f79b1ebe14776910d" translate="yes" xml:space="preserve">
          <source>This flag tells GHC to link against shared Haskell libraries. This flag only affects the selection of dependent libraries, not the form of the current target (see -shared). See &lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;Using shared libraries&lt;/a&gt; on how to create them.</source>
          <target state="translated">该标志告诉GHC链接共享的Haskell库。该标志仅影响选择依赖库，而不影响当前目标的形式（请参见-shared）。有关如何创建&lt;a href=&quot;shared_libs#using-shared-libs&quot;&gt;共享库的信息&lt;/a&gt;，请参见使用共享库。</target>
        </trans-unit>
        <trans-unit id="548eff16b1f921e7136ec0c8b1d05c12f1aee8db" translate="yes" xml:space="preserve">
          <source>This flag used to be simply &lt;code&gt;-k&lt;/code&gt;, but was renamed to &lt;code&gt;-ki&lt;/code&gt; in GHC 7.2.1. The old name is still accepted for backwards compatibility, but that may be removed in a future version.</source>
          <target state="translated">该标志以前只是 &lt;code&gt;-k&lt;/code&gt; ，但在GHC 7.2.1中被重命名为 &lt;code&gt;-ki&lt;/code&gt; 。为了向后兼容，仍接受旧名称，但将来的版本中可能会删除该旧名称。</target>
        </trans-unit>
        <trans-unit id="132a6f0fb187f19db841ab54e53adaeca2ba441f" translate="yes" xml:space="preserve">
          <source>This flag warns if you declare a module without declaring an explicit export list. For example</source>
          <target state="translated">如果您声明一个模块而没有声明一个显式的导出列表,这个标志会发出警告。例如</target>
        </trans-unit>
        <trans-unit id="c9662da7b45b17a0a6428b9dfe5bd157c250c8da" translate="yes" xml:space="preserve">
          <source>This flag warns if you use an unqualified &lt;code&gt;import&lt;/code&gt; declaration that does not explicitly list the entities brought into scope. For example</source>
          <target state="translated">如果您使用不显式列出带入范围的实体的不合格 &lt;code&gt;import&lt;/code&gt; 声明，则该标志会发出警告。例如</target>
        </trans-unit>
        <trans-unit id="164c1b4e302cfd37b98b634159b85132a613d2b3" translate="yes" xml:space="preserve">
          <source>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See &lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;Unboxed types&lt;/a&gt; for information about unlifted types.</source>
          <target state="translated">每当您编写一个模式来绑定一个类型不为实的变量时，该标志都会发出警告，但该模式既不是爆炸模式也不是裸变量。有关未&lt;a href=&quot;glasgow_exts#glasgow-unboxed&quot;&gt;提升类型&lt;/a&gt;的信息，请参见未装箱类型。</target>
        </trans-unit>
        <trans-unit id="a0c3352dc95a1207a9c6e17148992da28a73903b" translate="yes" xml:space="preserve">
          <source>This form is intended to catch cases where an imported function that is marked as &lt;code&gt;INLINABLE&lt;/code&gt; (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</source>
          <target state="translated">该表格旨在解决那些被标记为 &lt;code&gt;INLINABLE&lt;/code&gt; （可能启用专门化）的导入函数无法专门化的情况，因为它调用了本身未专门化的其他函数。</target>
        </trans-unit>
        <trans-unit id="05bd3fd9bbf23e07af768726368e949e8e01172d" translate="yes" xml:space="preserve">
          <source>This form is similar to the previous one, but allows you to create a function which will be passed as the first argument to f. As a consequence f must have the type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;. As you can see from the type, this function lets f &amp;ldquo;project out&amp;rdquo; some information from the elements of the list it is transforming.</source>
          <target state="translated">这种形式类似于前一种形式，但是允许您创建一个函数，该函数将作为第一个参数传递给f。因此，f必须具有所有类型 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; 。从类型可以看到，此函数使f从正在转换的列表元素中&amp;ldquo;投影&amp;rdquo;一些信息。</target>
        </trans-unit>
        <trans-unit id="b210b3ae2d9ae56e35b1c184f6366fb5e908d874" translate="yes" xml:space="preserve">
          <source>This function accepts an optional leading sign character, followed by at least one decimal digit. The syntax similar to that accepted by the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function, with the exception that a trailing &lt;code&gt;'.'&lt;/code&gt; or &lt;code&gt;'e'&lt;/code&gt;&lt;em&gt;not&lt;/em&gt; followed by a number is not consumed.</source>
          <target state="translated">此函数接受可选的前导符号字符，后接至少一个十进制数字。语法类似于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/text-read#v:read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 函数接受的语法，但末尾带有 &lt;code&gt;'.'&lt;/code&gt; 或&lt;em&gt;不&lt;/em&gt;加数字的 &lt;code&gt;'e'&lt;/code&gt; &lt;em&gt;不会&lt;/em&gt;被使用。</target>
        </trans-unit>
        <trans-unit id="a796cd8e434fa9169ce349d782e3ca0927d44d88" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 中。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="2c44cb1ccf0b7e4784ceeb306a067bdfeb7b206c" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given &lt;code&gt;ForeignPtr&lt;/code&gt;. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的 &lt;code&gt;ForeignPtr&lt;/code&gt; 中。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="f425649d9029247ad78fad40decd5202c4bc27eb" translate="yes" xml:space="preserve">
          <source>This function adds a finalizer to the given foreign object. The finalizer will run &lt;em&gt;before&lt;/em&gt; all other finalizers for the same object which have already been registered.</source>
          <target state="translated">此函数将终结器添加到给定的异物。终结器将&lt;em&gt;在&lt;/em&gt;已注册的同一对象的所有其他终结器&lt;em&gt;之前&lt;/em&gt;运行。</target>
        </trans-unit>
        <trans-unit id="f81d22635890e3a218f1ce58339b1c6ca6b2b5e3" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the current thread's event manager when using the threaded RTS and &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">使用线程的RTS时，此函数始终 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; 返回当前线程的事件管理器，否则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a7ca54d1ebb1f65a298f3f5394187b62319bd58" translate="yes" xml:space="preserve">
          <source>This function behaves as though it was defined as follows:</source>
          <target state="translated">这个函数的行为就像它的定义一样。</target>
        </trans-unit>
        <trans-unit id="a19a74c60710c427c9a8983f923cfe3116f4e33e" translate="yes" xml:space="preserve">
          <source>This function behaves in the exact same manner as &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt;, except that it pre-populates the input area. The text that resides in the input area is given as a 2-tuple with two &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;s. The string on the left of the tuple (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;) is what will appear to the left of the cursor and the string on the right (obtained by calling &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt;) is what will appear to the right of the cursor.</source>
          <target state="translated">此函数的行为与 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:getInputLine&quot;&gt;getInputLine&lt;/a&gt;&lt;/code&gt; 完全相同，只是它会预先填充输入区域。驻留在输入区域中的文本以带有两个 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 的2元组给出。元组左侧的字符串（通过调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; 获得）将显示在游标的左侧，而右侧的字符串（通过调用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:snd&quot;&gt;snd&lt;/a&gt;&lt;/code&gt; 获得）将显示在游标的右侧。</target>
        </trans-unit>
        <trans-unit id="ccadaf8449c87b756fcca9de3051eea76595bb20" translate="yes" xml:space="preserve">
          <source>This function blocks only if there is no data available, and EOF has not yet been reached. Once EOF is reached, this function returns an empty string instead of throwing an exception.</source>
          <target state="translated">这个函数只有在没有数据可用,并且尚未达到EOF时才会阻塞。一旦达到EOF,这个函数将返回一个空字符串,而不是抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="3727686d1f0656f78fbd676216e6218bba0d8f05" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">该函数比 &lt;code&gt;&lt;a href=&quot;system-filepath-posix#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 更具可预测性，尤其是在文件名本身可能包含的情况下 &lt;code&gt;.&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="95f9843654954e98c26a755ad5eb70155e80d09e" translate="yes" xml:space="preserve">
          <source>This function can be more predictable than &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt;, especially if the filename might itself contain &lt;code&gt;.&lt;/code&gt; characters.</source>
          <target state="translated">该函数比 &lt;code&gt;&lt;a href=&quot;system-filepath-windows#v:dropExtensions&quot;&gt;dropExtensions&lt;/a&gt;&lt;/code&gt; 更具可预测性，尤其是在文件名本身可能包含的情况下 &lt;code&gt;.&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="6370e62b7224731eb33323a61cd0cd0212bd73ab" translate="yes" xml:space="preserve">
          <source>This function can be used to parse commandline arguments and return the split up arguments as elements in a list.</source>
          <target state="translated">这个函数可以用来解析命令行参数,并将拆分后的参数作为列表中的元素返回。</target>
        </trans-unit>
        <trans-unit id="7b011ec479c4f18015f65a01a6cb42ad6c894e37" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="8455333cef6a211c11d46770009f2e17b149dc91" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="4c95a06b11246310d156afc3703af8aa75228ea4" translate="yes" xml:space="preserve">
          <source>This function casts a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; parameterised by one type into another type.</source>
          <target state="translated">此函数将由一种类型参数化的 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 转换为另一种类型。</target>
        </trans-unit>
        <trans-unit id="bae8bc388aa8fda5c095416ea7ccdf604e21a4b9" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3b38848479394206747ac44eca6fc387251ec91" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-lazy-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-lazy-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5db91917bf331211a29772aa52154e422f3f1d5b" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="519eb4a4b4c327867fd23f6eab3128242f48c9bb" translate="yes" xml:space="preserve">
          <source>This function does not handle leading sign characters. If you need to handle signed input, use &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能不处理前导符号字符。如果需要处理带符号的输入，请使用带 &lt;code&gt;&lt;a href=&quot;data-text-read#v:signed&quot;&gt;signed&lt;/a&gt; &lt;a href=&quot;data-text-read#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="857206c786beb79b34c3684c023645a579f1bf0a" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">此函数执行零复制，并且仅将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 展开以显示为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; 。这有两种方式是&lt;em&gt;不安全的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="0c2f12c1f574e8470c8cd228760ee018fd8aa95d" translate="yes" xml:space="preserve">
          <source>This function does zero copying, and merely unwraps a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; to appear as a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt;. It is &lt;em&gt;unsafe&lt;/em&gt;:</source>
          <target state="translated">此函数执行零复制，并且仅将 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 展开以显示为 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; 。这是&lt;em&gt;不安全的&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="f085bd357a8ba52ec5bf8ea2e8098bb00f21c4f3" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="fb2f540bf09969c8d0c8f8908ba854010bd23f1b" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="2149a9af262bcc49b7038b2f4d5b65dcac58accb" translate="yes" xml:space="preserve">
          <source>This function ensures that the foreign object in question is alive at the given place in the sequence of IO actions. In particular &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; after it executes the user action.</source>
          <target state="translated">该功能可确保所涉及的异物在IO操作序列中的给定位置上仍处于活动状态。特别 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 做了 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 它执行用户操作之后。</target>
        </trans-unit>
        <trans-unit id="56e6ded1b8cebed967e3f67bfe07578a6914f462" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">此函数提取外部指针的指针组件。这是一个潜在的危险操作，好像 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 的参数是给定外来指针的最后一次使用，则将运行其终结器，这可能会使刚获得的普通指针无效。因此，必须在必须保证指针位于其上的任何地方（即发生另一次使用情况） &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 必须使用touchForeignPtr。</target>
        </trans-unit>
        <trans-unit id="49a9ef9954f7355cd3182b557ae76bf73f873f39" translate="yes" xml:space="preserve">
          <source>This function extracts the pointer component of a foreign pointer. This is a potentially dangerous operations, as if the argument to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; is the last usage occurrence of the given foreign pointer, then its finalizer(s) will be run, which potentially invalidates the plain pointer just obtained. Hence, &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; must be used wherever it has to be guaranteed that the pointer lives on - i.e., has another usage occurrence.</source>
          <target state="translated">此函数提取外部指针的指针组件。这是一个潜在的危险操作，好像 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 的参数是给定外来指针的最后一次使用，则将运行其终结器，这可能会使刚获得的普通指针无效。因此，必须在必须保证指针位于其上的任何地方（即发生另一次使用情况） &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 必须使用touchForeignPtr。</target>
        </trans-unit>
        <trans-unit id="297ce1fcde50c3e64b2e180ca7a8295dfe927277" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">此功能给出的答案与将结果与 &lt;code&gt;&lt;a href=&quot;data-text#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 结果进行比较的结果相同，但是如果字符数大于数字，则可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="b9bfe488bf922598761ef0e89e23f74a82ced08d" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number or if the stream can't possibly be as long as the number supplied, and hence be more efficient.</source>
          <target state="translated">该函数给出的答案与将其与 &lt;code&gt;&lt;a href=&quot;data-text-internal-fusion-common#v:lengthI&quot;&gt;lengthI&lt;/a&gt;&lt;/code&gt; 的结果进行比较的结果相同，但是如果字符数大于数字或流的长度不能与所提供的数字一样长，则该函数可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="84c6fa989d414314e9aa49500aecc381f432a513" translate="yes" xml:space="preserve">
          <source>This function gives the same answer as comparing against the result of &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt;, but can short circuit if the count of characters is greater than the number, and hence be more efficient.</source>
          <target state="translated">此功能给出的答案与将结果与 &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 结果进行比较的结果相同，但是如果字符数大于数字，则可能会短路，因此效率更高。</target>
        </trans-unit>
        <trans-unit id="afb23fb6497a24d6ecb9c3763d5c34edba9c40d0" translate="yes" xml:space="preserve">
          <source>This function has been available from the &lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt; module for some time, and is part of the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module since version 1.2.1.0.</source>
          <target state="translated">此功能已在&lt;a href=&quot;system-process-internals&quot;&gt;System.Process.Internals&lt;/a&gt;模块中使用了一段时间，并且自1.2.1.0版以来是&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;模块的一部分。</target>
        </trans-unit>
        <trans-unit id="a6e9d76dad212825f2ce225dc9cdac55e8d4e959" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已移至 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTree&quot;&gt;showTree&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be411b927981a56314a00c20ba75fa59b5652a67" translate="yes" xml:space="preserve">
          <source>This function has moved to &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能已移至 &lt;code&gt;&lt;a href=&quot;data-map-internal-debug#v:showTreeWith&quot;&gt;showTreeWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c2e5206205cd6b75d161fb7bfc7299c5bdb8abf" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="1be0ffbb5619ad9aa9e30d9508745c85fb811ff4" translate="yes" xml:space="preserve">
          <source>This function has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="36afc198b9f7118549c1b6104d61dadd4fcd1cd4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt; in two ways:</source>
          <target state="translated">此功能有两种方式&lt;em&gt;不安全&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="e2a132e2c97ab0ed1a1b3a90355bbe48b412b6f7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, as there may be other &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s referring to the same underlying pages. If you use this, you need to have a proof of some kind that all &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s ever generated from the underlying byte array are no longer live.</source>
          <target state="translated">此函数是&lt;em&gt;不安全的&lt;/em&gt;，因为可能还有其他 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 引用相同的基础页面。如果使用此方法，则需要某种证明，即从基础字节数组生成的所有 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 都不再有效。</target>
        </trans-unit>
        <trans-unit id="bf420b59471bce124dbbd8b697170ee16a0713d7" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;, it is possible to break referential transparency by modifying the underlying buffer pointed to by the first argument. Any changes to the original buffer will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数&lt;em&gt;不安全&lt;/em&gt;，可以通过修改第一个参数指向的基础缓冲区来破坏引用透明性。对原始缓冲区的任何更改都将反映在结果 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3455262f8a39897a50aa39230052cbe6dba0d568" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果稍后修改了 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="e2747e624978d112ce90afa471f172dfb2b9cd31" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果后来修改了原始 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="f0382305dc3450f3e698022f8c72e2ed93bc7c33" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; is later modified, this change will be reflected in the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果后来修改了原始的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CStringLen&quot;&gt;CStringLen&lt;/a&gt;&lt;/code&gt; ，则此更改将反映在生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="4a191d5e90e0d3c89ab168efaec7413d2cd0acb4" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unsafe&lt;/em&gt;. If you modify the buffer pointed to by the original &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; this modification will be reflected in the resulting &lt;code&gt;ByteString&lt;/code&gt;, breaking referential transparency.</source>
          <target state="translated">此功能&lt;em&gt;不安全&lt;/em&gt;。如果修改原始 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; 指向的缓冲区，则此修改将反映在生成的 &lt;code&gt;ByteString&lt;/code&gt; 中，从而破坏了引用透明性。</target>
        </trans-unit>
        <trans-unit id="c9bb19123a210482015c0eb529407c8c92bd8a9d" translate="yes" xml:space="preserve">
          <source>This function is almost identical to &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt;. The only differences are:</source>
          <target state="translated">此功能几乎与 &lt;code&gt;&lt;a href=&quot;system-process#v:createProcess&quot;&gt;createProcess&lt;/a&gt;&lt;/code&gt; 相同。唯一的区别是：</target>
        </trans-unit>
        <trans-unit id="127b48d0ce942f2e91014031d7ba1b7c2f584c47" translate="yes" xml:space="preserve">
          <source>This function is also unsafe if you call its finalizer twice, which will result in a &lt;em&gt;double free&lt;/em&gt; error, or if you pass it a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; not allocated with &lt;code&gt;malloc&lt;/code&gt;.</source>
          <target state="translated">如果您两次调用它的终结器，则该函数也是不安全的，这将导致&lt;em&gt;双重释放&lt;/em&gt;错误，或者如果将其传递给未分配 &lt;code&gt;malloc&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-string#t:CString&quot;&gt;CString&lt;/a&gt;&lt;/code&gt; ，则该函数也不安全。</target>
        </trans-unit>
        <trans-unit id="a1352738c1dd68227a434686b430958d3c19705e" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3624112a91081c7d0092b5f7cbbb5f82d405f7c9" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b637539c4592b1c460f40d32f474fe342dccfe09" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用文件 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e297580fc2021dc8c611b1cab7ef8ab0b1a171b6" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d928e0ca94addd99cca4a82d7c03710b0e1ff8e8" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用文件 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a7dbf169335c01f89eb6a63ed0156362fcda8c5" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:foldrWithKey&quot;&gt;foldrWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c431a15b17f66529ec0971f021718a3de7606559" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertLookupWithKey&quot;&gt;insertLookupWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78dce4476ccaf3b80909ed078582168f3c380495" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWith&quot;&gt;insertWith&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be1b4711ed0b36e7147869439e2d34b0cf4d927" translate="yes" xml:space="preserve">
          <source>This function is being removed and is no longer usable. Use &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该功能已被删除，不再可用。使用 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:insertWithKey&quot;&gt;insertWithKey&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13a1297dbe50a5705a1a7b087e24f8f8c0611b79" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt;. It uses terminal-style interaction if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is connected to a terminal and has echoing enabled. Otherwise (e.g., if &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; is a pipe), it uses file-style interaction.</source>
          <target state="translated">此函数等效于 &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:runInputTBehavior&quot;&gt;runInputTBehavior&lt;/a&gt; &lt;a href=&quot;system-console-haskeline#v:defaultBehavior&quot;&gt;defaultBehavior&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 连接到终端并启用了回显，则它将使用终端样式的交互。否则（例如，如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 是管道），它将使用文件样式的交互。</target>
        </trans-unit>
        <trans-unit id="74b22623dc818147f2c6f57929328997d17b3b24" translate="yes" xml:space="preserve">
          <source>This function is identical to the normal unsafeInterleaveST, but is inlined and hence faster.</source>
          <target state="translated">这个函数与普通的unsafeInterleaveST相同,但是是内联的,因此速度更快。</target>
        </trans-unit>
        <trans-unit id="3df65f8bec8d8ab7b43b6ab0ab2e82da15c0ef13" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">尽管此函数的代码量很大，但仍可以内联，以与分配策略融合。例如，默认的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行函数 &lt;code&gt;toLazyByteString&lt;/code&gt; 定义如下。</target>
        </trans-unit>
        <trans-unit id="235b6b044bd31212b9719a4b1325277577dea428" translate="yes" xml:space="preserve">
          <source>This function is inlined despite its heavy code-size to allow fusing with the allocation strategy. For example, the default &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; execution function &lt;code&gt;toLazyByteString&lt;/code&gt; is defined as follows.</source>
          <target state="translated">尽管此函数的代码量很大，但仍可以内联，以与分配策略融合。例如，默认的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 执行函数 &lt;code&gt;toLazyByteString&lt;/code&gt; 定义如下。</target>
        </trans-unit>
        <trans-unit id="5e260df7d73e67cac6b68c2a311d7baa6dc73777" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (also known as case insensitive) string comparisons.</source>
          <target state="translated">这个函数主要用于执行无大小写(也称为不区分大小写)的字符串比较。</target>
        </trans-unit>
        <trans-unit id="982fe52bf42753f9c092c03c7dda6cf3ea3642ac" translate="yes" xml:space="preserve">
          <source>This function is mainly useful for performing caseless (or case insensitive) string comparisons.</source>
          <target state="translated">这个函数主要用于执行无大小写(或不区分大小写)的字符串比较。</target>
        </trans-unit>
        <trans-unit id="88a949c7c5b9a60ae7e9844db387f3275f199bc9" translate="yes" xml:space="preserve">
          <source>This function is meant to be invoked from any application level cleanup handler. It terminates the process, and closes any &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle&lt;/code&gt;s.</source>
          <target state="translated">该功能旨在从任何应用程序级清除处理程序中调用。它终止进程，并关闭所有 &lt;code&gt;&lt;a href=&quot;system-process#v:CreatePipe&quot;&gt;CreatePipe&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00b26bf5c664293ce811e9f9293ca81ecc310513" translate="yes" xml:space="preserve">
          <source>This function is more efficient than &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; because in many cases no buffer allocation has to be done. Moreover, the results of several executions of short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s are concatenated in the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s buffer, therefore avoiding unnecessary buffer flushes.</source>
          <target state="translated">此功能比 &lt;code&gt;hPut . &lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; 更有效。toLazyByteString，因为在许多情况下无需进行缓冲区分配。此外，short &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的几次执行结果都被合并在 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的缓冲区中，因此避免了不必要的缓冲区刷新。</target>
        </trans-unit>
        <trans-unit id="81cef0e8688cdc48d9b9ff9c39a55f003fae9595" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">此函数通常用于使用 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类中的操作将数据编组到 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 指向的对象或从该对象编入数据。</target>
        </trans-unit>
        <trans-unit id="dcc8eee9cef2591d3719a4001c66eea308bb00b1" translate="yes" xml:space="preserve">
          <source>This function is normally used for marshalling data to or from the object pointed to by the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt;, using the operations from the &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">此函数通常用于使用 &lt;code&gt;&lt;a href=&quot;foreign-storable#t:Storable&quot;&gt;Storable&lt;/a&gt;&lt;/code&gt; 类中的操作将数据编组到 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 指向的对象或从该对象编入数据。</target>
        </trans-unit>
        <trans-unit id="f40048a5f3caebc5fe300ab653bf30f1e2b70070" translate="yes" xml:space="preserve">
          <source>This function is only defined if &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; and &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; (Note: the documentation claims that only &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; is supported, however the actual implementation supports up to base 256).</source>
          <target state="translated">仅当 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;gt;= 2#&lt;/code&gt; 和 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 256#&lt;/code&gt; 时才定义此函数（注意：文档声称仅支持 &lt;code&gt;&lt;em&gt;base&lt;/em&gt; &amp;lt;= 62#&lt;/code&gt; ，但是实际实现最多支持base 256）。</target>
        </trans-unit>
        <trans-unit id="213dcd0849e6345864ca5752cd6d03ec515775cd" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="7180b41a302c7c04e8da7fd8f83d119c939f7280" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="5f63596c51e12b4f409448cb34c60a65c7a9ca0d" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配内存块。</target>
        </trans-unit>
        <trans-unit id="4083768355a45fdb0a42de16aa51a3af8c228c66" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray&quot;&gt;mallocArray&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配内存块。</target>
        </trans-unit>
        <trans-unit id="6b1d46b44ea9232c55a861a5d882fa3688f6cd96" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证内存块由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="7672c2399ed76b968a47b4291c113d59075f7990" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt;, but yields a memory area that has a finalizer attached that releases the memory area. As with &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, it is not guaranteed that the block of memory was allocated by &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;foreign-marshal-array#v:mallocArray0&quot;&gt;mallocArray0&lt;/a&gt;&lt;/code&gt; ，但是会产生一个内存区域，该区域附加了终结器，该终结器释放该内存区域。与 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 一样，不能保证内存块由 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="7ff12ee367a6fdd15f0645b4e1ebf055ffe60727" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt;, except that the size of the memory required is given explicitly as a number of bytes.</source>
          <target state="translated">该函数与 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtr&quot;&gt;mallocForeignPtr&lt;/a&gt;&lt;/code&gt; 相似，除了所需的内存大小以字节数显式给出。</target>
        </trans-unit>
        <trans-unit id="b6c52e12f35a2275476d84741c02f0045857af05" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrAlignedBytes&quot;&gt;mallocForeignPtrAlignedBytes&lt;/a&gt;&lt;/code&gt; ，不同之处在于，它使用内部优化的，不带终结器的ForeignPtr表示形式。尝试添加终结器将引发异常。</target>
        </trans-unit>
        <trans-unit id="e8bb381fc113886f37459f57bc0e517e18d58f74" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the internally an optimised ForeignPtr representation with no finalizer is used. Attempts to add a finalizer will cause an exception to be thrown.</source>
          <target state="translated">此函数与 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; 相似，除了使用内部优化的，不带终结器的ForeignPtr表示形式。尝试添加终结器将引发异常。</target>
        </trans-unit>
        <trans-unit id="3d6f8324541e76c432236c537e2a380f498fdc16" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt;, except that the size and alignment of the memory required is given explicitly as numbers of bytes.</source>
          <target state="translated">此函数类似于 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:mallocForeignPtrBytes&quot;&gt;mallocForeignPtrBytes&lt;/a&gt;&lt;/code&gt; ，不同之处在于，所需内存的大小和对齐方式以字节数形式明确给出。</target>
        </trans-unit>
        <trans-unit id="c6266d7b17854517fbd86bf34d982e2073442b47" translate="yes" xml:space="preserve">
          <source>This function is strict in &lt;code&gt;needle&lt;/code&gt;, and lazy (as far as possible) in the chunks of &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">该功能在 &lt;code&gt;needle&lt;/code&gt; 很严格，在 &lt;code&gt;haystack&lt;/code&gt; 很懒（尽可能）。</target>
        </trans-unit>
        <trans-unit id="f216683cc82aa64de779d88daeaba4d1152d651d" translate="yes" xml:space="preserve">
          <source>This function is strict in its first argument, and lazy in its second.</source>
          <target state="translated">这个函数的第一个参数是严格的,第二个参数是懒惰的。</target>
        </trans-unit>
        <trans-unit id="b0b32655d3a8d92812d81f5285c18f655d5a3859" translate="yes" xml:space="preserve">
          <source>This function is strict in the computed result and lazy in the writing of the bytes. For example, given</source>
          <target state="translated">这个函数在计算结果上是严格的,在写入字节上是懒惰的。例如,给定</target>
        </trans-unit>
        <trans-unit id="d42e669b72fdf00ca69c1146fbc6cd4f7fd2b0e3" translate="yes" xml:space="preserve">
          <source>This function is suitable for use in pure code. In an IO context use &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">此功能适用于纯代码。在IO上下文中，请改用 &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceMarkerIO&quot;&gt;traceMarkerIO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3b80efc4be65cc4f7d016d8e9df62478b06cdd3" translate="yes" xml:space="preserve">
          <source>This function is unsafe because the program behavior is undefined if the type of the returned &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; does not match the expected one.</source>
          <target state="translated">此函数是不安全的，因为如果返回的 &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; 的类型与预期的不匹配，则程序行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d0ef53dc671c66eb4f726f95bfbceabd2738d518" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">GHC使用此函数来构造 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="5abca3b3eff9479232b2f8880d6591a9960af27b" translate="yes" xml:space="preserve">
          <source>This function is used by GHC for constructing &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; literals.</source>
          <target state="translated">GHC使用此函数来构造 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="a76dc2ebb647a8a46428d99317295ae5c89ee276" translate="yes" xml:space="preserve">
          <source>This function is useful for informing the parent when a child terminates, for example.</source>
          <target state="translated">这个功能很有用,例如,当一个孩子终止时,可以通知家长。</target>
        </trans-unit>
        <trans-unit id="d5042b5be97cdd0d8f13f55579035132f9596b0e" translate="yes" xml:space="preserve">
          <source>This function is useful for using &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; in a safe way in a multithreaded program. If you only have one &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt;, then using &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; to access and modify it will prevent race conditions.</source>
          <target state="translated">此功能对于在多线程程序中安全使用 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; 很有用。如果只有一个 &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; ，则使用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:atomicModifyIORef&quot;&gt;atomicModifyIORef&lt;/a&gt;&lt;/code&gt; 进行访问和修改将防止出现竞争情况。</target>
        </trans-unit>
        <trans-unit id="78f182126e093e425fc7c58b56f7052d3cc81fd2" translate="yes" xml:space="preserve">
          <source>This function isn't suitable when we want to set the cTRL_C_EVENT handler. If you want to set the cTRL_C_EVENT handler, use &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">当我们要设置cTRL_C_EVENT处理程序时，此函数不合适。如果要设置cTRL_C_EVENT处理程序，请改用 &lt;code&gt;&lt;a href=&quot;system-win32-console-ctrlhandler#v:c_SetConsoleCtrlHandler&quot;&gt;c_SetConsoleCtrlHandler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9871f6366cef22e329fca1bc704e039bd6520451" translate="yes" xml:space="preserve">
          <source>This function maps one exception into another as proposed in the paper &quot;A semantics for imprecise exceptions&quot;.</source>
          <target state="translated">这个函数将一个异常映射成另一个异常,正如论文 &quot;A semantics for imprecise exceptions &quot;中提出的那样。</target>
        </trans-unit>
        <trans-unit id="1a5ff8da6eff5ff073f1ef4ac1e4757b5f92be33" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="626e558e3754f72bcf94652b857bc1fadf635831" translate="yes" xml:space="preserve">
          <source>This function may be used as a value for &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, provided that &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; is defined. (Using &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; instance defined only by &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; will result in infinite recursion.)</source>
          <target state="translated">该函数可以被用作一个值 &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; 在一个 &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; 实例，只要 &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; 被限定。（将 &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; 与仅由 &lt;code&gt;&lt;a href=&quot;data-traversable#v:sequenceA&quot;&gt;sequenceA&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;&lt;a href=&quot;data-traversable#t:Traversable&quot;&gt;Traversable&lt;/a&gt;&lt;/code&gt; 实例一起使用将导致无限递归。）</target>
        </trans-unit>
        <trans-unit id="e58338f4629941ddeb6081adb1d67e46144c1a35" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written and the same value being computed. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, monadic sequencing of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">此功能必须是参照透明的；即，使用相等大小的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 多次调用它必须导致写入相同的字节序列和计算相同的值。如果需要可变状态，则必须在每次调用此函数时重新分配它。更进一步，此函数必须在完成后调用延续。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 的单峰排序不起作用。最后，此函数必须写入它声称已写入的所有字节。否则，不能保证所生成的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Put&quot;&gt;Put&lt;/a&gt;&lt;/code&gt; 相对于参考透明，并且敏感数据可能会泄漏。</target>
        </trans-unit>
        <trans-unit id="d45d9a503757dbc2e079e55bb2d136d8ac259338" translate="yes" xml:space="preserve">
          <source>This function must be referentially transparent; i.e., calling it multiple times with equally sized &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt;s must result in the same sequence of bytes being written. If you need mutable state, then you must allocate it anew upon each call of this function. Moroever, this function must call the continuation once its done. Otherwise, concatenation of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s does not work. Finally, this function must write to all bytes that it claims it has written. Otherwise, the resulting &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; is not guaranteed to be referentially transparent and sensitive data might leak.</source>
          <target state="translated">此功能必须是参照透明的；即，使用相等大小的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:BufferRange&quot;&gt;BufferRange&lt;/a&gt;&lt;/code&gt; 多次调用它必须导致写入相同的字节序列。如果需要可变状态，则必须在每次调用此函数时重新分配它。更进一步，此函数必须在完成后调用延续。否则， &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的串联将不起作用。最后，此函数必须写入它声称已写入的所有字节。否则，不能保证 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的生成器是参照透明的，并且敏感数据可能会泄漏。</target>
        </trans-unit>
        <trans-unit id="f8b24ee1d1129f69b81aa438d99f4c55ce18780e" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">该函数一次读取块，增加了每次读取的块大小。然后将最终的字符串重新分配为适当的大小。对于大于可用内存一半的文件，这可能会导致内存耗尽。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb38f0c0e138df73f1bb18283100e26479279ef9" translate="yes" xml:space="preserve">
          <source>This function reads chunks at a time, increasing the chunk size on each read. The final string is then reallocated to the appropriate size. For files &amp;gt; half of available memory, this may lead to memory exhaustion. Consider using &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; in this case.</source>
          <target state="translated">该函数一次读取块，增加了每次读取的块大小。然后将最终的字符串重新分配为适当的大小。对于大于可用内存一半的文件，这可能会导致内存耗尽。在这种情况下，请考虑使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:readFile&quot;&gt;readFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96182eaae363b6548da5c4708f3fee19d0eba44" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">该函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果它的参数有以下一个 &lt;code&gt;&lt;a href=&quot;data-char#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; S，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 以其他方式：</target>
        </trans-unit>
        <trans-unit id="08b901589b02acf03fdb2c4330ddaefe06ce9626" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; if its argument has one of the following &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt;s, or &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; otherwise:</source>
          <target state="translated">该函数返回 &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; 如果它的参数有以下一个 &lt;code&gt;&lt;a href=&quot;ghc-unicode#t:GeneralCategory&quot;&gt;GeneralCategory&lt;/a&gt;&lt;/code&gt; S，或 &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; 以其他方式：</target>
        </trans-unit>
        <trans-unit id="829c7b2049bce335518e8e6987f223cd44774ac1" translate="yes" xml:space="preserve">
          <source>This function should not be called on a closed or cancelled &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不应在关闭或取消的 &lt;code&gt;&lt;a href=&quot;system-console-haskeline-io#t:InputState&quot;&gt;InputState&lt;/a&gt;&lt;/code&gt; 上调用此函数。</target>
        </trans-unit>
        <trans-unit id="4becc58728105fc63f4543e724ceed3d0b38faa9" translate="yes" xml:space="preserve">
          <source>This function takes an adjacency list representing a graph with vertices of type &lt;code&gt;key&lt;/code&gt; labeled by values of type &lt;code&gt;node&lt;/code&gt; and produces a &lt;code&gt;Graph&lt;/code&gt;-based representation of that list. The &lt;code&gt;Graph&lt;/code&gt; result represents the &lt;em&gt;shape&lt;/em&gt; of the graph, and the functions describe a) how to retrieve the label and adjacent vertices of a given vertex, and b) how to retrive a vertex given a key.</source>
          <target state="translated">该函数获取一个表示图的邻接表，该图具有由类型 &lt;code&gt;node&lt;/code&gt; 的值标记的类型为 &lt;code&gt;key&lt;/code&gt; 的顶点，并生成该列表的基于 &lt;code&gt;Graph&lt;/code&gt; 的表示形式。的 &lt;code&gt;Graph&lt;/code&gt; 结果表示&lt;em&gt;形状&lt;/em&gt;的曲线图的，和功能描述）如何检索给定顶点的标签和相邻顶点，以及b）如何以检索给定的密钥的顶点。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6070795d0875a01577e4829d564fa22e24b1b00c" translate="yes" xml:space="preserve">
          <source>This function takes an extra &lt;code&gt;String&lt;/code&gt; argument to be used in creating error messages.</source>
          <target state="translated">此函数使用一个额外的 &lt;code&gt;String&lt;/code&gt; 参数来创建错误消息。</target>
        </trans-unit>
        <trans-unit id="7f0c1ada42e597613fc7e7e6786e2387ef148b77" translate="yes" xml:space="preserve">
          <source>This function throws an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the process &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; is anything other than &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt;. If instead you want to get the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; then use &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果进程 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; 不同于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitSuccess&quot;&gt;ExitSuccess&lt;/a&gt;&lt;/code&gt; ,则此函数将 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。相反，如果要获取 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#t:ExitCode&quot;&gt;ExitCode&lt;/a&gt;&lt;/code&gt; ,请使用 &lt;code&gt;&lt;a href=&quot;system-process#v:readProcessWithExitCode&quot;&gt;readProcessWithExitCode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b8c3042780b1688ac6a3ee1fab2256e1f014dd" translate="yes" xml:space="preserve">
          <source>This function will be invoked at two points in the constraint solving process: after simplification of given constraints, and after unflattening of wanted constraints. The two phases can be distinguished because the deriveds and wanteds will be empty in the first case. In each case, the plugin should either</source>
          <target state="translated">这个函数将在约束求解过程中的两点被调用:在给定约束简化之后,和在想要的约束取消之后。这两个阶段可以区分开来,因为在第一种情况下,派生约束和想要的约束都是空的。在每种情况下,插件都应该</target>
        </trans-unit>
        <trans-unit id="6467a527fa88959e8823896b96be26bf195128c1" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; which has some implementation pecularities to take into account:</source>
          <target state="translated">此函数包装 &lt;code&gt;mpz_sizeinbase()&lt;/code&gt; ，其中考虑了一些实现方面的特殊性：</target>
        </trans-unit>
        <trans-unit id="80485bdbfd7c212c63fd29a0333499c58e82d6b5" translate="yes" xml:space="preserve">
          <source>This function, like &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt;, has no effect on a frozen &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;ghc-stack#v:pushCallStack&quot;&gt;pushCallStack&lt;/a&gt;&lt;/code&gt; 一样，此功能对冻结的 &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="842a68272f46af66e4862fdc0bc066609f64b0e0" translate="yes" xml:space="preserve">
          <source>This generalizes the list-based &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这概括了基于列表的 &lt;code&gt;&lt;a href=&quot;data-list#v:filter&quot;&gt;filter&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="b2ff47cfc567ef028dcfe716cd26e468cb33a9de" translate="yes" xml:space="preserve">
          <source>This generates one file per Haskell module, and 4 index files, &lt;code&gt;hpc_index.html&lt;/code&gt;, &lt;code&gt;hpc_index_alt.html&lt;/code&gt;, &lt;code&gt;hpc_index_exp.html&lt;/code&gt;, &lt;code&gt;hpc_index_fun.html&lt;/code&gt;.</source>
          <target state="translated">这 &lt;code&gt;hpc_index.html&lt;/code&gt; 每个Haskell模块生成一个文件，并生成4个索引文件：hpc_index.html， &lt;code&gt;hpc_index_alt.html&lt;/code&gt; ， &lt;code&gt;hpc_index_exp.html&lt;/code&gt; ， &lt;code&gt;hpc_index_fun.html&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c64c30705c50c32c9be3389ffedce10aebc7f56" translate="yes" xml:space="preserve">
          <source>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a &lt;code&gt;safe&lt;/code&gt; foreign function call. For instance, it is often desirable to pass an unpinned &lt;code&gt;ByteArray#&lt;/code&gt;s directly to native code to avoid making an otherwise-unnecessary copy. However, this can only be done safely if the array is guaranteed not to be moved by the garbage collector in the middle of the call.</source>
          <target state="translated">这极大地限制了库作者，因为它暗示将任何堆对象引用传递给 &lt;code&gt;safe&lt;/code&gt; 外部函数调用是不安全的。例如，通常希望将未固定的 &lt;code&gt;ByteArray#&lt;/code&gt; 直接传递给本机代码，以避免产生不必要的副本。但是，只有保证在调用过程中不让垃圾收集器移动该数组时，才能安全地完成此操作。</target>
        </trans-unit>
        <trans-unit id="41834e436d1719d30cabcc4b9b9f363c58c43156" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 以及与带有 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 一起调用具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="6ae7b2e29f0249e038dc6f2d5f144f9852f9724a" translate="yes" xml:space="preserve">
          <source>This has the same effect as calling &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt;, together with &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这与使用 &lt;code&gt;&lt;a href=&quot;system-io#v:char8&quot;&gt;char8&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetEncoding&quot;&gt;hSetEncoding&lt;/a&gt;&lt;/code&gt; 以及与带有 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetNewlineMode&quot;&gt;hSetNewlineMode&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;system-io#v:noNewlineTranslation&quot;&gt;noNewlineTranslation&lt;/a&gt;&lt;/code&gt; 一起调用具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="74c85cbe0088849b70271ff6b2b4f90df21c84ea" translate="yes" xml:space="preserve">
          <source>This has two effects. The first is to compile the code in such a way that it can be linked against shared library versions of Haskell packages (such as base). The second is when linking, to link against the shared versions of the packages&amp;rsquo; libraries rather than the static versions. Obviously this requires that the packages were built with shared libraries. On supported platforms GHC comes with shared libraries for all the core packages, but if you install extra packages (e.g. with Cabal) then they would also have to be built with shared libraries (&lt;code&gt;--enable-shared&lt;/code&gt; for Cabal).</source>
          <target state="translated">这有两个效果。第一种是编译代码，使其可以与Haskell软件包的共享库版本（例如base）链接。第二个是在链接时，链接到软件包库的共享版本而不是静态版本。显然，这需要使用共享库构建软件包。在支持的平台上，GHC附带了所有核心软件包的共享库，但是，如果您安装了额外的软件包（例如Cabal），则它们也必须使用共享库（对于Cabal为 &lt;code&gt;--enable-shared&lt;/code&gt; )构建。</target>
        </trans-unit>
        <trans-unit id="548fc7aaea96607acee200e9ba71f5d0c6b166be" translate="yes" xml:space="preserve">
          <source>This idea is very old; see Seciton 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable type classes&lt;/a&gt;.</source>
          <target state="translated">这个想法很古老；参见Seciton 7的&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/derivable-type-classes/&quot;&gt;Derivable类型类&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9630590333acefa1eb165b1fdb491f1028f3c007" translate="yes" xml:space="preserve">
          <source>This implemenation uses &lt;code&gt;memset(3)&lt;/code&gt;</source>
          <target state="translated">此实现使用 &lt;code&gt;memset(3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884b09618f3fa095f6ec125ed96fbbf8ccd437a1" translate="yes" xml:space="preserve">
          <source>This implementation is intentionally naive. Instances are expected to provide an optimized implementation for their size.</source>
          <target state="translated">这个实现是故意幼稚的。实例有望为其规模提供优化的实现。</target>
        </trans-unit>
        <trans-unit id="621e9b697c58fe612c7eaaea244ee764c09bb5f3" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">这意味着刷新输出缓冲区，即使它仅包含一个字节也是如此。因此，应仅对大（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 。否则，生成的块将过于分散，以至于无法在之后进行有效处理。</target>
        </trans-unit>
        <trans-unit id="ec6a5f5a381024ce57d5b678b6cb847a23f169c1" translate="yes" xml:space="preserve">
          <source>This implies flushing the output buffer, even if it contains just a single byte. You should therefore use &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; only for large (&lt;code&gt;&amp;gt; 8kb&lt;/code&gt;) &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s. Otherwise, the generated chunks are too fragmented to be processed efficiently afterwards.</source>
          <target state="translated">这意味着刷新输出缓冲区，即使它仅包含一个字节也是如此。因此，应仅对大（ &lt;code&gt;&amp;gt; 8kb&lt;/code&gt; ） &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#v:byteStringInsert&quot;&gt;byteStringInsert&lt;/a&gt;&lt;/code&gt; 。否则，生成的块将过于分散，以至于无法在之后进行有效处理。</target>
        </trans-unit>
        <trans-unit id="0f03bf2766810922713f86acfde0e9c886b0e80e" translate="yes" xml:space="preserve">
          <source>This improves efficiency slightly but significantly for most programs, and is bad for only a few. To suppress this bogus &amp;ldquo;optimisation&amp;rdquo; use &lt;code&gt;-fpedantic-bottoms&lt;/code&gt;.</source>
          <target state="translated">对于大多数程序而言，这会稍微提高效率，但会显着提高，而对于少数几个程序却是不利的。要抑制这种虚假的&amp;ldquo;优化&amp;rdquo;，请使用 &lt;code&gt;-fpedantic-bottoms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c3ae98027814be110bac171a0407c5649c80296" translate="yes" xml:space="preserve">
          <source>This includes the main thread, so using &lt;a href=&quot;#rts-flag--xt&quot;&gt;&lt;code&gt;-xt&lt;/code&gt;&lt;/a&gt; is a good way to see how much stack space the program is using.</source>
          <target state="translated">这包括主线程，因此使用&lt;a href=&quot;#rts-flag--xt&quot;&gt; &lt;code&gt;-xt&lt;/code&gt; &lt;/a&gt;是查看程序正在使用多少堆栈空间的好方法。</target>
        </trans-unit>
        <trans-unit id="d6a0e9f59821fc6a5f78b81c882c88a9ce445a90" translate="yes" xml:space="preserve">
          <source>This indicates that there may be more data to write. It gives you the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. You should call that action with an appropriate buffer. The int indicates the &lt;em&gt;minimum&lt;/em&gt; buffer size required by the next &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. That is, if you call the next action you &lt;em&gt;must&lt;/em&gt; supply it with a buffer length of at least this size.</source>
          <target state="translated">这表明可能还有更多数据要写入。它为您提供了下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作。您应该使用适当的缓冲区调用该操作。 int指示下一个 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作所需的&lt;em&gt;最小&lt;/em&gt;缓冲区大小。也就是说，如果调用下一个动作，则&lt;em&gt;必须&lt;/em&gt;为其提供至少此大小的缓冲区长度。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12dc46ef50110e91a94e6d325a61778b34facf10" translate="yes" xml:space="preserve">
          <source>This inlining occurs regardless of the argument to the call or the size of &lt;code&gt;f&lt;/code&gt;'s definition; it is unconditional. The main caveat is that &lt;code&gt;f&lt;/code&gt;'s definition must be visible to the compiler; it is therefore recommended to mark the function with an &lt;code&gt;INLINABLE&lt;/code&gt; pragma at its definition so that GHC guarantees to record its unfolding regardless of size.</source>
          <target state="translated">不管调用的参数或 &lt;code&gt;f&lt;/code&gt; 的定义大小如何，都会发生此内联；这是无条件的。主要警告是 &lt;code&gt;f&lt;/code&gt; 的定义对于编译器必须是可见的。因此，建议在函数定义时用 &lt;code&gt;INLINABLE&lt;/code&gt; 杂注标记功能，以便GHC保证记录其展开的大小。</target>
        </trans-unit>
        <trans-unit id="1ef01da60f8e50833762de51e88f6f38500b8529" translate="yes" xml:space="preserve">
          <source>This inserts the plugin as a core-to-core pass. Unlike &lt;code&gt;-fplugin=(module)&lt;/code&gt;, the plugin module can&amp;rsquo;t reside in the same package as the module calling &lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;. This way, the implementation can expect the plugin to be built by the time it is needed.</source>
          <target state="translated">这会将插件作为核心到核心通道插入。与 &lt;code&gt;-fplugin=(module)&lt;/code&gt; ，plugin模块不能与调用&lt;a href=&quot;../libraries/template-haskell-2.15.0.0/language-haskell-th-syntax#v:addCorePlugin&quot;&gt;Language.Haskell.TH.Syntax.addCorePlugin&lt;/a&gt;的模块位于同一软件包中。这样，实现可以期望插件在需要的时候构建。</target>
        </trans-unit>
        <trans-unit id="c72aeeca496ff034d5ed0f5d68c44678b8f30bdc" translate="yes" xml:space="preserve">
          <source>This instance has similar considerations to the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instance: it preserves abstraction at the cost of inefficiency.</source>
          <target state="translated">该实例与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; 实例具有类似的考虑：它以低效率为代价保留了抽象。</target>
        </trans-unit>
        <trans-unit id="f4e5c9cc750ce5f88a69b78165e5f0f4d42bcbfe" translate="yes" xml:space="preserve">
          <source>This instance is for convenience and consistency with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt;. This assumes that WHNF is equivalent to NF for functions.</source>
          <target state="translated">此实例是为了方便和与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; 保持一致。假设WHNF在功能上与NF等效。</target>
        </trans-unit>
        <trans-unit id="292d6bb24eb4520bb3e5e03c32ef914fb200aaac" translate="yes" xml:space="preserve">
          <source>This instance is only usable if the constructor &lt;code&gt;MkNT&lt;/code&gt; is in scope.</source>
          <target state="translated">仅当构造函数 &lt;code&gt;MkNT&lt;/code&gt; 在范围内时，此实例才可用。</target>
        </trans-unit>
        <trans-unit id="f66688755fda8b6fa988624af4229d29f0758a6a" translate="yes" xml:space="preserve">
          <source>This instance preserves data abstraction at the cost of inefficiency. We omit reflection services for the sake of data abstraction.</source>
          <target state="translated">这个实例以低效率为代价保留了数据抽象。为了数据抽象,我们省略了反射服务。</target>
        </trans-unit>
        <trans-unit id="6b584a1a609b62c189a035f58e1f74d23dc48f4f" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt;. If you feel a mistake has been made, please feel free to submit improvements.</source>
          <target state="translated">通过复制 &lt;code&gt;&lt;a href=&quot;data-set&quot;&gt;Data.Set&lt;/a&gt;.&lt;/code&gt; 的更新行为来创建此实例。 &lt;code&gt;&lt;a href=&quot;data-set#v:Set&quot;&gt;Set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map&quot;&gt;Data.Map&lt;/a&gt;.&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;data-map#v:Map&quot;&gt;Map&lt;/a&gt;&lt;/code&gt; 。如果您认为自己犯了一个错误，请随时提出改进意见。</target>
        </trans-unit>
        <trans-unit id="cebbf89c2d62c75612dfe9b00700d435728a9709" translate="yes" xml:space="preserve">
          <source>This instance was created by copying the updated behavior of &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">通过复制 &lt;code&gt;&lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt;.&lt;/code&gt; 的更新行为来创建此实例。 &lt;code&gt;&lt;a href=&quot;data-text#v:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9547a346372e77b8a94a20c518fb263a9e88db" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;control-applicative#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等效于 &lt;code&gt;&lt;a href=&quot;control-applicative#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype的派生实例。</target>
        </trans-unit>
        <trans-unit id="9d8b5c5a18b4eafeeabf6e2ae459cf6f977e8e46" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;data-functor-const#v:getConst&quot;&gt;getConst&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等效于 &lt;code&gt;&lt;a href=&quot;data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; newtype的派生实例。</target>
        </trans-unit>
        <trans-unit id="8f442041027e514839d6c7dbd7ef45f00a4ededa" translate="yes" xml:space="preserve">
          <source>This instance would be equivalent to the derived instances of the &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; newtype if the &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; field were removed</source>
          <target state="translated">如果删除了 &lt;code&gt;&lt;a href=&quot;data-functor-identity#v:runIdentity&quot;&gt;runIdentity&lt;/a&gt;&lt;/code&gt; 字段，则此实例将等同于 &lt;code&gt;&lt;a href=&quot;data-functor-identity#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 新类型的派生实例。</target>
        </trans-unit>
        <trans-unit id="04b4bf75fa251a6d79ae490ffe498133e416deeb" translate="yes" xml:space="preserve">
          <source>This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. Currently Linux and Windows/MinGW32 only. This is equivalent to using &lt;code&gt;-optl -rdynamic&lt;/code&gt; on Linux, and &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; on Windows.</source>
          <target state="translated">这指示链接器将所有符号（不仅是已使用的符号）添加到动态符号表中。目前仅适用于Linux和Windows / MinGW32。这等效于在Linux 上使用 &lt;code&gt;-optl -rdynamic&lt;/code&gt; ，在Windows 上使用-optl &lt;code&gt;-optl -export-all-symbols&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d93a8b76f0ddcde6fb04d1a2d2bc4ce8187928c7" translate="yes" xml:space="preserve">
          <source>This instructs the linker to produce a position-independent executable. This flag is only valid while producing executables and all object code being linked must have been produced with &lt;a href=&quot;#ghc-flag--fPIE&quot;&gt;&lt;code&gt;-fPIE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这指示链接器生成与位置无关的可执行文件。该标志仅在生成可执行文件时才有效，并且所有链接的目标代码必须已使用&lt;a href=&quot;#ghc-flag--fPIE&quot;&gt; &lt;code&gt;-fPIE&lt;/code&gt; 生成&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f3eb5f30b0cea2845a0034105f6b2f42741738e" translate="yes" xml:space="preserve">
          <source>This interface was introduced for parsers by Niklas R&amp;ouml;jemo, because it admits more sharing than the monadic interface. The names here are mostly based on parsing work by Doaitse Swierstra.</source>
          <target state="translated">NiklasR&amp;ouml;jemo为解析器引入了此接口，因为它接受的共享比monadic接口更多。这里的名称主要基于Doaitse Swierstra的解析工作。</target>
        </trans-unit>
        <trans-unit id="2193f86cf24477bc6ea98a7a666bf4f097144114" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; with its arguments flipped.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:-62--36-&quot;&gt;&amp;gt;$&lt;/a&gt;&lt;/code&gt; ，其参数已翻转。</target>
        </trans-unit>
        <trans-unit id="853ad3fece6dfad54dfa810a5f259b18c1ca92df" translate="yes" xml:space="preserve">
          <source>This is a &quot;secure&quot; variant of &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;mpz_powm_sec()&lt;/code&gt; function which is designed to be resilient to side channel attacks and is therefore intended for cryptographic applications.</source>
          <target state="translated">这是一个&amp;ldquo;安全的&amp;rdquo;变体 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;mpz_powm_sec()&lt;/code&gt; ，其被设计为弹性的，以侧信道攻击，并因此适用于密码应用的功能。</target>
        </trans-unit>
        <trans-unit id="206d2c688e36d3f91786f4ad10d32b3bbd76f245" translate="yes" xml:space="preserve">
          <source>This is a change in behaviour relative to 6.2 and earlier.</source>
          <target state="translated">这是相对于6.2及以前的行为变化。</target>
        </trans-unit>
        <trans-unit id="00558cc92150447e28cfde519a9ac027ba98b199" translate="yes" xml:space="preserve">
          <source>This is a combination of &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt;; ie. it takes the value from the &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt;, puts it back, and also returns it.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:takeTMVar&quot;&gt;takeTMVar&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#v:putTMVar&quot;&gt;putTMVar&lt;/a&gt;&lt;/code&gt; 的组合；即。它从 &lt;code&gt;&lt;a href=&quot;control-concurrent-stm-tmvar#t:TMVar&quot;&gt;TMVar&lt;/a&gt;&lt;/code&gt; 获取值，将其放回去，然后还返回它。</target>
        </trans-unit>
        <trans-unit id="5cf7cdffdf7f677c3d65b226f0158c81eb00adc8" translate="yes" xml:space="preserve">
          <source>This is a good alternative to &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; when you are trying to directly link in an object file.</source>
          <target state="translated">当您尝试直接链接到目标文件时，这是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:addForeignSource&quot;&gt;addForeignSource&lt;/a&gt;&lt;/code&gt; 的一个很好的选择。</target>
        </trans-unit>
        <trans-unit id="085ff8e3a0f8a72b0a54eeb21ca799400340b070" translate="yes" xml:space="preserve">
          <source>This is a good way to insulate your program from differences in the globally exposed packages, and being explicit about package dependencies is a Good Thing. Cabal always passes the &lt;code&gt;-hide-all-packages&lt;/code&gt; flag to GHC, for exactly this reason.</source>
          <target state="translated">这是使程序与全局暴露的程序包之间的差异隔离的好方法，并且明确说明程序包的依赖关系是一件好事。正是由于这个原因，Cabal始终将 &lt;code&gt;-hide-all-packages&lt;/code&gt; 标志传递给GHC。</target>
        </trans-unit>
        <trans-unit id="8027c0b11e662d6e52978de63e39356d25b88d32" translate="yes" xml:space="preserve">
          <source>This is a guide to using the Glasgow Haskell Compiler (GHC): an interactive and batch compilation system for the &lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt; language.</source>
          <target state="translated">这是有关使用格拉斯哥Haskell编译器（GHC）的指南：格拉斯哥&lt;a href=&quot;http://www.haskell.org/&quot;&gt;Haskell 2010&lt;/a&gt;语言的交互式批处理编译系统。</target>
        </trans-unit>
        <trans-unit id="c43f1cd29cf3fbfdaab28a7b865c723e0177f5eb" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by UTC. It has a precision of 10^-12 s.</source>
          <target state="translated">这是一个时间长度,由UTC测量。它的精确度为10^-12秒。</target>
        </trans-unit>
        <trans-unit id="b188ac0ba94d5b91f8dbb5c660aa1046ae2821a3" translate="yes" xml:space="preserve">
          <source>This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has a precision of 10^-12 s.</source>
          <target state="translated">这是一个时间长度,由时钟测量。换算函数会将其视为秒。它的精度为10^-12秒。</target>
        </trans-unit>
        <trans-unit id="b931fc8ba0422aa66c49ca99c7502e98ce5770ff" translate="yes" xml:space="preserve">
          <source>This is a library of parser combinators, originally written by Koen Claessen. It parses all alternatives in parallel, so it never keeps hold of the beginning of the input string, a common source of space leaks with other parsers. The &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; choice combinator is genuinely commutative; it makes no difference which branch is &quot;shorter&quot;.</source>
          <target state="translated">这是一个解析器组合器库，最初由Koen Claessen编写。它并行地解析所有替代项，因此它永远不会保持输入字符串的开头，这是其他解析器常见的空间泄漏源。的 &lt;code&gt;(&lt;a href=&quot;text-parsercombinators-readp#v:-43--43--43-&quot;&gt;+++&lt;/a&gt;)&lt;/code&gt; 的选择组合子是真正交换; 哪个分支&amp;ldquo;更短&amp;rdquo;没有区别。</target>
        </trans-unit>
        <trans-unit id="e42801ec302676ba22f8d444806417ba897f7527" translate="yes" xml:space="preserve">
          <source>This is a lot of information! However, most of it is actually merely meta-information that makes names of datatypes and constructors and more available on the type level.</source>
          <target state="translated">这是一个很大的信息!然而,大多数信息实际上只是元信息,它使数据类型和构造函数的名称和更多的类型水平可用。然而,它的大部分实际上只是元信息,使得数据类型和构造函数的名称以及更多的信息在类型级别上可用。</target>
        </trans-unit>
        <trans-unit id="80f7c821c90cd714f631d4e0a4b9d09aa6b02e5d" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Haskell style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">这是一个Haskell风格语言的最小化标记定义。它定义了注释、有效标识符和大小写敏感性的风格。它没有定义任何保留字或操作符。</target>
        </trans-unit>
        <trans-unit id="7695f0f91603fc6b7578c654d8c907922e492b31" translate="yes" xml:space="preserve">
          <source>This is a minimal token definition for Java style languages. It defines the style of comments, valid identifiers and case sensitivity. It does not define any reserved words or operators.</source>
          <target state="translated">这是一个Java风格语言的最小标记定义。它定义了注释的风格、有效的标识符和大小写敏感性。它没有定义任何保留字或运算符。</target>
        </trans-unit>
        <trans-unit id="fa0a32456a663556dc4c0ba610d08c21985dc005" translate="yes" xml:space="preserve">
          <source>This is a module for efficient stack traces. This stack trace implementation is considered low overhead. Basic usage looks like this:</source>
          <target state="translated">这是一个高效的堆栈跟踪模块。这个堆栈跟踪实现被认为是低开销的。基本用法是这样的。</target>
        </trans-unit>
        <trans-unit id="d8d7e87f49a4a49c2284947686e2481c865a646c" translate="yes" xml:space="preserve">
          <source>This is a non-blocking version of &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;. If the process is still running, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; is returned. If the process has exited, then &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; is returned where &lt;code&gt;e&lt;/code&gt; is the exit code of the process.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; 的非阻塞版本。如果该进程仍在运行， &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 返回任何内容。如果该进程已退出，则返回 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; e&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是该进程的退出代码。</target>
        </trans-unit>
        <trans-unit id="5bdec4fb766d4e0ba04b6cea6e7ffd45bb020610" translate="yes" xml:space="preserve">
          <source>This is a rather fragile arrangement, as generally a programmer expects &lt;code&gt;(*) a b&lt;/code&gt; to be equivalent to &lt;code&gt;a * b&lt;/code&gt;. With &lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt;&lt;code&gt;-Wstar-binder&lt;/code&gt;&lt;/a&gt; we warn when this special treatment of &lt;code&gt;(*)&lt;/code&gt; takes place.</source>
          <target state="translated">这是一个相当脆弱的安排，因为程序员通常期望 &lt;code&gt;(*) a b&lt;/code&gt; 等于 &lt;code&gt;a * b&lt;/code&gt; 。使用&lt;a href=&quot;#ghc-flag--Wstar-binder&quot;&gt; &lt;code&gt;-Wstar-binder&lt;/code&gt; &lt;/a&gt;可以警告对 &lt;code&gt;(*)&lt;/code&gt; 的特殊处理。</target>
        </trans-unit>
        <trans-unit id="bfbddac5a335e3a88e1f9114ff2652333aff0d5e" translate="yes" xml:space="preserve">
          <source>This is a slightly involved heuristic, but captures the situation of an imported module &lt;code&gt;N&lt;/code&gt; changing the behaviour of existing code. For example, if the second condition isn&amp;rsquo;t violated, then the module author &lt;code&gt;M&lt;/code&gt; must depend either on a type-class or type defined in &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">这是一个稍微涉及的试探法，但是捕获了更改现有代码行为的导入模块 &lt;code&gt;N&lt;/code&gt; 的情况。例如，如果不违反第二个条件，那么模块作者 &lt;code&gt;M&lt;/code&gt; 必须依赖于 &lt;code&gt;N&lt;/code&gt; 中定义的类型类或类型。</target>
        </trans-unit>
        <trans-unit id="4721594427df43592a87eef3fe9a7c319440d2ac" translate="yes" xml:space="preserve">
          <source>This is a suitable definition for an &lt;code&gt;mtimes&lt;/code&gt; member of &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;mtimes&lt;/code&gt; 成员，这是一个合适的定义。</target>
        </trans-unit>
        <trans-unit id="9d950f78f6594d495d879d450f50f2aaabfabc86" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个有效的定义 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f7c8d617e149468fb4914e042ce1964608c94f4" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个有效的定义 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 为幂等 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85d5215128cc4957be290b7930eb2a5cf73d213f" translate="yes" xml:space="preserve">
          <source>This is a valid definition of &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; for an idempotent &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是幂等 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; 的有效定义。</target>
        </trans-unit>
        <trans-unit id="172ab78ae87f58f1be94549d14a2e6f93c70f4c1" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 的变体，其中终结器是任意 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。调用终结器时，它将在新线程中运行。</target>
        </trans-unit>
        <trans-unit id="b4e325aa9ef040b927e3fb7ef2baa5b6a0f1b819" translate="yes" xml:space="preserve">
          <source>This is a variant of &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;, where the finalizer is an arbitrary &lt;code&gt;IO&lt;/code&gt; action. When it is invoked, the finalizer will run in a new thread.</source>
          <target state="translated">这是 &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; 的变体，其中终结器是任意 &lt;code&gt;IO&lt;/code&gt; 操作。调用终结器时，它将在新线程中运行。</target>
        </trans-unit>
        <trans-unit id="371673f71c58c2e9cdb85387820977d33c4caf49" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">这是查看位于异物内部的指针的方法。该函数采用一个应用于该指针的函数。然后执行生成的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。即使不直接在内部使用，异物也至少在整个动作过程中都保持活动状态。请注意，从操作返回指针并在操作完成后使用它是不安全的。指针的所有使用都应放在 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 括号内。这种不安全的原因与下面的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 相同：终结器的运行可能比预期的要早，因为编译器只能跟踪 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 对象的使用，而不能跟踪由此生成的 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="1bf47a6eebbbeb1a3756083812189988818bf7bb" translate="yes" xml:space="preserve">
          <source>This is a way to look at the pointer living inside a foreign object. This function takes a function which is applied to that pointer. The resulting &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action is then executed. The foreign object is kept alive at least during the whole action, even if it is not used directly inside. Note that it is not safe to return the pointer from the action and use it after the action completes. All uses of the pointer should be inside the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; bracket. The reason for this unsafeness is the same as for &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; below: the finalizer may run earlier than expected, because the compiler can only track usage of the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; object, not a &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; object made from it.</source>
          <target state="translated">这是查看位于异物内部的指针的方法。该函数采用一个应用于该指针的函数。然后执行生成的 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作。即使不直接在内部使用，异物也至少在整个动作过程中都保持活动状态。请注意，从操作返回指针并在操作完成后使用它是不安全的。指针的所有使用都应放在 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; 括号内。这种不安全的原因与下面的 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 相同：终结器的运行可能比预期的要早，因为编译器只能跟踪 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 对象的使用，而不能跟踪由此生成的 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:Ptr&quot;&gt;Ptr&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="0f341bdd202c5cbf36cfc8ae95ca15781837c676" translate="yes" xml:space="preserve">
          <source>This is a workaround for poor optimisation in GHC 6.8.2. It fails to notice constant-width shifts, and adds a test and branch to every shift. This imposes about a 10% performance hit.</source>
          <target state="translated">这是一个针对GHC 6.8.2中优化不良的变通方法。它没有注意到恒定宽度的移动,并为每次移动添加了测试和分支。这对性能造成了10%的影响。</target>
        </trans-unit>
        <trans-unit id="8c2b599fbba068d2e3306d55e3da89a6dea9c30d" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt;, but returns a quadruple consisting of the option arguments, a list of non-options, a list of unrecognized options, and a list of error messages.</source>
          <target state="translated">这几乎与 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 相同，但是返回一个由选项参数，非选项列表，无法识别的选项列表和错误消息列表组成的四元组。</target>
        </trans-unit>
        <trans-unit id="d0e2442d2a5176acfea0d861dcdf4c526699f651" translate="yes" xml:space="preserve">
          <source>This is almost the same as &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt;, except that &lt;code&gt;ghc-pkg dump&lt;/code&gt; is intended for use by tools that parse the results, so for example where &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; will emit an error if it can&amp;rsquo;t find any packages that match the pattern, &lt;code&gt;ghc-pkg dump&lt;/code&gt; will simply emit nothing.</source>
          <target state="translated">这与 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 几乎相同，不同之处在于 &lt;code&gt;ghc-pkg dump&lt;/code&gt; 是供解析结果的工具使用的，因此，例如 &lt;code&gt;ghc-pkg describe '*'&lt;/code&gt; 会发出错误。如果找不到与模式匹配的任何软件包， &lt;code&gt;ghc-pkg dump&lt;/code&gt; 将不会发出任何东西。</target>
        </trans-unit>
        <trans-unit id="7792587286beb0c2340a33dbd540974a7aa95716" translate="yes" xml:space="preserve">
          <source>This is also known as the catamorphism on trees.</source>
          <target state="translated">这也就是所谓的树上的猫腻。</target>
        </trans-unit>
        <trans-unit id="c1f05073a7db37870040709ee8825ace5ad9e27b" translate="yes" xml:space="preserve">
          <source>This is also the number of threads that will participate in parallel garbage collection. It is strongly recommended that the number of capabilities is not set larger than the number of physical processor cores, and it may often be beneficial to leave one or more cores free to avoid contention with other processes in the machine.</source>
          <target state="translated">这也是参与并行垃圾收集的线程数。强烈建议能力数量的设置不要大于物理处理器内核的数量,而且通常情况下,留出一个或多个内核以避免与机器中的其他进程发生争执可能是有益的。</target>
        </trans-unit>
        <trans-unit id="beec198333c6e916a71dc2007f654bbfb496d115" translate="yes" xml:space="preserve">
          <source>This is always an integral type. Width and signedness are platform specific.</source>
          <target state="translated">这始终是一个整体类型。宽度和签约度是平台特定的。</target>
        </trans-unit>
        <trans-unit id="2c94c1e0eafc78c19212557dee894b114bd63e4b" translate="yes" xml:space="preserve">
          <source>This is an alternative backend that uses the &lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler to produce executable code. It generally produces code as with performance as good as the native code generator but for some cases can produce much faster code. This is especially true for numeric, array heavy code using packages like vector. The penalty is a significant increase in compilation times. Select the LLVM backend with the &lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt;&lt;code&gt;-fllvm&lt;/code&gt;&lt;/a&gt; flag.</source>
          <target state="translated">这是使用&lt;a href=&quot;http://llvm.org&quot;&gt;LLVM&lt;/a&gt;编译器生成可执行代码的备用后端。它产生的代码通常具有与本机代码生成器一样好的性能，但是在某些情况下可以产生更快的代码。对于使用矢量之类的软件包的数字数组重代码尤其如此。惩罚是编译时间的显着增加。选择带有&lt;a href=&quot;phases#ghc-flag--fllvm&quot;&gt; &lt;code&gt;-fllvm&lt;/code&gt; &lt;/a&gt;标志的LLVM后端。</target>
        </trans-unit>
        <trans-unit id="b07234aad669def52b50175f945aeebcd045d700" translate="yes" xml:space="preserve">
          <source>This is an experimental feature, please let us know if it causes problems and/or could benefit from further tuning.</source>
          <target state="translated">这是一个实验性的功能,请让我们知道它是否会造成问题和/或可以从进一步的调整中受益。</target>
        </trans-unit>
        <trans-unit id="d518bb2db084fc2424d01684cf81e93ef233a006" translate="yes" xml:space="preserve">
          <source>This is an infix alias for &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 的中缀别名。</target>
        </trans-unit>
        <trans-unit id="101923d23a1c0936899b25445ac34361e56b2129" translate="yes" xml:space="preserve">
          <source>This is an infix version of &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; with the arguments flipped.</source>
          <target state="translated">这是参数 &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:contramap&quot;&gt;contramap&lt;/a&gt;&lt;/code&gt; 的infix版本。</target>
        </trans-unit>
        <trans-unit id="58c0c8b3a56848782113a6355b13f876cdde90db" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;qsort&lt;/code&gt; is a polymorphic function, and because GHCi does not carry type information at runtime, it cannot determine the runtime types of free variables that involve type variables. Hence, when you ask to display &lt;code&gt;left&lt;/code&gt; at the prompt, GHCi can&amp;rsquo;t figure out which instance of &lt;code&gt;Show&lt;/code&gt; to use, so it emits the type error above.</source>
          <target state="translated">这是因为 &lt;code&gt;qsort&lt;/code&gt; 是一个多态函数，并且因为GHCi在运行时不携带类型信息，所以它无法确定涉及类型变量的自由变量的运行时类型。因此，当您要求在提示处显示 &lt;code&gt;left&lt;/code&gt; 时，GHCi无法确定要使用哪个 &lt;code&gt;Show&lt;/code&gt; 实例，因此它会在上面发出类型错误。</target>
        </trans-unit>
        <trans-unit id="31f122da1e52003fb749b42feb286b289a499229" translate="yes" xml:space="preserve">
          <source>This is common type used by &lt;code&gt;Natural&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;. As this type consists of a single constructor wrapping a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; it can be unpacked.</source>
          <target state="translated">这是 &lt;code&gt;Natural&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 常用的类型。由于此类型由包装 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; 的单个构造函数组成，因此可以解压缩。</target>
        </trans-unit>
        <trans-unit id="e46c9188c411a7574791b7db9d68e4a5ba400984" translate="yes" xml:space="preserve">
          <source>This is crucial to preserve correctness. Entities defined in other modules might rely on laziness for correctness (whether functional or performance).</source>
          <target state="translated">这对保持正确性至关重要。在其他模块中定义的实体可能会依靠懒惰来保证正确性(无论是功能还是性能)。</target>
        </trans-unit>
        <trans-unit id="ed31266df50c8047adeba9f8ad5ed4814f624b36" translate="yes" xml:space="preserve">
          <source>This is currently only returned by the following operations:</source>
          <target state="translated">目前只由以下操作返回。</target>
        </trans-unit>
        <trans-unit id="69022b713a9a3be30ce145d8a3fa9a46d52862c0" translate="yes" xml:space="preserve">
          <source>This is dangerous territory, however. Here, for example, is a program that would make the typechecker loop:</source>
          <target state="translated">然而,这是一个危险的领域。例如,这里有一个程序,可以让typechecker循环。</target>
        </trans-unit>
        <trans-unit id="8bef230a1b33fc363b0b8397f3ec27a17fff06b4" translate="yes" xml:space="preserve">
          <source>This is definitely caused by a bug in GHC. Please report it (see &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt;).</source>
          <target state="translated">这肯定是由GHC中的错误引起的。请报告它（请参阅&lt;a href=&quot;intro#bug-reporting&quot;&gt;报告GHC中的错误&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="50509e11fe7ca6ff18f57510c20c4165a78570ab" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;if p then y else x&lt;/code&gt;; that is, one can think of it as an if-then-else construct with its arguments reordered.</source>
          <target state="translated">这等效于 &lt;code&gt;if p then y else x&lt;/code&gt; ; 也就是说，可以将其视为参数重新排序的if-then-else构造。</target>
        </trans-unit>
        <trans-unit id="ac94cb7c266f7957cc925f86fcff5b3aa8d29a4c" translate="yes" xml:space="preserve">
          <source>This is essentially a more performant version of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; that always returns the first result, if any. Details can be found in the documentation of &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从本质 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; ，这是findFilesWith的更高性能版本，它始终返回第一个结果（如果有）。可以在 &lt;code&gt;&lt;a href=&quot;system-directory#v:findFilesWith&quot;&gt;findFilesWith&lt;/a&gt;&lt;/code&gt; 的文档中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="9595725d43f98726f370669a781ee6935055f745" translate="yes" xml:space="preserve">
          <source>This is essentially the same as if you had written &lt;code&gt;deriving Foo&lt;/code&gt; after the declaration for &lt;code&gt;data Foo a&lt;/code&gt;. Using this feature requires the use of &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;).</source>
          <target state="translated">这与在声明 &lt;code&gt;data Foo a&lt;/code&gt; 之后编写 &lt;code&gt;deriving Foo&lt;/code&gt; 基本上相同。使用此功能需要使用&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;#partial-type-signatures&quot;&gt;部分类型签名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6d6cf1a68093409280369c1b6acf1d281e7ce24d" translate="yes" xml:space="preserve">
          <source>This is expected to improve performance on average, but actual performance difference can vary.</source>
          <target state="translated">预计这将提高平均性能,但实际性能差异会有所不同。</target>
        </trans-unit>
        <trans-unit id="9ac537ddcd723a43b8f01589d4e737eed3f70681" translate="yes" xml:space="preserve">
          <source>This is exposed solely for people writing GHC rewrite rules.</source>
          <target state="translated">这完全是为写GHC改写规则的人暴露的。</target>
        </trans-unit>
        <trans-unit id="8f87cd084e7f91046e80a5ffa06a25dbafabc73f" translate="yes" xml:space="preserve">
          <source>This is for specialist applications that may require symbols defined in these Haskell libraries at runtime even though they aren&amp;rsquo;t referenced by any other code linked into the executable. If you&amp;rsquo;re using &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt;, you probably also want &lt;code&gt;-rdynamic&lt;/code&gt;.</source>
          <target state="translated">这适用于可能需要在运行时在这些Haskell库中定义的符号的专业应用程序，即使未链接到可执行文件的任何其他代码引用了它们。如果您正在使用 &lt;code&gt;-fwhole-archive-hs-libs&lt;/code&gt; ，则可能还需要 &lt;code&gt;-rdynamic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb0b93f1aaeb2183a73344bfad7f37c373c52776" translate="yes" xml:space="preserve">
          <source>This is how to define &lt;code&gt;insertLookup&lt;/code&gt; using &lt;code&gt;insertLookupWithKey&lt;/code&gt;:</source>
          <target state="translated">这是使用 &lt;code&gt;insertLookupWithKey&lt;/code&gt; 定义 &lt;code&gt;insertLookup&lt;/code&gt; 的方法：</target>
        </trans-unit>
        <trans-unit id="f42e6638d71ed609c1ebc5bfa4f5a4bdde5aa067" translate="yes" xml:space="preserve">
          <source>This is illegal because the use of &lt;a href=&quot;#extension-BangPatterns&quot;&gt;&lt;code&gt;BangPatterns&lt;/code&gt;&lt;/a&gt; on the right-hand sides prevents it from being a well formed expression. However, constructing a strict pattern synonym is quite possible with an explicitly bidirectional pattern synonym:</source>
          <target state="translated">这是非法的，因为在右侧使用&lt;a href=&quot;#extension-BangPatterns&quot;&gt; &lt;code&gt;BangPatterns&lt;/code&gt; 会&lt;/a&gt;阻止它成为格式正确的表达。但是，使用明确的双向模式同义词来构造严格的模式同义词是很有可能的：</target>
        </trans-unit>
        <trans-unit id="8c0c93b41bba3d3d671093acebd3b256b511ac64" translate="yes" xml:space="preserve">
          <source>This is internally implemented as count-leading-zeros machine instruction.</source>
          <target state="translated">这在内部实现为计数前导-零的机器指令。</target>
        </trans-unit>
        <trans-unit id="852b04a3b6aa2150c763c2710aeb536c17bc4e95" translate="yes" xml:space="preserve">
          <source>This is just a convenience function, it's defined simply as:</source>
          <target state="translated">这只是一个方便函数,它的定义很简单,就是。</target>
        </trans-unit>
        <trans-unit id="e45e37056992d6af3645dca1e73531419ebe8cab" translate="yes" xml:space="preserve">
          <source>This is mostly done during Cmm passes. However this can miss corner cases. So at -O2 we run the pass again at the asm stage to catch these.</source>
          <target state="translated">这主要是在Cmm传球时进行的。然而,这可能会漏掉一些角落的情况。因此,在-O2时,我们在asm阶段再次运行该通道,以捕捉这些情况。</target>
        </trans-unit>
        <trans-unit id="a5b597ca7719e3d8708a1e507512f84a11523c7d" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">这通常在一组替代方法的末尾使用，在这些替代方法中，我们希望根据高层构造返回错误消息，而不是返回所有可能的字符。例如，如果 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 示例中的 &lt;code&gt;expr&lt;/code&gt; 解析器失败，则错误消息为：'...：expressioning expression'。如果没有 &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 组合器，则消息将类似于'...：期待&amp;ldquo; let&amp;rdquo;或字母&amp;ldquo;&amp;rdquo;，这不太友好。</target>
        </trans-unit>
        <trans-unit id="39a3eeed9577807a13413d7d9a4747103d4ba578" translate="yes" xml:space="preserve">
          <source>This is normally used at the end of a set alternatives where we want to return an error message in terms of a higher level construct rather than returning all possible characters. For example, if the &lt;code&gt;expr&lt;/code&gt; parser from the &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; example would fail, the error message is: '...: expecting expression'. Without the &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; combinator, the message would be like '...: expecting &quot;let&quot; or letter', which is less friendly.</source>
          <target state="translated">这通常在一组替代方法的末尾使用，在这些替代方法中，我们希望根据高层构造返回错误消息，而不是返回所有可能的字符。例如，如果 &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 示例中的 &lt;code&gt;expr&lt;/code&gt; 解析器失败，则错误消息为：'...：expressioning expression'。如果没有 &lt;code&gt;(&amp;lt;?&amp;gt;)&lt;/code&gt; 组合器，则消息将类似于'...：期待&amp;ldquo; let&amp;rdquo;或字母&amp;ldquo;&amp;rdquo;，这不太友好。</target>
        </trans-unit>
        <trans-unit id="c67587857810fc437f5fd2889f14753f716a50b7" translate="yes" xml:space="preserve">
          <source>This is not ideal in certain cases, like when the output is long, or contains strings with non-ascii characters.</source>
          <target state="translated">这在某些情况下并不理想,比如当输出很长,或者包含非ascii字符的字符串时。</target>
        </trans-unit>
        <trans-unit id="19107584e7f459839bffc5515c49619c3a279acc" translate="yes" xml:space="preserve">
          <source>This is not processed for special chars. use stringToHtml or lineToHtml instead, for user strings, because they understand special chars, like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特殊字符不进行处理。对于用户字符串，请使用stringToHtml或lineToHtml代替，因为它们可以理解特殊字符，例如 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-ord#v:-60-&quot;&gt;&amp;lt;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7fa5f45c008c43283961b6bf73fec56028cc02f" translate="yes" xml:space="preserve">
          <source>This is particularly useful in conjunction with larger &lt;code&gt;-A&lt;/code&gt; values, for example &lt;code&gt;-A64m -n4m&lt;/code&gt; is a useful combination on larger core counts (8+).</source>
          <target state="translated">与较大的 &lt;code&gt;-A&lt;/code&gt; 值结合使用时，这特别有用，例如 &lt;code&gt;-A64m -n4m&lt;/code&gt; 对于较大的内核数（8+）是有用的组合。</target>
        </trans-unit>
        <trans-unit id="9eda36a1c5f71327f9a1ce36f39f69ceebc7a2ca" translate="yes" xml:space="preserve">
          <source>This is particularly useful with the &lt;code&gt;ViewPatterns&lt;/code&gt; extension to GHC, as follows:</source>
          <target state="translated">这对于GHC 的 &lt;code&gt;ViewPatterns&lt;/code&gt; 扩展特别有用，如下所示：</target>
        </trans-unit>
        <trans-unit id="f9953554c74c35663186a90c0246462e6382fb5f" translate="yes" xml:space="preserve">
          <source>This is rather similar to the class &lt;code&gt;IsString&lt;/code&gt; (see &lt;a href=&quot;#overloaded-strings&quot;&gt;Overloaded string literals&lt;/a&gt;), but with an additional type parameter that makes the text of the label available as a type-level string (see &lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;). Note that &lt;code&gt;fromLabel&lt;/code&gt; had an extra &lt;code&gt;Proxy# x&lt;/code&gt; argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see &lt;a href=&quot;#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;) can be used instead.</source>
          <target state="translated">这与类 &lt;code&gt;IsString&lt;/code&gt; 非常相似（请参见&lt;a href=&quot;#overloaded-strings&quot;&gt;重载的字符串文字&lt;/a&gt;），但是具有一个附加的type参数，该参数使标签的文本可用作类型级字符串（请参见&lt;a href=&quot;#type-level-literals&quot;&gt;Type-Level Literals&lt;/a&gt;）。请注意， &lt;code&gt;fromLabel&lt;/code&gt; 在GHC 8.0中有一个额外的 &lt;code&gt;Proxy# x&lt;/code&gt; 参数，但是在GHC 8.2中已将其删除，因为可以改用类型应用程序（请参阅&lt;a href=&quot;#visible-type-application&quot;&gt;可见类型应用程序&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="275797ad44149a221def0ee243441fcab463f9bc" translate="yes" xml:space="preserve">
          <source>This is rejected because there is no &amp;ldquo;outermost level&amp;rdquo; for the types on the RHS (it would obviously be terrible to add extra parameters to &lt;code&gt;PackMap&lt;/code&gt;), so no implicit quantification happens, and the declaration is rejected (with &amp;ldquo;&lt;code&gt;f&lt;/code&gt; is out of scope&amp;rdquo;). Solution: use an explicit &lt;code&gt;forall&lt;/code&gt;:</source>
          <target state="translated">这被拒绝是因为RHS上的类型没有&amp;ldquo;最外层&amp;rdquo;（向 &lt;code&gt;PackMap&lt;/code&gt; 添加额外的参数显然很糟糕），因此不会发生隐式量化，并且声明被拒绝（&amp;ldquo; &lt;code&gt;f&lt;/code&gt; 超出范围&amp;rdquo; &amp;rdquo;）。解决方案：使用显式的 &lt;code&gt;forall&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="965462ce779e5c5398c7b7c8822c6fe46cd11f7e" translate="yes" xml:space="preserve">
          <source>This is rejected by Haskell 98, but under Jones&amp;rsquo;s scheme the definition for &lt;code&gt;g&lt;/code&gt; is typechecked first, separately from that for &lt;code&gt;f&lt;/code&gt;, because the reference to &lt;code&gt;f&lt;/code&gt; in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s right hand side is ignored by the dependency analysis. Then &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type is generalised, to get</source>
          <target state="translated">这是通过Haskell的98拒绝，但在琼斯的方案为定义 &lt;code&gt;g&lt;/code&gt; 首先typechecked，分别从对于 &lt;code&gt;f&lt;/code&gt; ，因为参考以 &lt;code&gt;f&lt;/code&gt; 在 &lt;code&gt;g&lt;/code&gt; 的右手侧由依赖性分析忽略。然后将 &lt;code&gt;g&lt;/code&gt; 的类型归纳为</target>
        </trans-unit>
        <trans-unit id="173eae666fe7062188303aaed7c3e9e91b4501ad" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;1&lt;/code&gt; when the compiler supports Template Haskell, and to &lt;code&gt;0&lt;/code&gt; when not. The latter is the case for a stage-1 compiler during bootstrapping, or on architectures where the interpreter is not available.</source>
          <target state="translated">如果编译器支持Template Haskell，则将其设置为 &lt;code&gt;1&lt;/code&gt; ；否则，将其设置为 &lt;code&gt;0&lt;/code&gt; 。后者是在引导过程中或在没有解释器的体系结构上的阶段1编译器的情况。</target>
        </trans-unit>
        <trans-unit id="e2a9fd34e0777a91dc7abb06fe3e0b3098e9ec74" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">这甚至适用于抽象类型，因为 &lt;code&gt;&lt;a href=&quot;control-applicative#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的定律暗示了一种关联性。</target>
        </trans-unit>
        <trans-unit id="e5265ef186d0fe504d07549453be769b06cb5de9" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the laws for &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; imply a form of associativity.</source>
          <target state="translated">这甚至适用于抽象类型，因为 &lt;code&gt;&lt;a href=&quot;prelude#v:-60--42--62-&quot;&gt;&amp;lt;*&amp;gt;&lt;/a&gt;&lt;/code&gt; 的定律暗示了一种关联性。</target>
        </trans-unit>
        <trans-unit id="886cde162909e5053a7382858de7970df163c591" translate="yes" xml:space="preserve">
          <source>This is suitable even for abstract types, as the monoid is assumed to satisfy the monoid laws. Alternatively, one could define &lt;code&gt;foldr&lt;/code&gt;:</source>
          <target state="translated">这甚至适用于抽象类型，因为假定类人动物满足类人动物定律。或者，可以定义 &lt;code&gt;foldr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bbe2ee805fe872cdfa9dad562a94abbdd44ba100" translate="yes" xml:space="preserve">
          <source>This is suitable for datatypes that are exported transparently.</source>
          <target state="translated">这适用于透明导出的数据类型。</target>
        </trans-unit>
        <trans-unit id="fb6774461de6668cb4c86bcd9b2d0f93d1213ac5" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 的&amp;ldquo;后门&amp;rdquo; ，允许随时执行 &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。为了安全起见， &lt;code&gt;&lt;a href=&quot;ghc-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算应无副作用且与环境无关。</target>
        </trans-unit>
        <trans-unit id="e076e79d373c95008b4305220e373d648e1a35dc" translate="yes" xml:space="preserve">
          <source>This is the &quot;back door&quot; into the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad, allowing &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation to be performed at any time. For this to be safe, the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; computation should be free of side effects and independent of its environment.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad 的&amp;ldquo;后门&amp;rdquo; ，允许随时执行 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算。为了安全起见， &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 计算应无副作用且与环境无关。</target>
        </trans-unit>
        <trans-unit id="fbf56641bd07ddb82df111a846a14d313459064a" translate="yes" xml:space="preserve">
          <source>This is the analogue of the &lt;code&gt;LINE&lt;/code&gt; pragma and is likewise intended for use in automatically generated Haskell code. It lets you specify the column number of the original code; for example</source>
          <target state="translated">这是 &lt;code&gt;LINE&lt;/code&gt; 编译指示的类似物，同样适用于自动生成的Haskell代码。它允许您指定原始代码的列号；例如</target>
        </trans-unit>
        <trans-unit id="5c9cf33d55e8504f25f0586b2ca2f9cf2d7a74c1" translate="yes" xml:space="preserve">
          <source>This is the defined behaviour of &lt;code&gt;getContents&lt;/code&gt;: it puts the stdin Handle in a state known as semi-closed, wherein any further I/O operations on it are forbidden. Because I/O state is retained between computations, the semi-closed state persists until the next &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">这是 &lt;code&gt;getContents&lt;/code&gt; 的已定义行为：将stdin Handle置于一种称为半封闭的状态，其中禁止对其进行任何进一步的I / O操作。由于在两次计算之间会保留I / O状态，因此半封闭状态将一直保持到下一个&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt;命令为止。</target>
        </trans-unit>
        <trans-unit id="d59a26993924ddd4622ca180b22b28d96a32273b" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="a8cafe2ab0917d4201e6879d83ae5338339737b2" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="f6167f3d89f3a57f13ddc1cfc30ba818a1c14f35" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="1d382c742dccd9be34f30f4a4585a36c280b6334" translate="yes" xml:space="preserve">
          <source>This is the fundamental &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; tactic.</source>
          <target state="translated">这是基本的&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMatched&quot;&gt;WhenMatched&lt;/a&gt;&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="cbc6595af04522c2fde6302bbc4d97ab2ecf3276" translate="yes" xml:space="preserve">
          <source>This is the initial locale encoding: if it has been subsequently changed by &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; this value will not reflect that change.</source>
          <target state="translated">这是初始的语言环境编码：如果后来被 &lt;code&gt;&lt;a href=&quot;ghc-io-encoding#v:setLocaleEncoding&quot;&gt;setLocaleEncoding&lt;/a&gt;&lt;/code&gt; 更改，则此值将不会反映该更改。</target>
        </trans-unit>
        <trans-unit id="abd17a970d52fd304b594c189a551764634555bd" translate="yes" xml:space="preserve">
          <source>This is the magic cut-off figure for unfolding (aka inlining): below this size, a function definition will be unfolded at the call-site, any bigger and it won&amp;rsquo;t. The size computed for a function depends on two things: the actual size of the expression minus any discounts that apply depending on the context into which the expression is to be inlined.</source>
          <target state="translated">这是展开（即内联）的不可思议的临界值：在此大小以下，函数定义将在调用位置展开，更大的部分将不会展开。为函数计算的大小取决于两件事：表达式的实际大小减去根据表达式要内联的上下文而适用的任何折扣。</target>
        </trans-unit>
        <trans-unit id="67b68027f5d62fd3f61a1b54666f56f7507aeca1" translate="yes" xml:space="preserve">
          <source>This is the most basic way to make your program go faster. Compilation time will be slower, especially with &lt;code&gt;-O2&lt;/code&gt;.</source>
          <target state="translated">这是使程序运行更快的最基本方法。编译时间会更慢，尤其是使用 &lt;code&gt;-O2&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="da3c5884261af5d6c5ce2a2fefd25b97aeda4835" translate="yes" xml:space="preserve">
          <source>This is the most general interface for building a weak pointer.</source>
          <target state="translated">这是最通用的构建弱指针的接口。</target>
        </trans-unit>
        <trans-unit id="5dbbb7f4bd171d6e5fe3f02c892e785922548729" translate="yes" xml:space="preserve">
          <source>This is the most general of the grouping-type statements. In this form, f is required to have type &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt;. As with the &lt;code&gt;then f by e&lt;/code&gt; case above, the first argument is a function supplied to f by the compiler which lets it compute e on every element of the list being transformed. However, unlike the non-grouping case, f additionally partitions the list into a number of sublists: this means that at every point after this statement, binders occurring before it in the comprehension refer to &lt;em&gt;lists&lt;/em&gt; of possible values, not single values. To help understand this, let&amp;rsquo;s look at an example:</source>
          <target state="translated">这是最通用的分组类型语句。在这种形式下，要求f具有类型 &lt;code&gt;forall a. (a -&amp;gt; t) -&amp;gt; [a] -&amp;gt; [[a]]&lt;/code&gt; 。与上面的 &lt;code&gt;then f by e&lt;/code&gt; 情况一样，第一个参数是由编译器提供给f的函数，该函数使它可以对要转换的列表的每个元素计算e。但是，与非分组情况不同，f将列表另外划分为多个子列表：这意味着在该语句之后的每个点，在理解中出现在其之前的联编程序都引用可能值的&lt;em&gt;列表&lt;/em&gt;，而不是单个值。为了帮助理解这一点，让我们看一个例子：</target>
        </trans-unit>
        <trans-unit id="97cacebb8a50334f0aa10455086684215843c90c" translate="yes" xml:space="preserve">
          <source>This is the most general way to spawn an external process. The process can be a command line to be executed by a shell or a raw command with a list of arguments. The stdin, stdout, and stderr streams of the new process may individually be attached to new pipes, to existing &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s, or just inherited from the parent (the default.)</source>
          <target state="translated">这是产生外部进程的最通用方法。该过程可以是要由Shell执行的命令行，也可以是带有参数列表的原始命令。新进程的stdin，stdout和stderr流可以分别附加到新管道，现有 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 或仅从父级继承（默认值）。</target>
        </trans-unit>
        <trans-unit id="17c6bc999a6e66cdf70760668583b194f94060fb" translate="yes" xml:space="preserve">
          <source>This is the most minimal token definition. It is recommended to use this definition as the basis for other definitions. &lt;code&gt;emptyDef&lt;/code&gt; has no reserved names or operators, is case sensitive and doesn't accept comments, identifiers or operators.</source>
          <target state="translated">这是最小的令牌定义。建议将此定义用作其他定义的基础。 &lt;code&gt;emptyDef&lt;/code&gt; 没有保留的名称或运算符，区分大小写，并且不接受注释，标识符或运算符。</target>
        </trans-unit>
        <trans-unit id="28714170914c36c5937fb4d6795c7183bf135afa" translate="yes" xml:space="preserve">
          <source>This is the most primitive combinator for accepting tokens. For example, the &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; parser could be implemented as:</source>
          <target state="translated">这是用于接受令牌的最原始的组合器。例如， &lt;code&gt;&lt;a href=&quot;text-parsec-char#v:char&quot;&gt;char&lt;/a&gt;&lt;/code&gt; 解析器可以实现为：</target>
        </trans-unit>
        <trans-unit id="6b5e00d2ed34cf00eb62f197974c932b271f59b3" translate="yes" xml:space="preserve">
          <source>This is the oldest code generator in GHC and is generally not included any more having been deprecated around GHC 7.0. Select it with the &lt;code&gt;-fvia-C&lt;/code&gt; flag.</source>
          <target state="translated">这是GHC中最古老的代码生成器，通常不包含在GHC 7.0中已弃用的代码生成器。使用 &lt;code&gt;-fvia-C&lt;/code&gt; 标志选择它。</target>
        </trans-unit>
        <trans-unit id="3ef0a3e02d26e1de4897c94f804fb945f14b00c6" translate="yes" xml:space="preserve">
          <source>This is the simplest of the exception-catching functions. It takes a single argument, runs it, and if an exception is raised the &quot;handler&quot; is executed, with the value of the exception passed as an argument. Otherwise, the result is returned as normal. For example:</source>
          <target state="translated">这是异常捕获函数中最简单的一个。它接受一个参数,运行它,如果出现异常,&quot;处理程序 &quot;就会被执行,异常值作为参数传递。否则,结果将按正常方式返回。例如</target>
        </trans-unit>
        <trans-unit id="709bbf178e88d31284082a439684f263fe4c4cba" translate="yes" xml:space="preserve">
          <source>This is the simplest representation of UTC. It consists of the day number, and a time offset from midnight. Note that if a day has a leap second added to it, it will have 86401 seconds.</source>
          <target state="translated">这是UTC最简单的表示方法。它由日号和从午夜开始的时间偏移组成。请注意,如果一天有一个闰秒,它将有86401秒。</target>
        </trans-unit>
        <trans-unit id="e4dbe9128e5734a5df9b1f11da3e326916a92167" translate="yes" xml:space="preserve">
          <source>This is the traditional batch-compiler mode, in which GHC can compile source files one at a time, or link objects together into an executable. See &lt;a href=&quot;#options-order&quot;&gt;Batch compiler mode&lt;/a&gt;.</source>
          <target state="translated">这是传统的批处理编译器模式，GHC可以一次编译一个源文件，也可以将对象链接在一起成为可执行文件。请参阅&lt;a href=&quot;#options-order&quot;&gt;批处理编译器模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63579352bd238619f1e8291119e93600ef4a9cde" translate="yes" xml:space="preserve">
          <source>This is the type of a field formatter reified over its argument.</source>
          <target state="translated">这是在其参数上重构的字段格式器的类型。</target>
        </trans-unit>
        <trans-unit id="e04da25499a8419831fe5bf0581bda0dfaf2d2e9" translate="yes" xml:space="preserve">
          <source>This is thrown when the user calls &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;. The first &lt;code&gt;String&lt;/code&gt; is the argument given to &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt;, second &lt;code&gt;String&lt;/code&gt; is the location.</source>
          <target state="translated">用户调用 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 时抛出此错误。第一个 &lt;code&gt;String&lt;/code&gt; 是给 &lt;code&gt;&lt;a href=&quot;prelude#v:error&quot;&gt;error&lt;/a&gt;&lt;/code&gt; 的参数，第二个 &lt;code&gt;String&lt;/code&gt; 是位置。</target>
        </trans-unit>
        <trans-unit id="a3b52992dd96200ef77ecde2d026b069e2b12589" translate="yes" xml:space="preserve">
          <source>This is used for holes or unresolved identifiers in AST quotes. Note that it could either have a variable name or constructor name.</source>
          <target state="translated">这用于AST引号中的漏洞或未解决的标识符。注意,它可以有一个变量名或构造函数名。</target>
        </trans-unit>
        <trans-unit id="328c1fbc5f4cd720ec3ec26821113be04b4a5990" translate="yes" xml:space="preserve">
          <source>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type &lt;code&gt;Any&lt;/code&gt; (by way of &lt;code&gt;unsafeCoerce#&lt;/code&gt;) and the result type is allowed to be an unboxed tuple or the type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">这用于导入遵循内部GHC调用约定的Cmm代码编写的函数。参数和结果必须是未装箱的类型，但参数可以是 &lt;code&gt;Any&lt;/code&gt; 类型（通过 &lt;code&gt;unsafeCoerce#&lt;/code&gt; ），并且结果类型可以是未装箱的元组或 &lt;code&gt;Any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="8b782ef95535f2b46a643a86d5559d4d59530093" translate="yes" xml:space="preserve">
          <source>This is useful for functions parameterized by a monad transformer.</source>
          <target state="translated">这对于通过单项式变换器进行参数化的函数非常有用。</target>
        </trans-unit>
        <trans-unit id="191eaf7a7c1efa9d12f4d0ead171eac959ffb8bd" translate="yes" xml:space="preserve">
          <source>This is useful in combination with &lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt;&lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt;&lt;/a&gt; to test if the generated files depend on the order of &lt;code&gt;Unique&lt;/code&gt;&amp;lsquo;s.</source>
          <target state="translated">与&lt;a href=&quot;#ghc-flag--dinitial-unique=%E2%9F%A8s%E2%9F%A9&quot;&gt; &lt;code&gt;-dinitial-unique=⟨s⟩&lt;/code&gt; &lt;/a&gt;结合使用以测试生成的文件是否取决于 &lt;code&gt;Unique&lt;/code&gt; 的顺序时，这很有用。</target>
        </trans-unit>
        <trans-unit id="d104180869342bc19c17c8e3619b3cc9055aa1fa" translate="yes" xml:space="preserve">
          <source>This is why the RIO module is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt;&amp;gt;, to allow the &lt;code&gt;Danger&lt;/code&gt; module to import it. The &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; flag doesn&amp;rsquo;t place any restrictions on the module like &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; does (expect to restrict overlapping instances to &lt;a href=&quot;#safe-overlapping-instances&quot;&gt;safe overlapping instances&lt;/a&gt;). Instead the module author claims that while code may use unsafe features internally, it only exposes an API that can used in a safe manner.</source>
          <target state="translated">这就是为什么RIO模块使用&amp;ldquo; &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;或&amp;ldquo; &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; &amp;gt;进行编译以允许 &lt;code&gt;Danger&lt;/code&gt; 模块导入它的原因。该&lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt;标志不一样的地方在模块上的任何限制，&lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt;没有（想到限制重叠的情况下，以&lt;a href=&quot;#safe-overlapping-instances&quot;&gt;安全重叠的情况下&lt;/a&gt;）。相反，该模块的作者声称，尽管代码可能在内部使用了不安全的功能，但它仅公开了可以安全使用的API。</target>
        </trans-unit>
        <trans-unit id="b712b2b82446ae28f73908890d2ef7531e15ac14" translate="yes" xml:space="preserve">
          <source>This is widely considered a misfeature, and is going to be removed from the language. In GHC, it is controlled by the deprecated extension &lt;code&gt;DatatypeContexts&lt;/code&gt;.</source>
          <target state="translated">人们普遍认为这是一种错误的功能，并且将从该语言中删除。在GHC中，它由已弃用的扩展 &lt;code&gt;DatatypeContexts&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="6778bfd500940c8e2d9a62565cee855196c0bd56" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t particularly enlightening. What happened is that &lt;code&gt;left&lt;/code&gt; is bound to an unevaluated computation (a suspension, or thunk), and &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; does not force any evaluation. The idea is that &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; can be used to inspect values at a breakpoint without any unfortunate side effects. It won&amp;rsquo;t force any evaluation, which could cause the program to give a different answer than it would normally, and hence it won&amp;rsquo;t cause any exceptions to be raised, infinite loops, or further breakpoints to be triggered (see &lt;a href=&quot;#nested-breakpoints&quot;&gt;Nested breakpoints&lt;/a&gt;). Rather than forcing thunks, &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt; binds each thunk to a fresh variable beginning with an underscore, in this case &lt;code&gt;_t1&lt;/code&gt;.</source>
          <target state="translated">这不是特别有启发性。发生的是， &lt;code&gt;left&lt;/code&gt; 绑定到未评估的计算（挂起或重击），并且&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;不会强制执行任何评估。这个想法是&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;可以用来检查断点处的值，而没有任何不幸的副作用。它不会强制执行任何评估，这可能导致程序给出与正常情况不同的答案，因此不会引发任何异常，无限循环或触发其他断点（请参见&lt;a href=&quot;#nested-breakpoints&quot;&gt;嵌套断点&lt;/a&gt;）。 。&lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt;不会强制重击，而是将每个重 &lt;code&gt;_t1&lt;/code&gt; 绑定到以下划线开头的新变量，在本例中为_t1。</target>
        </trans-unit>
        <trans-unit id="a27ce07dfb7b638358503a182b9e384fb7c6d870" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t the whole story: GHC also looks for modules in pre-compiled libraries, known as packages. See the section on packages (&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;) for details.</source>
          <target state="translated">这还不是全部：GHC还在预编译的库中寻找模块，即软件包。有关详细信息，请参见有关包（&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;）的部分。</target>
        </trans-unit>
        <trans-unit id="a1decd194e9db593e0098385b29579f07d63ab43" translate="yes" xml:space="preserve">
          <source>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it&amp;rsquo;s not clear the payoff is worth it. If you want to restrict &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind in the instance above, just use a kind signature in the instance head.</source>
          <target state="translated">缺乏类型推理只是GHC中的一个工程问题，但是使其工作将对推理基础结构做出重大改变，并且尚不清楚回报是否值得。如果要在上述实例中限制 &lt;code&gt;b&lt;/code&gt; 的种类，只需在实例头中使用种类签名即可。</target>
        </trans-unit>
        <trans-unit id="9700917da64757c5e788e69e5482f32627c03338" translate="yes" xml:space="preserve">
          <source>This legacy module provides access to the list-specialised operations of &lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;. This module may go away again in future GHC versions and is provided as transitional tool to access some of the list-specialised operations that had to be generalised due to the implementation of the &lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;Foldable/Traversable-in-Prelude Proposal (FTP)&lt;/a&gt;.</source>
          <target state="translated">此旧版模块提供对&lt;a href=&quot;data-list&quot;&gt;Data.List&lt;/a&gt;的列表特定操作的访问。在将来的GHC版本中，该模块可能会再次消失，并且作为过渡工具提供，用于访问由于实施了&lt;a href=&quot;https://wiki.haskell.org/Foldable_Traversable_In_Prelude&quot;&gt;可折叠/前奏式提议（FTP）&lt;/a&gt;而必须概括的一些列表专用操作。</target>
        </trans-unit>
        <trans-unit id="e36c09f207f2c815a09c379dd1fb2c4090b7e037" translate="yes" xml:space="preserve">
          <source>This lets you use a difference list of a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这可让您使用的差异列表 &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ae93c187283325d394ffe8b8fa3d56bccb015c1" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a floating point value. Returns the value of the number. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">这个词素解析器解析一个浮点值。返回数字的值。数字是根据 Haskell 报告中定义的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="527289d10a300c5f304dffa89904edeb2b163f3d" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法标识符。返回标识符字符串。对于保留字的标识符，此解析器将失败。合法标识符（开始）字符和保留字在传递给 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;identifier&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="163be1f77c7bb2337562a94b4777b7e5c72dc90c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal identifier. Returns the identifier string. This parser will fail on identifiers that are reserved words. Legal identifier (start) characters and reserved words are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;identifier&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法标识符。返回标识符字符串。对于保留字的标识符，此解析器将失败。合法标识符（开始）字符和保留字在传递给 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;identifier&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="7bd0992deca5f231a8e4bc4885419bb1a6bfcba7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法运算符。返回运算符的名称。该解析器将在所有保留运算符上失败。合法运算符（开始）字符和保留运算符在传递给 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;operator&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="76e90133adb94e7c3876b0dc934a4c349e00e9fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a legal operator. Returns the name of the operator. This parser will fail on any operators that are reserved operators. Legal operator (start) characters and reserved operators are defined in the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; that is passed to &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt;. An &lt;code&gt;operator&lt;/code&gt; is treated as a single token using &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该词素分析器分析合法运算符。返回运算符的名称。该解析器将在所有保留运算符上失败。合法运算符（开始）字符和保留运算符在传递给 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:makeTokenParser&quot;&gt;makeTokenParser&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#t:LanguageDef&quot;&gt;LanguageDef&lt;/a&gt;&lt;/code&gt; 中定义。使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;operator&lt;/code&gt; 视为单个令牌。</target>
        </trans-unit>
        <trans-unit id="d4009cc9448509a74e6a8d7bad513db7193f58fd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a literal string. Returns the literal string value. This parsers deals correctly with escape sequences and gaps. The literal string is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">这个词素解析器解析一个字面字符串。返回字面字符串的值。这个解析器能正确处理转义序列和间隙。字符串是根据Haskell报告中定义的语法规则进行解析的(与大多数编程语言相当接近)。</target>
        </trans-unit>
        <trans-unit id="5e7e07a35842fb9e4e49f081c6500aa5f24d9520" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">该词素分析器分析自然数（正整数）。返回数字的值。该数字可以 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 指定。该数字是根据Haskell报告中的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="ace0ef235b44c04e9847cae55d4c39fc3655ea48" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a natural number (a positive whole number). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">该词素分析器分析自然数（正整数）。返回数字的值。该数字可以 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 指定。该数字是根据Haskell报告中的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="5b51da9dfdc6deacb56625f72d3743f1f276426c" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses a single literal character. Returns the literal character value. This parsers deals correctly with escape sequences. The literal character is parsed according to the grammar rules defined in the Haskell report (which matches most programming languages quite closely).</source>
          <target state="translated">这个词素解析器解析一个单一的文字字符。返回字面字符的值。这个解析器正确处理转义序列。字符是根据Haskell报告中定义的语法规则进行解析的(与大多数编程语言非常接近)。</target>
        </trans-unit>
        <trans-unit id="df49a67e0891da13df2aeac391d3a61690541ebd" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">该词素分析器分析整数（整数）。该解析器很 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 只不过可以加上符号前缀（即&amp;ldquo;-&amp;rdquo;或&amp;ldquo; +&amp;rdquo;）。返回数字的值。该数字可以 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 指定。该数字是根据Haskell报告中的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="ca0065c43e88f0ea0be37c852f441cefb8de14a7" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses an integer (a whole number). This parser is like &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; except that it can be prefixed with sign (i.e. '-' or '+'). Returns the value of the number. The number can be specified in &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt;. The number is parsed according to the grammar rules in the Haskell report.</source>
          <target state="translated">该词素分析器分析整数（整数）。该解析器很 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 只不过可以加上符号前缀（即&amp;ldquo;-&amp;rdquo;或&amp;ldquo; +&amp;rdquo;）。返回数字的值。该数字可以 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:decimal&quot;&gt;decimal&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:hexadecimal&quot;&gt;hexadecimal&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:octal&quot;&gt;octal&lt;/a&gt;&lt;/code&gt; 指定。该数字是根据Haskell报告中的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="bf7d3fe039b607009e325c09fadc027724bbba18" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">这个Lexeme解析器解析 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 。返回数字的值。该解析器处理自然数和浮点数的语法规则中的任何重叠。该数字是根据Haskell报告中定义的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="4cc0de1ff1da25f44b1ba64f4600fc6b2f58174a" translate="yes" xml:space="preserve">
          <source>This lexeme parser parses either &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt;. Returns the value of the number. This parsers deals with any overlap in the grammar rules for naturals and floats. The number is parsed according to the grammar rules defined in the Haskell report.</source>
          <target state="translated">这个Lexeme解析器解析 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:natural&quot;&gt;natural&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:float&quot;&gt;float&lt;/a&gt;&lt;/code&gt; 。返回数字的值。该解析器处理自然数和浮点数的语法规则中的任何重叠。该数字是根据Haskell报告中定义的语法规则进行解析的。</target>
        </trans-unit>
        <trans-unit id="8b3e538648d90a568eed7b3e4b7980db877318e7" translate="yes" xml:space="preserve">
          <source>This lexer is not completely faithful to the Haskell lexical syntax in the following respects:</source>
          <target state="translated">这个词法器在以下方面并不完全忠实于Haskell词法。</target>
        </trans-unit>
        <trans-unit id="ba0c905e7229e2d42cfbc9060686e3e8b51c3edc" translate="yes" xml:space="preserve">
          <source>This library defines parser combinators for precedence parsing.</source>
          <target state="translated">这个库定义了用于优先解析的解析器组合器。</target>
        </trans-unit>
        <trans-unit id="26d58c3f8313372fb9a5712eb67174707d34b82e" translate="yes" xml:space="preserve">
          <source>This library provides facilities for parsing the command-line options in a standalone program. It is essentially a Haskell port of the GNU &lt;code&gt;getopt&lt;/code&gt; library.</source>
          <target state="translated">该库提供了用于解析独立程序中的命令行选项的功能。本质上，它是GNU &lt;code&gt;getopt&lt;/code&gt; 库的Haskell端口。</target>
        </trans-unit>
        <trans-unit id="dd805dfecd7f77257c432c66329c165e81f0fc28" translate="yes" xml:space="preserve">
          <source>This library provides support for &lt;em&gt;strict&lt;/em&gt; state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones &lt;em&gt;Lazy Functional State Threads&lt;/em&gt;.</source>
          <target state="translated">如John Launchbury和Simon Peyton Jones的&lt;em&gt;Lazy Functional State Threads&lt;/em&gt;在PLDI '94论文中所述，该库提供了对&lt;em&gt;严格&lt;/em&gt;状态线程的支持。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8126030a0db08f6efcbf327884b71cf1e6318582" translate="yes" xml:space="preserve">
          <source>This limitation is easily subvertible, so please ask if you get stuck on it.</source>
          <target state="translated">这个限制是很容易被颠覆的,所以如果你卡在这个问题上,请问。</target>
        </trans-unit>
        <trans-unit id="21a515f07e3c656c64c893fcd677dfba412563b8" translate="yes" xml:space="preserve">
          <source>This list could readily be extended; if there are Prelude functions that you use a lot which are not included, please tell us.</source>
          <target state="translated">这个列表可以很容易地扩展;如果有你经常使用的Prelude函数没有包括在内,请告诉我们。</target>
        </trans-unit>
        <trans-unit id="c9d77f7a9ab7e1d50b50bd600bb71a7967ecbbfb" translate="yes" xml:space="preserve">
          <source>This list is for GHC users to chat among themselves. If you have a specific question about GHC, please check the &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt; first.</source>
          <target state="translated">此列表供GHC用户彼此聊天。如果您有关于GHC的特定问题，请首先查看&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/FAQ&quot;&gt;FAQ&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29a814259d6babfac9ea76d85ac921a5f02baa19" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro expands to a string recording the version of &lt;code&gt;pkgname&lt;/code&gt; that is exposed for module import. It is identical in behavior to the &lt;code&gt;VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">从GHC 8.0开始可以使用此宏。它是为每个暴露的包装定义的。该宏扩展为一个字符串，该字符串记录了为模块导入而公开的 &lt;code&gt;pkgname&lt;/code&gt; 的版本。它的行为与Cabal定义的 &lt;code&gt;VERSION_pkgname&lt;/code&gt; 宏相同。</target>
        </trans-unit>
        <trans-unit id="a74c45d8cbbb98f3219b81a76db9cbe9b302bc7d" translate="yes" xml:space="preserve">
          <source>This macro is available starting GHC 8.0. It is defined for every exposed package. This macro is provided for convenience to write CPP conditionals testing if a package version is &lt;code&gt;x.y.z&lt;/code&gt; or later. It is identical in behavior to the &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; macros that Cabal defines.</source>
          <target state="translated">从GHC 8.0开始可以使用此宏。它是为每个暴露的包装定义的。提供此宏是为了方便编写CPP条件测试（如果程序包版本是 &lt;code&gt;x.y.z&lt;/code&gt; 或更高版本）。它的行为与Cabal定义的 &lt;code&gt;MIN_VERSION_pkgname&lt;/code&gt; 宏相同。</target>
        </trans-unit>
        <trans-unit id="369c31dee13e7ebf7250f99f560cae58a6ec67ab" translate="yes" xml:space="preserve">
          <source>This macro is available starting with GHC 7.10.1.</source>
          <target state="translated">这个宏从GHC 7.10.1开始可用。</target>
        </trans-unit>
        <trans-unit id="78b70fd2d98680d3ba8f51b750ceee956a98a51c" translate="yes" xml:space="preserve">
          <source>This macro is provided for convenience to write CPP conditionals testing whether the GHC version used is version &lt;code&gt;x.y.z.z'&lt;/code&gt; or later.</source>
          <target state="translated">提供此宏是为了方便编写CPP条件测试，以测试使用的GHC版本是 &lt;code&gt;x.y.z.z'&lt;/code&gt; 版本还是更高版本。</target>
        </trans-unit>
        <trans-unit id="9ccb8c1a1ef41b359721ee50eeb5b0ffe5456b94" translate="yes" xml:space="preserve">
          <source>This macro is set when pre-processing both Haskell source and C source, including the C source generated from a Haskell module (i.e. &lt;code&gt;.hs&lt;/code&gt;, &lt;code&gt;.lhs&lt;/code&gt;, &lt;code&gt;.c&lt;/code&gt; and &lt;code&gt;.hc&lt;/code&gt; files).</source>
          <target state="translated">在预处理Haskell源代码和C源代码（包括从Haskell模块生成的C源代码（即 &lt;code&gt;.hs&lt;/code&gt; ， &lt;code&gt;.lhs&lt;/code&gt; ， &lt;code&gt;.c&lt;/code&gt; 和 &lt;code&gt;.hc&lt;/code&gt; 文件））时，将设置此宏。</target>
        </trans-unit>
        <trans-unit id="126816cfbceb17265259c1bfd692cfa851e88117" translate="yes" xml:space="preserve">
          <source>This makes a copy, so does not retain the input string.</source>
          <target state="translated">这将进行复制,所以不会保留输入的字符串。</target>
        </trans-unit>
        <trans-unit id="409b9c14a753a56835750678eec0ceed50896009" translate="yes" xml:space="preserve">
          <source>This makes it convenient for printing the values of interesting variables or expressions inside a function. For example here we print the value of the variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">这使得在函数内部打印有趣的变量或表达式的值变得很方便。例如，在这里我们打印变量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的值：</target>
        </trans-unit>
        <trans-unit id="d154b682a58894f927011c8dcf1525090a6bca45" translate="yes" xml:space="preserve">
          <source>This may take real work, but&amp;hellip; There exist piles of massively-tuned library code, and the best thing is not to compete with it, but link with it.</source>
          <target state="translated">这可能需要实际工作，但是&amp;hellip;&amp;hellip;存在大量经过大规模调整的库代码，最好的办法不是与之竞争，而是与之竞争。</target>
        </trans-unit>
        <trans-unit id="8e305a9c2249a611331558008a6864ebdcc9df92" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;f&lt;/code&gt; 将不同的原始键映射到不同的结果键。该功能比 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 具有更好的性能。</target>
        </trans-unit>
        <trans-unit id="a2f7283b2f57776282bb867fc6a49c83c2f23c8b" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has better performance than &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;f&lt;/code&gt; 将不同的原始键映射到不同的结果键。该功能比 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 具有更好的性能。</target>
        </trans-unit>
        <trans-unit id="1d65304cb52af71023e15bd45422c06447d534f9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;f&lt;/code&gt; 将不同的原始键映射到不同的结果键。此功能比 &lt;code&gt;&lt;a href=&quot;data-intmap-lazy#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 的性能略好。</target>
        </trans-unit>
        <trans-unit id="9f79e70de4e10cc28ee0029d0a6a35c1bbea2e78" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;f&lt;/code&gt; 将不同的原始键映射到不同的结果键。此功能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 的性能略好。</target>
        </trans-unit>
        <trans-unit id="5f2b22c1be27f1ee28d05bb2aade303875940243" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;f&lt;/code&gt; maps distinct original keys to distinct resulting keys. This function has slightly better performance than &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;f&lt;/code&gt; 将不同的原始键映射到不同的结果键。此功能比 &lt;code&gt;&lt;a href=&quot;data-intmap-strict-internal#v:mapKeys&quot;&gt;mapKeys&lt;/a&gt;&lt;/code&gt; 的性能略好。</target>
        </trans-unit>
        <trans-unit id="9c92fe3388c138613ddb9738050b4232a8c3e292" translate="yes" xml:space="preserve">
          <source>This means that if you need to make a foreign call to a function that takes a long time or blocks indefinitely, then you should mark it &lt;code&gt;safe&lt;/code&gt; and use &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;. Some library functions make such calls internally; their documentation should indicate when this is the case.</source>
          <target state="translated">这意味着，如果需要对需要很长时间或无限期阻塞的函数进行外部调用，则应将其标记为 &lt;code&gt;safe&lt;/code&gt; 并使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;。一些库函数在内部进行此类调用；他们的文档应指出这种情况。</target>
        </trans-unit>
        <trans-unit id="c345f7d8502440fe1972767e0230a2d484f96fc3" translate="yes" xml:space="preserve">
          <source>This means that many operations on sequences are stricter than those on lists. For example,</source>
          <target state="translated">这意味着对序列的许多操作比对列表的操作更严格。例如:</target>
        </trans-unit>
        <trans-unit id="512d8c4339c4e152167f7ed6529861156bdd0ce2" translate="yes" xml:space="preserve">
          <source>This means that the usual string syntax can be used, e.g., for &lt;code&gt;ByteString&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, and other variations of string like types. String literals behave very much like integer literals, i.e., they can be used in both expressions and patterns. If used in a pattern the literal will be replaced by an equality test, in the same way as an integer literal is.</source>
          <target state="translated">这意味着可以使用常规的字符串语法，例如，用于 &lt;code&gt;ByteString&lt;/code&gt; ， &lt;code&gt;Text&lt;/code&gt; 和其他类似字符串的类型的变体。字符串文字的行为非常类似于整数文字，即，它们可以在表达式和模式中使用。如果在模式中使用，则文字将被相等性测试替代，就像整数文字一样。</target>
        </trans-unit>
        <trans-unit id="6e84b7b55ab4e53c7918a9eed0f0386ae7086f12" translate="yes" xml:space="preserve">
          <source>This means we're all done. All the builder data has now been written.</source>
          <target state="translated">这意味着我们已经完成了所有的工作。所有的构建器数据现在已经被写入。</target>
        </trans-unit>
        <trans-unit id="a699a362a2564a3c76496bfcaced4dda0fd71569" translate="yes" xml:space="preserve">
          <source>This mechanism makes use of GHC's efficient built-in generics support.</source>
          <target state="translated">这种机制利用了GHC高效的内置属性支持。</target>
        </trans-unit>
        <trans-unit id="ed8ed8da55dd83a0ef130774f673009214846879" translate="yes" xml:space="preserve">
          <source>This method is surprisingly useful. Where both instances exist and are lawful we have the following laws:</source>
          <target state="translated">这种方法出奇的有用。在这两种情况都存在且合法的情况下,我们有以下规律。</target>
        </trans-unit>
        <trans-unit id="917ff2b24c3401ef265e4f82c89c8ae89e4dbe83" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; as its default implementation (which ought to be equivalent to &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; for types which possess a 0th bit).</source>
          <target state="translated">此方法使用 &lt;code&gt;&lt;a href=&quot;data-bits#v:clearBit&quot;&gt;clearBit&lt;/a&gt; (&lt;a href=&quot;data-bits#v:bit&quot;&gt;bit&lt;/a&gt; 0) 0&lt;/code&gt; 作为其默认实现（对于拥有第0位的类型，此方法应等效于 &lt;code&gt;&lt;a href=&quot;data-bits#v:zeroBits&quot;&gt;zeroBits&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a56c576252b7c2f659be8b6306ca50d283138678" translate="yes" xml:space="preserve">
          <source>This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; option can be omitted.</source>
          <target state="translated">如果命令行中提到任何Haskell源文件，则此模式为默认模式，在这种情况下，可以忽略&lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;选项。</target>
        </trans-unit>
        <trans-unit id="5aa78e5fdb695de8a1ddc90859fa15ef056bc6c5" translate="yes" xml:space="preserve">
          <source>This mode is very similar to interactive mode, except that there is a single expression to evaluate which is specified on the command line as an argument to the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">此模式与交互模式非常相似，不同之处在于，存在一个要评估的表达式，该表达式在命令行上指定为 &lt;code&gt;-e&lt;/code&gt; 选项的参数：</target>
        </trans-unit>
        <trans-unit id="c36679dee1440f17c5d2fe66c1ebdd875fd933fe" translate="yes" xml:space="preserve">
          <source>This module also contains generalisations of &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; to work with any &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">该模块还包含 &lt;code&gt;&lt;a href=&quot;prelude#v:div&quot;&gt;div&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;prelude#v:mod&quot;&gt;mod&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:divMod&quot;&gt;divMod&lt;/a&gt;&lt;/code&gt; 的概括，可与任何 &lt;code&gt;&lt;a href=&quot;prelude#t:Real&quot;&gt;Real&lt;/a&gt;&lt;/code&gt; 实例一起使用。</target>
        </trans-unit>
        <trans-unit id="f4d1e1a6706fb58eb88829be1d42c2470d6cd3f3" translate="yes" xml:space="preserve">
          <source>This module can be imported for defining forward compatible &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; instances:</source>
          <target state="translated">可以导入此模块以定义向前兼容的 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="6e27f3d7a593111ec01d1dd70cd801444f3e1d34" translate="yes" xml:space="preserve">
          <source>This module contains platform specific information about types. __/As such the types presented on this page reflect the platform on which the documentation was generated and may not coincide with the types on your platform./__</source>
          <target state="translated">这个模块包含了关于类型的特定平台信息。_/因此,本页所展示的类型反映了文档生成的平台,可能与您平台上的类型不一致。</target>
        </trans-unit>
        <trans-unit id="69fea24c1770ed9b0390c085efc99817f8d87553" translate="yes" xml:space="preserve">
          <source>This module contains support for pooled memory management. Under this scheme, (re-)allocations belong to a given pool, and everything in a pool is deallocated when the pool itself is deallocated. This is useful when &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; with its implicit allocation and deallocation is not flexible enough, but explicit uses of &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; are too awkward.</source>
          <target state="translated">该模块包含对池内存管理的支持。在此方案下，（重新）分配属于给定的池，并且当池本身被释放时，池中的所有内容都将被释放。当具有隐式分配和释放的 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; 不够灵活，但是对 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; 的显式使用太尴尬时，这很有用。</target>
        </trans-unit>
        <trans-unit id="13d5f93e40c79a18376dc00ca5c87434053f0a7f" translate="yes" xml:space="preserve">
          <source>This module currently does not expose functions that require the special properties of fixed-size primitives. They are useful for prefixing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s with their size or for implementing chunked encodings. We will expose the corresponding functions in future releases of this library.</source>
          <target state="translated">该模块当前不公开需要固定大小基元的特殊属性的函数。它们对于为 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 加上大小前缀或实现分块编码很有用。我们将在此库的将来版本中公开相应的功能。</target>
        </trans-unit>
        <trans-unit id="5142c08054d9871661f7f0d130cb3d6fdd9407d3" translate="yes" xml:space="preserve">
          <source>This module defines a &quot;Fixed&quot; type for fixed-precision arithmetic. The parameter to &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; is any type that's an instance of &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; has a single method that gives the resolution of the &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">此模块为固定精度算术定义&amp;ldquo;固定&amp;rdquo;类型。 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 的参数是 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 实例的任何类型。 &lt;code&gt;&lt;a href=&quot;data-fixed#t:HasResolution&quot;&gt;HasResolution&lt;/a&gt;&lt;/code&gt; 有一个提供 &lt;code&gt;&lt;a href=&quot;data-fixed#t:Fixed&quot;&gt;Fixed&lt;/a&gt;&lt;/code&gt; 类型分辨率的方法。</target>
        </trans-unit>
        <trans-unit id="c812190315e834b8c95ed3f2997592b7564b3fdf" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">该模块定义了一个API，用于编写合并两个地图的函数。关键功能是 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。这些中的每一个都可以与几种不同的&amp;ldquo;合并策略&amp;rdquo;一起使用。</target>
        </trans-unit>
        <trans-unit id="748c4571f3ce28ef125886641fac7bef9890107e" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">该模块定义了一个API，用于编写合并两个地图的函数。关键功能是 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。这些中的每一个都可以与几种不同的&amp;ldquo;合并策略&amp;rdquo;一起使用。</target>
        </trans-unit>
        <trans-unit id="75f0e64e356523d1a0c9eb699ad805d54ab82048" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">该模块定义了一个API，用于编写合并两个地图的函数。关键功能是 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。这些中的每一个都可以与几种不同的&amp;ldquo;合并策略&amp;rdquo;一起使用。</target>
        </trans-unit>
        <trans-unit id="a495bc59840aa160735fbc988dd7aa12e8ba85b8" translate="yes" xml:space="preserve">
          <source>This module defines an API for writing functions that merge two maps. The key functions are &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt;. Each of these can be used with several different &quot;merge tactics&quot;.</source>
          <target state="translated">该模块定义了一个API，用于编写合并两个地图的函数。关键功能是 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:merge&quot;&gt;merge&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#v:mergeA&quot;&gt;mergeA&lt;/a&gt;&lt;/code&gt; 。这些中的每一个都可以与几种不同的&amp;ldquo;合并策略&amp;rdquo;一起使用。</target>
        </trans-unit>
        <trans-unit id="af9c5e66541cb60627fc011c4ff85f664b7cc4ed" translate="yes" xml:space="preserve">
          <source>This module defines bitwise operations for signed and unsigned integers. Instances of the class &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; types are available from this module, and instances for explicitly sized integral types are available from the &lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt; and &lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt; modules.</source>
          <target state="translated">此模块为有符号和无符号整数定义按位运算。该类的实例 &lt;code&gt;&lt;a href=&quot;data-bits#t:Bits&quot;&gt;Bits&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 类型都可以从这个模块，并明确大小的整数类型的实例可以从&lt;a href=&quot;data-int&quot;&gt;Data.Int&lt;/a&gt;和&lt;a href=&quot;data-word&quot;&gt;Data.Word&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="64cded15389022e2237acadfc2c3eed972bdb24d" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; class used by the &lt;code&gt;OverloadedRecordFields&lt;/code&gt; extension. See the &amp;lt;&lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; wiki page&amp;gt; for more details.</source>
          <target state="translated">此模块定义 &lt;code&gt;OverloadedRecordFields&lt;/code&gt; 扩展使用的 &lt;code&gt;&lt;a href=&quot;ghc-records#t:HasField&quot;&gt;HasField&lt;/a&gt;&lt;/code&gt; 类。有关更多详细信息，请参见&amp;lt; &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&quot;&gt;https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields&lt;/a&gt; Wiki页面&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="ec6eb416164cb4715d4e03695cde3fb980e473a9" translate="yes" xml:space="preserve">
          <source>This module defines the basic operations on I/O &quot;handles&quot;. All of the operations defined here are independent of the underlying device.</source>
          <target state="translated">该模块定义了对I/O &quot;句柄 &quot;的基本操作。这里定义的所有操作都是独立于底层设备的。</target>
        </trans-unit>
        <trans-unit id="d59bda9eaeaf5c1e3a36e9b88b617c773901fa3b" translate="yes" xml:space="preserve">
          <source>This module describes a structure intermediate between a functor and a monad (technically, a strong lax monoidal functor). Compared with monads, this interface lacks the full power of the binding operation &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt;, but</source>
          <target state="translated">该模块描述了在函子和monad（技术上是强松弛的单曲面函子）之间的中间结构。与monads相比，此接口缺乏绑定操作 &lt;code&gt;&lt;a href=&quot;control-monad#v:-62--62--61-&quot;&gt;&amp;gt;&amp;gt;=&lt;/a&gt;&lt;/code&gt; 的全部功能，但是</target>
        </trans-unit>
        <trans-unit id="6da3e730b43c82c0b85f8ebac281848e3fc9fe3b" translate="yes" xml:space="preserve">
          <source>This module exports exactly the same API as &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;, except that all file paths and environment strings are represented by &lt;code&gt;ByteString&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt;. The &lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API implicitly translates all file paths and environment strings using the locale encoding, whereas this version of the API does no encoding or decoding and works directly in terms of raw bytes.</source>
          <target state="translated">该模块导出与&lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt;完全相同的API ，除了所有文件路径和环境字符串均由 &lt;code&gt;ByteString&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; 表示。该&lt;a href=&quot;system-posix&quot;&gt;System.Posix&lt;/a&gt; API隐式转换的所有文件路径和使用区域设置编码环境字符串，而这个版本的API确实没有编码或解码，并直接在原始字节方面的工作。</target>
        </trans-unit>
        <trans-unit id="ae57a29c16b708a5f862b98209ca33ec88b9833b" translate="yes" xml:space="preserve">
          <source>This module exposes the &lt;em&gt;portable&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API. See &lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt; for the &lt;code&gt;integer-gmp&lt;/code&gt;-specific internal representation of &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; as well as optimized GMP-specific operations.</source>
          <target state="translated">该模块公开了&lt;em&gt;可移植的&lt;/em&gt; &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; API。见&lt;a href=&quot;ghc-integer-gmp-internals&quot;&gt;GHC.Integer.GMP.Internals&lt;/a&gt;为 &lt;code&gt;integer-gmp&lt;/code&gt; 的特异性内部表示 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 以及优化GMP-特定的操作。</target>
        </trans-unit>
        <trans-unit id="3a94829165fdca15372f0126fd78a0b495ce0522" translate="yes" xml:space="preserve">
          <source>This module implements permutation parsers. The algorithm used is fairly complex since we push the type system to its limits :-) The algorithm is described in:</source>
          <target state="translated">这个模块实现了换元分析器。使用的算法相当复杂,因为我们把类型系统推到了极限 :-)该算法描述在:</target>
        </trans-unit>
        <trans-unit id="c272683515777617630ed062550e54f1e41af5ba" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该模块包括GHC重写规则，以优化 &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 函子。通常，这些规则可以提高性能。唯一的例外是，使用 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 时，删除已经不存在的密钥所花费的时间比没有规则的时间长。如果您希望这种情况发生的时间非常长，则可以考虑使用 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 类型的私有副本。</target>
        </trans-unit>
        <trans-unit id="480d93e68fd6dc10a57cdf9aae6e88c254901353" translate="yes" xml:space="preserve">
          <source>This module includes GHC rewrite rules to optimize &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; functors. In general, these rules improve performance. The sole exception is that when using &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt;, deleting a key that is already absent takes longer than it would without the rules. If you expect this to occur a very large fraction of the time, you might consider using a private copy of the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">该模块包括GHC重写规则，以优化 &lt;code&gt;&lt;a href=&quot;data-map-strict#v:alterF&quot;&gt;alterF&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-functor-const#t:Const&quot;&gt;Const&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 函子。通常，这些规则可以提高性能。唯一的例外是，使用 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 时，删除已经不存在的密钥所花费的时间比没有规则的时间长。如果您希望这种情况发生的时间非常长，则可以考虑使用 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/containers-0.6.2.1/Data-Map-Internal.html#t:Identity&quot;&gt;Identity&lt;/a&gt;&lt;/code&gt; 类型的私有副本。</target>
        </trans-unit>
        <trans-unit id="7db164d6a986565222e119d577ff5c229ba8b29b" translate="yes" xml:space="preserve">
          <source>This module includes everything you need to get started writing a parser.</source>
          <target state="translated">这个模块包含了你需要开始编写解析器的所有内容。</target>
        </trans-unit>
        <trans-unit id="0e0f68392cbf21d07cf104e09ea0593872ccee43" translate="yes" xml:space="preserve">
          <source>This module is GHC-only and should not be considered portable.</source>
          <target state="translated">该模块只适用于GHC,不应视为便携式。</target>
        </trans-unit>
        <trans-unit id="84656ba40cd08703f7a3e8f512a38792e056d9c4" translate="yes" xml:space="preserve">
          <source>This module is an internal GHC module. It declares the constants used in the implementation of type-level natural numbers. The programmer interface for working with type-level naturals should be defined in a separate library.</source>
          <target state="translated">该模块是GHC的内部模块,它声明了实现类型级自然数时使用的常量。它声明了用于实现类型级自然数的常量。用于处理类型级自然数的程序员接口应该在一个单独的库中定义。</target>
        </trans-unit>
        <trans-unit id="d3afde49cd7420849dc0a50c7430aa7753bf402f" translate="yes" xml:space="preserve">
          <source>This module is considered &lt;strong&gt;internal&lt;/strong&gt;.</source>
          <target state="translated">该模块被认为是&lt;strong&gt;内部&lt;/strong&gt;模块。</target>
        </trans-unit>
        <trans-unit id="32342dd868ac356dff4bac50bb615e44b16dffd8" translate="yes" xml:space="preserve">
          <source>This module is inspired by the paper &lt;em&gt;Functional Programming with Overloading and Higher-Order Polymorphism&lt;/em&gt;, Mark P Jones (&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;) Advanced School of Functional Programming, 1995.</source>
          <target state="translated">该模块的灵感来自于论文《&lt;em&gt;带有重载和高阶多态性的函数编程》&lt;/em&gt;，Mark P Jones（&lt;a href=&quot;http://web.cecs.pdx.edu/~mpj/&quot;&gt;http://web.cecs.pdx.edu/~mpj/&lt;/a&gt;），高级函数编程学院，1995年。</target>
        </trans-unit>
        <trans-unit id="7096f5bf81e4fc89257ced2d74b5c3eaad60b08c" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions, e.g.</source>
          <target state="translated">该模块旨在导入 &lt;code&gt;qualified&lt;/code&gt; ，以避免名称与&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;函数冲突，例如</target>
        </trans-unit>
        <trans-unit id="eee7efdf6521c2a0678812a45bb80ea8d0fd2ac6" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported &lt;code&gt;qualified&lt;/code&gt;, to avoid name clashes with &lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt; functions. eg.</source>
          <target state="translated">此模块旨在导入 &lt;code&gt;qualified&lt;/code&gt; ，以避免名称与&lt;a href=&quot;../base-4.13.0.0/prelude&quot;&gt;Prelude&lt;/a&gt;函数冲突。例如。</target>
        </trans-unit>
        <trans-unit id="93e00704b6043d91bc0b1a65e596b7ceb43c33c8" translate="yes" xml:space="preserve">
          <source>This module is intended to be imported qualified, to avoid name clashes with Prelude functions:</source>
          <target state="translated">本模块旨在导入限定,以避免与Prelude函数名称冲突。</target>
        </trans-unit>
        <trans-unit id="c97f8a3f89d9890b95b69a48863882918e86fa8c" translate="yes" xml:space="preserve">
          <source>This module is part of the Foreign Function Interface (FFI) and will usually be imported via the module &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;.</source>
          <target state="translated">该模块是外部功能接口（FFI）的一部分，通常将通过模块&lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt;导入。</target>
        </trans-unit>
        <trans-unit id="461f2e382a01bf00f47b644a6f12f006c2e2728e" translate="yes" xml:space="preserve">
          <source>This module only defines the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad; you probably want to import &lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt; (which exports &lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;).</source>
          <target state="translated">该模块仅定义 &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; monad。您可能要导入&lt;a href=&quot;control-concurrent-stm&quot;&gt;Control.Concurrent.STM&lt;/a&gt;（它导出&lt;a href=&quot;control-monad-stm&quot;&gt;Control.Monad.STM&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fcaff35e4331afea7bccc306685504864f4b033e" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; operations until a value depending on them is required.</source>
          <target state="translated">此模块为&lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;提供了相同的接口，除了monad会延迟对 &lt;code&gt;&lt;a href=&quot;control-monad-st-lazy-safe#t:ST&quot;&gt;ST&lt;/a&gt;&lt;/code&gt; 操作的评估，直到需要一个取决于它们的值为止。</target>
        </trans-unit>
        <trans-unit id="785b925d63da4b41979c13438250f723b3f36584" translate="yes" xml:space="preserve">
          <source>This module presents an identical interface to &lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;, except that the monad delays evaluation of state operations until a value depending on them is required.</source>
          <target state="translated">此模块为&lt;a href=&quot;control-monad-st&quot;&gt;Control.Monad.ST&lt;/a&gt;提供了相同的接口，除了monad会延迟状态操作的评估，直到需要依赖于它们的值为止。</target>
        </trans-unit>
        <trans-unit id="5d29751e61c6eafcb5fbfdc53fe9336d12c4e225" translate="yes" xml:space="preserve">
          <source>This module provides &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;&lt;em&gt;primitives&lt;/em&gt;, which are lower level building blocks for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. You don't need to go down to this level but it can be slightly faster.</source>
          <target state="translated">该模块提供了 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; &lt;em&gt;原语&lt;/em&gt;，这些&lt;em&gt;原语&lt;/em&gt;是用于构建 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 的较低级别的构建块。您无需降低到这个级别，但是可以稍快一些。</target>
        </trans-unit>
        <trans-unit id="6e4ed2fc38393aca2df37326ba9f3afba3af1d5c" translate="yes" xml:space="preserve">
          <source>This module provides a low-level API to the line history stored in the &lt;code&gt;InputT&lt;/code&gt; monad transformer.</source>
          <target state="translated">此模块为存储在 &lt;code&gt;InputT&lt;/code&gt; monad转换器中的线路历史记录提供了一个低级API 。</target>
        </trans-unit>
        <trans-unit id="f1d3e88a44dc84dd2e2655daf9dcf215e0055df4" translate="yes" xml:space="preserve">
          <source>This module provides a low-level interface to the C functions of the terminfo library.</source>
          <target state="translated">该模块为terminfo库的C函数提供了一个低级接口。</target>
        </trans-unit>
        <trans-unit id="dcfa8281ead615b485cbc67a44a0d67023dd3214" translate="yes" xml:space="preserve">
          <source>This module provides a simple interface for executing external commands. For a more complex, but more powerful, interface, see the &lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt; module.</source>
          <target state="translated">该模块提供了用于执行外部命令的简单界面。有关更复杂但功能更强大的接口，请参见&lt;a href=&quot;system-process&quot;&gt;System.Process&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="a90fd78951dfe7db7ffb984d132da2184a51611f" translate="yes" xml:space="preserve">
          <source>This module provides a stateful, IO-based interface to Haskeline, which may be easier to integrate into some existing programs or libraries.</source>
          <target state="translated">该模块为Haskeline提供了一个有状态的、基于IO的接口,它可能更容易集成到一些现有的程序或库中。</target>
        </trans-unit>
        <trans-unit id="7665bb8888c593637beee8ce6f79ca4404cc5473" translate="yes" xml:space="preserve">
          <source>This module provides a version of pretty that allows for annotations to be attached to documents. Annotations are arbitrary pieces of metadata that can be attached to sub-documents.</source>
          <target state="translated">这个模块提供了一个pretty的版本,允许将注释附加到文档上。注释是可以附加到子文档的任意元数据。</target>
        </trans-unit>
        <trans-unit id="c1a38449e4b89f12a5a25525a42c36b9312c0f84" translate="yes" xml:space="preserve">
          <source>This module provides access to internal garbage collection and memory usage statistics. These statistics are not available unless a program is run with the &lt;code&gt;-T&lt;/code&gt; RTS flag.</source>
          <target state="translated">此模块提供对内部垃圾收集和内存使用情况统计信息的访问。除非使用 &lt;code&gt;-T&lt;/code&gt; RTS标志运行程序，否则这些统计信息不可用。</target>
        </trans-unit>
        <trans-unit id="9f3add7a2fb1719164d2ace74420d665a5258e75" translate="yes" xml:space="preserve">
          <source>This module provides capabilities for moving the cursor on the terminal.</source>
          <target state="translated">该模块提供了在终端上移动光标的功能。</target>
        </trans-unit>
        <trans-unit id="e18030012ebf6800ca52122e711e5ae7b02da7e6" translate="yes" xml:space="preserve">
          <source>This module provides efficient containers-based functions on the list type.</source>
          <target state="translated">该模块在列表类型上提供了高效的基于容器的功能。</target>
        </trans-unit>
        <trans-unit id="1f668197932586f66f5efc5d3fb7ae4c036d630e" translate="yes" xml:space="preserve">
          <source>This module provides overloaded functions, such as &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt;, for fully evaluating data structures (that is, evaluating to &quot;Normal Form&quot;).</source>
          <target state="translated">此模块提供重载函数，如 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:deepseq&quot;&gt;deepseq&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;control-deepseq#v:rnf&quot;&gt;rnf&lt;/a&gt;&lt;/code&gt; ，用于完全评估数据结构（即，评估为&amp;ldquo; Normal Form&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="582a828ee9bdf70b77d17ebec335ad7850fb4e35" translate="yes" xml:space="preserve">
          <source>This module provides scalable event notification for file descriptors and timeouts.</source>
          <target state="translated">该模块为文件描述符和超时提供可扩展的事件通知。</target>
        </trans-unit>
        <trans-unit id="854a2eebed7e5e3bcde5ed1dde2b3bcda6e0ef76" translate="yes" xml:space="preserve">
          <source>This module provides support for raising and catching both built-in and user-defined exceptions.</source>
          <target state="translated">该模块支持引发和捕获内置和用户定义的异常。</target>
        </trans-unit>
        <trans-unit id="779b1cd1a00e8f21b85e9635dbc10c2617ea3dc3" translate="yes" xml:space="preserve">
          <source>This module provides text encoding/decoding using iconv</source>
          <target state="translated">该模块提供了使用iconv进行文本编码/解码的功能。</target>
        </trans-unit>
        <trans-unit id="bd39e9a11c79866d26b9bd27b7ee858d0e154873" translate="yes" xml:space="preserve">
          <source>This module provides the various sorting implementations for &lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;. Further notes are available in the file sorting.md (in this directory).</source>
          <target state="translated">该模块提供&lt;a href=&quot;data-sequence&quot;&gt;Data.Sequence&lt;/a&gt;的各种排序实现。在文件sorting.md（在此目录中）中有更多说明。</target>
        </trans-unit>
        <trans-unit id="c752cac235dedd97d14389620cb23346095a0f16" translate="yes" xml:space="preserve">
          <source>This module provides typed pointers to foreign data. It is part of the Foreign Function Interface (FFI) and will normally be imported via the &lt;a href=&quot;foreign&quot;&gt;Foreign&lt;/a&gt; module.</source>
          <target state="translated">该模块提供了指向外部数据的类型化指针。它是外部功能接口（FFI）的一部分，通常将通过&lt;a href=&quot;foreign&quot;&gt;外部&lt;/a&gt;模块导入。</target>
        </trans-unit>
        <trans-unit id="8127ca85318ff1824be538551fa1fd1e340e9ab9" translate="yes" xml:space="preserve">
          <source>This module re-exports &lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;, which produces XHTML 1.0 Transitional. Use &lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt; if you want XHTML 1.0 Strict, and &lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt; if you want to produce XHTML 1.0 Frameset.</source>
          <target state="translated">此模块重新导出&lt;a href=&quot;text-xhtml-transitional&quot;&gt;Text.XHtml.Transitional&lt;/a&gt;，从而生成XHTML 1.0 Transitional。使用&lt;a href=&quot;text-xhtml-strict&quot;&gt;Text.XHtml.Strict&lt;/a&gt;如果你想XHTML 1.0严格，&lt;a href=&quot;text-xhtml-frameset&quot;&gt;Text.XHtml.Frameset&lt;/a&gt;如果你想制作XHTML 1.0框架集。</target>
        </trans-unit>
        <trans-unit id="d8ec7f9f123682eb0cc274e7c52cca0f3a5f423e" translate="yes" xml:space="preserve">
          <source>This module re-exports the value lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API, plus several deprecated value strict functions. Please note that these functions have different strictness properties than those in &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;: they only evaluate the result of the combining function. For example, the default value to &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; is only evaluated if the combining function is called and uses it.</source>
          <target state="translated">此模块重新导出值lazy &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; API，以及几个不建议使用的值严格函数。请注意，这些函数的严格性属性与&lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict中的&lt;/a&gt;严格性属性不同：它们仅评估组合函数的结果。例如，仅当调用并使用组合函数时才评估 &lt;code&gt;&lt;a href=&quot;data-intmap#v:insertWith-39-&quot;&gt;insertWith'&lt;/a&gt;&lt;/code&gt; 的默认值。</target>
        </trans-unit>
        <trans-unit id="652efe48d7f69bcc3c5490c01c5c8cb0efb0564b" translate="yes" xml:space="preserve">
          <source>This module redefines some of the functions in &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; to work for more general monads built on top of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此模块重新定义了&lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception中的&lt;/a&gt;某些功能，以用于基于 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 构建的更通用的monad 。</target>
        </trans-unit>
        <trans-unit id="3f6ca5d2535d9794227136b6b0c705ce4e24c48c" translate="yes" xml:space="preserve">
          <source>This module satisfies the following strictness property:</source>
          <target state="translated">该模块满足以下严格性属性。</target>
        </trans-unit>
        <trans-unit id="d8eb2deb7a56d67d9c957df553d23a112baecc39" translate="yes" xml:space="preserve">
          <source>This module should be considered GHC internal.</source>
          <target state="translated">该模块应被视为GHC内部模块。</target>
        </trans-unit>
        <trans-unit id="29e73688c548bf0c2243628b3c05e4e5e0b07e48" translate="yes" xml:space="preserve">
          <source>This module should be used as opposed to the &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; module. Both are equivalent though as this module simply re-exports the other.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;text-prettyprint-annotated#v:HughesPJ&quot;&gt;HughesPJ&lt;/a&gt;&lt;/code&gt; 模块相反，应使用此模块。两者是等效的，尽管此模块只是简单地重新导出了另一个模块。</target>
        </trans-unit>
        <trans-unit id="59ad027c5fc678b3f6724e2d8a2c3619f02ad834" translate="yes" xml:space="preserve">
          <source>This modules provides access to the &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; constructors and exposes some highly optimized GMP-operations.</source>
          <target state="translated">该模块提供对 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 构造函数的访问，并公开了一些高度优化的GMP操作。</target>
        </trans-unit>
        <trans-unit id="1130e146d0ff983a031a0a8522c8725e170d0829" translate="yes" xml:space="preserve">
          <source>This monad transformer adds the ability to fail or throw exceptions to a monad.</source>
          <target state="translated">这个单项式变换器为单项式增加了失败或抛出异常的能力。</target>
        </trans-unit>
        <trans-unit id="2a98bbb5afc9600bb6b74cc7f447cb8e1866b15b" translate="yes" xml:space="preserve">
          <source>This monad transformer extends a monad with the ability to throw exceptions.</source>
          <target state="translated">这个单项式变换器扩展了一个具有抛出异常能力的单项式。</target>
        </trans-unit>
        <trans-unit id="bba2acb7a712203bd9458987272d1dea78c2f000" translate="yes" xml:space="preserve">
          <source>This monad transformer is similar to both state and writer monad transformers. Thus it can be seen as</source>
          <target state="translated">这种单片机变压器与状态单片机和写入单片机变压器都很相似。因此,它可以被看作是</target>
        </trans-unit>
        <trans-unit id="7f2bb8a9d0620b88f4451a6324781ede4a2121a7" translate="yes" xml:space="preserve">
          <source>This monad transformer provides append-only accumulation during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">该monad转换器在计算过程中提供仅追加的累积。若要进行更一般的访问，请改用&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c53c5e051f564d4139a6d22099093a9506011e0" translate="yes" xml:space="preserve">
          <source>This monad transformer provides only limited access to the output during the computation. For more general access, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">在计算期间，此monad变压器仅提供对输出的有限访问。若要进行更一般的访问，请改用&lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e64b48298e57e04598190a3e73a7a420ac326928" translate="yes" xml:space="preserve">
          <source>This now re-exports &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">现在，这将重新导出 &lt;code&gt;&lt;a href=&quot;../bytestring-0.10.10.0/data-bytestring-lazy#v:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48569d17cf06edd49e682678e1dd43b354e7266d" translate="yes" xml:space="preserve">
          <source>This only happens if:</source>
          <target state="translated">只有在以下情况下才会出现这种情况:</target>
        </trans-unit>
        <trans-unit id="6c0b5dda6372d83897c8a1df104f5345b0b4220f" translate="yes" xml:space="preserve">
          <source>This only shows the time zone name, or offset if the name is empty.</source>
          <target state="translated">这只显示时区名称,如果名称为空,则显示偏移量。</target>
        </trans-unit>
        <trans-unit id="48af544d61c79afa3a39e1cd49eb4f6213f4528d" translate="yes" xml:space="preserve">
          <source>This only stands a chance of working for an encoding which is an ASCII superset, as for security reasons we refuse to escape any bytes smaller than 128. Many encodings of interest are ASCII supersets (in particular, you can assume that the locale encoding is an ASCII superset) but many (such as UTF-16) are not.</source>
          <target state="translated">这只适用于ASCII超集的编码,因为出于安全考虑,我们拒绝转义任何小于128的字节。许多感兴趣的编码都是ASCII超集(特别是,你可以假设locale编码是ASCII超集),但许多编码(如UTF-16)不是。</target>
        </trans-unit>
        <trans-unit id="a6ecf6dcbeadf01a7014b13f5a368ef88d650353" translate="yes" xml:space="preserve">
          <source>This only works for &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">这仅适用于 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 格式，单字母军事时区，以及以下时区：&amp;ldquo; UTC&amp;rdquo;，&amp;ldquo; UT&amp;rdquo;，&amp;ldquo; GMT&amp;rdquo;，&amp;ldquo; EST&amp;rdquo;，&amp;ldquo; EDT&amp;rdquo;，&amp;ldquo; CST&amp;rdquo;，&amp;ldquo; CDT&amp;rdquo;， &amp;ldquo; MST&amp;rdquo;，&amp;ldquo; MDT&amp;rdquo;，&amp;ldquo; PST&amp;rdquo;，&amp;ldquo; PDT&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d7c1d4016c14da3ba1514123886da29a32443086" translate="yes" xml:space="preserve">
          <source>This only works for a &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; format, single-letter military time-zones, and these time-zones: &quot;UTC&quot;, &quot;UT&quot;, &quot;GMT&quot;, &quot;EST&quot;, &quot;EDT&quot;, &quot;CST&quot;, &quot;CDT&quot;, &quot;MST&quot;, &quot;MDT&quot;, &quot;PST&quot;, &quot;PDT&quot;.</source>
          <target state="translated">这仅适用于 &lt;code&gt;&amp;plusmn;HHMM&lt;/code&gt; 格式的 &lt;code&gt;&lt;a href=&quot;data-time-localtime#v:zonedTimeZone&quot;&gt;zonedTimeZone&lt;/a&gt;&lt;/code&gt; ，单字母军事时区以及以下时区：&amp;ldquo; UTC&amp;rdquo;，&amp;ldquo; UT&amp;rdquo;，&amp;ldquo; GMT&amp;rdquo;，&amp;ldquo; EST&amp;rdquo;，&amp;ldquo; EDT&amp;rdquo;，&amp;ldquo; CST&amp;rdquo;，&amp;ldquo; CDT&amp;rdquo;，&amp;ldquo; MST&amp;rdquo;，&amp;ldquo; MDT&amp;rdquo;，&amp;ldquo; PST&amp;rdquo;，&amp;ldquo; PDT&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="23816db6dd8bea367310677e3bfbcb17ade64070" translate="yes" xml:space="preserve">
          <source>This operation acquires a unit from the semaphore (i.e. decreases the internal counter) and blocks (via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt;) if no units are available (i.e. if the counter is &lt;em&gt;not&lt;/em&gt; positive).</source>
          <target state="translated">此操作从信号量获取一个单位（即减少内部计数器），如果没有可用单位（即，如果计数器&lt;em&gt;不是&lt;/em&gt;正数），则阻塞（通过 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:retry&quot;&gt;retry&lt;/a&gt;&lt;/code&gt; ）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7014f780887d062aecc25cade39318f1f4267c3d" translate="yes" xml:space="preserve">
          <source>This operation adds/releases a unit back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">该操作将一个单元添加/释放回信号体(即增加内部计数器)。</target>
        </trans-unit>
        <trans-unit id="bbef804c0feb5706c138bd85cf6a98a3ae663039" translate="yes" xml:space="preserve">
          <source>This operation adds/releases multiple units back to the semaphore (i.e. increments the internal counter).</source>
          <target state="translated">该操作将多个单元添加/释放回信号体(即增加内部计数器)。</target>
        </trans-unit>
        <trans-unit id="23431b855341eca76cdc24f413dd7563b100983c" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">此操作对直接构建 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 值的测试套件和/或代码很有用。</target>
        </trans-unit>
        <trans-unit id="49d93c809fbddf9cf81dbda4c05507ecf14db03e" translate="yes" xml:space="preserve">
          <source>This operation is mostly useful for test-suites and/or code which constructs &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; values directly.</source>
          <target state="translated">此操作对直接构建 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 值的测试套件和/或代码很有用。</target>
        </trans-unit>
        <trans-unit id="6a3297c146519190d66c5419366b511b5ce250ad" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的定义中使用此操作来防止IO操作多次执行，这通常是不希望的。</target>
        </trans-unit>
        <trans-unit id="c2f6053c6fe980d3303ab7779a6c30bf3b23e441" translate="yes" xml:space="preserve">
          <source>This operation is used in the definition of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to prevent the IO action from being executed multiple times, which is usually undesirable.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的定义中使用此操作来防止IO操作多次执行，这通常是不希望的。</target>
        </trans-unit>
        <trans-unit id="8ee46adec231f99964d238f6075b76987a604b31" translate="yes" xml:space="preserve">
          <source>This operation may fail with:</source>
          <target state="translated">此操作可能会在以下情况下失败:</target>
        </trans-unit>
        <trans-unit id="a481371f0ca2e52248cb4d557f65d6db3c681c94" translate="yes" xml:space="preserve">
          <source>This optimisation isn&amp;rsquo;t always beneficial though (so GHC applies some heuristics to decide when to apply it). The details get complicated but a simple example is that it is often beneficial to move let bindings outwards so that multiple let bindings can be grouped into a larger single let binding, effectively batching their allocation and helping the garbage collector and allocator.</source>
          <target state="translated">不过，这种优化并不总是有益的（因此，GHC应用了一些启发式方法来决定何时应用它）。细节变得复杂，但是一个简单的示例是，向外移动let绑定通常很有益，这样可以将多个let绑定分组为更大的单个let绑定，从而有效地分批分配并帮助垃圾回收器和分配器。</target>
        </trans-unit>
        <trans-unit id="daf337b821cabcc31b64cb93551eb620a65ef97d" translate="yes" xml:space="preserve">
          <source>This optimisation moves let bindings closer to their use site. The benefit here is that this may avoid unnecessary allocation if the branch the let is now on is never executed. It also enables other optimisation passes to work more effectively as they have more information locally.</source>
          <target state="translated">这种优化使let绑定更接近其使用站点。这样做的好处是,如果let现在所在的分支从未被执行,可以避免不必要的分配。它还能使其他优化传递更有效地工作,因为它们在本地有更多的信息。</target>
        </trans-unit>
        <trans-unit id="7bc0b111503fc7f964b8ba8ae4f63543b67f459b" translate="yes" xml:space="preserve">
          <source>This optimisation specializes recursive functions according to their argument &amp;ldquo;shapes&amp;rdquo;. This is best explained by example so consider:</source>
          <target state="translated">此优化根据递归函数的参数&amp;ldquo;形状&amp;rdquo;专门化递归函数。最好通过示例来解释，因此请考虑：</target>
        </trans-unit>
        <trans-unit id="3fa5960caadfa09849470cf6386b6072cc3ffa4f" translate="yes" xml:space="preserve">
          <source>This option affects the processing of RTS control options given either on the command line or via the &lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt; environment variable. There are three possibilities:</source>
          <target state="translated">此选项影响命令行或通过&lt;a href=&quot;runtime_control#envvar-GHCRTS&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt;环境变量给出的RTS控制选项的处理。有三种可能性：</target>
        </trans-unit>
        <trans-unit id="65f85a6ef1d8626265a37c882bf54d7b55e6bccf" translate="yes" xml:space="preserve">
          <source>This option allows you to set the default RTS options at link-time. For example, &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; sets the default heap size to 128MB. This will always be the default heap size for this program, unless the user overrides it. (Depending on the setting of the &lt;code&gt;-rtsopts&lt;/code&gt; option, the user might not have the ability to change RTS options at run-time, in which case &lt;code&gt;-with-rtsopts&lt;/code&gt; would be the &lt;em&gt;only&lt;/em&gt; way to set them.)</source>
          <target state="translated">此选项使您可以在链接时设置默认的RTS选项。例如， &lt;code&gt;-with-rtsopts=&quot;-H128m&quot;&lt;/code&gt; 将默认堆大小设置为128MB。除非用户将其覆盖，否则它将始终是该程序的默认堆大小。 （取决于 &lt;code&gt;-rtsopts&lt;/code&gt; 选项的设置，用户可能无法在运行时更改RTS选项，在这种情况下， &lt;code&gt;-with-rtsopts&lt;/code&gt; 是设置它们的&lt;em&gt;唯一&lt;/em&gt;方法。）</target>
        </trans-unit>
        <trans-unit id="f91f71cb98fa24b36d5d90d1dbeb3041d935c33b" translate="yes" xml:space="preserve">
          <source>This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt;.</source>
          <target state="translated">当内部作用域值与外部作用域值具有相同的名称时，即内部值遮蔽外部作用域值时，此选项将发出警告。这可以捕获印刷错误，这些印刷错误会变成难以发现的错误，例如，无意中捕获了 &lt;code&gt;f = ... let f = id in ... f ...&lt;/code&gt; 的递归调用，而f = id在... f ...中。</target>
        </trans-unit>
        <trans-unit id="ed96edbbc25b6f1208ec75b666dd489af6409055" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &amp;ldquo;!&amp;rdquo;) and which representation is smaller or equal to the size of a pointer to be unpacked, if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;) to every strict constructor field that fulfils the size restriction.</source>
          <target state="translated">如果可能，此选项将使所有标记为严格（即&amp;ldquo;！&amp;rdquo;）且表示形式小于或等于指针大小的构造函数字段都被解压缩。这等效于向满足大小限制的每个严格的构造函数字段添加一个 &lt;code&gt;UNPACK&lt;/code&gt; 编译指示（请参阅&lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK编译指示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e2cd4133d01d71e89460c606007690e42b1fcee7" translate="yes" xml:space="preserve">
          <source>This option causes all constructor fields which are marked strict (i.e. &lt;code&gt;!&lt;/code&gt;) to be unpacked if possible. It is equivalent to adding an &lt;code&gt;UNPACK&lt;/code&gt; pragma to every strict constructor field (see &lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">如果可能，此选项使所有标记为严格（即 &lt;code&gt;!&lt;/code&gt; ）的构造函数字段都被解压缩。这等效于向每个严格的构造函数字段中添加 &lt;code&gt;UNPACK&lt;/code&gt; 编译指示（请参阅&lt;a href=&quot;glasgow_exts#unpack-pragma&quot;&gt;UNPACK编译指示&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fc09848f730f75b415b16f985abe5f3c3b0d4c17" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and distrusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be distrusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">此选项使GHC暴露并拒绝安装软件包&amp;ldquo; pkg&amp;rdquo;。该命令的功能与&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;命令非常相似，但是无论软件包数据库的内容如何，​​都将所选软件包设置为不受 GHC信任。（请参阅&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e900a6603015890af3c88ede22e351087bcb2f4c" translate="yes" xml:space="preserve">
          <source>This option causes the install package ⟨pkg⟩ to be both exposed and trusted by GHC. This command functions in a very similar way to the &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; command but in addition sets the selected packages to be trusted by GHC, regardless of the contents of the package database. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">该选项使GHC公开并信任安装软件包&amp;ldquo; pkg&amp;rdquo;。该命令的功能与&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;命令非常相似，但无论软件包数据库的内容如何，​​都将所选软件包设置为GHC信任的。 （请参阅&lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7d9bf3c24fe2f83f01a2a1fe6e2465277d625b8" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed for plugins, such as &lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt;&lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt;&lt;/a&gt;. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted if there is only one version of the package installed. If there are multiple versions of ⟨pkg⟩ installed and &lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt;&lt;code&gt;-hide-all-plugin-packages&lt;/code&gt;&lt;/a&gt; was not specified, then all other versions will become hidden. &lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; supports thinning and renaming described in &lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;Thinning and renaming modules&lt;/a&gt;.</source>
          <target state="translated">此选项使已安装的软件包⟨pkg⟩暴露给插件，例如&lt;a href=&quot;#ghc-flag--fplugin=%E2%9F%A8module%E2%9F%A9&quot;&gt; &lt;code&gt;-fplugin=⟨module⟩&lt;/code&gt; &lt;/a&gt;。 ⟨pkg⟩软件包可以完整指定其版本号（例如 &lt;code&gt;network-1.0&lt;/code&gt; ），或者，如果仅安装了一个版本的软件包，则可以省略版本号。如果安装了多个版本的&amp;ldquo; pkg&amp;rdquo;，并且未指定&lt;a href=&quot;#ghc-flag--hide-all-plugin-packages&quot;&gt; &lt;code&gt;-hide-all-plugin-packages&lt;/code&gt; &lt;/a&gt;，则所有其他版本将被隐藏。&lt;a href=&quot;#ghc-flag--plugin-package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-plugin-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;支持稀化和重&lt;a href=&quot;packages#package-thinning-and-renaming&quot;&gt;命名模块中&lt;/a&gt;介绍的稀化和重命名。</target>
        </trans-unit>
        <trans-unit id="8ef5788126155cc03138f5109c85138baa08f3cb" translate="yes" xml:space="preserve">
          <source>This option causes the installed package ⟨pkg⟩ to be exposed. The package ⟨pkg⟩ can be specified in full with its version number (e.g. &lt;code&gt;network-1.0&lt;/code&gt;) or the version number can be omitted in which case GHC will automatically expose the latest non-broken version from the installed versions of the package.</source>
          <target state="translated">此选项使安装的软件包&amp;ldquo; pkg&amp;rdquo;暴露出来。⟨pkg⟩软件包可以完整指定其版本号（例如 &lt;code&gt;network-1.0&lt;/code&gt; ），也可以省略版本号，在这种情况下，GHC会自动从已安装的软件包版本中公开最新的未破坏版本。</target>
        </trans-unit>
        <trans-unit id="a0e41ab6d83305de686a095b3332cab6407d1ce0" translate="yes" xml:space="preserve">
          <source>This option causes the runtime to print out the current cost-centre stack whenever an exception is raised. This can be particularly useful for debugging the location of exceptions, such as the notorious &lt;code&gt;Prelude.head: empty list&lt;/code&gt; error. See &lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;RTS options for hackers, debuggers, and over-interested souls&lt;/a&gt;.</source>
          <target state="translated">每当引发异常时，此选项都会使运行时打印出当前的成本中心堆栈。这对于调试异常的位置尤其有用，例如臭名昭​​著的 &lt;code&gt;Prelude.head: empty list&lt;/code&gt; 错误。请参阅&lt;a href=&quot;runtime_control#rts-options-debugging&quot;&gt;针对黑客，调试器和过度感兴趣的人的RTS选项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b57872a61028ef8c64baf35e07feb3f3f77cf233" translate="yes" xml:space="preserve">
          <source>This option controls the amount of memory reserved for the older generations (and in the case of a two space collector the size of the allocation area) as a factor of the amount of live data. For example, if there was 2M of live data in the oldest generation when we last collected it, then by default we&amp;rsquo;ll wait until it grows to 4M before collecting it again.</source>
          <target state="translated">此选项控制为较早的一代保留的内存量（如果是两个空间收集器，则分配空间的大小）作为实时数据量的一个因素。例如，如果上次收集时最早的一代中有2M实时数据，那么默认情况下，我们将等到它增长到4M后再进行收集。</target>
        </trans-unit>
        <trans-unit id="fb38d77df4357efae92d504cd6786c9d8c4e6bf3" translate="yes" xml:space="preserve">
          <source>This option disables RTS suggestions about linking with &lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt;&lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt;&lt;/a&gt; when they are not available. These suggestions would be unhelpful if the users have installed Haskell programs through their package managers. With this option enabled, these suggestions will not appear. It is recommended for people distributing binaries to build with either &lt;code&gt;-rtsopts&lt;/code&gt; or &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D&quot;&gt; &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; &lt;/a&gt;使用-rtsopts [=⟨none| some | all | all | ignore |ignoreAll⟩]进行链接，此选项将禁用RTS建议。如果用户已通过程序包管理器安装了Haskell程序，则这些建议将无济于事。启用此选项后，这些建议将不会出现。建议分发二进制文件的人员使用 &lt;code&gt;-rtsopts&lt;/code&gt; 或 &lt;code&gt;-no-rtsopts-suggestions&lt;/code&gt; 构建。</target>
        </trans-unit>
        <trans-unit id="956ede657ecee5ab5112379453aca532a83df0ab" translate="yes" xml:space="preserve">
          <source>This option displays the currently installed packages, for each of the databases known to &lt;code&gt;ghc-pkg&lt;/code&gt;. That includes the global database, the user&amp;rsquo;s local database, and any further files specified using the &lt;code&gt;-f&lt;/code&gt; option on the command line.</source>
          <target state="translated">对于 &lt;code&gt;ghc-pkg&lt;/code&gt; 已知的每个数据库，此选项显示当前安装的软件包。其中包括全局数据库，用户的本地数据库以及在命令行上使用 &lt;code&gt;-f&lt;/code&gt; 选项指定的任何其他文件。</target>
        </trans-unit>
        <trans-unit id="a08204879e3c5670124e4d3fa4df08f09c2c5827" translate="yes" xml:space="preserve">
          <source>This option does not put a &lt;em&gt;limit&lt;/em&gt; on the heap size: the heap may grow beyond the given size as usual.</source>
          <target state="translated">此选项对堆大小没有&lt;em&gt;限制&lt;/em&gt;：堆可能会像往常一样超出给定大小。</target>
        </trans-unit>
        <trans-unit id="177e417c340a66f0470d8511743420a60bcc5fbb" translate="yes" xml:space="preserve">
          <source>This option does the opposite of &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt;: it causes the specified package to be hidden, which means that none of its modules will be available for import by Haskell &lt;code&gt;import&lt;/code&gt; directives.</source>
          <target state="translated">此选项与&lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt;相反：它使指定的包被隐藏，这意味着Haskell &lt;code&gt;import&lt;/code&gt; 指令无法导入其任何模块。</target>
        </trans-unit>
        <trans-unit id="1560370f0ba5d1fdfc6dfeeacc2a54b30787c270" translate="yes" xml:space="preserve">
          <source>This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using &lt;code&gt;UNPACK&lt;/code&gt; pragmas might be better. An alternative is to use &lt;code&gt;-funbox-strict-fields&lt;/code&gt; to turn on unboxing by default but disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">这个选项有点像大锤：有时可能会使情况变得更糟。使用 &lt;code&gt;UNPACK&lt;/code&gt; 编译指示框选择性地取消装箱字段可能会更好。一种替代方法是使用 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 默认情况下打开取消装箱，但使用 &lt;code&gt;NOUNPACK&lt;/code&gt; pragma（请参阅&lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;）对某些构造函数字段禁用此功能。</target>
        </trans-unit>
        <trans-unit id="0ac262cc50deac3cfae652d65a7a869356b40b86" translate="yes" xml:space="preserve">
          <source>This option is for working around memory allocation problems only. Do not use unless GHCi fails with a message like &amp;ldquo;&lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt;&amp;rdquo;. If you need to use this option to get GHCi working on your machine, please file a bug.</source>
          <target state="translated">此选项仅用于解决内存分配问题。除非GHCi失败，并显示类似消息&amp;ldquo; &lt;code&gt;failed to mmap() memory below 2Gb&lt;/code&gt; 失败&amp;rdquo;，否则请不要使用。如果您需要使用此选项使GHCi在您的计算机上运行，​​请提交一个错误。</target>
        </trans-unit>
        <trans-unit id="1c1ed9c302993c8a254ff902df0dbce38b594005" translate="yes" xml:space="preserve">
          <source>This option is less of a sledgehammer than &lt;code&gt;-funbox-strict-fields&lt;/code&gt;: it should rarely make things worse. If you use &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; to turn on unboxing by default you can disable it for certain constructor fields using the &lt;code&gt;NOUNPACK&lt;/code&gt; pragma (see &lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;).</source>
          <target state="translated">与 &lt;code&gt;-funbox-strict-fields&lt;/code&gt; 相比，此选项不是大锤：它很少会使情况变得更糟。如果您使用 &lt;code&gt;-funbox-small-strict-fields&lt;/code&gt; 默认情况下启用取消装箱，则可以使用 &lt;code&gt;NOUNPACK&lt;/code&gt; pragma（请参见&lt;a href=&quot;glasgow_exts#nounpack-pragma&quot;&gt;NOUNPACK pragma&lt;/a&gt;）对某些构造函数字段禁用它。</target>
        </trans-unit>
        <trans-unit id="2fd49d1f76860f1c44d6c219e62e7f40bc9c2382" translate="yes" xml:space="preserve">
          <source>This option is most often used when creating an executable file, to set the filename of the executable. For example:</source>
          <target state="translated">这个选项最常用于创建可执行文件时,设置可执行文件的文件名。例如:</target>
        </trans-unit>
        <trans-unit id="2ec4e8819778435da9e1806c3a1ad92e747cbb70" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在不推荐使用此选项，而推荐使用&lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="267371a5e841319f6a790d155fb592c269a41960" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在不建议使用此选项，而推荐使用&lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0235b6cb10974ea14ea0574ec14232194a831212" translate="yes" xml:space="preserve">
          <source>This option is now deprecated in favour of &lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt;&lt;code&gt;-Wredundant-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">现在不建议使用此选项，而推荐使用&lt;a href=&quot;#ghc-flag--Wredundant-constraints&quot;&gt; &lt;code&gt;-Wredundant-constraints&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d62299c9dde524b1ef3bb3933973aa22ff0ff398" translate="yes" xml:space="preserve">
          <source>This option is off by default.</source>
          <target state="translated">该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="4293e9fab7792eac1853c48400535b8a8b77123a" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</source>
          <target state="translated">这个选项默认是开启的,当一个实例声明缺少一个或多个方法,而对应的类声明中又没有它们的默认声明时,这个选项就会警告你。</target>
        </trans-unit>
        <trans-unit id="aeda602ded05cab94ca86a41b88530e26ba7b489" translate="yes" xml:space="preserve">
          <source>This option is on by default, and warns you whenever the construction of a labelled field constructor isn&amp;rsquo;t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</source>
          <target state="translated">此选项默认情况下处于启用状态，并在标记字段构造函数的构建未完成而缺少一个或多个字段的初始化程序时向您发出警告。虽然不是错误（缺少的字段以底部开始初始化），但这通常表示程序员有错误。</target>
        </trans-unit>
        <trans-unit id="aa97f50ca584638ac24325128130ef5efe4b2fbf" translate="yes" xml:space="preserve">
          <source>This option is on by default.</source>
          <target state="translated">该选项默认为开启。</target>
        </trans-unit>
        <trans-unit id="9d2fe70b27b67051a789b82f4eb4f639ee630173" translate="yes" xml:space="preserve">
          <source>This option is on by default. As usual you can suppress it on a per-module basis with &lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt;&lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，此选项处于启用状态。像往常一样，您可以使用&lt;a href=&quot;#ghc-flag--Wsimplifiable-class-constraints&quot;&gt; &lt;code&gt;-Wno-simplifiable-class-constraints&lt;/code&gt; &lt;/a&gt;在每个模块的基础上禁止它。</target>
        </trans-unit>
        <trans-unit id="ccde2620c81cc8f927379b68565101df835bced2" translate="yes" xml:space="preserve">
          <source>This option is only useful when running in parallel (&lt;code&gt;-N2&lt;/code&gt; or greater). It allows the processor cores to make better use of the available allocation area, even when cores are allocating at different rates. Without &lt;code&gt;-n&lt;/code&gt;, each core gets a fixed-size allocation area specified by the &lt;code&gt;-A&lt;/code&gt;, and the first core to exhaust its allocation area triggers a GC across all the cores. This can result in a collection happening when the allocation areas of some cores are only partially full, so the purpose of the &lt;code&gt;-n&lt;/code&gt; is to allow cores that are allocating faster to get more of the allocation area. This means less frequent GC, leading a lower GC overhead for the same heap size.</source>
          <target state="translated">仅当并行运行（ &lt;code&gt;-N2&lt;/code&gt; 或更高版本）时，此选项才有用。即使内核以不同的速率进行分配，它也可以使处理器内核更好地利用可用的分配区域。如果不使用 &lt;code&gt;-n&lt;/code&gt; ，则每个内核将获得由 &lt;code&gt;-A&lt;/code&gt; 指定的固定大小的分配区域，并且第一个耗尽其分配区域的内核会触发所有内核的GC。当某些核心的分配区域仅部分填充时，这可能导致发生收集，因此 &lt;code&gt;-n&lt;/code&gt; 的目的是允许分配速度更快的核心获得更多的分配区域。这意味着较少的GC使用率，从而在相同堆大小的情况下降低了GC开销。</target>
        </trans-unit>
        <trans-unit id="8d9c254d7b78a3a3ecbc5027783e6457d1d482ef" translate="yes" xml:space="preserve">
          <source>This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;.</source>
          <target state="translated">该选项可能仅用于通过&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent#v:forkOn&quot;&gt;Control.Concurrent.forkOn&lt;/a&gt;将线程显式调度到CPU的并发程序。</target>
        </trans-unit>
        <trans-unit id="f35434e6bd52920e5c48189b8cfc8e504aad6697" translate="yes" xml:space="preserve">
          <source>This option is there mainly to stop the program eating up all the available memory in the machine if it gets into an infinite loop.</source>
          <target state="translated">这个选项的存在主要是为了阻止程序在进入无限循环的情况下吃掉机器中所有的可用内存。</target>
        </trans-unit>
        <trans-unit id="57d29d5e7df4da4169fdb64e362ca3677dd89e06" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be a bit noisy, and it doesn&amp;rsquo;t always indicate a bug in the program. However, it&amp;rsquo;s generally considered good practice to cover all the cases in your functions, and it is switched on by &lt;a href=&quot;#ghc-flag--W&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下，此选项未启用，因为它可能有点嘈杂，并且并不总是表明程序中存在错误。但是，通常最好将函数中的所有情况都包括在内，并且可以通过&lt;a href=&quot;#ghc-flag--W&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt;打开它。</target>
        </trans-unit>
        <trans-unit id="9f98751831a4a39977803e9637f7e77e2e14db0e" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t enabled by default because it can be very noisy, and it often doesn&amp;rsquo;t indicate a bug in the program.</source>
          <target state="translated">默认情况下，此选项未启用，因为它可能会非常吵杂，并且通常不表示程序中存在错误。</target>
        </trans-unit>
        <trans-unit id="674da51224e4596bdb3744f26e1f9a1fbcb8b81f" translate="yes" xml:space="preserve">
          <source>This option lists registered packages exposing module ⟨M⟩. Examples:</source>
          <target state="translated">这个选项列出了暴露模块 ⟨M⟩的注册包。例子</target>
        </trans-unit>
        <trans-unit id="c794703287cedcb0e1c47b116ac501bee05de960" translate="yes" xml:space="preserve">
          <source>This option may help if the evaluated top-level expressions are consuming large amounts of space, or if you need repeatable performance measurements.</source>
          <target state="translated">如果经过评估的顶层表达式消耗了大量的空间,或者需要进行可重复的性能测量,这个选项可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="b7ff2c217eff8117af9178fc8b3897c5316f401a" translate="yes" xml:space="preserve">
          <source>This option provides a &amp;ldquo;suggested heap size&amp;rdquo; for the garbage collector. Think of &lt;code&gt;-Hsize&lt;/code&gt; as a variable &lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-A ⟨size⟩&lt;/code&gt;&lt;/a&gt; option. It says: I want to use at least ⟨size⟩ bytes, so use whatever is left over to increase the &lt;code&gt;-A&lt;/code&gt; value.</source>
          <target state="translated">此选项为垃圾收集器提供&amp;ldquo;建议的堆大小&amp;rdquo;。将 &lt;code&gt;-Hsize&lt;/code&gt; 视为变量&lt;a href=&quot;#rts-flag--A%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-A ⟨size⟩&lt;/code&gt; &lt;/a&gt;选项。它说：我想至少使用&amp;ldquo; size&amp;rdquo;个字节，所以请使用剩下的任何东西来增加 &lt;code&gt;-A&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="8853a9d72e715d15e409a53251078ae18153a456" translate="yes" xml:space="preserve">
          <source>This option relates to allocation limits; for more about this see &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;. When a thread hits its allocation limit, the RTS throws an exception to the thread, and the thread gets an additional quota of allocation before the exception is raised again, the idea being so that the thread can execute its exception handlers. The &lt;code&gt;-xq&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">此选项与分配限制有关；有关更多信息，请参见&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-conc#v:enableAllocationLimit&quot;&gt;GHC.Conc.enableAllocationLimit&lt;/a&gt;。当线程达到其分配限制时，RTS会向该线程抛出一个异常，并且在再次引发该异常之前，该线程会获得一个额外的分配配额，其想法是使线程可以执行其异常处理程序。该 &lt;code&gt;-xq&lt;/code&gt; 控制额外的配额的大小。</target>
        </trans-unit>
        <trans-unit id="363c890a3de72dcec771b7f4c76b67f54a27050f" translate="yes" xml:space="preserve">
          <source>This output shows that, in the context of the current session (ie in the scope of &lt;code&gt;Prelude&lt;/code&gt;), the first group of items from &lt;code&gt;Data.Maybe&lt;/code&gt; are not in scope (althought they are available in fully qualified form in the GHCi session - see &lt;a href=&quot;#ghci-scope&quot;&gt;What&amp;rsquo;s really in scope at the prompt?&lt;/a&gt;), whereas the second group of items are in scope (via &lt;code&gt;Prelude&lt;/code&gt;) and are therefore available either unqualified, or with a &lt;code&gt;Prelude.&lt;/code&gt; qualifier.</source>
          <target state="translated">此输出表明，在当前会话的上下文中（即在 &lt;code&gt;Prelude&lt;/code&gt; 的范围内）， &lt;code&gt;Data.Maybe&lt;/code&gt; 中的第一组项目可能不在范围内（尽管它们在GHCi会话中以完全合格的形式可用-请参阅&amp;ldquo; &lt;a href=&quot;#ghci-scope&quot;&gt;什么&amp;rdquo;真的在范围内吗？&lt;/a&gt;），而第二组项目在范围内（通过 &lt;code&gt;Prelude&lt;/code&gt; ），因此可以不加限定地使用，也可以带有 &lt;code&gt;Prelude.&lt;/code&gt; 限定词。</target>
        </trans-unit>
        <trans-unit id="d32fd0e1a9f5bf7e2d98a725ace2312b41fff634" translate="yes" xml:space="preserve">
          <source>This package provides both strict and lazy &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; types. The strict type is provided by the &lt;a href=&quot;data-text&quot;&gt;Data.Text&lt;/a&gt; module, while the lazy type is provided by the &lt;a href=&quot;data-text-lazy&quot;&gt;Data.Text.Lazy&lt;/a&gt; module. Internally, the lazy &lt;code&gt;Text&lt;/code&gt; type consists of a list of strict chunks.</source>
          <target state="translated">该软件包提供严格和懒惰 &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; 类型。严格类型由&lt;a href=&quot;data-text&quot;&gt; Data.Text&lt;/a&gt;模块提供，而惰性类型由&lt;a href=&quot;data-text-lazy&quot;&gt; Data.Text.Lazy&lt;/a&gt;模块提供。在内部，惰性 &lt;code&gt;Text&lt;/code&gt; 类型由一组严格的块组成。</target>
        </trans-unit>
        <trans-unit id="5c301e63fdee476a49263ba8163281e72adf6b96" translate="yes" xml:space="preserve">
          <source>This package uses the term &lt;em&gt;character&lt;/em&gt; to denote Unicode &lt;em&gt;code points&lt;/em&gt;.</source>
          <target state="translated">该软件包使用术语&lt;em&gt;字符&lt;/em&gt;来表示Unicode &lt;em&gt;代码点&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aae5addb116c887a46f27acc513b2117c6d86f14" translate="yes" xml:space="preserve">
          <source>This parameter is reserved. You should pass just &lt;em&gt;nullPtr&lt;/em&gt;.</source>
          <target state="translated">该参数是保留的。您应该只传递&lt;em&gt;nullPtr&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="15f0fa32e677164a596a3b41ef5acc2c4991ec87" translate="yes" xml:space="preserve">
          <source>This parameter requires to use Windows 7 or later.</source>
          <target state="translated">此参数要求使用Windows 7或更高版本。</target>
        </trans-unit>
        <trans-unit id="2b0fc7a248b7324fafef584b213680e79287e0c9" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该解析器仅在输入末尾成功。这不是原始分析器，而是使用 &lt;code&gt;&lt;a href=&quot;text-parsec#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 定义的。</target>
        </trans-unit>
        <trans-unit id="6b70e45e4186d009ec916862fca7c137404104fc" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该解析器仅在输入末尾成功。这不是原始分析器，而是使用 &lt;code&gt;&lt;a href=&quot;text-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 定义的。</target>
        </trans-unit>
        <trans-unit id="4dfbf340dce50dc9038b479329f38e8ec299cf61" translate="yes" xml:space="preserve">
          <source>This parser only succeeds at the end of the input. This is not a primitive parser but it is defined using &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该解析器仅在输入末尾成功。这不是原始的解析器，而是使用 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-combinator#v:notFollowedBy&quot;&gt;notFollowedBy&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9300de657d2872adc67fa41e5ab353e07ce88a2d" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of identifiers. For example &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">该解析器应接受标识符的任何合法尾字符。例如 &lt;code&gt;alphaNum &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8528eebabb9825d0176f24d442e7c8b026df63e" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">该解析器应接受运算符的任何合法尾字符。请注意，如果该语言不支持用户定义的运算符，则甚至应定义该解析器，否则 &lt;code&gt;&lt;a href=&quot;text-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 解析器将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="00d8c7a0c04c027e82791e73a94a73041f724be2" translate="yes" xml:space="preserve">
          <source>This parser should accept any legal tail characters of operators. Note that this parser should even be defined if the language doesn't support user-defined operators, or otherwise the &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; parser won't work correctly.</source>
          <target state="translated">该解析器应接受运算符的任何合法尾字符。请注意，如果该语言不支持用户定义的运算符，则甚至应定义该解析器，否则 &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-token#v:reservedOp&quot;&gt;reservedOp&lt;/a&gt;&lt;/code&gt; 解析器将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="d983e2b71ccf1f3a26f0aff85466bf1e651e9beb" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of identifiers. For example &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt;.</source>
          <target state="translated">该解析器应接受标识符的任何起始字符。例如 &lt;code&gt;letter &amp;lt;|&amp;gt; char '_'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b9eeef0a0daf3a30997aca44251904a3bc4ace8" translate="yes" xml:space="preserve">
          <source>This parser should accept any start characters of operators. For example &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</source>
          <target state="translated">该解析器应接受运算符的任何起始字符。例如 &lt;code&gt;oneOf &quot;:!#$%&amp;amp;*+./&amp;lt;=&amp;gt;?@\\^|-~&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9db4088868263aaafdfa869a0f8e2314217323d7" translate="yes" xml:space="preserve">
          <source>This parser succeeds for any character. Returns the parsed character.</source>
          <target state="translated">该解析器对任何字符都能成功解析。返回解析后的字符。</target>
        </trans-unit>
        <trans-unit id="a306a889dc9a52a42b11381f826b2d7630214d4b" translate="yes" xml:space="preserve">
          <source>This pragma is similar to C&amp;rsquo;s &lt;code&gt;#line&lt;/code&gt; pragma, and is mainly for use in automatically generated Haskell code. It lets you specify the line number and filename of the original code; for example</source>
          <target state="translated">这种语用与C相似 &lt;code&gt;#line&lt;/code&gt; 实用程序，并且主要用于自动生成的Haskell代码中。它允许您指定原始代码的行号和文件名；例如</target>
        </trans-unit>
        <trans-unit id="ca88c24656a8d8661c565a0c56d31be0ec21660f" translate="yes" xml:space="preserve">
          <source>This primitive is only available when the underlying GMP library supports it (GMP &amp;gt;= 5). Otherwise, it internally falls back to &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt;, and a warning will be emitted when used.</source>
          <target state="translated">仅当基础GMP库支持该原语（GMP&amp;gt; = 5）时，此原语才可用。否则，它会在内部退回到 &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#v:powModInteger&quot;&gt;powModInteger&lt;/a&gt;&lt;/code&gt; ，并且在使用时将发出警告。</target>
        </trans-unit>
        <trans-unit id="dceb51efdb1a52e7502aaf8f2f6a2f14168bc8e4" translate="yes" xml:space="preserve">
          <source>This problem doesn&amp;rsquo;t just affect GHCi, it affects any GHC-compiled program that wants to catch console events. See the &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt; module.</source>
          <target state="translated">这个问题不仅影响GHCi，而且还会影响要捕获控制台事件的所有GHC编译程序。见&lt;a href=&quot;../libraries/base-4.13.0.0/ghc-consolehandler&quot;&gt;GHC.ConsoleHandler&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="c277562015915ae2718208c757d99e3c4a5c2ea5" translate="yes" xml:space="preserve">
          <source>This produces a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; for each key:</source>
          <target state="translated">这 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; 会产生将为每个键：</target>
        </trans-unit>
        <trans-unit id="e24c8bfbcd524c9aaee115418d115977f5d18a8a" translate="yes" xml:space="preserve">
          <source>This program will be rejected, because &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; does not scope over the definition of &amp;ldquo;&lt;code&gt;g&lt;/code&gt;&amp;rdquo;, so &amp;ldquo;&lt;code&gt;x::a&lt;/code&gt;&amp;rdquo; means &amp;ldquo;&lt;code&gt;x::forall a. a&lt;/code&gt;&amp;rdquo; by Haskell&amp;rsquo;s usual implicit quantification rules.</source>
          <target state="translated">该程序将被拒绝，因为&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;并不覆盖&amp;ldquo; &lt;code&gt;g&lt;/code&gt; &amp;rdquo; 的定义，因此&amp;ldquo; &lt;code&gt;x::a&lt;/code&gt; &amp;rdquo;的意思是&amp;ldquo; &lt;code&gt;x::forall a. a&lt;/code&gt; &amp;rdquo;由Haskell的通常隐含的量化规则。</target>
        </trans-unit>
        <trans-unit id="d583e97443b28f0723fcc05e1353f50d62ca3ee1" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">该程序将进行核心转储。多态引用的此问题在ML社区中是众所周知的，并且在引用的正常单例使用中不会出现。一旦使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ,就没有简单的方法使之成为不可能。确实，可以借助以下命令来编写 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; :::a-。所以要小心！</target>
        </trans-unit>
        <trans-unit id="39080170230fd9e748e118da55a46cb1b209f144" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">该程序将进行核心转储。多态引用的此问题在ML社区中是众所周知的，并且在引用的正常单例使用中不会出现。一旦使用 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ,就没有简单的方法使之成为不可能。确实，可以在 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 的帮助下编写 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; ::: a- &amp;gt; b。所以要小心！</target>
        </trans-unit>
        <trans-unit id="8c3070f1819b5144ee0019a42b9364d5b62ac534" translate="yes" xml:space="preserve">
          <source>This program will core dump. This problem with polymorphic references is well known in the ML community, and does not arise with normal monadic use of references. There is no easy way to make it impossible once you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. Indeed, it is possible to write &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; with the help of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;. So be careful!</source>
          <target state="translated">该程序将进行核心转储。多态引用的此问题在ML社区中是众所周知的，并且在引用的正常单例使用中不会出现。一旦使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ,就没有简单的方法使之成为不可能。确实，可以借助以下命令来编写 &lt;code&gt;coerce :: a -&amp;gt; b&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; :::a-。所以要小心！</target>
        </trans-unit>
        <trans-unit id="8edf15b81edbb17eae494e16b7d0533a271e50da" translate="yes" xml:space="preserve">
          <source>This provides a type-indexed type representation mechanism, similar to that described by,</source>
          <target state="translated">这提供了一个类型索引的类型表示机制,类似于以下所描述的:</target>
        </trans-unit>
        <trans-unit id="77d3447bc17b046a19fec0f3cc3c7ab330fb5b15" translate="yes" xml:space="preserve">
          <source>This reduces the allocation and trimming overhead, as all generated &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;s fit into the first buffer and there is no trimming required, if more than 64 bytes and less than 128 bytes are written.</source>
          <target state="translated">由于生成的所有内容都可以减少分配和调整开销 &lt;code&gt;&lt;a href=&quot;data-bytestring-lazy#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; 都适合第一个缓冲区，并且如果写入的字节数多于64个字节且少于128个字节，则不需要修剪，。</target>
        </trans-unit>
        <trans-unit id="79b2e379cd0f1eaf600da24618a21f3bffdedc96" translate="yes" xml:space="preserve">
          <source>This relative path technique can be used with either of the two &lt;code&gt;-dynload&lt;/code&gt; modes, though it makes most sense with the &lt;code&gt;deploy&lt;/code&gt; mode. The difference is that with the &lt;code&gt;deploy&lt;/code&gt; mode, the above example will end up with an ELF &lt;code&gt;RUNPATH&lt;/code&gt; of just &lt;code&gt;$ORIGIN&lt;/code&gt; while with the &lt;code&gt;sysdep&lt;/code&gt; mode the &lt;code&gt;RUNPATH&lt;/code&gt; will be &lt;code&gt;$ORIGIN&lt;/code&gt; followed by all the library directories of all the packages that the program depends on (e.g. &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;rts&lt;/code&gt; packages etc.) which are typically absolute paths. The unix tool &lt;code&gt;readelf --dynamic&lt;/code&gt; is handy for inspecting the &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries in ELF shared libraries and executables.</source>
          <target state="translated">尽管相对 &lt;code&gt;deploy&lt;/code&gt; 最有意义，但该相对路径技术可以与两种 &lt;code&gt;-dynload&lt;/code&gt; 模式中的任何一种一起使用。区别在于，在 &lt;code&gt;deploy&lt;/code&gt; 模式下，以上示例将以ELF &lt;code&gt;RUNPATH&lt;/code&gt; 结尾，而该 &lt;code&gt;sysdep&lt;/code&gt; 仅是 &lt;code&gt;$ORIGIN&lt;/code&gt; 而在sysdep模式下， &lt;code&gt;RUNPATH&lt;/code&gt; 将是 &lt;code&gt;$ORIGIN&lt;/code&gt; 后跟该程序所依赖的所有软件包的所有库目录（例如 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;rts&lt;/code&gt; 包等），它们通常是绝对路径。的unix工具 &lt;code&gt;readelf --dynamic&lt;/code&gt; 可方便地检查 &lt;code&gt;RPATH&lt;/code&gt; / &lt;code&gt;RUNPATH&lt;/code&gt; ELF共享库和可执行文件中的RUNPATH条目。</target>
        </trans-unit>
        <trans-unit id="370040cae2bc778368a6b92c807c4b5827ecb99e" translate="yes" xml:space="preserve">
          <source>This representation is generated automatically if a &lt;code&gt;deriving Generic&lt;/code&gt; clause is attached to the datatype. &lt;a href=&quot;#stand-alone-deriving&quot;&gt;Standalone deriving&lt;/a&gt; can also be used.</source>
          <target state="translated">如果 &lt;code&gt;deriving Generic&lt;/code&gt; 子句附加到数据类型，则会自动生成此表示形式。也可以使用&lt;a href=&quot;#stand-alone-deriving&quot;&gt;独立派生&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30dd0b304103583a22935853ab5fa131cea21cbe" translate="yes" xml:space="preserve">
          <source>This representation is very generic in that no types are given special treatment. However, some functions might need to handle some known types specially, for example the following two functions collect all argument types of (nested) arrow types, and recognize the &lt;code&gt;Int&lt;/code&gt; type, respectively:</source>
          <target state="translated">这种表示形式非常通用，因为没有对任何类型进行特殊处理。但是，某些函数可能需要专门处理某些已知类型，例如以下两个函数分别收集（嵌套）箭头类型的所有参数类型并识别 &lt;code&gt;Int&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="54c505cd157188eeaeea208a88996c170f20c5ef" translate="yes" xml:space="preserve">
          <source>This resembles the wildcards that can be used in &lt;a href=&quot;#partial-type-signatures&quot;&gt;Partial Type Signatures&lt;/a&gt;. However, there are some differences. No error messages reporting the inferred types are generated, nor does the extension &lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt;&lt;code&gt;PartialTypeSignatures&lt;/code&gt;&lt;/a&gt; have any effect.</source>
          <target state="translated">这类似于可以在&lt;a href=&quot;#partial-type-signatures&quot;&gt;部分类型签名中&lt;/a&gt;使用的通配符。但是，有一些差异。没有生成报告推断类型的错误消息，扩展&lt;a href=&quot;#extension-PartialTypeSignatures&quot;&gt; &lt;code&gt;PartialTypeSignatures&lt;/code&gt; &lt;/a&gt;也没有任何作用。</target>
        </trans-unit>
        <trans-unit id="05658b8ed19f8a18e37b401843f9f1390a5fc067" translate="yes" xml:space="preserve">
          <source>This results in the variable &lt;code&gt;output&lt;/code&gt; taking on the value below:</source>
          <target state="translated">这导致变量 &lt;code&gt;output&lt;/code&gt; 采用以下值：</target>
        </trans-unit>
        <trans-unit id="0dae13ecc0c945a796e78580e4456aee9006b862" translate="yes" xml:space="preserve">
          <source>This rule has occasionally-surprising consequences (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;Issue #10132&lt;/a&gt;.</source>
          <target state="translated">该规则有时会产生令人惊讶的后果（请参阅&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10132&quot;&gt;问题＃10132）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8a75e7f4aae139decf4dbddc8f92f07f78b73ed" translate="yes" xml:space="preserve">
          <source>This rule is applied regardless of flags. If you want a more exotic context, you can write it yourself, using the &lt;a href=&quot;#stand-alone-deriving&quot;&gt;standalone deriving mechanism&lt;/a&gt;.</source>
          <target state="translated">不管标志如何，都将应用此规则。如果您想要更特殊的环境，则可以使用&lt;a href=&quot;#stand-alone-deriving&quot;&gt;独立的派生机制&lt;/a&gt;自己编写。</target>
        </trans-unit>
        <trans-unit id="d9ad35ca09458fcaf673d419d014807d6053c2a9" translate="yes" xml:space="preserve">
          <source>This rule will cause the compiler to go into an infinite loop.</source>
          <target state="translated">这个规则会导致编译器进入无限循环。</target>
        </trans-unit>
        <trans-unit id="2d325df582f925494ea658de7dc04323c3323bae" translate="yes" xml:space="preserve">
          <source>This rule works for any concrete type constructor, including type constructors with polymorphic kinds. The only restriction is that if the type constructor has a polymorphic kind, then it has to be applied to all of its kinds parameters, and these kinds need to be concrete (i.e., they cannot mention kind variables).</source>
          <target state="translated">这个规则适用于任何具体的类型构造函数,包括具有多态类型的类型构造函数。唯一的限制是,如果类型构造函数有一个多态类型,那么它必须应用于所有的类型参数,而且这些类型需要是具体的(也就是说,它们不能提及类型变量)。</target>
        </trans-unit>
        <trans-unit id="012cf785712f9f58baa44a19777eaca31580d1fc" translate="yes" xml:space="preserve">
          <source>This runs the interpreted code in a separate process (see &lt;a href=&quot;#external-interpreter&quot;&gt;Running the interpreter in a separate process&lt;/a&gt;) and runs it in profiling mode to collect call stack information. Note that because we&amp;rsquo;re running the interpreted code in profiling mode, all packages that you use must be compiled for profiling. The &lt;code&gt;-prof&lt;/code&gt; flag to GHCi only works in conjunction with &lt;code&gt;-fexternal-interpreter&lt;/code&gt;.</source>
          <target state="translated">这将在单独的进程中运行解释后的代码（请参阅在单独的进程中&lt;a href=&quot;#external-interpreter&quot;&gt;运行解释器&lt;/a&gt;），并在分析模式下运行它以收集调用堆栈信息。请注意，由于我们以概要分析模式运行解释后的代码，因此必须编译您使用的所有软件包以进行概要分析。GHCi 的 &lt;code&gt;-prof&lt;/code&gt; 标志仅与 &lt;code&gt;-fexternal-interpreter&lt;/code&gt; 结合使用。</target>
        </trans-unit>
        <trans-unit id="0e7a2ad40c566ce0f6643ee923a3e30a05545bee" translate="yes" xml:space="preserve">
          <source>This says that &lt;code&gt;modify (+1)&lt;/code&gt; acts over any Monad that is a member of the &lt;code&gt;MonadState&lt;/code&gt; class, with an &lt;code&gt;Int&lt;/code&gt; state.</source>
          <target state="translated">这表示 &lt;code&gt;modify (+1)&lt;/code&gt; 对具有 &lt;code&gt;Int&lt;/code&gt; 状态的 &lt;code&gt;MonadState&lt;/code&gt; 类成员的任何Monad起作用。</target>
        </trans-unit>
        <trans-unit id="aeefc346ad248407772de61eb44c91ebc62b1dff" translate="yes" xml:space="preserve">
          <source>This section defines the layout of these events. The &lt;code&gt;String&lt;/code&gt; type below is defined to be a UTF-8 encoded NUL-terminated string.</source>
          <target state="translated">本节定义了这些事件的布局。下面的 &lt;code&gt;String&lt;/code&gt; 类型定义为UTF-8编码的NUL终止的字符串。</target>
        </trans-unit>
        <trans-unit id="426477ffd0f3109ffb983e296577e866ad83653a" translate="yes" xml:space="preserve">
          <source>This section describes &lt;em&gt;data type promotion&lt;/em&gt;, an extension to the kind system that complements kind polymorphism. It is enabled by &lt;a href=&quot;#extension-DataKinds&quot;&gt;&lt;code&gt;DataKinds&lt;/code&gt;&lt;/a&gt;, and described in more detail in the paper &lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;Giving Haskell a Promotion&lt;/a&gt;, which appeared at TLDI 2012.</source>
          <target state="translated">本节描述&lt;em&gt;数据类型提升&lt;/em&gt;，它是对种类多态性的补充的种类系统的扩展。它由&lt;a href=&quot;#extension-DataKinds&quot;&gt; &lt;code&gt;DataKinds&lt;/code&gt; &lt;/a&gt;启用，并在TLDI 2012上发表的&lt;a href=&quot;http://dreixel.net/research/pdf/ghp.pdf&quot;&gt;给Haskell进行推广&lt;/a&gt;的论文中进行了详细描述。</target>
        </trans-unit>
        <trans-unit id="cb974cf5a36706fbeb443061b653e868010df89d" translate="yes" xml:space="preserve">
          <source>This section describes GHC&amp;rsquo;s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC&amp;rsquo;s kind system.</source>
          <target state="translated">本节描述了GHC的同类系统，该系统出现在8.0版及更高版本中。此处描述的同类系统始终有效，带有或不带有扩展名，尽管它是对标准Haskell的保守扩展。上面的扩展仅启用语法并调整推理算法，以使用户能够利用GHC同类系统的额外表达能力。</target>
        </trans-unit>
        <trans-unit id="d4d58a26ba3b02f1db1fe2de0ac14aa3d6a048b5" translate="yes" xml:space="preserve">
          <source>This section describes features specific to GHC's implementation of Concurrent Haskell.</source>
          <target state="translated">这一节描述了GHC实现并发Haskell的具体功能。</target>
        </trans-unit>
        <trans-unit id="bdd49ffb73a3731ac6d967fc14496c16e1567101" translate="yes" xml:space="preserve">
          <source>This section describes how to create DLLs to be called from other languages, such as Visual Basic or C++. This is a special case of &lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;Making a Haskell library that can be called from foreign code&lt;/a&gt;; we&amp;rsquo;ll deal with the DLL-specific issues that arise below. Here&amp;rsquo;s an example:</source>
          <target state="translated">本节介绍如何创建要从其他语言（如Visual Basic或C ++）调用的DLL。这是&lt;a href=&quot;ffi-chap#ffi-library&quot;&gt;制作Haskell库的&lt;/a&gt;一种特例，可以从外部代码调用 ; 我们将处理下面出现的DLL特定问题。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="c716f59912a3ade4c8a600a747406892f16105cd" translate="yes" xml:space="preserve">
          <source>This section describes other program(s) which we distribute, that help with the Great Haskell Programming Task.</source>
          <target state="translated">这一节描述了我们分发的其他程序,这些程序有助于完成伟大的 Haskell 编程任务。</target>
        </trans-unit>
        <trans-unit id="cd9343002ee7f20ea72481ff97c75ea4a9503720" translate="yes" xml:space="preserve">
          <source>This section describes what files GHC expects to find, what files it creates, where these files are stored, and what options affect this behaviour.</source>
          <target state="translated">本节描述了GHC期望找到哪些文件,它创建了哪些文件,这些文件存储在哪里,以及哪些选项会影响这种行为。</target>
        </trans-unit>
        <trans-unit id="f1c1c7aa4c4b76ef9244f133c648760bb4ada19e" translate="yes" xml:space="preserve">
          <source>This section documents GHC&amp;rsquo;s take on various issues that are left undefined or implementation specific in Haskell 98.</source>
          <target state="translated">本节记录了GHC对Haskell 98中尚未定义或特定实现的各种问题的看法。</target>
        </trans-unit>
        <trans-unit id="d1b5cee4b5290696273cb8636327d9703229eadc" translate="yes" xml:space="preserve">
          <source>This section documents the encodings of the events emitted to GHC&amp;rsquo;s &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt;. These events can include information about the thread scheduling events, garbage collection statistics, profiling information, user-defined tracing events.</source>
          <target state="translated">本部分记录了发送到GHC &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;事件日志&lt;/a&gt;的事件的编码。这些事件可以包括有关线程调度事件，垃圾回收统计信息，性能分析信息，用户定义的跟踪事件的信息。</target>
        </trans-unit>
        <trans-unit id="b978b97b7476bee1ad03a8af2ae4346819b8abd7" translate="yes" xml:space="preserve">
          <source>This section is a quick-reference for GHC&amp;rsquo;s command-line flags. For each flag, we also list its mode/dynamic status (see &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;Dynamic and Mode options&lt;/a&gt;), and the flag&amp;rsquo;s opposite (if available).</source>
          <target state="translated">本部分是GHC命令行标志的快速参考。对于每个标志，我们还列出其模式/动态状态（请参见&amp;ldquo; &lt;a href=&quot;using#mode-dynamic-flags&quot;&gt;动态&amp;rdquo;和&amp;ldquo;模式&amp;rdquo;选项&lt;/a&gt;），以及标志的反面（如果可用）。</target>
        </trans-unit>
        <trans-unit id="e5d224e7441e3fb869faddf4a0821bffaff71c9b" translate="yes" xml:space="preserve">
          <source>This section is intended for implementors of tooling which consume these events.</source>
          <target state="translated">本节是为使用这些事件的工具的实现者准备的。</target>
        </trans-unit>
        <trans-unit id="4793c1dfb931aabba357e67757e80e8fe4a49b96" translate="yes" xml:space="preserve">
          <source>This section lists Glasgow Haskell infelicities in its implementation of Haskell 98 and Haskell 2010. See also the &amp;ldquo;when things go wrong&amp;rdquo; section (&lt;a href=&quot;gone_wrong#wrong&quot;&gt;What to do when something goes wrong&lt;/a&gt;) for information about crashes, space leaks, and other undesirable phenomena.</source>
          <target state="translated">本节列出了在实施Haskell 98和Haskell 2010时格拉斯哥Haskell的不足。有关崩溃，空间泄漏和其他不良现象的信息，另请参阅&amp;ldquo;何时出错&amp;rdquo;（&lt;a href=&quot;gone_wrong#wrong&quot;&gt;出错时应采取的措施&lt;/a&gt;）部分。</target>
        </trans-unit>
        <trans-unit id="9d329579f2386fca40f0668d94a24284cae13ec1" translate="yes" xml:space="preserve">
          <source>This section, and the next one, documents GHC&amp;rsquo;s type-class extensions. There&amp;rsquo;s lots of background in the paper &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;Type classes: exploring the design space&lt;/a&gt; (Simon Peyton Jones, Mark Jones, Erik Meijer).</source>
          <target state="translated">本节和下一节介绍GHC的类型类扩展。纸张&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/type-class-design-space/&quot;&gt;类型类中&lt;/a&gt;有很多背景知识：探索设计空间（西蒙&amp;middot;佩顿&amp;middot;琼斯，马克&amp;middot;琼斯，埃里克&amp;middot;梅耶尔）。</target>
        </trans-unit>
        <trans-unit id="2b1a90dce5c453c0f69c1639a0cce7223844a1ff" translate="yes" xml:space="preserve">
          <source>This seems like a generalisation of the standard &lt;code&gt;$&lt;/code&gt; operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call &lt;code&gt;bad&lt;/code&gt;, we must somehow pass &lt;code&gt;x&lt;/code&gt; into &lt;code&gt;bad&lt;/code&gt;. How wide (that is, how many bits) is &lt;code&gt;x&lt;/code&gt;? Is it a pointer? What kind of register (floating-point or integral) should &lt;code&gt;x&lt;/code&gt; go in? It&amp;rsquo;s all impossible to say, because &lt;code&gt;x&lt;/code&gt;&amp;lsquo;s type, &lt;code&gt;a :: TYPE r1&lt;/code&gt; is levity polymorphic. We thus forbid such constructions, via the following straightforward rule:</source>
          <target state="translated">这似乎是标准 &lt;code&gt;$&lt;/code&gt; 运算符的概括。但是，如果我们考虑将其编译为可运行的代码，则会出现问题。特别是，当我们称 &lt;code&gt;bad&lt;/code&gt; ，我们必须以某种方式将 &lt;code&gt;x&lt;/code&gt; 传递给 &lt;code&gt;bad&lt;/code&gt; 。 &lt;code&gt;x&lt;/code&gt; 有多宽（即多少位）？是指针吗？ &lt;code&gt;x&lt;/code&gt; 应该输入哪种寄存器（浮点数或整数）？很难说，因为 &lt;code&gt;x&lt;/code&gt; 的类型：:: &lt;code&gt;a :: TYPE r1&lt;/code&gt; 是多态性。因此，我们通过以下简单的规则禁止此类构造：</target>
        </trans-unit>
        <trans-unit id="c863740ea2de0c5a648f81c5a1a438b882986762" translate="yes" xml:space="preserve">
          <source>This seems the most intuitive and transparent approach towards the developer, who no longer needs to concern himself with the fact that his code might contain overlapping axioms or with the ordering of his instance contexts. But backtracking would apply equally to ordinary instance selection (in the presence of overlapping instances), so it is a much more pervasive change, with substantial consequences for the type inference engine.</source>
          <target state="translated">对开发者来说,这似乎是最直观、最透明的方法,他不再需要关注他的代码可能包含重叠公理的事实,也不需要关注他的实例上下文的排序。但是回溯将同样适用于普通的实例选择(在存在重叠实例的情况下),所以这是一个更普遍的变化,对类型推理引擎有实质性的影响。</target>
        </trans-unit>
        <trans-unit id="91bbd3a27d52a3a851dbfdab4b9ab18c81125223" translate="yes" xml:space="preserve">
          <source>This should call &lt;code&gt;error&lt;/code&gt; but actually prints &lt;code&gt;True&lt;/code&gt;. Reason: GHC eta-expands &lt;code&gt;f&lt;/code&gt; to</source>
          <target state="translated">这应该调用 &lt;code&gt;error&lt;/code&gt; ,但实际上会打印 &lt;code&gt;True&lt;/code&gt; 。原因：GHC ETA-膨胀 &lt;code&gt;f&lt;/code&gt; 到</target>
        </trans-unit>
        <trans-unit id="7ab63a2693cd6c7a45c1f790143037cd6507bc64" translate="yes" xml:space="preserve">
          <source>This should produce a file named &lt;code&gt;fib.dSYM&lt;/code&gt;.</source>
          <target state="translated">这将产生一个名为 &lt;code&gt;fib.dSYM&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="739e32040ecc4d2911d13031c9ae018167e3429f" translate="yes" xml:space="preserve">
          <source>This should work, as long as your GHCi was built with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; switch, which is the default. Consult whoever supplied your GHCi installation.</source>
          <target state="translated">只要您的GHCi是使用&lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt;开关（默认设置）构建的，它就可以工作。请咨询提供您的GHCi安装的人员。</target>
        </trans-unit>
        <trans-unit id="689b2645ac8c6757ff69fc4ca6accdc5ec8ea0cb" translate="yes" xml:space="preserve">
          <source>This slightly odd-looking rule instructs GHC to replace &lt;code&gt;genericLookup&lt;/code&gt; by &lt;code&gt;intLookup&lt;/code&gt;&lt;em&gt;whenever the types match&lt;/em&gt;. What is more, this rule does not need to be in the same file as &lt;code&gt;genericLookup&lt;/code&gt;, unlike the &lt;code&gt;SPECIALIZE&lt;/code&gt; pragmas which currently do (so that they have an original definition available to specialise).</source>
          <target state="translated">这个看起来有些古怪的规则指示GHC &lt;em&gt;在类型匹配时&lt;/em&gt;用 &lt;code&gt;intLookup&lt;/code&gt; 替换 &lt;code&gt;genericLookup&lt;/code&gt; 。而且，此规则不需要与 &lt;code&gt;genericLookup&lt;/code&gt; 放在同一文件中，这与当前使用的 &lt;code&gt;SPECIALIZE&lt;/code&gt; 编译指示不同（因此它们具有可用于定义的原始定义）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="074a31f4d9e16cb86e220f5f40a063ee59b833fe" translate="yes" xml:space="preserve">
          <source>This stack structure means that the order of &lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-package-db ⟨file⟩&lt;/code&gt;&lt;/a&gt; flags or &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is important. Each substack of the stack must be well formed (packages in databases on top of the stack can refer to packages below, but not vice versa).</source>
          <target state="translated">这种堆栈结构意味着&lt;a href=&quot;#ghc-flag--package-db%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-package-db ⟨file⟩&lt;/code&gt; &lt;/a&gt;标志或&lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 的顺序&lt;/a&gt;很重要。堆栈的每个子堆栈必须格式正确（堆栈顶部数据库中的程序包可以引用下面的程序包，反之亦然）。</target>
        </trans-unit>
        <trans-unit id="e66c29e8f81778a2aa9684e85767a00ebb262ce6" translate="yes" xml:space="preserve">
          <source>This statement requires that f have the type forall a. [a] -&amp;gt; [a] . You can see an example of its use in the motivating example, as this form is used to apply take 5 .</source>
          <target state="translated">该语句要求f的类型为a。[a]-&amp;gt; [a]。您可以在激励示例中看到其用法示例，因为此表格用于应用take 5。</target>
        </trans-unit>
        <trans-unit id="61c78a7e665855a92db9c5e9ffaec8226aba79b6" translate="yes" xml:space="preserve">
          <source>This strategy is as follows: GHC keeps a list of directories called the search path. For each of these directories, it tries appending &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; to the directory, and checks whether the file exists. The value of ⟨basename⟩ is the module name with dots replaced by the directory separator (&amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;\\&quot;&lt;/code&gt;, depending on the system), and ⟨extension⟩ is a source extension (&lt;code&gt;hs&lt;/code&gt;, &lt;code&gt;lhs&lt;/code&gt;) if we are in &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, or ⟨hisuf⟩ otherwise.</source>
          <target state="translated">此策略如下：GHC保留一个称为搜索路径的目录列表。对于这些目录中的每个目录，它尝试将&amp;ldquo; &lt;code&gt;⟨basename⟩.⟨extension⟩&lt;/code&gt; 附加到目录中，并检查文件是否存在。&amp;ldquo; basename&amp;rdquo;的值是模块名称，点号由目录分隔符替换（&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;\\&quot;&lt;/code&gt; ，具体取决于系统），而&amp;ldquo; extension&amp;rdquo;则是源扩展名（ &lt;code&gt;hs&lt;/code&gt; ， &lt;code&gt;lhs&lt;/code&gt; ）（如果我们位于&lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt;模式或GHCi，否则使用⟨hisuf⟩。</target>
        </trans-unit>
        <trans-unit id="11ed97c596e1d0bcc228efb8114c48f030b93b3b" translate="yes" xml:space="preserve">
          <source>This tells you:</source>
          <target state="translated">这告诉你。</target>
        </trans-unit>
        <trans-unit id="07d8f00faa3ae75b40703b0528f229ea480038a2" translate="yes" xml:space="preserve">
          <source>This thread has exceeded its allocation limit. See &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该线程已超出其分配限制。请参阅 &lt;code&gt;&lt;a href=&quot;system-mem#v:setAllocationCounter&quot;&gt;setAllocationCounter&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;system-mem#v:enableAllocationLimit&quot;&gt;enableAllocationLimit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c243ec7e03c31ba25363993635c259a833d99359" translate="yes" xml:space="preserve">
          <source>This translates to:</source>
          <target state="translated">这翻译成:</target>
        </trans-unit>
        <trans-unit id="e21f274a51f9949f29f1cc84b56dc845f3250ad2" translate="yes" xml:space="preserve">
          <source>This trick isn&amp;rsquo;t foolproof, because there might be other &lt;code&gt;B&lt;/code&gt; closures in the heap which aren&amp;rsquo;t the retainers we are interested in, but we&amp;rsquo;ve found this to be a useful technique in most cases.</source>
          <target state="translated">这个技巧不是万无一失的，因为堆中可能还有其他 &lt;code&gt;B&lt;/code&gt; 闭包，而这些B闭包不是我们感兴趣的保持器，但是我们发现这在大多数情况下是一种有用的技术。</target>
        </trans-unit>
        <trans-unit id="7eedf2bab1365e54cbd4693945639257ad4fb0f2" translate="yes" xml:space="preserve">
          <source>This trivial type constructor serves two purposes:</source>
          <target state="translated">这个琐碎的类型构造函数有两个目的。</target>
        </trans-unit>
        <trans-unit id="628155b5f0687904716807bcd6409248a6482468" translate="yes" xml:space="preserve">
          <source>This two stage process is required because GHC cannot currently profile using both biographical and retainer information simultaneously.</source>
          <target state="translated">之所以需要这两个阶段的程序,是因为GHC目前不能同时使用个人履历和保留资料进行简介。</target>
        </trans-unit>
        <trans-unit id="da64adf134879e08323ed89e3b1e4948df137364" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level natural numbers.</source>
          <target state="translated">这种类型表示未知的类型级自然数。</target>
        </trans-unit>
        <trans-unit id="63e71d7f0b07e2f8017ecf6cb7990bb372b6c369" translate="yes" xml:space="preserve">
          <source>This type represents unknown type-level symbols.</source>
          <target state="translated">此类型表示未知的类型级符号。</target>
        </trans-unit>
        <trans-unit id="dc9fd430c3e406e9bfda4395aaf8dea448b92e37" translate="yes" xml:space="preserve">
          <source>This type signature contains a kind error which cannot be deferred.</source>
          <target state="translated">这个类型签名包含了一个不能推迟的种类错误。</target>
        </trans-unit>
        <trans-unit id="d1458226daed690560f642a2591b54664bcd7099" translate="yes" xml:space="preserve">
          <source>This use of underscore for wildcard in a type pattern is exactly like pattern matching in the term language, but is rather different to the use of a underscore in a partial type signature (see &lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;).</source>
          <target state="translated">在类型模式中对通配符使用下划线与术语语言中的模式匹配完全相同，但是与在部分类型签名中对下划线的使用完全不同（请参见&lt;a href=&quot;#type-wildcards&quot;&gt;Type Wildcards&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="843b161d44b1dbfe532489a8737416458e734625" translate="yes" xml:space="preserve">
          <source>This uses the above tree rendering function, and displays the Html as a tree structure, allowing debugging of what is actually getting produced.</source>
          <target state="translated">这使用了上面的树形渲染功能,并将Html显示为树形结构,允许调试实际生成的内容。</target>
        </trans-unit>
        <trans-unit id="115cfdee365c54682223fbca3e4f895eb1f6e102" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">这利用了Haskell的 &lt;code&gt;let&lt;/code&gt; 引入递归绑定的事实。我们可以使用 &lt;code&gt;&lt;a href=&quot;control-monad-fix#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 重写此定义，</target>
        </trans-unit>
        <trans-unit id="c1be3ce1530bcdc820d6c90501be79827a35abad" translate="yes" xml:space="preserve">
          <source>This uses the fact that Haskell&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; introduces recursive bindings. We can rewrite this definition using &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">这利用了Haskell的 &lt;code&gt;let&lt;/code&gt; 引入递归绑定的事实。我们可以使用 &lt;code&gt;&lt;a href=&quot;data-function#v:fix&quot;&gt;fix&lt;/a&gt;&lt;/code&gt; 重写此定义，</target>
        </trans-unit>
        <trans-unit id="7f88835ef04d1f3754243e8cd078d29d91f94c0a" translate="yes" xml:space="preserve">
          <source>This usually isn&amp;rsquo;t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide &lt;em&gt;bound threads&lt;/em&gt;, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt; module.</source>
          <target state="translated">这通常不是问题，它允许GHC运行时系统有效利用OS线程资源。但是，在某些情况下，最好是更好地控制使用哪个OS线程，例如，在调用使用线程本地状态的外部代码时。对于这种情况，我们提供&lt;em&gt;绑定线程&lt;/em&gt;，这是与特定OS线程&lt;em&gt;绑定&lt;/em&gt;的Haskell线程。有关绑定线程的信息，请参见&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;模块的文档。</target>
        </trans-unit>
        <trans-unit id="a6fe6c899f31bf735023aed7edade5c845bb20c4" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 的此变体添加了一个终结器，该终结器除了终结指针之外还期望环境。将传递给终结器的环境由 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 的第二个参数确定。</target>
        </trans-unit>
        <trans-unit id="73272fcd0ad868eb9d7204167149b902a10e97d9" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; adds a finalizer that expects an environment in addition to the finalized pointer. The environment that will be passed to the finalizer is fixed by the second argument to &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtr&quot;&gt;newForeignPtr&lt;/a&gt;&lt;/code&gt; 的此变体添加了一个终结器，该终结器除了终结指针之外还期望环境。将传递给终结器的环境由 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:newForeignPtrEnv&quot;&gt;newForeignPtrEnv&lt;/a&gt;&lt;/code&gt; 的第二个参数确定。</target>
        </trans-unit>
        <trans-unit id="9448bed87d0380afdfc5a0e85ab115284bc4a12f" translate="yes" xml:space="preserve">
          <source>This variant of &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; appears at the type level.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:Fixity&quot;&gt;Fixity&lt;/a&gt;&lt;/code&gt; 这种变体出现在类型级别。</target>
        </trans-unit>
        <trans-unit id="d456ce198372e2f1c13a10638b827f2a19ffc595" translate="yes" xml:space="preserve">
          <source>This version builds its output lazily; for a constant-space version with almost the same interface, see &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;.</source>
          <target state="translated">这个版本延迟输出。有关具有几乎相同接口的恒定空间版本，请参见&lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bbca1b395d2fc0bccc520c78f768d92dd9c439e" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly and uses continuation-passing-style to achieve constant space usage. This transformer can be used as a drop-in replacement for &lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict&lt;/a&gt;.</source>
          <target state="translated">此版本严格构建其输出，并使用continuation-passing样式来实现恒定的空间使用率。该转换器可以用作&lt;a href=&quot;control-monad-trans-writer-strict&quot;&gt;Control.Monad.Trans.Writer.Strict的直接&lt;/a&gt;替代。</target>
        </trans-unit>
        <trans-unit id="930ffaae31f052ddd842b0cc0750e75bde4d30d4" translate="yes" xml:space="preserve">
          <source>This version builds its output strictly; for a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;. Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use &lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt; instead.</source>
          <target state="translated">此版本严格构建其输出。有关具有相同接口的惰性版本，请参见&lt;a href=&quot;control-monad-trans-writer-lazy&quot;&gt;Control.Monad.Trans.Writer.Lazy&lt;/a&gt;。尽管输出是严格构建的，但是使用此转换器无法实现恒定的空间行为：为此，请使用&lt;a href=&quot;control-monad-trans-writer-cps&quot;&gt;Control.Monad.Trans.Writer.CPS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c43334581b0313064f9793791ae64d3cd9cb11bb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此版本的 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 效率更高，因为它省略了仅由单个线程执行IO的检查。因此，当您使用 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 时，可能会多次执行IO操作（在多处理器上），因此应确保每次给出的结果相同。甚至可能发生了重复的IO操作之一仅部分运行，然后在中间中断而没有引发异常的情况。因此，不能在 &lt;code&gt;&lt;a href=&quot;data-text-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 中安全使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 之类的功能。</target>
        </trans-unit>
        <trans-unit id="5b59dda432be30bd0d16af2bacfdfe2d0f94c9cd" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此版本的 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 效率更高，因为它省略了仅由单个线程执行IO的检查。因此，当您使用 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 时，可能会多次执行IO操作（在多处理器上），因此应确保每次给出的结果相同。甚至可能发生了重复的IO操作之一仅部分运行，然后在中间中断而没有引发异常的情况。因此，不能在 &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 中安全使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 之类的功能。</target>
        </trans-unit>
        <trans-unit id="f67494c6dd16fe58429c914e2600fd861b46bc50" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此版本的 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 效率更高，因为它省略了仅由单个线程执行IO的检查。因此，当您使用 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 时，可能会多次执行IO操作（在多处理器上），因此应确保每次给出的结果相同。甚至可能发生了重复的IO操作之一仅部分运行，然后在中间中断而没有引发异常的情况。因此，不能在 &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 中安全使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 之类的功能。</target>
        </trans-unit>
        <trans-unit id="67c8e6fa4d8cd33fa64562f0db26d801a347a4eb" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; is more efficient because it omits the check that the IO is only being performed by a single thread. Hence, when you use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;, there is a possibility that the IO action may be performed multiple times (on a multiprocessor), and you should therefore ensure that it gives the same results each time. It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; cannot be used safely within &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此版本的 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; 效率更高，因为它省略了仅由单个线程执行IO的检查。因此，当您使用 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 时，可能会多次执行IO操作（在多处理器上），因此应确保每次给出的结果相同。甚至可能发生了重复的IO操作之一仅部分运行，然后在中间中断而没有引发异常的情况。因此，不能在 &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeDupablePerformIO&quot;&gt;unsafeDupablePerformIO&lt;/a&gt;&lt;/code&gt; 中安全使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; 之类的功能。</target>
        </trans-unit>
        <trans-unit id="c4d88c16a70afcd9d0a8c3fb7463a254c46bdefe" translate="yes" xml:space="preserve">
          <source>This version requires going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt;, which can be inefficient. However, &lt;code&gt;toIntegralSized&lt;/code&gt; is optimized to allow GHC to statically determine the relative type sizes (as measured by &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt;) and avoid going through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for many types. (The implementation uses &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt;, which is itself optimized with rules for &lt;code&gt;base&lt;/code&gt; types but may go through &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; for some type pairs.)</source>
          <target state="translated">此版本需要经过 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; ，这可能效率不高。但是，对 &lt;code&gt;toIntegralSized&lt;/code&gt; 进行了优化，以允许GHC静态确定相对类型的大小（由 &lt;code&gt;&lt;a href=&quot;data-bits#v:bitSizeMaybe&quot;&gt;bitSizeMaybe&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-bits#v:isSigned&quot;&gt;isSigned&lt;/a&gt;&lt;/code&gt; 度量），并避免对许多类型使用 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 。（该实现使用 &lt;code&gt;&lt;a href=&quot;prelude#v:fromIntegral&quot;&gt;fromIntegral&lt;/a&gt;&lt;/code&gt; ，它本身已针对 &lt;code&gt;base&lt;/code&gt; 类型的规则进行了优化，但对于某些类型对可能要经过 &lt;code&gt;&lt;a href=&quot;prelude#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="1713051baed32864f550a4d0ea48ed3f725fb1d1" translate="yes" xml:space="preserve">
          <source>This warning allows to detect such uses of &lt;code&gt;*&lt;/code&gt; before the actual breaking change takes place. The recommended fix is to replace &lt;code&gt;*&lt;/code&gt; with &lt;code&gt;Type&lt;/code&gt; imported from &lt;code&gt;Data.Kind&lt;/code&gt;.</source>
          <target state="translated">此警告允许在实际的重大更改发生之前检测到 &lt;code&gt;*&lt;/code&gt; 的此类用法。建议的解决方法是更换 &lt;code&gt;*&lt;/code&gt; 同 &lt;code&gt;Type&lt;/code&gt; 进口 &lt;code&gt;Data.Kind&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78b29ba7cfb3d2918f39c1441e99d9f4ce1287c2" translate="yes" xml:space="preserve">
          <source>This warning can be turned off with the flag &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wno-missing-methods&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可以使用标志&lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wno-missing-methods&lt;/code&gt; &lt;/a&gt;关闭该警告。</target>
        </trans-unit>
        <trans-unit id="f18c523e2627209783834547bda765478c64d4a5" translate="yes" xml:space="preserve">
          <source>This warning is enabled by default in &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">默认情况下，在&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;模式下启用此警告。</target>
        </trans-unit>
        <trans-unit id="72dcfecc8d5494d290ee1b21677961cb5175c2ed" translate="yes" xml:space="preserve">
          <source>This warning is off by default.</source>
          <target state="translated">该警告默认为关闭。</target>
        </trans-unit>
        <trans-unit id="8e25d5e92b85c829fac2f9477e4538faeeb61aa6" translate="yes" xml:space="preserve">
          <source>This warning is off by default. However, it is part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group.</source>
          <target state="translated">默认情况下，此警告处于关闭状态。但是，它是&lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt;选项组的一部分。</target>
        </trans-unit>
        <trans-unit id="90f45b839bbf6248dce6eb6cd816c8aef78b200f" translate="yes" xml:space="preserve">
          <source>This warning is on by default.</source>
          <target state="translated">该警告默认为开启。</target>
        </trans-unit>
        <trans-unit id="85a4aecbf183fdb5c42584066dc8c58f74eb0df7" translate="yes" xml:space="preserve">
          <source>This warning message:</source>
          <target state="translated">这条警告信息。</target>
        </trans-unit>
        <trans-unit id="f2d8282f3131ab448c2e8fe1cea01afde1138b09" translate="yes" xml:space="preserve">
          <source>This will be translated to:</source>
          <target state="translated">这将被翻译成:</target>
        </trans-unit>
        <trans-unit id="67139a4dd79ac7320ecf17b1941945dc01b22766" translate="yes" xml:space="preserve">
          <source>This will generate a derived instance for &lt;code&gt;(Foo [a])&lt;/code&gt; and &lt;code&gt;(Foo (Maybe a))&lt;/code&gt;, but other types such as &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; will not be an instance of &lt;code&gt;Eq&lt;/code&gt;.</source>
          <target state="translated">这将生成 &lt;code&gt;(Foo [a])&lt;/code&gt; 和 &lt;code&gt;(Foo (Maybe a))&lt;/code&gt; 的派生实例，但是其他类型，例如 &lt;code&gt;(Foo (Int,Bool))&lt;/code&gt; 将不是 &lt;code&gt;Eq&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="a8f28dc06b16f7d92df21079a2ca982f57eeedb1" translate="yes" xml:space="preserve">
          <source>This will generate code to the effect of:</source>
          <target state="translated">这将产生大意如下的代码:</target>
        </trans-unit>
        <trans-unit id="c07dbdd03a5f971eb5b11d111347c944fa4be0b3" translate="yes" xml:space="preserve">
          <source>This will generate the derived instance:</source>
          <target state="translated">这将生成派生实例。</target>
        </trans-unit>
        <trans-unit id="2f9635805f734d6a6ddee1819b851b9ba1e60653" translate="yes" xml:space="preserve">
          <source>This will sometimes exit with &quot;interrupted&quot; and code 0, because the main thread is given a chance to shut down when the child thread calls safeExit. There is a race to shut down between the main and child threads.</source>
          <target state="translated">这有时会以 &quot;中断 &quot;和代码0退出,因为当子线程调用safeExit时,主线程有机会关闭。主线程和子线程之间会有一个竞相关闭的过程。</target>
        </trans-unit>
        <trans-unit id="e043ff52775ea24499678e808e45c2c181b6a4d7" translate="yes" xml:space="preserve">
          <source>This will take &lt;code&gt;1 + 1 + 3&lt;/code&gt; words (the &lt;code&gt;ThingId&lt;/code&gt; constructor + unpacked &lt;code&gt;Int&lt;/code&gt; + unpacked &lt;code&gt;ShortByteString&lt;/code&gt;), plus the words for the string data.</source>
          <target state="translated">这将需要 &lt;code&gt;1 + 1 + 3&lt;/code&gt; 单词（ &lt;code&gt;ThingId&lt;/code&gt; 构造函数+解压缩的 &lt;code&gt;Int&lt;/code&gt; +解压缩的 &lt;code&gt;ShortByteString&lt;/code&gt; ），以及用于字符串数据的单词。</target>
        </trans-unit>
        <trans-unit id="ffb0c676449de8bbdd669f772c381c5dd02a2d1b" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在阻止此线程的同时关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="00447b8aa68db10f55c7e645117a8e9f6fffe839" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在该线程被阻止的情况下关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="53fc96ce3bb24d77dd77c6af32ec3bc111b921f5" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在阻止此线程的同时关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="3bf6f8f26d3df6178377eb2f4bcb17017279b918" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在该线程被阻止的情况下关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;prelude#v:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc-io#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="1fa41044d20ae1ba84ba01e6410c48a361f0588d" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在阻止此线程的同时关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitRead&quot;&gt;threadWaitRead&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="07a6c139763138b599cb7bbf37ebd6c6563d7c63" translate="yes" xml:space="preserve">
          <source>This will throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; if the file descriptor was closed while this thread was blocked. To safely close a file descriptor that has been used with &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在该线程被阻止的情况下关闭了文件描述符，则会抛出 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。若要安全关闭已与 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:threadWaitWrite&quot;&gt;threadWaitWrite&lt;/a&gt;&lt;/code&gt; 一起使用的 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:closeFdWith&quot;&gt;closeFdWith&lt;/a&gt;&lt;/code&gt; ，请使用closeFdWith。</target>
        </trans-unit>
        <trans-unit id="434dd08be079cc0bd5826173db52237398cf0bd7" translate="yes" xml:space="preserve">
          <source>This will yield a list containing every prefix of the word &amp;ldquo;hello&amp;rdquo; written out 5 times:</source>
          <target state="translated">这将产生一个列表，其中包含单词&amp;ldquo; hello&amp;rdquo;的每个前缀，被写出5次：</target>
        </trans-unit>
        <trans-unit id="5b7edf0cfa8817128eb97357c0b339d3968afe03" translate="yes" xml:space="preserve">
          <source>This works even if the type of the expression is more general, provided it can be &lt;em&gt;instantiated&lt;/em&gt; to &lt;code&gt;IO a&lt;/code&gt;. For example</source>
          <target state="translated">这适用即使表达式的类型是更普遍的，只要它可被&lt;em&gt;实例化&lt;/em&gt;到 &lt;code&gt;IO a&lt;/code&gt; 。例如</target>
        </trans-unit>
        <trans-unit id="8a8c5448116287ce4d1ddb842a2e4bddd7bd26ff" translate="yes" xml:space="preserve">
          <source>This would generate the following instances:</source>
          <target state="translated">这将产生以下实例:</target>
        </trans-unit>
        <trans-unit id="cb8b2e3b821f17047f04dce70c983fcb5b75e25f" translate="yes" xml:space="preserve">
          <source>Thread stacks (including the main thread&amp;rsquo;s stack) live on the heap. As the stack grows, new stack chunks are added as required; if the stack shrinks again, these extra stack chunks are reclaimed by the garbage collector. The default initial stack size is deliberately small, in order to keep the time and space overhead for thread creation to a minimum, and to make it practical to spawn threads for even tiny pieces of work.</source>
          <target state="translated">线程堆栈（包括主线程的堆栈）位于堆上。随着堆栈的增长，将根据需要添加新的堆栈块。如果堆栈再次缩小，则垃圾收集器将回收这些多余的堆栈块。默认的初始堆栈大小故意较小，目的是将创建线程的时间和空间开销降至最低，并使产生线程甚至很小的工作变得切实可行。</target>
        </trans-unit>
        <trans-unit id="afb01736a569cf800957c75c764e7b08e4d42882" translate="yes" xml:space="preserve">
          <source>ThreadDied</source>
          <target state="translated">ThreadDied</target>
        </trans-unit>
        <trans-unit id="b5249abe5125d8129b1f6094e27ca24e5dfd7b53" translate="yes" xml:space="preserve">
          <source>ThreadFinished</source>
          <target state="translated">ThreadFinished</target>
        </trans-unit>
        <trans-unit id="cd1b87b64abdd5b00fbed5a0cf0c46e8cabde3e0" translate="yes" xml:space="preserve">
          <source>ThreadId</source>
          <target state="translated">ThreadId</target>
        </trans-unit>
        <trans-unit id="cbacd9f0811868fee2692211c0f50253994d843c" translate="yes" xml:space="preserve">
          <source>ThreadId#</source>
          <target state="translated">ThreadId#</target>
        </trans-unit>
        <trans-unit id="210277f1f5be789fa38d99bf66d700f891a72b7b" translate="yes" xml:space="preserve">
          <source>ThreadKilled</source>
          <target state="translated">ThreadKilled</target>
        </trans-unit>
        <trans-unit id="1aacc5025242586267973269d42242e70a03c918" translate="yes" xml:space="preserve">
          <source>ThreadRunning</source>
          <target state="translated">ThreadRunning</target>
        </trans-unit>
        <trans-unit id="03539ff112c319a9993d65dc00b7fc1e80ba7832" translate="yes" xml:space="preserve">
          <source>ThreadStatus</source>
          <target state="translated">ThreadStatus</target>
        </trans-unit>
        <trans-unit id="c415b82d91d35c84fcc4655fc993abc0a3ab34c8" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程从父级继承 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 。也就是说，开始在一个线程 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状态，使用 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 。如果您需要在接收到任何异步异常之前在派生线程中建立异常处理程序，则此功能特别有用。要以未屏蔽状态创建新线程，请使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41a5f845685a6adcb61487ea721a7c03d396057a" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程从父级继承 &lt;code&gt;&lt;a href=&quot;control-exception#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 。也就是说，开始在一个线程 &lt;code&gt;&lt;a href=&quot;control-exception#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状态，使用 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 。如果您需要在接收到任何异步异常之前在派生线程中建立异常处理程序，则此功能特别有用。要以未屏蔽状态创建新线程，请使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02ddbb9a27e7d4b8d61317f07ad835b30faeee84" translate="yes" xml:space="preserve">
          <source>Threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; inherit the &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; from the parent; that is, to start a thread in the &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; state, use &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt;. This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received. To create a new thread in an unmasked state use &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; 创建的线程从父级继承 &lt;code&gt;&lt;a href=&quot;ghc-io#t:MaskingState&quot;&gt;MaskingState&lt;/a&gt;&lt;/code&gt; 。也就是说，开始在一个线程 &lt;code&gt;&lt;a href=&quot;ghc-io#v:MaskedInterruptible&quot;&gt;MaskedInterruptible&lt;/a&gt;&lt;/code&gt; 状态，使用 &lt;code&gt;mask_ $ forkIO ...&lt;/code&gt; 。如果您需要在接收到任何异步异常之前在派生线程中建立异常处理程序，则此功能特别有用。要以未屏蔽状态创建新线程，请使用 &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIOWithUnmask&quot;&gt;forkIOWithUnmask&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="581562d7fdd77f3436334b5a7259e674b4960049" translate="yes" xml:space="preserve">
          <source>Threads with affinity</source>
          <target state="translated">具有亲和力的主题</target>
        </trans-unit>
        <trans-unit id="1831f9d9a0a484604033e790590c1ca2132ad8fe" translate="yes" xml:space="preserve">
          <source>Three handles are allocated during program initialisation, and are initially open.</source>
          <target state="translated">在程序初始化过程中分配了三个句柄,并且初始是开放的。</target>
        </trans-unit>
        <trans-unit id="3cfb69dc1eee67ef7ef938e002c1dcccfc372df6" translate="yes" xml:space="preserve">
          <source>Three kinds of buffering are supported: line-buffering, block-buffering or no-buffering. These modes have the following effects. For output, items are written out, or &lt;em&gt;flushed&lt;/em&gt;, from the internal buffer according to the buffer mode:</source>
          <target state="translated">支持三种缓冲：行缓冲，块缓冲或无缓冲。这些模式具有以下效果。为了输出，根据缓冲区模式从内部缓冲区写出或&lt;em&gt;清除&lt;/em&gt;项目：</target>
        </trans-unit>
        <trans-unit id="67de4025637fbb0de0ee6f5d57e06c1db2d37ad2" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if decoding fails.</source>
          <target state="translated">如果解码失败，则抛出 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530bb7b54f06bf2237068556f8b41935da4566c0" translate="yes" xml:space="preserve">
          <source>Throw a &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; if encoding fails.</source>
          <target state="translated">如果编码失败，则抛出 &lt;code&gt;&lt;a href=&quot;data-text-encoding-error#t:UnicodeException&quot;&gt;UnicodeException&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a88939f2bc16a79d5911956081588d78806af274" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; ,则抛出与 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5653f6b091b3b56dbab455fefe64b2589e61e727" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, but retry in case of an interrupted operation.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; ，则抛出一个与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; ，但是在操作中断的情况下重试。</target>
        </trans-unit>
        <trans-unit id="34d7cc6341315d979ebf0a280e2812fcea684005" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回 &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; ,则抛出与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79cea3439c030b18b5417d5220cf8e7402498869" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;, but retries in case of an interrupted operation.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回的结果为 &lt;code&gt;-1&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的IOError，但在操作中断的情况下重试。</target>
        </trans-unit>
        <trans-unit id="4caf9e3403704122998dcd2e56f9c103bccc209c" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action returns a result of &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作返回结果 &lt;code&gt;-1&lt;/code&gt; ,则抛出与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036abf121e52aab2f60490c26b79ff2ead7c1e41" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; if the result value of the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; action meets the given predicate.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; 操作的结果值满足给定谓词，则抛出与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64aa8ce5d4c7d3f7f49e076896c60b8c7ef43c89" translate="yes" xml:space="preserve">
          <source>Throw an &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; corresponding to the current value of &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">抛出与 &lt;code&gt;&lt;a href=&quot;foreign-c-error#v:getErrno&quot;&gt;getErrno&lt;/a&gt;&lt;/code&gt; 当前值相对应的 &lt;code&gt;&lt;a href=&quot;system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a07ee5048c29ff28ddf4e5f424d1fa111508ece" translate="yes" xml:space="preserve">
          <source>Throw an error when an illegal sequence is encountered</source>
          <target state="translated">当遇到非法序列时抛出一个错误。</target>
        </trans-unit>
        <trans-unit id="4479756108b443a98b7354d085dbc835dc21aeb8" translate="yes" xml:space="preserve">
          <source>Throw an exception. Exceptions may be thrown from purely functional code, but may only be caught within the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad.</source>
          <target state="translated">引发异常。纯粹的功能代码可能会引发异常，但只能在 &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad中捕获异常。</target>
        </trans-unit>
        <trans-unit id="fe9dd6f4bbcbd9abdc92b3911d6713b369a19e14" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">在 &lt;code&gt;STM&lt;/code&gt; 中引发异常会中止事务并传播异常。如果通过 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 捕获了异常，则仅回退由catch包含的更改；否则，将回退。在 &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 之外进行的更改仍然存在。</target>
        </trans-unit>
        <trans-unit id="2e15244ee40229604b0e667942ba71e6efbddfe9" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">在 &lt;code&gt;STM&lt;/code&gt; 中引发异常会中止事务并传播异常。如果通过 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 捕获了异常，则仅回退由catch包含的更改；否则，将回退。在 &lt;code&gt;&lt;a href=&quot;ghc-conc#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 之外进行的更改仍然存在。</target>
        </trans-unit>
        <trans-unit id="62d516dc1db40b86d1546ce065ac2b133fff005a" translate="yes" xml:space="preserve">
          <source>Throwing an exception in &lt;code&gt;STM&lt;/code&gt; aborts the transaction and propagates the exception. If the exception is caught via &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt;, only the changes enclosed by the catch are rolled back; changes made outside of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; persist.</source>
          <target state="translated">在 &lt;code&gt;STM&lt;/code&gt; 中引发异常会中止事务并传播异常。如果通过 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 捕获了异常，则仅回退由catch包含的更改；否则，将回退。在 &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:catchSTM&quot;&gt;catchSTM&lt;/a&gt;&lt;/code&gt; 之外进行的更改仍然存在。</target>
        </trans-unit>
        <trans-unit id="3c57924c9d0ac14d868ac4b1686bc50ff51630e3" translate="yes" xml:space="preserve">
          <source>Throwing and catching I/O errors</source>
          <target state="translated">抛出和捕捉I/O错误</target>
        </trans-unit>
        <trans-unit id="7506d1dc91f2739ca014aacfd180c12f7a3cf7ce" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="translated">抛出异常</target>
        </trans-unit>
        <trans-unit id="7f06faf78ca599a5c5c8ba7a35902fe72d473ba2" translate="yes" xml:space="preserve">
          <source>Thrown when the program attempts to call &lt;code&gt;atomically&lt;/code&gt;, from the &lt;code&gt;stm&lt;/code&gt; package, inside another call to &lt;code&gt;atomically&lt;/code&gt;.</source>
          <target state="translated">当程序试图调用抛出 &lt;code&gt;atomically&lt;/code&gt; ，从 &lt;code&gt;stm&lt;/code&gt; 包，另一个调用内部 &lt;code&gt;atomically&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="153488b4e16cb9e06414f6864aee37a111104fae" translate="yes" xml:space="preserve">
          <source>Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not.</source>
          <target state="translated">当运行时系统检测到计算被保证不终止时抛出。请注意,不能保证运行时系统会注意到任何给定的计算是否被保证终止。</target>
        </trans-unit>
        <trans-unit id="e18cad06fc314dbe98850c48826dae1e000f1a31" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;ctermid(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">如果平台不提供 &lt;code&gt;ctermid(3)&lt;/code&gt; ），则抛出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （&amp;ldquo;不受支持的操作&amp;rdquo;）（使用 &lt;code&gt;#if HAVE_CTERMID&lt;/code&gt; CPP保护措施来检测可用性）。</target>
        </trans-unit>
        <trans-unit id="63e549a9e7a930bc1cd82834decb9a2bd163ce62" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fdatasync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">如果平台不提供 &lt;code&gt;fdatasync(2)&lt;/code&gt; ），则抛出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （&amp;ldquo;不受支持的操作&amp;rdquo;）（使用 &lt;code&gt;#if HAVE_FDATASYNC&lt;/code&gt; CPP保护措施来检测可用性）。</target>
        </trans-unit>
        <trans-unit id="b4fc88eb1e2da00b43f2c50a60cc44995e0823b9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;fsync(2)&lt;/code&gt; (use &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">如果平台不提供 &lt;code&gt;fsync(2)&lt;/code&gt; ），则引发 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （&amp;ldquo;不受支持的操作&amp;rdquo;）（使用 &lt;code&gt;#if HAVE_FSYNC&lt;/code&gt; CPP保护措施来检测可用性）。</target>
        </trans-unit>
        <trans-unit id="a9d629909206eee0dbcf9f3ef3c94be04cfef1d6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;posix_fallocate(2)&lt;/code&gt;.</source>
          <target state="translated">如果平台不提供 &lt;code&gt;posix_fallocate(2)&lt;/code&gt; ,则抛出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （&amp;ldquo;不受支持的操作&amp;rdquo; ）。</target>
        </trans-unit>
        <trans-unit id="e6e500df7fdd7f0b1291a3902735fde41700da58" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; (&quot;unsupported operation&quot;) if platform does not provide &lt;code&gt;tcdrain(3)&lt;/code&gt; (use &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP guard to detect availability).</source>
          <target state="translated">如果平台不提供 &lt;code&gt;tcdrain(3)&lt;/code&gt; ），则抛出 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-io-error#t:IOError&quot;&gt;IOError&lt;/a&gt;&lt;/code&gt; （&amp;ldquo;不受支持的操作&amp;rdquo;）（使用 &lt;code&gt;#if HAVE_TCDRAIN&lt;/code&gt; CPP保护器来检测可用性）。</target>
        </trans-unit>
        <trans-unit id="da37849b4252a8c8814bc0fdc57bbfa1e662b4c6" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; when the channel is empty and no other thread holds a reference to the channel.</source>
          <target state="translated">当通道为空且没有其他线程持有对该通道的引用时，抛出 &lt;code&gt;&lt;a href=&quot;control-exception#v:BlockedIndefinitelyOnMVar&quot;&gt;BlockedIndefinitelyOnMVar&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26e7a0586580fb90b1858fbd0f15fd38c47f7010" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is the empty string or contains an equals sign.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 为空字符串或包含等号，则引发 &lt;code&gt;&lt;a href=&quot;control-exception#v:IOException&quot;&gt;IOException&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ad0dcfc452814fa2ec2a379a00e78d0cb0ada8" translate="yes" xml:space="preserve">
          <source>Throws a &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; if the terminfo database could not be read.</source>
          <target state="translated">如果terminfo数据库无法读取，则引发 &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#t:SetupTermError&quot;&gt;SetupTermError&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76031ddf92450ba52c1e3945097079807a9065c2" translate="yes" xml:space="preserve">
          <source>Thursday</source>
          <target state="translated">Thursday</target>
        </trans-unit>
        <trans-unit id="cef8354a2187206dae84b0978cfa2cac783fc184" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">因此 &lt;code&gt;&lt;a href=&quot;data-list#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 至少包含的元素如换行符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29f4111a9574afc73ad4fb9aa2d80eb12106046f" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">因此 &lt;code&gt;&lt;a href=&quot;data-string#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 至少包含的元素如换行符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e20ffe6f7fbe373d959e03833b11abe8e7b589cd" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">因此 &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 至少包含的元素如换行符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c7038c652bd8ef014d4a0872642e6726ba19bc5" translate="yes" xml:space="preserve">
          <source>Thus &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; contains at least as many elements as newlines in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">因此 &lt;code&gt;&lt;a href=&quot;prelude#v:lines&quot;&gt;lines&lt;/a&gt; s&lt;/code&gt; 至少包含的元素如换行符 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57e24cd4910ef566d3177761fb96a3a2e10793cb" translate="yes" xml:space="preserve">
          <source>Thus rule applies in datatype declarations, too. For example, if we have &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; (and &lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt; is enabled), then &lt;code&gt;a&lt;/code&gt; will be assigned kind &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is a fresh kind variable. Because &lt;code&gt;k&lt;/code&gt; was not written by the user, it will be unavailable for type application in the type of the constructor &lt;code&gt;Proxy&lt;/code&gt;; only the &lt;code&gt;a&lt;/code&gt; will be available.</source>
          <target state="translated">因此，规则也适用于数据类型声明。例如，如果我们有 &lt;code&gt;data Proxy a = Proxy&lt;/code&gt; （并且启用了&lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt;），则将为 &lt;code&gt;a&lt;/code&gt; 分配种类 &lt;code&gt;k&lt;/code&gt; ，其中 &lt;code&gt;k&lt;/code&gt; 是新鲜种类变量。由于 &lt;code&gt;k&lt;/code&gt; 不是由用户编写的，因此它对于构造函数 &lt;code&gt;Proxy&lt;/code&gt; 的类型的type application不可用；仅 &lt;code&gt;a&lt;/code&gt; 将可用。</target>
        </trans-unit>
        <trans-unit id="fe1b4b67a9b45e5176c700a1accff9ef1d36429d" translate="yes" xml:space="preserve">
          <source>Thus, a common invocation would be:</source>
          <target state="translated">因此,一个常见的调用是:</target>
        </trans-unit>
        <trans-unit id="10617fc5bcf1b09fbc9f71f965511f582f11805a" translate="yes" xml:space="preserve">
          <source>Thus, if we call &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; we will get a formatted call-stack alongside our string.</source>
          <target state="translated">因此，如果调用 &lt;code&gt;putStrLnWithCallStack&lt;/code&gt; ,我们将在字符串旁边获得格式化的调用栈。</target>
        </trans-unit>
        <trans-unit id="e5c7ac32fac38f64112fb32061b44ba48e48877f" translate="yes" xml:space="preserve">
          <source>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use &lt;code&gt;App&lt;/code&gt; at a variety of kinds:</source>
          <target state="translated">因此，种类多态性的主要好处是我们现在可以推断出这些最一般的种类，并可以在多种种类下使用 &lt;code&gt;App&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="78f6be9afb4189596518c56574c13c30720db0d1" translate="yes" xml:space="preserve">
          <source>Thus, the instance triggers only when the implicit parameter to &lt;code&gt;UnEx&lt;/code&gt; matches the implicit parameter to &lt;code&gt;MkEx&lt;/code&gt;. Because &lt;code&gt;k&lt;/code&gt; is actually a parameter to &lt;code&gt;UnEx&lt;/code&gt;, the kind is not escaping the existential, and the above code is valid.</source>
          <target state="translated">因此，仅当 &lt;code&gt;UnEx&lt;/code&gt; 的隐式参数与 &lt;code&gt;MkEx&lt;/code&gt; 的隐式参数匹配时，实例才会触发。因为 &lt;code&gt;k&lt;/code&gt; 实际上是 &lt;code&gt;UnEx&lt;/code&gt; 的参数，所以该类型未转义存在对象，因此上述代码有效。</target>
        </trans-unit>
        <trans-unit id="96728018a51a18d78a6c7c7a21bb29d195c725bd" translate="yes" xml:space="preserve">
          <source>TickyFlags</source>
          <target state="translated">TickyFlags</target>
        </trans-unit>
        <trans-unit id="e426b9f760c1a38c2bacbad2f64c53212cc3ffbf" translate="yes" xml:space="preserve">
          <source>Time as measured by the Earth.</source>
          <target state="translated">地球测量的时间。</target>
        </trans-unit>
        <trans-unit id="de35e180cbf98fcc51757a7d0eeb7aa8703d0daf" translate="yes" xml:space="preserve">
          <source>Time locale.</source>
          <target state="translated">时间地点。</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">一天中的时间</target>
        </trans-unit>
        <trans-unit id="311ad74f1246fe76fb5e13a02593b243dfa01e4b" translate="yes" xml:space="preserve">
          <source>Time of day as represented in hour, minute and second (with picoseconds), typically used to express local time of day.</source>
          <target state="translated">以时、分、秒(含皮秒)表示的一天的时间,通常用来表示当地的时间。</target>
        </trans-unit>
        <trans-unit id="674eca31894fe11111cc9e95a912f546b20cfa4c" translate="yes" xml:space="preserve">
          <source>Time of last access in sub-second resolution.</source>
          <target state="translated">最后一次访问的时间,分辨率为亚秒。</target>
        </trans-unit>
        <trans-unit id="bf5b7ea4cfe40f929342452c57b6445e307ff98f" translate="yes" xml:space="preserve">
          <source>Time of last access.</source>
          <target state="translated">最后一次访问的时间。</target>
        </trans-unit>
        <trans-unit id="dd0e25f4fa1eea55d5c7dc261f690719e80e92b5" translate="yes" xml:space="preserve">
          <source>Time of last modification in sub-second resolution.</source>
          <target state="translated">最后一次修改的时间,分辨率为亚秒。</target>
        </trans-unit>
        <trans-unit id="d3ed1832d868c8126249a2fb407fc69507dfb189" translate="yes" xml:space="preserve">
          <source>Time of last modification.</source>
          <target state="translated">最后一次修改的时间。</target>
        </trans-unit>
        <trans-unit id="8a1b24f9546d48f74a1fc1f2be79cc16e32ce4b8" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.) in sub-second resolution.</source>
          <target state="translated">最后一次状态变化的时间(如所有者、组、链接数、模式等),分辨率为亚秒。</target>
        </trans-unit>
        <trans-unit id="de40af977c44da7ce142082cfbcc26c6ffe0cb65" translate="yes" xml:space="preserve">
          <source>Time of last status change (i.e. owner, group, link count, mode, etc.).</source>
          <target state="translated">最后一次状态变化的时间(如所有者、组、链接数、模式等)。</target>
        </trans-unit>
        <trans-unit id="37cc2e4553f3b7c4572077f6ce8dcd7260d2fd48" translate="yes" xml:space="preserve">
          <source>Time values from the RTS, using a fixed resolution of nanoseconds.</source>
          <target state="translated">来自RTS的时间值,使用纳秒的固定分辨率。</target>
        </trans-unit>
        <trans-unit id="fa9aac4028931969e4e43d5926f21c1c02b03737" translate="yes" xml:space="preserve">
          <source>Time zones</source>
          <target state="translated">时区</target>
        </trans-unit>
        <trans-unit id="3694fd8d8502573c050c12c21dfc64202808f47a" translate="yes" xml:space="preserve">
          <source>TimeExpired</source>
          <target state="translated">TimeExpired</target>
        </trans-unit>
        <trans-unit id="54ca8d2ae2173c38ac3276efe44835c04bf7b464" translate="yes" xml:space="preserve">
          <source>TimeLocale</source>
          <target state="translated">TimeLocale</target>
        </trans-unit>
        <trans-unit id="3a383c209c07d7ddd4a20a832e5e3183c6735122" translate="yes" xml:space="preserve">
          <source>TimeOfDay</source>
          <target state="translated">TimeOfDay</target>
        </trans-unit>
        <trans-unit id="a4208dd784207f8d84ef4fa31bd30bdd2b432c1d" translate="yes" xml:space="preserve">
          <source>TimeZone</source>
          <target state="translated">TimeZone</target>
        </trans-unit>
        <trans-unit id="30a4ddc2d1e47c72524d2ae1195d49334429ec48" translate="yes" xml:space="preserve">
          <source>TimeoutCallback</source>
          <target state="translated">TimeoutCallback</target>
        </trans-unit>
        <trans-unit id="03a9149686779469a820b3f21f5f3096edd2e773" translate="yes" xml:space="preserve">
          <source>TimeoutKey</source>
          <target state="translated">TimeoutKey</target>
        </trans-unit>
        <trans-unit id="554c6dbe0800fb90ce862ee9b17611f1be40e742" translate="yes" xml:space="preserve">
          <source>TimerManager</source>
          <target state="translated">TimerManager</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e0f0bc7f2e5196ca0e12562d2fea3c45abb35a55" translate="yes" xml:space="preserve">
          <source>TitlecaseLetter</source>
          <target state="translated">TitlecaseLetter</target>
        </trans-unit>
        <trans-unit id="2234a4a2c47c8ff0b64637496c3e6c3bfefcacba" translate="yes" xml:space="preserve">
          <source>Tix</source>
          <target state="translated">Tix</target>
        </trans-unit>
        <trans-unit id="a74eb4584cb5c18ee809ed00eb188fdec5bb579c" translate="yes" xml:space="preserve">
          <source>TixModule</source>
          <target state="translated">TixModule</target>
        </trans-unit>
        <trans-unit id="fe0563e640d1279bce1fac48bf8a1b5e02bcb7ab" translate="yes" xml:space="preserve">
          <source>To a foreign library, the bound thread will look exactly like an ordinary operating system thread created using OS functions like &lt;code&gt;pthread_create&lt;/code&gt; or &lt;code&gt;CreateThread&lt;/code&gt;.</source>
          <target state="translated">对于外部库而言，绑定线程看起来与使用OS函数（例如 &lt;code&gt;pthread_create&lt;/code&gt; 或 &lt;code&gt;CreateThread&lt;/code&gt; )创建的普通操作系统线程完全相同。</target>
        </trans-unit>
        <trans-unit id="ff80debaf5b64e3919c264f8e4e883f22ace9ad9" translate="yes" xml:space="preserve">
          <source>To abandon the current evaluation, use &lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt;&lt;code&gt;:abandon&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要放弃当前评估，请使用&lt;a href=&quot;#ghci-cmd-:abandon&quot;&gt; &lt;code&gt;:abandon&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d87be1eb54b07a48c8e89e1267bd4da7830b639e" translate="yes" xml:space="preserve">
          <source>To accumulate a value without using it on the way, see &lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;.</source>
          <target state="translated">要累积一个值而不在途中使用它，请参见&lt;a href=&quot;control-monad-trans-writer&quot;&gt;Control.Monad.Trans.Writer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e5f8467c41adb6b14b429081219eab2c60a0901" translate="yes" xml:space="preserve">
          <source>To achieve these properties, in the safe language dialect we disable completely the following features:</source>
          <target state="translated">为了实现这些特性,在安全语言方言中,我们完全禁用了以下功能。</target>
        </trans-unit>
        <trans-unit id="2aa92551218d14a1f44f24fb7177ce7a2bf713bc" translate="yes" xml:space="preserve">
          <source>To add modules to the scope, use ordinary Haskell &lt;code&gt;import&lt;/code&gt; syntax:</source>
          <target state="translated">要将模块添加到作用域，请使用普通的Haskell &lt;code&gt;import&lt;/code&gt; 语法：</target>
        </trans-unit>
        <trans-unit id="e2f3886d316e1e619156706746a8dfbb48e79115" translate="yes" xml:space="preserve">
          <source>To alleviate this issue, GHCi commands can be split over multiple lines, by wrapping them in &lt;code&gt;:{&lt;/code&gt; and &lt;code&gt;:}&lt;/code&gt; (each on a single line of its own):</source>
          <target state="translated">为了缓解此问题，可以通过将GHCi命令包装在 &lt;code&gt;:{&lt;/code&gt; 和 &lt;code&gt;:}&lt;/code&gt; 中（每行单独一行）来将其分成多行：</target>
        </trans-unit>
        <trans-unit id="de30b4286a2929bfdff88d5ee52a322ecb634497" translate="yes" xml:space="preserve">
          <source>To allow for such an instance, we would have to define &lt;code&gt;(:~~:)&lt;/code&gt; as follows:</source>
          <target state="translated">为了允许这样的实例，我们将必须定义 &lt;code&gt;(:~~:)&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="14c677f99c3ebfb083d5ba45347b3df00c07e009" translate="yes" xml:space="preserve">
          <source>To also set the directory in which to run &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">要同时设置运行 &lt;code&gt;ls&lt;/code&gt; 的目录：</target>
        </trans-unit>
        <trans-unit id="4ef0b5766dccbebaac045d8e4e6bded46db835a3" translate="yes" xml:space="preserve">
          <source>To always compile everything to object code and never use the interpreter, use the &lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt;&lt;code&gt;-fobject-code&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;#ghci-obj&quot;&gt;Compiling to object code inside GHCi&lt;/a&gt;).</source>
          <target state="translated">要始终将所有内容编译为目标代码并且不使用解释器，请使用&lt;a href=&quot;phases#ghc-flag--fobject-code&quot;&gt; &lt;code&gt;-fobject-code&lt;/code&gt; &lt;/a&gt;选项（请参阅&lt;a href=&quot;#ghci-obj&quot;&gt;GHCi中的编译为目标代码&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5df8df6d3cdb1b8cf45eb7ff8b8e9438a9330317" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为了避免种类和类型之间的重复，将它们定义为相同。自然，您永远不会拥有 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 类型，也永远不会拥有 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 类型，但是许多其他构造函数是共享的。请注意， &lt;code&gt;Bool&lt;/code&gt; 类型用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 表示，而不是 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; 。类似地，使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 来创建元组类型。</target>
        </trans-unit>
        <trans-unit id="9bbefb7d7331de5a028c9b6fdc70e6d980c4f650" translate="yes" xml:space="preserve">
          <source>To avoid duplication between kinds and types, they are defined to be the same. Naturally, you would never have a type be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; and you would never have a kind be &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt;, but many of the other constructors are shared. Note that the kind &lt;code&gt;Bool&lt;/code&gt; is denoted with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt;. Similarly, tuple kinds are made with &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">为了避免种类和类型之间的重复，将它们定义为相同。自然，您永远不会拥有 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:StarT&quot;&gt;StarT&lt;/a&gt;&lt;/code&gt; 类型，也永远不会拥有 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:SigT&quot;&gt;SigT&lt;/a&gt;&lt;/code&gt; 类型，但是许多其他构造函数是共享的。请注意， &lt;code&gt;Bool&lt;/code&gt; 类型用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ConT&quot;&gt;ConT&lt;/a&gt;&lt;/code&gt; 表示，而不是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedT&quot;&gt;PromotedT&lt;/a&gt;&lt;/code&gt; 。类似地，使用 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:TupleT&quot;&gt;TupleT&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PromotedTupleT&quot;&gt;PromotedTupleT&lt;/a&gt;&lt;/code&gt; 来创建元组类型。</target>
        </trans-unit>
        <trans-unit id="b6771efdf3a686f294db18bd2d14bac4e3dba651" translate="yes" xml:space="preserve">
          <source>To avoid generating an interface at all, you could use this option to redirect the interface into the bit bucket: &lt;code&gt;-ohi /dev/null&lt;/code&gt;, for example.</source>
          <target state="translated">要完全避免生成接口，可以使用此选项将接口重定向到位存储桶： &lt;code&gt;-ohi /dev/null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7aaccb0bd8d229ee1d19d9e75f8795d4cf2370af" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">为了避免细微的编码错误，手写编组代码最好使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ,而不是使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-unsafe#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 的组合。但是，后者例程有时在工具生成的编组代码中是首选。</target>
        </trans-unit>
        <trans-unit id="fa34733b5e19e7e6a87e5c91b392ff0b0780aa0b" translate="yes" xml:space="preserve">
          <source>To avoid subtle coding errors, hand written marshalling code should preferably use &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; rather than combinations of &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt;. However, the latter routines are occasionally preferred in tool generated marshalling code.</source>
          <target state="translated">为了避免细微的编码错误，手写编组代码最好使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:withForeignPtr&quot;&gt;withForeignPtr&lt;/a&gt;&lt;/code&gt; ,而不是使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:unsafeForeignPtrToPtr&quot;&gt;unsafeForeignPtrToPtr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:touchForeignPtr&quot;&gt;touchForeignPtr&lt;/a&gt;&lt;/code&gt; 的组合。但是，后者例程有时在工具生成的编组代码中是首选。</target>
        </trans-unit>
        <trans-unit id="b35e7282d157dcf47660cd59431c4a8fca882cba" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">为避免此问题，请改用 &lt;code&gt;&lt;a href=&quot;data-ioref#v:modifyIORef-39-&quot;&gt;modifyIORef'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dbcc0e48dafb4a864c6c8fc82578cf9d42f26f" translate="yes" xml:space="preserve">
          <source>To avoid this problem, use &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">为避免此问题，请改用 &lt;code&gt;&lt;a href=&quot;data-stref#v:modifySTRef-39-&quot;&gt;modifySTRef'&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c0704d5dd80ea4a49e31c8c21b3410ffa34f67" translate="yes" xml:space="preserve">
          <source>To avoid undefined behaviour, the original &lt;code&gt;MutableByteArray#&lt;/code&gt; shall not be accessed anymore after a &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; has been performed. Moreover, no reference to the old one should be kept in order to allow garbage collection of the original &lt;code&gt;MutableByteArray#&lt;/code&gt; in case a new &lt;code&gt;MutableByteArray#&lt;/code&gt; had to be allocated.</source>
          <target state="translated">为了避免不确定的行为，原来 &lt;code&gt;MutableByteArray#&lt;/code&gt; 不得进行访问后不再 &lt;code&gt;resizeMutableByteArray#&lt;/code&gt; 已执行。而且，在必须分配新的 &lt;code&gt;MutableByteArray#&lt;/code&gt; 的情况下，为了保留原始 &lt;code&gt;MutableByteArray#&lt;/code&gt; 的垃圾，不应保留任何对旧引用的引用。</target>
        </trans-unit>
        <trans-unit id="d1d67bfc1538ab33d21305009ebcc630714c1858" translate="yes" xml:space="preserve">
          <source>To be precise, if the class being derived is of the form</source>
          <target state="translated">准确地说,如果被派生的类的形式是</target>
        </trans-unit>
        <trans-unit id="c0d9f8d6315eb7cbdcbf50a9f874b3aee61aa5d5" translate="yes" xml:space="preserve">
          <source>To be precise, the annotation &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; is well staged if and only if &lt;code&gt;$(e)&lt;/code&gt; would be (disregarding the usual type restrictions of the splice syntax, and the usual restriction on splicing inside a splice - &lt;code&gt;$([|1|])&lt;/code&gt; is fine as an annotation, albeit redundant).</source>
          <target state="translated">确切地说，注释 &lt;code&gt;{-# ANN x e #-}&lt;/code&gt; 在且仅当 &lt;code&gt;$(e)&lt;/code&gt; 将（而不考虑拼接语法的通常类型限制，以及拼接内部的通常拼接限制- &lt;code&gt;$([|1|])&lt;/code&gt; 可以用作注释，尽管有多余）。</target>
        </trans-unit>
        <trans-unit id="28876308b2232e888282a46a9f2647185f20da23" translate="yes" xml:space="preserve">
          <source>To build Haskell modules that export a C API into a shared library use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; flags:</source>
          <target state="translated">要构建将C API导出到共享库中的Haskell模块，请使用&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt;标志：</target>
        </trans-unit>
        <trans-unit id="99edfbf2248bb2a627dfdcc360ffdb881b08cb4d" translate="yes" xml:space="preserve">
          <source>To build a simple program and have it use shared libraries for the runtime system and the base libraries use the &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; flag:</source>
          <target state="translated">要构建一个简单的程序并使它使用运行时系统的共享库，而基本库则使用&lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;标志：</target>
        </trans-unit>
        <trans-unit id="007ba52a2d8fb965e0b5df4e486442e39607c309" translate="yes" xml:space="preserve">
          <source>To bundle a pattern synonym with a type constructor, we list the pattern synonym in the export list of a module which exports the type constructor. For example, to bundle &lt;code&gt;Zero&lt;/code&gt; with &lt;code&gt;MyNum&lt;/code&gt; we could write the following:</source>
          <target state="translated">为了将模式同义词与类型构造函数捆绑在一起，我们在导出类型构造函数的模块的导出列表中列出了模式同义词。例如，要将 &lt;code&gt;Zero&lt;/code&gt; 与 &lt;code&gt;MyNum&lt;/code&gt; 捆绑在一起，我们可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="b5aae458adadd6ea36810e5833a7811c73bd6831" translate="yes" xml:space="preserve">
          <source>To check whether your &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; setting is doing the right thing, &lt;code&gt;ghc-pkg list&lt;/code&gt; will list all the databases in use, in the reverse order they are searched.</source>
          <target state="translated">要检查您的 &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; 设置是否做对了， &lt;code&gt;ghc-pkg list&lt;/code&gt; 将以搜索时的相反顺序列出所有正在使用的数据库。</target>
        </trans-unit>
        <trans-unit id="d99b230674f283901189e80464c11bff12827985" translate="yes" xml:space="preserve">
          <source>To compile a module which is to be part of a new package, use the &lt;code&gt;-package-name&lt;/code&gt; (to identify the name of the package) and &lt;code&gt;-library-name&lt;/code&gt; (to identify the version and the version hashes of its identities.) options (&lt;a href=&quot;#using-packages&quot;&gt;Using Packages&lt;/a&gt;). Failure to use these options when compiling a package will probably result in disaster, but you will only discover later when you attempt to import modules from the package. At this point GHC will complain that the package name it was expecting the module to come from is not the same as the package name stored in the &lt;code&gt;.hi&lt;/code&gt; file.</source>
          <target state="translated">要编译将作为新软件包一部分的模块，请使用 &lt;code&gt;-package-name&lt;/code&gt; （标识软件包的名称）和 &lt;code&gt;-library-name&lt;/code&gt; （标识版本和其标识的版本哈希。）选项（&lt;a href=&quot;#using-packages&quot;&gt;使用包&lt;/a&gt;）。编译软件包时不使用这些选项可能会导致灾难，但是只有稍后尝试从软件包中导入模块时，您才会发现。此时，GHC会抱怨它期望模块来自的软件包名称与存储在 &lt;code&gt;.hi&lt;/code&gt; 文件中的软件包名称不同。</target>
        </trans-unit>
        <trans-unit id="12fd6ddf28c5285fa1983ff47d370bb4e33b05da" translate="yes" xml:space="preserve">
          <source>To compile the program, use GHC like this:</source>
          <target state="translated">编译程序时,请使用GHC,像这样。</target>
        </trans-unit>
        <trans-unit id="485c5e401e6a134f4abe73897df6824e3409a20e" translate="yes" xml:space="preserve">
          <source>To compile these three files, issue the following commands:</source>
          <target state="translated">要编译这三个文件,请发出以下命令。</target>
        </trans-unit>
        <trans-unit id="8a91e9bb879d47c785fc61c253926f7398d2eae9" translate="yes" xml:space="preserve">
          <source>To control the choice of instance, it is possible to specify the overlap behavior for individual instances with a pragma, written immediately after the &lt;code&gt;instance&lt;/code&gt; keyword. The pragma may be one of: &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt;, &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt;, or &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt;.</source>
          <target state="translated">为了控制实例的选择，可以使用pragma（在紧跟 &lt;code&gt;instance&lt;/code&gt; 关键字之后编写）为单个实例指定重叠行为。编译指示可以是以下之一： &lt;code&gt;{-# OVERLAPPING #-}&lt;/code&gt; ， &lt;code&gt;{-# OVERLAPPABLE #-}&lt;/code&gt; ， &lt;code&gt;{-# OVERLAPS #-}&lt;/code&gt; ，或 &lt;code&gt;{-# INCOHERENT #-}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dc0d1e2f710041d917fa9128128d16f4e0b579c" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt;, use the following:</source>
          <target state="translated">要将 &lt;code&gt;&lt;a href=&quot;foreign-c-types#t:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-time#v:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; ，请使用以下命令：</target>
        </trans-unit>
        <trans-unit id="1c0964746ae7b2a2f00992a848001548495aecef" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">要将 &lt;code&gt;&lt;a href=&quot;foreign-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 值转换为相应的Haskell函数，可以为特定的外部类型定义&lt;em&gt;动态&lt;/em&gt;存根，例如</target>
        </trans-unit>
        <trans-unit id="5d067decf6925ff18738730cccec299d546abf35" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">要将 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 值转换为相应的Haskell函数，可以为特定的外部类型定义&lt;em&gt;动态&lt;/em&gt;存根，例如</target>
        </trans-unit>
        <trans-unit id="fea7f792e37393718cca4a9b6921cb08aba10fa5" translate="yes" xml:space="preserve">
          <source>To convert &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; values to corresponding Haskell functions, one can define a &lt;em&gt;dynamic&lt;/em&gt; stub for the specific foreign type, e.g.</source>
          <target state="translated">要将 &lt;code&gt;&lt;a href=&quot;ghc-ptr#t:FunPtr&quot;&gt;FunPtr&lt;/a&gt;&lt;/code&gt; 值转换为相应的Haskell函数，可以为特定的外部类型定义&lt;em&gt;动态&lt;/em&gt;存根，例如</target>
        </trans-unit>
        <trans-unit id="2acaa5dea000cc74154c0f402c3febbfb83f1a58" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">到转换 &lt;code&gt;&lt;a href=&quot;data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 到或从相应的 &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 通过的Unicode定义的值，使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 分别（或等效类 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="786657e4c88a725db3968f98b13dce85d65db23b" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">到转换 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 到或从相应的 &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 通过的Unicode定义的值，使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 分别（或等效类 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d7130a3be670709f03cd81a58cb2b61282e0d6dd" translate="yes" xml:space="preserve">
          <source>To convert a &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; to or from the corresponding &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; value defined by Unicode, use &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; class respectively (or equivalently &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">到转换 &lt;code&gt;&lt;a href=&quot;prelude#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; 到或从相应的 &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; 通过的Unicode定义的值，使用 &lt;code&gt;&lt;a href=&quot;prelude#v:toEnum&quot;&gt;toEnum&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;prelude#v:fromEnum&quot;&gt;fromEnum&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;prelude#v:Enum&quot;&gt;Enum&lt;/a&gt;&lt;/code&gt; 分别（或等效类 &lt;code&gt;&lt;a href=&quot;data-char#v:ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data-char#v:chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13a465a9773b015ffc884872ada910d6f797abb7" translate="yes" xml:space="preserve">
          <source>To convert from a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;System.Posix.EpochTime&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要从 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-c-types#v:CTime&quot;&gt;CTime&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;System.Posix.EpochTime&lt;/code&gt; 转换，请使用 &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:realToFrac&quot;&gt;realToFrac&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1659f84a77c9a2443a59423cc658f61a338f3abe" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要创建完全不编码的 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ，请使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。若要停止对现有 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的进一步编码或解码，请使用 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f153e244215130d9c4edb53cdcbba15630d42840" translate="yes" xml:space="preserve">
          <source>To create a &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; with no encoding at all, use &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt;. To stop further encoding or decoding on an existing &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要创建完全不编码的 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ，请使用 &lt;code&gt;&lt;a href=&quot;system-io#v:openBinaryFile&quot;&gt;openBinaryFile&lt;/a&gt;&lt;/code&gt; 。若要停止对现有 &lt;code&gt;&lt;a href=&quot;system-io#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的进一步编码或解码，请使用 &lt;code&gt;&lt;a href=&quot;system-io#v:hSetBinaryMode&quot;&gt;hSetBinaryMode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1171deb859f0f29f6aacadc46ea52378fb28f5f8" translate="yes" xml:space="preserve">
          <source>To create a pipe from which to read the output of &lt;code&gt;ls&lt;/code&gt;:</source>
          <target state="translated">创建一个管道来读取 &lt;code&gt;ls&lt;/code&gt; 的输出：</target>
        </trans-unit>
        <trans-unit id="96af4537bfd12fadb83763899a123cc096a36017" translate="yes" xml:space="preserve">
          <source>To define the &lt;code&gt;item&lt;/code&gt; parser, we need to lift the &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; operations through the &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; transformer.</source>
          <target state="translated">要定义 &lt;code&gt;item&lt;/code&gt; 解析器，我们需要通过 &lt;code&gt;&lt;a href=&quot;control-monad-trans-writer-lazy#v:WriterT&quot;&gt;WriterT&lt;/a&gt;&lt;/code&gt; 转换器提升 &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="61b1e6de56b01e5140d8cba3ed36c3acb9b257dc" translate="yes" xml:space="preserve">
          <source>To delete a breakpoint, use the &lt;a href=&quot;#ghci-cmd-:delete&quot;&gt;&lt;code&gt;:delete&lt;/code&gt;&lt;/a&gt; command with the number given in the output from &lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt;&lt;code&gt;:show breaks&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要删除断点，请使用&lt;a href=&quot;#ghci-cmd-:delete&quot;&gt; &lt;code&gt;:delete&lt;/code&gt; &lt;/a&gt;命令，并使用&lt;a href=&quot;#ghci-cmd-:show%20breaks&quot;&gt; &lt;code&gt;:show breaks&lt;/code&gt; &lt;/a&gt;输出中给出的数字：</target>
        </trans-unit>
        <trans-unit id="ea8e294886bade8bd7cc5b83aa9ec115d1403bbc" translate="yes" xml:space="preserve">
          <source>To delete all breakpoints at once, use &lt;code&gt;:delete *&lt;/code&gt;.</source>
          <target state="translated">要一次删除所有断点，请使用 &lt;code&gt;:delete *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20c69ea8d7a8119ee63218b8c507949aacadde61" translate="yes" xml:space="preserve">
          <source>To derive &lt;code&gt;Eq&lt;/code&gt; in the standard way we would need to have equality between the single component of two &lt;code&gt;MkT&lt;/code&gt; constructors:</source>
          <target state="translated">要以标准方式导出 &lt;code&gt;Eq&lt;/code&gt; ，我们需要在两个 &lt;code&gt;MkT&lt;/code&gt; 构造函数的单个组件之间具有相等性：</target>
        </trans-unit>
        <trans-unit id="9be5e62141d987ac491830af48130b4bb8a0121e" translate="yes" xml:space="preserve">
          <source>To examine one of the steps in the history, use &lt;a href=&quot;#ghci-cmd-:back&quot;&gt;&lt;code&gt;:back&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要查看历史记录中的步骤之一，请使用&lt;a href=&quot;#ghci-cmd-:back&quot;&gt; &lt;code&gt;:back&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="66eef0e4ec6c04a45dd59938c23022bba82ff967" translate="yes" xml:space="preserve">
          <source>To export them on their own, in an export or import specification, you must prefix pattern names with the &lt;code&gt;pattern&lt;/code&gt; keyword, e.g.:</source>
          <target state="translated">要单独导出它们，在导出或导入规范中，必须在模式名称前加上 &lt;code&gt;pattern&lt;/code&gt; 关键字，例如：</target>
        </trans-unit>
        <trans-unit id="373832b60bccf6816963a2a722042fdc637fe0c9" translate="yes" xml:space="preserve">
          <source>To figure out which part of the compiler is badly behaved, the &lt;code&gt;-v2&lt;/code&gt; option is your friend.</source>
          <target state="translated">要弄清楚编译器的哪个部分表现不佳，可以使用 &lt;code&gt;-v2&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="617e8f413888e2a59390516c4594fefa6467d4c8" translate="yes" xml:space="preserve">
          <source>To fix the problem, you need to recompile the broken packages against the new dependencies. The easiest way to do this is to use &lt;code&gt;cabal-install&lt;/code&gt;, or download the packages from &lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt; and build and install them as normal.</source>
          <target state="translated">要解决此问题，您需要针对新的依赖项重新编译损坏的程序包。最简单的方法是使用 &lt;code&gt;cabal-install&lt;/code&gt; ，或从&lt;a href=&quot;http://hackage.haskell.org/packages/hackage.html&quot;&gt;HackageDB&lt;/a&gt;下载软件包并按常规方式构建和安装它们。</target>
        </trans-unit>
        <trans-unit id="d1fadbae3a14577a0f008fefc32f335b95527ef3" translate="yes" xml:space="preserve">
          <source>To further explain this example, the right-hand side of the default type signature for &lt;code&gt;bar&lt;/code&gt; must be something that is alpha-equivalent to &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; (where &lt;code&gt;a&lt;/code&gt; is bound by the class itself, and is thus free in the methods&amp;rsquo; type signatures). So this would also be an acceptable default type signature:</source>
          <target state="translated">为了进一步说明此示例， &lt;code&gt;bar&lt;/code&gt; 的默认类型签名的右侧必须与 &lt;code&gt;forall b. a -&amp;gt; b -&amp;gt; b&lt;/code&gt; 等效。a-&amp;gt; b-&amp;gt; b（其中 &lt;code&gt;a&lt;/code&gt; 由类本身绑定，因此在方法的类型签名中是自由的）。因此，这也是可接受的默认类型签名：</target>
        </trans-unit>
        <trans-unit id="1e54d546d02ad4863886b9ee73d1e131e1c71a9f" translate="yes" xml:space="preserve">
          <source>To gain access to a much larger family of encodings, use the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">要访问更大的编码系列，请使用&lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7552595f3e9f52aba2ce1ac4224b4fd08998d77" translate="yes" xml:space="preserve">
          <source>To generate a heap profile from your program:</source>
          <target state="translated">要从你的程序中生成一个堆配置文件。</target>
        </trans-unit>
        <trans-unit id="5c213d8e1ad0bf625f6921a8437f98eeb3f4a1b0" translate="yes" xml:space="preserve">
          <source>To generate a time and allocation profile, give one of the following RTS options to the compiled program when you run it (RTS options should be enclosed between &lt;code&gt;+RTS ... -RTS&lt;/code&gt; as usual):</source>
          <target state="translated">要生成时间和分配配置文件，请在运行程序时为编译后的程序提供以下RTS选项之一（通常，RTS选项应放在 &lt;code&gt;+RTS ... -RTS&lt;/code&gt; 之间）：</target>
        </trans-unit>
        <trans-unit id="34cea9b35b2bfd8b0bd668c0b07e2825a95e1c3d" translate="yes" xml:space="preserve">
          <source>To get a list of the bindings currently in scope, use the &lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt;&lt;code&gt;:show bindings&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">要获取当前作用域中的绑定列表，请使用&lt;a href=&quot;#ghci-cmd-:show%20bindings&quot;&gt; &lt;code&gt;:show bindings&lt;/code&gt; &lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="584aacfb52fdd9de92b4db69f120bc255bd58b9a" translate="yes" xml:space="preserve">
          <source>To get a more useful version of the &lt;code&gt;Collects&lt;/code&gt; class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for &amp;ldquo;parametric type classes&amp;rdquo; that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones&amp;rsquo;s later framework for &amp;ldquo;improvement&amp;rdquo; of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript &lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</source>
          <target state="translated">为了获得更有用的 &lt;code&gt;Collects&lt;/code&gt; 类版本，GHC提供了一种机制，允许程序员指定多参数类的参数之间的依赖关系（对于对理论基础和以前的工作感兴趣的读者：可以看到依赖关系信息的使用既可以作为Chen，Hudak和Odersky提出的&amp;ldquo;参数类型类&amp;rdquo;建议的概括，也可以作为Mark Jones后来的&amp;ldquo;改进&amp;rdquo;合格类型框架的特例。手稿中更具理论性和抽象性的背景&lt;a href=&quot;#jones1999&quot; id=&quot;id31&quot;&gt;[Jones1999]&lt;/a&gt;，在隐式参数化系统的常规设计空间中将它们标识为一点。从一个抽象的例子开始，请考虑如下声明：</target>
        </trans-unit>
        <trans-unit id="2dd4283dabd7adbbf3b3fa6217759a91e02bf006" translate="yes" xml:space="preserve">
          <source>To get better errors, it is recommended to use #line pragmas when emitting C files, e.g.</source>
          <target state="translated">为了获得更好的错误,建议在发出C文件时使用#行原则,如</target>
        </trans-unit>
        <trans-unit id="c4c508962468a9bf469857dfae6ad15a1e12b86c" translate="yes" xml:space="preserve">
          <source>To get maximum performance when building lazy &lt;code&gt;Text&lt;/code&gt; values using a builder, associate &lt;code&gt;mappend&lt;/code&gt; calls to the right. For example, prefer</source>
          <target state="translated">为了在使用构建器构建惰性 &lt;code&gt;Text&lt;/code&gt; 值时获得最佳性能，请在右侧关联 &lt;code&gt;mappend&lt;/code&gt; 调用。例如，更喜欢</target>
        </trans-unit>
        <trans-unit id="e54b5b21677328842d1e9a6b9afb2745752f58b5" translate="yes" xml:space="preserve">
          <source>To get the annotations of a single binder, you can use &lt;code&gt;getAnnotations&lt;/code&gt; and specify the proper type. Here&amp;rsquo;s an example that will print out the name of any top-level non-recursive binding with the &lt;code&gt;SomeAnn&lt;/code&gt; annotation:</source>
          <target state="translated">要获取单个活页夹的注释，可以使用 &lt;code&gt;getAnnotations&lt;/code&gt; 并指定适当的类型。这是一个示例，该示例将打印出带有 &lt;code&gt;SomeAnn&lt;/code&gt; 批注的任何顶级非递归绑定的名称：</target>
        </trans-unit>
        <trans-unit id="427028b92998e9d2972ad20dfdc92870e2d3c450" translate="yes" xml:space="preserve">
          <source>To help understand the use of these functions, consider the Unicode string &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt;. If encoded as UTF-8, this becomes &lt;code&gt;&quot;hi
 \xe2\x98\x83&quot;&lt;/code&gt;; the final &lt;code&gt;'☃'&lt;/code&gt; is encoded as 3 bytes.</source>
          <target state="translated">为了帮助理解这些功能的使用，请考虑Unicode字符串 &lt;code&gt;&quot;hi ☃&quot;&lt;/code&gt; 。如果编码为UTF-8，则变为 &lt;code&gt;&quot;hi \xe2\x98\x83&quot;&lt;/code&gt; ；最后的 &lt;code&gt;'☃'&lt;/code&gt; 编码为3个字节。</target>
        </trans-unit>
        <trans-unit id="99872510dc191d4452db56bf22957570e23b92b9" translate="yes" xml:space="preserve">
          <source>To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into &lt;code&gt;Main.hs&lt;/code&gt; and &lt;code&gt;Printf.hs&lt;/code&gt;:</source>
          <target state="translated">为了帮助您克服置信区间的障碍，请尝试以下骨架示例。首先将以下两个模块剪切并粘贴到 &lt;code&gt;Main.hs&lt;/code&gt; 和 &lt;code&gt;Printf.hs&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="48b1aabf0c4a191f672c0b44cca67c4f38a6d577" translate="yes" xml:space="preserve">
          <source>To hopefully illuminate the role of the different data structures, here are the command-line options for a (very simple) compiler, done in two different ways. The difference arises because the type of &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; is parameterized by the type of values derived from flags.</source>
          <target state="translated">为了希望阐明不同数据结构的作用，这里有一个（非常简单的）编译器的命令行选项，以两种不同的方式完成。之所以会出现差异，是因为 &lt;code&gt;&lt;a href=&quot;system-console-getopt#v:getOpt&quot;&gt;getOpt&lt;/a&gt;&lt;/code&gt; 的类型由从标志派生的值的类型进行了参数化。</target>
        </trans-unit>
        <trans-unit id="d8ae72f545b1ce82b2cfe09ab991783beb655542" translate="yes" xml:space="preserve">
          <source>To implement &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findLast&lt;/code&gt; on any &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">在任何 &lt;code&gt;&lt;a href=&quot;data-foldable#v:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; 上实现 &lt;code&gt;find&lt;/code&gt; 或 &lt;code&gt;findLast&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c7c52e770ffa8a6b97378d2c5e459f4d2e43a4e" translate="yes" xml:space="preserve">
          <source>To install LLVM and Clang:</source>
          <target state="translated">要安装LLVM和Clang。</target>
        </trans-unit>
        <trans-unit id="f4755fa59e195e04ee11ff89504edf74eae51201" translate="yes" xml:space="preserve">
          <source>To invoke &lt;code&gt;foo()&lt;/code&gt; from C, just &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; and call &lt;code&gt;foo()&lt;/code&gt;.</source>
          <target state="translated">要从C 调用 &lt;code&gt;foo()&lt;/code&gt; ，只需 &lt;code&gt;#include &quot;Foo_stub.h&quot;&lt;/code&gt; 并调用 &lt;code&gt;foo()&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="67c620f61de0b4e8243389340a761b127a5420c3" translate="yes" xml:space="preserve">
          <source>To learn more about this decision and the design of GHC under the hood please see the &lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;paper&lt;/a&gt; introducing this kind system to GHC/Haskell.</source>
          <target state="translated">要了解更多关于这个决定，并GHC设计的引擎盖下请参阅&lt;a href=&quot;http://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf&quot;&gt;本文&lt;/a&gt;引入这种系统GHC /哈斯克尔。</target>
        </trans-unit>
        <trans-unit id="aae76ecf649e9d0d8a82065b74e94e13fc57f2d4" translate="yes" xml:space="preserve">
          <source>To load a Haskell source file into GHCi, use the &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">要将Haskell源文件加载到GHCi中，请使用&lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt;命令：</target>
        </trans-unit>
        <trans-unit id="84282ca7b4af31d8f72f41e5b0309bfeef77e8b2" translate="yes" xml:space="preserve">
          <source>To load a package &lt;code&gt;foo&lt;/code&gt;, GHCi can load its &lt;code&gt;libHSfoo.a&lt;/code&gt; library directly, but it can also load a package in the form of a single &lt;code&gt;HSfoo.o&lt;/code&gt; file that has been pre-linked. Loading the &lt;code&gt;.o&lt;/code&gt; file is slightly quicker, but at the expense of having another copy of the compiled package. The rule of thumb is that if the modules of the package were compiled with &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt; then building the &lt;code&gt;HSfoo.o&lt;/code&gt; is worthwhile because it saves time when loading the package into GHCi. Without &lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt;&lt;code&gt;-split-objs&lt;/code&gt;&lt;/a&gt;, there is not much difference in load time between the &lt;code&gt;.o&lt;/code&gt; and &lt;code&gt;.a&lt;/code&gt; libraries, so it is better to save the disk space and only keep the &lt;code&gt;.a&lt;/code&gt; around. In a GHC distribution we provide &lt;code&gt;.o&lt;/code&gt; files for most packages except the GHC package itself.</source>
          <target state="translated">要加载 &lt;code&gt;foo&lt;/code&gt; 软件包，GHCi可以直接加载其 &lt;code&gt;libHSfoo.a&lt;/code&gt; 库，但也可以以已预先链接的单个 &lt;code&gt;HSfoo.o&lt;/code&gt; 文件的形式加载软件包。加载 &lt;code&gt;.o&lt;/code&gt; 文件的速度稍快一些，但要以拥有另一个已编译包的副本为代价。经验法则是，如果使用&lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; &lt;/a&gt; &lt;code&gt;HSfoo.o&lt;/code&gt; 编译软件包的模块，则构建HSfoo.o是值得的，因为它可以节省将软件包加载到GHCi中的时间。不使用&lt;a href=&quot;phases#ghc-flag--split-objs&quot;&gt; &lt;code&gt;-split-objs&lt;/code&gt; 时&lt;/a&gt;， &lt;code&gt;.o&lt;/code&gt; 和 &lt;code&gt;.a&lt;/code&gt; 库之间的加载时间差异不大，因此最好保留磁盘空间并仅保留 &lt;code&gt;.a&lt;/code&gt; 周围。在GHC发行版中，我们为除GHC软件包本身以外的大多数软件包提供 &lt;code&gt;.o&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d2e3260144403e14ad423568ae3ce8f12c1a164c" translate="yes" xml:space="preserve">
          <source>To make an executable program, the GHC system compiles your code and then links it with a non-trivial runtime system (RTS), which handles storage management, thread scheduling, profiling, and so on.</source>
          <target state="translated">为了制作一个可执行的程序,GHC系统会编译你的代码,然后将其与一个非平凡的运行时系统(RTS)联系起来,处理存储管理、线程调度、剖析等。</target>
        </trans-unit>
        <trans-unit id="409b50b71b1cf04f14989a6bebb5d1b08c15a045" translate="yes" xml:space="preserve">
          <source>To make life slightly easier, the GHCi prompt also behaves as if there is an implicit &lt;code&gt;import qualified&lt;/code&gt; declaration for every module in every package, and every module currently loaded into GHCi. This behaviour can be disabled with the &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; flag.</source>
          <target state="translated">为了使生活更轻松一些，GHCi提示的行为也好像每个包中的每个模块以及当前加载到GHCi中的每个模块都有一个隐含的 &lt;code&gt;import qualified&lt;/code&gt; 声明。可以使用 &lt;code&gt;-fno-implicit-import-qualified&lt;/code&gt; 标志禁用此行为。</target>
        </trans-unit>
        <trans-unit id="f3811e1546e787ed220aa8285f2fd305ece22386" translate="yes" xml:space="preserve">
          <source>To make this more robust, GHC has a notion of deriving strategies, which allow the user to explicitly request which approach to use when deriving an instance. To enable this feature, one must enable the &lt;a href=&quot;#extension-DerivingStrategies&quot;&gt;&lt;code&gt;DerivingStrategies&lt;/code&gt;&lt;/a&gt; language extension. A deriving strategy can be specified in a deriving clause</source>
          <target state="translated">为了使它更可靠，GHC拥有派生策略的概念，该策略允许用户在派生实例时明确要求使用哪种方法。要启用此功能，必须启用&lt;a href=&quot;#extension-DerivingStrategies&quot;&gt; &lt;code&gt;DerivingStrategies&lt;/code&gt; &lt;/a&gt;语言扩展。可以在派生子句中指定派生策略</target>
        </trans-unit>
        <trans-unit id="b64615441fb8a751e6636d849ab82db0727aa6e0" translate="yes" xml:space="preserve">
          <source>To make use of the profiling system &lt;em&gt;all&lt;/em&gt; modules must be compiled and linked with the &lt;a href=&quot;#ghc-flag--prof&quot;&gt;&lt;code&gt;-prof&lt;/code&gt;&lt;/a&gt; option. Any &lt;code&gt;SCC&lt;/code&gt; annotations you&amp;rsquo;ve put in your source will spring to life.</source>
          <target state="translated">要使用概要分析系统，必须编译&lt;em&gt;所有&lt;/em&gt;模块并使用&lt;a href=&quot;#ghc-flag--prof&quot;&gt; &lt;code&gt;-prof&lt;/code&gt; &lt;/a&gt;选项链接。您在源代码中添加的所有 &lt;code&gt;SCC&lt;/code&gt; 注释都将生效。</target>
        </trans-unit>
        <trans-unit id="cadd792349a4de388974151ed3334973779b0aae" translate="yes" xml:space="preserve">
          <source>To make use of these hidden fields, we need to create some helper functions:</source>
          <target state="translated">为了使用这些隐藏字段,我们需要创建一些辅助函数。</target>
        </trans-unit>
        <trans-unit id="8a354e65731baf61d210fdcef00d7fcaebe03d2c" translate="yes" xml:space="preserve">
          <source>To provide more control over the compiler&amp;rsquo;s verbosity, the &lt;code&gt;-v&lt;/code&gt; flag takes an optional numeric argument. Specifying &lt;code&gt;-v&lt;/code&gt; on its own is equivalent to &lt;code&gt;-v3&lt;/code&gt;, and the other levels have the following meanings:</source>
          <target state="translated">为了更好地控制编译器的详细程度， &lt;code&gt;-v&lt;/code&gt; 标志采用了一个可选的数字参数。 &lt;code&gt;-v3&lt;/code&gt; 指定 &lt;code&gt;-v&lt;/code&gt; 等效于-v3，其他级别具有以下含义：</target>
        </trans-unit>
        <trans-unit id="e09a1d373d13bfd1fe833239f80a4362b6548f69" translate="yes" xml:space="preserve">
          <source>To recover after an exception and do something else, the best choice is to use one of the &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; family.</source>
          <target state="translated">要在发生异常后恢复并执行其他操作，最好的选择是使用 &lt;code&gt;&lt;a href=&quot;control-exception#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; 家族之一。</target>
        </trans-unit>
        <trans-unit id="14e26ca731fed1a65d734c4805ba32c05da97880" translate="yes" xml:space="preserve">
          <source>To remove an existing directory symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要删除现有目录符号链接，请使用 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeDirectoryLink&quot;&gt;removeDirectoryLink&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="902b5e7fc39d15c95b3964399bd08b53ff7a117f" translate="yes" xml:space="preserve">
          <source>To remove an existing file symbolic link, use &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">要删除现有文件符号链接，请使用 &lt;code&gt;&lt;a href=&quot;system-directory#v:removeFile&quot;&gt;removeFile&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eb5610465d9a35f189f4445a996d1ae11b587c8" translate="yes" xml:space="preserve">
          <source>To safely use this API you must either extract the list of vertices directly from the graph or first call &lt;code&gt;vertexFromKey k&lt;/code&gt; to check if a vertex corresponds to the key &lt;code&gt;k&lt;/code&gt;. Once it is known that a vertex exists you can use &lt;code&gt;nodeFromVertex&lt;/code&gt; to access the labelled node and adjacent vertices. See below for examples.</source>
          <target state="translated">为了安全地使用此API，您必须直接从图形中提取顶点列表，或者首先调用 &lt;code&gt;vertexFromKey k&lt;/code&gt; 来检查顶点是否与键 &lt;code&gt;k&lt;/code&gt; 相对应。一旦知道顶点存在，就可以使用 &lt;code&gt;nodeFromVertex&lt;/code&gt; 来访问标记的节点和相邻的顶点。请参阅下面的示例。</target>
        </trans-unit>
        <trans-unit id="a5e1113a1ceca8ac3b9f3aacd5ed4c7c86f2fc6d" translate="yes" xml:space="preserve">
          <source>To see whether you&amp;rsquo;re making good use of all the memory reseverd for the allocation area (&lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;), look at the output of &lt;code&gt;+RTS -S&lt;/code&gt; and check whether the amount of memory allocated between GCs is equal to &lt;code&gt;-A&lt;/code&gt; times &lt;code&gt;-N&lt;/code&gt;. If not, there are two possible remedies: use &lt;code&gt;-n&lt;/code&gt; to set a nursery chunk size, or use &lt;code&gt;-AL&lt;/code&gt; to increase the limit for large objects.</source>
          <target state="translated">要查看您是否充分利用好所有的内存reseverd为分配区域（ &lt;code&gt;-A&lt;/code&gt; 次 &lt;code&gt;-N&lt;/code&gt; ），看看输出 &lt;code&gt;+RTS -S&lt;/code&gt; 并检查内存选区之间分配的量是否等于 &lt;code&gt;-A&lt;/code&gt; 次 &lt;code&gt;-N&lt;/code&gt; 。如果不是，则有两种可能的补救方法：使用 &lt;code&gt;-n&lt;/code&gt; 设置托儿所的块大小，或使用 &lt;code&gt;-AL&lt;/code&gt; 增大大对象的限制。</target>
        </trans-unit>
        <trans-unit id="7f2b1743b3c15e52d49c7a46f47317e7b211afa8" translate="yes" xml:space="preserve">
          <source>To see which modules are provided by a package use the &lt;code&gt;ghc-pkg&lt;/code&gt; command (see &lt;a href=&quot;#package-management&quot;&gt;Package management (the ghc-pkg command)&lt;/a&gt;):</source>
          <target state="translated">要查看软件包提供了哪些模块，请使用 &lt;code&gt;ghc-pkg&lt;/code&gt; 命令（请参阅&lt;a href=&quot;#package-management&quot;&gt;软件包管理（ghc-pkg命令）&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="0d20768e5351c559b7b7519dd0d6001dcac049eb" translate="yes" xml:space="preserve">
          <source>To see which packages are currently available, use the &lt;code&gt;ghc-pkg list&lt;/code&gt; command:</source>
          <target state="translated">要查看当前可用的软件包，请使用 &lt;code&gt;ghc-pkg list&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="a70566dabf5a41f2019632020db79dab54902519" translate="yes" xml:space="preserve">
          <source>To see why a data type with a contravariant occurrence of its last type parameter cannot have a derived &lt;code&gt;Functor&lt;/code&gt; instance, let&amp;rsquo;s suppose that a &lt;code&gt;Functor ContraFun1&lt;/code&gt; instance exists. The implementation would look something like this:</source>
          <target state="translated">要了解为什么最后一个类型参数发生反变的数据类型不能具有派生的 &lt;code&gt;Functor&lt;/code&gt; 实例，我们假设存在 &lt;code&gt;Functor ContraFun1&lt;/code&gt; 实例。实现看起来像这样：</target>
        </trans-unit>
        <trans-unit id="1dd1e599c7b99d0ef6415d16c2b63820670b8ef4" translate="yes" xml:space="preserve">
          <source>To serialise a custom type, an instance of Binary for that type is required. For example, suppose we have a data structure:</source>
          <target state="translated">要序列化一个自定义类型,需要一个该类型的Binary实例。例如,假设我们有一个数据结构。</target>
        </trans-unit>
        <trans-unit id="ec5ac163ebb0f97a307be294a6581754c5f32393" translate="yes" xml:space="preserve">
          <source>To serialise this to a bytestring, we use &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt;, which packs the data structure into a binary format, in a lazy bytestring</source>
          <target state="translated">要将其序列化为字节串，我们使用 &lt;code&gt;&lt;a href=&quot;data-binary#v:encode&quot;&gt;encode&lt;/a&gt;&lt;/code&gt; ，它以惰性字节串的形式将数据结构打包为二进制格式</target>
        </trans-unit>
        <trans-unit id="8c4bb74fa2bda9539f0db58684ace13bfcd04704" translate="yes" xml:space="preserve">
          <source>To set a package&amp;rsquo;s trust property in the package database please refer to &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;.</source>
          <target state="translated">要在软件包数据库中设置软件包的信任属性，请参阅&lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a25ac21c6d3b62631dd08b42b9fae80c8727be0" translate="yes" xml:space="preserve">
          <source>To skip to the first occurence of a string:</source>
          <target state="translated">跳到一个字符串的第一次出现。</target>
        </trans-unit>
        <trans-unit id="edb758d0d6990d34bd2a170aea31bb2ebe72017b" translate="yes" xml:space="preserve">
          <source>To solve such concern, the references provided by this module offer a key that can be used to locate the values on each process. Each process maintains a global table of references which can be looked up with a given key. This table is known as the Static Pointer Table. The reference can then be dereferenced to obtain the value.</source>
          <target state="translated">为了解决这样的问题,本模块提供的引用提供了一个键,可以用来定位每个进程的值。每个进程都维护着一个全局的引用表,可以用给定的键进行查找。这个表被称为静态指针表。然后可以对该引用进行反引用以获得值。</target>
        </trans-unit>
        <trans-unit id="f9c68944d2e59e0a66846b50f57d32b2ca1f9acb" translate="yes" xml:space="preserve">
          <source>To solve this, GHC provides a single type-level function,</source>
          <target state="translated">为了解决这个问题,GHC提供了一个单一的类型级函数。</target>
        </trans-unit>
        <trans-unit id="bf25b9f1720e9ac7d0d7fdd7aee2f1ed9e0566fe" translate="yes" xml:space="preserve">
          <source>To start with an example, suppose you had a module &lt;code&gt;A&lt;/code&gt; which made use of some string operations. Using normal module imports, you would only be able to pick a particular implementation of strings:</source>
          <target state="translated">首先，假设您有一个使用一些字符串操作的模块 &lt;code&gt;A&lt;/code&gt; 。使用普通的模块导入，您将只能选择特定的字符串实现：</target>
        </trans-unit>
        <trans-unit id="89c4479e20c71a25f4dfb43028231f4a734bfcce" translate="yes" xml:space="preserve">
          <source>To take the parts of a string before a delimiter:</source>
          <target state="translated">取字符串中定界符前的部分。</target>
        </trans-unit>
        <trans-unit id="e0c0e5556db2e9b3b7a23b8b7d2d49b51aa44349" translate="yes" xml:space="preserve">
          <source>To the programmer, Concurrent Haskell introduces no new language constructs; rather, it appears simply as a library, &lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;. The functions exported by this library include:</source>
          <target state="translated">对程序员而言，Concurrent Haskell没有引入任何新的语言构造；而是简单地显示为&lt;a href=&quot;../libraries/base-4.13.0.0/control-concurrent&quot;&gt;Control.Concurrent&lt;/a&gt;库。该库导出的功能包括：</target>
        </trans-unit>
        <trans-unit id="23874375ac3170d79af0c71d4f8ee2bec3a32884" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;+RTS&lt;/code&gt; flags with &lt;code&gt;hs_init()&lt;/code&gt;, we have to modify the example slightly. By default, GHC&amp;rsquo;s RTS will only accept &amp;ldquo;safe&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; flags (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), and the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; link-time flag overrides this. However, &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; has no effect when &lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt;&lt;code&gt;-no-hs-main&lt;/code&gt;&lt;/a&gt; is in use (and the same goes for &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt;). To set these options we have to call a GHC-specific API instead of &lt;code&gt;hs_init()&lt;/code&gt;:</source>
          <target state="translated">要将 &lt;code&gt;+RTS&lt;/code&gt; 标志与 &lt;code&gt;hs_init()&lt;/code&gt; 结合使用，我们必须对示例进行一些修改。默认情况下，GHC的RTS仅接受&amp;ldquo;安全&amp;rdquo; &lt;code&gt;+RTS&lt;/code&gt; 标志（请参阅&lt;a href=&quot;phases#options-linker&quot;&gt;影响链接的选项&lt;/a&gt;），而 &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 链接时标志将覆盖此设置。但是，当使用&lt;a href=&quot;phases#ghc-flag--no-hs-main&quot;&gt; &lt;code&gt;-no-hs-main&lt;/code&gt; &lt;/a&gt;时， &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; 无效（并且 &lt;code&gt;-with-rtsopts=⟨opts⟩&lt;/code&gt; ）。要设置这些选项，我们必须调用特定于GHC的API而不是 &lt;code&gt;hs_init()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c832a5995effff9df59220a2bd9f7e56cfb4614f" translate="yes" xml:space="preserve">
          <source>To use an extended and very rich family of functions for working with Unicode text (including normalization, regular expressions, non-standard encodings, text breaking, and locales), see the &lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu package&lt;/a&gt;.</source>
          <target state="translated">要使用扩展的功能丰富的函数家族来处理Unicode文本（包括规范化，正则表达式，非标准编码，文本中断和语言环境），请参阅&lt;a href=&quot;http://hackage.haskell.org/package/text-icu&quot;&gt;text-icu包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b96ac2af089bcd3267331bb1501aa1e1d197309c" translate="yes" xml:space="preserve">
          <source>To use relative paths for dependent libraries on Linux and Solaris you can pass a suitable &lt;code&gt;-rpath&lt;/code&gt; flag to the linker:</source>
          <target state="translated">要将相对路径用于Linux和Solaris上的依赖库，可以将适当的 &lt;code&gt;-rpath&lt;/code&gt; 标志传递给链接器：</target>
        </trans-unit>
        <trans-unit id="7f309e398fff568b18e392785bde202981de0be5" translate="yes" xml:space="preserve">
          <source>To use this equality in practice, pattern-match on the &lt;code&gt;Coercion a b&lt;/code&gt; to get out the &lt;code&gt;Coercible a b&lt;/code&gt; instance, and then use &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; to apply it.</source>
          <target state="translated">要在实践中这种平等，在模式匹配 &lt;code&gt;Coercion a b&lt;/code&gt; 走出 &lt;code&gt;Coercible a b&lt;/code&gt; 实例，然后使用 &lt;code&gt;&lt;a href=&quot;data-coerce#v:coerce&quot;&gt;coerce&lt;/a&gt;&lt;/code&gt; 应用它。</target>
        </trans-unit>
        <trans-unit id="3aa17a9e79c9dcc3ca39fe2b79ee583cccf33fc4" translate="yes" xml:space="preserve">
          <source>To use tracing, evaluate an expression with the &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt; command. For example, if we set a breakpoint on the base case of &lt;code&gt;qsort&lt;/code&gt;:</source>
          <target state="translated">要使用跟踪，请使用&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;命令评估表达式。例如，如果我们在 &lt;code&gt;qsort&lt;/code&gt; 的基本情况下设置断点：</target>
        </trans-unit>
        <trans-unit id="efc675a1383ace97e3c2b8987f540eb58b6ceef5" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the documentation of the valid hole fits in the output.</source>
          <target state="translated">切換是否在輸出中顯示有效孔配合的文件。</target>
        </trans-unit>
        <trans-unit id="332b4115b5fb01dc68e2b60acec1f7d2ed0f11c6" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the provenance of the valid hole fits in the output.</source>
          <target state="translated">切換是否在輸出中顯示有效孔配合的來源。</target>
        </trans-unit>
        <trans-unit id="a7f408bf113ca084f529db4badbce821ff390f15" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type application of the valid hole fits in the output.</source>
          <target state="translated">切换是否在输出中显示有效孔配合的类型应用。</target>
        </trans-unit>
        <trans-unit id="2c4d22b7c838a1ecfb6276f53708bb0e679bc1f9" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the additional holes in refinement hole fits.</source>
          <target state="translated">切换是否显示细化孔配合的附加孔的类型。</target>
        </trans-unit>
        <trans-unit id="04756312abbe3334230e9fe9c79fe06f08cf1ef4" translate="yes" xml:space="preserve">
          <source>Toggles whether to show the type of the valid hole fits in the output.</source>
          <target state="translated">切換是否在輸出中顯示有效孔配合的類型。</target>
        </trans-unit>
        <trans-unit id="f88544b7c345be9bc6286319d7234499cb7a2281" translate="yes" xml:space="preserve">
          <source>Toggles whether to show what type each quantified variable takes in a valid hole fit.</source>
          <target state="translated">切换是否显示每个量化变量在有效洞拟合中的类型。</target>
        </trans-unit>
        <trans-unit id="8d4022d64adedc28fae75a3f895c4e8da81cd40c" translate="yes" xml:space="preserve">
          <source>Token pretty-printing function.</source>
          <target state="translated">Token pretty-printing功能。</target>
        </trans-unit>
        <trans-unit id="daef2147e79571af8d5a4f376f29fb535295e66d" translate="yes" xml:space="preserve">
          <source>TokenParser</source>
          <target state="translated">TokenParser</target>
        </trans-unit>
        <trans-unit id="de9a588a8ad015eb8d4acc3d2eccb5cd88ff7637" translate="yes" xml:space="preserve">
          <source>Top-level declaration splices break up a source file into &lt;em&gt;declaration groups&lt;/em&gt;. A &lt;em&gt;declaration group&lt;/em&gt; is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</source>
          <target state="translated">顶级声明拼接将源文件分成&lt;em&gt;声明组&lt;/em&gt;。一个&lt;em&gt;声明组&lt;/em&gt;是组由顶级声明拼接创建声明，再加上那些跟随它，一直到但不包括下一个顶级声明拼接。注意，仅顶级拼接符定义声明组，而不是表达式拼接符。模块中的第一个声明组包括所有顶级定义，但不包括第一个顶级声明拼接。</target>
        </trans-unit>
        <trans-unit id="64e70a05233381ae9b755ec9cdc13f4a77ee5cb1" translate="yes" xml:space="preserve">
          <source>Total CPU time (at the previous GC)</source>
          <target state="translated">总的CPU时间(上一次GC时)</target>
        </trans-unit>
        <trans-unit id="8386f73231e1e92e73f6b519f210511ca9193151" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the GC</source>
          <target state="translated">GC使用的CPU总时间</target>
        </trans-unit>
        <trans-unit id="042e7e784ddb44e360a337daa72b2ae8ba023cf1" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the init phase @since 4.12.0.0</source>
          <target state="translated">自4.12.0.0起,初始化阶段所使用的CPU时间总量</target>
        </trans-unit>
        <trans-unit id="d2dd5d438fb3dcc8fdc1f04bf55f6d2c501879d3" translate="yes" xml:space="preserve">
          <source>Total CPU time used by the mutator</source>
          <target state="translated">突变器使用的CPU总时间</target>
        </trans-unit>
        <trans-unit id="cd8f3ebd1cb51ba0810348d6c47b2fdc351d6519" translate="yes" xml:space="preserve">
          <source>Total amount of data copied during this GC</source>
          <target state="translated">本次GC期间复制的数据总量</target>
        </trans-unit>
        <trans-unit id="9735e288f821d32fcba71a1a70c14b5cdc350199" translate="yes" xml:space="preserve">
          <source>Total amount of live data in compact regions</source>
          <target state="translated">紧凑区域的实时数据总量</target>
        </trans-unit>
        <trans-unit id="490b2f80ac8821885d90f86d57b7974bbf2682ad" translate="yes" xml:space="preserve">
          <source>Total amount of live data in large objects</source>
          <target state="translated">大型物体的实时数据总量</target>
        </trans-unit>
        <trans-unit id="e6b177b175f265fd062fef05a1277c622c233454" translate="yes" xml:space="preserve">
          <source>Total amount of live data in the heap (incliudes large + compact data). Updated after every GC. Data in uncollected generations (in minor GCs) are considered live.</source>
          <target state="translated">堆中的实时数据总量(包括大数据+小数据)。每次GC后更新。未收集的数据代数(在小GC中)被视为实时数据。</target>
        </trans-unit>
        <trans-unit id="2439e747cf079533fc119f7f3372deeb2e6b3e0c" translate="yes" xml:space="preserve">
          <source>Total amount of memory in use by the RTS</source>
          <target state="translated">RTS使用的内存总量。</target>
        </trans-unit>
        <trans-unit id="ae1cf3a5225a7fa4703cee57bd8a99cfbdc1fa37" translate="yes" xml:space="preserve">
          <source>Total amount of slop (wasted memory)</source>
          <target state="translated">泔水总量(浪费内存)</target>
        </trans-unit>
        <trans-unit id="381d3d3026564b15b98332086f85db8c9c5116c1" translate="yes" xml:space="preserve">
          <source>Total bytes allocated</source>
          <target state="translated">分配的字节总数</target>
        </trans-unit>
        <trans-unit id="7ddb5932284e85cdb998a88ee61c45b3fb084550" translate="yes" xml:space="preserve">
          <source>Total elapsed time (at the previous GC)</source>
          <target state="translated">总耗时(上一次GC时)</target>
        </trans-unit>
        <trans-unit id="5176bda3a891825313e991007cfcf6a2dfe321e1" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the GC</source>
          <target state="translated">气相色谱仪使用的总时间</target>
        </trans-unit>
        <trans-unit id="a76b13b30e1f96d1561f8aba9418764cdf896ec9" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the init phase @since 4.12.0.0</source>
          <target state="translated">自4.12.0.0起,启动阶段使用的总时间。</target>
        </trans-unit>
        <trans-unit id="f8dffa4e4bface78bbc47de7cc9c4f635615fd39" translate="yes" xml:space="preserve">
          <source>Total elapsed time used by the mutator</source>
          <target state="translated">突变器使用的总时间。</target>
        </trans-unit>
        <trans-unit id="c702e8f0d2bf491124a83b3aba7ca49be01b7437" translate="yes" xml:space="preserve">
          <source>Total number of GCs</source>
          <target state="translated">理事会成员总数</target>
        </trans-unit>
        <trans-unit id="f31fc901ada0fd73f4d6d8746668c45f8b841486" translate="yes" xml:space="preserve">
          <source>Total number of major (oldest generation) GCs</source>
          <target state="translated">主要(最老一代)理事会成员总数</target>
        </trans-unit>
        <trans-unit id="5d0fb43e49fcfea4980958defc073241b65ca7be" translate="yes" xml:space="preserve">
          <source>Total width of the field.</source>
          <target state="translated">场地的总宽度。</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="26f445c1d8b2f4e101fdf56e72eb92189d409de2" translate="yes" xml:space="preserve">
          <source>Trace exhaustiveness checker</source>
          <target state="translated">追踪用尽检查器</target>
        </trans-unit>
        <trans-unit id="8d94ec6e077733db6938cd196aa7260c918b123b" translate="yes" xml:space="preserve">
          <source>Trace interface files</source>
          <target state="translated">跟踪接口文件</target>
        </trans-unit>
        <trans-unit id="fdbe7d47032190e46bbad6a5b35e468fcdd74e5e" translate="yes" xml:space="preserve">
          <source>Trace renamer</source>
          <target state="translated">跟踪重命名器</target>
        </trans-unit>
        <trans-unit id="b6912fb740cfa5def4327273bd86af0baeb5f9b4" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference</source>
          <target state="translated">跟踪运行时类型推断</target>
        </trans-unit>
        <trans-unit id="ea97ebbaf9290aacc9db9230d7d8410a1b17dde1" translate="yes" xml:space="preserve">
          <source>Trace runtime type inference done by various interpreter commands.</source>
          <target state="translated">跟踪各种解释器命令所做的运行时类型推断。</target>
        </trans-unit>
        <trans-unit id="918226cc8c88c96d88772b200fb277ce2462c0b2" translate="yes" xml:space="preserve">
          <source>Trace typechecker</source>
          <target state="translated">验字机跟踪</target>
        </trans-unit>
        <trans-unit id="cac5cce622b33dcb41c89b31f1cab4a7d79e4ee1" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Mix</source>
          <target state="translated">Trace.Hpc.Mix</target>
        </trans-unit>
        <trans-unit id="4dc37d38ccb40ad731bd6b735a3d79a901047644" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Tix</source>
          <target state="translated">Trace.Hpc.Tix</target>
        </trans-unit>
        <trans-unit id="b9911dc4ca5e0e643713d12b25be14491d441daa" translate="yes" xml:space="preserve">
          <source>Trace.Hpc.Util</source>
          <target state="translated">Trace.Hpc.Util</target>
        </trans-unit>
        <trans-unit id="0ce5cee6755ef940551826d010c5c2ba3528d3db" translate="yes" xml:space="preserve">
          <source>TraceEventLog</source>
          <target state="translated">TraceEventLog</target>
        </trans-unit>
        <trans-unit id="8255bba6a712a935f53931169349c3bf3667e4e7" translate="yes" xml:space="preserve">
          <source>TraceFlags</source>
          <target state="translated">TraceFlags</target>
        </trans-unit>
        <trans-unit id="f45cd5da920597cccb919c43b85883e95c0eb5ba" translate="yes" xml:space="preserve">
          <source>TraceNone</source>
          <target state="translated">TraceNone</target>
        </trans-unit>
        <trans-unit id="95797df6040c41d1f62d4c30f5d575a3fde2b6e0" translate="yes" xml:space="preserve">
          <source>TraceStderr</source>
          <target state="translated">TraceStderr</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="ee76b0788bcc9e4d134c6e63c0f905595d53f415" translate="yes" xml:space="preserve">
          <source>Traditional record syntax, such as &lt;code&gt;C {f = x}&lt;/code&gt;, is enabled by default. To disable it, you can use the &lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt;&lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">默认情况下启用传统记录语法，例如 &lt;code&gt;C {f = x}&lt;/code&gt; 。要禁用它，可以使用&lt;a href=&quot;#extension-NoTraditionalRecordSyntax&quot;&gt; &lt;code&gt;NoTraditionalRecordSyntax&lt;/code&gt; &lt;/a&gt;扩展名。</target>
        </trans-unit>
        <trans-unit id="e945a1a9931ffbae11e35d8dc13f62ffcd7e4996" translate="yes" xml:space="preserve">
          <source>TraditionalRecordSyntax</source>
          <target state="translated">TraditionalRecordSyntax</target>
        </trans-unit>
        <trans-unit id="07d54591052808d7665525ab9d03e9a8e6047941" translate="yes" xml:space="preserve">
          <source>Trailing slash functions</source>
          <target state="translated">尾部斜杠功能</target>
        </trans-unit>
        <trans-unit id="5a701b108c7ddd010bd4e5e1046abd3e059fbfcd" translate="yes" xml:space="preserve">
          <source>Transactional variables.</source>
          <target state="translated">交易型变量。</target>
        </trans-unit>
        <trans-unit id="c6bd77f69d4cdf801791ad51b3a5613597cd452f" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用给定的函数（ &lt;code&gt;&lt;a href=&quot;control-monad-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 的特殊化）来转换由计算引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="aefaf0cd8aa07449321af97629ce4b3770e62358" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function (a specialization of &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用给定的函数（ &lt;code&gt;&lt;a href=&quot;control-monad-trans-except#v:withExceptT&quot;&gt;withExceptT&lt;/a&gt;&lt;/code&gt; 的特殊化）来转换由计算引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="a4e682fcac2a4512b74e3dc63612d9586743f8e8" translate="yes" xml:space="preserve">
          <source>Transform any exceptions thrown by the computation using the given function.</source>
          <target state="translated">转变任何使用给定函数的计算抛出的异常。</target>
        </trans-unit>
        <trans-unit id="4578ae8d733586d0310337c8b520cee638a41571" translate="yes" xml:space="preserve">
          <source>Transform comprehensions</source>
          <target state="translated">转变理解力</target>
        </trans-unit>
        <trans-unit id="6d9379f1a17e7f9d27b049266346529304db629e" translate="yes" xml:space="preserve">
          <source>Transform statements (as with &lt;a href=&quot;#extension-TransformListComp&quot;&gt;&lt;code&gt;TransformListComp&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">转换语句（与&lt;a href=&quot;#extension-TransformListComp&quot;&gt; &lt;code&gt;TransformListComp&lt;/code&gt; 一样&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="34bbbf0593112d8021164739182249451cd348ed" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;MaybeT&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;MaybeT&lt;/code&gt; 内部转换计算。</target>
        </trans-unit>
        <trans-unit id="8e3add4bdcd20865c3718142bc9551385a370674" translate="yes" xml:space="preserve">
          <source>Transform the computation inside a &lt;code&gt;ReaderT&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ReaderT&lt;/code&gt; 内部转换计算。</target>
        </trans-unit>
        <trans-unit id="d94f891243caad66af3028997e36082e6d8dd8dc" translate="yes" xml:space="preserve">
          <source>Transform the value returned by a &lt;code&gt;Reader&lt;/code&gt;.</source>
          <target state="translated">转换 &lt;code&gt;Reader&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="529ddea17b3a6fb911dfd08011006b0a6dba6150" translate="yes" xml:space="preserve">
          <source>TransformListComp</source>
          <target state="translated">TransformListComp</target>
        </trans-unit>
        <trans-unit id="28382f411cec0cea1fa0d72a330aaf42ace1a9fe" translate="yes" xml:space="preserve">
          <source>Transformation of at least one immediate subterm does not fail</source>
          <target state="translated">至少一个直属子项的转化不会失败。</target>
        </trans-unit>
        <trans-unit id="6553c0c77ccd33d074aee1942550fc0f472cd3f4" translate="yes" xml:space="preserve">
          <source>Transformation of one immediate subterm with success</source>
          <target state="translated">转型成功的一个直属子任期</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="bc40fc64b9787d7dac7665e7c80ced3be2f64e6a" translate="yes" xml:space="preserve">
          <source>Transformer class</source>
          <target state="translated">变压器类</target>
        </trans-unit>
        <trans-unit id="12656556988bc57237e887a0b3bd66131be270a9" translate="yes" xml:space="preserve">
          <source>Transforming ByteStrings</source>
          <target state="translated">转换ByteStrings</target>
        </trans-unit>
        <trans-unit id="64733f4060672520e5c156055aa404b5a2fff0ad" translate="yes" xml:space="preserve">
          <source>Transforms a parser into one that does the same, but in addition returns the exact characters read. IMPORTANT NOTE: &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; gives a runtime error if its first argument is built using any occurrences of readS_to_P.</source>
          <target state="translated">将解析器转换为可以执行相同操作的解析器，但另外还返回读取的确切字符。重要提示： &lt;code&gt;&lt;a href=&quot;text-parsercombinators-readp#v:gather&quot;&gt;gather&lt;/a&gt;&lt;/code&gt; 当第一个参数是用readS_to_P任何出现建给出了一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="8f321ea579e546977788ec7503fb201f9808151b" translate="yes" xml:space="preserve">
          <source>Transitional module providing the &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; class and primitive instances.</source>
          <target state="translated">提供 &lt;code&gt;&lt;a href=&quot;control-monad-fail#t:MonadFail&quot;&gt;MonadFail&lt;/a&gt;&lt;/code&gt; 类和原始实例的过渡模块。</target>
        </trans-unit>
        <trans-unit id="cf6c281c3321c220a2860f225e26547c6663a008" translate="yes" xml:space="preserve">
          <source>Transitivity</source>
          <target state="translated">Transitivity</target>
        </trans-unit>
        <trans-unit id="7bd7baf126db335320e85434af814c47329f4fb9" translate="yes" xml:space="preserve">
          <source>Transitivity of equality</source>
          <target state="translated">平等性的转换</target>
        </trans-unit>
        <trans-unit id="ee21a36234c54ae6acecacce32dde8221553c2ab" translate="yes" xml:space="preserve">
          <source>Transitivity of representational equality</source>
          <target state="translated">表征性平等的转换</target>
        </trans-unit>
        <trans-unit id="e98e003d090d824a54f132e10d2d3a1b2abb08a4" translate="yes" xml:space="preserve">
          <source>TransliterateCodingFailure</source>
          <target state="translated">TransliterateCodingFailure</target>
        </trans-unit>
        <trans-unit id="9dcc95f8a9883fb6fa511276e0d2f0bd822f6472" translate="yes" xml:space="preserve">
          <source>TransmitStart</source>
          <target state="translated">TransmitStart</target>
        </trans-unit>
        <trans-unit id="d2cf87c31932f3da157ec8f3b86b864b9e7f88fd" translate="yes" xml:space="preserve">
          <source>TransmitStop</source>
          <target state="translated">TransmitStop</target>
        </trans-unit>
        <trans-unit id="59ababde52e8e86da31349f66a50ec3bb7819a93" translate="yes" xml:space="preserve">
          <source>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See &lt;a href=&quot;#tracing&quot;&gt;Tracing and history&lt;/a&gt; for more about GHCi&amp;rsquo;s debugging facilities. See also: &lt;a href=&quot;#ghci-cmd-:trace&quot;&gt;&lt;code&gt;:trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:history&quot;&gt;&lt;code&gt;:history&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ghci-cmd-:forward&quot;&gt;&lt;code&gt;:forward&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">向后追溯历史上的步骤。omittedn如果省略则为1。有关GHCi调试工具的更多信息，请参见&lt;a href=&quot;#tracing&quot;&gt;跟踪和历史记录&lt;/a&gt;。另请参阅&lt;a href=&quot;#ghci-cmd-:trace&quot;&gt; &lt;code&gt;:trace&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:history&quot;&gt; &lt;code&gt;:history&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#ghci-cmd-:forward&quot;&gt; &lt;code&gt;:forward&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b795f17232474b10e4eb05eb081a307e9d9dfa5d" translate="yes" xml:space="preserve">
          <source>Traversable</source>
          <target state="translated">Traversable</target>
        </trans-unit>
        <trans-unit id="9c8ab9d8f52e3cebde865983061e92e1572d8906" translate="yes" xml:space="preserve">
          <source>Traversal</source>
          <target state="translated">Traversal</target>
        </trans-unit>
        <trans-unit id="7b1817a217845dfc3e24c8c230b82767b4c56356" translate="yes" xml:space="preserve">
          <source>Traverse from right to left.</source>
          <target state="translated">从右往左穿越。</target>
        </trans-unit>
        <trans-unit id="977ae6d655ca9f1978129e8ccbfa10a6559b3561" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">遍历其他映射中缺少键的条目，可以选择生成值以放入结果中。这是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;最有效的策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="5e48e3b92b1820252cbfde816e12e1a271b17cb1" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">遍历其他映射中缺少键的条目，可以选择生成值以放入结果中。这是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-intmap-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;最有效的策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="b18e053b42f93b44a5abf294af55c3136c4f408d" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">遍历其他映射中缺少键的条目，可以选择生成值以放入结果中。这是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-lazy#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;最有效的策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="7200db17563eaefb9847d8db2d6e8155f2a4676c" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map, optionally producing values to put in the result. This is the most powerful &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; tactic, but others are usually more efficient.</source>
          <target state="translated">遍历其他映射中缺少键的条目，可以选择生成值以放入结果中。这是&amp;ldquo; &lt;code&gt;&lt;a href=&quot;data-map-merge-strict#t:WhenMissing&quot;&gt;WhenMissing&lt;/a&gt;&lt;/code&gt; &amp;rdquo;最有效的策略，但其他方法通常效率更高。</target>
        </trans-unit>
        <trans-unit id="d03af00b13b95140684e72553fba4a01106b42c9" translate="yes" xml:space="preserve">
          <source>Traverse over the entries whose keys are missing from the other map.</source>
          <target state="translated">遍历其他地图中缺少键的条目。</target>
        </trans-unit>
        <trans-unit id="30dc152103c6133db322f634f929327d30f349a1" translate="yes" xml:space="preserve">
          <source>Traverses in order of increasing key.</source>
          <target state="translated">按增加键的顺序遍历。</target>
        </trans-unit>
        <trans-unit id="7e92b229a11c1c4e925555ecc443d546f7203f39" translate="yes" xml:space="preserve">
          <source>Treat &lt;code&gt;*&lt;/code&gt; as &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;*&lt;/code&gt; 视为 &lt;code&gt;Data.Kind.Type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd46d6f300df9c79faeae4e756e06e57fe755cd8" translate="yes" xml:space="preserve">
          <source>Treat the unqualified uses of the &lt;code&gt;*&lt;/code&gt; type operator as nullary and desugar to &lt;code&gt;Data.Kind.Type&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;*&lt;/code&gt; 类型运算符的不合格使用视为空值， &lt;code&gt;Data.Kind.Type&lt;/code&gt; 进行降糖。</target>
        </trans-unit>
        <trans-unit id="99f5ff6378a0b48f815677894306b090ee036726" translate="yes" xml:space="preserve">
          <source>Tree</source>
          <target state="translated">Tree</target>
        </trans-unit>
        <trans-unit id="1e7081d736f43ad30574ac906d26acdd03c38ed9" translate="yes" xml:space="preserve">
          <source>Trees</source>
          <target state="translated">Trees</target>
        </trans-unit>
        <trans-unit id="d6ebaccbb7b2994140dcf46fc8cbd5a71b52292c" translate="yes" xml:space="preserve">
          <source>Trees and Forests</source>
          <target state="translated">树木和森林</target>
        </trans-unit>
        <trans-unit id="d1f88855d73f9050543090a479c62b476a835f18" translate="yes" xml:space="preserve">
          <source>Tried to encode a character that could not be represented under the given encoding, or ran out of input in mid-encode.</source>
          <target state="translated">试图对一个在给定编码下无法表示的字符进行编码,或者在编码过程中耗尽了输入。</target>
        </trans-unit>
        <trans-unit id="dcf41f4658aee61513347d3d72256ba068f1cb3d" translate="yes" xml:space="preserve">
          <source>Tries to find the definition site of the name at the given source-code span, e.g.:</source>
          <target state="translated">试图在给定的源代码跨度中找到名称的定义点,例如:。</target>
        </trans-unit>
        <trans-unit id="6d6761d1d070e2158059fdae1344762916cfe5cd" translate="yes" xml:space="preserve">
          <source>Triggers an immediate major garbage collection.</source>
          <target state="translated">触发一个即时的主要垃圾收集。</target>
        </trans-unit>
        <trans-unit id="5211c258ae504b8bbd5a65143e1ffaccbfaf5d21" translate="yes" xml:space="preserve">
          <source>Triggers an immediate minor garbage collection.</source>
          <target state="translated">触发立即进行小型垃圾收集。</target>
        </trans-unit>
        <trans-unit id="97bfbacf53c224ce01bb87815c2b91e603df8ea4" translate="yes" xml:space="preserve">
          <source>Trigonometric and hyperbolic functions and related functions.</source>
          <target state="translated">三角函数和双曲函数及相关函数。</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="6842273367fb0a7314d3db77e80a4246de4d0209" translate="yes" xml:space="preserve">
          <source>True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &quot;compact all the time&quot;</source>
          <target state="translated">True &lt;a href=&quot;=&quot;&gt;=&lt;/a&gt; &amp;ldquo;始终紧凑&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ff0a01862c74c77c6757cf7463f92a3698aca6ec" translate="yes" xml:space="preserve">
          <source>Truncate the destination file and then copy the contents of the source file to the destination file. If the destination file already exists, its attributes shall remain unchanged. Otherwise, its attributes are reset to the defaults.</source>
          <target state="translated">截断目标文件,然后将源文件的内容复制到目标文件中。如果目标文件已经存在,它的属性将保持不变,否则,它的属性将被重置为默认值。否则,其属性将被重置为默认值。</target>
        </trans-unit>
        <trans-unit id="b645724bb0724739a37a0f389e05496a29a993a0" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; to least-significant &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;ghc-integer#t:Integer&quot;&gt;Integer&lt;/a&gt;&lt;/code&gt; 截断为最低有效的 &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4191815c130347968d06550006d8bef069d5483" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Double#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Double#&lt;/code&gt; 值截断为最接近的 &lt;code&gt;Int#&lt;/code&gt; 。如果截断（如果截断）产生的值超出 &lt;code&gt;Int#&lt;/code&gt; 的范围，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="7f6d495ffdebdce795d559dc7a00814f02a9ed4a" translate="yes" xml:space="preserve">
          <source>Truncates a &lt;code&gt;Float#&lt;/code&gt; value to the nearest &lt;code&gt;Int#&lt;/code&gt;. Results are undefined if the truncation if truncation yields a value outside the range of &lt;code&gt;Int#&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;Float#&lt;/code&gt; 值截断为最接近的 &lt;code&gt;Int#&lt;/code&gt; 。如果截断（如果截断）产生的值超出 &lt;code&gt;Int#&lt;/code&gt; 的范围，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="c24171999adb97c4a8f884ec45a305760feb8353" translate="yes" xml:space="preserve">
          <source>Truncates the file down to the specified length. If the file was larger than the given length before this operation was performed the extra is lost.</source>
          <target state="translated">将文件截断到指定长度。如果文件在执行此操作之前大于指定的长度,则会丢失多余的文件。</target>
        </trans-unit>
        <trans-unit id="4bc4bdf5385df47149206feaa36c849748d83b64" translate="yes" xml:space="preserve">
          <source>Trustworthy</source>
          <target state="translated">Trustworthy</target>
        </trans-unit>
        <trans-unit id="c3d3c6266583689c8044755f6755946b22e2e727" translate="yes" xml:space="preserve">
          <source>Try alternatives in the same order as &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">按照与 &lt;code&gt;f&lt;/code&gt; 相同的顺序尝试替代方法。</target>
        </trans-unit>
        <trans-unit id="649615639f9b9c6ba5bc23c5c62fdf483263edda" translate="yes" xml:space="preserve">
          <source>Try downcasting &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; value. Returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; if value doesn't fit in &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尝试将 &lt;code&gt;&lt;a href=&quot;ghc-natural#t:Natural&quot;&gt;Natural&lt;/a&gt;&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; 值。如果value不适合 &lt;code&gt;&lt;a href=&quot;data-word#t:Word&quot;&gt;Word&lt;/a&gt;&lt;/code&gt; ,则返回 &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f32a8bcb3ae56ab6fee54ca560a7075df79e35e" translate="yes" xml:space="preserve">
          <source>Try to use local disks when linking:</source>
          <target state="translated">链接时尽量使用本地磁盘。</target>
        </trans-unit>
        <trans-unit id="42e43b612a5dfae57ddf5929f0fb945ae83cbf61" translate="yes" xml:space="preserve">
          <source>Tuesday</source>
          <target state="translated">Tuesday</target>
        </trans-unit>
        <trans-unit id="0fae6c283b56ecb589a1f52cbd69ed8461516cd4" translate="yes" xml:space="preserve">
          <source>Tuple data constructor</source>
          <target state="translated">元组数据构造器</target>
        </trans-unit>
        <trans-unit id="fe995f3be3d2ff04b4539a5c33f7f5265c5ec905" translate="yes" xml:space="preserve">
          <source>Tuple type constructor</source>
          <target state="translated">元组类型构造函数</target>
        </trans-unit>
        <trans-unit id="f3571e8acb567c55596ec89e11c3c7590fcd1efb" translate="yes" xml:space="preserve">
          <source>Tuple types. When a non-unit tuple is used on the right-hand side of a data declaration, &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;DeriveFunctor&lt;/code&gt;&lt;/a&gt; treats it as a product of distinct types. In other words, the following code:</source>
          <target state="translated">元组类型。当在数据声明的右侧使用非单位元组时，&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;DeriveFunctor&lt;/code&gt; &lt;/a&gt;会将其视为不同类型的乘积。换句话说，以下代码：</target>
        </trans-unit>
        <trans-unit id="07bc188bc9976952fc0cc95ef067281f658cb805" translate="yes" xml:space="preserve">
          <source>TupleSections</source>
          <target state="translated">TupleSections</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="0090b6abe499cb5c3a21cf4b91f82b1dc060fb8b" translate="yes" xml:space="preserve">
          <source>Tuples are currently limited to size 100. However, standard instances for tuples (&lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;) are available &lt;em&gt;only&lt;/em&gt; up to 16-tuples.</source>
          <target state="translated">元组当前限于大小100。但是，元组的标准实例（ &lt;code&gt;Eq&lt;/code&gt; ， &lt;code&gt;Ord&lt;/code&gt; ， &lt;code&gt;Bounded&lt;/code&gt; ， &lt;code&gt;Ix&lt;/code&gt; ， &lt;code&gt;Read&lt;/code&gt; 和 &lt;code&gt;Show&lt;/code&gt; ）最多&lt;em&gt;只能&lt;/em&gt;使用16个元组。</target>
        </trans-unit>
        <trans-unit id="eb72a46d788e7aaf184a3a1b039183884ebc8ddf" translate="yes" xml:space="preserve">
          <source>Tuples, all of whose component types have kind &lt;code&gt;Constraint&lt;/code&gt;. So for example the type &lt;code&gt;(Show a, Ord a)&lt;/code&gt; is of kind &lt;code&gt;Constraint&lt;/code&gt;.</source>
          <target state="translated">元组，其所有组件类型都具有 &lt;code&gt;Constraint&lt;/code&gt; 类型。因此，例如类型 &lt;code&gt;(Show a, Ord a)&lt;/code&gt; 是 &lt;code&gt;Constraint&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="208297b00f068e5585208c000785f0fce4f36c23" translate="yes" xml:space="preserve">
          <source>Tuples, lists, &lt;code&gt;Maybe&lt;/code&gt;, and all the other types from &lt;code&gt;Prelude&lt;/code&gt; continue to have their existing, lazy, semantics.</source>
          <target state="translated">元组，列表， &lt;code&gt;Maybe&lt;/code&gt; 和 &lt;code&gt;Prelude&lt;/code&gt; 中的所有其他类型继续具有其现有的惰性语义。</target>
        </trans-unit>
        <trans-unit id="253a3d85a1beb3288a473dc352f001b3960133ba" translate="yes" xml:space="preserve">
          <source>Turn &lt;em&gt;off&lt;/em&gt; &amp;ldquo;update-frame squeezing&amp;rdquo; at garbage-collection time. (There&amp;rsquo;s no particularly good reason to turn it off, except to ensure the accuracy of certain data collected regarding thunk entry counts.)</source>
          <target state="translated">关闭&lt;em&gt;关闭&lt;/em&gt; &amp;ldquo;更新帧挤压&amp;rdquo;在垃圾收集时间。（没有特别好的理由将其关闭，除了确保有关thunk条目计数的某些数据的准确性。）</target>
        </trans-unit>
        <trans-unit id="46ed6208974a650db0bd1f82cc0c70d6411a0c0e" translate="yes" xml:space="preserve">
          <source>Turn a &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; into its initial &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; 转换为其初始的 &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="99920f5c3b939caebceea45731d8b9d3427458f2" translate="yes" xml:space="preserve">
          <source>Turn a value into a Template Haskell expression, suitable for use in a splice.</source>
          <target state="translated">将一个值变成一个模板 Haskell 表达式,适合在拼接中使用。</target>
        </trans-unit>
        <trans-unit id="18c10b159949d028b9e59ba53a57b08c8fed29bf" translate="yes" xml:space="preserve">
          <source>Turn an existing Handle into a file descriptor. This function throws an IOError if the Handle does not reference a file descriptor.</source>
          <target state="translated">将一个现有的Handle变成一个文件描述符。如果Handle没有引用文件描述符,该函数会引发一个IOError。</target>
        </trans-unit>
        <trans-unit id="ff88efd554e6e2bbf0d6b57ed109bd14bff32a19" translate="yes" xml:space="preserve">
          <source>Turn an existing file descriptor into a Handle. This is used by various external libraries to make Handles.</source>
          <target state="translated">将一个现有的文件描述符变成一个Handle。这被各种外部库用来制作Handle。</target>
        </trans-unit>
        <trans-unit id="af1ea6cee0d8a6d561bf79d4ae3fe34c934b40bb" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining</source>
          <target state="translated">关闭预衬线</target>
        </trans-unit>
        <trans-unit id="d635f6906b908f74109d28ae4ecba3d5b4cf43a2" translate="yes" xml:space="preserve">
          <source>Turn off pre-inlining.</source>
          <target state="translated">关闭预衬线。</target>
        </trans-unit>
        <trans-unit id="17471888502443f29d90093ff7b1d13417c48663" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking (which is on by default). Recompilation checking normally stops compilation early, leaving an existing &lt;code&gt;.o&lt;/code&gt; file in place, if it can be determined that the module does not need to be recompiled.</source>
          <target state="translated">关闭重新编译检查（默认情况下处于启用状态）。重新编译检查通常可以尽早停止编译，如果可以确定不需要重新编译模块，则将现有的 &lt;code&gt;.o&lt;/code&gt; 文件保留在原位。</target>
        </trans-unit>
        <trans-unit id="d295e654c968e0d4b5d4ef28970645ceb9c359bd" translate="yes" xml:space="preserve">
          <source>Turn off recompilation checking. This is implied by any &lt;code&gt;-ddump-X&lt;/code&gt; option when compiling a single file (i.e. when using &lt;a href=&quot;using#ghc-flag--c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">关闭重新编译检查。编译单个文件时（即，使用&lt;a href=&quot;using#ghc-flag--c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; 时&lt;/a&gt;），任何 &lt;code&gt;-ddump-X&lt;/code&gt; 选项都暗含了这一点。</target>
        </trans-unit>
        <trans-unit id="2df7c8ae29045092a74a14419fbf30ce0ab66412" translate="yes" xml:space="preserve">
          <source>Turn off the &amp;ldquo;state hack&amp;rdquo; whereby any lambda with a &lt;code&gt;State#&lt;/code&gt; token as argument is considered to be single-entry, hence it is considered okay to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing.</source>
          <target state="translated">关闭&amp;ldquo;状态黑客&amp;rdquo;，将带有 &lt;code&gt;State#&lt;/code&gt; 令牌作为参数的任何lambda 都视为一次输入，因此可以将其中的内容内联。这可以提高IO和ST monad代码的性能，但是存在减少共享的风险。</target>
        </trans-unit>
        <trans-unit id="2ac1f9d019e52ced1d3ffee3e78447b7c0abfbb4" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser</source>
          <target state="translated">关闭胁迫优化器</target>
        </trans-unit>
        <trans-unit id="950c5d36c7c13101044e5055d34314b1e36c7cb9" translate="yes" xml:space="preserve">
          <source>Turn off the coercion optimiser.</source>
          <target state="translated">关闭胁迫优化器。</target>
        </trans-unit>
        <trans-unit id="617258e85d1cdd0cc36e433c788af7fa7395a65e" translate="yes" xml:space="preserve">
          <source>Turn off the state hackwhereby any lambda with a real-world state token as argument is considered to be single-entry. Hence OK to inline things inside it.</source>
          <target state="translated">关闭状态黑客whereby任何以现实世界的状态令牌作为参数的lambda都被认为是单入。因此可以在它里面内联东西。</target>
        </trans-unit>
        <trans-unit id="3910a508b92e090f15ab64efed4ef9b97e05635f" translate="yes" xml:space="preserve">
          <source>Turn on &lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;eager blackholing&lt;/a&gt;</source>
          <target state="translated">打开&lt;a href=&quot;using-concurrent#parallel-compile-options&quot;&gt;渴望的黑洞&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3be189c27f12c1b88373ff10bdc50133feda7a8" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser.</source>
          <target state="translated">在需求分析器中开启CPR分析。</target>
        </trans-unit>
        <trans-unit id="d6936ee375b84ce60a7c7670433d5b9d7fb09f4d" translate="yes" xml:space="preserve">
          <source>Turn on CPR analysis in the demand analyser. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在需求分析器中打开CPR分析。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="6d2e6cfb361c36aed029affd07ffbc2b96c57b78" translate="yes" xml:space="preserve">
          <source>Turn on Haskell program coverage instrumentation</source>
          <target state="translated">打开Haskell程序覆盖工具</target>
        </trans-unit>
        <trans-unit id="ce336f3c3e1aa6fd90aca25447fdfc1e39c9de85" translate="yes" xml:space="preserve">
          <source>Turn on call-pattern specialisation; see &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Call-pattern specialisation for Haskell programs&lt;/a&gt;.</source>
          <target state="translated">打开呼叫模式专门化；请参阅&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/&quot;&gt;Haskell程序的调用模式专用化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3a81a31f22fa4db1bc744fd067f81bd449e3b8f" translate="yes" xml:space="preserve">
          <source>Turn on debug printing (more verbose)</source>
          <target state="translated">开启调试打印(更详细)。</target>
        </trans-unit>
        <trans-unit id="296a0a179df472eb6abcb19de05eba23c2498ece" translate="yes" xml:space="preserve">
          <source>Turn on full laziness (floating bindings outwards). Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">启用完全懒惰（向外浮动绑定）。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="f318a6585e141f90a1614408fbe30c3ca88279fb" translate="yes" xml:space="preserve">
          <source>Turn on heavyweight intra-pass sanity-checking within GHC, at Core level. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">在核心级别启用GHC中的重量级内部通过完整性检查。（它检查GHC的健全性，而不是您的健全性。）</target>
        </trans-unit>
        <trans-unit id="52b6e6db9093fbc620c1a86c60865336318286e8" translate="yes" xml:space="preserve">
          <source>Turn on internal sanity checking</source>
          <target state="translated">开启内部安全检查</target>
        </trans-unit>
        <trans-unit id="83e49945c7e486aba50532474cfbb4c69f3506a7" translate="yes" xml:space="preserve">
          <source>Turn on printing of binding results in GHCi</source>
          <target state="translated">开启GHCi中的装订结果打印。</target>
        </trans-unit>
        <trans-unit id="95372a11f5d63bb2a5025a48e0b268c2ee7024be" translate="yes" xml:space="preserve">
          <source>Turn on profiling</source>
          <target state="translated">开启剖析</target>
        </trans-unit>
        <trans-unit id="9421cedd7efa973140e929983d758551f8869384" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions imported from other modules.</source>
          <target state="translated">开启从其他模块导入的重载函数的专用化。</target>
        </trans-unit>
        <trans-unit id="9a9361d3a422b8fd47b8bd6454e69dd2f06a3548" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions regardless of size, if unfolding is available</source>
          <target state="translated">开启重载函数的特殊化,无论其大小,如果可以展开的话。</target>
        </trans-unit>
        <trans-unit id="50eb8d530729d72c17cbfb2d67f874f147b28848" translate="yes" xml:space="preserve">
          <source>Turn on specialisation of overloaded functions. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开重载函数的专用化。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="83a88e24251094dd90ca7dd2a835cbafb1a5d02f" translate="yes" xml:space="preserve">
          <source>Turn on strictness analysis. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;. Implies &lt;code&gt;-fworker-wrapper&lt;/code&gt;</source>
          <target state="translated">打开严格性分析。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。意味着 &lt;code&gt;-fworker-wrapper&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bbbce33819b3dde8561126caccd5c72c407adf7" translate="yes" xml:space="preserve">
          <source>Turn on the SpecConstr transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开SpecConstr转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="2038c3131169ea1c711764a9caf8887658d5490a" translate="yes" xml:space="preserve">
          <source>Turn on the float-in transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开浮动转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="a3195d91b0f7c5107fbf8a4f3b68e117c0058d5a" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt;&lt;code&gt;-O2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">打开自由案例转换。由&lt;a href=&quot;using-optimisation#ghc-flag--O2&quot;&gt; &lt;code&gt;-O2&lt;/code&gt; &lt;/a&gt;暗示。</target>
        </trans-unit>
        <trans-unit id="d30dd0cd5415e1587f4f817ef17c1bfca9d1f69b" translate="yes" xml:space="preserve">
          <source>Turn on the liberate-case transformation. This unrolls recursive function once in its own RHS, to avoid repeated case analysis of free variables. It&amp;rsquo;s a bit like the call-pattern specialiser (&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt;&lt;code&gt;-fspec-constr&lt;/code&gt;&lt;/a&gt;) but for free variables rather than arguments.</source>
          <target state="translated">打开自由案例转换。这将在其自己的RHS中一次展开递归函数，以避免重复分析自由变量。它有点像调用模式专用程序（&lt;a href=&quot;#ghc-flag--fspec-constr&quot;&gt; &lt;code&gt;-fspec-constr&lt;/code&gt; &lt;/a&gt;），但是它提供的是自由变量而不是参数。</target>
        </trans-unit>
        <trans-unit id="fc206b146090aaae3538416928bdb40d73f8e572" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation, which turns a recursive function into a non-recursive one with a local recursive loop. See Chapter 7 of &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos&amp;rsquo;s PhD thesis&lt;/a&gt;.</source>
          <target state="translated">打开静态参数转换，该转换将递归函数转换为具有局部递归循环的非递归函数。参见&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/compilation-transformation-non-strict-functional-languages/&quot;&gt;Andre Santos博士论文的&lt;/a&gt;第7章。</target>
        </trans-unit>
        <trans-unit id="97962db7cd6430dc4d9f003ab15c722eda521246" translate="yes" xml:space="preserve">
          <source>Turn on the static argument transformation.</source>
          <target state="translated">开启静态参数转换。</target>
        </trans-unit>
        <trans-unit id="c01e89e1f152c4c360440816f0458dd2cbcfd270" translate="yes" xml:space="preserve">
          <source>Turn on ticky-ticky profiling</source>
          <target state="translated">开启ticky-ticky特征分析</target>
        </trans-unit>
        <trans-unit id="ce8a7e7e94d11356acccaca235f0a9548a974afc" translate="yes" xml:space="preserve">
          <source>Turn saturated self-recursive tail-calls into local jumps in the generated assembly. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将饱和的自递归尾调用转换为生成的程序集中的局部跳转。由&lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt;隐含。</target>
        </trans-unit>
        <trans-unit id="eafe423d4f61be7ed8a9e1ce23539a233dbf9f89" translate="yes" xml:space="preserve">
          <source>Turn type errors into warnings, &lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;deferring the error until runtime&lt;/a&gt;. Implies &lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt;&lt;code&gt;-fdefer-typed-holes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt;&lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt;&lt;code&gt;-Wdeferred-type-errors&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">将类型错误转换为警告，&lt;a href=&quot;glasgow_exts#defer-type-errors&quot;&gt;将错误推迟到runtime&lt;/a&gt;。隐含&lt;a href=&quot;using-warnings#ghc-flag--fdefer-typed-holes&quot;&gt; &lt;code&gt;-fdefer-typed-holes&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;using-warnings#ghc-flag--fdefer-out-of-scope-variables&quot;&gt; &lt;code&gt;-fdefer-out-of-scope-variables&lt;/code&gt; &lt;/a&gt;。另请参见&lt;a href=&quot;using-warnings#ghc-flag--Wdeferred-type-errors&quot;&gt; &lt;code&gt;-Wdeferred-type-errors&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="325282e86f95818411656427e91d140f8bec6af3" translate="yes" xml:space="preserve">
          <source>Turning on an option that enables special syntax &lt;em&gt;might&lt;/em&gt; cause working Haskell 98 code to fail to compile, perhaps because it uses a variable name which has become a reserved word. This section lists the syntax that is &amp;ldquo;stolen&amp;rdquo; by language extensions. We use notation and nonterminal names from the Haskell 98 lexical syntax (see the Haskell 98 Report). We only list syntax changes here that might affect existing working programs (i.e. &amp;ldquo;stolen&amp;rdquo; syntax). Many of these extensions will also enable new context-free syntax, but in all cases programs written to use the new syntax would not be compilable without the option enabled.</source>
          <target state="translated">打开启用特殊语法的选项&lt;em&gt;可能会&lt;/em&gt;导致有效的Haskell 98代码无法编译，可能是因为它使用的变量名已成为保留字。本节列出了语言扩展&amp;ldquo;偷走&amp;rdquo;的语法。我们使用Haskell 98词法语法的符号和非终结符名称（请参阅Haskell 98报告）。我们仅在此处列出可能会影响现有工作程序的语法更改（即&amp;ldquo;被盗&amp;rdquo;语法）。其中许多扩展都将启用新的无上下文语法，但是在所有情况下，如果未启用该选项，则使用新语法编写的程序将无法编译。</target>
        </trans-unit>
        <trans-unit id="8c434400de1c5aa027fbd3740ce12b2df9419a40" translate="yes" xml:space="preserve">
          <source>Turning patterns into irrefutable ones requires &lt;code&gt;~(~p)&lt;/code&gt; or &lt;code&gt;(~ ~p)&lt;/code&gt; when &lt;code&gt;Strict&lt;/code&gt; is enabled.</source>
          <target state="translated">车削图案成无可辩驳那些需要 &lt;code&gt;~(~p)&lt;/code&gt; 或 &lt;code&gt;(~ ~p)&lt;/code&gt; 时 &lt;code&gt;Strict&lt;/code&gt; 被启用。</target>
        </trans-unit>
        <trans-unit id="08265f8e8519574753252d41f723fe67031d627d" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">通过将终结器（由monadic操作指定）与引用关联，可以将普通内存引用转换为外来对象。在删除对 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; 的最后一个引用之后的一段时间，存储管理器将在单独的线程中启动终结器。不能保证及时性，实际上也不能保证终结器将最终运行。</target>
        </trans-unit>
        <trans-unit id="85564766611b55469be06dd366f3dfa26505bdd0" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign object by associating a finalizer - given by the monadic operation - with the reference. The storage manager will start the finalizer, in a separate thread, some time after the last reference to the &lt;code&gt;ForeignPtr&lt;/code&gt; is dropped. There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all.</source>
          <target state="translated">通过将终结器（由monadic操作指定）与引用关联，可以将普通内存引用转换为外来对象。在删除对 &lt;code&gt;ForeignPtr&lt;/code&gt; 的最后一个引用之后的一段时间，存储管理器将在单独的线程中启动终结器。不能保证及时性，实际上也不能保证终结器将最终运行。</target>
        </trans-unit>
        <trans-unit id="95d2eed85fb1f7986550657f2021b39f736f81e1" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="607285583b9c293196a605c10473335ddbf1efa2" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;foreign-foreignptr-safe#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="b845b225e753bbeac9cefa8b2735a44df5615e44" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer that may be associated with finalizers by using &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#v:addForeignPtrFinalizer&quot;&gt;addForeignPtrFinalizer&lt;/a&gt;&lt;/code&gt; 将普通内存引用转换为可与终结器关联的外部指针。</target>
        </trans-unit>
        <trans-unit id="209630eaf62c67416b251c558b35f54523d48fcd" translate="yes" xml:space="preserve">
          <source>Turns a plain memory reference into a foreign pointer, and associates a finalizer with the reference. The finalizer will be executed after the last reference to the foreign object is dropped. There is no guarantee of promptness, however the finalizer will be executed before the program exits.</source>
          <target state="translated">将一个普通的内存引用转化为一个外来指针,并将一个终结器与该引用关联。最终处理程序将在最后一个外来对象的引用被删除后执行。虽然不能保证及时性,但是定标器会在程序退出前执行。</target>
        </trans-unit>
        <trans-unit id="ebb6fb066f262607e7123212328b1299f8b3dfb9" translate="yes" xml:space="preserve">
          <source>Turns off all text attributes. This capability will always succeed, but it has no effect in terminals which do not support text attributes.</source>
          <target state="translated">关闭所有文本属性。该功能将始终成功,但在不支持文本属性的终端中没有效果。</target>
        </trans-unit>
        <trans-unit id="862d4af3a0d0cf7e5a018fc476f97e10f1a9c942" translate="yes" xml:space="preserve">
          <source>Turns off all warnings, including the standard ones and those that &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t enable.</source>
          <target state="translated">关闭所有警告，包括标准警告和&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;启用的警告。</target>
        </trans-unit>
        <trans-unit id="c120f254c274d83af220fb98a2c7a05760369ad8" translate="yes" xml:space="preserve">
          <source>Turns on all warning options that indicate potentially suspicious code. The warnings that are &lt;em&gt;not&lt;/em&gt; enabled by &lt;a href=&quot;#ghc-flag--Wall&quot;&gt;&lt;code&gt;-Wall&lt;/code&gt;&lt;/a&gt; are</source>
          <target state="translated">打开所有指示潜在可疑代码的警告选项。&lt;a href=&quot;#ghc-flag--Wall&quot;&gt; &lt;code&gt;-Wall&lt;/code&gt; &lt;/a&gt;&lt;em&gt;未&lt;/em&gt;启用的警告是</target>
        </trans-unit>
        <trans-unit id="40f733631bb72a22e027222a199f94b3ab0cd6c2" translate="yes" xml:space="preserve">
          <source>Turns on bold mode before outputting the given text, and then turns all attributes off.</source>
          <target state="translated">在输出给定文本前开启粗体模式,然后关闭所有属性。</target>
        </trans-unit>
        <trans-unit id="67813ec19f0d115e1f945fcce60a3304e9742d7a" translate="yes" xml:space="preserve">
          <source>Turns on every single warning supported by the compiler.</source>
          <target state="translated">开启编译器支持的每一个警告。</target>
        </trans-unit>
        <trans-unit id="712aa51fce57b7ec3c57639065bf9341454f6830" translate="yes" xml:space="preserve">
          <source>Turns on standout mode before outputting the given text, and then turns it off.</source>
          <target state="translated">在输出给定文本前开启突出模式,然后关闭。</target>
        </trans-unit>
        <trans-unit id="0e6f331bebb9604aed3b96d3a3c3888598136b3d" translate="yes" xml:space="preserve">
          <source>Turns on underline mode before outputting the given text, and then turns it off.</source>
          <target state="translated">在输出给定文本前开启下划线模式,然后关闭。</target>
        </trans-unit>
        <trans-unit id="86118d2f9d660a289256f279c1a5b872d4f80d3f" translate="yes" xml:space="preserve">
          <source>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</source>
          <target state="translated">开启未来默认启用的警告,但在正常编译中暂时保持关闭。这使得那些急于让自己的代码与未来兼容的库作者,可以在产生警告之前就适应新特性。</target>
        </trans-unit>
        <trans-unit id="ff28cc42f8a053998e917744dabc2b0418bf805a" translate="yes" xml:space="preserve">
          <source>Two command-line options control whether the startup files files are read:</source>
          <target state="translated">两个命令行选项控制是否读取启动文件文件。</target>
        </trans-unit>
        <trans-unit id="1ef6d52a2b612fed2aed21ed859ad1b8d21ad23d" translate="yes" xml:space="preserve">
          <source>Two things to watch out for:</source>
          <target state="translated">有两点要注意。</target>
        </trans-unit>
        <trans-unit id="734286508752def272446ebf258e9a3edb931b88" translate="yes" xml:space="preserve">
          <source>Two types are considered apart if, for all possible substitutions, the types cannot reduce to a common reduct.</source>
          <target state="translated">如果对于所有可能的替换,两个类型不能还原成一个共同的还原物,则认为这两个类型是分开的。</target>
        </trans-unit>
        <trans-unit id="65740d677d61ed4bde9d4c583395253b786ef4c4" translate="yes" xml:space="preserve">
          <source>Two types of messages are produced: Those beginning with &lt;code&gt;***&lt;/code&gt; do denote the beginning of a compilation phase whereas those starting with &lt;code&gt;!!!&lt;/code&gt; mark the end of a pass and are accompanied by allocation and runtime statistics.</source>
          <target state="translated">产生两种类型的消息：以 &lt;code&gt;***&lt;/code&gt; 开头的消息确实表示编译阶段的开始，而以 &lt;code&gt;!!!&lt;/code&gt; 开头的消息则表示！标记过程的结束，并伴随分配和运行时统计信息。</target>
        </trans-unit>
        <trans-unit id="2abaa8beec76b5d77b798c536fa4b1107e5f57b3" translate="yes" xml:space="preserve">
          <source>TwoStopBits</source>
          <target state="translated">TwoStopBits</target>
        </trans-unit>
        <trans-unit id="d3ed034a0f2ac469546d42366627fbcd92794ceb" translate="yes" xml:space="preserve">
          <source>TyCon</source>
          <target state="translated">TyCon</target>
        </trans-unit>
        <trans-unit id="f54b069f499e1f9490d2d00a694470c28524dd84" translate="yes" xml:space="preserve">
          <source>TyLit</source>
          <target state="translated">TyLit</target>
        </trans-unit>
        <trans-unit id="f8f994fcfb248f32e675f0f4fa05671284ab679c" translate="yes" xml:space="preserve">
          <source>TyLitQ</source>
          <target state="translated">TyLitQ</target>
        </trans-unit>
        <trans-unit id="b3a7f451591028e9f2464430caf92564d0da6cb9" translate="yes" xml:space="preserve">
          <source>TySynEqn</source>
          <target state="translated">TySynEqn</target>
        </trans-unit>
        <trans-unit id="40dbe9290e904fbafc0107b863075e7c03c4405f" translate="yes" xml:space="preserve">
          <source>TySynEqnQ</source>
          <target state="translated">TySynEqnQ</target>
        </trans-unit>
        <trans-unit id="8e498318f3d478f740d1ba3b3f9b862f396efd9b" translate="yes" xml:space="preserve">
          <source>TyVarBndr</source>
          <target state="translated">TyVarBndr</target>
        </trans-unit>
        <trans-unit id="8935a387193b0a5a816a4c66481c8d7c932e5d95" translate="yes" xml:space="preserve">
          <source>TyVarBndrQ</source>
          <target state="translated">TyVarBndrQ</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="01dbe869b73c807b8d1e0423661fe63c6667b4be" translate="yes" xml:space="preserve">
          <source>Type Literals</source>
          <target state="translated">字型</target>
        </trans-unit>
        <trans-unit id="683905a8f5337d0ba4784f351b463bf3f6346eb7" translate="yes" xml:space="preserve">
          <source>Type arguments can be replaced with underscores (&lt;code&gt;_&lt;/code&gt;) if the names of the arguments don&amp;rsquo;t matter. This is the same as writing type variables with unique names. Unused type arguments can be replaced or prefixed with underscores to avoid warnings when the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt;&lt;code&gt;-Wunused-type-patterns&lt;/code&gt;&lt;/a&gt; flag is enabled. The same rules apply as for &lt;a href=&quot;#data-instance-declarations&quot;&gt;Data instance declarations&lt;/a&gt;.</source>
          <target state="translated">如果参数名称无关紧要，则类型参数可以用下划线（ &lt;code&gt;_&lt;/code&gt; ）替换。这与使用唯一名称编写类型变量相同。启用&lt;a href=&quot;using-warnings#ghc-flag--Wunused-type-patterns&quot;&gt; &lt;code&gt;-Wunused-type-patterns&lt;/code&gt; &lt;/a&gt;标志时，可以将未使用的类型参数替换为下划线或在其下加上前缀，以避免发出警告。规则与&lt;a href=&quot;#data-instance-declarations&quot;&gt;数据实例声明相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9659950f117d747675f9b331917067539bfad472" translate="yes" xml:space="preserve">
          <source>Type checker will allow inferred types for holes.</source>
          <target state="translated">类型检查器将允许孔的推断类型。</target>
        </trans-unit>
        <trans-unit id="15f12c9fab92008565db5b57cde29394bdb8c86c" translate="yes" xml:space="preserve">
          <source>Type classes for I/O providers.</source>
          <target state="translated">I/O提供者的类型类。</target>
        </trans-unit>
        <trans-unit id="e7b44aa8869034215edcaae12677a88e93b094f6" translate="yes" xml:space="preserve">
          <source>Type classes which require their own extensions to be enabled to be derived, such as &lt;a href=&quot;#extension-DeriveFunctor&quot;&gt;&lt;code&gt;-XDeriveFunctor&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#deriving-extra&quot;&gt;Deriving instances of extra classes (Data, etc.)&lt;/a&gt;)</source>
          <target state="translated">需要启用自己的扩展名的类型类，例如&lt;a href=&quot;#extension-DeriveFunctor&quot;&gt; &lt;code&gt;-XDeriveFunctor&lt;/code&gt; &lt;/a&gt;（请参阅&lt;a href=&quot;#deriving-extra&quot;&gt;派生额外类的实例（Data等）&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8c9a4e5cab1cfa60793ccf4274a928c742c6b4aa" translate="yes" xml:space="preserve">
          <source>Type constructor applied to a type involving for-alls (if &lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt;&lt;code&gt;ImpredicativeTypes&lt;/code&gt;&lt;/a&gt; is off)</source>
          <target state="translated">类型构造函数应用于涉及所有人的类型（如果关闭了&lt;a href=&quot;#extension-ImpredicativeTypes&quot;&gt; &lt;code&gt;ImpredicativeTypes&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">类型构造器</target>
        </trans-unit>
        <trans-unit id="36b5ccdef806edc695be3db5ad16383dfcdb2c19" translate="yes" xml:space="preserve">
          <source>Type constructors and classes; Haskell has them in the same name space for now.</source>
          <target state="translated">类型构造函数和类;Haskell 目前将它们放在同一个名称空间。</target>
        </trans-unit>
        <trans-unit id="1e26c6647efeb9930ae7b1b903c5e593169df277" translate="yes" xml:space="preserve">
          <source>Type equalities under a forall cannot be deferred (c.f. Trac #14605).</source>
          <target state="translated">&quot;forall &quot;下的类型平等不能推迟(参见Trac #14605)。</target>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">平等类型</target>
        </trans-unit>
        <trans-unit id="36ea2932c958e42745f275dfbcdd59e4d26efb2e" translate="yes" xml:space="preserve">
          <source>Type families appear in three flavours: (1) they can be defined as open families on the toplevel, (2) they can be defined as closed families on the toplevel, or (3) they can appear inside type classes (in which case they are known as associated type synonyms). Toplevel families are more general, as they lack the requirement for the type-indexes to coincide with the class parameters. However, associated type synonyms can lead to more clearly structured code and compiler warnings if some type instances were - possibly accidentally - omitted. In the following, we always discuss the general toplevel forms first and then cover the additional constraints placed on associated types. Note that closed associated type synonyms do not exist.</source>
          <target state="translated">类型族有三种形式。(1)它们可以被定义为toplevel上的开放族,(2)它们可以被定义为toplevel上的封闭族,或(3)它们可以出现在类型类中(在这种情况下,它们被称为关联类型同义词)。toplevel族更通用,因为它们没有类型索引与类参数一致的要求。然而,关联类型同义词可以导致更清晰的结构化代码,如果一些类型实例被--可能是意外地--省略了,编译器会发出警告。在下文中,我们总是先讨论一般的toplevel形式,然后再讨论放在关联类型上的附加约束。注意,封闭的关联类型同义词是不存在的。</target>
        </trans-unit>
        <trans-unit id="a0217e7f7c0552b806a549d26e49045593d48ebc" translate="yes" xml:space="preserve">
          <source>Type families are enabled by the language extension &lt;a href=&quot;#extension-TypeFamilies&quot;&gt;&lt;code&gt;TypeFamilies&lt;/code&gt;&lt;/a&gt;. Additional information on the use of type families in GHC is available on &lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;the Haskell wiki page on type families&lt;/a&gt;.</source>
          <target state="translated">类型族由语言扩展&lt;a href=&quot;#extension-TypeFamilies&quot;&gt; &lt;code&gt;TypeFamilies&lt;/code&gt; &lt;/a&gt;启用。有关在GHC中使用类型族的其他信息，请参见&lt;a href=&quot;http://www.haskell.org/haskellwiki/GHC/Indexed_types&quot;&gt;有关类型族的Haskell Wiki页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d1cc718ce378b49b47bdbdb12d9dfc708c706bb3" translate="yes" xml:space="preserve">
          <source>Type families require us to extend the rules for the form of instance heads, which are given in &lt;a href=&quot;#flexible-instance-head&quot;&gt;Relaxed rules for the instance head&lt;/a&gt;. Specifically:</source>
          <target state="translated">类型族要求我们扩展实例头形式的规则，这&lt;a href=&quot;#flexible-instance-head&quot;&gt;在实例头的宽松规则&lt;/a&gt;中给出。特别：</target>
        </trans-unit>
        <trans-unit id="0a8c0f063a56614635f7174c757855682f77adaa" translate="yes" xml:space="preserve">
          <source>Type family declarations have no right-hand side, but GHC must still infer a kind for &lt;code&gt;F&lt;/code&gt;. Since there are no constraints, it could infer &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt;, but that seems &lt;em&gt;too&lt;/em&gt; polymorphic. So GHC defaults those entirely-unconstrained kind variables to &lt;code&gt;Type&lt;/code&gt; and we get &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt;. You can still declare &lt;code&gt;F&lt;/code&gt; to be kind-polymorphic using kind signatures:</source>
          <target state="translated">类型族声明没有右侧，但是GHC必须仍然为 &lt;code&gt;F&lt;/code&gt; 推断一种。由于没有约束，因此可以推断 &lt;code&gt;F :: forall k1 k2. k1 -&amp;gt; k2&lt;/code&gt; ，但这似乎&lt;em&gt;太多&lt;/em&gt;态了。因此，GHC将那些完全不受约束的种类变量默认为 &lt;code&gt;Type&lt;/code&gt; ，我们得到 &lt;code&gt;F :: Type -&amp;gt; Type&lt;/code&gt; 。您仍然可以使用种类签名将 &lt;code&gt;F&lt;/code&gt; 声明为种类多态：</target>
        </trans-unit>
        <trans-unit id="afd7475025d74b7eaf3a5c6c31d02e60c9ba84c8" translate="yes" xml:space="preserve">
          <source>Type family instance declarations are only legitimate when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible. Moreover, each instance declaration has to conform to the kind determined by its family declaration, and the number of type parameters in an instance declaration must match the number of type parameters in the family declaration. Finally, the right-hand side of a type instance must be a monotype (i.e., it may not include foralls) and after the expansion of all saturated vanilla type synonyms, no synonyms, except family synonyms may remain.</source>
          <target state="translated">只有当适当的族声明在范围内时,类型族实例声明才是合法的--就像类实例要求类声明可见一样。此外,每个实例声明必须符合其族声明所确定的种类,实例声明中的类型参数数量必须与族声明中的类型参数数量一致。最后,类型实例的右侧必须是单型(即不得包括foralls),在扩展了所有饱和的凡型同义词后,除了族同义词外,不得留下任何同义词。</target>
        </trans-unit>
        <trans-unit id="70bbb20d2a1a6691ef9fa237cff60e4e6de9eb91" translate="yes" xml:space="preserve">
          <source>Type family result</source>
          <target state="translated">家庭结果类型</target>
        </trans-unit>
        <trans-unit id="0f4828f660b26b8e0b84ed945344b94a3b83159e" translate="yes" xml:space="preserve">
          <source>Type family result signature</source>
          <target state="translated">类型家族结果签名</target>
        </trans-unit>
        <trans-unit id="358e178753bb1e86971badaa924cf0ea2c52929d" translate="yes" xml:space="preserve">
          <source>Type holes in typed splices (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;Issue #10945&lt;/a&gt; and &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;Issue #10946&lt;/a&gt;)</source>
          <target state="translated">在输入接头类型孔（见&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10945&quot;&gt;问题＃10945&lt;/a&gt;和&lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/10946&quot;&gt;问题＃10946&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="873a99e95101acee0eaf6ee1997f0cfc41142d03" translate="yes" xml:space="preserve">
          <source>Type of a device that can be used to back a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; (see also &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt;). The standard libraries provide creation of &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;s via Posix file operations with file descriptors (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt;) with FD being the underlying &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">可用于支持 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; 的设备的类型（另请参见 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:mkFileHandle&quot;&gt;mkFileHandle&lt;/a&gt;&lt;/code&gt; ）。标准库通过Posix文件操作（带有文件描述符（请参见 &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:mkHandleFromFD&quot;&gt;mkHandleFromFD&lt;/a&gt;&lt;/code&gt; ））来创建 &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; ,其中FD是基础 &lt;code&gt;&lt;a href=&quot;ghc-io-device#t:IODevice&quot;&gt;IODevice&lt;/a&gt;&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1a8dd35ccae4e966a68ff35c41712c9b36c641b0" translate="yes" xml:space="preserve">
          <source>Type of a function that will parse modifier characters from the format string.</source>
          <target state="translated">从格式字符串中解析修饰符的函数类型。</target>
        </trans-unit>
        <trans-unit id="abcdceb02cff6a2c30770317c525208b3a8f1938" translate="yes" xml:space="preserve">
          <source>Type representations</source>
          <target state="translated">类型代表</target>
        </trans-unit>
        <trans-unit id="4a3e13a726a19383a1d4e94b6299671bdfe44312" translate="yes" xml:space="preserve">
          <source>Type representing &lt;em&gt;raw&lt;/em&gt; arbitrary-precision Naturals</source>
          <target state="translated">表示&lt;em&gt;原始&lt;/em&gt;任意精度自然数的类型</target>
        </trans-unit>
        <trans-unit id="671703d1ace4903a86338074fcbb10d8c7abb79d" translate="yes" xml:space="preserve">
          <source>Type representing a GMP Limb</source>
          <target state="translated">代表GMP肢体的类型</target>
        </trans-unit>
        <trans-unit id="54d9ef78d2f719690e76c88c724133d9268d3dbd" translate="yes" xml:space="preserve">
          <source>Type representing arbitrary-precision non-negative integers.</source>
          <target state="translated">表示任意精度非负整数的类型。</target>
        </trans-unit>
        <trans-unit id="d1f333d10338307bc1b784667a629594e079c4f4" translate="yes" xml:space="preserve">
          <source>Type splices: only anonymous wildcards are supported in type splices. Named and extra-constraints wildcards are not.</source>
          <target state="translated">类型拼接:类型拼接中只支持匿名通配符。命名通配符和约束外通配符不支持。</target>
        </trans-unit>
        <trans-unit id="f11439c31a98487626c375dcea7b024dac99e79d" translate="yes" xml:space="preserve">
          <source>Type synonym families may not appear (at all) in an instance head</source>
          <target state="translated">类型同义词族可能不会出现在一个实例头中(根本不会)。</target>
        </trans-unit>
        <trans-unit id="0d76a40c54b048eccf092f3d284b847909f588a0" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Addr-35-&quot;&gt;Addr＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="f8bdd4c143c24e4a800f150ca0b3c707e64b8ee5" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Char-35-&quot;&gt;Char＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="6200650e3b073a512de8a4f746fe7641f19f3b6e" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Double-35-&quot;&gt;Double＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="68f0b26db1c67e68b16638c3bdb6e48c2730cfcb" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Float-35-&quot;&gt;Float＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="786449ff1af28a830302acb40a4df639ec0b1a9a" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="b833c73340a6aca568e641af9389cb5068a1b69c" translate="yes" xml:space="preserve">
          <source>Type synonym for &lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ghc-generics#t:URec&quot;&gt;URec&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word#&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;ghc-exts#t:Word-35-&quot;&gt;Word＃的&lt;/a&gt;类型同义词</target>
        </trans-unit>
        <trans-unit id="fbc2d6b543125a6bbcf32afd5ebc2e6194481a75" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for constructors</source>
          <target state="translated">为构造体编码元信息的类型同义词。</target>
        </trans-unit>
        <trans-unit id="01637cf0f027de68fdc7b5aa075fa796a7541a5a" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for datatypes</source>
          <target state="translated">为数据类型编码元信息的类型同义词。</target>
        </trans-unit>
        <trans-unit id="4614911dbcdbe75ce8420ef09e4cddfbd8bcd75b" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding meta-information for record selectors</source>
          <target state="translated">为记录选择器编码元信息的同义词类型。</target>
        </trans-unit>
        <trans-unit id="cd6568ab830a42d4743f02c359ffccacc3f04b1f" translate="yes" xml:space="preserve">
          <source>Type synonym for encoding recursion (of kind &lt;code&gt;Type&lt;/code&gt;)</source>
          <target state="translated">编码递归的类型同义词（ &lt;code&gt;Type&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="2e57d9ed04b093b3c81d176b71e171ce86cead21" translate="yes" xml:space="preserve">
          <source>Type synonyms</source>
          <target state="translated">类型同义词</target>
        </trans-unit>
        <trans-unit id="66c87db4429ac309b453d99467ebf0303fe2943b" translate="yes" xml:space="preserve">
          <source>Type synonyms are like macros at the type level, but Haskell 98 imposes many rules on individual synonym declarations. With the &lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt;&lt;code&gt;LiberalTypeSynonyms&lt;/code&gt;&lt;/a&gt; extension, GHC does validity checking on types &lt;em&gt;only after expanding type synonyms&lt;/em&gt;. That means that GHC can be very much more liberal about type synonyms than Haskell 98.</source>
          <target state="translated">类型同义词就像类型级别的宏一样，但是Haskell 98在单个同义词声明上强加了许多规则。通过&lt;a href=&quot;#extension-LiberalTypeSynonyms&quot;&gt; &lt;code&gt;LiberalTypeSynonyms&lt;/code&gt; &lt;/a&gt;扩展，GHC &lt;em&gt;仅在扩展类型同义词后才&lt;/em&gt;对类型进行有效性检查。这意味着GHC在类型同义词方面比Haskell 98更加自由。</target>
        </trans-unit>
        <trans-unit id="b53035e4ebf40cc37041e2c629488482dfa0e22e" translate="yes" xml:space="preserve">
          <source>Type wildcards can also be named by giving the underscore an identifier as suffix, i.e. &lt;code&gt;_a&lt;/code&gt;. These are called &lt;em&gt;named wildcards&lt;/em&gt;. All occurrences of the same named wildcard within one type signature will unify to the same type. For example:</source>
          <target state="translated">类型通配符也可以通过在下划线后加上一个标识符后缀 &lt;code&gt;_a&lt;/code&gt; 来命名。这些被称为&lt;em&gt;命名通配符&lt;/em&gt;。在一个类型签名中出现的所有相同名称的通配符将统一为同一类型。例如：</target>
        </trans-unit>
        <trans-unit id="3ead66032815d945b91e7f3ca53e01f2a9b3d371" translate="yes" xml:space="preserve">
          <source>Type-Indexed</source>
          <target state="translated">Type-Indexed</target>
        </trans-unit>
        <trans-unit id="89349ef7a3b1aed9c4a2611c575f48ebe1f9588c" translate="yes" xml:space="preserve">
          <source>Type-checking and renaming</source>
          <target state="translated">类型检查和重命名</target>
        </trans-unit>
        <trans-unit id="e4df789f69216abcb6af7685ef88fccb48d4e029" translate="yes" xml:space="preserve">
          <source>Type-class and implicit-parameter constraints</source>
          <target state="translated">类型类和隐式参数约束</target>
        </trans-unit>
        <trans-unit id="925e6d79cddba2c3bddc37cf1588ba124ea988cc" translate="yes" xml:space="preserve">
          <source>Type-level &quot;and&quot;</source>
          <target state="translated">类型级 &quot;和&quot;</target>
        </trans-unit>
        <trans-unit id="da8bd8c22c8d2b83e3a41e6db5bb694a1cab398a" translate="yes" xml:space="preserve">
          <source>Type-level &quot;not&quot;. An injective type family since &lt;code&gt;4.10.0.0&lt;/code&gt;.</source>
          <target state="translated">类型级别为&amp;ldquo; not&amp;rdquo;。从 &lt;code&gt;4.10.0.0&lt;/code&gt; 开始的单射型族。</target>
        </trans-unit>
        <trans-unit id="4ace6e6dff738eea140d3177610f72ab3c710220" translate="yes" xml:space="preserve">
          <source>Type-level &quot;or&quot;</source>
          <target state="translated">类型级 &quot;或&quot;</target>
        </trans-unit>
        <trans-unit id="fb80fb0cd37d8fc564daf6fedf45033846615274" translate="yes" xml:space="preserve">
          <source>Type-level &lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;. &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt;; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">类型级别&lt;a href=&quot;if&quot;&gt;If&lt;/a&gt;。 &lt;code&gt;If True a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;a&lt;/code&gt; ; &lt;code&gt;If False a b&lt;/code&gt; ==&amp;gt; &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e8911f3eca1306cba381f9e1e254ca16f95d810" translate="yes" xml:space="preserve">
          <source>Type-safe cast</source>
          <target state="translated">铸型安全</target>
        </trans-unit>
        <trans-unit id="2dbb305ead6c25f7be1be5c3d5f41eb8a9a76dd6" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using propositional equality</source>
          <target state="translated">使用命题平等的类型安全转换</target>
        </trans-unit>
        <trans-unit id="50d265b22a2aba2469677629fcf416096471ba92" translate="yes" xml:space="preserve">
          <source>Type-safe cast, using representational equality</source>
          <target state="translated">使用表征平等的类型安全投射</target>
        </trans-unit>
        <trans-unit id="4d7fb49caed5ccaa28b4e22df123b1870b603064" translate="yes" xml:space="preserve">
          <source>Type.Reflection</source>
          <target state="translated">Type.Reflection</target>
        </trans-unit>
        <trans-unit id="1742f07af879d3cf88a9051291b4573ccd9dc6bc" translate="yes" xml:space="preserve">
          <source>Type.Reflection.Unsafe</source>
          <target state="translated">Type.Reflection.Unsafe</target>
        </trans-unit>
        <trans-unit id="64d3d705e437d4286c78a22f6d7ee8620f4bda1e" translate="yes" xml:space="preserve">
          <source>TypeApplications</source>
          <target state="translated">TypeApplications</target>
        </trans-unit>
        <trans-unit id="a90b20668004606ae955d09021dde257f6505557" translate="yes" xml:space="preserve">
          <source>TypeArg</source>
          <target state="translated">TypeArg</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="1baee472beb95c11f5ef2d7b8b3f743a3ba9ddf6" translate="yes" xml:space="preserve">
          <source>TypeFamilies</source>
          <target state="translated">TypeFamilies</target>
        </trans-unit>
        <trans-unit id="77b335820321b9c88753310855c49f382d99b38c" translate="yes" xml:space="preserve">
          <source>TypeFamilyDependencies</source>
          <target state="translated">TypeFamilyDependencies</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
