<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="ab5146bc0337c0c4ec162adcbc0f516bf45e19f0" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;</source>
          <target state="translated">有关用法，请参见&lt;a href=&quot;#partitionby&quot;&gt;示例：PARTITION BY&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f9184fa3102a195538324a094c9f3e87e8512af" translate="yes" xml:space="preserve">
          <source>For usage, see &lt;a href=&quot;#partitionby&quot;&gt;Example: PARTITION BY&lt;/a&gt;.</source>
          <target state="translated">有关用法，请参见&lt;a href=&quot;#partitionby&quot;&gt;示例：PARTITION BY&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0950ec5daec19b5369e8db389d77d478ef703948" translate="yes" xml:space="preserve">
          <source>For use with functions.</source>
          <target state="translated">用于功能。</target>
        </trans-unit>
        <trans-unit id="2e73207156965726452940b3f15d34faa203e678" translate="yes" xml:space="preserve">
          <source>For use with streaming.</source>
          <target state="translated">用于与流。</target>
        </trans-unit>
        <trans-unit id="e710be2705e01b5fdc5bc69b770043ff7d7443e6" translate="yes" xml:space="preserve">
          <source>Force parallel &quot;1&quot; for &quot;group all&quot; statement. That's because even if we set parallel to N, only 1 reducer will be used in this case and all other reducer produce empty result.</source>
          <target state="translated">强制将 &quot;group all &quot;语句的并行设置为 &quot;1&quot;,这是因为即使我们将并行设置为N,在这种情况下也只会使用1个减速器,而其他所有减速器都会产生空结果。这是因为即使我们将parallel设置为N,在这种情况下也只会使用1个reducer,其他所有reducer都会产生空结果。</target>
        </trans-unit>
        <trans-unit id="c4f05734f466b587d8c8a1997c40b3f98c2fd069" translate="yes" xml:space="preserve">
          <source>Format floats/doubles with %f, hexadecimal integers with %x (there are others besides -- see the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java docs&lt;/a&gt;)</source>
          <target state="translated">用％f格式化浮点数/双精度数，用％x格式化十六进制整数（此外还有其他格式-请参阅&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;Java文档&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="65b19c46035a1e459a4e6bb765528e1af24e48c0" translate="yes" xml:space="preserve">
          <source>Format strings with %s, integers with %d. Types are converted for you where reasonable (here, int -&amp;gt; string).</source>
          <target state="translated">用％s格式化字符串，用％d格式化整数。类型将在合理的范围内为您转换（这里为int-&amp;gt; string）。</target>
        </trans-unit>
        <trans-unit id="f0c02fc6d4fa96dcda39151919580b8f3027d3c2" translate="yes" xml:space="preserve">
          <source>Formats a set of values according to a printf-style template, using the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;native Java Formatter&lt;/a&gt; library.</source>
          <target state="translated">使用本&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html&quot;&gt;机Java Formatter&lt;/a&gt;库，根据printf样式模板来格式化一组值。</target>
        </trans-unit>
        <trans-unit id="37a95ef7b2da5e9dfb0b25b33a9688c6a79aa3a1" translate="yes" xml:space="preserve">
          <source>Fragment replicate join is a special type of join that works well if one or more relations are small enough to fit into main memory. In such cases, Pig can perform a very efficient join because all of the hadoop work is done on the map side. In this type of join the large relation is followed by one or more small relations. The small relations must be small enough to fit into main memory; if they don't, the process fails and an error is generated.</source>
          <target state="translated">Fragment replicate join是一种特殊的join类型,如果一个或多个关系小到足以装入主内存,那么这种join就能很好地工作。在这种情况下,Pig可以执行一个非常高效的连接,因为所有的hadoop工作都是在map端完成的。在这种类型的连接中,大关系后面跟着一个或多个小关系。小关系必须小到足以装入主内存,如果不装入主内存,这个过程就会失败,并产生一个错误。</target>
        </trans-unit>
        <trans-unit id="f7d2029d8a7b6c3c5acd074ab389e6e84bd20928" translate="yes" xml:space="preserve">
          <source>Fragment replicate joins are experimental; we don't have a strong sense of how small the small relation must be to fit into memory. In our tests with a simple query that involves just a JOIN, a relation of up to 100 M can be used if the process overall gets 1 GB of memory. Please share your observations and experience with us.</source>
          <target state="translated">碎片复制join是实验性的,我们对小关系必须小到什么程度才适合内存没有很强的感觉。在我们的测试中,通过一个只涉及JOIN的简单查询,如果进程整体获得1GB的内存,可以使用高达100M的关系。请把你的观察和经验与我们分享。</target>
        </trans-unit>
        <trans-unit id="f3b8fd3a28a763d9eab819f563e9a8f0681fa259" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idlocal.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">在当前工作目录中，编译程序。（请注意，idlocal.class已写入当前工作目录。运行程序时，请在类路径中包含&amp;ldquo;。&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="68b6e84a59d14c66e17c94d2084cee2765bf4216" translate="yes" xml:space="preserve">
          <source>From your current working directory, compile the program. (Note that idmapreduce.class is written to your current working directory. Include &amp;ldquo;.&amp;rdquo; in the class path when you run the program.)</source>
          <target state="translated">在当前工作目录中，编译程序。（请注意，idmapreduce.class已写入当前工作目录。运行程序时，请在类路径中包含&amp;ldquo;。&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="8d3c6572188487e7d0f0bf43f11a330f71f5a985" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the idout directory on your Hadoop system.</source>
          <target state="translated">从您当前的工作目录中,运行该程序。要查看结果,请检查Hadoop系统上的idout目录。</target>
        </trans-unit>
        <trans-unit id="3ae11fbd09e929b80dba1b8d2891594f82f70b9d" translate="yes" xml:space="preserve">
          <source>From your current working directory, run the program. To view the results, check the output file, id.out.</source>
          <target state="translated">在当前工作目录下,运行该程序。要查看结果,请检查输出文件id.out。</target>
        </trans-unit>
        <trans-unit id="a7a933fc62edcf10d9c4963f8596c7a787656527" translate="yes" xml:space="preserve">
          <source>Full outer join is not supported for bloom joins.</source>
          <target state="translated">绽放式连接不支持全外侧连接。</target>
        </trans-unit>
        <trans-unit id="5f3f294cdfe303f5625a901ee7d581a06175c157" translate="yes" xml:space="preserve">
          <source>Full outer join.</source>
          <target state="translated">全外接。</target>
        </trans-unit>
        <trans-unit id="bd51a32f96535333dd4e1a84807c6dd179d912eb" translate="yes" xml:space="preserve">
          <source>Function Instantiation</source>
          <target state="translated">函数实例化</target>
        </trans-unit>
        <trans-unit id="84101354a0a57697de0f255638b9cba689a57826" translate="yes" xml:space="preserve">
          <source>Function Overloading</source>
          <target state="translated">功能重载</target>
        </trans-unit>
        <trans-unit id="41a40e8fa627c3e0562970952ab6b5e561ad1d21" translate="yes" xml:space="preserve">
          <source>Function names PigStorage and COUNT are case sensitive.</source>
          <target state="translated">函数名PigStorage和COUNT是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="160b3670e04858fde7e4140b45e86e3c1b2090a9" translate="yes" xml:space="preserve">
          <source>Function:</source>
          <target state="translated">Function:</target>
        </trans-unit>
        <trans-unit id="8a60d2c69bf2f39201997d6084ec499f9e7d4ad3" translate="yes" xml:space="preserve">
          <source>Functions can be a part of almost every operator in Pig. The &lt;a href=&quot;func&quot;&gt;Built In Functions&lt;/a&gt; guide describes Pig's built in functions. The &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt; manual shows you how to how to write your own functions and how to access/contribute functions using the Piggy Bank repository.</source>
          <target state="translated">在Pig中，功能几乎可以成为每个运算符的一部分。该&lt;a href=&quot;func&quot;&gt;内置函数&lt;/a&gt;指南介绍了猪的内置功能。该&lt;a href=&quot;udf&quot;&gt;用户定义函数&lt;/a&gt;手册告诉您如何如何编写自己的函数，以及如何访问/使用做出贡献的储蓄罐库功能。</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="69c25d3382693097f4ee01b8b77967c5ef7e79d1" translate="yes" xml:space="preserve">
          <source>Future Enhancements</source>
          <target state="translated">未来的改进</target>
        </trans-unit>
        <trans-unit id="c47a6ad23578fb44a406e049fe66c07a90f32a42" translate="yes" xml:space="preserve">
          <source>GENERATE expression [AS schema] [expression [AS schema]&amp;hellip;.]</source>
          <target state="translated">生成表达式[AS模式] [表达式[AS模式]&amp;hellip;。]</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="013e1ba0cbe0583ac34e8b6e095d4f74e6839fce" translate="yes" xml:space="preserve">
          <source>General Expressions</source>
          <target state="translated">一般表达式</target>
        </trans-unit>
        <trans-unit id="ba7ce2025ad3e9884daf361153c61aba79035239" translate="yes" xml:space="preserve">
          <source>General expressions can be made up of UDFs and almost any operator. Since Pig does not consider boolean a base type, the result of a general expression cannot be a boolean. Field expressions are the simpliest general expressions.</source>
          <target state="translated">通用表达式可以由UDF和几乎所有的运算符组成。由于Pig不认为boolean是基础类型,所以一般表达式的结果不能是boolean。字段表达式是最简单的通用表达式。</target>
        </trans-unit>
        <trans-unit id="05659366d857f4eb5690afb9bdc9b7cff8960f88" translate="yes" xml:space="preserve">
          <source>Generates data transformations based on columns of data.</source>
          <target state="translated">基于数据列生成数据转换。</target>
        </trans-unit>
        <trans-unit id="5d31621c5fbd4db9066caabd502e7f486ee3e5b1" translate="yes" xml:space="preserve">
          <source>GetDay</source>
          <target state="translated">GetDay</target>
        </trans-unit>
        <trans-unit id="a2818cfc533e59e26a20d03c8af18c62d9b9c5cb" translate="yes" xml:space="preserve">
          <source>GetDay(datetime)</source>
          <target state="translated">GetDay(datetime)</target>
        </trans-unit>
        <trans-unit id="3b156f58cad62688611629fcdf71abc53cfef5f1" translate="yes" xml:space="preserve">
          <source>GetHour</source>
          <target state="translated">GetHour</target>
        </trans-unit>
        <trans-unit id="7f19466d1ae92343794e23e8bd7e86f438306630" translate="yes" xml:space="preserve">
          <source>GetHour(datetime)</source>
          <target state="translated">GetHour(datetime)</target>
        </trans-unit>
        <trans-unit id="58893931dfea4b07fda21ca1e5395092265e2c3a" translate="yes" xml:space="preserve">
          <source>GetMilliSecond</source>
          <target state="translated">GetMilliSecond</target>
        </trans-unit>
        <trans-unit id="afef00aa595fe91edb36d72cf45140620b780d38" translate="yes" xml:space="preserve">
          <source>GetMilliSecond(datetime)</source>
          <target state="translated">GetMilliSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="fbac074c454a28eb5bc3652325337229670aceab" translate="yes" xml:space="preserve">
          <source>GetMinute</source>
          <target state="translated">GetMinute</target>
        </trans-unit>
        <trans-unit id="6ddb6810694ebf38157652de08ac6474351f11dd" translate="yes" xml:space="preserve">
          <source>GetMinute(datetime)</source>
          <target state="translated">GetMinute(datetime)</target>
        </trans-unit>
        <trans-unit id="9a9c8d02c50cc38f21c8d41bc770a3c35f506480" translate="yes" xml:space="preserve">
          <source>GetMonth</source>
          <target state="translated">GetMonth</target>
        </trans-unit>
        <trans-unit id="f2fff6f22018398e947df0b8d628bc57c850fec7" translate="yes" xml:space="preserve">
          <source>GetMonth(datetime)</source>
          <target state="translated">GetMonth(datetime)</target>
        </trans-unit>
        <trans-unit id="ff6d2cdc9cd0bca91c09f0335184b3630e5b2deb" translate="yes" xml:space="preserve">
          <source>GetSecond</source>
          <target state="translated">GetSecond</target>
        </trans-unit>
        <trans-unit id="45f99eb79a9b7a9ba3bd539dcbbaf4f8c0817e77" translate="yes" xml:space="preserve">
          <source>GetSecond(datetime)</source>
          <target state="translated">GetSecond(datetime)</target>
        </trans-unit>
        <trans-unit id="dbe83da717d9b3ecc4a104bf9633dbb6f97546bc" translate="yes" xml:space="preserve">
          <source>GetWeek</source>
          <target state="translated">GetWeek</target>
        </trans-unit>
        <trans-unit id="b1f08071cdcc6fbf37da9c2cb680ecaa83720d89" translate="yes" xml:space="preserve">
          <source>GetWeek(datetime)</source>
          <target state="translated">GetWeek(datetime)</target>
        </trans-unit>
        <trans-unit id="535b65cc823f05d8dee165e5013a86a55c020e85" translate="yes" xml:space="preserve">
          <source>GetWeekYear</source>
          <target state="translated">GetWeekYear</target>
        </trans-unit>
        <trans-unit id="05f2caa2e1cdd71879407becb731af0dcee8c734" translate="yes" xml:space="preserve">
          <source>GetWeekYear(datetime)</source>
          <target state="translated">GetWeekYear(datetime)</target>
        </trans-unit>
        <trans-unit id="834cef9635aab01a61de7d362e8845f769065b31" translate="yes" xml:space="preserve">
          <source>GetYear</source>
          <target state="translated">GetYear</target>
        </trans-unit>
        <trans-unit id="fb7ba0f88bff662f921c57e03488fa999f79c2f9" translate="yes" xml:space="preserve">
          <source>GetYear(datetime)</source>
          <target state="translated">GetYear(datetime)</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="4682593736b76df959401b0677e46c3da95e5f88" translate="yes" xml:space="preserve">
          <source>Given a field named alpha whose value is ABCDEF, to return substring BCD use this statement: SUBSTRING(alpha,1,4). Note that 1 is the index of B (the first character of the substring) and 4 is the index of E (the character &lt;em&gt;following&lt;/em&gt; the last character of the substring).</source>
          <target state="translated">给定一个名为alpha的字段，其值为ABCDEF，要返回子字符串BCD，请使用以下语句：SUBSTRING（alpha，1,4）。请注意，1是B（子字符串的第一个字符）的索引，而4是E（子字符串的最后一个字符&lt;em&gt;之后&lt;/em&gt;的字符）的索引。</target>
        </trans-unit>
        <trans-unit id="2904ccdb85701307c7a4cf0211c6c673432f8e03" translate="yes" xml:space="preserve">
          <source>Given relation A above, the three fields are separated out in this table.</source>
          <target state="translated">给出上面的关系A,这三个字段在本表中是分开的。</target>
        </trans-unit>
        <trans-unit id="5a460e02a6c7ad51f55a1454d1e43a85fd04b53c" translate="yes" xml:space="preserve">
          <source>Given this {$1, $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">给定这个{$1,$2}猪创建了这个{($1),($2)}有两个元组的袋子。</target>
        </trans-unit>
        <trans-unit id="819d769c6789870f4f6ec3bd99567803b29a16b7" translate="yes" xml:space="preserve">
          <source>Given this {($1), $2} Pig creates this {($1), ($2)} a bag with two tuples</source>
          <target state="translated">给定这个{($1),$2}猪创建这个{($1),($2)}有两个元组的袋子。</target>
        </trans-unit>
        <trans-unit id="7b8a3b30656b5b8d1c274bf06cf27e2edc4a7002" translate="yes" xml:space="preserve">
          <source>Given this {($1, $2)} Pig creates this {($1, $2)} a bag with a single tuple</source>
          <target state="translated">给定这个{(1元,2元)},Pig创建这个{(1元,2元)}一个带有单个元组的袋子。</target>
        </trans-unit>
        <trans-unit id="c18327c070894ced2aa384e5bac6ad7ebbd23172" translate="yes" xml:space="preserve">
          <source>Groovy to Pig</source>
          <target state="translated">Groovy to Pig</target>
        </trans-unit>
        <trans-unit id="671afc89df0401f9442ee7ad8b3683045e599c39" translate="yes" xml:space="preserve">
          <source>Group/Organization and Version are optional fields. In such cases you can leave them blank.</source>
          <target state="translated">组/组织和版本是可选的字段。在这种情况下,您可以将它们留空。</target>
        </trans-unit>
        <trans-unit id="748922032ec9b2f255ede26d965bccd104ad8a43" translate="yes" xml:space="preserve">
          <source>GroupByConstParallelSetter</source>
          <target state="translated">GroupByConstParallelSetter</target>
        </trans-unit>
        <trans-unit id="6ac2bc105d01b75f0cb6647c28ad7b1ded321074" translate="yes" xml:space="preserve">
          <source>Grouped and ordered data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</source>
          <target state="translated">分组和排序数据&amp;ndash;保证将相同分组密钥的数据连续提供给流应用程序。此外，保证组中的数据按提供的辅助键排序。</target>
        </trans-unit>
        <trans-unit id="8cb388e32ba9398b3d8e495be2290836a832d3ca" translate="yes" xml:space="preserve">
          <source>Grouped data &amp;ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</source>
          <target state="translated">分组数据&amp;ndash;保证将相同分组密钥的数据连续提供给流应用程序</target>
        </trans-unit>
        <trans-unit id="20439eb031c2c2b9f6f2b1f7678cd259da8c350d" translate="yes" xml:space="preserve">
          <source>Groups the data in one or more relations.</source>
          <target state="translated">在一个或多个关系中对数据进行分组。</target>
        </trans-unit>
        <trans-unit id="f5b29066a94b56a4df47b36a243e361e26fd8c0a" translate="yes" xml:space="preserve">
          <source>HBaseStorage</source>
          <target state="translated">HBaseStorage</target>
        </trans-unit>
        <trans-unit id="bc02175406f48d300473a8fc281831d54e6647b9" translate="yes" xml:space="preserve">
          <source>HBaseStorage stores and loads data from HBase. The function takes two arguments. The first argument is a space seperated list of columns. The second optional argument is a space seperated list of options. Column syntax and available options are listed above. Note that HBaseStorage always disable split combination.</source>
          <target state="translated">HBaseStorage存储和加载HBase中的数据。该函数需要两个参数。第一个参数是一个以空格分隔的列列表。第二个可选参数是一个用空格分隔的选项列表。上面列出了列语法和可用选项。注意,HBaseStorage总是禁用拆分组合。</target>
        </trans-unit>
        <trans-unit id="42e829762cee04a70bc5305f66fd119de2d0708d" translate="yes" xml:space="preserve">
          <source>HBaseStorage('columns', ['options'])</source>
          <target state="translated">HBaseStorage('columns',['options'])</target>
        </trans-unit>
        <trans-unit id="a681ca832e37b54f22d309ff4273f4866e57dab0" translate="yes" xml:space="preserve">
          <source>Hadoop configuration files (include pig-cluster-hadoop-site.xml)</source>
          <target state="translated">Hadoop 配置文件(包括 pig-cluster-hadoop-site.xml)。</target>
        </trans-unit>
        <trans-unit id="020d890f6143875ea62437b4701c7f2b8c694a7e" translate="yes" xml:space="preserve">
          <source>Hadoop counters are easily accessible within EvalFunc by using PigStatusReporter object. Here is one example:</source>
          <target state="translated">通过使用PigStatusReporter对象,可以在EvalFunc中轻松访问Hadoop计数器。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="efd0ea6d637892905e05f7688a0e68aa55230d64" translate="yes" xml:space="preserve">
          <source>Hadoop properties are not interpreted by Pig but are passed directly to Hadoop. Any Hadoop property can be passed this way.</source>
          <target state="translated">Hadoop属性不被Pig解释,而是直接传递给Hadoop。任何Hadoop属性都可以通过这种方式传递。</target>
        </trans-unit>
        <trans-unit id="4c073bed947ef004c13b391708120392ca11dadb" translate="yes" xml:space="preserve">
          <source>Handling Compression</source>
          <target state="translated">处理压缩</target>
        </trans-unit>
        <trans-unit id="4f90cbd026c5d20793d9146514d003112f491dc9" translate="yes" xml:space="preserve">
          <source>Handling null values in dimensions</source>
          <target state="translated">处理尺寸中的空值</target>
        </trans-unit>
        <trans-unit id="456113f4880e946d95b861c54ca030a6ccd9d9bc" translate="yes" xml:space="preserve">
          <source>Has no effect.</source>
          <target state="translated">没有效果。</target>
        </trans-unit>
        <trans-unit id="ae32223dae550e038f070d4468e48d2258fd9abe" translate="yes" xml:space="preserve">
          <source>Hash-based Aggregation in Map Task</source>
          <target state="translated">在地图任务中基于哈希值的聚合算法</target>
        </trans-unit>
        <trans-unit id="41e875e1fcc46eff88f8e5016b5fc7b546a006fe" translate="yes" xml:space="preserve">
          <source>Hash-based aggregation has been shown to improve the speed of group-by operations by up to 50%. However, since this is a very new feature, it is currently turned OFF by default. To turn it ON, set the property pig.exec.mapPartAgg to true.</source>
          <target state="translated">基于哈希值的聚合已经被证明可以将逐组操作的速度提高50%。然而,由于这是一个非常新的功能,它目前默认是关闭的。要打开它,请将属性 pig.exec.mapPartAgg 设置为 true。</target>
        </trans-unit>
        <trans-unit id="2c2640b5898454356e628151c15672d38e055e19" translate="yes" xml:space="preserve">
          <source>Having a deterministic schema is very powerful; however, sometimes it comes at the cost of performance. Consider the following example:</source>
          <target state="translated">拥有一个确定性的模式是非常强大的;然而,有时它是以性能为代价的。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="bfef818e148e3b8356ff2f774f2b9ee7df4e0e3b" translate="yes" xml:space="preserve">
          <source>Here D will be splitted into:</source>
          <target state="translated">在这里,D将被分割成。</target>
        </trans-unit>
        <trans-unit id="5b126cd838c032776e841c16e4e7635096eb5aff" translate="yes" xml:space="preserve">
          <source>Here Python UDFs means C Python UDFs. It uses python command line to run the Python UDFs. It is different than Jython, which relies on Jython library. Instead, it streams the data in and out of the python process. The implementation mechanism is completely different than Jython.</source>
          <target state="translated">这里的Python UDFs是指C Python UDFs。它使用python命令行来运行Python UDFs。它与Jython不同,Jython依赖于Jython库。相反,它是在python进程中流转数据,并将数据流出。实现机制与Jython完全不同。</target>
        </trans-unit>
        <trans-unit id="5f2c08c455258fee101fb67d0b42f00bc1baf24c" translate="yes" xml:space="preserve">
          <source>Here are two complete Ruby UDF samples.</source>
          <target state="translated">这里有两个完整的Ruby UDF样本。</target>
        </trans-unit>
        <trans-unit id="b8dcfe1b81cf245877e8f5d58903219442973ef1" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Avro values to Pig:</source>
          <target state="translated">以下是AvroStorage如何将Avro值翻译成Pig。</target>
        </trans-unit>
        <trans-unit id="6e9d5893cd22a1028524ead1e3803b984d8322c6" translate="yes" xml:space="preserve">
          <source>Here is how AvroStorage translates Pig values to Avro:</source>
          <target state="translated">以下是AvroStorage如何将Pig值翻译成Avro。</target>
        </trans-unit>
        <trans-unit id="d29548e0cb2915ac50ffc61f38a48d8d0a1e70d9" translate="yes" xml:space="preserve">
          <source>Here is the code for SimpleCustomPartitioner:</source>
          <target state="translated">下面是SimpleCustomPartitioner的代码。</target>
        </trans-unit>
        <trans-unit id="8d42a9f211cf946a11b895acfcf50eecca384660" translate="yes" xml:space="preserve">
          <source>Here us a code snippet of the integer version of the MAX function that implements the interface:</source>
          <target state="translated">这里是实现接口的MAX函数的整数版的代码片段。</target>
        </trans-unit>
        <trans-unit id="69363bb44856067aa39c56a08488523df0c874c7" translate="yes" xml:space="preserve">
          <source>Here's the way to think about this in the Hadoop world. The exec function of the Initial class is invoked once for each input tuple by the map process and produces partial results. The exec function of the Intermed class is invoked once by each combiner invocation (which can happen zero or more times) and also produces partial results. The exec function of the Final class is invoked once by the reducer and produces the final result.</source>
          <target state="translated">在Hadoop世界里,是这样考虑的。Initial类的exec函数被map进程对每个输入元组调用一次,并产生部分结果。Intermed类的exec函数被每个组合器调用一次(可以发生零次或多次),也会产生部分结果。Final类的exec函数被reducer调用一次,产生最终结果。</target>
        </trans-unit>
        <trans-unit id="729230c39ce6b3b3af88b635a6fffcb4e16631bf" translate="yes" xml:space="preserve">
          <source>Here's what the multi-query execution does to increase the performance:</source>
          <target state="translated">下面说说多查询执行对提高性能的作用。</target>
        </trans-unit>
        <trans-unit id="d08b502754ac5a29f00b79cc168f4200278b24f3" translate="yes" xml:space="preserve">
          <source>Here, we read the file 'flights.txt' out of HDFS and store the results into the relation A. We extract a unique ID for the flight, its source and destination and the tail number from the given file. When STORE'ing back into Accumulo, we specify the column specifications (in this case, just a column family). It is also important to note that four elements are provided as columns because the first element in the Tuple is used as the row in Accumulo.</source>
          <target state="translated">这里,我们从HDFS中读取文件'flights.txt',并将结果存储到关系A中。我们从给定的文件中提取出航班的唯一ID,它的来源和目的地以及尾数。当stORE'ing回到Accumulo时,我们指定列的规格(在本例中,只是一个列族)。同样需要注意的是,由于Tuple中的第一个元素在Accumulo中被用作行,所以提供了四个元素作为列。</target>
        </trans-unit>
        <trans-unit id="88f4ff51e4104da0415333a640e6fd975154c6c2" translate="yes" xml:space="preserve">
          <source>Hive UDF</source>
          <target state="translated">Hive UDF</target>
        </trans-unit>
        <trans-unit id="f9ce0b773269b974a71ef6d3a6fce10ebf9a16ec" translate="yes" xml:space="preserve">
          <source>Hive UDF name. This can be a fully qualified class name of the Hive UDF/UDTF/UDAF class, or a registered short name in Hive FunctionRegistry (most Hive builtin UDF does that)</source>
          <target state="translated">Hive UDF名称。这可以是Hive UDF/UDTF/UDAF类的完全限定的类名,或者是在Hive FunctionRegistry中注册的简称(大多数Hive内置的UDF都是这样做的)。</target>
        </trans-unit>
        <trans-unit id="c5b9d1b74a891758ac6053ce9ef2656a452abb0a" translate="yes" xml:space="preserve">
          <source>HiveUDAF</source>
          <target state="translated">HiveUDAF</target>
        </trans-unit>
        <trans-unit id="a7bf7f603ccf4f8e5fd4d24a6b4801fd41785386" translate="yes" xml:space="preserve">
          <source>HiveUDAF with constant parameter</source>
          <target state="translated">HiveUDAF,参数不变</target>
        </trans-unit>
        <trans-unit id="6be8ec051a4a129cb854a01427a634a2d62c1beb" translate="yes" xml:space="preserve">
          <source>HiveUDF</source>
          <target state="translated">HiveUDF</target>
        </trans-unit>
        <trans-unit id="1f5b904784c7a83976cd781e900ba741b08bcc25" translate="yes" xml:space="preserve">
          <source>HiveUDF(name[, constant parameters])</source>
          <target state="translated">HiveUDF(name[,常量参数])</target>
        </trans-unit>
        <trans-unit id="57b25bdd42a8bfd89cde5d17150a800bbdd82d46" translate="yes" xml:space="preserve">
          <source>HiveUDF, HiveUDAF, HiveUDTF share the same syntax.</source>
          <target state="translated">HiveUDF、HiveUDAF、HiveUDTF共享相同的语法。</target>
        </trans-unit>
        <trans-unit id="b176b48a267bfe0c13f39e147ccb976626dc67ed" translate="yes" xml:space="preserve">
          <source>HiveUDTF</source>
          <target state="translated">HiveUDTF</target>
        </trans-unit>
        <trans-unit id="0c649e2ec017b5914ee8ac547ddec61818f46581" translate="yes" xml:space="preserve">
          <source>Horizontal ellipsis points indicate that you can repeat a portion of the code.</source>
          <target state="translated">水平省略号点表示可以重复一部分代码。</target>
        </trans-unit>
        <trans-unit id="a3c07a08d24fc29656223d7ad5fe33d21d2ff9db" translate="yes" xml:space="preserve">
          <source>HoursBetween</source>
          <target state="translated">HoursBetween</target>
        </trans-unit>
        <trans-unit id="d85ad836458e49eb6188932c56b1a9f36287859a" translate="yes" xml:space="preserve">
          <source>HoursBetween(datetime1, datetime2)</source>
          <target state="translated">小时之间(datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="100cb0b9b76cf128bd36c57de623e9519f3f1a9c" translate="yes" xml:space="preserve">
          <source>How it Works</source>
          <target state="translated">它是如何工作的</target>
        </trans-unit>
        <trans-unit id="5a512c42842d315c68d30298afe72953eec16d9c" translate="yes" xml:space="preserve">
          <source>How to Use a Simple Eval Function</source>
          <target state="translated">如何使用一个简单的Eval函数</target>
        </trans-unit>
        <trans-unit id="859136ad08aa1c154af53341ef9e723eb18c7e39" translate="yes" xml:space="preserve">
          <source>How to Write a Simple Eval Function</source>
          <target state="translated">如何编写一个简单的Eval函数</target>
        </trans-unit>
        <trans-unit id="d404f08d8481d9ea8efead4d447a2938101dcb8f" translate="yes" xml:space="preserve">
          <source>How to enable Tez</source>
          <target state="translated">如何启用Tez</target>
        </trans-unit>
        <trans-unit id="9a04bea978466940a152fd73b98e9fbace4a67cf" translate="yes" xml:space="preserve">
          <source>However, if you further process relation X (Y = FILTER X BY $0 &amp;gt; 1;) there is no guarantee that the data will be processed in the order you originally specified (descending).</source>
          <target state="translated">但是，如果进一步处理关系X（Y = FILTER X BY $ 0&amp;gt; 1;），则不能保证将按照您最初指定的顺序（降序）处理数据。</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="74d77878ac50a503b2a5ae4d6f5d12f747eb630d" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE</source>
          <target state="translated">ILLUSTRATE</target>
        </trans-unit>
        <trans-unit id="4cf3dfa0284dcad8ef3078afd5ea4e09752b0fad" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE is based on an example generator (see &lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;Generating Example Data for Dataflow Programs&lt;/a&gt;). The algorithm works by retrieving a small sample of the input data and then propagating this data through the pipeline. However, some operators, such as JOIN and FILTER, can eliminate tuples from the data - and this could result in no data following through the pipeline. To address this issue, the algorithm will automatically generate example data, in near real-time. Thus, you might see data propagating through the pipeline that was not found in the original input data, but this data changes nothing and ensures that you will be able to examine the semantics of your Pig Latin statements.</source>
          <target state="translated">ILLUSTRATE基于示例生成器（请参阅&lt;a href=&quot;http://research.yahoo.com/files/paper_5.pdf&quot;&gt;为数据流程序生成示例数据&lt;/a&gt;）。该算法的工作原理是检索输入数据的一小部分样本，然后通过管道传播该数据。但是，某些运算符（例如JOIN和FILTER）可以从数据中消除元组-这可能导致没有数据跟随流水线。为了解决这个问题，该算法将自动近实时地生成示例数据。因此，您可能会看到在原始输入数据中找不到的，通过管道传播的数据，但是此数据没有任何变化，并确保您能够检查Pig Latin语句的语义。</target>
        </trans-unit>
        <trans-unit id="3eac28999aea33c81cb98bea80ea6fcce043fe8e" translate="yes" xml:space="preserve">
          <source>ILLUSTRATE {alias | -script scriptfile};</source>
          <target state="translated">ILLUSTRATE {alias | -script scriptfile}。</target>
        </trans-unit>
        <trans-unit id="b034fe864d511351df0ee4a7cfd55942cb62d4ba" translate="yes" xml:space="preserve">
          <source>IMPORT</source>
          <target state="translated">IMPORT</target>
        </trans-unit>
        <trans-unit id="89fff016f6b8ebc8add59a5f8f96f47f4a92e5df" translate="yes" xml:space="preserve">
          <source>IMPORT 'file-with-macro';</source>
          <target state="translated">IMPORT 'file-with-macro'。</target>
        </trans-unit>
        <trans-unit id="1167b0e824163ea9e215a382f87b8f12fbf29970" translate="yes" xml:space="preserve">
          <source>IMPORT (macros)</source>
          <target state="translated">导入(宏)</target>
        </trans-unit>
        <trans-unit id="5badbc082509a68348d1b2de0b506786bd7658d9" translate="yes" xml:space="preserve">
          <source>IMPORT adds the macro definitions to the Pig Latin namespace; these macros can then be invoked as if they were defined in the same file.</source>
          <target state="translated">IMPORT 将宏定义添加到 Pig Latin 命名空间;然后可以调用这些宏,就像它们是在同一个文件中定义的一样。</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="059d298a40b3fec4385406229f5af45d61612a3d" translate="yes" xml:space="preserve">
          <source>IN (expression)</source>
          <target state="translated">IN(表情)</target>
        </trans-unit>
        <trans-unit id="c55aaf120352287dba10abc369c393e2d067b025" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to help reduce the need for multiple OR conditions.</source>
          <target state="translated">IN运算符允许您轻松地测试一个表达式是否匹配值列表中的任何值。它用于帮助减少对多个OR条件的需求。</target>
        </trans-unit>
        <trans-unit id="4d85ce819eaff4a81308dc90de69623bf9480d8a" translate="yes" xml:space="preserve">
          <source>IN operator allows you to easily test if an expression matches any value in a list of values. It is used to reduce the need for multiple OR conditions.</source>
          <target state="translated">IN运算符允许您轻松地测试一个表达式是否与一个值列表中的任何值相匹配。它用于减少对多个OR条件的需求。</target>
        </trans-unit>
        <trans-unit id="3f22e0a8543ace135a5f509674fc4700b89a5896" translate="yes" xml:space="preserve">
          <source>IN operator is equivalent to nested OR operators.</source>
          <target state="translated">IN运算符相当于嵌套的OR运算符。</target>
        </trans-unit>
        <trans-unit id="d219b4dc13cdee432eb9cf599decd114b681ee36" translate="yes" xml:space="preserve">
          <source>INDEXOF</source>
          <target state="translated">INDEXOF</target>
        </trans-unit>
        <trans-unit id="2c95e05e2e3fc975e680d037087c38ecaa793399" translate="yes" xml:space="preserve">
          <source>INDEXOF(string, 'character', startIndex)</source>
          <target state="translated">INDEXOF(string,'character',startIndex)</target>
        </trans-unit>
        <trans-unit id="091cedb09a5345c158de5c9b9ce5201d93e5d038" translate="yes" xml:space="preserve">
          <source>INPUT &amp;ndash; Keyword.</source>
          <target state="translated">输入-关键字。</target>
        </trans-unit>
        <trans-unit id="e2e6f67f49f77e6f17a5a4a70377d85084890b16" translate="yes" xml:space="preserve">
          <source>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] &amp;hellip;] )</source>
          <target state="translated">输入（{stdin |'path'} [使用序列化器] [，{stdin |'path'} [使用序列化器...]]</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="0fe012d40367d7664e9b3bf78c05516e6b49cdfd" translate="yes" xml:space="preserve">
          <source>Identifiers include the names of relations (aliases), fields, variables, and so on. In Pig, identifiers start with a letter and can be followed by any number of letters, digits, or underscores.</source>
          <target state="translated">标识符包括关系(别名)、字段、变量等的名称。在Pig中,标识符以字母开头,后面可以跟任何数量的字母、数字或下划线。</target>
        </trans-unit>
        <trans-unit id="33cf76ea88eecf41631c2c6696ed2f52f782942a" translate="yes" xml:space="preserve">
          <source>If A is a relation (outer bag), a FOREACH statement could look like this.</source>
          <target state="translated">如果A是一个关系(外袋),FOREACH语句可以是这样的。</target>
        </trans-unit>
        <trans-unit id="afe0e53cb4d9d90b6ba1aca74a93d2f8445ecde1" translate="yes" xml:space="preserve">
          <source>If A is an inner bag, a FOREACH statement could look like this.</source>
          <target state="translated">如果A是一个内袋,FOREACH语句可以是这样的。</target>
        </trans-unit>
        <trans-unit id="3c63da8e13e1306df1c5329f267b1cf013f00c39" translate="yes" xml:space="preserve">
          <source>If CUBE and ROLLUP operations are used together, the output groups will be the cross product of all groups generated by cube and rollup operation. If there are m dimensions in cube operations and n dimensions in rollup operation then overall number of combinations will be (2^m) * (n+1).</source>
          <target state="translated">如果CUBE和ROLLUP操作一起使用,输出的组将是所有由cube和rollup操作产生的组的交叉乘积。如果立方体操作中有m个维度,而卷积操作中有n个维度,那么总的组合数将是(2^m)*(n+1)。</target>
        </trans-unit>
        <trans-unit id="53995723b5b706a6616e5f264aad6a4b93b46fe0" translate="yes" xml:space="preserve">
          <source>If MyUDF is algebraic, the query will use combiner and run much faster. You can run explain command on your query to make sure that combiner is used.</source>
          <target state="translated">如果MyUDF是代数式的,查询将使用combiner,运行速度会快很多。你可以在你的查询中运行explain命令来确定是否使用了组合器。</target>
        </trans-unit>
        <trans-unit id="fbc88faf080a72258643a84cf95f10e149e13ae3" translate="yes" xml:space="preserve">
          <source>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the &lt;a href=&quot;#types-table-add&quot;&gt;Types Table for addition and subtraction&lt;/a&gt;).</source>
          <target state="translated">如果Pig无法通过隐式强制转换解决不兼容的类型，则会发生错误。例如，您不能添加chararray和float（&lt;a href=&quot;#types-table-add&quot;&gt;有关加法和减法，&lt;/a&gt;请参见类型表）。</target>
        </trans-unit>
        <trans-unit id="e01f1d7383a02a96bedbc379dd0c0288bc379a73" translate="yes" xml:space="preserve">
          <source>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on).</source>
          <target state="translated">如果Pig确定需要自动运送绝对路径,它根本不会运送,因为没有办法将文件运送到必要的位置(缺乏权限等)。</target>
        </trans-unit>
        <trans-unit id="e62658035d80920f5b1abb78f7987725661dad47" translate="yes" xml:space="preserve">
          <source>If Pig is unable to process the expression, Pig returns an exception.</source>
          <target state="translated">如果Pig无法处理该表达式,Pig会返回一个异常。</target>
        </trans-unit>
        <trans-unit id="3816a983fff2acee696300df0a392ba6e758130e" translate="yes" xml:space="preserve">
          <source>If a UDF returns a tuple or a bag and schema information is not provided, Pig assumes that the tuple contains a single field of type bytearray. If this is not the case, then not specifying the schema can cause failures. We look at this next.</source>
          <target state="translated">如果一个 UDF 返回一个元组或袋,而没有提供模式信息,Pig 假设元组包含一个类型为 bytearray 的单一字段。如果不是这种情况,那么不指定模式就会导致失败。我们接下来看看这个问题。</target>
        </trans-unit>
        <trans-unit id="486e4f66991631e2d049a07741fd4d7ef1bfe823" translate="yes" xml:space="preserve">
          <source>If a custom loader using a text-based InputFormat or a file-based InputFormat would like to read files in all subdirectories under a given input directory recursively, then it should use the PigTextInputFormat and PigFileInputFormat classes provided in org.apache.pig.backend.hadoop.executionengine.mapReduceLayer. The Pig InputFormat classes work around a current limitation in the Hadoop TextInputFormat and FileInputFormat classes which only read one level down from the provided input directory. For example, if the input in the load statement is 'dir1' and there are subdirs 'dir2' and 'dir2/dir3' beneath dir1, the Hadoop TextInputFormat and FileInputFormat classes read the files under 'dir1' only. Using PigTextInputFormat or PigFileInputFormat (or by extending them), the files in all the directories can be read.</source>
          <target state="translated">如果使用基于文本的InputFormat或基于文件的InputFormat的自定义加载器希望递归地读取给定输入目录下所有子目录中的文件,那么它应该使用org.apache.pig.backend.hadoop.executeengine.mapReduceLayer中提供的PigTextInputFormat和PigFileInputFormat类。Pig InputFormat 类可以绕过 Hadoop TextInputFormat 和 FileInputFormat 类当前的限制,因为它们只能从提供的输入目录向下读取一级。例如,如果加载语句中的输入是'dir1',而dir1下面有子目录'dir2'和'dir2/dir3',那么Hadoop TextInputFormat和FileInputFormat类只读取'dir1'下面的文件。使用PigTextInputFormat或PigFileInputFormat(或通过扩展它们),可以读取所有目录下的文件。</target>
        </trans-unit>
        <trans-unit id="a4794078ab3e12dc82064bb4f0a80d07b3c59c8f" translate="yes" xml:space="preserve">
          <source>If a function is algebraic but can be used in a FOREACH statement with accumulator functions, it needs to implement the Accumulator interface in addition to the Algebraic interface.</source>
          <target state="translated">如果一个函数是代数的,但可以在FOREACH语句中使用累加器函数,那么除了代数接口外,它还需要实现累加器接口。</target>
        </trans-unit>
        <trans-unit id="ccda3daa249c8bc65b4370e66326a311939c526e" translate="yes" xml:space="preserve">
          <source>If a loader implements IndexableLoadFunc, or implements OrderedLoadFunc and CollectableLoadFunc, its input splits won't be subject to possible combinations.</source>
          <target state="translated">如果一个加载器实现了IndexableLoadFunc,或者实现了OrderedLoadFunc和CollectableLoadFunc,它的输入分割就不会受到可能的组合的影响。</target>
        </trans-unit>
        <trans-unit id="d22536397a6526bff16d2b44ae5ad32b2dad3166" translate="yes" xml:space="preserve">
          <source>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</source>
          <target state="translated">如果模式被定义为加载语句的一部分,加载函数将尝试执行模式。如果数据不符合模式,加载器将产生一个空值或错误。</target>
        </trans-unit>
        <trans-unit id="d20b21a086aff45ff998ceac8189b33486fbc4c6" translate="yes" xml:space="preserve">
          <source>If a script has dependencies on the execution order outside of what Pig knows about, execution may fail.</source>
          <target state="translated">如果脚本的执行顺序有Pig所不知道的依赖性,执行可能会失败。</target>
        </trans-unit>
        <trans-unit id="c60b8394e3c8ca844c4dd6c95b31ff82395596c7" translate="yes" xml:space="preserve">
          <source>If a script with a alias is specified, it will output the plan for the given alias.</source>
          <target state="translated">如果指定了一个带有别名的脚本,它将输出给定别名的计划。</target>
        </trans-unit>
        <trans-unit id="c929a573b654a6447af3bebd28ecf3072a0bfa7e" translate="yes" xml:space="preserve">
          <source>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce).</source>
          <target state="translated">如果指定了一个没有别名的脚本,它将输出整个执行图(逻辑、物理或映射还原)。</target>
        </trans-unit>
        <trans-unit id="7b66f4af28f8442dd36e47f974b35d46ae1ab601" translate="yes" xml:space="preserve">
          <source>If a type is declared then ALL values in the map must be of this type.</source>
          <target state="translated">如果声明了一个类型,那么地图中的所有值都必须是这个类型。</target>
        </trans-unit>
        <trans-unit id="a9165157e4c228dc6b25213c7bef47de768cebba" translate="yes" xml:space="preserve">
          <source>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</source>
          <target state="translated">如果不支持显式转码,就会出现一个错误。例如,你不能将一个chararray转为int。</target>
        </trans-unit>
        <trans-unit id="1c8c61b8e893dc2134f7b454bd561bcf24bcadc6" translate="yes" xml:space="preserve">
          <source>If any subexpression is null, the resulting expression is null.</source>
          <target state="translated">如果任何子表达式为空,则产生的表达式为空。</target>
        </trans-unit>
        <trans-unit id="bb9518c418a6a42b64160ff3fdffbdf9e983c161" translate="yes" xml:space="preserve">
          <source>If arguments are not bags, an IOException is thrown.</source>
          <target state="translated">如果参数不是袋子,就会抛出一个IOException。</target>
        </trans-unit>
        <trans-unit id="67c0548636f03fb391aff763f50ae24a819f4ca2" translate="yes" xml:space="preserve">
          <source>If desired, custom logic can also be implemented for error handling by creating a subclass of MonitoredUDFExecutor.ErrorCallback, and overriding its handleError and/or handleTimeout methods. Both of those methods are static, and are passed in the instance of the EvalFunc that produced an exception, as well as an exception, so you may use any state you have in the UDF to process the errors as desired. The default behavior is to increment Hadoop counters every time an error is encountered. Once you have an implementation of the ErrorCallback that performs your custom logic, you can provide it in the annotation:</source>
          <target state="translated">如果需要,还可以通过创建MonitoredUDFExecutor.ErrorCallback的子类,并覆盖其handleError和/或handleTimeout方法,实现自定义逻辑的错误处理。这两个方法都是静态的,并且在产生异常的EvalFunc实例中传递了一个异常,以及一个异常,因此您可以根据需要使用UDF中的任何状态来处理错误。默认的行为是每次遇到错误时都会递增 Hadoop 计数器。一旦你有了执行你的自定义逻辑的ErrorCallback的实现,你可以在注释中提供它。</target>
        </trans-unit>
        <trans-unit id="a9eef31189a46ca896e1a11d04cfdc69be907574" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the result is null.</source>
          <target state="translated">如果任一子表达式为空,则结果为空。</target>
        </trans-unit>
        <trans-unit id="fbb8787a10e9277578f3bacf3c583933a72af49a" translate="yes" xml:space="preserve">
          <source>If either subexpression is null, the resulting expression is null.</source>
          <target state="translated">如果任何一个子表达式为空,则产生的表达式为空。</target>
        </trans-unit>
        <trans-unit id="df9492dcb135b34471ac4c01597f6c3e6e9d0c72" translate="yes" xml:space="preserve">
          <source>If either the string being matched against or the string defining the match is null, the result is null.</source>
          <target state="translated">如果被匹配的字符串或定义匹配的字符串为空,则结果为空。</target>
        </trans-unit>
        <trans-unit id="7c7b8337ae5bc3235aee39b3bf00c4a3b18c0f1e" translate="yes" xml:space="preserve">
          <source>If field_delimiter is null or not passed, the following will be used as delimiters: space [ ], double quote [ &quot; ], coma [ , ] parenthesis [ () ], star [ * ].</source>
          <target state="translated">如果field_delimiter为空或未被传递,则以下内容将被用作定界符:空格[]、双引号[&quot;]、逗号[,]括号[()]、星号[*]。</target>
        </trans-unit>
        <trans-unit id="d38b38abb97f4eb1e0dcf9186921de58382f8118" translate="yes" xml:space="preserve">
          <source>If invoking Pig in Java, there is change in PigStats and PigProgressNotificationListener if using PigRunner.run(), check &lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Statistics&lt;/a&gt; and &lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Notification Listener&lt;/a&gt;</source>
          <target state="translated">如果使用Java调用Pig，如果使用PigRunner.run（），则PigStats和PigProgressNotificationListener发生变化，请检查&lt;a href=&quot;test#pig-statistics&quot;&gt;Pig Statistics&lt;/a&gt;和&lt;a href=&quot;test#ppnl&quot;&gt;Pig Progress Notification Listener&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="94ca295cf76f515a0109ec429d1f4a34670cbbe4" translate="yes" xml:space="preserve">
          <source>If load statement specify a schema, Pig will convert the complex type according to schema. If conversion fails, the affected item will be null (see &lt;a href=&quot;basic#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;).</source>
          <target state="translated">如果load语句指定了模式，Pig将根据模式转换复杂类型。如果转换失败，则受影响的项目将为null（请参见&lt;a href=&quot;basic#nulls&quot;&gt;Nulls和Pig Latin&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9f3c3c0240ae80e56e35fc2fe724ffaf7f5b93b5" translate="yes" xml:space="preserve">
          <source>If neither &quot;set default parallel&quot; nor the PARALLEL clause are used, Pig sets the number of reducers using a heuristic based on the size of the input data. You can set the values for these properties:</source>
          <target state="translated">如果既不使用 &quot;设置默认并行&quot;,也不使用parallel子句,Pig会根据输入数据的大小,使用启发式方法设置减速器的数量。你可以为这些属性设置值。</target>
        </trans-unit>
        <trans-unit id="c1dbfad22027ead0b9c53033155be2cdf92f70af" translate="yes" xml:space="preserve">
          <source>If no script is given:</source>
          <target state="translated">如果没有给出脚本。</target>
        </trans-unit>
        <trans-unit id="3c30b8a15458b41c3c14a039867b1afab3f19551" translate="yes" xml:space="preserve">
          <source>If null, bag arguments are replaced by empty bags.</source>
          <target state="translated">如果为空,则用空袋代替袋参数。</target>
        </trans-unit>
        <trans-unit id="1f86825c5ae24539f35706c23d25d87bce6d588c" translate="yes" xml:space="preserve">
          <source>If one is running Pig in Tez mode (or both Tez/MapReduce mode), should pass PigTezProgressNotificationListener which extends PigProgressNotificationListener to PigRunner.run() to make sure to get notification in both Tez mode or MapReduce mode.</source>
          <target state="translated">如果在Tez模式下运行Pig(或同时运行Tez/MapReduce模式),应该将PigTezProgressNotificationListener这个扩展的PigProgressNotificationListener传递给PigRunner.run(),以确保在Tez模式或MapReduce模式下都能得到通知。</target>
        </trans-unit>
        <trans-unit id="a520e683b22094fd77e688c9dcd1fed6eddf94bb" translate="yes" xml:space="preserve">
          <source>If one of the data sets is small enough to fit into memory, a Replicated Join is very likely to provide better performance.</source>
          <target state="translated">如果其中一个数据集小到足以装进内存,Replicated Join很可能提供更好的性能。</target>
        </trans-unit>
        <trans-unit id="207190487fec91fe50bf8a8e561b556722ac4451" translate="yes" xml:space="preserve">
          <source>If only one argument is given, the field is delimited with underscore characters</source>
          <target state="translated">如果只给了一个参数,则该字段用下划线字符分隔。</target>
        </trans-unit>
        <trans-unit id="979bda1c695b72deb2de992c0dbc8fd750122f17" translate="yes" xml:space="preserve">
          <source>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</source>
          <target state="translated">如果在Pig命令行或参数文件中指定了参数,脚本应该为命令行或参数文件中的每个para_name包含一个$param_name。</target>
        </trans-unit>
        <trans-unit id="b3bd4de29e52beea43d5160ea3b5d527766906ff" translate="yes" xml:space="preserve">
          <source>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</source>
          <target state="translated">如果使用预处理器语句指定了参数,脚本应该包含%declare或%default。</target>
        </trans-unit>
        <trans-unit id="52ce5e98f919ecf8fe4edf9131ddd0faddc8d6f2" translate="yes" xml:space="preserve">
          <source>If sort is provided by the loader, rather than an explicit Order operation, the right-side loader must implement either the {OrderedLoadFunc} interface or {IndexableLoadFunc} interface.</source>
          <target state="translated">如果排序是由加载器提供的,而不是显式的Order操作,右侧加载器必须实现{OrderedLoadFunc}接口或{IndexableLoadFunc}接口。</target>
        </trans-unit>
        <trans-unit id="aee0b5384005bdfb9e581a456be8ae8427f85fcd" translate="yes" xml:space="preserve">
          <source>If tagPath or tagFile option is specified, PigStorage will add a pseudo-column INPUT_FILE_PATH or INPUT_FILE_NAME respectively to the beginning of the record. As the name suggests, it is the input file path/name containing this particular record. Please note tagsource is deprecated.</source>
          <target state="translated">如果指定了tagPath或tagFile选项,PigStorage会在记录的开头分别添加一个伪列INPUT_FILE_PATH或INPUT_FILE_NAME。顾名思义,它是包含这个特定记录的输入文件路径/名称。请注意,tagsource已经过时了。</target>
        </trans-unit>
        <trans-unit id="0d16362f5232337bd67ea5e2e860c60236bd2764" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used, enclose the schema in parentheses.</source>
          <target state="translated">如果使用&lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt;运算符，则将模式括在括号中。</target>
        </trans-unit>
        <trans-unit id="0caf7a1673c2590cb133f449af480656dad1cb8b" translate="yes" xml:space="preserve">
          <source>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</source>
          <target state="translated">如果没有使用FLATTEN操作符,不要把模式用括号括起来。</target>
        </trans-unit>
        <trans-unit id="8742c01ca7dfdb8c7b97679f58a80857cfe6e74b" translate="yes" xml:space="preserve">
          <source>If the STORE and LOAD both had exact matching file paths, Pig will recognize the implicit dependency and launch two different mapreduce jobs/Tez DAGs with the second job depending on the output of the first one. exec is not required to be specified in that case.</source>
          <target state="translated">如果STORE和LOAD都有完全匹配的文件路径,Pig会识别隐含的依赖关系,并根据第一个作业的输出,启动两个不同的mapreduce作业/Tez DAG,第二个作业不需要指定exec,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="ce8a9990603bf3420d85f373d9702d4a3cac5619" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default load function PigStorage is used.</source>
          <target state="translated">如果省略USING子句,则使用默认的加载函数PigStorage。</target>
        </trans-unit>
        <trans-unit id="caf383bc86d8a53d213a4ff08b295b5cdb463fbc" translate="yes" xml:space="preserve">
          <source>If the USING clause is omitted, the default store function PigStorage is used.</source>
          <target state="translated">如果省略USING子句,则使用默认的存储函数PigStorage。</target>
        </trans-unit>
        <trans-unit id="8ade11ca523a11122e604fa8fcd322615b76561d" translate="yes" xml:space="preserve">
          <source>If the build is successful, you should see the pig.jar file created in that directory.</source>
          <target state="translated">如果构建成功,你应该看到在该目录下创建了pig.jar文件。</target>
        </trans-unit>
        <trans-unit id="2e73841d4f5c17efd8924856bacadb48c1718106" translate="yes" xml:space="preserve">
          <source>If the de-referenced tuple or map is null, returns null.</source>
          <target state="translated">如果去引用的元组或映射为空,则返回空。</target>
        </trans-unit>
        <trans-unit id="136bbc1ae8c1804896ccba758e270481404a38b7" translate="yes" xml:space="preserve">
          <source>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</source>
          <target state="translated">如果流命令上的第一个词是perl或python,Pig假设二进制是它遇到的第一个不以破折号开头的非引号字符串。</target>
        </trans-unit>
        <trans-unit id="2edbaa925c2b4bb7fab3191de0feae3407e8c8ae" translate="yes" xml:space="preserve">
          <source>If the group-by keys used for grouping don't result in a sufficient reduction in the number of records, the performance might be worse with this feature turned ON. To prevent this from happening, the feature turns itself off if the reduction in records sent to combiner is not more than a configurable threshold. This threshold can be set using the property pig.exec.mapPartAgg.minReduction. It is set to a default value of 10, which means that the number of records that get sent to the combiner should be reduced by a factor of 10 or more.</source>
          <target state="translated">如果用于分组的按组键不能充分减少记录数量,那么在开启此功能后,性能可能会变差。为了防止这种情况发生,如果发送到 combiner 的记录减少量不超过一个可配置的阈值,该功能就会自动关闭。这个阈值可以使用属性pig.exec.mapPartAgg.minReduction来设置。它被设置为默认值10,这意味着被发送到梳理器的记录数量应该减少10倍或更多。</target>
        </trans-unit>
        <trans-unit id="f0a0dbd61aa62c74fcf75355267ae83889868c65" translate="yes" xml:space="preserve">
          <source>If the input relation has a schema, you can refer to columns by alias rather than by column position. You can also combine aliases and column positions in an expression; for example, &quot;col1 .. $5&quot; is valid.</source>
          <target state="translated">如果输入关系有一个模式,你可以用别名而不是列的位置来引用列。你也可以在一个表达式中结合别名和列位置,例如,&quot;col1 ...$5 &quot;是有效的。</target>
        </trans-unit>
        <trans-unit id="1aceb56e8670ae04161c5161bd71a70daf79faf0" translate="yes" xml:space="preserve">
          <source>If the macro has no return alias, then void must be specified.</source>
          <target state="translated">如果宏没有返回别名,则必须指定void。</target>
        </trans-unit>
        <trans-unit id="ab05a18b7e2fd87f280e1388a3db09480d98d569" translate="yes" xml:space="preserve">
          <source>If the noschema option is NOT specified, and a schema is found, it gets loaded when loading data.</source>
          <target state="translated">如果没有指定noschema选项,并且找到了一个模式,那么在加载数据时,它将被加载。</target>
        </trans-unit>
        <trans-unit id="cc815978d8fbacfa3f024e4ccf2f529fd09fcb51" translate="yes" xml:space="preserve">
          <source>If the parameters of the EvalFunc are all constants, Pig could evaluate the result at compile time. The benefit of evaluating at compile time is performance optimization, and enable certain other optimizations at front end (such as partition pruning, which only allow constant not UDF in filter condition). By default, compile time evaluation is disabled in EvalFunc to prevent potential side effect. To enable it, override allowCompileTimeCalculation. For example:</source>
          <target state="translated">如果EvalFunc的参数都是常量,Pig可以在编译时评估结果。在编译时评估的好处是性能优化,并在前端启用某些其他优化(如分区修剪,只允许在过滤条件下使用常量而不是 UDF)。默认情况下,EvalFunc中编译时评估是被禁用的,以防止潜在的副作用。要启用它,可以覆盖 allowCompileTimeCalculation。例如,在EvalFunc中的编译时间评估被禁用。</target>
        </trans-unit>
        <trans-unit id="37792a4c1c43f548d87fd2c3c9b325971248e022" translate="yes" xml:space="preserve">
          <source>If the query is rewritten to</source>
          <target state="translated">如果将查询重写为</target>
        </trans-unit>
        <trans-unit id="884e911c9fc042d4017b9c9111d9b8041a7952e3" translate="yes" xml:space="preserve">
          <source>If the result value is not a number (NaN), Pig returns null.</source>
          <target state="translated">如果结果值不是一个数字(NaN),Pig返回null。</target>
        </trans-unit>
        <trans-unit id="7c1585043821cee828c177bd1dee01acb15c382d" translate="yes" xml:space="preserve">
          <source>If the result value is null or empty, Pig returns null.</source>
          <target state="translated">如果结果值为空或空,Pig就返回空。</target>
        </trans-unit>
        <trans-unit id="832a57705057f4442db3191d05182bfe04aabc3e" translate="yes" xml:space="preserve">
          <source>If the schema is null, Pig treats all fields as bytearray (in the backend, Pig will determine the real type for the fields dynamically)</source>
          <target state="translated">如果模式为空,Pig将所有字段视为字节数组(在后端,Pig将动态确定字段的真实类型)。</target>
        </trans-unit>
        <trans-unit id="b0b624c38d08281a478732651dc5b82106034b90" translate="yes" xml:space="preserve">
          <source>If the schema of a relation can&amp;rsquo;t be inferred, Pig will just use the runtime data as is and propagate it through the pipeline.</source>
          <target state="translated">如果无法推断出关系的模式，Pig将仅按原样使用运行时数据，并将其通过管道传播。</target>
        </trans-unit>
        <trans-unit id="0e6717986491eb0953097c78d9d3c2a67abe2393" translate="yes" xml:space="preserve">
          <source>If the schema option is NOT specified, a schema will not be written when storing data.</source>
          <target state="translated">如果没有指定模式选项,则在存储数据时不会写入模式。</target>
        </trans-unit>
        <trans-unit id="ff2b36c03367bc79f4d31985e06636e1530acb9a" translate="yes" xml:space="preserve">
          <source>If the schema option is specified, a hidden &quot;.pig_schema&quot; file is created in the output directory when storing data. It is used by PigStorage (with or without -schema) during loading to determine the field names and types of the data without the need for a user to explicitly provide the schema in an as clause, unless noschema is specified. No attempt to merge conflicting schemas is made during loading. The first schema encountered during a file system scan is used.</source>
          <target state="translated">如果指定了schema选项,在存储数据时,会在输出目录下创建一个隐藏的&quot;.pig_schema &quot;文件。在加载过程中,PigStorage(无论是否使用-schema)都会使用它来确定数据的字段名和类型,而不需要用户在as子句中明确提供模式,除非指定了noschema。在加载过程中,不会尝试合并冲突的模式。在文件系统扫描过程中遇到的第一个模式被使用。</target>
        </trans-unit>
        <trans-unit id="eda78a9c0114a6e6fb5cb21af8108768e29477da" translate="yes" xml:space="preserve">
          <source>If the script doesn't re-load A' for the processing of A the steps above A' will be duplicated. This is a special case of Example 2 above, so the same steps are recommended. With multi-query execution, the script will process A and dump A' as a side-effect.</source>
          <target state="translated">如果脚本没有重新加载A'来处理A,那么A'上面的步骤就会重复。这是上面例2的特殊情况,所以建议使用相同的步骤。在多查询执行的情况下,脚本会对A进行处理,并将A'转储为副作用。</target>
        </trans-unit>
        <trans-unit id="56ff9b9e7d57fa5c8fe5a67569d32c6b3312a279" translate="yes" xml:space="preserve">
          <source>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</source>
          <target state="translated">如果没有指定ship和cache选项,Pig将尝试以下列方式自动运送二进制文件。</target>
        </trans-unit>
        <trans-unit id="6540b7615ec5950ced044baf9a5fecbbb70e65b7" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, all tuples in the relation are returned.</source>
          <target state="translated">如果指定的输出元组数等于或超过关系中的元组数,则返回关系中的所有元组。</target>
        </trans-unit>
        <trans-unit id="661dd3451b1f1f8a9425df1c0a8c2855275567c4" translate="yes" xml:space="preserve">
          <source>If the specified number of output tuples is less than the number of tuples in the relation, then n tuples are returned. There is no guarantee which n tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</source>
          <target state="translated">如果指定的输出元组数小于关系中的元组数,那么将返回n个元组。不能保证返回的是哪一个tuples,而且返回的tuples可能会从一次运行到下一次运行。可以使用 ORDER 操作符和 LIMIT 来请求一组特定的元组。</target>
        </trans-unit>
        <trans-unit id="018691f5562232d00cbae123ff01bedb87fa8b15" translate="yes" xml:space="preserve">
          <source>If the tested object is null, returns null.</source>
          <target state="translated">如果测试对象为空,则返回空。</target>
        </trans-unit>
        <trans-unit id="9e1b93c2a09e03a21f0905f246868a8fad2e9176" translate="yes" xml:space="preserve">
          <source>If the tested object is null, the SIZE function returns null.</source>
          <target state="translated">如果测试对象为空,SIZE函数返回空。</target>
        </trans-unit>
        <trans-unit id="52452dd37cfe0e014d1a5eeb279eb873c8dd2f17" translate="yes" xml:space="preserve">
          <source>If the tested value is not null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">如果测试值不为null，则返回true；否则，返回true。否则，返回false（请参见&lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="05bcf78db415053b73d510bab61b81cfa58b8490" translate="yes" xml:space="preserve">
          <source>If the tested value is null, returns true; otherwise, returns false (see &lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;).</source>
          <target state="translated">如果测试值是null，则返回true；否则，返回true。否则，返回false（请参见&lt;a href=&quot;#null_operators&quot;&gt;Null Operators&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="45e72887e023eb789c7ad2ce2f5d3f8a9395e06f" translate="yes" xml:space="preserve">
          <source>If the the underlying data is sufficiently skewed, bloom join might not help. Skewed join can be considered for those cases.</source>
          <target state="translated">如果底层数据有足够的倾斜,bloom join可能没有帮助。对于这些情况,可以考虑采用倾斜连接。</target>
        </trans-unit>
        <trans-unit id="a278eee26bc0d40cd14c07492b34d0e32ef8c022" translate="yes" xml:space="preserve">
          <source>If the type is omitted, the field defaults to type bytearray.</source>
          <target state="translated">如果省略类型,该字段默认为字节数组类型。</target>
        </trans-unit>
        <trans-unit id="df75bf757439ba68f277b7d366c1fe4887dcb0d3" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied for the length of the result tuple.</source>
          <target state="translated">如果该值为负值,则对结果元组的长度没有限制。</target>
        </trans-unit>
        <trans-unit id="36672551acc7fb0ca7d3aa692155b038a5a092b7" translate="yes" xml:space="preserve">
          <source>If the value is negative, no limit is applied to the size of the result bag.</source>
          <target state="translated">如果该值为负值,则对结果袋的大小没有限制。</target>
        </trans-unit>
        <trans-unit id="989efda04814537696830f9d12387663f1d8fe4d" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum length of the result tuple. The last element of the result tuple will contain all input after the last match.</source>
          <target state="translated">如果值为正,模式(正则表达式的编译表示)最多应用 limit-1 次,因此参数的值意味着结果元组的最大长度。结果元组的最后一个元素将包含最后一次匹配之后的所有输入。</target>
        </trans-unit>
        <trans-unit id="c6d264e7216fcd7fd94f7b27901536988583458c" translate="yes" xml:space="preserve">
          <source>If the value is positive, the pattern (the compiled representation of the regular expression) is applied at most limit-1 times, therefore the value of the argument means the maximum size of the result bag. The last tuple of the result bag will contain all input after the last match.</source>
          <target state="translated">如果值为正,模式(正则表达式的编译表示)最多应用 limit-1 次,因此参数的值意味着结果袋的最大大小。结果袋的最后一个元组将包含最后一次匹配后的所有输入。</target>
        </trans-unit>
        <trans-unit id="03070291f5db09d8b1e48844535ce39e98bd447f" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied for the length of the result tuple too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">如果值为零,结果元组的长度也不会受到限制,并且尾部的空字符串(如果有的话)会被删除。</target>
        </trans-unit>
        <trans-unit id="7e89973f6facf127728c69232069efe9c532fbb6" translate="yes" xml:space="preserve">
          <source>If the value is zero, no limit is applied to the size of the result bag too, and trailing empty strings (if any) will be removed.</source>
          <target state="translated">如果值为零,结果袋的大小也不受限制,而且后面的空字符串(如果有的话)会被删除。</target>
        </trans-unit>
        <trans-unit id="6231df4fcddcd0669f4101ebd7715a2f671b8fe9" translate="yes" xml:space="preserve">
          <source>If there is a filter statement right after OrcStorage, Pig will push the filter condition to the loader. OrcStorage will prune file/stripe/row group which does not satisfy the condition entirely. For the file/stripe/row group contains data that satisfies the filter condition, OrcStorage will load the file/stripe/row group and Pig will evaluate the filter condition again to remove additional data which does not satisfy the filter condition.</source>
          <target state="translated">如果在OrcStorage之后有一个过滤语句,Pig会将过滤条件推送给加载器。OrcStorage会修剪不完全满足条件的file/stripe/row组。如果file/stripe/row组包含了满足过滤条件的数据,OrcStorage会加载file/stripe/row组,Pig会再次评估过滤条件,以删除不满足过滤条件的额外数据。</target>
        </trans-unit>
        <trans-unit id="59ca04d3d9150ea272608b03ae0156c687fc7b38" translate="yes" xml:space="preserve">
          <source>If types are not specified in the load statement, Pig assumes the type of =double= for numeric computations. A lot of the time, your data would be much smaller, maybe, integer or long. Specifying the real type will help with speed of arithmetic computation. It has an additional advantage of early error detection.</source>
          <target state="translated">如果在加载语句中没有指定类型,Pig会假设数值计算的类型为=double=。很多时候,你的数据会小很多,也许,是整数或长数。指定实型将有助于算术计算的速度。它还有一个额外的优点,就是可以早期发现错误。</target>
        </trans-unit>
        <trans-unit id="24fb50f409eb821f7919123b47b4f273f7700fc1" translate="yes" xml:space="preserve">
          <source>If user specify neither &quot;parallel&quot; or &quot;default_parallel&quot;, Pig will use automatic parallelism. In MapReduce, Pig submit one MapReduce job a time and before submiting a job, Pig has chance to automatically set reduce parallelism based on the size of input file. On the contrary, Tez submit a DAG as a unit and automatic parallelism is managed in three parts</source>
          <target state="translated">如果用户既不指定 &quot;parallel &quot;也不指定 &quot;default_parallel&quot;,Pig将使用自动并行。在MapReduce中,Pig每次提交一个MapReduce作业,在提交作业前,Pig有机会根据输入文件的大小自动设置减少并行度。相反,Tez以一个DAG为单位提交,自动并行管理分为三个部分。</target>
        </trans-unit>
        <trans-unit id="b4dc665c403c330f35903b458f6fe6096a2ced59" translate="yes" xml:space="preserve">
          <source>If you FLATTEN a bag with empty inner schema, the schema for the resulting relation is null.</source>
          <target state="translated">如果你FLATTEN了一个内部模式为空的袋子,那么产生的关系的模式为空。</target>
        </trans-unit>
        <trans-unit id="a9dad6c87764738da3cfc061e6f727d2a6799327" translate="yes" xml:space="preserve">
          <source>If you UNION two relations with incompatible schema, the schema for resulting relation is null.</source>
          <target state="translated">如果你把两个模式不兼容的关系UNION,产生的关系模式为空。</target>
        </trans-unit>
        <trans-unit id="56e8101602c2d9c75a14cf49e518adb7c0ea62ba" translate="yes" xml:space="preserve">
          <source>If you are just a user of UDFs, this is most of what you need to know about UDFs to use them in your code.</source>
          <target state="translated">如果你只是一个UDFs的用户,这就是你需要了解的关于UDFs的大部分内容,以便在你的代码中使用它们。</target>
        </trans-unit>
        <trans-unit id="7c772834e2a9aed00764a6e96ad1c9163813c083" translate="yes" xml:space="preserve">
          <source>If you are using Spark, you will also need to specify SPARK_HOME and specify SPARK_JAR which is the hdfs location where you uploaded $SPARK_HOME/lib/spark-assembly*.jar:</source>
          <target state="translated">如果你使用的是Spark,你还需要指定SPARK_HOME并指定SPARK_JAR,也就是你上传$SPARK_HOME/lib/spark-assembly*.jar的hdfs位置。</target>
        </trans-unit>
        <trans-unit id="6cb81c239c67bf888e13b2d22dde63010dbe3dfb" translate="yes" xml:space="preserve">
          <source>If you are using Tez, you will also need to put Tez configuration directory (the directory that contains the tez-site.xml):</source>
          <target state="translated">如果你使用的是Tez,你还需要把Tez配置目录(包含tez-site.xml的目录)。</target>
        </trans-unit>
        <trans-unit id="f86801fd7dc0106a735a5ab7b2fbc69bbc1e2ca3" translate="yes" xml:space="preserve">
          <source>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</source>
          <target state="translated">如果你给一个字段指定了一个名字,你可以用这个名字或位置符号来引用这个字段。如果你不给字段指定名称(字段未命名),你只能用位置符号来引用字段。</target>
        </trans-unit>
        <trans-unit id="5c2068efddb33c739f6e1e4118009324d44d4dc5" translate="yes" xml:space="preserve">
          <source>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</source>
          <target state="translated">如果你给一个字段指定了一个类型,你可以随后使用投射运算符来改变类型,如果你没有给字段指定类型,字段默认为字节数,你可以使用投射运算符来改变默认类型。如果不给字段指定类型,字段默认为字节数;你可以使用投射运算符改变默认类型。</target>
        </trans-unit>
        <trans-unit id="93009caea4faeed63c7a3f49e29e15e2d31dcaf9" translate="yes" xml:space="preserve">
          <source>If you do &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt; on B, you will see a single column of type double. This is because Pig makes the safest choice and uses the largest numeric type when the schema is not know. In practice, the input data could contain integer values; however, Pig will cast the data to double and make sure that a double result is returned.</source>
          <target state="translated">如果在B上执行&lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt;，您将看到一个类型为double的单列。这是因为Pig是最安全的选择，并且在不知道模式时使用最大的数字类型。实际上，输入数据可以包含整数值。但是，Pig会将数据强制转换为双精度，并确保返回双精度结果。</target>
        </trans-unit>
        <trans-unit id="c200fd2558a69c650aaf5de63cfc921f16db98be" translate="yes" xml:space="preserve">
          <source>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</source>
          <target state="translated">如果你没有为一个给定的流媒体命令提供一个DEFINE,那么自动运输将被关闭。</target>
        </trans-unit>
        <trans-unit id="c7d732bcc63d3993a0471861bd1df7f8145f5af3" translate="yes" xml:space="preserve">
          <source>If you have more questions, you can ask on the &lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig Mailing Lists&lt;/a&gt;.</source>
          <target state="translated">如果您还有其他问题，可以在&lt;a href=&quot;http://hadoop.apache.org/pig/mailing_lists.html&quot;&gt;Pig邮件列表中&lt;/a&gt;询问。</target>
        </trans-unit>
        <trans-unit id="76dbbb85aae7650b87268f029aecb7ef5ea47ad5" translate="yes" xml:space="preserve">
          <source>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</source>
          <target state="translated">如果你需要另一种格式,你将需要通过实现以下接口来创建一个自定义的序列化器/解序列化器。</target>
        </trans-unit>
        <trans-unit id="3ab330aaf103a3416195109dc88d65171a3113af" translate="yes" xml:space="preserve">
          <source>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same data.</source>
          <target state="translated">如果将关系A排序产生关系X(X=ORDER A BY*DESC;)关系A和X仍然包含相同的数据。</target>
        </trans-unit>
        <trans-unit id="4e50578ad11c2c7c9f284f3844fbe57c5a3d59d7" translate="yes" xml:space="preserve">
          <source>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</source>
          <target state="translated">如果你向脚本传递了一个脚本不使用的参数,这个参数会被默默忽略。如果脚本有一个参数,但没有提供或替换任何值,将导致一个错误。</target>
        </trans-unit>
        <trans-unit id="1369a59a2bb2e259294a035010e7c4da3f78013e" translate="yes" xml:space="preserve">
          <source>If you retrieve relation X (DUMP X;) the data is guaranteed to be in the order you specified (descending).</source>
          <target state="translated">如果你检索关系X(DUMP X;),保证数据按照你指定的顺序(降序)进行。</target>
        </trans-unit>
        <trans-unit id="07b727742d1a4fca1de7143e1c07d0e86425235b" translate="yes" xml:space="preserve">
          <source>If you specify a directory name, all the files in the directory are loaded.</source>
          <target state="translated">如果你指定了一个目录名,则会加载该目录中的所有文件。</target>
        </trans-unit>
        <trans-unit id="2b27e9a3e53e3fef81b3d326d2e23e78ab25c9ea" translate="yes" xml:space="preserve">
          <source>If you use a local cluster, you need to set the required environment variables before starting it:</source>
          <target state="translated">如果使用本地集群,则需要在启动前设置所需的环境变量。</target>
        </trans-unit>
        <trans-unit id="f6a85122c8dd900955aa81ccb9781c63a8e5c20c" translate="yes" xml:space="preserve">
          <source>If you use concatenated bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</source>
          <target state="translated">如果你在Pig作业中使用了连接的bzip文件,你不会看到失败,但结果会不正确。</target>
        </trans-unit>
        <trans-unit id="ec27bed12f5b3966ebd9a9d8528ad6a6ed6a7aba" translate="yes" xml:space="preserve">
          <source>If your Pig script generates a sequence of MapReduce jobs, you can compress the output of the intermediate jobs using LZO compression. (Use the &lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt; operator to determine if your script produces multiple MapReduce Jobs.)</source>
          <target state="translated">如果Pig脚本生成一系列MapReduce作业，则可以使用LZO压缩来压缩中间作业的输出。（使用&lt;a href=&quot;test#EXPLAIN&quot;&gt;EXPLAIN&lt;/a&gt;运算符来确定您的脚本是否产生多个MapReduce作业。）</target>
        </trans-unit>
        <trans-unit id="1239ee562b13227e2353dd2b5d0642351c9fb666" translate="yes" xml:space="preserve">
          <source>If your UDF can't be made Algebraic but is able to deal with getting input in chunks rather than all at once, consider implementing the Accumulator interface to reduce the amount of memory used by your script. If your function &lt;em&gt;is&lt;/em&gt; Algebraic and can be used on conjunction with Accumulator functions, you will need to implement the Accumulator interface as well as the Algebraic interface. For more information, see &lt;a href=&quot;udf#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;.</source>
          <target state="translated">如果您的UDF不能被代数化，但是能够处理成块而不是一次全部获取输入的情况，请考虑实现Accumulator接口以减少脚本使用的内存量。如果您的函数&lt;em&gt;是&lt;/em&gt;代数的并且可以与Accumulator函数结合使用，则您将需要实现Accumulator接口以及Algebraic接口。有关更多信息，请参见&lt;a href=&quot;udf#accumulator-interface&quot;&gt;累加器接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="349f0b1b2f441677a38531ccee38d0d7d15aa938" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, the &amp;lsquo;merge&amp;rsquo; clause to perform an optimized version of COGROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">如果您的数据和加载程序满足这些条件，则使用'merge'子句执行优化版本的COGROUP；该操作将在地图端执行，并避免运行reduce阶段。</target>
        </trans-unit>
        <trans-unit id="f86b761e8e078b0506cc07cd02d05eb34d02e1a7" translate="yes" xml:space="preserve">
          <source>If your data and loaders satisfy these conditions, use the &amp;lsquo;collected&amp;rsquo; clause to perform an optimized version of GROUP; the operation will execute on the map side and avoid running the reduce phase.</source>
          <target state="translated">如果您的数据和加载程序满足这些条件，请使用&amp;ldquo; collected&amp;rdquo;子句执行GROUP的优化版本；该操作将在地图端执行，并避免运行reduce阶段。</target>
        </trans-unit>
        <trans-unit id="feef6e3b59816e49d675edf99fac1a33a1fb5a57" translate="yes" xml:space="preserve">
          <source>If your loader implementation makes use of the PigSplit object passed through the prepareToRead method, then you may need to rebuild the loader since the definition of PigSplit has been modified.</source>
          <target state="translated">如果你的装载机实现使用了通过prepareToRead方法传递的PigSplit对象,那么你可能需要重建装载机,因为PigSplit的定义已经被修改。</target>
        </trans-unit>
        <trans-unit id="dee1bf176cbe01fd0441b1a12c13b06adb1b7153" translate="yes" xml:space="preserve">
          <source>Implement UDF by Simulation</source>
          <target state="translated">通过模拟实现UDF</target>
        </trans-unit>
        <trans-unit id="5827f6f79b07ec443d93d8058ad81cc9d4d2ac27" translate="yes" xml:space="preserve">
          <source>Implicit Dependencies</source>
          <target state="translated">隐性依赖性</target>
        </trans-unit>
        <trans-unit id="4c4d1de553948a314adeca034d84e23cd3b9ae4a" translate="yes" xml:space="preserve">
          <source>Import Lists</source>
          <target state="translated">进口清单</target>
        </trans-unit>
        <trans-unit id="1e56c1186fa7d5c3374f67d59101df99e56c90cb" translate="yes" xml:space="preserve">
          <source>Import macros defined in a separate file.</source>
          <target state="translated">导入在单独文件中定义的宏。</target>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="translated">导入模块</target>
        </trans-unit>
        <trans-unit id="398119218cf11b626396e7917ac6cf24641f838c" translate="yes" xml:space="preserve">
          <source>Improvements and other components based on PigUnit that could be built later.</source>
          <target state="translated">基于PigUnit的改进和其他组件,可以在以后建立。</target>
        </trans-unit>
        <trans-unit id="ab855867b4034f4bb99051d1f3ccaf64cefc7280" translate="yes" xml:space="preserve">
          <source>In Pig Latin,</source>
          <target state="translated">在猪的拉丁语。</target>
        </trans-unit>
        <trans-unit id="7b89c2531e0f47016cb2eac1f0115cc5c90e90d9" translate="yes" xml:space="preserve">
          <source>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</source>
          <target state="translated">在Pig Latin中,表达式是与FILTER、FOREACH、GROUP、SPLIT运算符以及eval函数一起使用的语言结构。</target>
        </trans-unit>
        <trans-unit id="047330b0ff963c6df380d337f23e804c0fa8f828" translate="yes" xml:space="preserve">
          <source>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation.</source>
          <target state="translated">在Pig Latin中,nulls使用SQL定义的null来实现,即未知或不存在。空值可以在数据中自然出现,也可以是操作的结果。</target>
        </trans-unit>
        <trans-unit id="e2b472a5cb1d2bb6677c5894a233ab880022ee5b" translate="yes" xml:space="preserve">
          <source>In Pig, problems with memory usage can occur when data, which results from a group or cogroup operation, needs to be placed in a bag and passed in its entirety to a UDF.</source>
          <target state="translated">在Pig中,当一个组或cogroup操作所产生的数据需要放在一个袋子里并完整地传递给一个UDF时,就会出现内存使用问题。</target>
        </trans-unit>
        <trans-unit id="77ac446bcfdd607749e9908e882446119d984b45" translate="yes" xml:space="preserve">
          <source>In Pig, relations are unordered (see &lt;a href=&quot;#relations&quot;&gt;Relations, Bags, Tuples, Fields&lt;/a&gt;):</source>
          <target state="translated">在Pig中，关系是无序的（请参见&amp;ldquo; &lt;a href=&quot;#relations&quot;&gt;关系，包，元组，字段&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="77395bf675c2c5145ba7cb6ba484de1ce1ad1445" translate="yes" xml:space="preserve">
          <source>In Tez, jvm could reuse for other tasks. It is important to cleanup static variable to make sure there is no side effect. Here is one example:</source>
          <target state="translated">在Tez中,jvm可以重用于其他任务。清理静态变量以确保没有副作用是很重要的。这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="7dd89a54572b05053fd654da00615655e3c8186b" translate="yes" xml:space="preserve">
          <source>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</source>
          <target state="translated">在加载语句中,加载器会将null注入元组中。替换为null的实际值是加载器特有的;例如,PigStorage将一个空字段替换为null。</target>
        </trans-unit>
        <trans-unit id="9ab73a609fcb251095ae635071ba701b69b3b5ae" translate="yes" xml:space="preserve">
          <source>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</source>
          <target state="translated">在非加载语句中,如果一个元组中缺少一个请求的字段,Pig将注入null。</target>
        </trans-unit>
        <trans-unit id="761d64cc264226017ae6e486dbdb548f042b4ea4" translate="yes" xml:space="preserve">
          <source>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</source>
          <target state="translated">除了位置之外,数据的分组和排序也可以由数据本身决定。但是,你需要知道数据的属性,才能利用其结构。</target>
        </trans-unit>
        <trans-unit id="4e5448a648336936524e336b0e640a723e9a9434" translate="yes" xml:space="preserve">
          <source>In addition to providing Pig script via a string, you can store it in a file and pass the file to the compile call:</source>
          <target state="translated">除了通过字符串提供Pig脚本外,你还可以将其存储在文件中,并将该文件传递给编译调用。</target>
        </trans-unit>
        <trans-unit id="1ea3be12b2777f643d5e98b83b6f48b651f89c54" translate="yes" xml:space="preserve">
          <source>In cases where the schema is stored as part of the StoreFunc like PigStorage, JsonStorage, AvroStorage or OrcStorage, users generally have to use an extra FOREACH before STORE to rename the field names and remove the disambiguate operator from the names. To automatically remove the disambiguate operator from the schema for the STORE operation, the pig.store.schema.disambiguate Pig property can be set to &quot;false&quot;. It is the responsibility of the user to make sure that there is no conflict in the field names when using this setting.</source>
          <target state="translated">在模式作为StoreFunc的一部分存储的情况下,如PigStorage、JsonStorage、AvroStorage或OrcStorage,用户一般要在STORE之前使用额外的FOREACH来重命名字段名,并从名称中删除disambiguate操作符。要想在STORE操作中自动去除模式中的disambiguate操作符,可以将pig.store.schema.disambiguate Pig属性设置为 &quot;false&quot;。用户有责任确保在使用此设置时,字段名中没有冲突。</target>
        </trans-unit>
        <trans-unit id="cb09a5599dba9a08193e6ba5ca41cf184a2941b2" translate="yes" xml:space="preserve">
          <source>In general, lowercase type indicates elements that you supply.</source>
          <target state="translated">一般来说,小写类型表示你提供的元素。</target>
        </trans-unit>
        <trans-unit id="667bae580123f622168d5ecaf410d9ca73353cd3" translate="yes" xml:space="preserve">
          <source>In general, uppercase type indicates elements the system supplies.</source>
          <target state="translated">一般来说,大写类型表示系统提供的元素。</target>
        </trans-unit>
        <trans-unit id="43385afe9d70e705c298432cd61a48b9ebab8e78" translate="yes" xml:space="preserve">
          <source>In its basic form, compile just takes a Pig Latin fragment that defines the pipeline as described in the previous section. Additionally, the pipeline can be given a name. This name is only used when the embedded script is invoked via the PigRunner Java API (as discussed later in this document).</source>
          <target state="translated">在其基本形式中,compile只是接受一个Pig拉丁语片段,它定义了上一节中描述的管道。此外,还可以给管道起一个名字。这个名称只有在通过PigRunner Java API调用嵌入式脚本时才会使用(本文档后面会讨论)。</target>
        </trans-unit>
        <trans-unit id="c386aecc87f49116be4bbc8980ea9301e6beef05" translate="yes" xml:space="preserve">
          <source>In its simplest form, bind takes no parameters. In this case, an implicit bind is performed; Pig internally constructs a map of parameters from the local variables specified by the user in the script.</source>
          <target state="translated">在最简单的形式下,bind不需要参数。在这种情况下,会执行隐式绑定;Pig在内部从用户在脚本中指定的本地变量中构建一个参数映射。</target>
        </trans-unit>
        <trans-unit id="a6ce11ff76294b5348b9aa96365ef9638cb0d1b7" translate="yes" xml:space="preserve">
          <source>In many cases, AvroStorage will automatically translate your data correctly and you will not need to provide any more information to AvroStorage. But sometimes, it may be convenient to manually provide a schema to AvroStorge. See the example selection below for examples on manually specifying a schema with AvroStorage.</source>
          <target state="translated">在许多情况下,AvroStorage会自动正确翻译您的数据,您无需向AvroStorage提供更多信息。但有时,向AvroStorge手动提供模式可能会很方便。请参阅下面的示例选择,以了解有关使用 AvroStorage 手动指定模式的例子。</target>
        </trans-unit>
        <trans-unit id="5d274aa391941e3db3eaf1d92d4ca5b2b777dcc2" translate="yes" xml:space="preserve">
          <source>In map-reduce mode, the following script will load from &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/data1&quot; and store into &quot;hdfs://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/tmp/out1&quot;.</source>
          <target state="translated">在map-reduce模式下，以下脚本将从&amp;ldquo; hdfs：// &amp;lt;主机&amp;gt;：&amp;lt;端口&amp;gt; / data1&amp;rdquo;加载并存储到&amp;ldquo; hdfs：// &amp;lt;主机&amp;gt;：&amp;lt;端口&amp;gt; / tmp / out1&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fbac605553184ef19261778bcb7ec6f398ca51e3" translate="yes" xml:space="preserve">
          <source>In order to avoid replicated joins on large relations, we fail if size of relation(s) to be replicated (in bytes) is greater than pig.join.replicated.max.bytes (default = 1GB).</source>
          <target state="translated">为了避免在大的关系上复制连接,如果要复制的关系大小(以字节为单位)大于 pig.join.replicated.max.bytes(默认=1GB),我们就会失败。</target>
        </trans-unit>
        <trans-unit id="f6df614c8a5e9de3ecdeefdab6a02557f17f3174" translate="yes" xml:space="preserve">
          <source>In parameter file, as part of a command line.</source>
          <target state="translated">在参数文件中,作为命令行的一部分。</target>
        </trans-unit>
        <trans-unit id="a83607c547c007f3cf1a9c56712a1e100cdccaa1" translate="yes" xml:space="preserve">
          <source>In prior Pig releases, Example 1 will dump A' to disk and then start jobs for B' and C'. Example 2 will execute all the dependencies of B' and store it and then execute all the dependencies of C' and store it. Both are equivalent, but the performance will be different.</source>
          <target state="translated">在之前的Pig版本中,例1会将A'转储到磁盘上,然后启动B'和C'的作业。例2将执行B'的所有依赖项并存储它,然后执行C'的所有依赖项并存储它。两者是等价的,但性能会有所不同。</target>
        </trans-unit>
        <trans-unit id="3dd2199bc012d7207d555ef9e715d44419202375" translate="yes" xml:space="preserve">
          <source>In some cases it might be desirable to fail the entire script upon detecting the first failed job. This can be achieved with the &quot;-F&quot; or &quot;-stop_on_failure&quot; command line flag. If used, Pig will stop execution when the first failed job is detected and discontinue further processing. This also means that file commands that come after a failed store in the script will not be executed (this can be used to create &quot;done&quot; files).</source>
          <target state="translated">在某些情况下,当检测到第一个失败的作业时,可能需要使整个脚本失败,这可以通过&quot;-F &quot;或&quot;-stop_on_failure &quot;命令行标志来实现。这可以通过&quot;-F &quot;或&quot;-stop_on_failure &quot;命令行标志来实现。如果使用,Pig 将在检测到第一个失败的作业时停止执行,并停止进一步的处理。这也意味着,在脚本中失败的存储之后的文件命令将不会被执行(这可以用来创建 &quot;已完成 &quot;的文件)。</target>
        </trans-unit>
        <trans-unit id="a902912f349147fbbe0eb2d57a40fcb3a4e6de06" translate="yes" xml:space="preserve">
          <source>In the FOREACH statement, the field in relation B is referred to by positional notation ($0).</source>
          <target state="translated">在FOREACH语句中,关系B中的字段用位置符号($0)来表示。</target>
        </trans-unit>
        <trans-unit id="0534091b29b78ead8b83df710a7671a6499bd98e" translate="yes" xml:space="preserve">
          <source>In the SQL case, the SQLLoader function is invoked with 'sql://mytable'.</source>
          <target state="translated">在SQL的情况下,SQLLoader函数是以'sql://mytable'来调用的。</target>
        </trans-unit>
        <trans-unit id="7013811a67a11af4ac23552269ed48873de74a1b" translate="yes" xml:space="preserve">
          <source>In the above example, a variety of expressions can be applied to algebraic functions including:</source>
          <target state="translated">在上述例子中,各种表达式可以应用于代数函数,包括:。</target>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="translated">在上面的例子中。</target>
        </trans-unit>
        <trans-unit id="789a8aaef2965b6eb70d651d97130eed1c314f0f" translate="yes" xml:space="preserve">
          <source>In the case of inner join and right outer join, the right most relation is used for building the bloom filter and the users are expected to specify the smaller dataset as the right most relation. But in the case of left outer join, the left most relation is used for building the bloom filter and is expected to be the smaller dataset. This is because all records of the outer relation should be in the result and no records can be filtered. If the left relation turns out to be the bigger dataset, it would not be as efficient to build the bloom filter on the bigger dataset. But it might still perform better than a regular join if it is able to filter lot of records from the right relation.</source>
          <target state="translated">在内联接和右外联接的情况下,最右边的关系被用于构建bloom过滤器,用户被期望指定较小的数据集作为最右边的关系。但是在左外连接的情况下,最左的关系被用于构建bloom过滤器,并且被期望是较小的数据集。这是因为外层关系的所有记录都应该在结果中,没有记录可以被过滤。如果左边关系变成了更大的数据集,那么在更大的数据集上建立bloom过滤器的效率就会降低。但如果能够从右侧关系中过滤出大量记录,它的表现可能还是比普通的join更好。</target>
        </trans-unit>
        <trans-unit id="366cfaa9f77dcf4de6672d5c4eeb8495d9aab995" translate="yes" xml:space="preserve">
          <source>In the example above relation A is loaded from HDFS and stored in HBase. Note that the schema of relation A is a tuple of size 3, but only two column descriptor names are passed to the HBaseStorage constructor. This is because the first entry in the tuple is used as the HBase rowKey.</source>
          <target state="translated">在上面的例子中,关系A从HDFS中加载并存储在HBase中。请注意,关系A的模式是一个大小为3的元组,但只有两个列描述符名称被传递给HBaseStorage构造函数。这是因为元组中的第一个条目被用作HBase的rowKey。</target>
        </trans-unit>
        <trans-unit id="8768ae4a7963f867789d54883f792a4b049338c3" translate="yes" xml:space="preserve">
          <source>In the example below, note the following:</source>
          <target state="translated">在下面的例子中,请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="810f4025eba8164da7f5c931db880c74c3f881c2" translate="yes" xml:space="preserve">
          <source>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</source>
          <target state="translated">在脚本中,参数名可以用反斜线字符(\ )进行转义,在这种情况下,不会进行替换。</target>
        </trans-unit>
        <trans-unit id="823a66cbb60bb79080f0a8b1ea0d329c7d74614e" translate="yes" xml:space="preserve">
          <source>In these examples a directory is created, a file is copied, a file is listed.</source>
          <target state="translated">在这些例子中,一个目录被创建,一个文件被复制,一个文件被列出。</target>
        </trans-unit>
        <trans-unit id="9fb53acc5fc864b189dffd5763e2ccfc43d29a03" translate="yes" xml:space="preserve">
          <source>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</source>
          <target state="translated">在这个例子中,A是一个关系或tuples的袋子。你可以把这个袋子看作是一个外袋。</target>
        </trans-unit>
        <trans-unit id="c2b8d5695ad31a39e71eead60f9a78e531f16388" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used to load multiple locations.</source>
          <target state="translated">在这个例子中,BinStorage被用来加载多个位置。</target>
        </trans-unit>
        <trans-unit id="fb4dad7abc1d7506c6a665f7d105adc4e5904a6a" translate="yes" xml:space="preserve">
          <source>In this example BinStorage is used with the LOAD and STORE functions.</source>
          <target state="translated">在这个例子中,BinStorage与LOAD和STORE函数一起使用。</target>
        </trans-unit>
        <trans-unit id="5a58d2ef04a5cda433ef29f50daa6af7e7faab9f" translate="yes" xml:space="preserve">
          <source>In this example COUNT_STAR is used to count the tuples in a bag.</source>
          <target state="translated">在这个例子中,COUNT_STAR被用来计算一个袋子中的元组。</target>
        </trans-unit>
        <trans-unit id="1ff7470c5528ca285c04a3c3ac0c8d55936316c0" translate="yes" xml:space="preserve">
          <source>In this example DIFF compares the tuples in two bags.</source>
          <target state="translated">在这个例子中,DIFF比较了两个袋子中的元组。</target>
        </trans-unit>
        <trans-unit id="59300d5fb1b29001840b069de1bdcfdde402ef36" translate="yes" xml:space="preserve">
          <source>In this example FOREACH is nested to the second level.</source>
          <target state="translated">在这个例子中,FOREACH被嵌套到第二层。</target>
        </trans-unit>
        <trans-unit id="c1481519e4226587e1177016b76ec2132f08cef8" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used to store a relation into HBase.</source>
          <target state="translated">在这个例子中,HBaseStorage用于将一个关系存储到HBase中。</target>
        </trans-unit>
        <trans-unit id="ab84b86ed1cd0f81d89240b20eeb6f47b9930a87" translate="yes" xml:space="preserve">
          <source>In this example HBaseStorage is used with the LOAD function with an explicit schema.</source>
          <target state="translated">在这个例子中,HBaseStorage与LOAD函数一起使用了显式模式。</target>
        </trans-unit>
        <trans-unit id="435c4dd4d77b5e857be6bf8ad142ee3d71a0e7a5" translate="yes" xml:space="preserve">
          <source>In this example PARALLEL is used with the GROUP operator.</source>
          <target state="translated">在这个例子中,PARALLEL与GROUP操作符一起使用。</target>
        </trans-unit>
        <trans-unit id="40cb6c5ae4d9ef5896bcd6d4b036252b875f816a" translate="yes" xml:space="preserve">
          <source>In this example Pig will validate, but not execute, the LOAD and FOREACH statements.</source>
          <target state="translated">在这个例子中,Pig将验证但不执行LOAD和FOREACH语句。</target>
        </trans-unit>
        <trans-unit id="de61ae61ea6032b2e228021c21932ce307a7c989" translate="yes" xml:space="preserve">
          <source>In this example PigDump is used with the STORE function.</source>
          <target state="translated">在本例中,PigDump与STORE函数一起使用。</target>
        </trans-unit>
        <trans-unit id="46d2148592ebc16cb761333836a92127b54281f5" translate="yes" xml:space="preserve">
          <source>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</source>
          <target state="translated">在这个例子中,PigStorage希望input.txt包含以tab分隔的字段和以换行符分隔的记录。这些语句是等价的。</target>
        </trans-unit>
        <trans-unit id="6470b4bdc80ce6ec14c6b369cff173d8a96a70af" translate="yes" xml:space="preserve">
          <source>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE statement specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</source>
          <target state="translated">在这个例子中,PigStorage将X的内容存储到以星号(*)分隔的字段的文件中。STORE语句指定文件将位于名为output的目录中,文件将被命名为part-nnnnn(例如,part-00000)。</target>
        </trans-unit>
        <trans-unit id="3545f3dfb4a61c191d5ce7c17db12055dbea1552" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</source>
          <target state="translated">在这个例子中,PigStreaming是默认的序列化/反序列化函数。来自关系A的元组被转换为以tab分隔的行,并传递给脚本。</target>
        </trans-unit>
        <trans-unit id="53acd63180313d053382b996221400c3670c3ad0" translate="yes" xml:space="preserve">
          <source>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</source>
          <target state="translated">在这个例子中,PigStreaming被用作序列化/解序列化函数,但使用逗号作为分隔符。</target>
        </trans-unit>
        <trans-unit id="505900e4da0fa482992eb1a2f88bcc0e5d38a43b" translate="yes" xml:space="preserve">
          <source>In this example REGISTER states that the JavaScript module, myfunc.js, is located in the /src directory.</source>
          <target state="translated">在这个例子中,REGISTER说明JavaScript模块myfunc.js位于/src目录下。</target>
        </trans-unit>
        <trans-unit id="50cb9301684455fe267eae841880105c8315f523" translate="yes" xml:space="preserve">
          <source>In this example TextLoader is used with the LOAD function.</source>
          <target state="translated">在本例中,TextLoader与LOAD函数一起使用。</target>
        </trans-unit>
        <trans-unit id="3c5e9d3dd6f9a44bb764a99545f07562b251abc9" translate="yes" xml:space="preserve">
          <source>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</source>
          <target state="translated">在这个例子中,X是一个关系或图元组的袋子。关系X中的元组有两个字段。第一个字段是int类型。第二个字段是类型为bag的;你可以把这个bag看作是一个内袋。</target>
        </trans-unit>
        <trans-unit id="2bf5f5dc213edcf0c2a75a62d467adfd719f4117" translate="yes" xml:space="preserve">
          <source>In this example a CROSS is performed within the nested block.</source>
          <target state="translated">在这个例子中,在嵌套块中进行了CROSS。</target>
        </trans-unit>
        <trans-unit id="9d96da638dd744c8666b0a4d7441d6698bbcae66" translate="yes" xml:space="preserve">
          <source>In this example a JAR file stored in HDFS and a local JAR file are registered.</source>
          <target state="translated">在这个例子中,一个存储在HDFS中的JAR文件和一个本地JAR文件被注册。</target>
        </trans-unit>
        <trans-unit id="c853730b16a0a6d3de6a48047bf1fd0903963d8c" translate="yes" xml:space="preserve">
          <source>In this example a and null are projected.</source>
          <target state="translated">在这个例子中,a和null是投影。</target>
        </trans-unit>
        <trans-unit id="252278b82d54611f8604f3c1c4920b5131753f06" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type bag.</source>
          <target state="translated">在这个例子中,一个字节数组(关系A中的fld)被投向类型bag。</target>
        </trans-unit>
        <trans-unit id="52be4343435f44112a5462538218eec269b8c99a" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type map.</source>
          <target state="translated">在这个例子中,一个字节数组(关系A中的fld)被转换为类型映射。</target>
        </trans-unit>
        <trans-unit id="adc6b1c539b7f3b4f765bf66f1bbf223243eec17" translate="yes" xml:space="preserve">
          <source>In this example a bytearray (fld in relation A) is cast to type tuple.</source>
          <target state="translated">在这个例子中,一个字节数组(关系A中的fld)被转换为元组类型。</target>
        </trans-unit>
        <trans-unit id="b780edd4e748b15aca64e2b122fa86c500341bd8" translate="yes" xml:space="preserve">
          <source>In this example a command is defined for use with the &lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt; operator.</source>
          <target state="translated">在此示例中，定义了一个命令，供&lt;a href=&quot;#stream&quot;&gt;STREAM&lt;/a&gt;运算符使用。</target>
        </trans-unit>
        <trans-unit id="a42086ec48674799538294ab226a5ef8414b48d8" translate="yes" xml:space="preserve">
          <source>In this example a dump is performed after each statement.</source>
          <target state="translated">在这个例子中,在每条语句之后都会进行一次转储。</target>
        </trans-unit>
        <trans-unit id="28b34e252e518f10cb207856de095b2d0a0edae9" translate="yes" xml:space="preserve">
          <source>In this example a field delimiter is specified.</source>
          <target state="translated">在这个例子中,指定了一个字段定界符。</target>
        </trans-unit>
        <trans-unit id="231dd12f30cc168f8fe434f1dc9d10741002943a" translate="yes" xml:space="preserve">
          <source>In this example a function is defined for use with the FOREACH &amp;hellip;GENERATE operator.</source>
          <target state="translated">在此示例中，定义了一个函数，供FOREACH&amp;hellip;GENERATE运算符使用。</target>
        </trans-unit>
        <trans-unit id="902f7920721a3a412c9e07306586280fa07bbed2" translate="yes" xml:space="preserve">
          <source>In this example a macro (group_with_parallel) refers to another macro (foreach_count).</source>
          <target state="translated">在这个例子中,一个宏(group_with_parallel)引用了另一个宏(foreach_count)。</target>
        </trans-unit>
        <trans-unit id="c526f01c29f290403e51e19b0ba26f8e808e9d41" translate="yes" xml:space="preserve">
          <source>In this example a multi-field tuple is used. For the FILTER statement, Pig performs an implicit cast. For the FOREACH statement, an explicit cast is used.</source>
          <target state="translated">在这个例子中,使用了一个多字段元组。对于 FILTER 语句,Pig 执行了隐式转换。对于 FOREACH 语句,则使用显式转换。</target>
        </trans-unit>
        <trans-unit id="f34e9ccd45ed5247a9948b597bda137a57066df6" translate="yes" xml:space="preserve">
          <source>In this example a name collision will occur. Here letter B is used as alias name and as name in user-defined schema. Pig will throw an exception when name collision is detected.</source>
          <target state="translated">在这个例子中,将发生名称冲突。这里,字母B被用作别名和用户定义模式中的名称。当检测到名称冲突时,Pig会抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="fe539b60b5336a69ebbb6e4634bb45d1f0a5d224" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified as part of the STREAM statement.</source>
          <target state="translated">在这个例子中,模式被指定为STREAM语句的一部分。</target>
        </trans-unit>
        <trans-unit id="06061e753d06a1e6057c5ffcb4a812aa78fbf9d1" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</source>
          <target state="translated">在这个例子中,使用 AS 子句指定了一个模式。如果所有数据都符合模式,Pig将使用分配的类型。</target>
        </trans-unit>
        <trans-unit id="34acf70f365e4b31c6e0e3cccb93c0182b8a1c41" translate="yes" xml:space="preserve">
          <source>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema.</source>
          <target state="translated">在这个例子中,使用AS关键字指定了一个模式。两个LOAD语句是等价的。你可以使用DESCRIBE和ILLUSTRATE操作符来查看模式。</target>
        </trans-unit>
        <trans-unit id="dc43776c73d7d053427079800e34a406b2a45d68" translate="yes" xml:space="preserve">
          <source>In this example additional JAR files are registered via PIG_OPTS environment variable.</source>
          <target state="translated">在这个例子中,额外的JAR文件是通过PIG_OPTS环境变量注册的。</target>
        </trans-unit>
        <trans-unit id="16dcc4a12858c636c8fa146c2aad2b889eb7fae9" translate="yes" xml:space="preserve">
          <source>In this example all duplicate tuples are removed.</source>
          <target state="translated">在这个例子中,所有重复的元组都被删除。</target>
        </trans-unit>
        <trans-unit id="b618f5f0bcbb7b8e5bdafd32f7a9e4baece8803f" translate="yes" xml:space="preserve">
          <source>In this example all students with an SSN but no name are located.</source>
          <target state="translated">在这个例子中,所有有SSN但没有名字的学生都被定位。</target>
        </trans-unit>
        <trans-unit id="79068ccaa260466fc6f972d14a88f57c0fcfb5d3" translate="yes" xml:space="preserve">
          <source>In this example all the MapReduce jobs that get launched use 20 reducers.</source>
          <target state="translated">在这个例子中,所有被启动的MapReduce作业都使用20个reducer。</target>
        </trans-unit>
        <trans-unit id="b770e6fe233709b0a9582cf8bb7b9270df9258d2" translate="yes" xml:space="preserve">
          <source>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</source>
          <target state="translated">在这个例子中,由于请求的列(3)在声明的模式之外(位置符号以$0开头),所以产生了一个错误。请注意,这个错误在语句执行之前就被发现了。</target>
        </trans-unit>
        <trans-unit id="019c413fae337da8ece686fc5d54f62505ef2c7a" translate="yes" xml:space="preserve">
          <source>In this example an int is cast to type chararray (see relation X).</source>
          <target state="translated">在这个例子中,一个int被转换为chararray类型(见关系X)。</target>
        </trans-unit>
        <trans-unit id="93db6358d966d0c7d514bd2decd538210cc879e4" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be cast to int, a implicitly, and null explicitly.</source>
          <target state="translated">在这个例子中,a和null都将被转换为int,a是隐式的,null是显式的。</target>
        </trans-unit>
        <trans-unit id="f959bad76d0bbfd8004a39fa235bd4ca5f054f65" translate="yes" xml:space="preserve">
          <source>In this example both a and null will be implicitly cast to double.</source>
          <target state="translated">在这个例子中,a和null都会被隐式地转为double。</target>
        </trans-unit>
        <trans-unit id="e27f98b53bc5588e16ad4f1af469c5dfda881206" translate="yes" xml:space="preserve">
          <source>In this example cache is used to specify a file located on the cluster compute nodes.</source>
          <target state="translated">在这个例子中,缓存用来指定一个位于集群计算节点上的文件。</target>
        </trans-unit>
        <trans-unit id="0dfa087e0c75a861542022b8ebc000c17d370200" translate="yes" xml:space="preserve">
          <source>In this example data is loaded with a schema.</source>
          <target state="translated">在这个例子中,数据是用模式加载的。</target>
        </trans-unit>
        <trans-unit id="d52a2a475a46079874a2842b0e1af3a3ae07325b" translate="yes" xml:space="preserve">
          <source>In this example data is loaded without a schema; it assumes there is a .pig_schema (produced by JsonStorage) in the input directory.</source>
          <target state="translated">在这个例子中,数据的加载没有模式,它假设在输入目录中有一个.pig_schema(由JsonStorage产生)。</target>
        </trans-unit>
        <trans-unit id="98510e7774ca7a3b39f659179e898062288bbc9c" translate="yes" xml:space="preserve">
          <source>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</source>
          <target state="translated">在这个例子中,数据使用PigStorage和星号字符(*)作为字段分隔符来存储。</target>
        </trans-unit>
        <trans-unit id="993517c57ee376d2b7b84473441b0326f8a923af" translate="yes" xml:space="preserve">
          <source>In this example default_parallel is set in the Pig script; all MapReduce jobs that get launched will use 20 reducers.</source>
          <target state="translated">在本例中,Pig脚本中设置了default_parallel,所有被启动的MapReduce作业将使用20个reducers。</target>
        </trans-unit>
        <trans-unit id="004f088c97324626f2f5dd9f710d01d17559c6aa" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to look up the value of key 'open'.</source>
          <target state="translated">在这个例子中,dereferencing被用来查找键 &quot;open &quot;的值。</target>
        </trans-unit>
        <trans-unit id="6b80a144f43f789acea82e8c85d4bcbd2d95337f" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</source>
          <target state="translated">在这个例子中,dereferencing用于从元组(group)中投射一个字段(f1),从袋子(a)中投射一个字段(f1)。</target>
        </trans-unit>
        <trans-unit id="212fc5892a721a0060e45e75350a1fbdbf50b4be" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used to retrieve two fields from tuple f2.</source>
          <target state="translated">在这个例子中,dereferencing被用来从元组f2中检索两个字段。</target>
        </trans-unit>
        <trans-unit id="904d63269308c6655e00fc821dff1fc33db0eed0" translate="yes" xml:space="preserve">
          <source>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</source>
          <target state="translated">在这个例子中,dereferencing与关系X一起使用,以投射袋(a)中每个元组的第一个字段(f1)。</target>
        </trans-unit>
        <trans-unit id="bd906ea6b105d25e2f0d5b0003b730ae52af1ed4" translate="yes" xml:space="preserve">
          <source>In this example field &quot;gpa&quot; will default to bytearray because no type is declared.</source>
          <target state="translated">在这个例子中,字段 &quot;gpa &quot;将默认为字节数,因为没有声明类型。</target>
        </trans-unit>
        <trans-unit id="71b7c69ad52a06b1bcb69143364d7c4a4045b02f" translate="yes" xml:space="preserve">
          <source>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</source>
          <target state="translated">在这个例子中,如果输入关系中的一个字段是元组、袋或映射,我们就可以在这个字段上执行投影(使用deference操作符)。</target>
        </trans-unit>
        <trans-unit id="381c3ad80f6a75a1d6369b158db1f23e56c0c1a2" translate="yes" xml:space="preserve">
          <source>In this example key value pairs are set at the command line.</source>
          <target state="translated">在这个例子中,键值对是在命令行设置的。</target>
        </trans-unit>
        <trans-unit id="036d7f9ad9b7cc7d5a796a8fa59f8957b424182b" translate="yes" xml:space="preserve">
          <source>In this example multiple key value pairs are set in the Pig script. These key value pairs are put in job-conf by Pig (making the pairs available to Pig and Hadoop). This is a script-wide setting; if a key value is defined multiple times in the script the last value will take effect and will be set for all jobs generated by the script.</source>
          <target state="translated">在这个例子中,Pig脚本中设置了多个键值对。这些键值对由 Pig 放在 job-conf 中(使这些键值对对 Pig 和 Hadoop 可用)。这是一个脚本范围内的设置;如果一个键值在脚本中被多次定义,最后一个值将生效,并将为脚本生成的所有作业设置。</target>
        </trans-unit>
        <trans-unit id="5f41fb70f423cb0dbfced17b805614a0b220128e" translate="yes" xml:space="preserve">
          <source>In this example multiple nested columns are retained.</source>
          <target state="translated">在这个例子中,保留了多个嵌套列。</target>
        </trans-unit>
        <trans-unit id="0d5857ac7ca8abbc90407cf41477661d258b1c55" translate="yes" xml:space="preserve">
          <source>In this example multiple parameters are specified.</source>
          <target state="translated">在这个例子中,指定了多个参数。</target>
        </trans-unit>
        <trans-unit id="74314f14b6f4d8ce3ccc71bc58e4f39e20febcce" translate="yes" xml:space="preserve">
          <source>In this example my_macro (defined above) is expanded. Because alias B is not visible from the outside it is renamed macro_my_macro_B_0.</source>
          <target state="translated">在这个例子中,my_macro(上面定义的)被展开。因为别名B在外部不可见,所以它被改名为宏_my_macro_B_0。</target>
        </trans-unit>
        <trans-unit id="8ef086a29e25d0a628246ae86a8dfd0251c73a5a" translate="yes" xml:space="preserve">
          <source>In this example no parameters are passed to the macro.</source>
          <target state="translated">在这个例子中,没有参数传递给宏。</target>
        </trans-unit>
        <trans-unit id="4c2b33f77cda03a397ae83edefe497af878760f6" translate="yes" xml:space="preserve">
          <source>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</source>
          <target state="translated">在这个例子中,没有指定模式,所有的字段都默认为字节数组或长类型(参见数据类型)。所有字段都默认为字节数组或长类型(参见数据类型)。</target>
        </trans-unit>
        <trans-unit id="60048a1c8591e593e65c99554a20d95fc58747db" translate="yes" xml:space="preserve">
          <source>In this example nulls are injected if fields do not have data.</source>
          <target state="translated">在这个例子中,如果字段没有数据,就会注入空值。</target>
        </trans-unit>
        <trans-unit id="c8c2d3f0591222c2c9f03e628a85df359bc7b283" translate="yes" xml:space="preserve">
          <source>In this example of an outer join, if the join key is missing from a table it is replaced by null.</source>
          <target state="translated">在这个外部连接的例子中,如果连接键从表中缺失,它将被null替换。</target>
        </trans-unit>
        <trans-unit id="0107821bc8812479bdbf1f64b26078690d140226" translate="yes" xml:space="preserve">
          <source>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</source>
          <target state="translated">在这个例子中,输出被限制为3个元组。请注意,不能保证输出的是哪三个元组。</target>
        </trans-unit>
        <trans-unit id="6926a0c31dcd9e33a949b13c70271304c004ba03" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the exec command.</source>
          <target state="translated">在这个例子中,参数替换与exec命令一起使用。</target>
        </trans-unit>
        <trans-unit id="8418fd14b7d1e17833903e6a625c75e3ce956813" translate="yes" xml:space="preserve">
          <source>In this example parameter substitution is used with the run command.</source>
          <target state="translated">在这个例子中,参数替换与运行命令一起使用。</target>
        </trans-unit>
        <trans-unit id="829f361647b770f5f6f543d85b2622ed7c6cd584" translate="yes" xml:space="preserve">
          <source>In this example parameters are passed and returned.</source>
          <target state="translated">在这个例子中,参数被传递和返回。</target>
        </trans-unit>
        <trans-unit id="f8309b5f7726c99d87799e05a93319a66d843c5f" translate="yes" xml:space="preserve">
          <source>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</source>
          <target state="translated">在这个例子中,关系A由第三个字段f3按降序排序。请注意,以3结尾的三个元组的顺序可以不同。</target>
        </trans-unit>
        <trans-unit id="c7a76748d23607d469a11fdd632d38e8948725ce" translate="yes" xml:space="preserve">
          <source>In this example relation A is split into three relations, X, Y, and Z.</source>
          <target state="translated">在这个例子中,关系A被分割成三个关系,X、Y、Z。</target>
        </trans-unit>
        <trans-unit id="ea5ae7eac546e34a2d13c3fafaa1736e62a4a6ac" translate="yes" xml:space="preserve">
          <source>In this example relation X will contain 1% of the data in relation A.</source>
          <target state="translated">在这个例子中,关系X将包含关系A中1%的数据。</target>
        </trans-unit>
        <trans-unit id="e048f00ed84c4268f680319e8d3e4543df48f677" translate="yes" xml:space="preserve">
          <source>In this example relations A and B are joined by their first fields.</source>
          <target state="translated">在这个例子中,关系A和B由它们的第一个字段连接。</target>
        </trans-unit>
        <trans-unit id="1fbb00b56354e90b99f0d0abee287efa949183ef" translate="yes" xml:space="preserve">
          <source>In this example ship is used to send the script to the cluster compute nodes.</source>
          <target state="translated">在这个例子中,ship是用来将脚本发送到集群计算节点的。</target>
        </trans-unit>
        <trans-unit id="bb32f8e1cb739afed30691ec54c7d7d010de23a0" translate="yes" xml:space="preserve">
          <source>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</source>
          <target state="translated">在这个例子中,不使用特殊字符的单字值(在本例中,mydata)不必用引号括起来。</target>
        </trans-unit>
        <trans-unit id="cb06a1600d91e4a228d8c694d3f8cc460e0f109e" translate="yes" xml:space="preserve">
          <source>In this example the &lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt; operator is used to eliminate nesting.</source>
          <target state="translated">在此示例中，&lt;a href=&quot;#flatten&quot;&gt;FLATTEN&lt;/a&gt;运算符用于消除嵌套。</target>
        </trans-unit>
        <trans-unit id="00106135a67fa0fb49d05b22a6af49367f72d99b" translate="yes" xml:space="preserve">
          <source>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</source>
          <target state="translated">在这个例子中,EXPLAIN操作符会产生所有三个计划。(请注意,本例中只显示了输出的一部分。)</target>
        </trans-unit>
        <trans-unit id="e7c916eb550f56bcc8d23590cbf1cf0c80f42104" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes FLATTEN and a schema for simple data types.</source>
          <target state="translated">在这个例子中,FOREACH语句包括FLATTEN和一个简单数据类型的模式。</target>
        </trans-unit>
        <trans-unit id="417fccbcd046561d8ffe25457defbd55e880d1fe" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schema for simple expression.</source>
          <target state="translated">在这个例子中,FOREACH语句包括一个简单表达式的模式。</target>
        </trans-unit>
        <trans-unit id="e7d9bf5151735fb7eac9687d81ce6fb8ed553219" translate="yes" xml:space="preserve">
          <source>In this example the FOREACH statement includes a schemas for multiple fields.</source>
          <target state="translated">在这个例子中,FOREACH语句包含了多个字段的模式。</target>
        </trans-unit>
        <trans-unit id="24842feb372ec793af9f761b6b82120ae0b6939d" translate="yes" xml:space="preserve">
          <source>In this example the LOAD statement includes a schema definition for simple data types.</source>
          <target state="translated">在这个例子中,LOAD语句包含了一个简单数据类型的模式定义。</target>
        </trans-unit>
        <trans-unit id="9b1685e1972a2735b748823663c7d18cc3169868" translate="yes" xml:space="preserve">
          <source>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</source>
          <target state="translated">在这个例子中,ORDER操作符用于对元组进行排序,LIMIT操作符用于输出前三个元组。</target>
        </trans-unit>
        <trans-unit id="d46d714daa065ac64bf616b27d931b45616989ad" translate="yes" xml:space="preserve">
          <source>In this example the asterisk (*) is used to project all fields from relation A to relation X. Relation A and X are identical.</source>
          <target state="translated">在这个例子中,星号(*)用于将所有字段从关系A投射到关系X。关系A和X是相同的。</target>
        </trans-unit>
        <trans-unit id="f747b7eff53d66ec54b4dcd3a59958f8f656a8bc" translate="yes" xml:space="preserve">
          <source>In this example the average GPA for each student is computed (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">在此示例中，将计算每个学生的平均GPA（有关关系B中字段名称的信息，请参阅&lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt;运算符）。</target>
        </trans-unit>
        <trans-unit id="ce3f8dbd72e1ca5670215036e9a44f0b071ca7c3" translate="yes" xml:space="preserve">
          <source>In this example the bincond operator is used with fields f2 and B. The condition is &quot;f2 equals 1&quot;; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</source>
          <target state="translated">在本例中,对字段f2和B使用了bincond运算符,条件是 &quot;f2等于1&quot;;如果条件为真,返回1;如果条件为假,返回B中的图元数。</target>
        </trans-unit>
        <trans-unit id="6aaa13edf7e147edb799d5432c00b145a2899bd3" translate="yes" xml:space="preserve">
          <source>In this example the built in function SUM() is used to sum a set of numbers in a bag.</source>
          <target state="translated">在这个例子中,内置的函数SUM()被用来对一个袋子中的一组数字进行求和。</target>
        </trans-unit>
        <trans-unit id="f0ad9fb42b25648f0ae623cc3fafcfffe7daac86" translate="yes" xml:space="preserve">
          <source>In this example the case operator is used with field f2. The expression is &quot;f2 % 2&quot;; if the expression is equal to 0, return 'even'; if the expression is equal to 1, return 'odd'.</source>
          <target state="translated">在这个例子中,case运算符被用于字段f2。表达式为 &quot;f2 % 2&quot;;如果表达式等于0,返回 &quot;偶数&quot;;如果表达式等于1,返回 &quot;奇数&quot;。</target>
        </trans-unit>
        <trans-unit id="092f4e5a8bef8cb9851796d251a7997b165bdd80" translate="yes" xml:space="preserve">
          <source>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped.</source>
          <target state="translated">在这个例子中,字符(在本例中,Joe的URL)可以用单引号或双引号括起来,并且可以对字符序列中的引号进行转义。</target>
        </trans-unit>
        <trans-unit id="ede799c3bc9b3029dc9c8360cd04456907800fde" translate="yes" xml:space="preserve">
          <source>In this example the clear command clean up Pig grunt shell.</source>
          <target state="translated">在本例中,清除命令清理Pig grunt shell。</target>
        </trans-unit>
        <trans-unit id="25d6ee41375a393d7a680688e835a625f56d5bef" translate="yes" xml:space="preserve">
          <source>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</source>
          <target state="translated">在这个例子中,命令是用后划线括起来的。首先,在遇到声明语句时,将参数mycmd和date代入。然后执行产生的命令,并将其stdout放在加载语句运行前的路径中。</target>
        </trans-unit>
        <trans-unit id="b89b66c6c88049c686630255f175fff0f626bdcf" translate="yes" xml:space="preserve">
          <source>In this example the command is executed and its stdout is used as the parameter value.</source>
          <target state="translated">在这个例子中,命令被执行,其stdout被用作参数值。</target>
        </trans-unit>
        <trans-unit id="8ce0f2c976b3fe8e4f40f38c3029dab1eb1cec85" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</source>
          <target state="translated">在这个例子中,条件规定,如果第一个字段等于8,或者如果字段f2和f3之和不大于第一个字段,那么包括元组关系X。</target>
        </trans-unit>
        <trans-unit id="26b224c7415697f3852d73862430dd9075adbd5f" translate="yes" xml:space="preserve">
          <source>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</source>
          <target state="translated">在这个例子中,条件规定,如果第三个字段等于3,那么包括关系X的元组。</target>
        </trans-unit>
        <trans-unit id="d1025ef014af40aa64437028c4999384b00c45c4" translate="yes" xml:space="preserve">
          <source>In this example the cross product of relation A and B is computed.</source>
          <target state="translated">在这个例子中,计算关系A和B的交叉积。</target>
        </trans-unit>
        <trans-unit id="acbe209f9e9a1e61b98b326bbd67ec1907b268ea" translate="yes" xml:space="preserve">
          <source>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</source>
          <target state="translated">在这个例子中,数据文件包含tuples。复杂数据类型的模式(在本例中是元组)被用来加载数据,然后,dereference运算符(t1.t1a和t2.$0中的点)被用来访问元组中的字段。然后,去引用操作符(t1.t1a和t2.$0中的点)被用来访问元组中的字段。请注意,当您为字段分配名称时,您仍然可以使用位置符号来引用这些字段。</target>
        </trans-unit>
        <trans-unit id="4e4e82302c1dcf3cf245b321e2f2024b324f3f18" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped and ordered.</source>
          <target state="translated">在本例中,对数据进行了分组和排序。</target>
        </trans-unit>
        <trans-unit id="d6c450e1b8e75a80b634b42feb0e20c5b019d350" translate="yes" xml:space="preserve">
          <source>In this example the data is grouped.</source>
          <target state="translated">在这个例子中,数据是分组的。</target>
        </trans-unit>
        <trans-unit id="cb28ee9adf8539445368e3a7354c61897a47de43" translate="yes" xml:space="preserve">
          <source>In this example the data is unordered.</source>
          <target state="translated">在这个例子中,数据是无序的。</target>
        </trans-unit>
        <trans-unit id="6603ac59abe4e83a9f3630ed1514e5ee65f95568" translate="yes" xml:space="preserve">
          <source>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray.</source>
          <target state="translated">在这个例子中,默认的加载函数PigStorage从myfile.txt中加载数据以形成关系A,这两条LOAD语句是等价的。请注意,由于没有指定模式,字段没有命名,所有字段默认为字节数组类型。</target>
        </trans-unit>
        <trans-unit id="eb0d387430982dda1c08cffe6bc594f972418231" translate="yes" xml:space="preserve">
          <source>In this example the history command shows all the statements with line numbers and without them.</source>
          <target state="translated">在这个例子中,历史记录命令显示了所有带行号和不带行号的语句。</target>
        </trans-unit>
        <trans-unit id="476af286c3ec71967ab312182ce2b62adf926b94" translate="yes" xml:space="preserve">
          <source>In this example the job with id job_0001 is killed.</source>
          <target state="translated">在这个例子中,id为job_0001的作业被杀死。</target>
        </trans-unit>
        <trans-unit id="b029e1c370efb6daa4ba5eb4f901c821a93416f8" translate="yes" xml:space="preserve">
          <source>In this example the limit is expressed as a scalar.</source>
          <target state="translated">在这个例子中,极限用标量表示。</target>
        </trans-unit>
        <trans-unit id="2e34eec81ca9c49c22acf02db69215d8d4e34e78" translate="yes" xml:space="preserve">
          <source>In this example the ls command is invoked.</source>
          <target state="translated">在这个例子中,调用了ls命令。</target>
        </trans-unit>
        <trans-unit id="76f374ece7dcad13158f830af8da60b38d97b189" translate="yes" xml:space="preserve">
          <source>In this example the macro does not have a return alias; thus, void must be specified.</source>
          <target state="translated">在这个例子中,宏没有返回的别名,因此,必须指定void。</target>
        </trans-unit>
        <trans-unit id="cd64ffc9b96611ae3793e3e5ba859e7d36b80811" translate="yes" xml:space="preserve">
          <source>In this example the macro is named my_macro. Note that only aliases A and C are visible from the outside; alias B is not visible from the outside.</source>
          <target state="translated">在这个例子中,宏的名字是my_macro。注意,只有别名A和C从外部可见,别名B从外部不可见。</target>
        </trans-unit>
        <trans-unit id="6404afa0a6b34470610936e43c5cf53ae1ed10be" translate="yes" xml:space="preserve">
          <source>In this example the map includes two key value pairs.</source>
          <target state="translated">在这个例子中,地图包括两个键值对。</target>
        </trans-unit>
        <trans-unit id="1711a19cfa3302a682910d13c83d53af9d0f1b78" translate="yes" xml:space="preserve">
          <source>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">在这个例子中,所有学期的最大GPA是为每个学生计算的(关于关系B中字段名的信息,请参见GROUP操作符)。</target>
        </trans-unit>
        <trans-unit id="9d880bfbdf389fd36ac97f66b734bd7cf322568a" translate="yes" xml:space="preserve">
          <source>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">在这个例子中,所有学期的最低GPA是为每个学生计算的(参见GROUP操作符,了解关系B中字段名的信息)。</target>
        </trans-unit>
        <trans-unit id="6f6938263aa57a2bb9d2caa685487136b07bb471" translate="yes" xml:space="preserve">
          <source>In this example the modulo operator is used with fields f1 and f2.</source>
          <target state="translated">在这个例子中,模数运算符被用于字段f1和f2。</target>
        </trans-unit>
        <trans-unit id="9587d64b9e55a467c8f05370b86a5919538e4e78" translate="yes" xml:space="preserve">
          <source>In this example the number of characters in the first field is computed.</source>
          <target state="translated">在这个例子中,第一个字段中的字符数被计算出来。</target>
        </trans-unit>
        <trans-unit id="1b286a09468d93c61174ef82f5d5ce20e0200311" translate="yes" xml:space="preserve">
          <source>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</source>
          <target state="translated">在这个例子中,宠物的数量被计算出来。参见GROUP操作符,了解关系B中字段名的信息)。</target>
        </trans-unit>
        <trans-unit id="1317fabb77110a5157dbf3c1989811a052d00d38" translate="yes" xml:space="preserve">
          <source>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</source>
          <target state="translated">在这个例子中,Pig脚本中使用默认语句指定了参数(DATE)和值('20090101')。如果没有在其他地方指定DATE的值,则使用默认值20090101。</target>
        </trans-unit>
        <trans-unit id="2e98bd8685b77fd467a6fbb1af6b37b502f7b21e" translate="yes" xml:space="preserve">
          <source>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</source>
          <target state="translated">在这个例子中,参数(data)和参数值(mydata)是在命令行中指定的,如果命令行中的参数名(data)和脚本中的参数名($data)不一致,脚本将无法运行。如果命令行中的参数名(data)和脚本中的参数名($data)不匹配,脚本将无法运行。如果没有找到参数的值(mydata),就会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="6ed4d9d9c3e64f1c8ed8531ebff8cca25da2370b" translate="yes" xml:space="preserve">
          <source>In this example the parameters and values are passed to the script using the parameter file.</source>
          <target state="translated">在这个例子中,参数和值是通过参数文件传递给脚本的。</target>
        </trans-unit>
        <trans-unit id="a1b2909b057f9a09ca537aaf439edc1877ad06cf" translate="yes" xml:space="preserve">
          <source>In this example the percentage of clicks belonging to a particular user are computed. For the FOREACH statement, an explicit cast is used. If the SUM is not given a name, a position can be used as well (userid, clicks/(double)C.$0).</source>
          <target state="translated">在这个例子中,计算了属于特定用户的点击率。对于FOREACH语句,使用了显式的投值。如果没有给SUM命名,也可以使用一个位置(userid,clicks/(double)C.$0)。</target>
        </trans-unit>
        <trans-unit id="d4aff9a2fd5846372e7438a9400d514b26787e3a" translate="yes" xml:space="preserve">
          <source>In this example the quit command exits the Pig grunt shall.</source>
          <target state="translated">在本例中,退出命令退出Pig grunt应。</target>
        </trans-unit>
        <trans-unit id="2d4709cf6d5853667a759dfa1d106eed84020b7e" translate="yes" xml:space="preserve">
          <source>In this example the same data is loaded twice using aliases A and B.</source>
          <target state="translated">在这个例子中,相同的数据使用别名A和B加载两次。</target>
        </trans-unit>
        <trans-unit id="fc5789de4d75cad94be41c5facecc34fe4971feb" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a bag. The two load statements are equivalent.</source>
          <target state="translated">在这个例子中,模式定义了一个袋子。这两个加载语句是等价的。</target>
        </trans-unit>
        <trans-unit id="8755ba412043fe803f3282f9a04a78a7dee177a3" translate="yes" xml:space="preserve">
          <source>In this example the schema defines a tuple, bag, and map.</source>
          <target state="translated">在这个例子中,模式定义了一个元组、袋子和地图。</target>
        </trans-unit>
        <trans-unit id="7cd7118a92ca87fa2d331c8470cf4842dff265de" translate="yes" xml:space="preserve">
          <source>In this example the schema defines an untyped map (the map values default to bytearray). The load statements are equivalent.</source>
          <target state="translated">在这个例子中,模式定义了一个非类型的映射(映射值默认为bytearray)。加载语句是等价的。</target>
        </trans-unit>
        <trans-unit id="5cd0cb1fc97ce5841696cd76163b3e5eb768aca1" translate="yes" xml:space="preserve">
          <source>In this example the schema defines multiple types.</source>
          <target state="translated">在这个例子中,模式定义了多种类型。</target>
        </trans-unit>
        <trans-unit id="82f2e4223d2166be4de020826791e51ada52b60a" translate="yes" xml:space="preserve">
          <source>In this example the schema defines one tuple. The load statements are equivalent.</source>
          <target state="translated">在这个例子中,模式定义了一个元组。加载语句是等价的。</target>
        </trans-unit>
        <trans-unit id="bf67db086de69e41eae0849cf525acbd64482062" translate="yes" xml:space="preserve">
          <source>In this example the schema defines two tuples.</source>
          <target state="translated">在这个例子中,模式定义了两个元组。</target>
        </trans-unit>
        <trans-unit id="374e1d1c9089f64e9a3f6e17445b7108876892bc" translate="yes" xml:space="preserve">
          <source>In this example the script interacts with the results of commands issued via the Grunt shell.</source>
          <target state="translated">在这个例子中,脚本与通过Grunt shell发出的命令结果进行交互。</target>
        </trans-unit>
        <trans-unit id="99317ecfb2f2d2f8e22397ef775944c5ef25b329" translate="yes" xml:space="preserve">
          <source>In this example the script is displayed and run.</source>
          <target state="translated">在这个例子中,脚本被显示和运行。</target>
        </trans-unit>
        <trans-unit id="2e598eccd5a601dd744d347f16c97195afdc76a1" translate="yes" xml:space="preserve">
          <source>In this example the streaming stderr is stored in the _logs/&amp;lt;dir&amp;gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</source>
          <target state="translated">在此示例中，流式stderr存储在作业的输出目录的_logs / &amp;lt;dir&amp;gt;目录中。由于作业可以具有多个与之关联的流应用程序，因此您需要确保使用不同的目录名来避免冲突。Pig每个流作业最多可存储100个任务。</target>
        </trans-unit>
        <trans-unit id="12004346bfe8b9058047ed1fff89d8df9e7971b7" translate="yes" xml:space="preserve">
          <source>In this example the strings in each row are split.</source>
          <target state="translated">在这个例子中,每一行的字符串都被拆分。</target>
        </trans-unit>
        <trans-unit id="5ca70fcce90aa1c6cf4766d1a9176002ded5188b" translate="yes" xml:space="preserve">
          <source>In this example the top 10 occurrences are returned.</source>
          <target state="translated">在这个例子中,返回前10个出现次数。</target>
        </trans-unit>
        <trans-unit id="021afd1412e5a5955bb3fb59bfd3c0a85c063129" translate="yes" xml:space="preserve">
          <source>In this example the tuple contains three fields.</source>
          <target state="translated">在这个例子中,元组包含三个字段。</target>
        </trans-unit>
        <trans-unit id="f597683856676d8bafb6405513e3ebe7baf66915" translate="yes" xml:space="preserve">
          <source>In this example the tuples are grouped using an expression, f2*f3.</source>
          <target state="translated">在这个例子中,使用表达式f2*f3对元组进行分组。</target>
        </trans-unit>
        <trans-unit id="5e310234a9bc1536d78449f454a40dbd0fea419f" translate="yes" xml:space="preserve">
          <source>In this example the tuples in the bag are counted (see the &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; operator for information about the field names in relation B).</source>
          <target state="translated">在此示例中，对袋子中的元组进行计数（有关关系B中字段名称的信息，请参阅&lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt;运算符）。</target>
        </trans-unit>
        <trans-unit id="c431411d674fcbd3d4993f3b148f0ab1fd9627c8" translate="yes" xml:space="preserve">
          <source>In this example the union of relation A and B is computed.</source>
          <target state="translated">在这个例子中,计算关系A和B的结合。</target>
        </trans-unit>
        <trans-unit id="6d9b64e41ad4836645b8177be3ac9c0030fd0d8b" translate="yes" xml:space="preserve">
          <source>In this example tuples are co-grouped using field &amp;ldquo;owner&amp;rdquo; from relation A and field &amp;ldquo;friend2&amp;rdquo; from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has three fields, &quot;group&quot;, &quot;A&quot; and &quot;B&quot; (see the GROUP operator for information about the field names).</source>
          <target state="translated">在此示例中，使用关系A的字段&amp;ldquo;所有者&amp;rdquo;和关系B的字段&amp;ldquo; friend2&amp;rdquo;作为关键字段对元组进行了分组。DESCRIBE运算符显示关系X的模式，该关系具有三个字段&amp;ldquo; group&amp;rdquo;，&amp;ldquo; A&amp;rdquo;和&amp;ldquo; B&amp;rdquo;（有关字段名称的信息，请参阅GROUP运算符）。</target>
        </trans-unit>
        <trans-unit id="dde4ecc1f27426000ba5fe853e50128821f2f398" translate="yes" xml:space="preserve">
          <source>In this example two fields from relation A are projected to form relation X.</source>
          <target state="translated">在这个例子中,关系A的两个字段被投影成关系X。</target>
        </trans-unit>
        <trans-unit id="bc47fb195353fb6458455bd7a9f15093c04fb95c" translate="yes" xml:space="preserve">
          <source>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</source>
          <target state="translated">在这个例子中,关系A中的两个字段相加形成关系X,为投影字段定义了一个模式。</target>
        </trans-unit>
        <trans-unit id="374e1a3a44b5c072bbee353fcde0ae6d5ba08c31" translate="yes" xml:space="preserve">
          <source>In this example user defined serialization/deserialization functions are used with the script.</source>
          <target state="translated">在这个例子中,用户定义的序列化/反序列化函数被用于脚本。</target>
        </trans-unit>
        <trans-unit id="7c1a5311dceb63c974e9b2cfc727be221f3bb244" translate="yes" xml:space="preserve">
          <source>In this example we filter out ID 4 and 6.</source>
          <target state="translated">在这个例子中,我们过滤掉ID4和6。</target>
        </trans-unit>
        <trans-unit id="12cea5022f6e359ede64a2f3cade86cdf43e9f89" translate="yes" xml:space="preserve">
          <source>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE. Also, note the use of projection (PA = FA.outlink;) to retrieve a field. DISTINCT can be applied to a subset of fields (as opposed to a relation) only within a nested block.</source>
          <target state="translated">在这个例子中,我们执行了嵌套块中允许的两个操作:FILTER和DISTINCT。请注意,嵌套块中的最后一条语句必须是GENERATE。另外,请注意使用投影(PA=FA.outlink;)来检索一个字段。DISTINCT只能应用于嵌套块中的字段子集(而不是关系)。</target>
        </trans-unit>
        <trans-unit id="fa386fd96cd26dfb68e71c6977b54eb2ca55f776" translate="yes" xml:space="preserve">
          <source>In this example, Pig will validate and then execute the LOAD, FOREACH, and DUMP statements.</source>
          <target state="translated">在这个例子中,Pig将验证,然后执行LOAD、FOREACH和DUMP语句。</target>
        </trans-unit>
        <trans-unit id="d4558a0e1b18bdd5eee2ed93dafa87c2da9e505c" translate="yes" xml:space="preserve">
          <source>In this example, PigStorage loads data with complex data type, a bag of map and double.</source>
          <target state="translated">在这个例子中,PigStorage加载的数据类型很复杂,是一袋map和double的数据。</target>
        </trans-unit>
        <trans-unit id="b9f6baa8723253b0ff5da6f6200823682a8e7924" translate="yes" xml:space="preserve">
          <source>In this example, SUBTRACT creates a new bag composed of B1 elements that are not in B2.</source>
          <target state="translated">在这个例子中,SUBTRACT创建了一个由B1元素组成的新袋子,这些元素不在B2中。</target>
        </trans-unit>
        <trans-unit id="628bdb7c844633083f052de93a85c78a122db14c" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with one field is converted to a tuple.</source>
          <target state="translated">在这个例子中,一个包含有一个字段的元组的袋子被转换为一个元组。</target>
        </trans-unit>
        <trans-unit id="31ad0d826c111e02076048c8e848b2bc5512a7f5" translate="yes" xml:space="preserve">
          <source>In this example, a bag containing tuples with two fields is converted to a tuple.</source>
          <target state="translated">在这个例子中,一个包含有两个字段的元组的袋子被转换为一个元组。</target>
        </trans-unit>
        <trans-unit id="7ba1ab45b8d5e801bda851513ebce706791389a2" translate="yes" xml:space="preserve">
          <source>In this example, a scalar expression is used (it will sample approximately 1000 records from the input).</source>
          <target state="translated">在这个例子中,使用了一个标量表达式(它将从输入中抽取大约1000条记录)。</target>
        </trans-unit>
        <trans-unit id="0c050f08cf94a0faf1569c2cd017c23c7029793b" translate="yes" xml:space="preserve">
          <source>In this example, because a path is not given, Pig will use the import path specified in pig.import.search.path.</source>
          <target state="translated">在这个例子中,由于没有给出路径,Pig将使用pig.import.search.path中指定的导入路径。</target>
        </trans-unit>
        <trans-unit id="f8d18d2738156bb9536be2726da1b0055af29572" translate="yes" xml:space="preserve">
          <source>In this example, fields f1 and f3 are converted to tuples that are then placed in a bag.</source>
          <target state="translated">在这个例子中,字段f1和f3被转换为元组,然后放在一个袋子里。</target>
        </trans-unit>
        <trans-unit id="8b5550925189ae7bf57a03a71682900e5449f00f" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, an underscore string literal, f2 and f3 are concatenated.</source>
          <target state="translated">在这个例子中,字段f1(下划线字符串文字)、f2和f3被连接起来。</target>
        </trans-unit>
        <trans-unit id="3ab2c3d36b021dc631caeb2e9d192769dc62ae3c" translate="yes" xml:space="preserve">
          <source>In this example, fields f1, f2 and f3 are converted to a tuple.</source>
          <target state="translated">在这个例子中,字段f1、f2和f3被转换为元组。</target>
        </trans-unit>
        <trans-unit id="7924a4aff410ec62e1625fb749420c25e9e40967" translate="yes" xml:space="preserve">
          <source>In this example, parameters passed to run/exec command or declared within the called scripts are not visible to the caller.</source>
          <target state="translated">在这个例子中,传递给运行/执行命令的参数或在被调用的脚本中声明的参数对调用者不可见。</target>
        </trans-unit>
        <trans-unit id="3bb04af80246e86e73ab32302c82691b112dec27" translate="yes" xml:space="preserve">
          <source>In this example, student names (type chararray) and student GPAs (type float) are used to create three maps.</source>
          <target state="translated">在这个例子中,学生姓名(类型为chararray)和学生GPA(类型为float)被用来创建三个地图。</target>
        </trans-unit>
        <trans-unit id="e7bb96091fb633aa0dd9a62cf0641bf708fbda94" translate="yes" xml:space="preserve">
          <source>In this example, the CONCAT function is used to format the data before it is stored.</source>
          <target state="translated">在本例中,CONCAT函数用于在存储数据之前对其进行格式化。</target>
        </trans-unit>
        <trans-unit id="067351e08e674c5bf43312d16f3cfc906bf4efea" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator does not change the order of the relation and simply prepends to each tuple a sequential value.</source>
          <target state="translated">在这个例子中,RANK操作符并没有改变关系的顺序,只是给每个元组预置了一个顺序值。</target>
        </trans-unit>
        <trans-unit id="f697de11b6e8be82a227e004decddf6bf4447be5" translate="yes" xml:space="preserve">
          <source>In this example, the RANK operator works with f1 and f2 fields, and each one with different sorting order. RANK sorts the relation on these fields and prepends the rank value to each tuple. Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">在这个例子中,RANK操作符适用于f1和f2字段,而且每个字段都有不同的排序顺序。RANK在这些字段上对关系进行排序,并在每个元组上预输入秩值。否则,RANK操作符使用每个字段(或字段集)对关系进行排序。一个元组的等级是1加上它前面不同等级值的数量。如果两个或更多的元组在排序字段值上打成平手,它们将获得相同的等级。</target>
        </trans-unit>
        <trans-unit id="1f3b4221a79d008988b7876075995e6b8d7835e6" translate="yes" xml:space="preserve">
          <source>In this example, the SPLIT and FILTER statements are essentially equivalent. However, because SPLIT is implemented as &quot;split the data stream and then apply filters&quot; the SPLIT statement is more expensive than the FILTER statement because Pig needs to filter and store two data streams.</source>
          <target state="translated">在这个例子中,SPLIT和FILTER语句基本上是等价的。但是,由于SPLIT的实现方式是 &quot;分割数据流,然后应用过滤器&quot;,所以SPLIT语句比FILTER语句更昂贵,因为Pig需要过滤和存储两个数据流。</target>
        </trans-unit>
        <trans-unit id="14d08384e4aaff3f8be0a78561d22848f60f1375" translate="yes" xml:space="preserve">
          <source>In this example, the function gets one parameter of type float and another of type double. The best fit will be the function that takes two double values. Pig makes this choice on the user's behalf by inserting implicit casts for the parameters. Running the script above is equivalent to running the script below:</source>
          <target state="translated">在这个例子中,函数得到一个类型为float的参数和另一个类型为double的参数。最适合的是取两个双值的函数。Pig通过为参数插入隐式的casts来代表用户做出这个选择。运行上面的脚本相当于运行下面的脚本。</target>
        </trans-unit>
        <trans-unit id="881155eba58f9e850386857207058c2bcc0dde01" translate="yes" xml:space="preserve">
          <source>In this example, the negation operator is applied to the &quot;x&quot; values.</source>
          <target state="translated">在这个例子中,否定运算符被应用于 &quot;x &quot;值。</target>
        </trans-unit>
        <trans-unit id="ed1b3ee3654de3cdf2209317bbe036a32a65e1c9" translate="yes" xml:space="preserve">
          <source>In this example, to disambiguate y, use A::y or B::y. In cases where there is no ambiguity, such as z, the :: is not necessary but is still supported.</source>
          <target state="translated">在这个例子中,要消除y的歧义,可以使用A::y或B::y。在没有歧义的情况下,例如z,不需要使用::,但仍然支持。</target>
        </trans-unit>
        <trans-unit id="0224a2baaf9cd9707e2e7cf53337aeaeaf373da6" translate="yes" xml:space="preserve">
          <source>In this example, values that are not null are obtained.</source>
          <target state="translated">在这个例子中,得到的值不是空的。</target>
        </trans-unit>
        <trans-unit id="6e4679058adb8da48ed2faf2b2035bd49505dbe0" translate="yes" xml:space="preserve">
          <source>In this example, we pass (null, &quot;names.txt&quot;) to the construct of UDF in_file, meaning the first parameter is regular, the second parameter is a constant. names.txt can be double quoted (unlike other Pig syntax), or quoted in \'. Note we need to pass 'names.txt' again in line 3. This looks stupid but we need to do this to fill the semantic gap between Pig and Hive. We need to pass the constant in the data pipeline in line 3, which is similar Pig UDF. Initialization code in Hive UDF takes ObjectInspector, which capture the data type and whether or not the parameter is a constant. However, initialization code in Pig takes schema, which only capture the former. We need to use additional mechanism (construct parameter) to convey the later.</source>
          <target state="translated">在这个例子中,我们将(null,&quot;names.txt&quot;)传递给UDF in_file的构造,这意味着第一个参数是常规参数,第二个参数是常量。names.txt可以是双引号(与其他Pig语法不同),或者用'/'引号。注意,我们需要在第3行再次传递'names.txt'。这看起来很愚蠢,但我们需要这样做来填补Pig和Hive之间的语义空白。我们需要在第3行传递数据管道中的常量,这是类似Pig UDF。Hive UDF中的初始化代码采取ObjectInspector,它可以捕获数据类型和参数是否为常量。但是,Pig中的初始化代码采取schema,只捕获前者。我们需要使用额外的机制(构造参数)来传达后者。</target>
        </trans-unit>
        <trans-unit id="9c2dcd3fec58a0ebe5b61ce427c75e4270cee26f" translate="yes" xml:space="preserve">
          <source>In this example, we're passing a BigInteger and using NOT operator, thereby negating the passed list of fields in the IN clause</source>
          <target state="translated">在这个例子中,我们传递了一个BigInteger,并使用NOT操作符,从而否定了IN子句中传递的字段列表。</target>
        </trans-unit>
        <trans-unit id="b8ac1c53434de8d305b7f189975c25cebec6a49b" translate="yes" xml:space="preserve">
          <source>In this script, MYUDF might try to read from out1, a file that A was just stored into. However, Pig does not know that MYUDF depends on the out1 file and might submit the jobs producing the out2 and out1 files at the same time.</source>
          <target state="translated">在这个脚本中,MYUDF可能会尝试从out1中读取A刚刚存储到的文件,但Pig并不知道MYUDF依赖于out1文件,可能会同时提交产生out2和out1文件的作业。然而,Pig并不知道MYUDF依赖于out1文件,可能会同时提交产生out2和out1文件的作业。</target>
        </trans-unit>
        <trans-unit id="eaeebfe1f5eff1ee401092bdf4bfaa13b02e1352" translate="yes" xml:space="preserve">
          <source>In this script, the STORE/LOAD operators have different file paths; however, the LOAD operator depends on the STORE operator.</source>
          <target state="translated">在这个脚本中,STORE/LOAD操作符有不同的文件路径,但是LOAD操作符依赖于STORE操作符。</target>
        </trans-unit>
        <trans-unit id="388a7f3ab68e1015ed7e6c293c2ff263c2a3d0ea" translate="yes" xml:space="preserve">
          <source>Increase the parallelism of a job by specifying the number of reduce tasks, n.</source>
          <target state="translated">通过指定reduce任务的数量n来增加作业的并行度。</target>
        </trans-unit>
        <trans-unit id="e9a90a62d3ab8cd810db61a4caae391f73d2d675" translate="yes" xml:space="preserve">
          <source>Inner merge join (between two tables) will only work under these conditions:</source>
          <target state="translated">内部合并连接(两张表之间)只有在这些条件下才会生效。</target>
        </trans-unit>
        <trans-unit id="03a548863c266dc43de099b2b4dcd58730363f30" translate="yes" xml:space="preserve">
          <source>InputStats</source>
          <target state="translated">InputStats</target>
        </trans-unit>
        <trans-unit id="a881c6dfaceae2347739afd1176127808734fa29" translate="yes" xml:space="preserve">
          <source>Inside your script, you can define parameters and then pass parameters from command line to your script. There are two ways to pass parameters to your script:</source>
          <target state="translated">在你的脚本里面,你可以定义参数,然后从命令行传递参数到你的脚本。有两种方法可以将参数传递给你的脚本。</target>
        </trans-unit>
        <trans-unit id="d38ec86271222cf540ae29ce6fdce3cf0bb0bdae" translate="yes" xml:space="preserve">
          <source>Instead of figuring out the dependencies manually, downloading them and registering each jar using the above &lt;a href=&quot;#register-jar&quot;&gt;register command&lt;/a&gt;, you can specify the artifact's coordinates and expect pig to automatically fetch the required dependencies, download and register them.</source>
          <target state="translated">无需手动找出依赖关系，而是使用上述&lt;a href=&quot;#register-jar&quot;&gt;register命令&lt;/a&gt;下载依赖关系并注册每个jar ，您可以指定工件的坐标，并期望Pig自动获取所需的依赖关系，进行下载并注册。</target>
        </trans-unit>
        <trans-unit id="f6e225003256a2a1b59e6d92b0617521bd13c8e2" translate="yes" xml:space="preserve">
          <source>Instead use ToString to format the date/time portions and SPRINTF to layout the results.</source>
          <target state="translated">相反,使用ToString来格式化日期/时间部分,并使用SPRINTF来布局结果。</target>
        </trans-unit>
        <trans-unit id="4cf0450c6e840f4cdcb5c3195b6b05d10c9d0ad9" translate="yes" xml:space="preserve">
          <source>Instead, assemble it in pieces. In step 2, we sort on one field but process another; it remains in the sorted order.</source>
          <target state="translated">相反,将其分块组装。在步骤2中,我们对一个字段进行排序,但对另一个字段进行处理;它仍然保持排序顺序。</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="94dc8e4a59fafe99eded0ffa98b6e8ea00efeca7" translate="yes" xml:space="preserve">
          <source>Interaction</source>
          <target state="translated">Interaction</target>
        </trans-unit>
        <trans-unit id="af3758608388b05871589b2b19e12008ace4a0d4" translate="yes" xml:space="preserve">
          <source>Interactive Mode</source>
          <target state="translated">互动模式</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="048850efc4e3902868045111cefcac3a0e527ce7" translate="yes" xml:space="preserve">
          <source>Invalid identifiers:</source>
          <target state="translated">无效的标识符。</target>
        </trans-unit>
        <trans-unit id="888bb77151bd6eaba885bae449bb376eb7118989" translate="yes" xml:space="preserve">
          <source>Invocation Basics</source>
          <target state="translated">调用基础知识</target>
        </trans-unit>
        <trans-unit id="b747cea14bf58e7def2e01119aae868ffb489ab7" translate="yes" xml:space="preserve">
          <source>Invocation Details</source>
          <target state="translated">调用详情</target>
        </trans-unit>
        <trans-unit id="cb31f6339e723fd50bd0157d6fe131b36204092b" translate="yes" xml:space="preserve">
          <source>Invokes any FsShell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">在 Pig 脚本或 Grunt shell 中调用任何 FsShell 命令。</target>
        </trans-unit>
        <trans-unit id="387341bd057cbb29666274908fe3359e6d22dd4f" translate="yes" xml:space="preserve">
          <source>Invokes any sh shell command from within a Pig script or the Grunt shell.</source>
          <target state="translated">在 Pig 脚本或 Grunt shell 中调用任何 sh shell 命令。</target>
        </trans-unit>
        <trans-unit id="002b9d3672a67b31dde384d5c82b77b20d5c5873" translate="yes" xml:space="preserve">
          <source>IsEmpty</source>
          <target state="translated">IsEmpty</target>
        </trans-unit>
        <trans-unit id="363a45b6f463769784d3f21486a12e29d0abf261" translate="yes" xml:space="preserve">
          <source>IsEmpty(expression)</source>
          <target state="translated">IsEmpty(expression)</target>
        </trans-unit>
        <trans-unit id="88de2259b3b3f72d4d9041583c92b54b45aa01e0" translate="yes" xml:space="preserve">
          <source>It is possible to enable a Hadoop job to request new tickets when they expire by creating a keytab file and make it part of the job that is running in the cluster. This will extend the maximum job duration beyond the maximum renew time of the kerberos tickets.</source>
          <target state="translated">可以通过创建一个 keytab 文件,使 Hadoop 作业在票据过期时请求新的票据,并使其成为集群中运行的作业的一部分。这将延长作业的最大持续时间,超过 kerberos 票据的最大更新时间。</target>
        </trans-unit>
        <trans-unit id="33cd6ef902f5caf739b2a2823cacab7fda072487" translate="yes" xml:space="preserve">
          <source>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</source>
          <target state="translated">只有从集群上的任务的当前工作目录中运送文件来执行才是安全的。</target>
        </trans-unit>
        <trans-unit id="d9433ba5a82fa587313360ad26116c0000526441" translate="yes" xml:space="preserve">
          <source>It is simple to fetch all columns from Airport codes that fall between Boston and San Francisco that can be viewed with 'auth1' and/or 'auth2' Accumulo authorizations.</source>
          <target state="translated">很简单,从波士顿和旧金山之间的机场代码中获取所有列,可以用'auth1'和/或'auth2'Accumulo授权查看。</target>
        </trans-unit>
        <trans-unit id="eb8f70933c32c8862ef0e315b9d3b91803410867" translate="yes" xml:space="preserve">
          <source>It is very important for performance to make sure that aggregate functions that are algebraic are implemented as such. Let's look at the implementation of the COUNT function to see what this means. (Error handling and some other code is omitted to save space. The full code can be accessed &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt; here&lt;/a&gt;.)</source>
          <target state="translated">对于性能而言，确保如此实现代数的聚合函数非常重要。让我们看一下COUNT函数的实现，看看这意味着什么。（为节省空间，省略了错误处理和一些其他代码。完整的代码可在&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/COUNT.java?view=markup&quot;&gt;此处&lt;/a&gt;访问。）</target>
        </trans-unit>
        <trans-unit id="27ef4d2a6cf1d08c5ea52e79fbc6638e458ce3ab" translate="yes" xml:space="preserve">
          <source>It's OK to supply too many, though</source>
          <target state="translated">不过,提供太多也没关系。</target>
        </trans-unit>
        <trans-unit id="720a64aa2e384f654ad24f02483f843d4fa544c7" translate="yes" xml:space="preserve">
          <source>JOIN (inner)</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="10dbe28c733242b09a204b8afa7bda322c04edfb" translate="yes" xml:space="preserve">
          <source>JOIN (outer)</source>
          <target state="translated">JOIN(外)</target>
        </trans-unit>
        <trans-unit id="7d1cb24c2595ad4575c4ec6e01cbd73136b6732a" translate="yes" xml:space="preserve">
          <source>Jars required for user defined functions (UDFs) are copied to distributed cache by pig to make them available on task nodes. To put these jars on distributed cache, pig clients copy these jars to HDFS under a temporary location. For scheduled jobs, these jars do not change frequently. Also, creating a lot of small jar files on HDFS is not HDFS friendly. To avoid copying these small jar files to HDFS again and again, pig allows users to configure a user level jar cache (readable only to the user for security reasons). If pig.user.cache.enabled flag is set to true, UDF jars are copied to jar cache location (configurable) under a directory named with the hash (SHA) of the jar. Hash of the jar is used to identify the existence of the jar in subsequent uses of the jar by the user. If a jar with same hash and filename is found in the cache, it is used avoiding copy of the jar to hdfs.</source>
          <target state="translated">用户定义函数(UDFs)所需的jar被pig复制到分布式缓存中,使其在任务节点上可用。为了将这些jar放在分布式缓存上,pig客户端将这些jar复制到HDFS的临时位置下。对于计划任务来说,这些jar不会经常变化。另外,在HDFS上创建大量的小jar文件对HDFS不友好。为了避免将这些小的jar文件反复复制到HDFS上,pig允许用户配置一个用户级别的jar缓存(出于安全考虑,只有用户可以读取)。如果pig.user.cache.enabled标志被设置为 &quot;true&quot;,UDF jar会被复制到jar缓存的位置(可配置),并以jar的哈希值(SHA)命名。jar的哈希值在用户后续使用jar时被用来识别jar的存在。如果在缓存中发现了一个具有相同哈希值和文件名的jar,则会使用它来避免将jar复制到hdfs。</target>
        </trans-unit>
        <trans-unit id="95430344cb2583fdd1f91fe40b6a426c6cdb7d10" translate="yes" xml:space="preserve">
          <source>Java API</source>
          <target state="translated">Java应用程序接口</target>
        </trans-unit>
        <trans-unit id="220874040658928dfd28599011834e1d343f6a06" translate="yes" xml:space="preserve">
          <source>Java BigDecimal</source>
          <target state="translated">Java BigDecimal</target>
        </trans-unit>
        <trans-unit id="08f070a244c3d5ae1d6e726845ba3cf27ed3a4ee" translate="yes" xml:space="preserve">
          <source>Java BigInteger</source>
          <target state="translated">Java BigInteger</target>
        </trans-unit>
        <trans-unit id="8c689b2df07d5ac7a956c5d5f96beb6beed619e6" translate="yes" xml:space="preserve">
          <source>Java Class</source>
          <target state="translated">Java类</target>
        </trans-unit>
        <trans-unit id="ecdb578d70bdad641779bb3cf2409b8a930d4cc0" translate="yes" xml:space="preserve">
          <source>Java Objects</source>
          <target state="translated">Java对象</target>
        </trans-unit>
        <trans-unit id="4e2d7efd6e5d57f9e2fd04c772bf368801395eaf" translate="yes" xml:space="preserve">
          <source>Java Test</source>
          <target state="translated">Java测试</target>
        </trans-unit>
        <trans-unit id="c016599191077ac21a20ca4a9937da89712a611b" translate="yes" xml:space="preserve">
          <source>Java UDFs can be invoked multiple ways. The simplest UDF can just extend EvalFunc, which requires only the exec function to be implemented (see &lt;a href=&quot;#eval-functions-write&quot;&gt; How to Write a Simple Eval Function&lt;/a&gt;). Every eval UDF must implement this. Additionally, if a function is algebraic, it can implement Algebraic interface to significantly improve query performance in the cases when combiner can be used (see &lt;a href=&quot;#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;). Finally, a function that can process tuples in an incremental fashion can also implement the Accumulator interface to improve query memory consumption (see &lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;).</source>
          <target state="translated">Java UDF可以通过多种方式调用。最简单的UDF可以仅扩展EvalFunc，这仅需要实现exec函数（请参见&lt;a href=&quot;#eval-functions-write&quot;&gt;如何编写简单的Eval函数&lt;/a&gt;）。每个评估UDF必须实现这一点。另外，如果一个函数是代数的，那么在可以使用&lt;a href=&quot;#algebraic-interface&quot;&gt;合并&lt;/a&gt;器的情况下，它可以实现代数接口以显着提高查询性能（请参见代数接口）。最后，可以以增量方式处理元组的函数还可以实现Accumulator接口，以改善查询内存消耗（请参见&lt;a href=&quot;#accumulator-interface&quot;&gt;Accumulator Interface&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d5889044826a763834c9c012a37f5c86407ecc85" translate="yes" xml:space="preserve">
          <source>Job XML</source>
          <target state="translated">工作XML</target>
        </trans-unit>
        <trans-unit id="6cc61673b0dee9980ed3e68bb162982c295dc41b" translate="yes" xml:space="preserve">
          <source>JobStats</source>
          <target state="translated">JobStats</target>
        </trans-unit>
        <trans-unit id="5753a498f025464d72e088a9d5d6e872592d5f91" translate="yes" xml:space="preserve">
          <source>John</source>
          <target state="translated">John</target>
        </trans-unit>
        <trans-unit id="13b0d0b8d9cc13668684c1e4def8925fe90d5929" translate="yes" xml:space="preserve">
          <source>JsonLoader( ['schema'] )</source>
          <target state="translated">JsonLoader((原理图 ))</target>
        </trans-unit>
        <trans-unit id="8ecc1bbc9be4c62ea582a64bff9ee07d59799f5d" translate="yes" xml:space="preserve">
          <source>JsonLoader, JsonStorage</source>
          <target state="translated">JsonLoader,JsonStorage</target>
        </trans-unit>
        <trans-unit id="606d2a58b14210dd67ff5015b481adddb0d11fcd" translate="yes" xml:space="preserve">
          <source>JsonStorage( )</source>
          <target state="translated">JsonStorage()</target>
        </trans-unit>
        <trans-unit id="4f52e476a57f572278206a16e11c4378156dad2a" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt; and &lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming&lt;/a&gt;, Java UDF has a getLoadCaster() method that returns &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; to convert byte arrays to specific types. A UDf implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported. Default implementation returns null and Pig will determine if all parameters passed to the UDF have identical loadcaster and use it when true.</source>
          <target state="translated">就像&lt;a href=&quot;#load-functions&quot;&gt;Load Function&lt;/a&gt;和&lt;a href=&quot;basic#pig-streaming-input-output&quot;&gt;Streaming一样&lt;/a&gt;，Java UDF具有getLoadCaster（）方法，该方法返回&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt;来将字节数组转换为特定类型。如果需要支持从DataByteArray字段强制转换（隐式或显式）到其他类型，则UDf实现应实现此目的。默认实现返回null，Pig将确定传递给UDF的所有参数是否具有相同的loadcaster，并在为true时使用它。</target>
        </trans-unit>
        <trans-unit id="b07a29909bdb4a7c9a4c7d68a06e09221fc27e7c" translate="yes" xml:space="preserve">
          <source>Just like MapReduce, if user specify &quot;parallel&quot; in their Pig statement, or user define default_parallel in Tez mode, Pig will honor it (the only exception is if user specify a parallel which is apparently too low, Pig will override it)</source>
          <target state="translated">就像MapReduce一样,如果用户在Pig语句中指定了 &quot;parallel&quot;,或者用户在Tez模式下定义了default_parallel,Pig就会尊重它(唯一的例外是,如果用户指定的parallel明显过低,Pig就会覆盖它)。</target>
        </trans-unit>
        <trans-unit id="362ce6c69aec6aa228025cdea51fbad41241c2ee" translate="yes" xml:space="preserve">
          <source>Kerberos is a authentication system that uses tickets with a limited validity time.</source>
          <target state="translated">Kerberos是一种使用票据的认证系统,有一定的有效时间。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="134d1eb6aa3d758c6d2a1058ae3736bf8dd9041a" translate="yes" xml:space="preserve">
          <source>Key (see table). Case sensitive.</source>
          <target state="translated">钥匙(见表)。对大小写敏感。</target>
        </trans-unit>
        <trans-unit id="6cca404086c0c970a335a2fb82ffafe8356b46e5" translate="yes" xml:space="preserve">
          <source>Key value pairs are separated by the pound sign #.</source>
          <target state="translated">键值对用磅号#分隔。</target>
        </trans-unit>
        <trans-unit id="8098eb09dd0aab077b1f27f175c7ab7b69b5f496" translate="yes" xml:space="preserve">
          <source>Key values within a relation must be unique.</source>
          <target state="translated">一个关系中的键值必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="20f56842c9025d12cf677dcfcfc8d42101d62d87" translate="yes" xml:space="preserve">
          <source>Keyword.</source>
          <target state="translated">Keyword.</target>
        </trans-unit>
        <trans-unit id="59a29873cf3f108383cd6005d3b1061f15d203a8" translate="yes" xml:space="preserve">
          <source>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</source>
          <target state="translated">关键字。如果你想让所有的元组进入一个单一的组,请使用ALL;例如,在整个关系中进行聚合时。</target>
        </trans-unit>
        <trans-unit id="a7c4c244651ed2eef71562ff0f3f4ddcc23cb537" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to group the relation by field, tuple or expression.</source>
          <target state="translated">关键字。使用此子句按字段、元组或表达式对关系进行分组。</target>
        </trans-unit>
        <trans-unit id="319289cdafee96fb1df0ad9cc8cefb1bd579fb6b" translate="yes" xml:space="preserve">
          <source>Keyword. Use this clause to name the store function.</source>
          <target state="translated">关键字。用这个子句来命名存储函数。</target>
        </trans-unit>
        <trans-unit id="67bd5860f834413aaa7d43179cf49527a0e0a2a6" translate="yes" xml:space="preserve">
          <source>Keywords LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, and DUMP are case insensitive. They can also be written as load, using, as, group, by, etc.</source>
          <target state="translated">关键词LOAD,USING,AS,GROUP,BY,FOREACH,GENERATE,和DUMP是不区分大小写的。它们也可以写成load,using,as,group,by等。</target>
        </trans-unit>
        <trans-unit id="0edfbf0b2bd967f0c42ea28a41230fdd455d94f6" translate="yes" xml:space="preserve">
          <source>Kills a job.</source>
          <target state="translated">杀了一个工作。</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">已知问题</target>
        </trans-unit>
        <trans-unit id="081687e57ce32b0d5310545712b5004fdc61e427" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF</source>
          <target state="translated">LAST_INDEX_OF</target>
        </trans-unit>
        <trans-unit id="df47fe57bbca631a9709a10608e1b138590b99bd" translate="yes" xml:space="preserve">
          <source>LAST_INDEX_OF(string, 'character')</source>
          <target state="translated">LAST_INDEX_OF(string,'character')</target>
        </trans-unit>
        <trans-unit id="52e4213745bcac792482d968e621c5b7a8d439c9" translate="yes" xml:space="preserve">
          <source>LCFIRST</source>
          <target state="translated">LCFIRST</target>
        </trans-unit>
        <trans-unit id="97e019a4f6ed7512191b214c6cc6b45d3f156619" translate="yes" xml:space="preserve">
          <source>LCFIRST(expression)</source>
          <target state="translated">LCFIRST(expression)</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="97eb8c80f7fd9d9f6120c3bffd79e5e23e575196" translate="yes" xml:space="preserve">
          <source>LOAD</source>
          <target state="translated">LOAD</target>
        </trans-unit>
        <trans-unit id="4774d9fc38721cde600e4accf82d0e696ef36f65" translate="yes" xml:space="preserve">
          <source>LOAD '/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00//&lt;strong&gt;part &lt;/strong&gt;'</source>
          <target state="translated">LOAD'/mydata/20110423{00,01,02,03,04,05,06,07,08,09,{10..23}}00// &lt;strong&gt;部分&lt;/strong&gt; '</target>
        </trans-unit>
        <trans-unit id="9a4fc268593a3d77b3f981e8ec7b7ac700de71ad" translate="yes" xml:space="preserve">
          <source>LOAD 'data' [USING function] [AS schema];</source>
          <target state="translated">LOAD 'data' [USING function][AS schema]。</target>
        </trans-unit>
        <trans-unit id="285ba2da17d87dd834eefed1cada61171d7d941f" translate="yes" xml:space="preserve">
          <source>LOAD ... USING ... AS</source>
          <target state="translated">加载...使用...作为</target>
        </trans-unit>
        <trans-unit id="6a8f5f55cccc7758440851683be6f04c67cd6f96" translate="yes" xml:space="preserve">
          <source>LOAD, AS - Pig keywords</source>
          <target state="translated">LOAD,AS-Pig关键字</target>
        </trans-unit>
        <trans-unit id="94b16081400651bfe270528a0e3ee7024a5f9ca3" translate="yes" xml:space="preserve">
          <source>LOG</source>
          <target state="translated">LOG</target>
        </trans-unit>
        <trans-unit id="fd8045b04b52cf7e9e6124cd894331256d12dd1a" translate="yes" xml:space="preserve">
          <source>LOG(expression)</source>
          <target state="translated">LOG(expression)</target>
        </trans-unit>
        <trans-unit id="bc31df31706dbabb2fd79fd247573138a9a82419" translate="yes" xml:space="preserve">
          <source>LOG10</source>
          <target state="translated">LOG10</target>
        </trans-unit>
        <trans-unit id="bf7398056782a2eb6fd651f94e9a8d6d8204c678" translate="yes" xml:space="preserve">
          <source>LOG10(expression)</source>
          <target state="translated">LOG10(expression)</target>
        </trans-unit>
        <trans-unit id="e2b5c793d8e006e471a5275e68adfb98fe059dc4" translate="yes" xml:space="preserve">
          <source>LOWER</source>
          <target state="translated">LOWER</target>
        </trans-unit>
        <trans-unit id="92aead129812450be477e67e7eb989a4e9f71ce9" translate="yes" xml:space="preserve">
          <source>LOWER(expression)</source>
          <target state="translated">LOWER(expression)</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="27e73e8192dd9ba4f47ae3488ff498e67ffd4019" translate="yes" xml:space="preserve">
          <source>LTRIM(expression)</source>
          <target state="translated">LTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="fc5aafa84439164f5915b1b47617fd862bbd82b2" translate="yes" xml:space="preserve">
          <source>Left outer join.</source>
          <target state="translated">左外侧连接。</target>
        </trans-unit>
        <trans-unit id="13b628b4ab8b2509575a1cd6f8cb5fda2b247abd" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement the {CollectableLoader} interface as well as {OrderedLoadFunc} interface.</source>
          <target state="translated">最左边的加载器必须实现{CollectableLoader}接口以及{OrderedLoadFunc}接口。</target>
        </trans-unit>
        <trans-unit id="73cd7b56ef42ec03731837023a47cd87b79de49f" translate="yes" xml:space="preserve">
          <source>Left-most loader must implement {CollectableLoader} interface as well as {OrderedLoadFunc}.</source>
          <target state="translated">最左边的加载器必须实现{CollectableLoader}接口以及{OrderedLoadFunc}。</target>
        </trans-unit>
        <trans-unit id="ca2f7f65c0903edf089f4879169677e242e0ac7f" translate="yes" xml:space="preserve">
          <source>Let's assume that we have UDF Swap that, given a tuple with two fields, swaps their order. Let's assume that the UDF does not specify a schema and look at the scripts below:</source>
          <target state="translated">我们假设我们有UDF Swap,给定一个有两个字段的元组,交换它们的顺序。我们假设UDF没有指定模式,看看下面的脚本。</target>
        </trans-unit>
        <trans-unit id="32d45a02984af444cda547a94ac518a5c5a58bc4" translate="yes" xml:space="preserve">
          <source>Let's now look at the implementation of the UPPER UDF.</source>
          <target state="translated">现在我们来看看UPPER UDF的实现。</target>
        </trans-unit>
        <trans-unit id="fe6299c19bf8df974b9bebf8fccacccb0c36ebbe" translate="yes" xml:space="preserve">
          <source>Let's now see how this function can be used in a Pig script:</source>
          <target state="translated">现在让我们看看如何在Pig脚本中使用这个函数。</target>
        </trans-unit>
        <trans-unit id="ea4e0d6736c7d827cc4e7a66876464026006c55b" translate="yes" xml:space="preserve">
          <source>Let's revisit the UPPER function from our first example. As it is written now, it would only work if the data passed to it is of type chararray. To make it work with data whose type is not explicitly set, a function table with a single entry needs to be added:</source>
          <target state="translated">让我们再来看看第一个例子中的UPPER函数。按照现在的写法,只有当传递给它的数据类型为chararray时,它才会工作。为了使它能够处理没有明确设置类型的数据,需要添加一个带有单个条目的函数表。</target>
        </trans-unit>
        <trans-unit id="475a9652b88fed65852bd4b23c1359282ee6e175" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache Software License version 2.0.</source>
          <target state="translated">根据Apache Software License 2.0版本授权。</target>
        </trans-unit>
        <trans-unit id="4ae3881b2b0fb732bb6de9dde72017285f72800a" translate="yes" xml:space="preserve">
          <source>Like any other expression, null constants can be implicitly or explicitly cast.</source>
          <target state="translated">像其他任何表达式一样,空常数可以隐式或显式地投掷。</target>
        </trans-unit>
        <trans-unit id="854814e315400972c4441dad1114f75bef4e9cc4" translate="yes" xml:space="preserve">
          <source>Likewise, TrevniStorage is very closely related to AvroStorage, and shares the same options as AvroStorage. See &lt;a href=&quot;#AvroStorage&quot;&gt;AvroStorage&lt;/a&gt; for a detailed description of the arguments for TrevniStorage.</source>
          <target state="translated">同样，TrevniStorage与AvroStorage密切相关，并且具有与AvroStorage相同的选项。有关&lt;a href=&quot;#AvroStorage&quot;&gt;TrevniStorage&lt;/a&gt;参数的详细说明，请参见AvroStorage。</target>
        </trans-unit>
        <trans-unit id="b87f80550d82a9e0365779f8be23adc0ee585a43" translate="yes" xml:space="preserve">
          <source>LimitOptimizer</source>
          <target state="translated">LimitOptimizer</target>
        </trans-unit>
        <trans-unit id="6195b6b19ca290cb1f0c777b8f337e23861be917" translate="yes" xml:space="preserve">
          <source>Limited support is provided for Jython, Python, JavaScript, Ruby and Groovy functions. These functions are new, still evolving, additions to the system. Currently only the basic interface is supported; load/store functions are not supported. Furthermore, JavaScript, Ruby and Groovy are provided as experimental features because they did not go through the same amount of testing as Java or Jython. At runtime note that Pig will automatically detect the usage of a scripting UDF in the Pig script and will automatically ship the corresponding scripting jar, either Jython, Rhino, JRuby or Groovy-all, to the backend. Python does not require any runtime engine since it invoke python command line and stream data in and out of it.</source>
          <target state="translated">对Jython、Python、JavaScript、Ruby和Groovy函数的支持有限。这些函数是系统中新增加的,还在不断发展中。目前只支持基本接口,不支持加载/存储功能。此外,JavaScript、Ruby和Groovy是作为实验性功能提供的,因为它们没有像Java或Jython那样经过大量的测试。在运行时注意,Pig会自动检测Pig脚本中脚本UDF的使用情况,并会自动向后端运送相应的脚本jar,无论是Jython、Rhino、JRuby还是Groovy-all。Python不需要任何运行时引擎,因为它调用python命令行,数据流进出。</target>
        </trans-unit>
        <trans-unit id="7515906f2285af7d60e86a7d43455b7a249592bf" translate="yes" xml:space="preserve">
          <source>Limits the number of output tuples.</source>
          <target state="translated">限制输出元组的数量。</target>
        </trans-unit>
        <trans-unit id="956e1330b61723ff186fcbcfd265adba91e6af54" translate="yes" xml:space="preserve">
          <source>Line 1 indicates that the function is part of the myudfs package. The UDF class extends the EvalFunc class which is the base class for all eval functions. It is parameterized with the return type of the UDF which is a Java String in this case. We will look into the EvalFunc class in more detail later, but for now all we need to do is to implement the exec function. This function is invoked on every input tuple. The input into the function is a tuple with input parameters in the order they are passed to the function in the Pig script. In our example, it will contain a single string field corresponding to the student name.</source>
          <target state="translated">第1行表示该函数是myudfs包的一部分。UDF类是EvalFunc类的扩展,EvalFunc是所有eval函数的基类,它以UDF的返回类型为参数,在本例中是一个Java String。它以UDF的返回类型为参数,在本例中是一个Java String。我们将在后面更详细地研究EvalFunc类,但现在我们需要做的是实现exec函数。这个函数会在每个输入元组上被调用。该函数的输入是一个元组,其输入参数按照Pig脚本中传递给函数的顺序排列。在我们的例子中,它将包含一个与学生姓名相对应的单一字符串字段。</target>
        </trans-unit>
        <trans-unit id="5caa6119e5a5784410641134836063fbda7a2642" translate="yes" xml:space="preserve">
          <source>List Pig properties.</source>
          <target state="translated">列出Pig属性。</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="f021aa6572ced84b6338a8aa2d7c6ec393f0e8e9" translate="yes" xml:space="preserve">
          <source>Load Example</source>
          <target state="translated">加载示例</target>
        </trans-unit>
        <trans-unit id="1c6f5e374c495440813dfb8c43762f92a485801a" translate="yes" xml:space="preserve">
          <source>Load Examples</source>
          <target state="translated">加载示例</target>
        </trans-unit>
        <trans-unit id="153ed64057be54f8d2533568f5517a405ba5a31f" translate="yes" xml:space="preserve">
          <source>Load Functions</source>
          <target state="translated">加载功能</target>
        </trans-unit>
        <trans-unit id="c84877c34cdbb71bdceab39a857b49dc7dd074db" translate="yes" xml:space="preserve">
          <source>Load or store JSON data.</source>
          <target state="translated">加载或存储JSON数据。</target>
        </trans-unit>
        <trans-unit id="b8a5a6a4984d874b5d5fc5f56453ae2255a611d3" translate="yes" xml:space="preserve">
          <source>Load statements &amp;ndash; PigStorage expects data to be formatted using field delimiters, either the tab character ('\t') or other specified character.</source>
          <target state="translated">加载语句&amp;ndash; PigStorage期望使用字段定界符（制表符（'\ t'）或其他指定的字符）对数据进行格式化。</target>
        </trans-unit>
        <trans-unit id="8394a86595651bd6aa48839d4b9509225529fe8b" translate="yes" xml:space="preserve">
          <source>Load/Store Functions</source>
          <target state="translated">加载/存储功能</target>
        </trans-unit>
        <trans-unit id="1ff3612ad5b787d3be631d6699ef0010173126d2" translate="yes" xml:space="preserve">
          <source>Load/store functions determine how data goes into Pig and comes out of Pig. Pig provides a set of built-in load/store functions, described in the sections below. You can also write your own load/store functions (see &lt;a href=&quot;udf&quot;&gt;User Defined Functions&lt;/a&gt;).</source>
          <target state="translated">加载/存储功能确定数据如何进入Pig和从Pig中输出。Pig提供了一组内置的加载/存储功能，如以下各节所述。您还可以编写自己的加载/存储函数（请参阅&lt;a href=&quot;udf&quot;&gt;用户定义的函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c431ce3cc6de545c006a5dc4f55812d9901c37ac" translate="yes" xml:space="preserve">
          <source>Loader side:</source>
          <target state="translated">装载机方面。</target>
        </trans-unit>
        <trans-unit id="292c202d7f33de20bb18cb9b0cd78363326e07b9" translate="yes" xml:space="preserve">
          <source>Loader will be instructed to loader the partition with dt=='201310' and state=='CA'</source>
          <target state="translated">加载器将被指示加载dt=='201310'和state=='CA'的分区。</target>
        </trans-unit>
        <trans-unit id="1bbec1f2925e33de29cc103440eaad38ddc86d8c" translate="yes" xml:space="preserve">
          <source>Loading Data</source>
          <target state="translated">加载数据</target>
        </trans-unit>
        <trans-unit id="c2683406031d7a18de1fd67e1e11494ce9bebe57" translate="yes" xml:space="preserve">
          <source>Loads and stores data as structured text files.</source>
          <target state="translated">以结构化文本文件的形式加载和存储数据。</target>
        </trans-unit>
        <trans-unit id="c5ab9df0752359ce2a9010c5aca5c7b13218b8ac" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Avro files.</source>
          <target state="translated">加载和存储Avro文件中的数据。</target>
        </trans-unit>
        <trans-unit id="fd223bb0ff10c21f09b831e58eea8a6f58904d01" translate="yes" xml:space="preserve">
          <source>Loads and stores data from Trevni files.</source>
          <target state="translated">从Trevni文件加载和存储数据。</target>
        </trans-unit>
        <trans-unit id="80db5f3f39fbbc84dd2b14e51899dff294e39ece" translate="yes" xml:space="preserve">
          <source>Loads and stores data from an HBase table.</source>
          <target state="translated">从HBase表中加载并存储数据。</target>
        </trans-unit>
        <trans-unit id="d72f04a406a7e49e13a302e150306baf032923ec" translate="yes" xml:space="preserve">
          <source>Loads and stores data in machine-readable format.</source>
          <target state="translated">以机器可读格式加载和存储数据。</target>
        </trans-unit>
        <trans-unit id="7c132ef27274638f19bb72b1001c8a9395135f95" translate="yes" xml:space="preserve">
          <source>Loads data from the file system.</source>
          <target state="translated">从文件系统中加载数据。</target>
        </trans-unit>
        <trans-unit id="eea9cefa9b896289e9167b60ed8b404fccfd5b53" translate="yes" xml:space="preserve">
          <source>Loads from or stores data to Orc file.</source>
          <target state="translated">从Orc文件加载或存储数据到Orc文件。</target>
        </trans-unit>
        <trans-unit id="18e8e0842b1999e676731438c4dea4a56f79cd4c" translate="yes" xml:space="preserve">
          <source>Loads or stores data from an Accumulo table. The first element in a Tuple is equivalent to the &quot;row&quot; from the Accumulo Key, while the columns in that row are can be grouped in various static or wildcarded ways. Basic wildcarding functionality exists to group various columns families/qualifiers into a Map for LOADs, or serialize a Map into some group of column families or qualifiers on STOREs.</source>
          <target state="translated">从Accumulo表加载或存储数据。Tuple中的第一个元素相当于来自Accumulo Key的 &quot;行&quot;,而该行中的列可以以各种静态或通配符的方式进行分组。存在基本的通配功能,可以将各种列族/限定符分组到LOADs的Map中,或者将Map序列化到STOREs上的一些列族或限定符组中。</target>
        </trans-unit>
        <trans-unit id="740ccec530db15440e48181713136ee050ab7097" translate="yes" xml:space="preserve">
          <source>Loads unstructured data in UTF-8 format.</source>
          <target state="translated">以UTF-8格式加载非结构化数据。</target>
        </trans-unit>
        <trans-unit id="b3b24cc821e27fff117200af94d65c12872874b1" translate="yes" xml:space="preserve">
          <source>Local Mode</source>
          <target state="translated">本地模式</target>
        </trans-unit>
        <trans-unit id="ea7076530ceab2e77fb3cb520efd850a7ddef48b" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (local mode)</source>
          <target state="translated">日志文件,Excite搜索引擎(本地模式)</target>
        </trans-unit>
        <trans-unit id="863629ee92f0cce989f168afc709eb06192b10b7" translate="yes" xml:space="preserve">
          <source>Log file, Excite search engine (mapreduce)</source>
          <target state="translated">日志文件,Excite搜索引擎(mapreduce)</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="0178a9a96c884d695567e06fe46d3aa4cbf9b156" translate="yes" xml:space="preserve">
          <source>Long lived jobs</source>
          <target state="translated">长期工作</target>
        </trans-unit>
        <trans-unit id="c95e7e6f6a263bc67561c7fc8ceb0607d15d1cba" translate="yes" xml:space="preserve">
          <source>Long: long</source>
          <target state="translated">长:长</target>
        </trans-unit>
        <trans-unit id="3316c8ddabfaccc1e70bfecfd5b7747a06043e4b" translate="yes" xml:space="preserve">
          <source>Longs</source>
          <target state="translated">Longs</target>
        </trans-unit>
        <trans-unit id="7b186e235f284107df6b4dbe6060d2b6a5d9f1e5" translate="yes" xml:space="preserve">
          <source>MAX</source>
          <target state="translated">MAX</target>
        </trans-unit>
        <trans-unit id="3ada24ec29991deafbe9dbcbe2155e2e6ee05875" translate="yes" xml:space="preserve">
          <source>MAX(expression)</source>
          <target state="translated">MAX(expression)</target>
        </trans-unit>
        <trans-unit id="04e66352aa8f9c4c5f26b71bf380973ada994760" translate="yes" xml:space="preserve">
          <source>MIN</source>
          <target state="translated">MIN</target>
        </trans-unit>
        <trans-unit id="9f16fb3a367f47ced429f9a96ee8af3d40dcccdd" translate="yes" xml:space="preserve">
          <source>MIN(expression)</source>
          <target state="translated">MIN(expression)</target>
        </trans-unit>
        <trans-unit id="4a83930aeba65503717c88ca93580a0d643e3c2d" translate="yes" xml:space="preserve">
          <source>Macro expansion is not a complete replacement for function calls. Recursive expansions are not supported.</source>
          <target state="translated">宏扩展不能完全替代函数调用。不支持递归扩展。</target>
        </trans-unit>
        <trans-unit id="90103d0b5c28db7922249a3fa2ea7bfff2ba0064" translate="yes" xml:space="preserve">
          <source>Macro names are global and all macros share the same name space. While the file can contain more than one macro definition, having two macros with the same name in your execution context will result in an error.</source>
          <target state="translated">宏名称是全局的,所有的宏都共享同一个名称空间。虽然文件可以包含一个以上的宏定义,但在执行上下文中出现两个名称相同的宏会导致错误。</target>
        </trans-unit>
        <trans-unit id="a950d781ec76e0d5d8f9a49df1d80136a24daf6d" translate="yes" xml:space="preserve">
          <source>Macros are NOT alllowed inside a nested block.</source>
          <target state="translated">在嵌套块中不允许使用宏。</target>
        </trans-unit>
        <trans-unit id="e0fe92ab842bd9468af7fe40e3c0e996ece09d87" translate="yes" xml:space="preserve">
          <source>Macros are not allowed inside a &lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt; nested block.</source>
          <target state="translated">不允许在&lt;a href=&quot;basic#nested-block&quot;&gt;FOREACH&lt;/a&gt;嵌套块内使用宏。</target>
        </trans-unit>
        <trans-unit id="ec793f1eac030adf34d2e41a8195b5aa6af3faa2" translate="yes" xml:space="preserve">
          <source>Macros can only contain Pig Latin statements; Grunt shell commands are not supported. REGISTER statements and parameter definitions with %default or %declare are both valid however. Your macro file also IMPORT other macro files, so long as these imports are not recursive.</source>
          <target state="translated">宏只能包含 Pig Latin 语句,不支持 Grunt shell 命令。但是,REGISTER 语句和带 %default 或 %declare 的参数定义都是有效的。你的宏文件也可以导入其他宏文件,只要这些导入不是递归的。</target>
        </trans-unit>
        <trans-unit id="8f5d729039ce92b99bf31323c027bd3e1999e4d3" translate="yes" xml:space="preserve">
          <source>Macros cannot contain &lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt shell commands&lt;/a&gt;.</source>
          <target state="translated">宏不能包含&lt;a href=&quot;cmds#shell-cmds&quot;&gt;Grunt shell命令&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fb4798c01e02a87a25ab288415fe8315792ab65a" translate="yes" xml:space="preserve">
          <source>Macros cannot include a user-defined schema that has a name collision with an alias in the macro.</source>
          <target state="translated">宏不能包含用户定义的模式,该模式的名称与宏中的别名有冲突。</target>
        </trans-unit>
        <trans-unit id="b90c9bc525fef91c7051e223d84db955ed26d8b6" translate="yes" xml:space="preserve">
          <source>Make Your UDFs Algebraic</source>
          <target state="translated">让你的UDFs成为代数</target>
        </trans-unit>
        <trans-unit id="0c76e7b16941afa21f1bc061662c5afc67e30d7d" translate="yes" xml:space="preserve">
          <source>Make sure that for each function, you add a corresponding test class in the test part of the tree.</source>
          <target state="translated">确保为每个函数在树的测试部分添加一个相应的测试类。</target>
        </trans-unit>
        <trans-unit id="89075a765b1a0bbdfb1037d1e343f2d19beb8ffd" translate="yes" xml:space="preserve">
          <source>Make sure that your code follows Pig coding conventions described in &lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;How to Contribute to Pig&lt;/a&gt;.</source>
          <target state="translated">确保您的代码遵循&lt;a href=&quot;https://cwiki.apache.org/confluence/display/PIG/HowToContribute&quot;&gt;如何对Pig进行贡献中&lt;/a&gt;所述的Pig编码约定。</target>
        </trans-unit>
        <trans-unit id="1453bf305e9c5ecb3fb272c5a0f810f865052a67" translate="yes" xml:space="preserve">
          <source>Make sure that your function is well documented and uses the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt; style of documentation.</source>
          <target state="translated">确保对函数进行了充分的文档记录，并使用&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/tools/solaris/javadoc.html&quot;&gt;javadoc&lt;/a&gt;样式的文档记录。</target>
        </trans-unit>
        <trans-unit id="02bf56b1b68374b208d34a48eae88f93b5114cb8" translate="yes" xml:space="preserve">
          <source>Make sure the JAVA_HOME environment variable is set the root of your Java installation.</source>
          <target state="translated">确保JAVA_HOME环境变量被设置为Java安装的根。</target>
        </trans-unit>
        <trans-unit id="f0a14e7b46d7b053eeee4d905350e82494b9e784" translate="yes" xml:space="preserve">
          <source>Make sure your PATH includes bin/pig (this enables you to run the tutorials using the &quot;pig&quot; command).</source>
          <target state="translated">确保你的PATH中包含bin/pig(这可以让你使用 &quot;pig &quot;命令运行教程)。</target>
        </trans-unit>
        <trans-unit id="8f2f922bc9ecd3f2a3cdc0e7b3ae6ed62fb20721" translate="yes" xml:space="preserve">
          <source>Makes the split non-blocking and allows processing to continue. This helps reduce the amount of data that has to be stored right at the split.</source>
          <target state="translated">使拆分变得无阻塞,并允许继续处理。这有助于减少在分割时必须存储的数据量。</target>
        </trans-unit>
        <trans-unit id="209567b32f8fea5e9ef198fb3941b8730fad033c" translate="yes" xml:space="preserve">
          <source>Many PigUnit examples are available in the &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit tests&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/test/org/apache/pig/test/pigunit/TestPigTest.java&quot;&gt;PigUnit测试&lt;/a&gt;中提供了许多PigUnit示例。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="dae74f13b986a147221f41b0053b991ea203fea3" translate="yes" xml:space="preserve">
          <source>Map Schemas</source>
          <target state="translated">地图模式</target>
        </trans-unit>
        <trans-unit id="8af46e94e502b7aa7a2f1aa05b12cb0c07e01870" translate="yes" xml:space="preserve">
          <source>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</source>
          <target state="translated">地图取消引用必须通过键(field_name#key或$0#key)来完成。如果pound操作符应用于一个字节数组,则假定字节数组是一个映射。如果key不存在,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="172c8b9363030fc7be69a2798cd806007e34c86e" translate="yes" xml:space="preserve">
          <source>Map&amp;lt;Object, Object&amp;gt;</source>
          <target state="translated">Map &amp;lt;对象，对象&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5a376ab0b0389e27d40fa426227bc396c3d2e452" translate="yes" xml:space="preserve">
          <source>Map: java.util.Map</source>
          <target state="translated">地图:java.util.Map</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="1a50f5954df4dfe8722ed6d174a9520e089c8ce6" translate="yes" xml:space="preserve">
          <source>Maps are enclosed in straight brackets [ ].</source>
          <target state="translated">地图用直括号[]括起来。</target>
        </trans-unit>
        <trans-unit id="1756bec08ab2e5a4f6f3ea1577c5665ca0e8a418" translate="yes" xml:space="preserve">
          <source>Math Functions</source>
          <target state="translated">数学函数</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">内存管理</target>
        </trans-unit>
        <trans-unit id="ffc4d0fd84372762976635002c427e810e8329a6" translate="yes" xml:space="preserve">
          <source>Merge Joins</source>
          <target state="translated">合并加入</target>
        </trans-unit>
        <trans-unit id="627dc8ff0cef660b000fb836bad32ded77d9db38" translate="yes" xml:space="preserve">
          <source>Merge filter conditions after PushUpFilter rule to decrease the number of filter statements.</source>
          <target state="translated">在PushUpFilter规则后合并过滤条件,减少过滤语句的数量。</target>
        </trans-unit>
        <trans-unit id="51c7b431837f24885f18db611764cb39830ff71e" translate="yes" xml:space="preserve">
          <source>Merge-Sparse Joins</source>
          <target state="translated">合并-分离式加入</target>
        </trans-unit>
        <trans-unit id="8fea2fed8c16c2288bb31ada275a77e267a6ab5c" translate="yes" xml:space="preserve">
          <source>Merge-Sparse join is a specialization of merge join. Merge-sparse join is intended for use when one of the tables is very sparse, meaning you expect only a small number of records to be matched during the join. In tests this join performed well for cases where less than 1% of the data was matched in the join.</source>
          <target state="translated">Merge-Sparse join是merge join的一种特殊化。Merge-sparse join的目的是为了在其中一个表非常稀疏的情况下使用,这意味着你希望在连接过程中只有少量记录被匹配。在测试中,这种连接在连接中匹配的数据少于1%的情况下表现良好。</target>
        </trans-unit>
        <trans-unit id="a4bdcc67e1fd583bc328f53c3b10ec1e75cec47e" translate="yes" xml:space="preserve">
          <source>Merge-sparse join only works for inner joins and is not currently implemented for outer joins.</source>
          <target state="translated">Merge-sparse join只适用于内联接,目前还没有实现外联接。</target>
        </trans-unit>
        <trans-unit id="c8fae7f7316c44f46454df38407830d960deca78" translate="yes" xml:space="preserve">
          <source>MergeFilter</source>
          <target state="translated">MergeFilter</target>
        </trans-unit>
        <trans-unit id="23a02331f579c7154e40a84a1946289d36647520" translate="yes" xml:space="preserve">
          <source>MergeForEach</source>
          <target state="translated">MergeForEach</target>
        </trans-unit>
        <trans-unit id="6b121c3e89581e5ceab18466104db8aab4915066" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween</source>
          <target state="translated">MilliSecondsBetween</target>
        </trans-unit>
        <trans-unit id="e71ec4d9c2fb04eac5ce8aa7ddfc94b4e537dc73" translate="yes" xml:space="preserve">
          <source>MilliSecondsBetween(datetime1, datetime2)</source>
          <target state="translated">MilliSecondsBetween(datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="6295a9ae493dccb2f773f064edfa765b839ab428" translate="yes" xml:space="preserve">
          <source>MiniCluster generates one in build/classes.</source>
          <target state="translated">MiniCluster在build/classes中生成一个。</target>
        </trans-unit>
        <trans-unit id="13b68c92e094101ca904236df27e6d286dfc4604" translate="yes" xml:space="preserve">
          <source>MinutesBetween</source>
          <target state="translated">MinutesBetween</target>
        </trans-unit>
        <trans-unit id="121265c9da1c27a9e91b296b9a032f9dc043e2cf" translate="yes" xml:space="preserve">
          <source>MinutesBetween(datetime1, datetime2)</source>
          <target state="translated">MinutesBetween(datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="5af6b4c2a5b65cc8ab62dc972a6b79fd159c1004" translate="yes" xml:space="preserve">
          <source>MissingFormatArgumentException: Format specifier '%-8s'</source>
          <target state="translated">MissingFormatArgumentException。格式指定符'%-8s'</target>
        </trans-unit>
        <trans-unit id="99a3402325144d291bec7ddf15b2b92ddc5bc907" translate="yes" xml:space="preserve">
          <source>Mocking</source>
          <target state="translated">Mocking</target>
        </trans-unit>
        <trans-unit id="98c1556eb14f903ff0cc6da7fce11300097e4f71" translate="yes" xml:space="preserve">
          <source>Monitoring Long-Running UDFs</source>
          <target state="translated">监测长期运行的UDF</target>
        </trans-unit>
        <trans-unit id="f4e4587a8e5bc89978b95fd14712b5c637d334c7" translate="yes" xml:space="preserve">
          <source>MonthsBetween</source>
          <target state="translated">MonthsBetween</target>
        </trans-unit>
        <trans-unit id="c2497de4c3a7f46f52e471bf016580c8b05abe79" translate="yes" xml:space="preserve">
          <source>MonthsBetween(datetime1, datetime2)</source>
          <target state="translated">MonthsBetween(datetime1,datetime2)</target>
        </trans-unit>
        <trans-unit id="5d01423227f4b2cd4ded59e2cdbfb0057686b879" translate="yes" xml:space="preserve">
          <source>Most Orc data type has one to one mapping to Pig data type. Several exceptions are:</source>
          <target state="translated">大多数兽人数据类型与猪数据类型有一对一的映射。有几个例外:</target>
        </trans-unit>
        <trans-unit id="cdfa5243b3d54966023e586cfec06cfd9d7a42dd" translate="yes" xml:space="preserve">
          <source>Most existing Pig scripts will produce the same result with or without the multi-query execution. There are cases though where this is not true. Path names and schemes are discussed here.</source>
          <target state="translated">大多数现有的 Pig 脚本在执行或不执行多查询的情况下都会产生相同的结果。但也有一些情况不是这样的。这里讨论了路径名称和方案。</target>
        </trans-unit>
        <trans-unit id="b10b3ed627fb4772162ce992b3ea0544246f7c8b" translate="yes" xml:space="preserve">
          <source>Most of the time, single-tuple processing within a UDF is very short and does not require a UDF to heartbeat. The same is true for aggregate functions that operate on large bags because bag iteration code takes care of it. However, if you have a function that performs a complex computation that can take an order of minutes to execute, you should add a progress indicator to your code. This is very easy to accomplish. The EvalFunc class provides a progress function that you need to call in your exec method.</source>
          <target state="translated">大多数时候,UDF内的单元处理时间非常短,不需要UDF来心跳。对于在大包上操作的聚合函数也是如此,因为包的迭代代码会照顾到它。然而,如果你有一个执行复杂计算的函数,执行起来可能需要几分钟的时间,你应该在你的代码中添加一个进度指示器。这很容易实现。EvalFunc类提供了一个进度函数,你需要在你的exec方法中调用它。</target>
        </trans-unit>
        <trans-unit id="e6ca4666a38ad0441b66ffd38051824a3e1f9b9e" translate="yes" xml:space="preserve">
          <source>Most times, it is not necessary, nor desired for performance reasons, to fetch all columns.</source>
          <target state="translated">大多数情况下,出于性能的考虑,没有必要也不希望获取所有的列。</target>
        </trans-unit>
        <trans-unit id="12fdb217bf25b1d89a39ced7476e27e33bf049f6" translate="yes" xml:space="preserve">
          <source>Move to the Pig tutorial directory (.../pig-0.17.0/tutorial).</source>
          <target state="translated">移动到Pig教程目录(.../pig-0.17.0/tutorial)。</target>
        </trans-unit>
        <trans-unit id="31c02a320c089f6597a14f81e99bbbb176a8d14f" translate="yes" xml:space="preserve">
          <source>Move to the pigtmp directory.</source>
          <target state="translated">移动到pigtmp目录。</target>
        </trans-unit>
        <trans-unit id="6ac8dd3fbae422b42dfb2b029fcf9ffa579e90ba" translate="yes" xml:space="preserve">
          <source>Multi-Query Execution</source>
          <target state="translated">多查询执行</target>
        </trans-unit>
        <trans-unit id="01b85aabcb3b39447e1aab1a2ca45fed5b213163" translate="yes" xml:space="preserve">
          <source>Multi-query execution introduces some changes:</source>
          <target state="translated">多查询执行引入了一些变化。</target>
        </trans-unit>
        <trans-unit id="be0c81ed15124e2c9f58dac0249e297166b9f212" translate="yes" xml:space="preserve">
          <source>Multi-query execution is turned on by default. To turn it off and revert to Pig's &quot;execute-on-dump/store&quot; behavior, use the &quot;-M&quot; or &quot;-no_multiquery&quot; options.</source>
          <target state="translated">多查询执行默认是打开的。要关闭它并恢复到 Pig 的 &quot;执行-转储/存储 &quot;行为,使用&quot;-M &quot;或&quot;-no_multiquery &quot;选项。</target>
        </trans-unit>
        <trans-unit id="df511d0b9ccb7e1d2a7d7c5c3de6213920d670e9" translate="yes" xml:space="preserve">
          <source>Multiple fields are enclosed in parentheses and separated by commas.</source>
          <target state="translated">多个字段用括号括起来,并用逗号隔开。</target>
        </trans-unit>
        <trans-unit id="49c92016401e9e368896026aade96455b23a26cb" translate="yes" xml:space="preserve">
          <source>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</source>
          <target state="translated">可以指定多个文件。如果同一个参数在文件中多次出现,将使用最后一个值,并产生一个警告。如果一个参数在多个文件中出现,将使用最后一个文件的值,并产生一个警告。</target>
        </trans-unit>
        <trans-unit id="78de899b1c722999a754115b391c3f6d8afcc630" translate="yes" xml:space="preserve">
          <source>Multiple items:</source>
          <target state="translated">多个项目。</target>
        </trans-unit>
        <trans-unit id="4fd56e73c50d1cf9df45651cb8969f782fc4bd9d" translate="yes" xml:space="preserve">
          <source>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</source>
          <target state="translated">可以指定多个参数。如果多次指定同一个参数,将使用最后一个值,并产生一个警告。</target>
        </trans-unit>
        <trans-unit id="a7224113267e40a9f1083035389fd70d294aaf25" translate="yes" xml:space="preserve">
          <source>Multiple register commands can be used in the same script. If the same fully-qualified function is present in multiple jars, the first occurrence will be used consistently with Java semantics.</source>
          <target state="translated">在同一个脚本中可以使用多个寄存器命令。如果同一个完全限定的函数出现在多个罐子中,第一次出现的函数将与Java语义一致。</target>
        </trans-unit>
        <trans-unit id="3e91b337a11e8be469e11fd079a265758b7d0f67" translate="yes" xml:space="preserve">
          <source>Must be chararray data type. Must be a unique value.</source>
          <target state="translated">必须是chararray数据类型。必须是一个唯一的值。</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="dbda54bf8f5b0c2cab6b61e46d69af778895241e" translate="yes" xml:space="preserve">
          <source>NATIVE</source>
          <target state="translated">NATIVE</target>
        </trans-unit>
        <trans-unit id="8e7f35442a0cbdf6e52522bf252417e0672f3cf5" translate="yes" xml:space="preserve">
          <source>NGramGenerator</source>
          <target state="translated">NGramGenerator</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="434fe5f55d2da77a8c38d9d086d184382c0431af" translate="yes" xml:space="preserve">
          <source>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword (see &lt;a href=&quot;#identifiers&quot;&gt;Identifiers&lt;/a&gt; for valid name examples).</source>
          <target state="translated">名称是由您使用模式分配的（或者，对于GROUP GROUP运算符和某些函数，是由系统分配的）。您可以使用不是Pig关键字的任何名称（有关有效的名称示例，请参阅&lt;a href=&quot;#identifiers&quot;&gt;标识符&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a1cd1435493b07624397f0caecc9c127f1237605" translate="yes" xml:space="preserve">
          <source>Nested FOREACH...GENERATE block used with a inner bag. Use this syntax:</source>
          <target state="translated">嵌套的FOREACH...GENERATE块与内袋一起使用。使用这种语法。</target>
        </trans-unit>
        <trans-unit id="856b986d3b3538c9f63c14a8bfa923da457a6cbf" translate="yes" xml:space="preserve">
          <source>No gap in the ranking values.</source>
          <target state="translated">排名值没有差距。</target>
        </trans-unit>
        <trans-unit id="8afea8785f2d471644a7e2ce83ccf7eaafc476b5" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the LOAD and COGROUP statements.</source>
          <target state="translated">LOAD和COGROUP语句之间不能进行其他操作。</target>
        </trans-unit>
        <trans-unit id="6cacbef0c08a2a634815e58b66c00fed7c2c41d6" translate="yes" xml:space="preserve">
          <source>No other operations can be done between the load and join statements.</source>
          <target state="translated">在加载和连接语句之间不能进行其他操作。</target>
        </trans-unit>
        <trans-unit id="37c34486a47e980837dfed80ad60c633165578bc" translate="yes" xml:space="preserve">
          <source>No terms.</source>
          <target state="translated">没有条件。</target>
        </trans-unit>
        <trans-unit id="4f05f854bcf667613eb1bcf644bf89bea7c04c22" translate="yes" xml:space="preserve">
          <source>Non-empty bag: {code}{(tuple1),(tuple2),(tuple3)}{code}</source>
          <target state="translated">非空袋。{code}{(元组1),(元组2),(元组3)}{code}。</target>
        </trans-unit>
        <trans-unit id="a9028fbba3faab3bb8d6374d3d3b12e55ec4d07e" translate="yes" xml:space="preserve">
          <source>Non-empty map: [key1#value1,key2#value2]</source>
          <target state="translated">非空地图。[key1#value1,key2#value2]</target>
        </trans-unit>
        <trans-unit id="454c82816301c007849136a6a6afd39e636c7a7d" translate="yes" xml:space="preserve">
          <source>Non-empty tuple: (item1,item2,item3)</source>
          <target state="translated">非空元组。(项目1、项目2、项目3)</target>
        </trans-unit>
        <trans-unit id="8bb35935b1c067f8f5b9269c75f07f122dc91e0b" translate="yes" xml:space="preserve">
          <source>NonURLDetector</source>
          <target state="translated">NonURLDetector</target>
        </trans-unit>
        <trans-unit id="f3a561a666d179ca85f5eca5281a4cc29dc561d4" translate="yes" xml:space="preserve">
          <source>Not applicable.</source>
          <target state="translated">不适用。</target>
        </trans-unit>
        <trans-unit id="3097e34dbf20e18d2f69780a551e61726fd84f2e" translate="yes" xml:space="preserve">
          <source>Not only inside outputSchema at compile time, input schema is also accessible in exec at runtime. For example:</source>
          <target state="translated">不仅在编译时的outputSchema里面,在运行时的exec中也可以访问输入模式。例如</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="fe6878280c596a2dd5322865b0537fe6209c86bf" translate="yes" xml:space="preserve">
          <source>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &amp;lt;= i &amp;lt; s A[i] == B[i])</source>
          <target state="translated">注1：布尔值（如果元组A具有相同的大小s，并且对于所有0 &amp;lt;= i &amp;lt;s A [i] == B [i]，则元组A等于元组B））</target>
        </trans-unit>
        <trans-unit id="e7ce1a756a8dac8acf02cf7ce21512a25d378b81" translate="yes" xml:space="preserve">
          <source>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 == k2 and v1 == v2)</source>
          <target state="translated">注2:布尔值(如果A和B的条目数相同,且A中每一个键k1的值为v1,B中就有一个键k2的值为v2,这样k1==k2,v1==v2,则地图A等于地图B)</target>
        </trans-unit>
        <trans-unit id="7b6c6d89bc2c99329a0bff371ae22ebd24929b95" translate="yes" xml:space="preserve">
          <source>Note that a DUMP or STORE statement is required to generate output.</source>
          <target state="translated">请注意,生成输出需要DUMP或STORE语句。</target>
        </trans-unit>
        <trans-unit id="7830de9d278f278b280af353b2b1e821813572b3" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Java UDF may be embedded in Python, JavaScript, Groovy, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">请注意，宿主语言和UDF的语言（作为嵌入式Pig的一部分包含在内）是完全正交的。例如，注册Java UDF的Pig Latin语句可以嵌入在Python，JavaScript，Groovy或Java中。唯一的例外规则是&amp;ldquo;组合拳&amp;rdquo;的脚本-这里的语言必须匹配（参见&lt;a href=&quot;udf#jython-advanced&quot;&gt;高级主题为Python&lt;/a&gt;，&lt;a href=&quot;udf#js-advanced&quot;&gt;JavaScript的高级主题&lt;/a&gt;和&lt;a href=&quot;udf#groovy-advanced&quot;&gt;高级主题对Groovy&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ced2283529be7070b1816e7bc88ea7c4ff8a20e9" translate="yes" xml:space="preserve">
          <source>Note that host languages and the languages of UDFs (included as part of the embedded Pig) are completely orthogonal. For example, a Pig Latin statement that registers a Python UDF may be embedded in Python, JavaScript, or Java. The exception to this rule is &quot;combined&quot; scripts &amp;ndash; here the languages must match (see the &lt;a href=&quot;udf#jython-advanced&quot;&gt;Advanced Topics for Python&lt;/a&gt;, &lt;a href=&quot;udf#js-advanced&quot;&gt;Advanced Topics for JavaScript&lt;/a&gt; and &lt;a href=&quot;udf#groovy-advanced&quot;&gt;Advanced Topics for Groovy&lt;/a&gt;).</source>
          <target state="translated">请注意，宿主语言和UDF的语言（作为嵌入式Pig的一部分包含在内）是完全正交的。例如，注册Python UDF的Pig Latin语句可以嵌入Python，JavaScript或Java中。唯一的例外规则是&amp;ldquo;组合拳&amp;rdquo;的脚本-这里的语言必须匹配（参见&lt;a href=&quot;udf#jython-advanced&quot;&gt;高级主题为Python&lt;/a&gt;，&lt;a href=&quot;udf#js-advanced&quot;&gt;JavaScript的高级主题&lt;/a&gt;和&lt;a href=&quot;udf#groovy-advanced&quot;&gt;高级主题对Groovy&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a92b6e8e114c8750692dc7d3c9a3cb2162bb5174" translate="yes" xml:space="preserve">
          <source>Note that only real programs can be run form the sh command. Commands such as cd are not programs but part of the shell environment and as such cannot be executed unless the user invokes the shell explicitly, like &quot;bash cd&quot;.</source>
          <target state="translated">请注意,只有真正的程序才能以sh命令的形式运行。像cd这样的命令不是程序,而是shell环境的一部分,因此不能被执行,除非用户明确地调用shell,比如 &quot;bash cd&quot;。</target>
        </trans-unit>
        <trans-unit id="c3b397cb98d2ff8d3aff186a2a49ff9b5ce0dce4" translate="yes" xml:space="preserve">
          <source>Note that production scripts SHOULD NOT use DUMP as it will disable multi-query optimizations and is likely to slow down execution (see &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;).</source>
          <target state="translated">请注意，生产脚本不应使用DUMP，因为它将禁用多查询优化，并且可能会减慢执行速度（请参阅&lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="220abe9e473e98cfec1e0a00df725cde1dc89b0a" translate="yes" xml:space="preserve">
          <source>Note that regardless of whether or not you store the schema, you always need to specify the correct delimiter to read your data. If you store using delimiter &quot;#&quot; and then load using the default delimiter, your data will not be parsed correctly.</source>
          <target state="translated">注意,无论你是否存储模式,你总是需要指定正确的定界符来读取你的数据。如果你使用定界符 &quot;#&quot;存储,然后使用默认的定界符加载,你的数据将不会被正确解析。</target>
        </trans-unit>
        <trans-unit id="cd60f49eedb0eb2995d8bffd71cf6b05d7d5ba0e" translate="yes" xml:space="preserve">
          <source>Note that the REPLACE function is internally implemented using &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt; java.string.replaceAll(String regex, String replacement)&lt;/a&gt; where 'regExp' and 'newChar' are passed as the 1st and 2nd argument respectively. If you want to replace &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt; special characters&lt;/a&gt; such as '[' in the string literal, it is necessary to escape them in 'regExp' by prefixing them with double backslashes (e.g. '\\[').</source>
          <target state="translated">请注意，REPLACE函数是使用&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)&quot;&gt;java.string.replaceAll（String regex，String replacement）&lt;/a&gt;在内部实现的，其中regExp和newchar分别作为第一个和第二个参数传递。如果要替换字符串文字中的&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html#bs&quot;&gt;特殊字符，&lt;/a&gt;例如&amp;ldquo; [&amp;rdquo;，则必须在它们的&amp;ldquo; regExp&amp;rdquo;中通过在其前面加上双反斜杠（例如&amp;ldquo; \\ [&amp;rdquo;）来对其进行转义。</target>
        </trans-unit>
        <trans-unit id="7e09f5334aab86da1b1a89569910200108793437" translate="yes" xml:space="preserve">
          <source>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable.</source>
          <target state="translated">请注意,ship选项有两个组成部分:ship()子句中提供的源规范是你的机器的视图;命令规范是实际集群的视图。唯一的保证是,出货的文件在启动作业的当前工作目录中是可用的,而且你的当前工作目录也在PATH环境变量中。</target>
        </trans-unit>
        <trans-unit id="4e1565e4014885607dad5c0c2988001edad8fcbf" translate="yes" xml:space="preserve">
          <source>Note that there is no concept of delimit in JsonLoader or JsonStorage. The data is encoded in standard JSON format. JsonLoader optionally takes a schema as the construct argument.</source>
          <target state="translated">请注意,在JsonLoader或JsonStorage中没有delimit的概念。数据是以标准JSON格式编码的。JsonLoader可以选择接受一个模式作为构造参数。</target>
        </trans-unit>
        <trans-unit id="f363dfb66c51fc8e96f3f1500d605d9e9288e8c2" translate="yes" xml:space="preserve">
          <source>Note that type is NOT part of parameter definition. It is your responsibility to document the types of the parameters in a macro.</source>
          <target state="translated">注意,类型不是参数定义的一部分。您有责任在宏中记录参数的类型。</target>
        </trans-unit>
        <trans-unit id="2d208e362ac7a9c4e5eb23ba8f74811e2d7eaa7a" translate="yes" xml:space="preserve">
          <source>Note that, even if filtering is omitted, the same results will be produced because the foreach results is a cross product and cross products get rid of empty bags. However, doing up-front filtering is more efficient since it reduces the input of the cross product.</source>
          <target state="translated">请注意,即使省略过滤,也会产生同样的结果,因为foreach的结果是交叉产品,而交叉产品可以摆脱空袋。不过,做前置过滤的效率更高,因为它减少了交叉产品的投入。</target>
        </trans-unit>
        <trans-unit id="1ed3db195fd189a63eb841d3fbd72406806084cd" translate="yes" xml:space="preserve">
          <source>Note the following about bags:</source>
          <target state="translated">注意以下关于袋子的问题。</target>
        </trans-unit>
        <trans-unit id="d3b92c42da2b629b81e09e80527a3382ab34212d" translate="yes" xml:space="preserve">
          <source>Note the following about the GROUP/COGROUP and JOIN operators:</source>
          <target state="translated">注意以下关于GROUP/COGROUP和JOIN操作符的内容。</target>
        </trans-unit>
        <trans-unit id="cc2f3dea19169906a9c3f9ebf1959122ab5b196c" translate="yes" xml:space="preserve">
          <source>Note the following general observations about data types:</source>
          <target state="translated">请注意以下关于数据类型的一般性意见:</target>
        </trans-unit>
        <trans-unit id="69a5304de52ed596021b9b04debf06f38d8482d3" translate="yes" xml:space="preserve">
          <source>Note the following restrictions:</source>
          <target state="translated">注意以下限制:</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="473512170f0fb2c20a02c7d3b244817ba7bd30ab" translate="yes" xml:space="preserve">
          <source>Note the second column, &amp;lsquo;cube&amp;rsquo; field which is a bag of all tuples that belong to &amp;lsquo;group&amp;rsquo;. Also note that the measure attribute &amp;lsquo;sales&amp;rsquo; along with other unused dimensions in load statement are pushed down so that it can be referenced later while computing aggregates on the measure, like in this case SUM(cube.sales).</source>
          <target state="translated">请注意第二列&amp;ldquo;多维数据集&amp;rdquo;字段，它是属于&amp;ldquo;组&amp;rdquo;的所有元组的包。还要注意，将度量属性&amp;ldquo; sales&amp;rdquo;以及load语句中的其他未使用尺寸下推，以便稍后在计算度量上的聚合时可以引用该属性，例如本例中的SUM（cube.sales）。</target>
        </trans-unit>
        <trans-unit id="2e3c6dd868a0b7f3f2667d05913760948c880115" translate="yes" xml:space="preserve">
          <source>Note, the legacy property pig.additional.jars which use colon as separator is still supported. But we recommend to use pig.additional.jars.uris since colon is also used in URL scheme, and thus we cannot use full scheme in the list. We will deprecate pig.additional.jar in future releases.</source>
          <target state="translated">请注意,仍然支持使用冒号作为分隔符的传统属性pig.additional.jars,但我们建议使用pig.additional.jars.uris,因为在URL方案中也使用了冒号,因此我们不能在列表中使用完整的方案。但我们建议使用pig.additional.jars.uris,因为在URL方案中也使用了冒号,因此我们不能在列表中使用完整的方案。我们将在以后的版本中取消pig.additional.jar。</target>
        </trans-unit>
        <trans-unit id="965007b15476572db9ef0dd93fbea3f0a4093cfd" translate="yes" xml:space="preserve">
          <source>Note: A few Hive 0.14 UDF contains bug which affects Pig and are fixed in Hive 1.0. Here is a list: compute_stats, context_ngrams, count, ewah_bitmap, histogram_numeric, collect_list, collect_set, ngrams, case, in, named_struct, stack, percentile_approx.</source>
          <target state="translated">注:一些Hive 0.14 UDF包含了影响Pig的bug,在Hive 1.0中得到了修复。以下是一个列表:compute_stats,context_ngrams,count,ewah_bitmap,histogram_numeric,collect_list,collect_set,ngrams,case,in,named_struct,stack,percentile_approx.</target>
        </trans-unit>
        <trans-unit id="1dc746cfe7d74da28d435069888547345cd0e6c0" translate="yes" xml:space="preserve">
          <source>Note: FOREACH statements can be nested to two levels only. FOREACH statements that are nested to three or more levels will result in a grammar error.</source>
          <target state="translated">注意:FOREACH语句只能嵌套到两层。FOREACH语句如果嵌套到三层或三层以上将导致语法错误。</target>
        </trans-unit>
        <trans-unit id="80e6a55bf31a90c13baf56b918aa0883b6a73cca" translate="yes" xml:space="preserve">
          <source>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</source>
          <target state="translated">注意:由于性能原因,加载器可能不会立即将数据转换为指定的格式;但是,你仍然可以对数据进行假设指定类型的操作。</target>
        </trans-unit>
        <trans-unit id="ef3e4fdc51f94140b39d0bd6e49fb88dc740fa81" translate="yes" xml:space="preserve">
          <source>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED bz/bz2 FILES generated in this manner:</source>
          <target state="translated">注意:PigStorage和TextLoader可以正确地读取压缩文件,只要它们不是以这种方式生成的concatenATED bz/bz2文件。</target>
        </trans-unit>
        <trans-unit id="c0518f86c35b79620a3094a43a0ad3c6c991d598" translate="yes" xml:space="preserve">
          <source>Note: The GROUP and COGROUP operators are identical. Both operators work with one or more relations. For readability GROUP is used in statements involving one relation and COGROUP is used in statements involving two or more relations. You can COGROUP up to but no more than 127 relations at a time.</source>
          <target state="translated">注意:GROUP和COGROUP运算符是相同的。这两个运算符都适用于一个或多个关系。为了便于阅读,GROUP用于涉及一个关系的语句,COGROUP用于涉及两个或多个关系的语句。一次最多可以COGROUP但不超过127个关系。</target>
        </trans-unit>
        <trans-unit id="1dd595d75ed7d8086119b3f8ba5b4bdfe66882d8" translate="yes" xml:space="preserve">
          <source>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</source>
          <target state="translated">注意:LIMIT操作符允许Pig避免处理关系中的所有元组。在大多数情况下,使用 LIMIT 的查询比不使用 LIMIT 的相同查询运行效率更高。如果可以的话,使用limit总是一个好主意。</target>
        </trans-unit>
        <trans-unit id="2b9a0acdfe2379b3842f287d992bccd78205e712" translate="yes" xml:space="preserve">
          <source>Note: The expression can consist of constants or scalars; it cannot contain any columns from the input relation.</source>
          <target state="translated">注意:表达式可以由常量或标量组成;不能包含输入关系中的任何列。</target>
        </trans-unit>
        <trans-unit id="c0f3237ae0f4fc4380931b678193ed2fc302b2e4" translate="yes" xml:space="preserve">
          <source>Note: To debug scripts during development, you can use &lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt; to check intermediate results.</source>
          <target state="translated">注意：要在开发过程中调试脚本，可以使用&lt;a href=&quot;test#dump&quot;&gt;DUMP&lt;/a&gt;来检查中间结果。</target>
        </trans-unit>
        <trans-unit id="b80c89e4cc5f492c5be085c22ab1f50cca4f91fc" translate="yes" xml:space="preserve">
          <source>Note: Using a scalar instead of a constant in LIMIT automatically disables most optimizations (only push-before-foreach is performed).</source>
          <target state="translated">注意:在LIMIT中使用标量而不是常量,会自动禁用大多数优化(只执行push-before-foreach)。</target>
        </trans-unit>
        <trans-unit id="ee0e474fc81852f36c5fdc6b3952b10b45bbe057" translate="yes" xml:space="preserve">
          <source>Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.</source>
          <target state="translated">注意:不能在COUNT中使用元组代号(*);也就是说,COUNT(*)将不起作用。</target>
        </trans-unit>
        <trans-unit id="109a6c5afefe5d900d28ab42046f4fa5d0b0d109" translate="yes" xml:space="preserve">
          <source>Note: exec, run, and explain also support parameter substitution.</source>
          <target state="translated">注:exec、run和explain也支持参数替换。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c256885553501e3fcd67fb31c3651f0b8df34e96" translate="yes" xml:space="preserve">
          <source>Now that we have the function implemented, it needs to be compiled and included in a jar. You will need to build pig.jar to compile your UDF. You can use the following set of commands to checkout the code from SVN repository and create pig.jar:</source>
          <target state="translated">现在我们已经实现了这个函数,它需要被编译并包含在一个jar中。你需要建立pig.jar来编译你的UDF。你可以使用以下一组命令从SVN仓库中检查代码并创建pig.jar。</target>
        </trans-unit>
        <trans-unit id="bb88ad100d7880e07c6d760abded0864a9d02ad0" translate="yes" xml:space="preserve">
          <source>Now the following script will ran:</source>
          <target state="translated">现在将运行以下脚本。</target>
        </trans-unit>
        <trans-unit id="1f2d994aef96688f7037755c22498e05bc932790" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A by the first field to form relation X.</source>
          <target state="translated">现在,假设我们将关系A按第一个字段分组,形成关系X。</target>
        </trans-unit>
        <trans-unit id="80712e1ab7247b5e2bf95f9c76ec0fce22fb65e3" translate="yes" xml:space="preserve">
          <source>Now, suppose we group relation A on field &quot;age&quot; for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named &quot;group&quot; and is type int, the same as field &quot;age&quot; in relation A. The second field is name &quot;A&quot; after relation A and is type bag.</source>
          <target state="translated">现在,假设我们将关系A的字段 &quot;年龄 &quot;分组,形成关系B,我们可以使用DESCRIBE和ILLUSTRATE运算符来检查关系B的结构。第一个字段命名为 &quot;group&quot;,类型为int,与关系A中的字段 &quot;age &quot;相同;第二个字段在关系A之后命名为 &quot;A&quot;,类型为bag。</target>
        </trans-unit>
        <trans-unit id="217dc9412f1631b0d14b11b385eb5f1c8fece4f7" translate="yes" xml:space="preserve">
          <source>Now, you can assert that a0 column in your data is &amp;gt;0, fail if otherwise</source>
          <target state="translated">现在，您可以断言数据中的a0列&amp;gt; 0，否则返回失败</target>
        </trans-unit>
        <trans-unit id="b5fa110064ef2aba05aa7955d4237db465bf6269" translate="yes" xml:space="preserve">
          <source>Null Operators</source>
          <target state="translated">空操作符</target>
        </trans-unit>
        <trans-unit id="d723cf2b44d40a1ac71aeacb0490bce050f06594" translate="yes" xml:space="preserve">
          <source>Null operator:</source>
          <target state="translated">无效运算符。</target>
        </trans-unit>
        <trans-unit id="9a0b4f0bceedd8bee0e9f98e565c8e1a7a905e08" translate="yes" xml:space="preserve">
          <source>Nulls and Constants</source>
          <target state="translated">无效和常量</target>
        </trans-unit>
        <trans-unit id="f8e886cfbe6cffa98e03a6ad89d5caf8d8cf99de" translate="yes" xml:space="preserve">
          <source>Nulls and GROUP/COGROUP Operators</source>
          <target state="translated">空值和GROUP/COGROUP操作符</target>
        </trans-unit>
        <trans-unit id="9d0af334fae1ee9bc62facfa1200db1ece9b07c4" translate="yes" xml:space="preserve">
          <source>Nulls and JOIN Operator</source>
          <target state="translated">Nulls和JOIN操作符</target>
        </trans-unit>
        <trans-unit id="0b3c1a0927de16437ff4e83643fa705f3fbadba3" translate="yes" xml:space="preserve">
          <source>Nulls and Load Functions</source>
          <target state="translated">空值和加载函数</target>
        </trans-unit>
        <trans-unit id="d3eb7d232fed3cb6080570b64943cc8ecee344e0" translate="yes" xml:space="preserve">
          <source>Nulls and Pig Latin</source>
          <target state="translated">Nulls和Pig Latin</target>
        </trans-unit>
        <trans-unit id="6da7a1f37680b518d10a94f89d73ceb2846a7f55" translate="yes" xml:space="preserve">
          <source>Nulls are considered smaller than evertyhing. If data contains null keys, they should occur before anything else.</source>
          <target state="translated">Nulls被认为比evertyhing小。如果数据中包含空键,它们应该出现在其他东西之前。</target>
        </trans-unit>
        <trans-unit id="e071444e347313a47d45e426ba220f983bb2317e" translate="yes" xml:space="preserve">
          <source>Nulls can be used as constant expressions in place of expressions of any type.</source>
          <target state="translated">Nulls可以作为常量表达式来代替任何类型的表达式。</target>
        </trans-unit>
        <trans-unit id="1208e9e89c0a8cbfe9919e6706a3a570ae6c30f8" translate="yes" xml:space="preserve">
          <source>Nulls, Operators, and Functions</source>
          <target state="translated">无值、运算符和函数</target>
        </trans-unit>
        <trans-unit id="67b2f87c7a2f07028b46ec3058b64c67312a49b0" translate="yes" xml:space="preserve">
          <source>Numerics take a prefix modifier: , for locale-specific thousands-delimiting, 0 for zero-padding; + to always show a plus sign for positive numbers; space  to allow a space preceding positive numbers; ( to indicate negative numbers with parentheses (accountant-style).</source>
          <target state="translated">数字采用前缀修饰符。千位分隔符表示局部,0表示零填充;+表示正数始终显示加号;空格表示正数前有空格;(表示负数用括号表示(会计式)。</target>
        </trans-unit>
        <trans-unit id="e98bff99da15229b9b6d25ba78b508e05e344875" translate="yes" xml:space="preserve">
          <source>ONSCHEMA</source>
          <target state="translated">ONSCHEMA</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">排序方式</target>
        </trans-unit>
        <trans-unit id="7b09d896b967e0241fb1f8e717db211b19ad86b0" translate="yes" xml:space="preserve">
          <source>OTHERWISE</source>
          <target state="translated">OTHERWISE</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="91ecfe414d0fb8ea8961b0c7b022ed8849f2e096" translate="yes" xml:space="preserve">
          <source>OUTPUT &amp;ndash; Keyword.</source>
          <target state="translated">输出&amp;ndash;关键字。</target>
        </trans-unit>
        <trans-unit id="5e8b6c4fabb5fcd98502309908c5ae2f7f3b3d89" translate="yes" xml:space="preserve">
          <source>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] &amp;hellip;] )</source>
          <target state="translated">输出（{stdout | stderr |'path'} [使用解串器] [，{stdout | stderr |'path'} [使用解串器...]]）</target>
        </trans-unit>
        <trans-unit id="436316c809cb5512af5763e373c28a63cb305e4d" translate="yes" xml:space="preserve">
          <source>Object[]: Tuple</source>
          <target state="translated">Object[]:Tuple</target>
        </trans-unit>
        <trans-unit id="a921503fb0dae8fda28f9d3615aba523991068c2" translate="yes" xml:space="preserve">
          <source>Occasionally, users use BinStorage to store their own data. However, because BinStorage is a proprietary binary format, the original data is never in BinStorage - it is always a derivation of some other data.</source>
          <target state="translated">偶尔,用户会使用BinStorage来存储自己的数据。然而,由于BinStorage是一种专有的二进制格式,原始数据从来没有在BinStorage中出现过--它总是其他数据的衍生。</target>
        </trans-unit>
        <trans-unit id="0bc92801b465b9bb97e55a1a664340f960368994" translate="yes" xml:space="preserve">
          <source>Often user data is stored such that both inputs are already sorted on the join key. In this case, it is possible to join the data in the map phase of a MapReduce job. This provides a significant performance improvement compared to passing all of the data through unneeded sort and shuffle phases.</source>
          <target state="translated">通常用户数据的存储方式是,两个输入都已经在join键上进行了排序。在这种情况下,可以在MapReduce作业的map阶段加入数据。与将所有数据通过不需要的排序和洗牌阶段相比,这提供了一个显著的性能改进。</target>
        </trans-unit>
        <trans-unit id="f378e4a14200e531d64d8be58a4840b795824261" translate="yes" xml:space="preserve">
          <source>Often you are not interested in the entire output but rather a sample or top results. In such cases, using LIMIT can yield a much better performance as we push the limit as high as possible to minimize the amount of data travelling through the pipeline.</source>
          <target state="translated">通常情况下,您对整个输出不感兴趣,而是对样本或顶级结果感兴趣。在这种情况下,使用LIMIT可以产生更好的性能,因为我们尽可能地将极限推高,以减少通过管道的数据量。</target>
        </trans-unit>
        <trans-unit id="cf71a41255fb73b5c3854a80e8b93532dd87b916" translate="yes" xml:space="preserve">
          <source>Often you may need to use a simple function that is already provided by standard Java libraries, but for which a &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDF) has not been written. Dynamic invokers allow you to refer to Java functions without having to wrap them in custom UDFs, at the cost of doing some Java reflection on every function call.</source>
          <target state="translated">通常，您可能需要使用标准Java库已经提供的简单函数，但是尚未为其编写&lt;a href=&quot;udf&quot;&gt;用户定义函数&lt;/a&gt;（UDF）。动态调用程序使您可以引用Java函数，而不必将其包装在自定义UDF中，这是以在每个函数调用上进行一些Java反射为代价的。</target>
        </trans-unit>
        <trans-unit id="c0734e56926091020e2bafbec598196d6c34bd12" translate="yes" xml:space="preserve">
          <source>Omit line numbers in the list.</source>
          <target state="translated">省略列表中的行号。</target>
        </trans-unit>
        <trans-unit id="5922013b0865acdbeeb785909913820c1e623db4" translate="yes" xml:space="preserve">
          <source>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</source>
          <target state="translated">在UTF-8系统上，您可以指定由可打印ASCII字符（例如'abc'）组成的字符串常量；您可以指定控制字符，例如'\ t';并且，您可以通过以'\ u'开头来指定Unicode中的字符，例如，'\ u0001'以十六进制表示Ctrl-A（请参阅Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;，&lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;）。从理论上讲，您应该能够在非UTF-8系统上指定非UTF-8常量，但据我们所知，尚未对此进行测试。</target>
        </trans-unit>
        <trans-unit id="fccca353eb6301c93d9f86e365716c6debf47b6c" translate="yes" xml:space="preserve">
          <source>On the non-trivial queries (one ran longer than a couple of minutes) we saw significant improvements both in terms of query latency and space usage. For some queries we saw up to 96% disk saving and up to 4x query speed up. Of course, the performance characteristics are very much query and data dependent and testing needs to be done to determine gains. We did not see any slowdown in the tests we peformed which means that you are at least saving on space while using compression.</source>
          <target state="translated">在非平凡的查询中(其中一个运行时间超过几分钟),我们看到查询延迟和空间使用方面都有显著改善。对于一些查询,我们看到了高达96%的磁盘节省和高达4倍的查询速度提升。当然,性能特性在很大程度上取决于查询和数据,需要进行测试来确定收益。在我们所做的测试中,我们并没有看到任何的减速,这意味着你在使用压缩的同时至少节省了空间。</target>
        </trans-unit>
        <trans-unit id="4c24fbf5c7d7120112ceec12106504825249996b" translate="yes" xml:space="preserve">
          <source>One case where pushing filters up might not be a good idea is if the cost of applying filter is very high and only a small amount of data is filtered out.</source>
          <target state="translated">有一种情况下,将过滤器推高可能不是一个好主意,那就是如果应用过滤器的成本非常高,而且只有少量数据被过滤掉。</target>
        </trans-unit>
        <trans-unit id="c2cbc2e2cd29c7b36db51b7156f79f696494a899" translate="yes" xml:space="preserve">
          <source>One downside of MapReduce is the startup cost for a job is very high. That hurts the performance especially for small job. Tez alleviate the problem by using session and container reuse, so it is not necessary to start an application master for every job, and start a JVM for every task. By default, session/container reuse is on and we usually shall not turn it off. JVM reuse might cause some side effect if static variable is used since static variable might live across different jobs. So if static variable is used in EvalFunc/LoadFunc/StoreFunc, be sure to implement a cleanup function and register with &lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;.</source>
          <target state="translated">MapReduce的缺点之一是工作的启动成本非常高。这会损害性能，尤其是对于小工作。通过使用会话和容器重用，Tez可以缓解该问题，因此不必为每个作业启动应用程序主服务器，也不必为每个任务启动JVM。默认情况下，会话/容器重用处于打开状态，我们通常不应将其关闭。如果使用静态变量，则JVM重用可能会产生一些副作用，因为静态变量可能存在于不同的作业中。因此，如果在EvalFunc / LoadFunc / StoreFunc中使用了静态变量，请确保实现清除功能并向&lt;a href=&quot;http://pig.apache.org/docs/r0.17.0/api/org/apache/pig/JVMReuseManager.html&quot;&gt;JVMReuseManager&lt;/a&gt;注册。</target>
        </trans-unit>
        <trans-unit id="01399f316fca8487fd4f55faaee3ac7bb6836292" translate="yes" xml:space="preserve">
          <source>One more note about schemas and UDFs. Users have requested the ability to examine the input schema of the data before processing the data via a UDF. For example, they would like to know how to convert an input tuple to a map such that the keys in the map are the names of the input columns. Currently there is no way to do this. This is a feature we would like to support in the future.</source>
          <target state="translated">关于模式和UDF还有一个说明。用户要求能够在通过UDF处理数据之前检查数据的输入模式。例如,他们想知道如何将一个输入元组转换为一个映射,使映射中的键是输入列的名称。目前还没有办法做到这一点。这是我们希望在未来支持的一个功能。</target>
        </trans-unit>
        <trans-unit id="86b1a003236c7726fc8c1ef65c53f5899623c990" translate="yes" xml:space="preserve">
          <source>One or more Pig Latin statements, enclosed in curly brackets.</source>
          <target state="translated">一个或多个Pig Latin语句,用大括号括起来。</target>
        </trans-unit>
        <trans-unit id="cb292bd04b825808a658558eceff1f99e3746de2" translate="yes" xml:space="preserve">
          <source>One problem that users run into is when they make assumption about how many times a constructor for their UDF is called. For instance, they might be creating side files in the store function and doing it in the constructor seems like a good idea. The problem with this approach is that in most cases Pig instantiates functions on the client side to, for instance, examine the schema of the data.</source>
          <target state="translated">用户遇到的一个问题是,当他们对UDF的构造函数的调用次数做出假设时。例如,他们可能会在存储函数中创建侧文件,而在构造函数中做似乎是个好主意。这种方法的问题是,在大多数情况下,Pig会在客户端实例化函数,例如,检查数据的模式。</target>
        </trans-unit>
        <trans-unit id="768e440f42a11fcbfa95a4b6852f49f12632d6f7" translate="yes" xml:space="preserve">
          <source>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</source>
          <target state="translated">只有文件,而不是目录,可以用ship选项指定。绕过这个限制的一个方法是将所有的依赖关系都压缩到一个能准确反映计算节点上所需结构的tar文件中,然后为你的脚本设计一个包装器,在执行前解开依赖关系的tar。</target>
        </trans-unit>
        <trans-unit id="2f500bcae0ac1d9a7f69a316f1483fc4cc7418c1" translate="yes" xml:space="preserve">
          <source>Only left outer join is supported for replicated joins.</source>
          <target state="translated">复制连接只支持左外侧连接。</target>
        </trans-unit>
        <trans-unit id="98c134b4570970f85b7a28cd1d729744bbdd592f" translate="yes" xml:space="preserve">
          <source>Only methods annotated with either @OutputSchema or @OutputSchemaFunction will be exposed to Pig as UDFs. In the example above, squareSchema will not be available in Pig as a UDF.</source>
          <target state="translated">只有用 @OutputSchema 或 @OutputSchemaFunction 注解的方法才会作为 UDF 暴露给 Pig。在上面的例子中,squareSchema将不会作为UDF在Pig中使用。</target>
        </trans-unit>
        <trans-unit id="7404c733035e01f2951203e52a17f2d7b25c3f70" translate="yes" xml:space="preserve">
          <source>Only primitives can be used for numbers; no capital-letter numeric classes can be used as arguments. Depending on the return type, a specific kind of invoker must be used: InvokeForString, InvokeForInt, InvokeForLong, InvokeForDouble, or InvokeForFloat.</source>
          <target state="translated">只有基元可以用于数字;不能将大写字母的数字类用作参数。根据返回类型,必须使用特定类型的调用器。InvokeForString、InvokeForInt、InvokeForLong、InvokeForDouble或InvokeForFloat。</target>
        </trans-unit>
        <trans-unit id="c500f72032e0fffa7307e38303bd6bd22f060e21" translate="yes" xml:space="preserve">
          <source>Operations That Produce Nulls</source>
          <target state="translated">产生空值的操作</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="6c7f4f579b94c45bf7d1ec93c8760a07327897b1" translate="yes" xml:space="preserve">
          <source>Optimization Rules</source>
          <target state="translated">优化规则</target>
        </trans-unit>
        <trans-unit id="04659a29a038f8b6f95d9df28a89681d94dc2803" translate="yes" xml:space="preserve">
          <source>Optimization can also be achieved using fragment replicate joins, skewed joins, and merge joins. For more information see &lt;a href=&quot;perf#specialized-joins&quot;&gt;Specialized Joins&lt;/a&gt;.</source>
          <target state="translated">还可以使用片段复制联接，偏斜联接和合并联接来实现优化。有关更多信息，请参见&lt;a href=&quot;perf#specialized-joins&quot;&gt;特殊联接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f92b41bb13aa91ef73f2405bc184ea22fe7ab53" translate="yes" xml:space="preserve">
          <source>Optimization for regular joins ensures that the last table in the join is not brought into memory but streamed through instead. Optimization reduces the amount of memory used which means you can avoid spilling the data and also should be able to scale your query to larger data volumes.</source>
          <target state="translated">常规连接的优化确保了连接中的最后一张表不会被带入内存,而是被流过。优化减少了所使用的内存量,这意味着你可以避免数据溢出,也应该能够将你的查询扩展到更大的数据量。</target>
        </trans-unit>
        <trans-unit id="f8766608ab14ae4c0ace8e4aee51b7a378f862b8" translate="yes" xml:space="preserve">
          <source>Optional items:</source>
          <target state="translated">可选项目:</target>
        </trans-unit>
        <trans-unit id="9efc8753c1e4995cd0d1185902d8c3c9200a5b32" translate="yes" xml:space="preserve">
          <source>Optional keyword. Designates a default relation.</source>
          <target state="translated">可选关键字。指定一个默认关系。</target>
        </trans-unit>
        <trans-unit id="f9d88b237b4a78d338edf7da6c0b3e11382d6f4d" translate="yes" xml:space="preserve">
          <source>Optional tuple representing constant parameters of a Hive UDF/UDTF/UDAF. If Hive UDF requires a constant parameter, there is no other way Pig can pass that information to Hive, since Pig schema does not carry the information whether a parameter is constant or not. Null item in the tuple means this field is not a constant. Non-null item represents a constant field. Data type for the item is determined by Pig contant parser.</source>
          <target state="translated">可选的元组,代表Hive UDF/UDTF/UDAF的常量参数。如果Hive UDF需要一个常量参数,Pig没有其他方式可以将该信息传递给Hive,因为Pig schema不携带参数是否为常量的信息。元组中的空项代表这个字段不是常量。非空项代表一个常量字段。项的数据类型由Pig contant解析器决定。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="371b0ae2ff2ab087176f32bee166d4da2913bff3" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark local mode:</source>
          <target state="translated">或者如果你使用的是Spark本地模式。</target>
        </trans-unit>
        <trans-unit id="095b0c2883ec0b939fed65357c1b04420e296e0a" translate="yes" xml:space="preserve">
          <source>Or if you are using Spark:</source>
          <target state="translated">或者如果你使用的是Spark。</target>
        </trans-unit>
        <trans-unit id="907c1518b24f449be57666853914f303931b978f" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez local mode:</source>
          <target state="translated">或者如果你使用的是Tez本地模式。</target>
        </trans-unit>
        <trans-unit id="5a4c4c74b3f7d241b86e5336001adb11c6de88bf" translate="yes" xml:space="preserve">
          <source>Or if you are using Tez:</source>
          <target state="translated">或者如果你在使用Tez。</target>
        </trans-unit>
        <trans-unit id="4c9450cd3b04d1fd47af444a11a91bb90f9a49d5" translate="yes" xml:space="preserve">
          <source>Orc BYTE/BINARY all map to Pig bytearray</source>
          <target state="translated">半兽人BYTE/BINARY全部映射到Pig bytearray。</target>
        </trans-unit>
        <trans-unit id="b510b6858c4b9765788f82d0e9c521f50419cd2f" translate="yes" xml:space="preserve">
          <source>Orc DECIMAL maps to Pig bigdecimal</source>
          <target state="translated">半兽人DECIMAL映射到Pig bigdecimal。</target>
        </trans-unit>
        <trans-unit id="9961f1b05ddf0fc66a4ab6a46c676c806aebb176" translate="yes" xml:space="preserve">
          <source>Orc STRING/CHAR/VARCHAR all map to Pig varchar</source>
          <target state="translated">半兽人STRING/CHAR/VARCHAR全部映射到Pig varchar。</target>
        </trans-unit>
        <trans-unit id="6d27972086aacd281681114b9c28fd369d9c4b9f" translate="yes" xml:space="preserve">
          <source>Orc TIMESTAMP/DATE all maps to Pig datetime</source>
          <target state="translated">兽人的时间标签/日期全部映射到猪的日期时间。</target>
        </trans-unit>
        <trans-unit id="a1591da02510a2712f04308058e399add5eca1dd" translate="yes" xml:space="preserve">
          <source>OrcStorage</source>
          <target state="translated">OrcStorage</target>
        </trans-unit>
        <trans-unit id="4c9f23c645f12bfa00bd50f98ef015ca573fdaf2" translate="yes" xml:space="preserve">
          <source>OrcStorage as a LoadFunc.</source>
          <target state="translated">OrcStorage作为一个LoadFunc。</target>
        </trans-unit>
        <trans-unit id="3eb7b9cec1cdd27213bef34fc6170acf9fdd4faa" translate="yes" xml:space="preserve">
          <source>OrcStorage as a StoreFunc.</source>
          <target state="translated">OrcStorage作为一个StoreFunc。</target>
        </trans-unit>
        <trans-unit id="469606f67e8335e115993b24e3f6965fc1459c33" translate="yes" xml:space="preserve">
          <source>OrcStorage predicate pushdown currently support all primitive data types but none of the complex data types. For example, map condition cannot push into OrcStorage:</source>
          <target state="translated">OrcStorage predicate pushdown目前支持所有的原始数据类型,但不支持复杂数据类型。例如,地图条件不能推入OrcStorage。</target>
        </trans-unit>
        <trans-unit id="1bfcf8f6cfd1ff12ec733abbdfb29a53dcdc9dcc" translate="yes" xml:space="preserve">
          <source>OrcStorage(['options'])</source>
          <target state="translated">OrcStorage(['options'])</target>
        </trans-unit>
        <trans-unit id="d0fe29562a7c21056884a2c410f56a9812b54c99" translate="yes" xml:space="preserve">
          <source>Original Avro Types</source>
          <target state="translated">原有的Avro类型</target>
        </trans-unit>
        <trans-unit id="882617723625c587393c99fb5f6b0d0cf3ad5a0e" translate="yes" xml:space="preserve">
          <source>Original Pig Type</source>
          <target state="translated">原猪型</target>
        </trans-unit>
        <trans-unit id="be0be73dfa142afb06644b4bd429b15778e4bac4" translate="yes" xml:space="preserve">
          <source>Other Modes</source>
          <target state="translated">其他模式</target>
        </trans-unit>
        <trans-unit id="ebe6018e98731e126f80812a6b4853d5ee2275d6" translate="yes" xml:space="preserve">
          <source>Other properties</source>
          <target state="translated">其他属性</target>
        </trans-unit>
        <trans-unit id="701a7e9210bdedb5978458dbeba9fb2d822971a2" translate="yes" xml:space="preserve">
          <source>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from /bin, /usr/bin, /usr/local/bin. Pig will determine this by scanning the path if an absolute path is provided or by executing which. The paths can be made configurable using the &lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt; option (you can use multiple set commands to specify more than one path to skip).</source>
          <target state="translated">否则，Pig将尝试从命令行发送第一个字符串，只要它不来自/ bin，/ usr / bin，/ usr / local / bin。 Pig将通过扫描路径（如果提供了绝对路径）或执行绝对路径来确定这一点。可以使用&lt;a href=&quot;cmds#set&quot;&gt;set stream.skippath&lt;/a&gt;选项使这些路径可配置（您可以使用多个set命令来指定多个要跳过的路径）。</target>
        </trans-unit>
        <trans-unit id="a338e1e79d114a1522d9eb5979c8db612a93073a" translate="yes" xml:space="preserve">
          <source>Otherwise, the RANK operator uses each field (or set of fields) to sort the relation. The rank of a tuple is one plus the number of different rank values preceding it. If two or more tuples tie on the sorting field values, they will receive the same rank.</source>
          <target state="translated">否则,rank操作符使用每个字段(或字段集)来对关系进行排序。一个元组的等级是1加上它前面不同等级值的数量。如果两个或更多的元组在排序字段值上打成平手,它们将获得相同的等级。</target>
        </trans-unit>
        <trans-unit id="5cd2e1cb8ff03e85d7add8f6016467a3f5e57d79" translate="yes" xml:space="preserve">
          <source>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</source>
          <target state="translated">外联接只适用于双向联接;如果要执行多向外联接,则需要执行多条双向外联接语句。</target>
        </trans-unit>
        <trans-unit id="600054c2fe7432d844752d909a7af30d0a800923" translate="yes" xml:space="preserve">
          <source>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</source>
          <target state="translated">只有在需要产生空值(在非匹配键的情况下)的关系有模式的情况下,外连接才会工作。</target>
        </trans-unit>
        <trans-unit id="c746f245398c7408bb6df1ccfc1430c711902402" translate="yes" xml:space="preserve">
          <source>Outer merge join (between two tables) and inner merge join (between three or more tables) will only work under these conditions:</source>
          <target state="translated">外侧合并连接(两张表之间)和内侧合并连接(三张或更多的表之间)只有在这些条件下才能工作。</target>
        </trans-unit>
        <trans-unit id="0d2a263550d66b9f4e2dd5cc2ce0bd6b5aa3b982" translate="yes" xml:space="preserve">
          <source>Output location strict check</source>
          <target state="translated">严格检查输出位置</target>
        </trans-unit>
        <trans-unit id="c5729f9b287de5b3dfc0238cb6432a164885bc6a" translate="yes" xml:space="preserve">
          <source>Output schema</source>
          <target state="translated">输出模式</target>
        </trans-unit>
        <trans-unit id="f1657b858c692a8810b394c9fbe10ef1f3ebefa9" translate="yes" xml:space="preserve">
          <source>OutputStats</source>
          <target state="translated">OutputStats</target>
        </trans-unit>
        <trans-unit id="efbc45e086170113898fb269e6cf4a872cd68ed5" translate="yes" xml:space="preserve">
          <source>Overall you would create a file that looks like this (assume we call it niels.kerberos.properties):</source>
          <target state="translated">总的来说,你会创建一个类似这样的文件(假设我们把它叫做niels.kerberos.properties)。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="96ce24f1a92e6b30382bcf71beddd1d02bbf7658" translate="yes" xml:space="preserve">
          <source>PARALLEL n</source>
          <target state="translated">并行n</target>
        </trans-unit>
        <trans-unit id="b00fec6efa227099463e118d74a38da9dc9e323c" translate="yes" xml:space="preserve">
          <source>PARTITION BY partitioner</source>
          <target state="translated">按分区器分区</target>
        </trans-unit>
        <trans-unit id="2b338af39aea20defe562c404d22d384da1fb4d9" translate="yes" xml:space="preserve">
          <source>Parallel Execution</source>
          <target state="translated">并行执行</target>
        </trans-unit>
        <trans-unit id="58171bd8fa88aa62d26baf06d454a174292bf115" translate="yes" xml:space="preserve">
          <source>Parallel joins are vulnerable to the presence of skew in the underlying data. If the underlying data is sufficiently skewed, load imbalances will swamp any of the parallelism gains. In order to counteract this problem, skewed join computes a histogram of the key space and uses this data to allocate reducers for a given key. Skewed join does not place a restriction on the size of the input keys. It accomplishes this by splitting the left input on the join predicate and streaming the right input. The left input is sampled to create the histogram.</source>
          <target state="translated">并行连接很容易受到基础数据中存在的倾斜的影响。如果底层数据有足够的倾斜,负载不平衡将淹没任何并行性收益。为了解决这个问题,倾斜连接计算出键空间的直方图,并使用这些数据为给定的键分配减速器。倾斜联接不对输入键的大小进行限制。它通过拆分join谓词上的左输入和流式输入右输入来实现。左边的输入会被采样以创建直方图。</target>
        </trans-unit>
        <trans-unit id="3375c065590ef4a44f56b15335a0387a3cccbc5a" translate="yes" xml:space="preserve">
          <source>Parameter Substitution</source>
          <target state="translated">参数替换</target>
        </trans-unit>
        <trans-unit id="7790c9a165b0c914283a93f7037cf0b0cc4cb830" translate="yes" xml:space="preserve">
          <source>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed.</source>
          <target state="translated">参数文件按照命令行上指定的顺序进行扫描。在每个文件中,参数按其排列顺序进行处理。</target>
        </trans-unit>
        <trans-unit id="70117576ffa2ad03e5513ff9b3fbd512b8641d45" translate="yes" xml:space="preserve">
          <source>Parameter names are case insensitive.</source>
          <target state="translated">参数名称不分大小写。</target>
        </trans-unit>
        <trans-unit id="f6466211ad9aa97ba4dc313d987046ab6af23120" translate="yes" xml:space="preserve">
          <source>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods.</source>
          <target state="translated">通过参数替换,您可以编写包含参数的 Pig 脚本,并在运行时为这些参数提供值。例如,假设您有一个需要每天使用当前一天的数据运行的作业,您可以创建一个包含日期参数的Pig脚本。你可以创建一个包含日期参数的Pig脚本。然后,当你运行这个脚本时,你可以使用其中一种支持的方法为日期参数指定或提供一个值。</target>
        </trans-unit>
        <trans-unit id="f69e14d703d0fb6cfc378c0a831efb4f72f66bf1" translate="yes" xml:space="preserve">
          <source>Parameter substitution may be used inside of macros. When there are conflicts between names of parameters defined at the top level and names of arguments or return values for a given macro, then ones inside the macro are used. See &lt;a href=&quot;#define-macros&quot;&gt;DEFINE (macros)&lt;/a&gt;.</source>
          <target state="translated">可以在宏内部使用参数替换。如果在顶层定义的参数名称与给定宏的参数名称或返回值之间存在冲突，则使用该宏内的参数。参见&lt;a href=&quot;#define-macros&quot;&gt;DEFINE（宏）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c256c12a753b5b6bd6decc3861da77cc5d8f2234" translate="yes" xml:space="preserve">
          <source>Parameters Supported in the Query String</source>
          <target state="translated">查询字符串中支持的参数</target>
        </trans-unit>
        <trans-unit id="769003fbcc6fc353a4044c923e34ca968752f228" translate="yes" xml:space="preserve">
          <source>Parameters are processed as follows:</source>
          <target state="translated">参数处理如下:</target>
        </trans-unit>
        <trans-unit id="0074ddadeda7d41356f958931e0fcd57e8b79c9b" translate="yes" xml:space="preserve">
          <source>Parameters defined in parameter files specified by -param_file</source>
          <target state="translated">参数定义在由-param_file指定的参数文件中。</target>
        </trans-unit>
        <trans-unit id="70543f43b0b77a80afe0d18b065682a97d7fcc6d" translate="yes" xml:space="preserve">
          <source>Parameters defined in the command line using -param</source>
          <target state="translated">在命令行中使用-param定义的参数。</target>
        </trans-unit>
        <trans-unit id="e7a454f5498afc7a5bd9a3b2032372bdf7551245" translate="yes" xml:space="preserve">
          <source>Parameters defined using the declare statement</source>
          <target state="translated">使用声明语句定义的参数</target>
        </trans-unit>
        <trans-unit id="7030e575509b3a9849a213f50450f6c3ea2b9a16" translate="yes" xml:space="preserve">
          <source>Parameters defined using the default statement</source>
          <target state="translated">使用默认语句定义的参数</target>
        </trans-unit>
        <trans-unit id="ef98d6e375037bebdef260ca6d55bd8ab3dd0e64" translate="yes" xml:space="preserve">
          <source>Parentheses are also used to indicate the tuple data type.</source>
          <target state="translated">括号也用来表示元组数据类型。</target>
        </trans-unit>
        <trans-unit id="ddc4e9e14a7a05acd86ecf4b274ad71ee33e5bcd" translate="yes" xml:space="preserve">
          <source>Parentheses enclose one or more items.</source>
          <target state="translated">括号中包含一个或多个项目。</target>
        </trans-unit>
        <trans-unit id="9277a0569e80e9b319b019aefc95b0225b6e8571" translate="yes" xml:space="preserve">
          <source>PartitionFilterOptimizer</source>
          <target state="translated">PartitionFilterOptimizer</target>
        </trans-unit>
        <trans-unit id="97a0e02c60f7bd5b056aeeb4d721b45b24381261" translate="yes" xml:space="preserve">
          <source>Partitions a relation into two or more relations.</source>
          <target state="translated">将一个关系分割成两个或多个关系。</target>
        </trans-unit>
        <trans-unit id="5fffb570a05163ec7d3a9ee94c710223f45deb55" translate="yes" xml:space="preserve">
          <source>Passing Configurations to UDFs</source>
          <target state="translated">将配置传递给UDFs</target>
        </trans-unit>
        <trans-unit id="900e8b0d2c1088af54281fa7b734ee24070da72e" translate="yes" xml:space="preserve">
          <source>Passing Parameters to a Script</source>
          <target state="translated">向脚本传递参数</target>
        </trans-unit>
        <trans-unit id="30e96c64e3d87a1b3ae0dcab374223bf047c1fd7" translate="yes" xml:space="preserve">
          <source>Passing a Pig Script</source>
          <target state="translated">传递Pig脚本</target>
        </trans-unit>
        <trans-unit id="bc0b27a7477f8ed02a5b4c719673367cbbf610fe" translate="yes" xml:space="preserve">
          <source>Perform a bloom join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations. Bloom filter is built from join keys of the right most relation which is small and the filter is applied on the big and medium relations. None of the relations are required to fit into main memory.</source>
          <target state="translated">使用USING子句执行Bloom Join（请参阅&lt;a href=&quot;basic#join-inner&quot;&gt;JOIN（内部）&lt;/a&gt;和&lt;a href=&quot;basic#join-outer&quot;&gt;JOIN（外部）&lt;/a&gt;）。在此示例中，大关系与两个小关系结合在一起。请注意，较大的关系首先出现，其次是较小的关系。Bloom过滤器是根据最右边的小联接键建立的，并且该过滤器适用于大和中等关系。不需要任何关系就可以装入主存储器。</target>
        </trans-unit>
        <trans-unit id="67969b99648d91d1035f722084db31dddca473ad" translate="yes" xml:space="preserve">
          <source>Perform a merge join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">使用USING子句执行合并&lt;a href=&quot;basic#join-inner&quot;&gt;联接（&lt;/a&gt;请参阅JOIN（内部）和&lt;a href=&quot;basic#join-outer&quot;&gt;JOIN（外部）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="dd5572ed8b373fc67c4f3724a55aa798b14ca3c3" translate="yes" xml:space="preserve">
          <source>Perform a merge-sparse join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt;).</source>
          <target state="translated">使用USING子句执行合并稀疏连接（请参阅&lt;a href=&quot;basic#join-inner&quot;&gt;JOIN（内部）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="402e4b589f5a0d62e1e68cc5769ea6fe810721f3" translate="yes" xml:space="preserve">
          <source>Perform a replicated join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;). In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations; and, all small relations together must fit into main memory, otherwise an error is generated.</source>
          <target state="translated">使用USING子句执行复制&lt;a href=&quot;basic#join-inner&quot;&gt;联接（&lt;/a&gt;请参阅JOIN（内部）和&lt;a href=&quot;basic#join-outer&quot;&gt;JOIN（外部）&lt;/a&gt;）。在此示例中，大关系与两个小关系结合在一起。请注意，较大的关系首先出现，其次是较小的关系。并且，所有小关系必须一起放入主存储器中，否则会产生错误。</target>
        </trans-unit>
        <trans-unit id="1f464de18fcec5cc28885815dcee4e7667a7ec7e" translate="yes" xml:space="preserve">
          <source>Perform a skewed join with the USING clause (see &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt; and &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;).</source>
          <target state="translated">使用USING子句执行倾斜的&lt;a href=&quot;basic#join-inner&quot;&gt;联接（&lt;/a&gt;请参阅JOIN（内部）和&lt;a href=&quot;basic#join-outer&quot;&gt;JOIN（外部）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3130994b43da1d8950109e1c6564a8348e9d6104" translate="yes" xml:space="preserve">
          <source>Performance Considerations</source>
          <target state="translated">性能考虑因素</target>
        </trans-unit>
        <trans-unit id="f24e3938bb4e4cb45e3fceea03006c92f75688c9" translate="yes" xml:space="preserve">
          <source>Performance Enhancers</source>
          <target state="translated">性能增强剂</target>
        </trans-unit>
        <trans-unit id="25a6857524ecb9afe00595831a6eabce0d0dfafa" translate="yes" xml:space="preserve">
          <source>Performance and Efficiency</source>
          <target state="translated">性能和效率</target>
        </trans-unit>
        <trans-unit id="8f76637cf34db3a94cdd1b0e2b9af4d58294a730" translate="yes" xml:space="preserve">
          <source>Performs an inner join of two or more relations based on common field values.</source>
          <target state="translated">根据共同的字段值执行两个或多个关系的内部连接。</target>
        </trans-unit>
        <trans-unit id="1e1e34d4c871c8f4da9be20b9f4469a363f98b73" translate="yes" xml:space="preserve">
          <source>Performs an outer join of two relations based on common field values.</source>
          <target state="translated">根据共同的字段值执行两个关系的外连接。</target>
        </trans-unit>
        <trans-unit id="cad8be75b29842759141027890e92f4432bb017a" translate="yes" xml:space="preserve">
          <source>Performs cube/rollup operations.</source>
          <target state="translated">执行cube/rollup操作。</target>
        </trans-unit>
        <trans-unit id="d24cf8c587230b4ed2537a805a07c9584dcfb6ca" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts all matched groups.</source>
          <target state="translated">执行正则表达式匹配并提取所有匹配组。</target>
        </trans-unit>
        <trans-unit id="9018076e46e8c3ab55cf8633b09942355fa4aec9" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and extracts the matched group defined by an index parameter.</source>
          <target state="translated">执行正则表达式匹配并提取由索引参数定义的匹配组。</target>
        </trans-unit>
        <trans-unit id="ebeb13a8133f2d73bb66dcd9301c11a7ab8ac32f" translate="yes" xml:space="preserve">
          <source>Performs regular expression matching and searches all matched characters in a string.</source>
          <target state="translated">执行正则表达式匹配并搜索字符串中所有匹配的字符。</target>
        </trans-unit>
        <trans-unit id="28e7ba6ea4395e9894a796bb57462b156a7c5827" translate="yes" xml:space="preserve">
          <source>Pig JAR file</source>
          <target state="translated">Pig JAR文件</target>
        </trans-unit>
        <trans-unit id="92283693de8e1c937c436504772afa7e54d4d779" translate="yes" xml:space="preserve">
          <source>Pig Latin Basics</source>
          <target state="translated">猪的拉丁语基础知识</target>
        </trans-unit>
        <trans-unit id="278a8301cb0641c9a4edbfd68852047e3b82ffe2" translate="yes" xml:space="preserve">
          <source>Pig Latin Statements</source>
          <target state="translated">猪的拉丁语声明</target>
        </trans-unit>
        <trans-unit id="abe1ac30b366cc27ad64f6b2a535541e0d5bd848" translate="yes" xml:space="preserve">
          <source>Pig Latin operators and functions interact with nulls as shown in this table.</source>
          <target state="translated">Pig拉丁语运算符和函数与空值的交互,如本表所示。</target>
        </trans-unit>
        <trans-unit id="3c6a60413a273559ed0f210ce1379e5ecd049483" translate="yes" xml:space="preserve">
          <source>Pig Latin provides operators that can help you debug your Pig Latin statements:</source>
          <target state="translated">Pig Latin提供的操作符可以帮助你调试Pig Latin语句。</target>
        </trans-unit>
        <trans-unit id="f38d85519e485d8e2d061fcc97d35bf4ac9736e0" translate="yes" xml:space="preserve">
          <source>Pig Latin statement:</source>
          <target state="translated">猪拉丁语声明。</target>
        </trans-unit>
        <trans-unit id="aafb100d0f8b7f3882c6325c161b1a4b645fc993" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are generally organized as follows:</source>
          <target state="translated">猪拉丁语的语句一般组织如下:</target>
        </trans-unit>
        <trans-unit id="dfefbefcd550d25bef5229b93a8fd8ba2bde0953" translate="yes" xml:space="preserve">
          <source>Pig Latin statements are the basic constructs you use to process data using Pig. A Pig Latin statement is an operator that takes a &lt;a href=&quot;basic#relations&quot;&gt;relation&lt;/a&gt; as input and produces another relation as output. (This definition applies to all Pig Latin operators except LOAD and STORE which read data from and write data to the file system.) Pig Latin statements may include &lt;a href=&quot;basic#expressions&quot;&gt;expressions&lt;/a&gt; and &lt;a href=&quot;basic#schemas&quot;&gt;schemas&lt;/a&gt;. Pig Latin statements can span multiple lines and must end with a semi-colon ( ; ). By default, Pig Latin statements are processed using &lt;a href=&quot;perf#multi-query-execution&quot;&gt;multi-query execution&lt;/a&gt;.</source>
          <target state="translated">Pig Latin语句是用于使用Pig处理数据的基本构造。 Pig Latin语句是一个将一个&lt;a href=&quot;basic#relations&quot;&gt;关系&lt;/a&gt;作为输入并产生另一个关系作为输出的运算符。 （此定义适用于除LOAD和STORE之外的所有Pig Latin运算符，它们从文件系统读取数据并将数据写入文件系统。）Pig Latin语句可以包括&lt;a href=&quot;basic#expressions&quot;&gt;表达式&lt;/a&gt;和&lt;a href=&quot;basic#schemas&quot;&gt;模式&lt;/a&gt;。 Pig拉丁语语句可以跨越多行，并且必须以分号（;）结尾。默认情况下，使用&lt;a href=&quot;perf#multi-query-execution&quot;&gt;多查询执行&lt;/a&gt;处理Pig Latin语句。</target>
        </trans-unit>
        <trans-unit id="4d6b1b831ea171957ed0e1ca09e2fcb0f0cc8198" translate="yes" xml:space="preserve">
          <source>Pig Latin supports casts as shown in this table.</source>
          <target state="translated">猪拉丁语支持投稿,如本表所示。</target>
        </trans-unit>
        <trans-unit id="d272d6e8e9fd410fba40f8d7f45eb3ef23d66fd5" translate="yes" xml:space="preserve">
          <source>Pig Latin supports the definition, expansion, and import of macros.</source>
          <target state="translated">Pig Latin支持宏的定义、扩展和导入。</target>
        </trans-unit>
        <trans-unit id="a52974cdd3ea4e71d39c1a5b454a4491f41f2366" translate="yes" xml:space="preserve">
          <source>Pig Latin syntax statement:</source>
          <target state="translated">猪的拉丁语语法语句。</target>
        </trans-unit>
        <trans-unit id="a6de2cdfe9e769e638ae13f67688e2ebf50c4116" translate="yes" xml:space="preserve">
          <source>Pig Macros</source>
          <target state="translated">猪宏</target>
        </trans-unit>
        <trans-unit id="4a2ca1d4b92ee91ccc81dde3263e5535ea441ba7" translate="yes" xml:space="preserve">
          <source>Pig Object</source>
          <target state="translated">猪对象</target>
        </trans-unit>
        <trans-unit id="9fd1a1cb2d567f7a5ff0480ca9134d87032c5949" translate="yes" xml:space="preserve">
          <source>Pig Progress Notification Listener</source>
          <target state="translated">Pig进度通知监听器</target>
        </trans-unit>
        <trans-unit id="99c542779d91327bc9bd3447f9526c2088c67b88" translate="yes" xml:space="preserve">
          <source>Pig Properties</source>
          <target state="translated">猪的特性</target>
        </trans-unit>
        <trans-unit id="734f02bedf731c9ba833109c0b94942fe59227b8" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (local mode)</source>
          <target state="translated">猪脚本1,查询短语流行度(本地模式</target>
        </trans-unit>
        <trans-unit id="0e141603768346ca22cbf8799fa641ebc9a2665a" translate="yes" xml:space="preserve">
          <source>Pig Script 1, Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">猪脚本1,查询短语流行度(mapreduce模式)。</target>
        </trans-unit>
        <trans-unit id="2da304232e645beee888e58d6826aa40479df310" translate="yes" xml:space="preserve">
          <source>Pig Script 1: Query Phrase Popularity</source>
          <target state="translated">Pig Script 1:查询短语流行度</target>
        </trans-unit>
        <trans-unit id="f9be711a0ed7d8a9d09e991f0c431dfed287b99e" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (local mode)</source>
          <target state="translated">Pig Script 2、时空查询词条流行度(本地模式</target>
        </trans-unit>
        <trans-unit id="f2397170eecb6952fd14aafebda31090031e9196" translate="yes" xml:space="preserve">
          <source>Pig Script 2, Temporal Query Phrase Popularity (mapreduce mode)</source>
          <target state="translated">Pig Script 2、时空查询词组流行度(mapreduce模式)。</target>
        </trans-unit>
        <trans-unit id="96a4246b4d848f77f5340b34b8f5f9356de36427" translate="yes" xml:space="preserve">
          <source>Pig Script 2: Temporal Query Phrase Popularity</source>
          <target state="translated">Pig Script 2:时态查询词组受欢迎程度</target>
        </trans-unit>
        <trans-unit id="d650e124b03231e4f6e63a60633af92981457281" translate="yes" xml:space="preserve">
          <source>Pig Scripts</source>
          <target state="translated">猪脚本</target>
        </trans-unit>
        <trans-unit id="3711a90b3c1fa50c85635bc7e599451f34dc20e0" translate="yes" xml:space="preserve">
          <source>Pig Scripts and MapReduce Job IDs (MapReduce mode only)</source>
          <target state="translated">Pig Scripts和MapReduce作业ID(仅MapReduce模式)。</target>
        </trans-unit>
        <trans-unit id="43590fd010743d8912e0f24af54d70fb5088bcc6" translate="yes" xml:space="preserve">
          <source>Pig Setup</source>
          <target state="translated">猪的设置</target>
        </trans-unit>
        <trans-unit id="ad6533e178840e687da8395d7e65379f0284aea8" translate="yes" xml:space="preserve">
          <source>Pig Statistics</source>
          <target state="translated">猪统计</target>
        </trans-unit>
        <trans-unit id="e124c110e55a5e3fc700ba74964a062c34387574" translate="yes" xml:space="preserve">
          <source>Pig Statistics is a framework for collecting and storing script-level statistics for Pig Latin. Characteristics of Pig Latin scripts and the resulting MapReduce jobs are collected while the script is executed. These statistics are then available for Pig users and tools using Pig (such as Oozie) to retrieve after the job is done.</source>
          <target state="translated">Pig Statistics是一个用于收集和存储Pig Latin脚本级统计数据的框架。Pig Latin 脚本和由此产生的 MapReduce 作业的特征在脚本执行时被收集。然后,这些统计数据可供Pig用户和使用Pig的工具(如Oozie)在作业完成后检索。</target>
        </trans-unit>
        <trans-unit id="612dd975aa5ad31fc345b7a3ddd612ad0616e4ab" translate="yes" xml:space="preserve">
          <source>Pig Tutorial</source>
          <target state="translated">猪的教程</target>
        </trans-unit>
        <trans-unit id="4757ba63e67d355d84729fef8914757bf15f22dd" translate="yes" xml:space="preserve">
          <source>Pig Tutorial Files</source>
          <target state="translated">Pig教程文件</target>
        </trans-unit>
        <trans-unit id="f4e3c20276b1374c79d691d19de05b31570ed547" translate="yes" xml:space="preserve">
          <source>Pig Type</source>
          <target state="translated">猪型</target>
        </trans-unit>
        <trans-unit id="47775b7064fc01c255082ec71e837ab11cb3bfdc" translate="yes" xml:space="preserve">
          <source>Pig Types and Native Java Types</source>
          <target state="translated">Pig类型和本地Java类型</target>
        </trans-unit>
        <trans-unit id="763ba17130114f0d728d2c9da6a94cee2662e38e" translate="yes" xml:space="preserve">
          <source>Pig allocates a fix amount of memory to store bags and spills to disk as soon as the memory limit is reached. This is very similar to how Hadoop decides when to spill data accumulated by the combiner.</source>
          <target state="translated">Pig会分配一个固定的内存量来存储袋,一旦达到内存上限,就会立即溢出到磁盘。这与Hadoop如何决定何时溢出梳理机积累的数据非常相似。</target>
        </trans-unit>
        <trans-unit id="11d7036422db3b031d72375b00787ef03de9aa59" translate="yes" xml:space="preserve">
          <source>Pig allows you to cast the elements of a single-tuple relation into a scalar value. The tuple can be a single-field or multi-field tulple. If the relation contains more than one tuple, however, a runtime error is generated: &quot;Scalar has more than one row in the output&quot;.</source>
          <target state="translated">Pig 允许你将一个单元组关系的元素转换为一个标量值。元组可以是单字段或多字段的元组。然而,如果关系包含多个元组,就会产生一个运行时错误。&quot;Scalar在输出中有多于一行&quot;。</target>
        </trans-unit>
        <trans-unit id="e6f9793557df721a51315601bec2173f9083f743" translate="yes" xml:space="preserve">
          <source>Pig allows you to transform data in many ways. As a starting point, become familiar with these operators:</source>
          <target state="translated">Pig允许你以多种方式转换数据。作为一个起点,熟悉这些操作符。</target>
        </trans-unit>
        <trans-unit id="73604424b7f623aa52673331d4844b85c87dfa4e" translate="yes" xml:space="preserve">
          <source>Pig also provides support for Piggy Bank, a repository for JAVA UDFs. Through Piggy Bank you can access Java UDFs written by other users and contribute Java UDFs that you have written.</source>
          <target state="translated">Pig还提供了对Piggy Bank的支持,Piggy Bank是一个JAVA UDFs的存储库,通过Piggy Bank,你可以访问其他用户编写的Java UDFs,并贡献你编写的Java UDFs。通过Piggy Bank,您可以访问其他用户编写的Java UDF,并贡献您编写的Java UDF。</target>
        </trans-unit>
        <trans-unit id="f2ee3d36a3dc27b7f962519361eb68284ec849ad" translate="yes" xml:space="preserve">
          <source>Pig bigdecimal/biginteger all map to Orc DECIMAL</source>
          <target state="translated">猪的bigdecimal/biginteger都映射到兽人的DECIMAL上。</target>
        </trans-unit>
        <trans-unit id="5a000788cb7b838a8a19059f606035a562b8829b" translate="yes" xml:space="preserve">
          <source>Pig bytearray maps to Orc BINARY</source>
          <target state="translated">猪的字节阵列映射到半兽人BINARY。</target>
        </trans-unit>
        <trans-unit id="da371b573e3bcb43e639b2160b5c518b0b7700f1" translate="yes" xml:space="preserve">
          <source>Pig chararray maps to Orc STRING</source>
          <target state="translated">猪图谱映射到兽人STRING</target>
        </trans-unit>
        <trans-unit id="7d31dc542bef65e4c473198b27d60992d79d21e7" translate="yes" xml:space="preserve">
          <source>Pig comes with a set of built in functions (the eval, load/store, math, string, bag and tuple functions). Two main properties differentiate built in functions from &lt;a href=&quot;udf&quot;&gt;user defined functions&lt;/a&gt; (UDFs). First, built in functions don't need to be registered because Pig knows where they are. Second, built in functions don't need to be qualified when they are used because Pig knows where to find them.</source>
          <target state="translated">Pig带有一组内置函数（评估，加载/存储，数学，字符串，包和元组函数）。内置函数与&lt;a href=&quot;udf&quot;&gt;用户定义函数&lt;/a&gt;（UDF）有两个主要属性。首先，内置函数不需要注册，因为Pig知道它们在哪里。其次，内置函数在使用时不需要限定，因为Pig知道在哪里可以找到它们。</target>
        </trans-unit>
        <trans-unit id="ec76128e5910a6c0dc476b3ee3f3c86bf0e02469" translate="yes" xml:space="preserve">
          <source>Pig currently drops all STORE and DUMP commands. You can tell PigUnit to keep the commands and execute the script:</source>
          <target state="translated">Pig目前放弃了所有STORE和DUMP命令。你可以告诉PigUnit保留这些命令并执行脚本。</target>
        </trans-unit>
        <trans-unit id="3ad1529318465104bd4cda2ad68472350964be44" translate="yes" xml:space="preserve">
          <source>Pig currently supports ordering on fields with simple types or by tuple designator (*). You cannot order on fields with complex types or by expressions.</source>
          <target state="translated">Pig 目前支持对简单类型的字段或通过元组代号 (*)进行排序。您不能对复杂类型的字段或通过表达式进行排序。</target>
        </trans-unit>
        <trans-unit id="d9f5530e025cc570af7472498b65ad3cdc347893" translate="yes" xml:space="preserve">
          <source>Pig datetime maps to Orc TIMESTAMP</source>
          <target state="translated">猪的日期时间映射到兽人的TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="b06635ad448da689ef56ed31a6a822d359c09cd2" translate="yes" xml:space="preserve">
          <source>Pig does not (yet) determine when a field is no longer needed and drop the field from the row. For example, say you have a query like:</source>
          <target state="translated">Pig并没有(还没有)确定何时不再需要一个字段,并从行中删除该字段。例如,假设你有一个类似于以下的查询。</target>
        </trans-unit>
        <trans-unit id="4c9e85a8b2e0c0dd60b8ab7196e655a11595d0e5" translate="yes" xml:space="preserve">
          <source>Pig does not provide a loader that supports outer merge joins. You will need to build your own loader to take advantage of this feature.</source>
          <target state="translated">Pig 不提供支持外部合并连接的加载器。你需要建立自己的加载器来利用这个功能。</target>
        </trans-unit>
        <trans-unit id="78bf7455f2e9a63798376b4de79dec1915e2cc29" translate="yes" xml:space="preserve">
          <source>Pig function names are case sensitive and UPPER CASE.</source>
          <target state="translated">猪的函数名是区分大小写的,而且是UPPER CASE。</target>
        </trans-unit>
        <trans-unit id="3497b8a9c4307da9ad98ce7b329893e102bfadf9" translate="yes" xml:space="preserve">
          <source>Pig has implemented a merge join algorithm, or sort-merge join. It works on pre-sorted data, and does not sort data for you. See Conditions, below, for restrictions that apply when using this join algorithm. Pig implements the merge join algorithm by selecting the left input of the join to be the input file for the map phase, and the right input of the join to be the side file. It then samples records from the right input to build an index that contains, for each sampled record, the key(s) the filename and the offset into the file the record begins at. This sampling is done in the first MapReduce job. A second MapReduce job is then initiated, with the left input as its input. Each map uses the index to seek to the appropriate record in the right input and begin doing the join.</source>
          <target state="translated">Pig实现了一个合并连接算法,或者说排序合并连接。它适用于预先排序的数据,而不是为你排序数据。请参阅下面的条件,了解使用该连接算法时的限制。Pig 实现合并联接算法的方法是选择联接的左输入作为 map 阶段的输入文件,联接的右输入作为侧文件。然后,它从右边输入的记录中取样,建立一个索引,这个索引包含了每个取样记录的键、文件名和记录开始的文件的偏移量。这个采样是在第一个MapReduce作业中完成的。然后启动第二个MapReduce作业,以左边的输入作为其输入。每个Map使用索引寻找到右边输入中的相应记录,并开始做连接。</target>
        </trans-unit>
        <trans-unit id="8c465a5a14c5bf2028d4313b2065c52ed6b1f407" translate="yes" xml:space="preserve">
          <source>Pig has six execution modes or exectypes:</source>
          <target state="translated">Pig有六种执行模式或exectypes。</target>
        </trans-unit>
        <trans-unit id="abe1a7ac5158db2e5d49b5c0bf1750141f4b1162" translate="yes" xml:space="preserve">
          <source>Pig invokes all types of Hive UDF, including UDF, GenericUDF, UDAF, GenericUDAF and GenericUDTF. Depending on the Hive UDF you want to use, you need to declare it in Pig with HiveUDF(handles UDF and GenericUDF), HiveUDAF(handles UDAF and GenericUDAF), HiveUDTF(handles GenericUDTF).</source>
          <target state="translated">Pig调用所有类型的Hive UDF,包括UDF、GenericUDF、UDAF、GenericUDAF和GenericUDTF。根据你要使用的Hive UDF,你需要在Pig中用HiveUDF(handle UDF和GenericUDF)、HiveUDAF(handle UDAF和GenericUDAF)、HiveUDTF(handle GenericUDTF)来声明它。</target>
        </trans-unit>
        <trans-unit id="ab624fcbf738a4b8acd080c76087b67d14708f02" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification. If any of the input parameters are null or if an insufficient number of parameters are supplied, NULL is returned.</source>
          <target state="translated">Pig可能会以不同于Java API规范中所述的方式处理结果。如果任何输入参数为空或提供的参数数量不足,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="5a922bbffcd1b5032fad1768816830c613580833" translate="yes" xml:space="preserve">
          <source>Pig may process results differently than as stated in the Java API Specification:</source>
          <target state="translated">Pig可能会以不同于Java API规范中所述的方式处理结果。</target>
        </trans-unit>
        <trans-unit id="9471d85941c65173fff582e14b71cf4f967ea913" translate="yes" xml:space="preserve">
          <source>Pig provides constant representations for all data types except bytearrays.</source>
          <target state="translated">Pig为除字节数组以外的所有数据类型提供了常量表示。</target>
        </trans-unit>
        <trans-unit id="87c574c013f523193858b45a84f91642023a8f10" translate="yes" xml:space="preserve">
          <source>Pig provides extensive support for user defined functions (UDFs) as a way to specify custom processing. Pig UDFs can currently be implemented in six languages: Java, Jython, Python, JavaScript, Ruby and Groovy.</source>
          <target state="translated">Pig为用户定义函数(UDFs)提供了广泛的支持,作为一种指定自定义处理的方式。Pig UDFs目前可以用六种语言实现。Java、Jython、Python、JavaScript、Ruby和Groovy。</target>
        </trans-unit>
        <trans-unit id="ceda33dea4ba3f881c49648249091f447f7a880a" translate="yes" xml:space="preserve">
          <source>Pig provides shortcuts for the frequently used debugging operators (DUMP, DESCRIBE, EXPLAIN, ILLUSTRATE). These shortcuts can be used in Grunt shell or within pig scripts. Following are the shortcuts supported by pig</source>
          <target state="translated">Pig 为常用的调试操作符(DUMP、DESCRIBE、EXPLAIN、ILLUSTRATE)提供了快捷键,这些快捷键可以在 Grunt shell 或 pig 脚本中使用。这些快捷键可以在Grunt shell中或猪脚本中使用。以下是pig支持的快捷方式</target>
        </trans-unit>
        <trans-unit id="8e8994ca2f5728663eb94fb005036ffcd6396df7" translate="yes" xml:space="preserve">
          <source>Pig provides the ability to register a listener to receive event notifications during the execution of a script. Events include MapReduce plan creation, script launch, script progress, script completion, job submit, job start, job completion and job failure.</source>
          <target state="translated">Pig提供了在脚本执行过程中注册监听器以接收事件通知的能力。事件包括MapReduce计划创建、脚本启动、脚本进度、脚本完成、作业提交、作业启动、作业完成和作业失败。</target>
        </trans-unit>
        <trans-unit id="aa6596e8905b3938c3700ea230f899c89f11a17f" translate="yes" xml:space="preserve">
          <source>Pig reserved keywords are listed here.</source>
          <target state="translated">这里列出了猪的保留关键词。</target>
        </trans-unit>
        <trans-unit id="8ee530c88eb069019e89fb162c7af7e0491d6334" translate="yes" xml:space="preserve">
          <source>Pig scripts allow you to pass values to parameters using &lt;a href=&quot;cont#Parameter-Sub&quot;&gt;parameter substitution&lt;/a&gt;.</source>
          <target state="translated">Pig脚本允许您使用&lt;a href=&quot;cont#Parameter-Sub&quot;&gt;参数替换&lt;/a&gt;将值传递给参数。</target>
        </trans-unit>
        <trans-unit id="7af5953cb1970013fe65b12593533955cde08d36" translate="yes" xml:space="preserve">
          <source>Pig scripts could contain multiple STORE statements. There are cases when one would like to avoid writing to the same output location. Pig provides admins/script writers with a property to check if multiple STORE statements make an attempt to write to the same output directory. And fail fast letting the user know of the same.</source>
          <target state="translated">Pig脚本可以包含多个STORE语句。在某些情况下,人们希望避免写到同一个输出位置。Pig为管理员/脚本编写者提供了一个属性,用于检查多个STORE语句是否试图写入同一个输出目录。并快速失败,让用户知道。</target>
        </trans-unit>
        <trans-unit id="f4f54e08d6f27a21247ba6b73114b665162748d1" translate="yes" xml:space="preserve">
          <source>Pig stores the intermediate data generated between MapReduce jobs in a temporary location on HDFS. This location must already exist on HDFS prior to use. This location can be configured using the pig.temp.dir property. The property's default value is &quot;/tmp&quot; which is the same as the hardcoded location in Pig 0.7.0 and earlier versions.</source>
          <target state="translated">Pig 将 MapReduce 作业之间产生的中间数据存储在 HDFS 上的一个临时位置。在使用之前,这个位置必须已经存在于HDFS上。这个位置可以使用pig.temp.dir属性进行配置。该属性的默认值是&quot;/tmp&quot;,这与Pig 0.7.0和早期版本中的硬编码位置相同。</target>
        </trans-unit>
        <trans-unit id="714c7646d7666c8d22f8f121acb63f13797f2c2b" translate="yes" xml:space="preserve">
          <source>Pig string functions have an extra, first parameter: the string to which all the operations are applied.</source>
          <target state="translated">Pig 字符串函数有一个额外的第一个参数:应用所有操作的字符串。</target>
        </trans-unit>
        <trans-unit id="d463cd387da41f017a06eeec2ec8c8e1a5cb86d2" translate="yes" xml:space="preserve">
          <source>Pig supports a number of Java properties that you can use to customize Pig behavior. You can retrieve a list of the properties using the &lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt; command. All of these properties are optional; none are required.</source>
          <target state="translated">Pig支持许多Java属性，可用于自定义Pig行为。您可以使用&lt;a href=&quot;cmds#help&quot;&gt;help properties&lt;/a&gt;命令检索属性列表。所有这些属性都是可选的。不需要。</target>
        </trans-unit>
        <trans-unit id="baff641180058647b74777d2576baee8385ad92c" translate="yes" xml:space="preserve">
          <source>Pig supports running scripts (and Jar files) that are stored in HDFS, Amazon S3, and other distributed file systems. The script's full location URI is required (see &lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt; for information about Jar files). For example, to run a Pig script on HDFS, do the following:</source>
          <target state="translated">Pig支持存储在HDFS，Amazon S3和其他分布式文件系统中的运行脚本（和Jar文件）。脚本的完整位置URI是必需的（有关Jar文件的信息，请参见&lt;a href=&quot;basic#register&quot;&gt;REGISTER&lt;/a&gt;）。例如，要在HDFS上运行Pig脚本，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="93b8509eca6765e62d9376104cd05a29add5f154" translate="yes" xml:space="preserve">
          <source>Pig supports various &lt;a href=&quot;perf#optimization-rules&quot;&gt;optimization rules&lt;/a&gt; which are turned on by default. Become familiar with these rules.</source>
          <target state="translated">Pig支持各种默认打开的&lt;a href=&quot;perf#optimization-rules&quot;&gt;优化规则&lt;/a&gt;。熟悉这些规则。</target>
        </trans-unit>
        <trans-unit id="7db2788da4d3cb08c1ef2ff25689ec2ee8056211" translate="yes" xml:space="preserve">
          <source>Pig supports various optimization rules, all of which are enabled by default. To disable all or specific optimizations, use one or more of the following methods. Note some optimization rules are mandatory and cannot be disabled.</source>
          <target state="translated">Pig 支持各种优化规则,所有这些规则都是默认启用的。要禁用所有或特定的优化规则,请使用以下一种或多种方法。注意有些优化规则是强制性的,不能禁用。</target>
        </trans-unit>
        <trans-unit id="dec5b4fd96103af2122e2313ddd5abca5934ce71" translate="yes" xml:space="preserve">
          <source>Pig to Groovy</source>
          <target state="translated">猪到Groovy</target>
        </trans-unit>
        <trans-unit id="ffd9764afd639133c7dcafbb3bfb8b5a0f6b5c57" translate="yes" xml:space="preserve">
          <source>Pig uses BinStorage to load and store the temporary data that is generated between multiple MapReduce jobs.</source>
          <target state="translated">Pig使用BinStorage来加载和存储多个MapReduce作业之间产生的临时数据。</target>
        </trans-unit>
        <trans-unit id="e6f964ef2f2e1463a5575b90549505104722c310" translate="yes" xml:space="preserve">
          <source>Pig uses type information for validation and performance. It is important for UDFs to participate in type propagation. Our UDFs generally make no effort to communicate their output schema to Pig. This is because Pig can usually figure out this information by using Java's &lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt; Reflection&lt;/a&gt;. If your UDF returns a scalar or a map, no work is required. However, if your UDF returns a tuple or a bag (of tuples), it needs to help Pig figure out the structure of the tuple.</source>
          <target state="translated">Pig使用类型信息进行验证和性能。 UDF参与类型传播很重要。我们的UDF通常不努力将其输出模式传达给Pig。这是因为Pig通常可以使用Java的&lt;a href=&quot;http://www.oracle.com/technetwork/articles/java/javareflection-1536171.html&quot;&gt;Reflection&lt;/a&gt;找出这些信息。如果您的UDF返回标量或地图，则不需要任何工作。但是，如果您的UDF返回一个元组或一个（元组的）包，则需要帮助Pig找出元组的结构。</target>
        </trans-unit>
        <trans-unit id="b6c4f473278cb2c4d79b79244d369de45127e72f" translate="yes" xml:space="preserve">
          <source>Pig will look for the #!/usr/bin/python line in the script.</source>
          <target state="translated">Pig会在脚本中寻找#!/usr/bin/python行。</target>
        </trans-unit>
        <trans-unit id="e77ea84c3c6071688fbeecc5c58ee3a6a8b11e23" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.groovy extension in the script.</source>
          <target state="translated">Pig会在脚本中寻找*.groovy扩展名。</target>
        </trans-unit>
        <trans-unit id="0364a2ce40f5c70f5452cfa0554c3480442e1323" translate="yes" xml:space="preserve">
          <source>Pig will look for the *.js extension in the script.</source>
          <target state="translated">Pig会在脚本中寻找*.js扩展名。</target>
        </trans-unit>
        <trans-unit id="91634384ed9e6b31da4cf199ee9633830ca9b602" translate="yes" xml:space="preserve">
          <source>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &amp;lt;file&amp;gt;' command).</source>
          <target state="translated">Pig不会自动发送以下系统目录中的文件（这是通过执行&amp;ldquo; which &amp;lt;file&amp;gt;&amp;rdquo;命令确定的）。</target>
        </trans-unit>
        <trans-unit id="25b2234668fa28c694ddf8954f0db6fd297cd55d" translate="yes" xml:space="preserve">
          <source>PigDump</source>
          <target state="translated">PigDump</target>
        </trans-unit>
        <trans-unit id="cd0f4a6c71f7d548ed016babe0f1794757d97253" translate="yes" xml:space="preserve">
          <source>PigDump stores data as tuples in human-readable UTF-8 format.</source>
          <target state="translated">PigDump以人类可读的UTF-8格式存储数据。</target>
        </trans-unit>
        <trans-unit id="076d83430955260169fb65f99eac100421155024" translate="yes" xml:space="preserve">
          <source>PigDump()</source>
          <target state="translated">PigDump()</target>
        </trans-unit>
        <trans-unit id="7e5a4069b9fdb2979478c1ee4fdbc3e2c6ad6bac" translate="yes" xml:space="preserve">
          <source>PigProgressNotificationListener Object</source>
          <target state="translated">PigProgressNotificationListener对象</target>
        </trans-unit>
        <trans-unit id="3b203b52f09d0ae21512293305adfa539797f50a" translate="yes" xml:space="preserve">
          <source>PigRunner API</source>
          <target state="translated">PigRunner API</target>
        </trans-unit>
        <trans-unit id="c591d5d2fae917bd8241460a851795d39ef7fd4d" translate="yes" xml:space="preserve">
          <source>PigServer Interface</source>
          <target state="translated">PigServer接口</target>
        </trans-unit>
        <trans-unit id="2f322dd1e3ab68730e8f4ea4e48514c5d2b0e8fe" translate="yes" xml:space="preserve">
          <source>PigStats</source>
          <target state="translated">PigStats</target>
        </trans-unit>
        <trans-unit id="09ef3422b57b20584bb4bd1065c0d793e6c60aa6" translate="yes" xml:space="preserve">
          <source>PigStats Object</source>
          <target state="translated">PigStats对象</target>
        </trans-unit>
        <trans-unit id="8c9ea42da56c5bce11828868d9a6b3bd2007fda6" translate="yes" xml:space="preserve">
          <source>PigStats is now an abstract class. (PigStats as it was before has become SimplePigStats.)</source>
          <target state="translated">PigStats现在是一个抽象类。之前的PigStats已经变成了SimplePigStats)。</target>
        </trans-unit>
        <trans-unit id="25cdca4514b647129134787cd149f41de99035d4" translate="yes" xml:space="preserve">
          <source>PigStorage</source>
          <target state="translated">PigStorage</target>
        </trans-unit>
        <trans-unit id="189d56b69a7325ea9365151a6fd186619f7dba18" translate="yes" xml:space="preserve">
          <source>PigStorage is the default function used by Pig to load/store the data. PigStorage supports structured text files (in human-readable UTF-8 format) in compressed or uncompressed form (see &lt;a href=&quot;#handling-compression&quot;&gt;Handling Compression&lt;/a&gt;). All Pig &lt;a href=&quot;basic#data-types&quot;&gt;data types&lt;/a&gt; (both simple and complex) can be read/written using this function. The input data to the load can be a file, a directory or a glob.</source>
          <target state="translated">PigStorage是Pig用于加载/存储数据的默认功能。PigStorage支持压缩或未压缩形式的结构化文本文件（人类可读UTF-8格式）（请参阅&lt;a href=&quot;#handling-compression&quot;&gt;处理压缩&lt;/a&gt;）。使用此功能可以读取/写入所有Pig &lt;a href=&quot;basic#data-types&quot;&gt;数据类型&lt;/a&gt;（简单和复杂）。加载的输入数据可以是文件，目录或全局文件。</target>
        </trans-unit>
        <trans-unit id="db2e71c500f2a58ecf6be6205a6d15e6c21c547c" translate="yes" xml:space="preserve">
          <source>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</source>
          <target state="translated">PigStorage是LOAD操作符的默认加载函数。在本例中,is not null操作符用于过滤空值的名称。</target>
        </trans-unit>
        <trans-unit id="851b7752cd0d7ce793cb4e4ca346b699d8bf7ba9" translate="yes" xml:space="preserve">
          <source>PigStorage( [field_delimiter] , ['options'] )</source>
          <target state="translated">PigStorage([field_delimiter],['options'])</target>
        </trans-unit>
        <trans-unit id="0d3b09a00028b253cd0f1f6c7b23a76114298a8a" translate="yes" xml:space="preserve">
          <source>PigUnit</source>
          <target state="translated">PigUnit</target>
        </trans-unit>
        <trans-unit id="dbc328ccebde1c387467a71ae41410ef063708a6" translate="yes" xml:space="preserve">
          <source>PigUnit Example</source>
          <target state="translated">PigUnit示例</target>
        </trans-unit>
        <trans-unit id="e58deab3203c61b8478e84f609cbbfd6830c6870" translate="yes" xml:space="preserve">
          <source>PigUnit also runs in Pig's mapreduce/tez/tez_local mode. Mapreduce/Tez mode requires you to use a Hadoop cluster and HDFS installation. It is enabled when the Java system property pigunit.exectype is set to specific values (mr/tez/tez_local): e.g. -Dpigunit.exectype=mr or System.getProperties().setProperty(&quot;pigunit.exectype&quot;, &quot;mr&quot;), which means PigUnit will run in mr mode. The cluster you select to run mr/tez test must be specified in the CLASSPATH (similar to the HADOOP_CONF_DIR variable).</source>
          <target state="translated">PigUnit也可以在Pig的mapreduce/tez/tez_local模式下运行。Mapreduce/Tez模式需要你使用Hadoop集群和HDFS安装。当Java系统属性pigunit.exectype被设置为特定值(mr/tez/tez_local)时,它就被启用了:例如-Dpigunit.exectype=mr或System.getProperties().setProperty(&quot;pigunit.exectype&quot;,&quot;mr&quot;),这意味着PigUnit将以mr模式运行。你选择运行mr/tez测试的集群必须在CLASSPATH中指定(类似于HADOOP_CONF_DIR变量)。</target>
        </trans-unit>
        <trans-unit id="5efb4aafd77f51485d9e22a5331f73c21b84e2d1" translate="yes" xml:space="preserve">
          <source>PigUnit is a simple xUnit framework that enables you to easily test your Pig scripts. With PigUnit you can perform unit testing, regression testing, and rapid prototyping. No cluster set up is required if you run Pig in local mode.</source>
          <target state="translated">PigUnit是一个简单的xUnit框架,它可以让你轻松地测试你的Pig脚本。通过PigUnit,您可以进行单元测试、回归测试和快速原型设计。如果您在本地模式下运行Pig,则无需设置集群。</target>
        </trans-unit>
        <trans-unit id="e825c7a9656dd5933b89b6587e34170d6f8b825d" translate="yes" xml:space="preserve">
          <source>PigUnit runs in Pig's local mode by default. Local mode is fast and enables you to use your local file system as the HDFS cluster. Local mode does not require a real cluster but a new local one is created each time.</source>
          <target state="translated">PigUnit默认在Pig的本地模式下运行。本地模式速度快,可以将本地文件系统用作HDFS集群。本地模式不需要真正的集群,但每次都会创建一个新的本地集群。</target>
        </trans-unit>
        <trans-unit id="51485a7e9c11278ddb30a38747984651921c7357" translate="yes" xml:space="preserve">
          <source>Piggy Bank</source>
          <target state="translated">存钱罐</target>
        </trans-unit>
        <trans-unit id="94706352a7655c2f04cd6d5b3c48f2991946cce6" translate="yes" xml:space="preserve">
          <source>Piggy Bank is a place for Pig users to share the Java UDFs they have written for use with Pig. The functions are contributed &quot;as-is.&quot; If you find a bug in a function, take the time to fix it and contribute the fix to Piggy Bank. If you don't find the UDF you need, take the time to write and contribute the function to Piggy Bank.</source>
          <target state="translated">Piggy Bank是Pig用户分享他们编写的用于Pig的Java UDF的地方。这些函数都是 &quot;按原样 &quot;贡献的。如果你发现一个函数中的bug,请花时间修复它,并将修复的内容贡献给Piggy Bank。如果你没有找到你需要的UDF,请花时间编写并将函数贡献给Piggy Bank。</target>
        </trans-unit>
        <trans-unit id="548bf24c348f6ecb39a696616e88c2bdb8fc7c48" translate="yes" xml:space="preserve">
          <source>Piggybank now contains a load function called org.apache.pig.piggybank.storage.IndexedStorage that is a derivation of PigStorage and implements IndexedLoadFunc. This is the only loader included in the standard Pig distribution that can be used for merge-sparse join.</source>
          <target state="translated">Piggybank 现在包含一个名为 org.apache.pig.piggybank.storage.IndexedStorage 的加载函数,它是 PigStorage 的派生函数,并实现了 IndexedLoadFunc。这是标准Pig发行版中唯一包含的加载器,可以用于合并-稀疏连接。</target>
        </trans-unit>
        <trans-unit id="80e46ef91cf972b79cfeb37c8c0b0f1a663a2b3c" translate="yes" xml:space="preserve">
          <source>Place your java code in the directory that makes sense for your function. The directory structure currently has two levels: (1) function type, as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;, and (2) function subtype, for some of the types (like math or string for eval functions). If you think your function requires a new subtype, feel free to add one.</source>
          <target state="translated">将Java代码放在对您的功能有意义的目录中。目录结构当前具有两个级别：（1）函数类型（如&lt;a href=&quot;#piggbank-access&quot;&gt;访问函数中所述&lt;/a&gt;）和（2）函数子类型，用于某些类型（如数学或eval函数的字符串）。如果您认为函数需要一个新的子类型，请随时添加一个。</target>
        </trans-unit>
        <trans-unit id="45b51fb4489a0001750d8a0d80a1eabd943fd26b" translate="yes" xml:space="preserve">
          <source>Please note that all parameters must be resolved during bind. Having unbound parameters while running your script is an error. Also note that even if your script is fully defined during compile, bind without parameters still must be called.</source>
          <target state="translated">请注意,所有的参数必须在绑定过程中被解析。在运行你的脚本时有未绑定的参数是一个错误。另外请注意,即使你的脚本在编译过程中已经完全定义,没有参数的绑定仍然必须被调用。</target>
        </trans-unit>
        <trans-unit id="6a06967c386bbcf581bbbff0858c5a65621763d0" translate="yes" xml:space="preserve">
          <source>Please note that the script above can be made more efficient by performing filtering before the GROUP statement:</source>
          <target state="translated">请注意,上面的脚本可以通过在GROUP语句之前执行过滤来提高效率。</target>
        </trans-unit>
        <trans-unit id="1e1fc2184a267b82bd60f72a9ca2cc38f005be8b" translate="yes" xml:space="preserve">
          <source>Please note the following:</source>
          <target state="translated">请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="1e0f495264f489ed260b938fbaf923286b89db5c" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;the Joda-Time doc&lt;/a&gt; for available timezone IDs.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://joda-time.sourceforge.net/timezones.html&quot;&gt;Joda-Time文档&lt;/a&gt;以获取可用的时区ID。</target>
        </trans-unit>
        <trans-unit id="c3414cc34b87b848682458107bbe3817781eebf0" translate="yes" xml:space="preserve">
          <source>PluckTuple</source>
          <target state="translated">PluckTuple</target>
        </trans-unit>
        <trans-unit id="5d6a4911520319a2d3e4452f20e0a79aefaaa5b1" translate="yes" xml:space="preserve">
          <source>Point $HADOOPDIR to the directory that contains the hadoop-site.xml file. Example:</source>
          <target state="translated">将$HADOOPDIR指向包含hadoop-site.xml文件的目录。例子:$HADOOPDIR</target>
        </trans-unit>
        <trans-unit id="dbec33ded970d7645cff3e7a90ffcb1db17bf2b3" translate="yes" xml:space="preserve">
          <source>Positional notation (generated by system)</source>
          <target state="translated">位置符号(由系统生成</target>
        </trans-unit>
        <trans-unit id="7a1a9c9263f88ba37537ce91842a5071d4c86b03" translate="yes" xml:space="preserve">
          <source>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2.</source>
          <target state="translated">位置符号由系统生成。位置符号用美元符号($)表示,并以零(0)开头;例如,$0、$1、$2。</target>
        </trans-unit>
        <trans-unit id="470b7c6b31d52098c05a7c0eb3537e05b562b162" translate="yes" xml:space="preserve">
          <source>Possible name (assigned by you using a schema)</source>
          <target state="translated">可能的名称(由您使用模式指定)</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="c62fe3da66de5300e411627aa04bcf8aba54c94e" translate="yes" xml:space="preserve">
          <source>Precedence for parameters is as follows, from highest to lowest:</source>
          <target state="translated">参数的优先顺序如下,从高到低:</target>
        </trans-unit>
        <trans-unit id="aa06e8fd282659ac6d432bb0788f9503111f1ec3" translate="yes" xml:space="preserve">
          <source>Predicate pushdown</source>
          <target state="translated">谓词推倒</target>
        </trans-unit>
        <trans-unit id="67219f57bcad6686b5aafd1fa4c0f49cde92f4ad" translate="yes" xml:space="preserve">
          <source>PredicatePushdownOptimizer</source>
          <target state="translated">PredicatePushdownOptimizer</target>
        </trans-unit>
        <trans-unit id="8adf8f822b81878db822737e2402a291fabdb7a0" translate="yes" xml:space="preserve">
          <source>Prefer DISTINCT over GROUP BY/GENERATE</source>
          <target state="translated">优先选择DISTINCT而不是GROUP BY/GENERATE。</target>
        </trans-unit>
        <trans-unit id="71ee3d895930077b420791fb640e0fcf277eb35a" translate="yes" xml:space="preserve">
          <source>Preprocessor statement included in a Pig script.</source>
          <target state="translated">包含在Pig脚本中的预处理程序语句。</target>
        </trans-unit>
        <trans-unit id="0e7683a0a1b3a8c7fba74716254c107f2f5e90e3" translate="yes" xml:space="preserve">
          <source>Prerequisite: Tez requires the tez tarball to be available in hdfs while running a job on the cluster and a tez-site.xml with tez.lib.uris setting pointing to that hdfs location in classpath. Copy the tez tarball to hdfs and add the tez conf directory($TEZ_HOME/conf) containing tez-site.xml to environmental variable &quot;PIG_CLASSPATH&quot; if pig on tez fails with &quot;tez.lib.uris is not defined&quot;. This is required by the Apache Pig distribution.</source>
          <target state="translated">前提条件。Tez要求在集群上运行作业时,tez tar包必须在hdfs中可用,并且tez-site.xml的tez.lib.uris设置必须指向classpath中的hdfs位置。将tez的tar包复制到hdfs,并将包含tez-site.xml的tez conf目录($TEZ_HOME/conf)添加到环境变量 &quot;PIG_CLASSPATH &quot;中,如果tez上的pig失败,会出现 &quot;tez.lib.uris未定义&quot;。这是Apache Pig发行版所要求的。</target>
        </trans-unit>
        <trans-unit id="68c4f7f4e32d071edfecdccbc2955d1848fe5d3f" translate="yes" xml:space="preserve">
          <source>Previous Relation Shortcut</source>
          <target state="translated">上一个关系捷径</target>
        </trans-unit>
        <trans-unit id="91668392239b2ed6e082ab66f5115752a3228d5d" translate="yes" xml:space="preserve">
          <source>Prints a list of Pig commands or properties.</source>
          <target state="translated">打印Pig命令或属性的列表。</target>
        </trans-unit>
        <trans-unit id="64172510397f433c399b5d42e0b1269626b1a958" translate="yes" xml:space="preserve">
          <source>Processing Order and Precedence</source>
          <target state="translated">处理顺序和优先权</target>
        </trans-unit>
        <trans-unit id="985f018300a3bcf017393d943a21bd0b142ab797" translate="yes" xml:space="preserve">
          <source>Processing input (either user input or intermediate input) from multiple small files can be inefficient because a separate map has to be created for each file. Pig can now combined small files so that they are processed as a single map.</source>
          <target state="translated">处理来自多个小文件的输入(无论是用户输入还是中间输入)可能效率很低,因为必须为每个文件创建一个单独的地图。现在,Pig可以将小文件组合起来,从而将它们作为一个单一的地图进行处理。</target>
        </trans-unit>
        <trans-unit id="068b6f370b0ca1593f3b3fbac750583d9d7d8efa" translate="yes" xml:space="preserve">
          <source>Processing small mapreduce jobs on hadoop cluster could be slow as it has overhead of job startup and job scheduling. For jobs with small input data, pig can convert them to run them as in-process mapreduce with hadoop's local mode. If pig.auto.local.enabled flag is set to true, pig will convert mapreduce jobs with input data less than pig.auto.local.input.maxbytes (100MB by default) to run in local mode, provided the number of reducers required by the job are less than or equal to 1. Note, jobs converted to run in local mode load and store data from HDFS, so any job in the pig workflow(dag) could be converted to run in local mode without affecting its downstream jobs.</source>
          <target state="translated">在hadoop集群上处理小型mapreduce作业可能会很慢,因为它有作业启动和作业调度的开销。对于输入数据较小的作业,pig可以将它们转换为hadoop的本地模式下的进程内mapreduce运行。如果pig.auto.local.enabled标志设置为true,pig会将输入数据小于pig.auto.local.input.maxbytes(默认为100MB)的mapreduce作业转换为本地模式运行,前提是作业所需的reducer数量小于或等于1。需要注意的是,转换为本地模式运行的作业是从HDFS中加载和存储数据的,所以pig工作流(dag)中的任何作业都可以转换为本地模式运行,而不影响其下游作业。</target>
        </trans-unit>
        <trans-unit id="1d28a282560bb759052a3e6e6fcd13088d888408" translate="yes" xml:space="preserve">
          <source>Project Early and Often</source>
          <target state="translated">早期和经常项目</target>
        </trans-unit>
        <trans-unit id="9155c425ec77a3089191509a98c385937bbb07a9" translate="yes" xml:space="preserve">
          <source>Project-Range Expressions</source>
          <target state="translated">项目范围表达式</target>
        </trans-unit>
        <trans-unit id="549f47352730051b89a49356a5aa47d12e349987" translate="yes" xml:space="preserve">
          <source>Project-range ( .. ) expressions can be used to project a range of columns from input. For example:</source>
          <target state="translated">Project-range(...)表达式可以用来从输入中投影出一系列的列。例如</target>
        </trans-unit>
        <trans-unit id="badce2f5aad822deab06383975c71e3c2b6f9be2" translate="yes" xml:space="preserve">
          <source>Project-range can be used in all cases where the &lt;a href=&quot;#sexp&quot;&gt;star expression&lt;/a&gt; ( * ) is allowed.</source>
          <target state="translated">项目范围可用于所有允许使用&lt;a href=&quot;#sexp&quot;&gt;星号&lt;/a&gt;（*）的情况。</target>
        </trans-unit>
        <trans-unit id="5c69909c9dc93448f96162044d8b25b4d837f86e" translate="yes" xml:space="preserve">
          <source>Project-range can be used in the following statements: &lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt;, &lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt;, &lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt;, &lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt;, and &lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt; (also when ORDER BY is used within a nested FOREACH block).</source>
          <target state="translated">项目范围可以在以下语句中使用：&lt;a href=&quot;#foreach&quot;&gt;FOREACH&lt;/a&gt;，&lt;a href=&quot;#join-inner&quot;&gt;JOIN&lt;/a&gt;，&lt;a href=&quot;#group&quot;&gt;GROUP&lt;/a&gt;，&lt;a href=&quot;#cogroup&quot;&gt;COGROUP&lt;/a&gt;和&lt;a href=&quot;#order-by&quot;&gt;ORDER BY&lt;/a&gt;（同样在嵌套的FOREACH块中使用ORDER BY时）。</target>
        </trans-unit>
        <trans-unit id="fa33f39f5421ef81d13a830fb4443370104ee3c9" translate="yes" xml:space="preserve">
          <source>Projections (dimensions) of the relation. Supports field, star and project-range expressions.</source>
          <target state="translated">关系的投影(维度)。支持字段、星形和投影范围表达式。</target>
        </trans-unit>
        <trans-unit id="2ec840bd9176cde5b4141fc791989284f3e9ed0c" translate="yes" xml:space="preserve">
          <source>Prune the loader to only load necessary columns. The performance gain is more significant if the corresponding loader support column pruning and only load necessary columns (See LoadPushDown.pushProjection). Otherwise, ColumnMapKeyPrune will insert a ForEach statement right after loader.</source>
          <target state="translated">修剪装载机,只装载必要的列。如果相应的加载器支持列修剪,并且只加载必要的列,那么性能的提升会更加显著(参见LoadPushDown.pushProjection)。否则,ColumnMapKeyPrune会在加载器之后直接插入一个ForEach语句。</target>
        </trans-unit>
        <trans-unit id="c46a0e7afbefa23c27c29686d94920c8b40fe658" translate="yes" xml:space="preserve">
          <source>Prune unused column as soon as possible. In addition to prune the loader in ColumnMapKeyPrune, we can prune a column as soon as it is not used in the rest of the script</source>
          <target state="translated">尽快修剪未使用的列。除了在ColumnMapKeyPrune中对加载器进行修剪外,我们还可以在脚本的其余部分没有使用的时候尽快修剪一个列</target>
        </trans-unit>
        <trans-unit id="c7931337f31f75950cb4c2cdebc73bd2f84097cc" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader.</source>
          <target state="translated">将过滤条件推给装载机。</target>
        </trans-unit>
        <trans-unit id="fc4197eb949bc0da0a0aeedd23a8819a37dc696c" translate="yes" xml:space="preserve">
          <source>Push the filter condition to loader. Different than PartitionFilterOptimizer, the filter condition will be evaluated in Pig. In other words, the filter condition pushed to the loader is a hint. Loader might still load records which does not satisfy filter condition.</source>
          <target state="translated">将过滤条件推送给装载机。与PartitionFilterOptimizer不同,过滤条件将在Pig中进行评估。换句话说,推送给加载器的过滤条件只是一个提示。加载器仍然可能加载不满足过滤条件的记录。</target>
        </trans-unit>
        <trans-unit id="c6019407474c8f4cd672f2782447a068a3eff87a" translate="yes" xml:space="preserve">
          <source>PushDownForEachFlatten</source>
          <target state="translated">PushDownForEachFlatten</target>
        </trans-unit>
        <trans-unit id="00d23fd27f64adf999e795e338babf1919b5159b" translate="yes" xml:space="preserve">
          <source>PushUpFilter</source>
          <target state="translated">PushUpFilter</target>
        </trans-unit>
        <trans-unit id="9e91ff7fcaea97ed1e629c1ea1dd3a3be1f9a961" translate="yes" xml:space="preserve">
          <source>Queries that can take advantage of the combiner generally ran much faster (sometimes several times faster) than the versions that don't. The latest code significantly improves combiner usage; however, you need to make sure you do your part. If you have a UDF that works on grouped data and is, by nature, algebraic (meaning their computation can be decomposed into multiple steps) make sure you implement it as such. For details on how to write algebraic UDFs, see &lt;a href=&quot;udf#algebraic-interface&quot;&gt;Algebraic Interface&lt;/a&gt;.</source>
          <target state="translated">可以利用组合器的查询的运行速度通常比不使用组合器的查询快得多（有时快几倍）。最新的代码大大提高了合并器的使用率；但是，您需要确保自己发挥作用。如果您有一个UDF可以处理分组数据并且本质上是代数的（这意味着它们的计算可以分解为多个步骤），请确保按此方式实现。有关如何编写代数UDF的详细信息，请参见&lt;a href=&quot;udf#algebraic-interface&quot;&gt;代数接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7189bc7a153aae22c9ad9fbdd927084b0fc40f73" translate="yes" xml:space="preserve">
          <source>Quits from the Pig grunt shell.</source>
          <target state="translated">从猪格壳中退出。</target>
        </trans-unit>
        <trans-unit id="620db5d9320e96ee12d500dbe6be7488db8de087" translate="yes" xml:space="preserve">
          <source>RANDOM</source>
          <target state="translated">RANDOM</target>
        </trans-unit>
        <trans-unit id="9e3bfd1f2a524ee518de592cf7435459586a3d76" translate="yes" xml:space="preserve">
          <source>RANDOM( )</source>
          <target state="translated">RANDOM()</target>
        </trans-unit>
        <trans-unit id="9cc2229409ebf7a451b2509c23892c92fff169d6" translate="yes" xml:space="preserve">
          <source>RANK</source>
          <target state="translated">RANK</target>
        </trans-unit>
        <trans-unit id="94e87841c18078a6be5f0c47297fcf1078db118b" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT</source>
          <target state="translated">REGEX_EXTRACT</target>
        </trans-unit>
        <trans-unit id="25060cd6008a61bda5883baa15d7cfb4500fcb19" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT (string, regex, index)</source>
          <target state="translated">REGEX_EXTRACT (string,regex,index)</target>
        </trans-unit>
        <trans-unit id="0921fe22357a6d6189cafbbaccb9446992f7c4b5" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL</source>
          <target state="translated">REGEX_EXTRACT_ALL</target>
        </trans-unit>
        <trans-unit id="0b2e921ca3a52345dca73d874d8ecb7ca4ad0cc1" translate="yes" xml:space="preserve">
          <source>REGEX_EXTRACT_ALL (string, regex)</source>
          <target state="translated">REGEX_EXTRACT_ALL (string,regex)</target>
        </trans-unit>
        <trans-unit id="7aa14173b8000e15aca4adfdc3b1a5e0d8c44ef0" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH</source>
          <target state="translated">REGEX_SEARCH</target>
        </trans-unit>
        <trans-unit id="4c56880804c60faefafcbee89177e1727de2dff4" translate="yes" xml:space="preserve">
          <source>REGEX_SEARCH(string, 'regExp');</source>
          <target state="translated">REGEX_SEARCH(string,'regExp')。</target>
        </trans-unit>
        <trans-unit id="018678424b56c2120abb69e981ef3eec820e05dd" translate="yes" xml:space="preserve">
          <source>REGISTER (a jar/script)</source>
          <target state="translated">注册(jar/脚本)</target>
        </trans-unit>
        <trans-unit id="c28d820c6f95eb8bc2a1c939755c4308dae8a884" translate="yes" xml:space="preserve">
          <source>REGISTER (an artifact)</source>
          <target state="translated">注册表</target>
        </trans-unit>
        <trans-unit id="c2f18c3d25c024de2d314688e5568c2e2b885ce4" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://group:module:version?querystring</source>
          <target state="translated">注册 ivy://group:module:version?querystring</target>
        </trans-unit>
        <trans-unit id="3213ec58664edb7df53533dc66ffd9af231fd2cb" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?classifier=value</source>
          <target state="translated">注册 ivy://org:module:version?classifier=value</target>
        </trans-unit>
        <trans-unit id="298b74bfc4131cf922f0663bebad6b611ebc696d" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?exclude=org:mod,org:mod,...</source>
          <target state="translated">注册 ivy://org:module:version?exclude=org:mod,org:mod,...。</target>
        </trans-unit>
        <trans-unit id="f9f07df8a78db31fca096c05b31f0bcd7a3a50f7" translate="yes" xml:space="preserve">
          <source>REGISTER ivy://org:module:version?transitive=false</source>
          <target state="translated">注册 ivy://org:module:version?transitive=false</target>
        </trans-unit>
        <trans-unit id="523fb225d3a2759dc8655903d1bc6a8288ada1ba" translate="yes" xml:space="preserve">
          <source>REGISTER path;</source>
          <target state="translated">注册表路径。</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="e04cf56acc0c4981837a53b7ff1256bf0c0ff4fe" translate="yes" xml:space="preserve">
          <source>REPLACE(string, 'regExp', 'newChar');</source>
          <target state="translated">REPLACE(string,'regExp','newChar')。</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="7f78099ba5db4acf80827e5f3d1a83db2ae525ec" translate="yes" xml:space="preserve">
          <source>ROLLUP</source>
          <target state="translated">ROLLUP</target>
        </trans-unit>
        <trans-unit id="8580cec9b53e98ece67f310e025d4a349121f88a" translate="yes" xml:space="preserve">
          <source>ROUND</source>
          <target state="translated">ROUND</target>
        </trans-unit>
        <trans-unit id="cacfa70692e87c3321966a012a48ba58ce3bb591" translate="yes" xml:space="preserve">
          <source>ROUND(expression)</source>
          <target state="translated">ROUND(expression)</target>
        </trans-unit>
        <trans-unit id="c4c0b1ef3217efe1d9bf9b7d827e6ad059b864bd" translate="yes" xml:space="preserve">
          <source>ROUND(x)</source>
          <target state="translated">ROUND(x)</target>
        </trans-unit>
        <trans-unit id="0715c249cd668d5284678dca026287c3e463851a" translate="yes" xml:space="preserve">
          <source>ROUND_TO</source>
          <target state="translated">ROUND_TO</target>
        </trans-unit>
        <trans-unit id="9e50ef723b8064863d96f779d169424a37563aa0" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits [, mode])</source>
          <target state="translated">ROUND_TO(val,数字[,模式])</target>
        </trans-unit>
        <trans-unit id="8552829751a281e6ba49d05c41a939ede5eaafcb" translate="yes" xml:space="preserve">
          <source>ROUND_TO(val, digits)</source>
          <target state="translated">ROUND_TO(val,digits)</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="d0176c9b5630a9edca1e76d654fc1c435437c454" translate="yes" xml:space="preserve">
          <source>RTRIM(expression)</source>
          <target state="translated">RTRIM(expression)</target>
        </trans-unit>
        <trans-unit id="2a967919b023bdd7576620af97326ae9c9f3491d" translate="yes" xml:space="preserve">
          <source>Record Deliminters &amp;ndash; For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</source>
          <target state="translated">记录传递者&amp;ndash;​​对于装入语句，Pig将换行符（'\ n'），回车符（'\ r'或CTRL-M）和组合的CR + LF（'\ r \ n'）字符解释为记录定界符（不使用这些字符作为字段定界符）。对于商店对帐单，Pig使用换行（'\ n'）字符作为记录定界符。</target>
        </trans-unit>
        <trans-unit id="ef6b7434b39836c7b5476b127140cb9fc733f047" translate="yes" xml:space="preserve">
          <source>Reduce Your Operator Pipeline</source>
          <target state="translated">减少您的操作员管道</target>
        </trans-unit>
        <trans-unit id="a5b5c7ea81e2d801d5ee70f53f3a6c23d9a8c4e6" translate="yes" xml:space="preserve">
          <source>Reducer Estimation</source>
          <target state="translated">减速器估计</target>
        </trans-unit>
        <trans-unit id="62beeb3ebea5d1b6fbcca509b70d060344fdd22b" translate="yes" xml:space="preserve">
          <source>Refer to args positionally and as many times as you like using %(pos)$.... Use %&amp;lt;... to refer to the previously-specified arg.</source>
          <target state="translated">使用％（pos）$ ...在任意位置多次引用args。使用％&amp;lt;...引用先前指定的arg。</target>
        </trans-unit>
        <trans-unit id="4737d8da85fe53493025312e1f0d18e0867c487c" translate="yes" xml:space="preserve">
          <source>Referencing Fields</source>
          <target state="translated">参考领域</target>
        </trans-unit>
        <trans-unit id="4cae9bdf3920da7757a8c85f6b54d8738dd7967d" translate="yes" xml:space="preserve">
          <source>Referencing Fields that are Complex Data Types</source>
          <target state="translated">引用复杂数据类型的字段</target>
        </trans-unit>
        <trans-unit id="d23bb24e2f8bcaae71a9d10cc001c98353b1b509" translate="yes" xml:space="preserve">
          <source>Referencing Relations</source>
          <target state="translated">参考关系</target>
        </trans-unit>
        <trans-unit id="dc42ec7da7d0e19f1a5ed6e62ea29d2d256d89ad" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the included UDFs can be called in the script.</source>
          <target state="translated">注册教程JAR文件,以便在脚本中调用包含的UDFs。</target>
        </trans-unit>
        <trans-unit id="6692a10545ad9ae35c076d55ecf3df797aeb3ad4" translate="yes" xml:space="preserve">
          <source>Register the tutorial JAR file so that the user defined functions (UDFs) can be called in the script.</source>
          <target state="translated">注册教程JAR文件,以便在脚本中调用用户定义函数(UDF)。</target>
        </trans-unit>
        <trans-unit id="26c92f3731d6fecfb43c28c225f8c2bc30998abb" translate="yes" xml:space="preserve">
          <source>Registering an Artifact and all its dependencies.</source>
          <target state="translated">注册一个Artifact及其所有的依赖关系。</target>
        </trans-unit>
        <trans-unit id="dc29b2e11b3b43cda736fcba0bb6760a606e849e" translate="yes" xml:space="preserve">
          <source>Registering an artifact by excluding specific dependencies.</source>
          <target state="translated">通过排除特定的依赖关系来注册一个工件。</target>
        </trans-unit>
        <trans-unit id="5f4ed5bdc8024ad52459ee1a00ab28199dd38f89" translate="yes" xml:space="preserve">
          <source>Registering an artifact without a group or organization. Just skip them.</source>
          <target state="translated">在没有团体或组织的情况下注册文物。直接跳过它们。</target>
        </trans-unit>
        <trans-unit id="3d4a9d6f350eea88c38c96fd0c95e87ab7bbad29" translate="yes" xml:space="preserve">
          <source>Registering an artifact without getting its dependencies.</source>
          <target state="translated">在没有获得依赖关系的情况下注册一个工件。</target>
        </trans-unit>
        <trans-unit id="da1d3a98f791337ad0a4ec68eae079eb6ef95ae7" translate="yes" xml:space="preserve">
          <source>Registering the UDF</source>
          <target state="translated">注册UDF</target>
        </trans-unit>
        <trans-unit id="8a29de9c3832ce4b8e6b18747e5a829713fca18d" translate="yes" xml:space="preserve">
          <source>Registering the latest artifact.</source>
          <target state="translated">登记最新的文物。</target>
        </trans-unit>
        <trans-unit id="dd54c0c65bf4584f34e8a3942380ffcf0970fe76" translate="yes" xml:space="preserve">
          <source>Registers a JAR file so that the UDFs in the file can be used.</source>
          <target state="translated">注册一个JAR文件,这样就可以使用文件中的UDF。</target>
        </trans-unit>
        <trans-unit id="428be11df215f5cd15290e03edfab6e2024b704f" translate="yes" xml:space="preserve">
          <source>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</source>
          <target state="translated">关系X是这样的。为每个唯一的键字段创建一个元组。元组包括键字段和两个袋子。第一个袋子是来自第一个关系的与键字段匹配的元组。第二个袋子是来自第二个关系的与键字段匹配的元组。如果没有与关键字段匹配的元组,那么袋子是空的。</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">关系运算符</target>
        </trans-unit>
        <trans-unit id="ac6eb526c4d3427712a60a1a682dfb9f6e58dad9" translate="yes" xml:space="preserve">
          <source>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</source>
          <target state="translated">关系用名字(或别名)来称呼。名字由你指定,作为Pig Latin语句的一部分。在这个例子中,关系的名称(别名)是A。</target>
        </trans-unit>
        <trans-unit id="657fe9adf3cabd570b43f36ea037911276330628" translate="yes" xml:space="preserve">
          <source>Relations, Bags, Tuples, Fields</source>
          <target state="translated">关系、包、图元组、字段</target>
        </trans-unit>
        <trans-unit id="47f90b570611ed6b62f0263d679682900ef503e8" translate="yes" xml:space="preserve">
          <source>Remove the boiler plate code appearing when there is more than one test methods.</source>
          <target state="translated">去掉出现的锅炉板码,当有一种以上的测试方法时。</target>
        </trans-unit>
        <trans-unit id="f90556d367ec2b7b89d6cb1145ec2ab9a7d43795" translate="yes" xml:space="preserve">
          <source>Removes duplicate tuples in a relation.</source>
          <target state="translated">删除关系中重复的元组。</target>
        </trans-unit>
        <trans-unit id="d5aed14a2d8cc1e13aa0226552743bc08f973991" translate="yes" xml:space="preserve">
          <source>Removes the record if the query field is empty or a URL.</source>
          <target state="translated">如果查询字段为空或为URL,则删除该记录。</target>
        </trans-unit>
        <trans-unit id="01b967cc6fcf66fa1a327d6e23a3adcc183a7585" translate="yes" xml:space="preserve">
          <source>Replaces existing characters in a string with new characters.</source>
          <target state="translated">用新字符替换字符串中的现有字符。</target>
        </trans-unit>
        <trans-unit id="7c9f7314d870cf506926a81a725609a309180df7" translate="yes" xml:space="preserve">
          <source>Replicated Joins</source>
          <target state="translated">复制连接</target>
        </trans-unit>
        <trans-unit id="8e2d170ab822648a868ed17db41712a1e458ed56" translate="yes" xml:space="preserve">
          <source>Reporting Progress</source>
          <target state="translated">报告进展</target>
        </trans-unit>
        <trans-unit id="c3ab25ae5e2cc5df52b11a23cfbf50e86331bacb" translate="yes" xml:space="preserve">
          <source>Required keyword.</source>
          <target state="translated">所需关键词:</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="4fef845de7495dcd1565cda432d4b9908db6c9c9" translate="yes" xml:space="preserve">
          <source>Reserved Keywords</source>
          <target state="translated">保留关键词</target>
        </trans-unit>
        <trans-unit id="d486788d225653651eb6a74aed6bf2b553d1d42b" translate="yes" xml:space="preserve">
          <source>Return Types and Schemas</source>
          <target state="translated">返回类型和模式</target>
        </trans-unit>
        <trans-unit id="5d4dbb16b26776ff0a9681435fb191cc339ea164" translate="yes" xml:space="preserve">
          <source>Return code 0: All jobs succeeded</source>
          <target state="translated">返回代码0:所有工作成功</target>
        </trans-unit>
        <trans-unit id="dcf12244c4ffa52bf59195a2ed18fd4736d7b67b" translate="yes" xml:space="preserve">
          <source>Return code 1: &lt;em&gt;Used for retrievable errors&lt;/em&gt;</source>
          <target state="translated">返回码1：&lt;em&gt;用于可检索的错误&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0358e44b177069a82ad64649295be297b6b49ac" translate="yes" xml:space="preserve">
          <source>Return code 2: All jobs have failed</source>
          <target state="translated">返回代码2:所有工作都失败了</target>
        </trans-unit>
        <trans-unit id="1491195b66e37f39862ac3347539de9fd938e5ac" translate="yes" xml:space="preserve">
          <source>Return code 3: Some jobs have failed</source>
          <target state="translated">返回代码3:一些工作失败</target>
        </trans-unit>
        <trans-unit id="419dc24bbf3839e94617bca8e82b80dcf575f429" translate="yes" xml:space="preserve">
          <source>Returns Euler's number e raised to the power of x.</source>
          <target state="translated">返回欧拉数e升到x的幂。</target>
        </trans-unit>
        <trans-unit id="513587fb94f9ca8a02c2130dbf24ce9970499d45" translate="yes" xml:space="preserve">
          <source>Returns a DateTime object according to parameters.</source>
          <target state="translated">根据参数返回一个DateTime对象。</target>
        </trans-unit>
        <trans-unit id="36cf64f64f1683a1f6fd71ff4731efb70faacd64" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with leading and trailing white space removed.</source>
          <target state="translated">返回去掉前导和尾部空白的字符串的副本。</target>
        </trans-unit>
        <trans-unit id="881fb398d9c55cad7a537386644c3c3154142c43" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only leading white space removed.</source>
          <target state="translated">返回一个只去掉前导空格的字符串的副本。</target>
        </trans-unit>
        <trans-unit id="c7af3ae3ff3f406d011103cff7ba952d404e72e2" translate="yes" xml:space="preserve">
          <source>Returns a copy of a string with only trailing white space removed.</source>
          <target state="translated">返回一个只去掉尾部空格的字符串的副本。</target>
        </trans-unit>
        <trans-unit id="2fc98512d189e4d3f3c0cca8ae024088810e4bc5" translate="yes" xml:space="preserve">
          <source>Returns a pseudo random number.</source>
          <target state="translated">返回一个伪随机数。</target>
        </trans-unit>
        <trans-unit id="08d59bcf7e4da2d316cce1fe0f800acd9ca0e768" translate="yes" xml:space="preserve">
          <source>Returns a string converted to upper case.</source>
          <target state="translated">返回一个转换为大写的字符串。</target>
        </trans-unit>
        <trans-unit id="60bd6525d26a868296aef9ef39229cb4f21b553b" translate="yes" xml:space="preserve">
          <source>Returns a string with the first character converted to upper case.</source>
          <target state="translated">返回一个将第一个字符转换为大写的字符串。</target>
        </trans-unit>
        <trans-unit id="0a6ceee3abe688e26f32d11ad4e8bfa6056694d1" translate="yes" xml:space="preserve">
          <source>Returns a string, an int, a long, a double, or a float</source>
          <target state="translated">返回一个字符串、一个int、一个long、一个double或一个float。</target>
        </trans-unit>
        <trans-unit id="149929531961b59343eac086b94315964280e9c6" translate="yes" xml:space="preserve">
          <source>Returns a substring from a given string.</source>
          <target state="translated">从给定的字符串中返回一个子串。</target>
        </trans-unit>
        <trans-unit id="f650c7101aebe01253479ec3832aa36457dd38e0" translate="yes" xml:space="preserve">
          <source>Returns a unique id string for each record in the alias.</source>
          <target state="translated">返回别名中每个记录的唯一id字符串。</target>
        </trans-unit>
        <trans-unit id="1d2e7b7f3392f0d0a7f4edac2ffbf6e49ec75c21" translate="yes" xml:space="preserve">
          <source>Returns each tuple with the rank within a relation.</source>
          <target state="translated">返回关系中每个元组的等级。</target>
        </trans-unit>
        <trans-unit id="5de4cf3d0ef61696c28177da2c48a786b952ce4f" translate="yes" xml:space="preserve">
          <source>Returns from user defined functions (UDFs)</source>
          <target state="translated">从用户定义函数(UDF)中得到的回报</target>
        </trans-unit>
        <trans-unit id="22f2b5afc5bcb54987844be722ae41dd06fae1e6" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) if any single argument is null.</source>
          <target state="translated">如果任何一个参数为空,则返回null(无错误或警告)。</target>
        </trans-unit>
        <trans-unit id="a9d33c367a852dbfb596f52d5473ef9e15fc1757" translate="yes" xml:space="preserve">
          <source>Returns null (no error or warning) with a null format string.</source>
          <target state="translated">返回null(无错误或警告),格式字符串为空。</target>
        </trans-unit>
        <trans-unit id="69abd17980fc8fc326fac6f58dfef8a3d54c981e" translate="yes" xml:space="preserve">
          <source>Returns the DateTime object of the current time.</source>
          <target state="translated">返回当前时间的DateTime对象。</target>
        </trans-unit>
        <trans-unit id="37ef5243e85c9e64bfe6667ede2cdc7c7805da8c" translate="yes" xml:space="preserve">
          <source>Returns the Unix Time as long for a DateTime object. UnixTime is the number of seconds elapsed since January 1, 1970, 00:00:00.000 GMT.</source>
          <target state="translated">返回一个DateTime对象的Unix时间。UnixTime是自1970年1月1日00:00:00.000 GMT以来的秒数。</target>
        </trans-unit>
        <trans-unit id="e2205e5e3349d473a1aa00a87ddbbfaf4cef2bfb" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of an expression.</source>
          <target state="translated">返回一个表达式的绝对值。</target>
        </trans-unit>
        <trans-unit id="85b804678f1cf453ee531619aad616e9ee0444a6" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of an expression.</source>
          <target state="translated">返回一个表达式的弧余弦值。</target>
        </trans-unit>
        <trans-unit id="e39a89b4ea91acef8e89dd0bab73bd8c9003ffe3" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of an expression.</source>
          <target state="translated">Returns the arc sine of an expression.</target>
        </trans-unit>
        <trans-unit id="ed3aecce972de660c52bf3943dca60cdc02e893a" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of an expression.</source>
          <target state="translated">返回一个表达式的弧切值。</target>
        </trans-unit>
        <trans-unit id="11d674b8dd60cc025724efb8108982d963bec977" translate="yes" xml:space="preserve">
          <source>Returns the base 10 logarithm of an expression.</source>
          <target state="translated">返回一个表达式的10基对数。</target>
        </trans-unit>
        <trans-unit id="6204881bdacb24f052b8f2ce9e963bcd536065ea" translate="yes" xml:space="preserve">
          <source>Returns the cube root of an expression.</source>
          <target state="translated">返回一个表达式的立方根。</target>
        </trans-unit>
        <trans-unit id="b91499640701da81cac5582f0880c4af26e4863c" translate="yes" xml:space="preserve">
          <source>Returns the day of a month from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回某月的某一天。</target>
        </trans-unit>
        <trans-unit id="046718c428dc7dd4d4c49d04ec41ba4ec46e1f95" translate="yes" xml:space="preserve">
          <source>Returns the hour of a day from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回一天的时间。</target>
        </trans-unit>
        <trans-unit id="e9e27533f3b351679e918b0146c940f249292548" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic cosine of an expression.</source>
          <target state="translated">返回一个表达式的双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="41ba86c915c553776146f87efe83c29cb5788f94" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic sine of an expression.</source>
          <target state="translated">返回一个表达式的双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="29c1b5b8c50562788b9f9d48e7847459fbd66840" translate="yes" xml:space="preserve">
          <source>Returns the hyperbolic tangent of an expression.</source>
          <target state="translated">返回一个表达式的双曲正切值。</target>
        </trans-unit>
        <trans-unit id="4ba0b6ea8572bf47f2c36352a0d682f2633e3113" translate="yes" xml:space="preserve">
          <source>Returns the index of the first occurrence of a character in a string, searching forward from a start index.</source>
          <target state="translated">返回字符串中首次出现的字符的索引,从起始索引向前搜索。</target>
        </trans-unit>
        <trans-unit id="b507a1b60d4ec92ab20324dabd54b2a53b040481" translate="yes" xml:space="preserve">
          <source>Returns the index of the last occurrence of a character in a string, searching backward from the end of the string.</source>
          <target state="translated">返回字符串中最后出现的字符的索引,从字符串的末尾向后搜索。</target>
        </trans-unit>
        <trans-unit id="1cb694fbca257bfbfaa8a2e38404b491899885aa" translate="yes" xml:space="preserve">
          <source>Returns the millisecond of a second from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回秒的毫秒。</target>
        </trans-unit>
        <trans-unit id="38e5458a5bbfe1c1e08c75b6ab2b15f6d398a004" translate="yes" xml:space="preserve">
          <source>Returns the minute of a hour from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回一个小时的分钟。</target>
        </trans-unit>
        <trans-unit id="1b592cc480e5ac16c4831e12d57d73c66abb6b01" translate="yes" xml:space="preserve">
          <source>Returns the month of a year from a DateTime object.</source>
          <target state="translated">从DateTime对象返回一年中的月份。</target>
        </trans-unit>
        <trans-unit id="48a6c81ffdf6d2cf4cf5ac04a474905115f8080f" translate="yes" xml:space="preserve">
          <source>Returns the natural logarithm (base e) of an expression.</source>
          <target state="translated">返回一个表达式的自然对数(基数e)。</target>
        </trans-unit>
        <trans-unit id="12c23b2ca17df96650ee9ee563cc87b5e17096da" translate="yes" xml:space="preserve">
          <source>Returns the number of days between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的天数。</target>
        </trans-unit>
        <trans-unit id="e807d5135f00cb9c11e91294361fc38911f84ce8" translate="yes" xml:space="preserve">
          <source>Returns the number of hours between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的小时数。</target>
        </trans-unit>
        <trans-unit id="29fdd2cb901cf9d6cedf200b96a4083351a2cbef" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的毫秒数。</target>
        </trans-unit>
        <trans-unit id="454ce2c667f43fe5c79bf50c7bd8507796c70a8a" translate="yes" xml:space="preserve">
          <source>Returns the number of milliseconds elapsed since January 1, 1970, 00:00:00.000 GMT for a DateTime object.</source>
          <target state="translated">返回一个DateTime对象自1970年1月1日00:00:00.000 GMT以来的毫秒数。</target>
        </trans-unit>
        <trans-unit id="121e43fe18bf40c290d3191cfc7659d7eb7c5f0a" translate="yes" xml:space="preserve">
          <source>Returns the number of minutes between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的分钟数。</target>
        </trans-unit>
        <trans-unit id="8f78df41df2f2e976bbae604765220c5169483d0" translate="yes" xml:space="preserve">
          <source>Returns the number of months between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的月数。</target>
        </trans-unit>
        <trans-unit id="7fd3b014ec0a7ff566e268eee49fccc5fe1a7e48" translate="yes" xml:space="preserve">
          <source>Returns the number of seconds between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的秒数。</target>
        </trans-unit>
        <trans-unit id="cb227e6e9a62373e0c416d76c20a65d7d2dfeb0a" translate="yes" xml:space="preserve">
          <source>Returns the number of weeks between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的周数。</target>
        </trans-unit>
        <trans-unit id="223d8b607ac03fc9f2f03460164780e62eb5f639" translate="yes" xml:space="preserve">
          <source>Returns the number of years between two DateTime objects.</source>
          <target state="translated">返回两个DateTime对象之间的年数。</target>
        </trans-unit>
        <trans-unit id="52badd610226f06179fe93b678ec80a1a5fd11d0" translate="yes" xml:space="preserve">
          <source>Returns the positive square root of an expression.</source>
          <target state="translated">返回一个表达式的正平方根。</target>
        </trans-unit>
        <trans-unit id="8616431c76cac4a8057fb11c41e0a7fb048ca004" translate="yes" xml:space="preserve">
          <source>Returns the remainder of a divided by b (a%b).</source>
          <target state="translated">返回a除以b的余数(a%b)。</target>
        </trans-unit>
        <trans-unit id="9f34c6241173dbb432200f51aab86ac7ba22ce94" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object minus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="translated">返回DateTime对象的结果减去&lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration对象的结果&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e5f4ea42054712389ba9d161a9241dc2d2bed6b" translate="yes" xml:space="preserve">
          <source>Returns the result of a DateTime object plus a &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration object&lt;/a&gt;.</source>
          <target state="translated">返回DateTime对象加上&lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;Duration对象的结果&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a14b74942cf37d4ce87b5279887777ffece87cb2" translate="yes" xml:space="preserve">
          <source>Returns the schema of a relation.</source>
          <target state="translated">返回一个关系的模式。</target>
        </trans-unit>
        <trans-unit id="7604d46e673c7c005c76a6bb8363f23077180df5" translate="yes" xml:space="preserve">
          <source>Returns the second of a minute from a DateTime object.</source>
          <target state="translated">返回DateTime对象的秒数。</target>
        </trans-unit>
        <trans-unit id="c9900dd72cfc78443973c5927397ba417d993936" translate="yes" xml:space="preserve">
          <source>Returns the sine of an expression.</source>
          <target state="translated">返回一个表达式的正弦值。</target>
        </trans-unit>
        <trans-unit id="afb424818b35ef253e9f9b4a24ce670200b714b6" translate="yes" xml:space="preserve">
          <source>Returns the top-n tuples from a bag of tuples.</source>
          <target state="translated">从一袋元组中返回top-n元组。</target>
        </trans-unit>
        <trans-unit id="429dc3c96810cd8514fb775c6cad21f062815f57" translate="yes" xml:space="preserve">
          <source>Returns the trignometric tangent of an angle.</source>
          <target state="translated">返回一个角的三棱镜正切值。</target>
        </trans-unit>
        <trans-unit id="439e6280c2aec77be8bdbea9ad7666662569a20a" translate="yes" xml:space="preserve">
          <source>Returns the trigonometric cosine of an expression.</source>
          <target state="translated">返回一个表达式的三角余弦值。</target>
        </trans-unit>
        <trans-unit id="ba4f750d033224c623421cf67f35d53975b95e79" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded down to the nearest integer.</source>
          <target state="translated">返回一个表达式的值,将其四舍五入到最接近的整数。</target>
        </trans-unit>
        <trans-unit id="3231b2172ae518d230e21f3d1aaf0c9d68054c6c" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to a fixed number of decimal digits.</source>
          <target state="translated">返回一个表达式的值,四舍五入到一个固定的小数位。</target>
        </trans-unit>
        <trans-unit id="732dc5476d1cc4d243ec593b786a34517d6cbbaa" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded to an integer.</source>
          <target state="translated">返回一个表达式的值,四舍五入为一个整数。</target>
        </trans-unit>
        <trans-unit id="c7f0f91270d33bf1639a9d2e64d27739473916df" translate="yes" xml:space="preserve">
          <source>Returns the value of an expression rounded up to the nearest integer.</source>
          <target state="translated">返回一个表达式的值,将其四舍五入到最接近的整数。</target>
        </trans-unit>
        <trans-unit id="0214274502e7a06d319f46f09e8cd90ba878642c" translate="yes" xml:space="preserve">
          <source>Returns the week of a week year from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回一周年的星期。</target>
        </trans-unit>
        <trans-unit id="06c0ada39ef7630382e9d8499fc52074d7bb307d" translate="yes" xml:space="preserve">
          <source>Returns the week year from a DateTime object.</source>
          <target state="translated">从DateTime对象中返回星期年。</target>
        </trans-unit>
        <trans-unit id="d6e941db4f0d8d0912857032d9ad159b271b32cc" translate="yes" xml:space="preserve">
          <source>Returns the year from a DateTime object.</source>
          <target state="translated">返回DateTime对象的年份。</target>
        </trans-unit>
        <trans-unit id="5764aae9ab18ee498e93f36852feed2c93bdc9fc" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-hadoop-results or script2-hadoop-results HDFS directory:</source>
          <target state="translated">查看结果文件,位于 script1-hadoopresults 或 script2-hadoopresults HDFS 目录下。</target>
        </trans-unit>
        <trans-unit id="87c76b6e92d7e26b17fa88c6d0f6bf26b951de10" translate="yes" xml:space="preserve">
          <source>Review the result files, located in the script1-local-results.txt directory.</source>
          <target state="translated">查看结果文件,位于script1-localresults.txt目录下。</target>
        </trans-unit>
        <trans-unit id="012599a8c6f241f3c89808b0514daa3a79a4c971" translate="yes" xml:space="preserve">
          <source>Right outer join.</source>
          <target state="translated">右外侧连接。</target>
        </trans-unit>
        <trans-unit id="7469e8632182ae0e8d493ab42d0b639213cfaf09" translate="yes" xml:space="preserve">
          <source>Rollup operation</source>
          <target state="translated">滚动操作</target>
        </trans-unit>
        <trans-unit id="18b5daa46c0d001f3238ed5f9ad432b325e08c58" translate="yes" xml:space="preserve">
          <source>Rollup operations computes multiple levels of aggregates based on hierarchical ordering of specified group by dimensions. Rollup is useful when there is hierarchical ordering on the dimensions. The number of group by combinations generated by rollup for n dimensions will be n+1.</source>
          <target state="translated">卷积操作根据指定的维度组的分级排序计算多级汇总。当在维度上有分级排序时,rollup很有用。对于n个维度,通过滚动操作产生的分组组合数将是n+1。</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
