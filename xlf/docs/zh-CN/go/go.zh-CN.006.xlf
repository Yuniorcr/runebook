<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="go">
    <body>
      <group id="go">
        <trans-unit id="e63a57b040488970eacecfd2272a9deb62e2be3e" translate="yes" xml:space="preserve">
          <source>It returns an error if the receiver is not an exported type or has no suitable methods. It also logs the error using package log. The client accesses each method using a string of the form &quot;Type.Method&quot;, where Type is the receiver's concrete type.</source>
          <target state="translated">如果接收器不是导出的类型或者没有合适的方法,它将返回一个错误。它还使用包日志记录错误。客户端使用 &quot;Type.Method &quot;形式的字符串访问每个方法,其中Type是接收器的具体类型。</target>
        </trans-unit>
        <trans-unit id="4dde580c3be3f14ce5fe15d368688767eafb64f5" translate="yes" xml:space="preserve">
          <source>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address 192.0.2.1 and the network 192.0.2.0/24.</source>
          <target state="translated">它返回IP地址和IP及前缀长度所隐含的网络。例如,ParseCIDR(&quot;192.0.2.1/24&quot;)返回IP地址192.0.2.1和网络192.0.2.0/24。</target>
        </trans-unit>
        <trans-unit id="0b053a1afdc2a3fb959c27dc82bd3e04e4d3478f" translate="yes" xml:space="preserve">
          <source>It sets only the Path and Args in the returned structure.</source>
          <target state="translated">它只在返回的结构中设置路径和Args。</target>
        </trans-unit>
        <trans-unit id="810599e9d82ed867f48c9be47863d26eaa5d33f3" translate="yes" xml:space="preserve">
          <source>It sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form:</source>
          <target state="translated">它将z设置为相应浮点值的(可能是四舍五入)值,并返回z、实际的基数b和错误err(如果有)。整个字符串(不仅仅是前缀)必须被消耗才能成功。如果z的精度为0,则在四舍五入生效之前将其改为64。数字必须是这样的形式。</target>
        </trans-unit>
        <trans-unit id="4b0e67dd55e6df4a3c7132865324312cab9fb6a8" translate="yes" xml:space="preserve">
          <source>It should not be used for recursive read locking; a blocked Lock call excludes new readers from acquiring the lock. See the documentation on the RWMutex type.</source>
          <target state="translated">它不应被用于递归读取锁定;被阻止的Lock调用排除了新的读者获取锁。参见RWMutex类型的文档。</target>
        </trans-unit>
        <trans-unit id="ff62c59d333b6b7669c7f0b6568819a5dff0f396" translate="yes" xml:space="preserve">
          <source>Iterate calls f for the files in the file set in the order they were added until f returns false.</source>
          <target state="translated">迭代调用f,按照文件集中的文件添加顺序,直到f返回false。</target>
        </trans-unit>
        <trans-unit id="380c384a3bc4560682612879309496ebdde5cfd3" translate="yes" xml:space="preserve">
          <source>Itoa</source>
          <target state="translated">Itoa</target>
        </trans-unit>
        <trans-unit id="aac52064292950f4b3f0337ac6b1ebbc54bd40af" translate="yes" xml:space="preserve">
          <source>Itoa is equivalent to FormatInt(int64(i), 10).</source>
          <target state="translated">Itoa相当于FormatInt(int64(i),10)。</target>
        </trans-unit>
        <trans-unit id="2d1e23b725be8aad6b338015ecefbc3479bf797c" translate="yes" xml:space="preserve">
          <source>J0 returns the order-zero Bessel function of the first kind.</source>
          <target state="translated">J0返回第一种的零阶贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="9b402d642da0f20c362bc1bcf6bfd3cb9482a1ee" translate="yes" xml:space="preserve">
          <source>J1 returns the order-one Bessel function of the first kind.</source>
          <target state="translated">J1返回第一种类型的阶一贝塞尔函数。</target>
        </trans-unit>
        <trans-unit id="0a183d189787e52c86d1ff01f1f68fc26c61737d" translate="yes" xml:space="preserve">
          <source>JPEG is defined in ITU-T T.81: &lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&lt;/a&gt;.</source>
          <target state="translated">JPEG在ITU-T T.81：&lt;a href=&quot;https://www.w3.org/Graphics/JPEG/itu-t81.pdf&quot;&gt;https&lt;/a&gt;：//www.w3.org/Graphics/JPEG/itu-t81.pdf中定义。</target>
        </trans-unit>
        <trans-unit id="bd49e7822aebcb558798ee4f0f590d63e8da7cc1" translate="yes" xml:space="preserve">
          <source>JPEG, VP8, the MPEG family and other codecs use this color model. Such codecs often use the terms YUV and Y'CbCr interchangeably, but strictly speaking, the term YUV applies only to analog video signals, and Y' (luma) is Y (luminance) after applying gamma correction.</source>
          <target state="translated">JPEG、VP8、MPEG系列和其他编解码器都使用这种颜色模型。这类编解码器经常互换使用YUV和Y'CbCr这两个术语,但严格来说,YUV这个术语只适用于模拟视频信号,而Y'(luma)是应用伽玛校正后的Y(亮度)。</target>
        </trans-unit>
        <trans-unit id="922b9fe605d8db0c621e15bc38a3c570a5ce91fd" translate="yes" xml:space="preserve">
          <source>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like &quot;{ foo: bar() }\n['foo']()&quot;, which is both a valid Expression and a valid Program with a very different meaning.</source>
          <target state="translated">JS封装了一个已知的安全的EcmaScript5表达式,例如`(x+y*z())`。模板作者有责任确保类型化的表达式不会破坏预期的优先级,也不会出现声明/表达式的歧义,比如传递&quot;{foo:bar()}\n['foo']()&quot;这样的表达式,它既是一个有效的表达式,也是一个有效的程序,但意义却截然不同。</target>
        </trans-unit>
        <trans-unit id="26cbdc0eb97f168871a53f6c7842d5c136b64697" translate="yes" xml:space="preserve">
          <source>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.</source>
          <target state="translated">JSEscape将明文数据b的转义JavaScript等价物写入w。</target>
        </trans-unit>
        <trans-unit id="bd3faa1039cdd3fc555ce394120927a3ffbfdfd6" translate="yes" xml:space="preserve">
          <source>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.</source>
          <target state="translated">JSEscapeString返回纯文本数据s的转义JavaScript等价物。</target>
        </trans-unit>
        <trans-unit id="0657ce896f15a5407782a5a0cb9e814dbb9243d9" translate="yes" xml:space="preserve">
          <source>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.</source>
          <target state="translated">JSEscaper返回其参数的文本表示的转义JavaScript等价物。</target>
        </trans-unit>
        <trans-unit id="69a10a5b123daa69a949ffea8479901f451d66ee" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd554b8109b0533f9a7bb62634a7c4956ea4b3a" translate="yes" xml:space="preserve">
          <source>JSON cannot represent cyclic data structures and Marshal does not handle them. Passing cyclic structures to Marshal will result in an infinite recursion.</source>
          <target state="translated">JSON不能表示循环数据结构,Marshal不能处理它们。将循环结构传递给Marshal会导致无限递归。</target>
        </trans-unit>
        <trans-unit id="16c95a3afe47aa9594cf8938af617a9901298497" translate="yes" xml:space="preserve">
          <source>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:</source>
          <target state="translated">JSStr封装了一个旨在嵌入到JavaScript表达式中引号之间的字符序列。该字符串必须与一系列StringCharacters匹配。</target>
        </trans-unit>
        <trans-unit id="7ee415a9e606531fbf364133b0de844b1078510a" translate="yes" xml:space="preserve">
          <source>JSValue implements Wrapper interface.</source>
          <target state="translated">JSValue实现了Wrapper接口。</target>
        </trans-unit>
        <trans-unit id="b800dfb6df40a19873f9dc7ec5927a93b2cfe769" translate="yes" xml:space="preserve">
          <source>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.</source>
          <target state="translated">Jacobi返回Jacobi符号(x/y),可以是+1,-1,或0,y参数必须是奇数。</target>
        </trans-unit>
        <trans-unit id="173acb21066734464813cc933e35bf49fb5074d7" translate="yes" xml:space="preserve">
          <source>Jar implements the http.CookieJar interface from the net/http package.</source>
          <target state="translated">Jar实现了net/http包中的http.CookieJar接口。</target>
        </trans-unit>
        <trans-unit id="0a5f33ea0d4d273fa523aad519e0bd5003a1f2a2" translate="yes" xml:space="preserve">
          <source>Jn returns the order-n Bessel function of the first kind.</source>
          <target state="translated">Jn 返回第一种的阶-n Bessel 函数。</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="b160ff3535de402a5c7113020ea1b5b48c93aaa3" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="translated">Join将a中的元素连接起来,创建一个单一的字符串。分隔符sep被放置在字符串中的元素之间。</target>
        </trans-unit>
        <trans-unit id="eb1bffc0eefb099fa476568b7bfaeb338665eac0" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of its first argument to create a single string. The separator string sep is placed between elements in the resulting string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6badcc1917f6227c17c3b5a3bb3a7ab0dac561dd" translate="yes" xml:space="preserve">
          <source>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.</source>
          <target state="translated">Join将s的元素连接起来,创建一个新的字节分片。分隔符sep被放置在生成的分片中的元素之间。</target>
        </trans-unit>
        <trans-unit id="aa67e6029ba49c3f992d57c2d0ab202a04ec1080" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.</source>
          <target state="translated">Join将任意数量的路径元素连接成一个单一的路径,必要时添加一个Separator。Join会对结果进行Clean处理,特别是会忽略所有空字符串。在Windows下,只有当第一个路径元素是UNC路径时,结果才是UNC路径。</target>
        </trans-unit>
        <trans-unit id="945c23e567973c47ce3562fa8cf5ef5f3d5533ea" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.</source>
          <target state="translated">Join将任意数量的路径元素连接成一个单一的路径,必要时添加一个分隔线。结果是Cleaned,特别是所有空字符串都会被忽略。</target>
        </trans-unit>
        <trans-unit id="a3a49c8f80c8e5d91256710add83dcb9a3a81e62" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with an OS specific Separator. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string. On Windows, the result will only be a UNC path if the first non-empty element is a UNC path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2d5664268a2d39abd731e2e8cd12f3a113ecce" translate="yes" xml:space="preserve">
          <source>Join joins any number of path elements into a single path, separating them with slashes. Empty elements are ignored. The result is Cleaned. However, if the argument list is empty or all its elements are empty, Join returns an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f25f02ad0ad7ded23a0d09d8ea462e385b6164c" translate="yes" xml:space="preserve">
          <source>JoinHostPort combines host and port into a network address of the form &quot;host:port&quot;. If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.</source>
          <target state="translated">JoinHostPort 将主机和端口结合成一个 &quot;host:port &quot;形式的网络地址。如果host包含一个冒号,就像在IPv6地址中发现的那样,那么JoinHostPort返回&quot;[host]:port&quot;。</target>
        </trans-unit>
        <trans-unit id="0cf4b24840f4e27435d8326ea5a70f3fed6a3f6e" translate="yes" xml:space="preserve">
          <source>KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.</source>
          <target state="translated">KeepAlive把它的参数标记为当前可达。这确保了在程序中调用KeepAlive之前,对象不会被释放,它的终结器也不会被运行。</target>
        </trans-unit>
        <trans-unit id="4901b1829f2829b984a0de81f7472f13edad3727" translate="yes" xml:space="preserve">
          <source>Key returns the key of the iterator's current map entry.</source>
          <target state="translated">Key 返回迭代器当前地图条目的key。</target>
        </trans-unit>
        <trans-unit id="91d7c5c0cb63de8145a0cccf24bc8d2f799ffa8e" translate="yes" xml:space="preserve">
          <source>Key returns the key type of map m.</source>
          <target state="translated">Key返回地图m的键类型。</target>
        </trans-unit>
        <trans-unit id="376426fe335e339ad2d0569150ad1299f858528e" translate="yes" xml:space="preserve">
          <source>KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.</source>
          <target state="translated">KeyUsage 表示对给定密钥有效的操作集。它是KeyUsage*常量的位图。</target>
        </trans-unit>
        <trans-unit id="096044ddbad86155a76b804e09110be8b259d0c6" translate="yes" xml:space="preserve">
          <source>KeyValue represents a single entry in a Map.</source>
          <target state="translated">KeyValue代表地图中的一个条目。</target>
        </trans-unit>
        <trans-unit id="054ac770f511da2fe690104026b09ee1f229a5cb" translate="yes" xml:space="preserve">
          <source>Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.</source>
          <target state="translated">Kill 导致进程立即退出。Kill不会等到进程实际退出。这只杀死进程本身,不杀死它可能已经启动的任何其他进程。</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="2f96efc28c6a98b35f43fa160b16237570ef8889" translate="yes" xml:space="preserve">
          <source>Kind returns the kind of basic type b.</source>
          <target state="translated">Kind返回基本类型b的种类。</target>
        </trans-unit>
        <trans-unit id="1333bd1a9ccf64ac482cd7154071753a44d2a74b" translate="yes" xml:space="preserve">
          <source>Kind returns the selection kind.</source>
          <target state="translated">Kind返回选择的种类。</target>
        </trans-unit>
        <trans-unit id="c33cadf6bcbf16450240b63ecfd3a8a6cf556ed6" translate="yes" xml:space="preserve">
          <source>Kind returns the tag representing the kind of value this is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c89bd23580c2ae3925d134637371987fedb05e1" translate="yes" xml:space="preserve">
          <source>Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.</source>
          <target state="translated">Kind返回v的Kind。如果v是零值(IsValid返回false),Kind返回Invalid。</target>
        </trans-unit>
        <trans-unit id="069ade3ad94bb7d5e1d27e83fcea3337da44893d" translate="yes" xml:space="preserve">
          <source>Kind specifies the kind of value represented by a Value.</source>
          <target state="translated">Kind指定Value所代表的值的种类。</target>
        </trans-unit>
        <trans-unit id="4774d947be420886f05bc80b8d7b99a878f5521e" translate="yes" xml:space="preserve">
          <source>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only), &quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot; (IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">已知的网络有 &quot;tcp&quot;、&quot;tcp4&quot;(仅限IPv4)、&quot;tcp6&quot;(仅限IPv6)、&quot;udp&quot;、&quot;udp4&quot;(仅限IPv4)、&quot;udp6&quot;(仅限IPv6)、&quot;ip&quot;、&quot;ip4&quot;(仅限IPv4)、&quot;ip6&quot;(仅限IPv6)、&quot;unix&quot;、&quot;unixgram &quot;和 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="b8b88dd6dbbf9262e1174af16ab3d22e577d2db5" translate="yes" xml:space="preserve">
          <source>Known options:</source>
          <target state="translated">已知选项:</target>
        </trans-unit>
        <trans-unit id="14eee53dd9c3bca9efa386f9ef53c298322ea056" translate="yes" xml:space="preserve">
          <source>Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.</source>
          <target state="translated">Label 返回ctx上带有给定键的标签的值,以及一个表示该标签是否存在的布尔值。</target>
        </trans-unit>
        <trans-unit id="17f6783a9c705de835debb13cac8a07e2f5a8b94" translate="yes" xml:space="preserve">
          <source>LabelSet is a set of labels.</source>
          <target state="translated">LabelSet是一组标签。</target>
        </trans-unit>
        <trans-unit id="bd752eb91afd54f78c7060bac232ea7dd334932f" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only CPU profile utilizes labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="translated">标签采用偶数个表示键值对的字符串，并创建一个包含它们的LabelSet。标签会使用相同的密钥覆盖先前的标签。当前，只有CPU配置文件使用标签信息。有关详细信息，请参见&lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b4c0dd78376377f6719d381d9475b9c65e91949" translate="yes" xml:space="preserve">
          <source>Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key. Currently only the CPU and goroutine profiles utilize any labels information. See &lt;a href=&quot;https://golang.org/issue/23458&quot;&gt;https://golang.org/issue/23458&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80c2e659a9bc68c02557be9a6c755aeed779cd0" translate="yes" xml:space="preserve">
          <source>LastIndex</source>
          <target state="translated">LastIndex</target>
        </trans-unit>
        <trans-unit id="c2daa604f07bcb24a260e4fea3217009758689c4" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</source>
          <target state="translated">LastIndex 返回 s 中 sep 的最后一个实例的索引,如果 sep 在 s 中不存在,则返回-1。</target>
        </trans-unit>
        <trans-unit id="b07643ffeaf5942b3f11986d945cbd1ca4dc0db5" translate="yes" xml:space="preserve">
          <source>LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.</source>
          <target state="translated">LastIndex 返回 s 中 substr 的最后一个实例的索引,如果 s 中没有 substr,则返回-1。</target>
        </trans-unit>
        <trans-unit id="a55ae6e0d05b49527c27558955cfb6017a5cb79e" translate="yes" xml:space="preserve">
          <source>LastIndexAny</source>
          <target state="translated">LastIndexAny</target>
        </trans-unit>
        <trans-unit id="c468ec7af80d497e073da5281108fc969df48a62" translate="yes" xml:space="preserve">
          <source>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.</source>
          <target state="translated">LastIndexAny将s解释为一个UTF-8编码的Unicode码点序列。它返回在s中最后出现的任何Unicode码点在chars中的字节索引。如果chars为空或者没有共同的码点,它返回-1。</target>
        </trans-unit>
        <trans-unit id="f35ff2cbc15f8519c2de1c522556210dbec6f0d9" translate="yes" xml:space="preserve">
          <source>LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.</source>
          <target state="translated">LastIndexAny返回s中任何来自chars的Unicode码点的最后一个实例的索引,如果s中没有来自chars的Unicode码点,则返回-1。</target>
        </trans-unit>
        <trans-unit id="e5af45bb29df606a6ad9f71c5f8ffe801cf806e3" translate="yes" xml:space="preserve">
          <source>LastIndexByte</source>
          <target state="translated">LastIndexByte</target>
        </trans-unit>
        <trans-unit id="715ec7346f22f455ae3b4f77928429d6e6ea2e7d" translate="yes" xml:space="preserve">
          <source>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</source>
          <target state="translated">LastIndexByte返回s中c的最后一个实例的索引,如果s中没有c,则返回-1。</target>
        </trans-unit>
        <trans-unit id="0052a6c35642a0a5651d0e514c35ebcc1b001ad3" translate="yes" xml:space="preserve">
          <source>LastIndexFunc</source>
          <target state="translated">LastIndexFunc</target>
        </trans-unit>
        <trans-unit id="e9e6d245d6f60be69d3deb822ef844937727defc" translate="yes" xml:space="preserve">
          <source>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc 将 s 解释为一个 UTF-8 编码的码点序列。它返回s中最后一个满足f(c)的Unicode码点的字节索引,如果没有,则返回-1。</target>
        </trans-unit>
        <trans-unit id="573828a944fe303002f7c0336cac457a4d45085f" translate="yes" xml:space="preserve">
          <source>LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.</source>
          <target state="translated">LastIndexFunc 返回最后一个满足 f(c)的 Unicode 码点在 s 中的索引,如果没有,则返回 -1。</target>
        </trans-unit>
        <trans-unit id="cdb76fffe46f91856747d3f589e0a3ea42a00f8c" translate="yes" xml:space="preserve">
          <source>Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lchown 改变了命名文件的数字 uid 和 gid。如果文件是一个符号链接,则改变链接本身的 uid 和 gid。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="9f1275e6821f8a51315e2ca81450b41140587c42" translate="yes" xml:space="preserve">
          <source>Ldexp is the inverse of Frexp. It returns frac &amp;times; 2**exp.</source>
          <target state="translated">Ldexp与Frexp相反。它返回frac&amp;times;2 ** exp。</target>
        </trans-unit>
        <trans-unit id="0bfbea9fa1b1bd75227de20412ea5faba23da169" translate="yes" xml:space="preserve">
          <source>LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.</source>
          <target state="translated">LeadingZeros 返回 x 中的前导零位数;对于 x ==0,结果是 UintSize。</target>
        </trans-unit>
        <trans-unit id="e3dbef4bbdf5cce299ff063f0c95032879c3da58" translate="yes" xml:space="preserve">
          <source>LeadingZeros16</source>
          <target state="translated">LeadingZeros16</target>
        </trans-unit>
        <trans-unit id="44f8376c5ec759270046aff7d8e5b19117ded5c1" translate="yes" xml:space="preserve">
          <source>LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.</source>
          <target state="translated">LeadingZeros16返回x中的前导零位数;对于x==0,结果是16。</target>
        </trans-unit>
        <trans-unit id="e9ed6b4c7187930afe2c50c883fcac4812515684" translate="yes" xml:space="preserve">
          <source>LeadingZeros32</source>
          <target state="translated">LeadingZeros32</target>
        </trans-unit>
        <trans-unit id="d0f408a69a9bfc0c9d5428df849a3e3f9c88b61c" translate="yes" xml:space="preserve">
          <source>LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.</source>
          <target state="translated">LeadingZeros32返回x中的前导零位数;对于x==0,结果是32。</target>
        </trans-unit>
        <trans-unit id="f987ddc8abdaac6d127e5eafa8b11404f85e5b1a" translate="yes" xml:space="preserve">
          <source>LeadingZeros64</source>
          <target state="translated">LeadingZeros64</target>
        </trans-unit>
        <trans-unit id="fda83273480c3e8d70a28c2f123cbf299bd51fd9" translate="yes" xml:space="preserve">
          <source>LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.</source>
          <target state="translated">LeadingZeros64 返回 x 中的前导零位数;对于 x ==0,结果是 64。</target>
        </trans-unit>
        <trans-unit id="fda98988d92b8709dacc15db674b3e6e61682f64" translate="yes" xml:space="preserve">
          <source>LeadingZeros8</source>
          <target state="translated">LeadingZeros8</target>
        </trans-unit>
        <trans-unit id="d8a16180e08b654e4c4467808de5826069ff567a" translate="yes" xml:space="preserve">
          <source>LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.</source>
          <target state="translated">LeadingZeros8返回x中的前导零位数;对于x==0,结果是8。</target>
        </trans-unit>
        <trans-unit id="721bda08d146a886975a86dd204cbec756066f9e" translate="yes" xml:space="preserve">
          <source>Least Surprise Property: &quot;A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.&quot;</source>
          <target state="translated">最不意外的属性。&quot;一个熟悉HTML、CSS和JavaScript的开发者(或代码审查员),如果知道上下文自动套用的发生,应该能够看到{{.}},并正确推断出发生了什么消毒。&quot;</target>
        </trans-unit>
        <trans-unit id="8d92112ff544a635650fbaf730715150d27bea5c" translate="yes" xml:space="preserve">
          <source>Len computes the number of elements in ring r. It executes in time proportional to the number of elements.</source>
          <target state="translated">Len计算环r中的元素数,它的执行时间与元素数成正比。</target>
        </trans-unit>
        <trans-unit id="1399044ec4cebde1e345bfb6e7bc0665028c448d" translate="yes" xml:space="preserve">
          <source>Len returns the length of array a. A negative result indicates an unknown length.</source>
          <target state="translated">Len返回数组a的长度,负值表示未知长度。</target>
        </trans-unit>
        <trans-unit id="93ef3e242273d75e5bb1dbc766c5fd7830570833" translate="yes" xml:space="preserve">
          <source>Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len返回表示x所需的最小位数;对于x==0,结果为0。</target>
        </trans-unit>
        <trans-unit id="ca5afaea7adacd073486db0f70027386a60f94b6" translate="yes" xml:space="preserve">
          <source>Len returns the number of accumulated bytes; b.Len() == len(b.String()).</source>
          <target state="translated">Len返回累计的字节数;b.Len()==len(b.String())。</target>
        </trans-unit>
        <trans-unit id="ee2f279ceb0f8a58afdf88fefe8cee3f9c31fa50" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).</source>
          <target state="translated">Len返回缓冲区未读部分的字节数;b.Len()==len(b.Bytes())。</target>
        </trans-unit>
        <trans-unit id="67467f9c2f5df39d1ac34826fd0579c560dedb06" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the slice.</source>
          <target state="translated">Len返回分片中未读部分的字节数。</target>
        </trans-unit>
        <trans-unit id="9a34422a61609509fefc4a297f2f9c07ff69ccf9" translate="yes" xml:space="preserve">
          <source>Len returns the number of bytes of the unread portion of the string.</source>
          <target state="translated">Len返回字符串中未读部分的字节数。</target>
        </trans-unit>
        <trans-unit id="be3ac6245438d5424b518ab2335163e6f1965692" translate="yes" xml:space="preserve">
          <source>Len returns the number of elements of list l. The complexity is O(1).</source>
          <target state="translated">Len返回列表l的元素数,复杂度为O(1)。</target>
        </trans-unit>
        <trans-unit id="a7b0b1334a129ccc7a0e235fc902ddfdb01aa234" translate="yes" xml:space="preserve">
          <source>Len returns the number of methods in s.</source>
          <target state="translated">Len返回s中方法的数量。</target>
        </trans-unit>
        <trans-unit id="9909b01102ccbea5c34e603dc1a8df16cade5eea" translate="yes" xml:space="preserve">
          <source>Len returns the number of scope elements.</source>
          <target state="translated">Len返回范围元素的数量。</target>
        </trans-unit>
        <trans-unit id="8315c44360f57db88aab9b44a76e81307e540e3a" translate="yes" xml:space="preserve">
          <source>Len returns the number variables of tuple t.</source>
          <target state="translated">Len返回元组t的数量变量。</target>
        </trans-unit>
        <trans-unit id="ca8349640e110d5798f69868438b094ed5d5cb6c" translate="yes" xml:space="preserve">
          <source>Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.</source>
          <target state="translated">Len返回v的长度。如果v的Kind不是Array、Chan、Map、Slice或String,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="b58611e03df383dbaa4dc9ba6fd2e4a6b8e52327" translate="yes" xml:space="preserve">
          <source>Len16</source>
          <target state="translated">Len16</target>
        </trans-unit>
        <trans-unit id="f5e60795826c955dcfd526c1230894564783d120" translate="yes" xml:space="preserve">
          <source>Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len16返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="76efc8ef8d6465f58231c9d295309a299f1d8534" translate="yes" xml:space="preserve">
          <source>Len32</source>
          <target state="translated">Len32</target>
        </trans-unit>
        <trans-unit id="2bdd325b510dd0548fcbb4a4b3c4d52a4f66d711" translate="yes" xml:space="preserve">
          <source>Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len32返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="5bed2d704a16234c65f3795d3067f97369c94923" translate="yes" xml:space="preserve">
          <source>Len64</source>
          <target state="translated">Len64</target>
        </trans-unit>
        <trans-unit id="67dd373d63df43f7c3cfe611f388cdd1def82589" translate="yes" xml:space="preserve">
          <source>Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len64返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="5877dcf480cd63f747b4cd7b2e4473a4fb01962a" translate="yes" xml:space="preserve">
          <source>Len8</source>
          <target state="translated">Len8</target>
        </trans-unit>
        <trans-unit id="ead2ce671d2982c7db8677f2bb62a7b4fdd9a8e8" translate="yes" xml:space="preserve">
          <source>Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.</source>
          <target state="translated">Len8返回表示x所需的最小位数,x==0时结果为0。</target>
        </trans-unit>
        <trans-unit id="2981abdd30fd95f0ea0e0799884f920048d0fba8" translate="yes" xml:space="preserve">
          <source>Length returns the JavaScript property &quot;length&quot; of v. It panics if v is not a JavaScript object.</source>
          <target state="translated">Length返回v的JavaScript属性 &quot;length&quot;,如果v不是JavaScript对象,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="f0f51015552f0c7df8f3dcfecc5c896adfb05b7f" translate="yes" xml:space="preserve">
          <source>Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.</source>
          <target state="translated">Length 返回可变长度列类型(如文本和二进制字段类型)的列类型长度。如果类型长度是无限制的,那么该值将是math.MaxInt64(任何数据库限制仍然适用)。如果列类型不是可变长度的,例如int,或者如果驱动程序不支持,ok为false。</target>
        </trans-unit>
        <trans-unit id="7beb25af4ef1b6178972b02133e74127d796618a" translate="yes" xml:space="preserve">
          <source>Less reports whether x[i] should be ordered before x[j], as required by the sort Interface. Note that floating-point comparison by itself is not a transitive relation: it does not report a consistent ordering for not-a-number (NaN) values. This implementation of Less places NaN values before any others, by using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7467b2c9a7e459bce96e4603f4b9c0fecbbea6e6" translate="yes" xml:space="preserve">
          <source>Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).</source>
          <target state="translated">Lgamma返回Gamma(x)的自然对数和符号(-1或+1)。</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">根据知识共享署名协议3.0许可。</target>
        </trans-unit>
        <trans-unit id="7d9d345bfff5b874e03396293193a78237bde2df" translate="yes" xml:space="preserve">
          <source>Like Scanf and Fscanf, Sscanf need not consume its entire input. There is no way to recover how much of the input string Sscanf used.</source>
          <target state="translated">像Scanf和Fscanf一样,Sscanf不需要消耗整个输入。没有办法恢复Sscanf使用了多少输入字符串。</target>
        </trans-unit>
        <trans-unit id="7e1cb140c6b5c5e4e4aa15375a7a581d31852d58" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard error when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="translated">与测试中一样,基准日志在执行过程中被累积,并在完成后转储到标准误差。与测试中不同的是,基准日志总是被打印出来,这样就不会隐藏那些可能影响基准结果的输出。</target>
        </trans-unit>
        <trans-unit id="eb83a6fa3fb8d575ea5425178090b707c4e5b7e9" translate="yes" xml:space="preserve">
          <source>Like in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d7a9c098ae2cc78ad63fdda4f717ce942dd2cc" translate="yes" xml:space="preserve">
          <source>Like the RoundTripper interface, the error types returned by RoundTrip are unspecified.</source>
          <target state="translated">和RoundTripper接口一样,RoundTrip返回的错误类型也是不指定的。</target>
        </trans-unit>
        <trans-unit id="8c3e2cc8bde5ef9c910164a74c49f21b4ecb6bc1" translate="yes" xml:space="preserve">
          <source>LimitReader</source>
          <target state="translated">LimitReader</target>
        </trans-unit>
        <trans-unit id="82f17ce7a899200e83a237fbfff2e0aec18adc46" translate="yes" xml:space="preserve">
          <source>LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.</source>
          <target state="translated">LimitReader返回一个从r读取但在n个字节后以EOF停止的Reader。底层实现是一个*LimitedReader。</target>
        </trans-unit>
        <trans-unit id="dfc4ccc73713d6d0c21377e9d4eb82cf06cf9ec2" translate="yes" xml:space="preserve">
          <source>Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.</source>
          <target state="translated">Line返回给定文件位置p的行号;p必须是该文件中的Pos值或NoPos。</target>
        </trans-unit>
        <trans-unit id="c80f69f5d4f28c6e33fd6610f08a1143f38de111" translate="yes" xml:space="preserve">
          <source>LineCount returns the number of lines in file f.</source>
          <target state="translated">LineCount 返回文件 f 中的行数。</target>
        </trans-unit>
        <trans-unit id="8021239ce81a740af9d1126d1dcb955373ee8d6d" translate="yes" xml:space="preserve">
          <source>LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.</source>
          <target state="translated">LineReader 返回一个新的编译单元 cu 的行表阅读器,它必须是一个带有 TagCompileUnit 标签的条目。</target>
        </trans-unit>
        <trans-unit id="d6e6998fd35451f00c85f965d2d22dc96e7bd958" translate="yes" xml:space="preserve">
          <source>LineStart returns the Pos value of the start of the specified line. It ignores any alternative positions set using AddLineColumnInfo. LineStart panics if the 1-based line number is invalid.</source>
          <target state="translated">LineStart 返回指定行的起始位置的 Pos 值。它忽略任何使用AddLineColumnInfo设置的替代位置。如果以1为基准的行号无效,LineStart会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="4776e3cbe12ee14e372370ae9f2a2f5ec9999059" translate="yes" xml:space="preserve">
          <source>LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.</source>
          <target state="translated">LineToPC在给定的文件行中查找第一个程序计数器。如果这一行出现错误,它将返回 UnknownPathError 或 UnknownLineError。</target>
        </trans-unit>
        <trans-unit id="e41c87878f5ec2dd68efcc90f4932d27c2b8d1c2" translate="yes" xml:space="preserve">
          <source>LineToPC returns the program counter for the given line number, considering only program counters before maxpc.</source>
          <target state="translated">LineToPC返回给定行号的程序计数器,只考虑maxpc之前的程序计数器。</target>
        </trans-unit>
        <trans-unit id="d3ece36672b155d5080f24d88b4ef4dc56af15c6" translate="yes" xml:space="preserve">
          <source>Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.</source>
          <target state="translated">Link连接环r和环s,使r.Next()变成s,并返回r.Next()的原始值。r不能为空。</target>
        </trans-unit>
        <trans-unit id="61bc01a247b2210bb40d4dab78269bb633df6036" translate="yes" xml:space="preserve">
          <source>Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.</source>
          <target state="translated">Link创建newname作为旧名文件的硬链接。如果出现错误,它的类型将是*LinkError。</target>
        </trans-unit>
        <trans-unit id="8c53bb40a220e2f4f66bfd2012a9dda9a12bc64f" translate="yes" xml:space="preserve">
          <source>LinkError records an error during a link or symlink or rename system call and the paths that caused it.</source>
          <target state="translated">LinkError记录了系统调用链接、symlink或重命名过程中的错误,以及导致该错误的路径。</target>
        </trans-unit>
        <trans-unit id="2ca439921c0481dec50573fdcf5a08b538a5f2a3" translate="yes" xml:space="preserve">
          <source>List represents a doubly linked list. The zero value for List is an empty list ready to use.</source>
          <target state="translated">List代表一个双链路的列表。List的零值是一个准备使用的空列表。</target>
        </trans-unit>
        <trans-unit id="ed96ea56ffbf3b559f9c41465dc17435379898fd" translate="yes" xml:space="preserve">
          <source>ListNode holds a sequence of nodes.</source>
          <target state="translated">ListNode持有一个节点序列。</target>
        </trans-unit>
        <trans-unit id="ca24c0263416d5489002e073f3f7f972b1a2c801" translate="yes" xml:space="preserve">
          <source>Listen announces on the local network address.</source>
          <target state="translated">听听在本地网络地址上宣布。</target>
        </trans-unit>
        <trans-unit id="fbc501a375c74f3f294816964a99702dd99275fe" translate="yes" xml:space="preserve">
          <source>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">Listen使用net.Listen创建一个TLS监听器,接受给定网络地址上的连接。配置配置必须为非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="6c1bd8cd11c9c376470f7f547014d7596b4d2372" translate="yes" xml:space="preserve">
          <source>ListenAndServe</source>
          <target state="translated">ListenAndServe</target>
        </trans-unit>
        <trans-unit id="ca4b599f82e29135dc1efc68105574de3edf6ae1" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error.</source>
          <target state="translated">ListenAndServe总是返回一个非零的错误。</target>
        </trans-unit>
        <trans-unit id="5dd294a2ba295a8af34a90f46a25099808a8e7bb" translate="yes" xml:space="preserve">
          <source>ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServe总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="0e017d6f66fb57e5159203491154acdfd7f3155e" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe对TCP网络地址addr进行监听,然后用handler调用Serve来处理传入连接的请求。接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="1eb6871fd885bb71d1764b988ed8e0b1207dbd10" translate="yes" xml:space="preserve">
          <source>ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServe监听TCP网络地址srv.Addr,然后调用Serve处理传入连接的请求。已接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="f672409681724db7975a81f059dabf70eb0a6552" translate="yes" xml:space="preserve">
          <source>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</source>
          <target state="translated">ListenAndServe用一个给定的地址和处理程序启动一个HTTP服务器,处理程序通常为nil,这意味着使用DefaultServeMux。处理程序通常是nil,这意味着要使用DefaultServeMux。Handle和HandleFunc向DefaultServeMux添加处理程序。</target>
        </trans-unit>
        <trans-unit id="b1444c4d4c91aea2ff2c287b0f4c6b6c33effbc6" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS</source>
          <target state="translated">ListenAndServeTLS</target>
        </trans-unit>
        <trans-unit id="4b13ffad776ec4c1e6e622baa48939390c7f43be" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.</source>
          <target state="translated">ListenAndServeTLS的作用与ListenAndServe相同,只是它期望HTTPS连接。此外,必须提供包含服务器的证书和匹配的私钥的文件。如果证书是由证书颁发机构签署的,那么certFile应该是服务器的证书、任何中介机构和CA的证书的连接。</target>
        </trans-unit>
        <trans-unit id="e993bc61c7cd05bdd6aa504a7bf534f06ff70ebd" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed.</source>
          <target state="translated">ListenAndServeTLS总是返回一个非零的错误。关机或关闭后,返回的错误是ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="4de6956912052ccb175eeb5c4727583b8c87a58f" translate="yes" xml:space="preserve">
          <source>ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.</source>
          <target state="translated">ListenAndServeTLS监听TCP网络地址srv.Addr,然后调用ServeTLS来处理传入的TLS连接的请求。接受的连接被配置为启用TCP keep-alives。</target>
        </trans-unit>
        <trans-unit id="2ef32140a96f71533a922e8af1a4a1287b2aa08c" translate="yes" xml:space="preserve">
          <source>ListenConfig contains options for listening to an address.</source>
          <target state="translated">ListenConfig包含监听地址的选项。</target>
        </trans-unit>
        <trans-unit id="56e637fe09ab78156ad9d4b14c696af0fcd5c313" translate="yes" xml:space="preserve">
          <source>ListenIP acts like ListenPacket for IP networks.</source>
          <target state="translated">ListenIP的作用类似于IP网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="f21580354d675fc10d1e9ee1c4db6486064ec455" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.</source>
          <target state="translated">ListenMulticastUDP的作用类似于UDP网络的ListenPacket,但在特定的网络接口上取一个组地址。</target>
        </trans-unit>
        <trans-unit id="867f2d87132f64efe5f8f6f86d2c98549b471fdb" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses.</source>
          <target state="translated">ListenMulticastUDP只是为了方便简单的小型应用。有golang.org/x/net/ipv4和golang.org/x/net/ipv6包供通用。</target>
        </trans-unit>
        <trans-unit id="bd5f6e57a541e39939141511f957be405b380471" translate="yes" xml:space="preserve">
          <source>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen.</source>
          <target state="translated">ListenMulticastUDP监听本地系统的所有可用IP地址,包括组、组播IP地址。如果i为nil,ListenMulticastUDP使用系统分配的组播接口,不过不建议这样做,因为分配取决于平台,有时可能需要进行路由配置。如果gaddr的Port字段为0,则会自动选择一个端口号。</target>
        </trans-unit>
        <trans-unit id="468da55aa49f2b551af4d2ec242f5d19018b56ca" translate="yes" xml:space="preserve">
          <source>ListenPacket announces on the local network address.</source>
          <target state="translated">ListenPacket在本地网络地址上宣布。</target>
        </trans-unit>
        <trans-unit id="df604088a8b978cdce196e569a7b165e976e6869" translate="yes" xml:space="preserve">
          <source>ListenTCP acts like Listen for TCP networks.</source>
          <target state="translated">ListenTCP的作用类似于TCP网络的Listen。</target>
        </trans-unit>
        <trans-unit id="9851cfe87c5b9ef168f40038c7d75b3a82ee3529" translate="yes" xml:space="preserve">
          <source>ListenUDP acts like ListenPacket for UDP networks.</source>
          <target state="translated">ListenUDP的作用类似于UDP网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="5b7757b4611e8ba6d66b663a1f48d50bfcf3ecc4" translate="yes" xml:space="preserve">
          <source>ListenUnix acts like Listen for Unix networks.</source>
          <target state="translated">ListenUnix的作用就像Unix网络的Listen。</target>
        </trans-unit>
        <trans-unit id="df0abb591dbf2fca4d32aeb087ddbb3eb5bf7905" translate="yes" xml:space="preserve">
          <source>ListenUnixgram acts like ListenPacket for Unix networks.</source>
          <target state="translated">ListenUnixgram的作用类似于Unix网络的ListenPacket。</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="0391fe0f913571d2818f72cca0ff528d31c4414b" translate="yes" xml:space="preserve">
          <source>LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.</source>
          <target state="translated">LiteralPrefix 返回一个必须在正则表达式 re 的任何匹配开始的字词串,如果字词串包含整个正则表达式,则返回布尔值 true。</target>
        </trans-unit>
        <trans-unit id="ecdd85ee0de784370070e365d9f936724803e148" translate="yes" xml:space="preserve">
          <source>LittleEndian is the little-endian implementation of ByteOrder.</source>
          <target state="translated">LittleEndian是ByteOrder的little-endian实现。</target>
        </trans-unit>
        <trans-unit id="d5ae70e267716ec3e2a976b68757e30ee0e214a8" translate="yes" xml:space="preserve">
          <source>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.</source>
          <target state="translated">Load返回最近一次Store设置的值。如果没有调用过该值的Store,则返回nil。</target>
        </trans-unit>
        <trans-unit id="74c5a2d6710e8b201a98f6c2837198f613eec0fa" translate="yes" xml:space="preserve">
          <source>Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.</source>
          <target state="translated">Load返回存储在地图中的键值,如果没有键值,则返回nil。ok的结果表示是否在地图中找到了值。</target>
        </trans-unit>
        <trans-unit id="bfe3a7d08b4bcafd9312e5433ad874e88e9a309d" translate="yes" xml:space="preserve">
          <source>LoadAndDelete deletes the value for a key, returning the previous value if any. The loaded result reports whether the key was present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881052b1a20f63445e79814467ecdb5374883ab0" translate="yes" xml:space="preserve">
          <source>LoadInt32 atomically loads *addr.</source>
          <target state="translated">LoadInt32原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="2ac3794cf69cbb4165a4ee85d8ea313e85610e69" translate="yes" xml:space="preserve">
          <source>LoadInt64 atomically loads *addr.</source>
          <target state="translated">LoadInt64原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="3cd00c96c1dde37f4e165d9dd83f094e52c09c97" translate="yes" xml:space="preserve">
          <source>LoadLocation</source>
          <target state="translated">LoadLocation</target>
        </trans-unit>
        <trans-unit id="942c4e15f8861257bc29d285e307a9855ad8da88" translate="yes" xml:space="preserve">
          <source>LoadLocation returns the Location with the given name.</source>
          <target state="translated">LoadLocation 返回给定名称的位置。</target>
        </trans-unit>
        <trans-unit id="452c7f6aa0b947a115cd7ebee668ccabc28767f6" translate="yes" xml:space="preserve">
          <source>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).</source>
          <target state="translated">LoadLocationFromTZData从IANA时区数据库格式化的数据中返回一个具有给定名称初始化的位置。这些数据应该是标准IANA时区文件的格式(例如,Unix系统中的/etc/localtime的内容)。</target>
        </trans-unit>
        <trans-unit id="730b9fd8d031760ad2f11544687c7f3a4c32ba10" translate="yes" xml:space="preserve">
          <source>LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.</source>
          <target state="translated">LoadOrStore返回键的现有值(如果存在)。否则,它将存储并返回给定的值。如果值被加载,则加载的结果为true,如果被存储,则返回false。</target>
        </trans-unit>
        <trans-unit id="16e5531718ad0441ff996bffe1bdb2f9013072b8" translate="yes" xml:space="preserve">
          <source>LoadPointer atomically loads *addr.</source>
          <target state="translated">LoadPointer原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="3a58860dce2950635c9b0aec0356bd0e023fcd4b" translate="yes" xml:space="preserve">
          <source>LoadUint32 atomically loads *addr.</source>
          <target state="translated">LoadUint32原子地加载*addr。</target>
        </trans-unit>
        <trans-unit id="ed4689d0f224e4c5a01ae1b69433a91e9f118b20" translate="yes" xml:space="preserve">
          <source>LoadUint64 atomically loads *addr.</source>
          <target state="translated">LoadUint64原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="9cfbde985c4614b9808e9de0d65afb5568c9c53d" translate="yes" xml:space="preserve">
          <source>LoadUintptr atomically loads *addr.</source>
          <target state="translated">LoadUintptr原子地加载*addr.</target>
        </trans-unit>
        <trans-unit id="e85b79501e4b543de03554e2a29fd9cbd965ec40" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair</source>
          <target state="translated">LoadX509KeyPair</target>
        </trans-unit>
        <trans-unit id="45fae6424c26a4b8eb19ae242ef820e6061dab08" translate="yes" xml:space="preserve">
          <source>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.</source>
          <target state="translated">LoadX509KeyPair从一对文件中读取并解析一对公钥/私钥。文件必须包含PEM编码的数据。证书文件可以包含叶子证书之后的中间证书,以形成一个证书链。当成功返回时,Certificate.Leaf将为零,因为证书的解析形式不会被保留。</target>
        </trans-unit>
        <trans-unit id="1da25ed4d4f6ff8e68f5335ba8ba070399bd7f5f" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone.</source>
          <target state="translated">本地代表系统的本地时区。</target>
        </trans-unit>
        <trans-unit id="4f717f0478e589f031d904c7f74748dd18f86eeb" translate="yes" xml:space="preserve">
          <source>Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=&quot;&quot; means use UTC. TZ=&quot;foo&quot; means use file foo in the system timezone directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6d294473bbbfce0d1197b903b10c86fb6c3b7b" translate="yes" xml:space="preserve">
          <source>Local returns t with the location set to local time.</source>
          <target state="translated">Local返回t,并将位置设置为当地时间。</target>
        </trans-unit>
        <trans-unit id="4a5ab837cb8b234abbab484d911af5705d613e13" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address.</source>
          <target state="translated">LocalAddr 返回本地网络地址。</target>
        </trans-unit>
        <trans-unit id="c10eb870360e8baad53b9b506e944815aa5896df" translate="yes" xml:space="preserve">
          <source>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.</source>
          <target state="translated">LocalAddr返回本地网络地址。返回的Addr是所有调用LocalAddr的次数所共享的,所以不要修改它。</target>
        </trans-unit>
        <trans-unit id="238b4cd4fe464f99416bb574ab9c5c6651970ad5" translate="yes" xml:space="preserve">
          <source>LocalhostCert is a PEM-encoded TLS cert with SAN IPs &quot;127.0.0.1&quot; and &quot;[::1]&quot;, expiring at Jan 29 16:00:00 2084 GMT. generated from src/crypto/tls: go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h</source>
          <target state="translated">LocalhostCert是一个PEM编码的TLS证书,其SAN IP为 &quot;127.0.0.1 &quot;和&quot;[::1]&quot;,到期时间为1月29日16:00:00 2084 GMT。从src/crypto/tls生成:go run generate_cert.go --rsa-bits 1024 --host 127.0.0.1,::1,example.com --ca --start-date &quot;Jan 1 00:00:00 1970&quot; --duration=1000000h。</target>
        </trans-unit>
        <trans-unit id="2852b827de5091ca5aa6958386fa1405befa6094" translate="yes" xml:space="preserve">
          <source>LocalhostKey is the private key for localhostCert.</source>
          <target state="translated">LocalhostKey是localhostCert的私钥。</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="c9551a197b6ccbbe733e98e1afb44218648f365d" translate="yes" xml:space="preserve">
          <source>Location returns the URL of the response's &quot;Location&quot; header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.</source>
          <target state="translated">Location返回响应的 &quot;Location &quot;头的URL,如果存在的话。相对重定向是相对于Response的Request进行解析的,如果没有Location头,则返回ErrNoLocation。如果没有Location头,则返回ErrNoLocation。</target>
        </trans-unit>
        <trans-unit id="6b99376f9c15a7e92154da5850b5d13b41ab37cc" translate="yes" xml:space="preserve">
          <source>Location returns the time zone information associated with t.</source>
          <target state="translated">Location返回与t相关的时区信息。</target>
        </trans-unit>
        <trans-unit id="f30d8c256e2218530f9f115302f529d73fbbff9d" translate="yes" xml:space="preserve">
          <source>Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.</source>
          <target state="translated">锁定锁m.如果锁已经在使用中,则调用goroutine阻塞,直到mutex可用。</target>
        </trans-unit>
        <trans-unit id="c3a987424c4290a7edfb3d1d597eb0eadb3ba378" translate="yes" xml:space="preserve">
          <source>Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.</source>
          <target state="translated">锁定锁rw进行写入。如果锁已经被锁住进行读写,则锁锁住,直到锁可用为止。</target>
        </trans-unit>
        <trans-unit id="5e340916752857a7b67a505378d157d115c1dd5a" translate="yes" xml:space="preserve">
          <source>LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.</source>
          <target state="translated">LockOSThread将调用的goroutine连接到当前的操作系统线程中。在调用的goroutine调用了与LockOSThread同样多的UnlockOSThread之前,调用的goroutine将始终在该线程中执行,其他goroutine不会在该线程中执行。如果调用的goroutine没有解锁线程就退出,那么该线程将被终止。</target>
        </trans-unit>
        <trans-unit id="8bf95ea372568c7a254ba9fada5f6f1701ebc5b5" translate="yes" xml:space="preserve">
          <source>Log</source>
          <target state="translated">Log</target>
        </trans-unit>
        <trans-unit id="fef609891d98d73a3ae686771d1e86e56fc90748" translate="yes" xml:space="preserve">
          <source>Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.</source>
          <target state="translated">日志用给定的类别和消息发出一次性的事件,类别可以是空的,API假设系统中只有少数几个独特的类别。类别可以是空的,API假设系统中只有少数几个独特的类别。</target>
        </trans-unit>
        <trans-unit id="2353b4e8ade1606ef5c45cccd26ad3ad6087c78a" translate="yes" xml:space="preserve">
          <source>Log emits a timestamped message to the execution trace along with additional information such as the category of the message and which goroutine called Log. The execution tracer provides UIs to filter and group goroutines using the log category and the message supplied in Log.</source>
          <target state="translated">日志会向执行跟踪器发送一个带有时间戳的消息,同时还会提供额外的信息,比如消息的类别和哪个goroutine调用了日志。执行跟踪器提供了使用日志类别和Log中提供的消息来过滤和分组goroutine的用户界面。</target>
        </trans-unit>
        <trans-unit id="9821e0db1231d181423f2e3b3225f154baa6bcf6" translate="yes" xml:space="preserve">
          <source>Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Log使用默认的格式化参数,类似于Println,并将文本记录在错误日志中。对于测试,只有当测试失败或设置了-test.v标志时,才会打印文本,对于基准,总是打印文本,以避免性能取决于-test.v标志的值。对于基准,文本总是被打印出来,以避免性能取决于-test.v标志的值。</target>
        </trans-unit>
        <trans-unit id="ad88d5c498edf7ea21028a5246446ba6a3bf9e4a" translate="yes" xml:space="preserve">
          <source>Log returns the natural logarithm of x.</source>
          <target state="translated">Log返回x的自然对数。</target>
        </trans-unit>
        <trans-unit id="81d615cdf905d64451161a1aa0b68ae0ffb374e3" translate="yes" xml:space="preserve">
          <source>Log10</source>
          <target state="translated">Log10</target>
        </trans-unit>
        <trans-unit id="977a2b5c893e89719e9a7736a4e1f9cc525e8f11" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x.</source>
          <target state="translated">Log10 返回 x 的小数对数。</target>
        </trans-unit>
        <trans-unit id="8671c0c40d7db0093d8bf62e5f04cba5c99ec3ea" translate="yes" xml:space="preserve">
          <source>Log10 returns the decimal logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log10 返回 x 的小数对数,特殊情况与 Log 相同。</target>
        </trans-unit>
        <trans-unit id="a5b2fd4cb1a8e2bb305b5672e391aef89a37298c" translate="yes" xml:space="preserve">
          <source>Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.</source>
          <target state="translated">Log1p 返回 1 加上其参数 x 的自然对数。当 x 接近零时,它比 Log(1+x)更准确。</target>
        </trans-unit>
        <trans-unit id="6687db9bf747c384bcc8d36417e42b952196b766" translate="yes" xml:space="preserve">
          <source>Log2</source>
          <target state="translated">Log2</target>
        </trans-unit>
        <trans-unit id="7a0389c8675757d7572efc0a10b125d5c66b151f" translate="yes" xml:space="preserve">
          <source>Log2 returns the binary logarithm of x. The special cases are the same as for Log.</source>
          <target state="translated">Log2 返回 x 的二进制对数,特殊情况与 Log 相同。</target>
        </trans-unit>
        <trans-unit id="5963a7c64c0149e44b174ff76b7f701d23bc3074" translate="yes" xml:space="preserve">
          <source>Logb returns the binary exponent of x.</source>
          <target state="translated">Logb返回x的二进制指数。</target>
        </trans-unit>
        <trans-unit id="ea0c4052b7cdd5aadd9cd6f72174db65e462d77d" translate="yes" xml:space="preserve">
          <source>Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.</source>
          <target state="translated">Logf按照格式对其参数进行格式化,类似于Printf,并将文本记录在错误日志中。如果没有提供参数,最后会添加一个新行。对于测试,只有在测试失败或设置了 -test.v 标志时才会打印文本。对于基准,文本总是被打印出来,以避免性能取决于-test.v标志的值。</target>
        </trans-unit>
        <trans-unit id="38de20acad3e04f48129d8399f6a41e7517acf40" translate="yes" xml:space="preserve">
          <source>Logf is like Log, but the value is formatted using the specified format spec.</source>
          <target state="translated">Logf和Log一样,但值的格式化使用了指定的格式规范。</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="71c466638d24f772f0edc78440c6db3a9b5a9e5d" translate="yes" xml:space="preserve">
          <source>Logger.Output</source>
          <target state="translated">Logger.Output</target>
        </trans-unit>
        <trans-unit id="00aa9c00206cc40c149f1a777f6bcbff0a6df954" translate="yes" xml:space="preserve">
          <source>Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.</source>
          <target state="translated">最长使未来的搜索更倾向于最左最长的匹配。也就是说,当对文本进行匹配时,regexp会返回一个在输入中尽可能早开始的匹配(最左),并在这些匹配中选择一个尽可能长的匹配。这个方法修改了Regexp,并且不能与其他方法同时调用。</target>
        </trans-unit>
        <trans-unit id="2397e2af778033b693f99aeecb7590b807be4783" translate="yes" xml:space="preserve">
          <source>LookPath</source>
          <target state="translated">LookPath</target>
        </trans-unit>
        <trans-unit id="3feb8389b758c68212533dd8278b352dcce121bf" translate="yes" xml:space="preserve">
          <source>LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.</source>
          <target state="translated">LookPath在PATH环境变量命名的目录中搜索一个名为文件的可执行文件。如果文件中包含斜杠,则直接尝试,不参考PATH。结果可能是绝对路径或相对于当前目录的路径。</target>
        </trans-unit>
        <trans-unit id="31ab9ed47ac6872e6361cf76170e61fbc5a37449" translate="yes" xml:space="preserve">
          <source>Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError.</source>
          <target state="translated">Lookup通过用户名查找一个用户。如果找不到该用户,返回的错误类型为UnknownUserError。</target>
        </trans-unit>
        <trans-unit id="2c6f1e000a822d2c47b6a21ebdd8f5f93b104795" translate="yes" xml:space="preserve">
          <source>Lookup maps an identifier to its keyword token or IDENT (if not a keyword).</source>
          <target state="translated">查找将一个标识符映射到它的关键字标记或IDENT(如果不是关键字)。</target>
        </trans-unit>
        <trans-unit id="e9251196227d6115352b68461b921cf61a906b43" translate="yes" xml:space="preserve">
          <source>Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n &amp;lt; 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data.</source>
          <target state="translated">查找返回最多n个索引的未排序列表，其中字节串s出现在索引数据中。如果n &amp;lt;0，则返回所有出现的事件。如果s为空，找不到s或n == 0，则结​​果为nil。查找时间为O（log（N）* len（s）+ len（result）），其中N是索引数据的大小。</target>
        </trans-unit>
        <trans-unit id="13380eb03660f02dbd5d025d2b74f6f24450d311" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.</source>
          <target state="translated">Lookup返回命名的命令行标志的Flag结构,如果不存在则返回nil。</target>
        </trans-unit>
        <trans-unit id="7e5483b0c984c3a57ec759db6fb278e7b255ecf8" translate="yes" xml:space="preserve">
          <source>Lookup returns the Flag structure of the named flag, returning nil if none exists.</source>
          <target state="translated">Lookup返回命名标志的Flag结构,如果不存在则返回nil。</target>
        </trans-unit>
        <trans-unit id="5b0f26aebf1133c7a9f5776675b02659900d5a6f" translate="yes" xml:space="preserve">
          <source>Lookup returns the method with matching package and name, or nil if not found.</source>
          <target state="translated">Lookup 返回匹配包和名称的方法,如果没有找到,则返回nil。</target>
        </trans-unit>
        <trans-unit id="903dddeee2a83198e7d326397e76f54d9c716c8e" translate="yes" xml:space="preserve">
          <source>Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil.</source>
          <target state="translated">如果存在给定名称的对象,Lookup返回s范围内的对象,否则结果为nil。</target>
        </trans-unit>
        <trans-unit id="103697c251b3570afaab5577775dc041e648c7f1" translate="yes" xml:space="preserve">
          <source>Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored.</source>
          <target state="translated">如果在作用域s中找到了给定名称的对象,Lookup返回,否则返回nil。外部作用域会被忽略。</target>
        </trans-unit>
        <trans-unit id="85596012a102f4cba55be912c69d163f2b6f529c" translate="yes" xml:space="preserve">
          <source>Lookup returns the profile with the given name, or nil if no such profile exists.</source>
          <target state="translated">Lookup返回给定名称的配置文件,如果没有这样的配置文件,则返回nil。</target>
        </trans-unit>
        <trans-unit id="38285e372c5ecf7fee79e8f5475a7ad611b07ce7" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t, or nil if there is no such template.</source>
          <target state="translated">Lookup返回与t相关联的给定名称的模板,如果没有这样的模板,则返回nil。</target>
        </trans-unit>
        <trans-unit id="b619549e7b11c0494158ea2b89e4d841aca101b2" translate="yes" xml:space="preserve">
          <source>Lookup returns the template with the given name that is associated with t. It returns nil if there is no such template or the template has no definition.</source>
          <target state="translated">如果没有这样的模板或者模板没有定义,则返回nil。</target>
        </trans-unit>
        <trans-unit id="c7a19da9ed723c89b3a482cb521b80e66fbdef7d" translate="yes" xml:space="preserve">
          <source>Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.</source>
          <target state="translated">Lookup 返回与标签字符串中的 key 相关联的值,如果标签中存在 key,则返回值(可能为空)。如果标签中存在键,则返回值(可能为空)。否则返回的值将是空字符串。ok 返回值会报告该值是否在标签字符串中显式设置。如果标签没有常规格式,Lookup 返回的值是未指定的。</target>
        </trans-unit>
        <trans-unit id="b1ca47c6e14b4100767398ad08b18ceba8715515" translate="yes" xml:space="preserve">
          <source>Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">查找在插件p中搜索一个名为symName的符号,符号是任何导出的变量或函数。如果没有找到这个符号,它就会报错。它对多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="99f5d988af7e6ab773a1a6146dd567b1c079995f" translate="yes" xml:space="preserve">
          <source>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.</source>
          <target state="translated">LookupAddr对给定的地址进行反向查找,返回一个映射到该地址的名称列表。</target>
        </trans-unit>
        <trans-unit id="c70e79ec87ca49562ea197d9f2381d9321d8fe1b" translate="yes" xml:space="preserve">
          <source>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.</source>
          <target state="translated">LookupCNAME返回给定主机的规范名。不关心规范名的调用者可以直接调用LookupHost或LookupIP;两者都会将规范名的解析作为查找的一部分。</target>
        </trans-unit>
        <trans-unit id="8f4cf5e540b2d7dc315df0e1c1d62f60bab0e907" translate="yes" xml:space="preserve">
          <source>LookupEnv</source>
          <target state="translated">LookupEnv</target>
        </trans-unit>
        <trans-unit id="1ae2ee5065be9305542647e69dc65b9fd29b64fe" translate="yes" xml:space="preserve">
          <source>LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.</source>
          <target state="translated">LookupEnv检索由键命名的环境变量的值。如果该变量存在于环境中,则返回值(可能为空),布尔值为true。否则返回的值将为空,布尔值为false。</target>
        </trans-unit>
        <trans-unit id="450e346d69b1c045fb4f52550736ebb0d1d8a4f8" translate="yes" xml:space="preserve">
          <source>LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups).</source>
          <target state="translated">LookupFieldOrMethod在T中查找一个给定包和名称的字段或方法,并返回相应的*Var或*Func,一个索引序列,以及一个表示在通往字段或方法的路径上是否有任何指针指示的bool。如果设置了addressable,那么T就是一个可寻址变量的类型(只对方法的查找重要)。</target>
        </trans-unit>
        <trans-unit id="9411c991fe6ec6318c1ddadaf5239d4c8ddf419e" translate="yes" xml:space="preserve">
          <source>LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupFunc返回给定名称的文本、数据或bss符号,如果没有找到这样的符号,则返回nil。</target>
        </trans-unit>
        <trans-unit id="b92e9ccf5cc37f1e202dab80af7fdd5adb2d4fdf" translate="yes" xml:space="preserve">
          <source>LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError.</source>
          <target state="translated">LookupGroup通过名称查找一个组。如果找不到该组,返回的错误类型为UnknownGroupError。</target>
        </trans-unit>
        <trans-unit id="864ecbbe82138c5e60336462e2e26b9cc0321aa1" translate="yes" xml:space="preserve">
          <source>LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError.</source>
          <target state="translated">LookupGroupId通过groupid查找一个组。如果找不到该组,返回的错误类型是UnknownGroupIdError。</target>
        </trans-unit>
        <trans-unit id="b9002491d44dda33fcc5ee2b368b90bad48de6db" translate="yes" xml:space="preserve">
          <source>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.</source>
          <target state="translated">LookupHost 使用本地解析器查找给定主机。它返回该主机地址的一个片段。</target>
        </trans-unit>
        <trans-unit id="755f9feba02c89c681a556fd82001ef270f65acd" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host for the given network using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. network must be one of &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9702748a7f19b9de210233c47deec534e3b2cf2" translate="yes" xml:space="preserve">
          <source>LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIP 使用本地解析器查找主机。它返回该主机的IPv4和IPv6地址的一部分。</target>
        </trans-unit>
        <trans-unit id="f974c6e0590936cd53144b751f0c8c53e1e56f97" translate="yes" xml:space="preserve">
          <source>LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.</source>
          <target state="translated">LookupIPAddr 使用本地解析器查找主机。它返回该主机的IPv4和IPv6地址的一部分。</target>
        </trans-unit>
        <trans-unit id="39cfba6c5476e7337eb21e14ebf7cf0d6e5bedc2" translate="yes" xml:space="preserve">
          <source>LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError.</source>
          <target state="translated">LookupId通过userid查找一个用户。如果找不到用户,返回的错误类型是UnknownUserIdError。</target>
        </trans-unit>
        <trans-unit id="fa6df437374a8db7470645bbe9d4e27c81caaaeb" translate="yes" xml:space="preserve">
          <source>LookupMX returns the DNS MX records for the given domain name sorted by preference.</source>
          <target state="translated">LookupMX按照偏好排序,返回指定域名的DNS MX记录。</target>
        </trans-unit>
        <trans-unit id="eb321dee8209258e986d88d75de6022a02c641f4" translate="yes" xml:space="preserve">
          <source>LookupNS returns the DNS NS records for the given domain name.</source>
          <target state="translated">LookupNS返回给定域名的DNS NS记录。</target>
        </trans-unit>
        <trans-unit id="74ae49fce9af1a0aa1c34cc08bb2eaff3e2f9136" translate="yes" xml:space="preserve">
          <source>LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil).</source>
          <target state="translated">LookupParent 遵循从 s 开始的父作用域链,直到它找到一个 Lookup(name)返回非零对象的作用域,然后返回该作用域和对象。如果提供了一个有效的位置 pos,则只考虑在 pos 或之前声明的对象。如果不存在这样的作用域和对象,结果是(nil,nil)。</target>
        </trans-unit>
        <trans-unit id="0730b69dbfb75d19ecc78b2277aae489ac068a4f" translate="yes" xml:space="preserve">
          <source>LookupPort looks up the port for the given network and service.</source>
          <target state="translated">LookupPort查找指定网络和服务的端口。</target>
        </trans-unit>
        <trans-unit id="f0a5a2c68645491f7f14b8ebf958dd03393284be" translate="yes" xml:space="preserve">
          <source>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly.</source>
          <target state="translated">LookupSRV按照RFC 2782构建要查询的DNS名称。也就是说,它查找的是_service._proto.name。为了适应以非标准名称发布SRV记录的服务,如果service和proto都是空字符串,LookupSRV会直接查找name。</target>
        </trans-unit>
        <trans-unit id="6b37c6078d739a1c536ea751e03fbdc7bcfb4fd9" translate="yes" xml:space="preserve">
          <source>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;. The returned records are sorted by priority and randomized by weight within a priority.</source>
          <target state="translated">LookupSRV试图解析给定服务、协议和域名的SRV查询。proto是 &quot;tcp &quot;或 &quot;udp&quot;。返回的记录按优先级排序,并在优先级内按权重随机排列。</target>
        </trans-unit>
        <trans-unit id="53adeca568bb0a57f84e1f9d5ebd3b79ee2295f0" translate="yes" xml:space="preserve">
          <source>LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.</source>
          <target state="translated">LookupSym返回给定名称的文本、数据或bss符号,如果没有找到这样的符号,则返回nil。</target>
        </trans-unit>
        <trans-unit id="e3ed61b0b0e3039a19a182ecd64a64ecece699f9" translate="yes" xml:space="preserve">
          <source>LookupTXT returns the DNS TXT records for the given domain name.</source>
          <target state="translated">LookupTXT返回指定域名的DNS TXT记录。</target>
        </trans-unit>
        <trans-unit id="be0fd93650565eb4e261e38483006a0a6e96ae35" translate="yes" xml:space="preserve">
          <source>Lsh sets z = x &amp;lt;&amp;lt; n and returns z.</source>
          <target state="translated">Lsh设置z = x &amp;lt;&amp;lt; n并返回z。</target>
        </trans-unit>
        <trans-unit id="8432c7185b33f226f3a96e2aaaeb0017fbd79a53" translate="yes" xml:space="preserve">
          <source>Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Lstat 返回一个描述命名文件的 FileInfo。如果文件是一个符号链接,返回的FileInfo会描述这个符号链接。Lstat不试图跟踪该链接。如果有错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="653b7ad5571eb02f2761c383b0762a05ad1e21e9" translate="yes" xml:space="preserve">
          <source>M is a type passed to a TestMain function to run the actual tests.</source>
          <target state="translated">M是传递给TestMain函数的类型,用于运行实际测试。</target>
        </trans-unit>
        <trans-unit id="6c4afe9957321d9f90932c8eebed2802a4ac1436" translate="yes" xml:space="preserve">
          <source>MD5 is cryptographically broken and should not be used for secure applications.</source>
          <target state="translated">MD5在密码学上是有缺陷的,不应该用于安全应用。</target>
        </trans-unit>
        <trans-unit id="2c0f2626fcfbcf6f5cc06f45f9a06123950573c9" translate="yes" xml:space="preserve">
          <source>Machine is found in Header.Machine.</source>
          <target state="translated">在Header.Machine中发现了机器。</target>
        </trans-unit>
        <trans-unit id="abd1aeb6203ae00a3b2e20d1890fa31ee8357446" translate="yes" xml:space="preserve">
          <source>Magic number for the elf trampoline, chosen wisely to be an immediate value.</source>
          <target state="translated">精灵蹦床的魔法数字,明智地选择了一个即时值。</target>
        </trans-unit>
        <trans-unit id="34db1d3199d388dde94cedd16c554b4e44c4ed46" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. If the server supports the SMTPUTF8 extension, Mail adds the SMTPUTF8 parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30cb76631db62a976ef3584c436e5f44c54006c" translate="yes" xml:space="preserve">
          <source>Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.</source>
          <target state="translated">Mail使用提供的电子邮件地址向服务器发出MAIL命令,如果服务器支持8BITMIME扩展,Mail会添加BODY=8BITMIME参数。如果服务器支持8BITMIME扩展名,Mail会添加BODY=8BITMIME参数。这就启动了一个邮件事务,并在后面进行一个或多个Rcpt调用。</target>
        </trans-unit>
        <trans-unit id="62bce9422ff2d14f69ab80a154510232fc8a9afd" translate="yes" xml:space="preserve">
          <source>Main</source>
          <target state="translated">Main</target>
        </trans-unit>
        <trans-unit id="0784ed59d6aa6164d650ee5788e4f48c9ab53ccb" translate="yes" xml:space="preserve">
          <source>Main is an internal function, part of the implementation of the &quot;go test&quot; command. It was exported because it is cross-package and predates &quot;internal&quot; packages. It is no longer used by &quot;go test&quot; but preserved, as much as possible, for other systems that simulate &quot;go test&quot; using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating &quot;go test&quot; should be updated to use MainStart.</source>
          <target state="translated">Main 是一个内部函数,是实现 &quot;go test &quot;命令的一部分。它被导出是因为它是跨包的,而且比 &quot;内部 &quot;包更早。它不再被 &quot;go test &quot;使用,而是尽可能地保留下来,供其他使用Main模拟 &quot;go test &quot;的系统使用,但由于测试包中增加了新的功能,Main有时无法更新。模拟 &quot;go test &quot;的系统应该更新为使用MainStart。</target>
        </trans-unit>
        <trans-unit id="b4948070b9137e3c4295247505827d161a1430c0" translate="yes" xml:space="preserve">
          <source>MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.</source>
          <target state="translated">MainStart 是为了给'go test'生成的测试使用。它不是用来直接调用的,也不受 Go 1 兼容性文件的限制。它可能会在不同的版本中改变签名。</target>
        </trans-unit>
        <trans-unit id="76f0e763aa0460d3ebdb6819d8a8618bd610502c" translate="yes" xml:space="preserve">
          <source>Make returns the Value for x.</source>
          <target state="translated">使返回x的值。</target>
        </trans-unit>
        <trans-unit id="d212d37a7f555035543edd9847aa0f8944d00dd6" translate="yes" xml:space="preserve">
          <source>MakeBool returns the Bool value for b.</source>
          <target state="translated">MakeBool返回b的Bool值。</target>
        </trans-unit>
        <trans-unit id="1bde4b612786d9c5dc71f0124e7f5aff783bd040" translate="yes" xml:space="preserve">
          <source>MakeChan creates a new channel with the specified type and buffer size.</source>
          <target state="translated">MakeChan用指定的类型和缓冲区大小创建一个新通道。</target>
        </trans-unit>
        <trans-unit id="07c781b2f5d2aafadbf3e2e50e6f01577121585d" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is -0.0, the result is 0.0. If x is not finite, the result is an Unknown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499a9ac9172e4fd5f8c155f860005e583c8290f" translate="yes" xml:space="preserve">
          <source>MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown.</source>
          <target state="translated">MakeFloat64返回x的Float值,如果x不是有限值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="080b5a4b73c758656574c66abecfca2800793e12" translate="yes" xml:space="preserve">
          <source>MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.</source>
          <target state="translated">MakeFromBytes 返回给定小二进制表示的字节的Int值。一个空的字节片参数代表0。</target>
        </trans-unit>
        <trans-unit id="04110b4029f3d51d7f1b1e32dfd59973aae981d8" translate="yes" xml:space="preserve">
          <source>MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown.</source>
          <target state="translated">MakeFromLiteral 回报 Go 字符串对应的整数、浮点、虚数、字符或字符串值。tok值必须是token.INT、token.FLOAT、token.IMAG、token.CHAR或token.STRING中的一种。最后的参数必须是0。如果文字串语法无效,结果是未知数。</target>
        </trans-unit>
        <trans-unit id="07a7a52634a41aa9116fcfbf959be30745aab340" translate="yes" xml:space="preserve">
          <source>MakeFunc</source>
          <target state="translated">MakeFunc</target>
        </trans-unit>
        <trans-unit id="643c1268f2628745bb74a74c0b6210fc3a37b52e" translate="yes" xml:space="preserve">
          <source>MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:</source>
          <target state="translated">MakeFunc返回一个给定类型的新函数,它封装了函数fn。当调用该新函数时,该函数将执行以下操作。</target>
        </trans-unit>
        <trans-unit id="e91507405a52b25c3084428772c7fd9dd85d29bc" translate="yes" xml:space="preserve">
          <source>MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown.</source>
          <target state="translated">MakeImag 返回 Complex 值 x*i;x 必须是 Int、Float 或 Unknown。如果x是未知值,结果是未知值。</target>
        </trans-unit>
        <trans-unit id="da6ba30b4b9d9da1cda2bb8d92f1cb545785138a" translate="yes" xml:space="preserve">
          <source>MakeInt64 returns the Int value for x.</source>
          <target state="translated">MakeInt64返回x的Int值。</target>
        </trans-unit>
        <trans-unit id="f32c29a01762bfefeedc6eb9373c057117a43683" translate="yes" xml:space="preserve">
          <source>MakeMap creates a new map with the specified type.</source>
          <target state="translated">MakeMap创建一个新的指定类型的地图。</target>
        </trans-unit>
        <trans-unit id="f52a4bb4c4b8bb40c53081e9faafbd87a3b197bc" translate="yes" xml:space="preserve">
          <source>MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.</source>
          <target state="translated">MakeMapWithSize创建一个具有指定类型和初始空间的新地图,大约有n个元素。</target>
        </trans-unit>
        <trans-unit id="ddd7ccbb39b9b3baa5ecbf90987fe0065249d556" translate="yes" xml:space="preserve">
          <source>MakeSeed returns a new random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55769617e91451b5769c2caeaf264e53ded13fa6" translate="yes" xml:space="preserve">
          <source>MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.</source>
          <target state="translated">MakeSlice为指定的片类型、长度和容量创建一个新的零初始化的片值。</target>
        </trans-unit>
        <trans-unit id="fbaf52cf63ee748130cb04d59e9e62d4763220eb" translate="yes" xml:space="preserve">
          <source>MakeString returns the String value for s.</source>
          <target state="translated">MakeString 返回 s 的字符串值。</target>
        </trans-unit>
        <trans-unit id="5e3fa6d0673feb64d51f64ca41937f6da75eff62" translate="yes" xml:space="preserve">
          <source>MakeTable</source>
          <target state="translated">MakeTable</target>
        </trans-unit>
        <trans-unit id="785bab6ccfcc81c98865184a96f5abfea960b9ee" translate="yes" xml:space="preserve">
          <source>MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.</source>
          <target state="translated">MakeTable 返回一个由指定多项式构造的表。这个Table的内容不能被修改。</target>
        </trans-unit>
        <trans-unit id="9a7cf77039092ac36f999962d307dd473ba79848" translate="yes" xml:space="preserve">
          <source>MakeUint64 returns the Int value for x.</source>
          <target state="translated">MakeUint64返回x的Int值。</target>
        </trans-unit>
        <trans-unit id="e3694e34668330687dd83b2555828d28784d9456" translate="yes" xml:space="preserve">
          <source>MakeUnknown returns the Unknown value.</source>
          <target state="translated">MakeUnknown返回未知值。</target>
        </trans-unit>
        <trans-unit id="fc2df9e4256f3cab4d6220a72b883983cc586bc1" translate="yes" xml:space="preserve">
          <source>MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant &amp;times; 2**exp, with 0.5 &amp;lt;= |mant| &amp;lt; 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.</source>
          <target state="translated">MantExp将x分解为其尾数和指数成分，并返回指数。如果提供了非nil mant参数，则将其值设置为x的尾数，其精度和舍入模式与x相同。分量满足x == mant&amp;times;2 ** exp，其中0.5 &amp;lt;= | mant | &amp;lt;1.0。使用nil参数调用MantExp是获得接收方指数的有效方法。</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="053e42c081459c8a8812cfba3b82d0d77adea8da" translate="yes" xml:space="preserve">
          <source>Map is a string-to-Var map variable that satisfies the Var interface.</source>
          <target state="translated">Map是一个满足Var接口的字符串到Var的映射变量。</target>
        </trans-unit>
        <trans-unit id="f35fa30552bf86b6a97457f5a529f46b1ec4ac90" translate="yes" xml:space="preserve">
          <source>Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.</source>
          <target state="translated">Map就像Go的map[interface{}]interface{}一样,但对于多个goroutine的并发使用是安全的,不需要额外的锁定或协调。加载、存储和删除都是以摊开的恒定时间运行的。</target>
        </trans-unit>
        <trans-unit id="a55357ddaf2509ac1bf72db741f5c0cb32477d6c" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.</source>
          <target state="translated">映射返回字节片s的副本,并根据映射函数修改其所有字符。如果映射返回一个负值,则该字符将从字节片中删除,而不会被替换。s和输出中的字符被解释为UTF-8编码的码点。</target>
        </trans-unit>
        <trans-unit id="0c9f196c46a54d96a050fd1d4b324297d8b6bbfd" translate="yes" xml:space="preserve">
          <source>Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.</source>
          <target state="translated">Map 返回字符串 s 的副本,并根据映射函数修改其所有字符。如果映射返回负值,则从字符串中删除该字符,不进行替换。</target>
        </trans-unit>
        <trans-unit id="4153ac6503fd2f26b78b101383b87a23ab8757a1" translate="yes" xml:space="preserve">
          <source>Map values are deeply equal when all of the following are true: they are both nil or both non-nil, they have the same length, and either they are the same map object or their corresponding keys (matched using Go equality) map to deeply equal values.</source>
          <target state="translated">当以下所有条件为真时,地图值是深度相等的:它们都是零或都是非零,它们有相同的长度,它们是同一个地图对象,或者它们的对应键(使用围棋平等匹配)映射到深度相等的值。</target>
        </trans-unit>
        <trans-unit id="ff4de2d02636ff0b35d7ac62c39c77c38ada9f83" translate="yes" xml:space="preserve">
          <source>Map values encode as JSON objects. The map's key type must either be a string, an integer type, or implement encoding.TextMarshaler. The map keys are sorted and used as JSON object keys by applying the following rules, subject to the UTF-8 coercion described for string values above:</source>
          <target state="translated">地图值编码为JSON对象。地图的键类型必须是字符串、整数类型或实现 encoding.TextMarshaler。通过应用以下规则对地图键进行排序,并将其作为JSON对象键使用,但须遵守上面为字符串值描述的UTF-8胁迫。</target>
        </trans-unit>
        <trans-unit id="b746be79a80992b182da84fae71887f2ec6be3ae" translate="yes" xml:space="preserve">
          <source>MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.</source>
          <target state="translated">MapIndex 返回与地图 v 中 key 相关联的值,如果 v 的 Kind 不是 Map,它就会惊慌失措。如果在地图中找不到key,或者v代表一个nil地图,它就返回零值。与Go中一样,key的值必须可以分配给map的key类型。</target>
        </trans-unit>
        <trans-unit id="8a8f96c2a60281e18fdf86af937035c625b23750" translate="yes" xml:space="preserve">
          <source>MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.</source>
          <target state="translated">MapKeys 返回一个包含地图中所有键的片断,顺序不详。如果v的Kind不是Map,它就会恐慌。如果v代表一个nil map,则返回一个空片断。</target>
        </trans-unit>
        <trans-unit id="393371509edfbb2648f262a9e6f9034fb677acf3" translate="yes" xml:space="preserve">
          <source>MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.</source>
          <target state="translated">MapOf 返回具有给定键和元素类型的地图类型。例如,如果k代表int,e代表字符串,MapOf(k,e)代表map[int]string。</target>
        </trans-unit>
        <trans-unit id="d868be238acb64c17c8f70f0fad5dbca2528fe1a" translate="yes" xml:space="preserve">
          <source>MapRange returns a range iterator for a map. It panics if v's Kind is not Map.</source>
          <target state="translated">MapRange 返回一个地图的范围迭代器。如果v的Kind不是Map,它就会恐慌。</target>
        </trans-unit>
        <trans-unit id="61f910b08995efdd96acb55eeb3536149a9ef35f" translate="yes" xml:space="preserve">
          <source>Mapping between XML elements and data structures is inherently flawed: an XML element is an order-dependent collection of anonymous values, while a data structure is an order-independent collection of named values. See package json for a textual representation more suitable to data structures.</source>
          <target state="translated">XML 元素和数据结构之间的映射存在固有的缺陷:XML 元素是一个依赖于顺序的匿名值集合,而数据结构是一个依赖于顺序的命名值集合。参见包json,以获得更适合数据结构的文本表示方式。</target>
        </trans-unit>
        <trans-unit id="2b32ea0b0909e5260b55a58bd4f84f53b5d1ee01" translate="yes" xml:space="preserve">
          <source>Maps are sent as an unsigned count followed by that many key, element pairs. Empty but non-nil maps are sent, so if the receiver has not allocated one already, one will always be allocated on receipt unless the transmitted map is nil and not at the top level.</source>
          <target state="translated">地图是以一个无符号数的形式发送的,后面跟着那么多的键、元素对。发送的地图是空的,但不是零,所以如果接收者还没有分配地图,那么在收到地图时总会分配一个,除非传输的地图是零,而且不是最高级别的。</target>
        </trans-unit>
        <trans-unit id="ea8cf739cc820968d208878224615030de7ce782" translate="yes" xml:space="preserve">
          <source>MarkComplete marks a package as complete.</source>
          <target state="translated">MarkComplete 标记一个包是完整的。</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="eb880bd9042393d95106d6336ca91dc7587c2469" translate="yes" xml:space="preserve">
          <source>Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="translated">Marshal将一个点转换为ANSI X9.62的4.3.6节中指定的非压缩形式。</target>
        </trans-unit>
        <trans-unit id="9a568ce91bc9dd658d20c975742fe8852b970117" translate="yes" xml:space="preserve">
          <source>Marshal converts a point on the curve into the uncompressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcb1e980e770758d048cdbf31965108d4392cbe" translate="yes" xml:space="preserve">
          <source>Marshal handles an array or slice by marshaling each of the elements. Marshal handles a pointer by marshaling the value it points at or, if the pointer is nil, by writing nothing. Marshal handles an interface value by marshaling the value it contains or, if the interface value is nil, by writing nothing. Marshal handles all other data by writing one or more XML elements containing the data.</source>
          <target state="translated">Marshal处理一个数组或分片时,会对每个元素进行marshaling。Marshal处理一个指针的方法是对它所指向的值进行marshaling,如果指针为零,则什么也不写。Marshal处理一个接口值的方法是对它所包含的值进行marshaling,如果接口值是nil,则什么也不写。Marshal通过写入一个或多个包含数据的XML元素来处理所有其他数据。</target>
        </trans-unit>
        <trans-unit id="62270c3791161d9e12b821a2dd5a09da76b7d939" translate="yes" xml:space="preserve">
          <source>Marshal returns the ASN.1 encoding of val.</source>
          <target state="translated">Marshal 返回 val 的 ASN.1 编码。</target>
        </trans-unit>
        <trans-unit id="d0688338eb6d31b2244e733d8a38556baae70f6c" translate="yes" xml:space="preserve">
          <source>Marshal returns the JSON encoding of v.</source>
          <target state="translated">Marshal返回v的JSON编码。</target>
        </trans-unit>
        <trans-unit id="fd91d49c812b62dbf02b368713f03ffdd50b3ad6" translate="yes" xml:space="preserve">
          <source>Marshal returns the XML encoding of v.</source>
          <target state="translated">Marshal返回v的XML编码。</target>
        </trans-unit>
        <trans-unit id="0de0f4cea1e586ddc2b14ecaaa41c4020891c164" translate="yes" xml:space="preserve">
          <source>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</source>
          <target state="translated">Marshal递归地遍历值v。如果遇到的值实现了Marshaler接口并且不是一个nil指针,Marshal就会调用它的MarshalJSON方法来生成JSON。如果没有MarshalJSON方法,但该值实现了encoding.TextMarshaler,Marshal就会调用它的MarshalText方法,并将结果编码为JSON字符串。严格来说,nil指针异常并不是必要的,而是模仿了UnmarshalJSON行为中类似的必要异常。</target>
        </trans-unit>
        <trans-unit id="fafaa1ebf620f3798cc6a8c58b669a7ea73fa6b9" translate="yes" xml:space="preserve">
          <source>Marshal will return an error if asked to marshal a channel, function, or map.</source>
          <target state="translated">如果要求Marshal对一个通道、函数或地图进行marshal,Marshal会返回一个错误。</target>
        </trans-unit>
        <trans-unit id="db453e34c5fbd8220b129af743f7150483dd7932" translate="yes" xml:space="preserve">
          <source>MarshalBinary encodes the receiver into a binary form and returns the result.</source>
          <target state="translated">MarshalBinary将接收器编码成二进制形式并返回结果。</target>
        </trans-unit>
        <trans-unit id="0bedf8f876a84577084ab2b16cacfd3254f063b2" translate="yes" xml:space="preserve">
          <source>MarshalBinary implements the encoding.BinaryMarshaler interface.</source>
          <target state="translated">MarshalBinary实现了encoding.BinaryMarshaler接口。</target>
        </trans-unit>
        <trans-unit id="b0dd910cac1cbbac9d43ce35c5c8bd02d8b6dc15" translate="yes" xml:space="preserve">
          <source>MarshalCompressed converts a point on the curve into the compressed form specified in section 4.3.6 of ANSI X9.62.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee53c721c287cd02dbf9f92c9f5e2a991f1f615d" translate="yes" xml:space="preserve">
          <source>MarshalECPrivateKey converts an EC private key to SEC 1, ASN.1 DER form.</source>
          <target state="translated">MarshalECPrivateKey将EC私钥转换为SEC 1、ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="f9e73b7909d7a048a7d6c9e44a0504b100446e17" translate="yes" xml:space="preserve">
          <source>MarshalIndent</source>
          <target state="translated">MarshalIndent</target>
        </trans-unit>
        <trans-unit id="42cea4e6f776e84fbd92d4a9f5ef1c3b218c54ea" translate="yes" xml:space="preserve">
          <source>MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.</source>
          <target state="translated">MarshalIndent与Marshal类似,但应用Indent来格式化输出。输出中的每一个JSON元素都将从一个新行开始,以前缀开始,然后根据缩进嵌套的方式,进行一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="b93c5c2e6a3ce1b1ffab83edfd3027b2f5a958ee" translate="yes" xml:space="preserve">
          <source>MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.</source>
          <target state="translated">MarshalIndent的工作原理与Marshal类似,但每个XML元素都从一个新的缩进行开始,该缩进行以前缀开始,并根据嵌套深度跟随一个或多个缩进副本。</target>
        </trans-unit>
        <trans-unit id="1fe8186b542a0c93fd906dfbf1d378366d66b83e" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface.</source>
          <target state="translated">MarshalJSON实现了json.Marshaler接口。</target>
        </trans-unit>
        <trans-unit id="34cafb57f3bf4f148de8715aea906ddd24ca5b67" translate="yes" xml:space="preserve">
          <source>MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalJSON实现了json.Marshaler接口。时间是RFC 3339格式的引号字符串,如果存在,则添加亚秒精度。</target>
        </trans-unit>
        <trans-unit id="79739908efedb1d030bbc1bed7fc419173d502bc" translate="yes" xml:space="preserve">
          <source>MarshalJSON returns m as the JSON encoding of m.</source>
          <target state="translated">MarshalJSON 返回 m 的 JSON 编码。</target>
        </trans-unit>
        <trans-unit id="dc6df497a7bc177e42838cf4d34e8a9fff8f37f9" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS #1, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c4c53b126d5e728f2103ee05aeb8456df06352" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PrivateKey converts an RSA private key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PrivateKey将RSA私钥转换为PKCS#1,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="679ae9ec5a41bfe29c2cb0674503ed9d5f0c3931" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS #1, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbb4afc98d66ecc773730ab53b2d3d25670dae3" translate="yes" xml:space="preserve">
          <source>MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS1PublicKey将RSA公钥转换为PKCS#1,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="45354407cae2db32eaa7718849355ec2165c982c" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts a private key to PKCS #8, ASN.1 DER form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5c14e75241b3422cb105f3219299fa62dfe8b0" translate="yes" xml:space="preserve">
          <source>MarshalPKCS8PrivateKey converts an RSA private key to PKCS#8, ASN.1 DER form.</source>
          <target state="translated">MarshalPKCS8PrivateKey将RSA私钥转换为PKCS#8,ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="7c79ebdd42b60d7be91053c9a1161ea6d5ebbab9" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form.</source>
          <target state="translated">MarshalPKIXPublicKey将公钥转换为PKIX、ASN.1 DER形式。</target>
        </trans-unit>
        <trans-unit id="f11f550d1b6c7d3b4aec2299c3db3d8ce95b07ef" translate="yes" xml:space="preserve">
          <source>MarshalPKIXPublicKey converts a public key to PKIX, ASN.1 DER form. The encoded public key is a SubjectPublicKeyInfo structure (see RFC 5280, Section 4.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def0005fff87679bf808d28ec17c1164d884c779" translate="yes" xml:space="preserve">
          <source>MarshalText encodes the receiver into UTF-8-encoded text and returns the result.</source>
          <target state="translated">MarshalText将接收器编码成UTF-8编码的文本,并返回结果。</target>
        </trans-unit>
        <trans-unit id="0e6ec969b789b52d1c5120ea85c9ad182259f168" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。</target>
        </trans-unit>
        <trans-unit id="e9f45c26a4b805caf1ff0c7f133453fe1405ea6f" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。只有Float值被Marshal(全精度),其他属性如精度或准确度被忽略。</target>
        </trans-unit>
        <trans-unit id="1fbe6f2d906b1d5948fbd9851ef463bba4786bcb" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。编码与String返回的编码相同,但有一个例外。当len(ip)为零时,它返回一个空的片断。</target>
        </trans-unit>
        <trans-unit id="83f43718a3654277944df9768c5af959f91ebe45" translate="yes" xml:space="preserve">
          <source>MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.</source>
          <target state="translated">MarshalText实现了encoding.TextMarshaler接口。时间的格式为RFC 3339格式,如果存在,则添加亚秒精度。</target>
        </trans-unit>
        <trans-unit id="14fcaccd265e76bda57404dd966d33311a65ffc3" translate="yes" xml:space="preserve">
          <source>MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.</source>
          <target state="translated">MarshalWithParams允许为顶层元素指定字段参数。参数的形式与字段标签相同。</target>
        </trans-unit>
        <trans-unit id="34052c5ea18ea7495e24eea4a4d137cecba4872c" translate="yes" xml:space="preserve">
          <source>MarshalXML encodes the receiver as zero or more XML elements. By convention, arrays or slices are typically encoded as a sequence of elements, one per entry. Using start as the element tag is not required, but doing so will enable Unmarshal to match the XML elements to the correct struct field. One common implementation strategy is to construct a separate value with a layout corresponding to the desired XML and then to encode it using e.EncodeElement. Another common strategy is to use repeated calls to e.EncodeToken to generate the XML output one token at a time. The sequence of encoded tokens must make up zero or more valid XML elements.</source>
          <target state="translated">MarshalXML将接收器编码为零或多个XML元素。按照惯例,数组或切片通常被编码为一个元素序列,每个条目一个。使用start作为元素标签并不是必须的,但这样做可以使Unmarshal将XML元素匹配到正确的结构域。一个常见的实现策略是构造一个单独的值,其布局对应于所需的 XML,然后使用 e.EncodeElement 对其进行编码。另一种常见的策略是使用对e.EncodeToken的重复调用,每次生成一个标记的XML输出。编码后的令牌序列必须由零个或多个有效的XML元素组成。</target>
        </trans-unit>
        <trans-unit id="41210996386655a5e9f720c4f9e735ef866f35cb" translate="yes" xml:space="preserve">
          <source>MarshalXMLAttr returns an XML attribute with the encoded value of the receiver. Using name as the attribute name is not required, but doing so will enable Unmarshal to match the attribute to the correct struct field. If MarshalXMLAttr returns the zero attribute Attr{}, no attribute will be generated in the output. MarshalXMLAttr is used only for struct fields with the &quot;attr&quot; option in the field tag.</source>
          <target state="translated">MarshalXMLAttr返回一个XML属性,其中包含接收器的编码值。使用name作为属性名并不是必须的,但这样做可以使Unmarshal将属性匹配到正确的结构域。如果MarshalXMLAttr返回零属性Attr{},则输出中不会生成任何属性。MarshalXMLAttr仅用于字段标签中带有 &quot;attr &quot;选项的结构体字段。</target>
        </trans-unit>
        <trans-unit id="18fd048394e569d8195a81313b9e64f2eba7ee35" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.</source>
          <target state="translated">Marshaler是由对象实现的接口,它可以将自己混成有效的XML元素。</target>
        </trans-unit>
        <trans-unit id="47a2664e5f80a08312afe3946a74993c99143c6d" translate="yes" xml:space="preserve">
          <source>Marshaler is the interface implemented by types that can marshal themselves into valid JSON.</source>
          <target state="translated">Marshaler是由类型实现的接口,它可以将自己的类型marshal成有效的JSON。</target>
        </trans-unit>
        <trans-unit id="4a00ca7b38dd0506417989c16c2542f21f4d7c58" translate="yes" xml:space="preserve">
          <source>MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.</source>
          <target state="translated">MarshalerAttr是由对象实现的接口,这些对象可以将自己的marshal变成有效的XML属性。</target>
        </trans-unit>
        <trans-unit id="5c61140e5006502f101ce6ee77324538231946bb" translate="yes" xml:space="preserve">
          <source>Mask returns the result of masking the IP address ip with mask.</source>
          <target state="translated">Mask返回用mask屏蔽ip地址的结果。</target>
        </trans-unit>
        <trans-unit id="0335207f5e840d81afa158c6c2bb6e3fa02653b4" translate="yes" xml:space="preserve">
          <source>Match</source>
          <target state="translated">Match</target>
        </trans-unit>
        <trans-unit id="b841b8491dab0dabb8feb21367e059b0624fa3bb" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell file name pattern. The pattern syntax is:</source>
          <target state="translated">Match报告name是否符合shell文件名模式。该模式的语法是:</target>
        </trans-unit>
        <trans-unit id="65238f3fd69244258d0fe7834a55d41fd9fdb4b5" translate="yes" xml:space="preserve">
          <source>Match reports whether name matches the shell pattern. The pattern syntax is:</source>
          <target state="translated">Match报告name是否符合shell模式。该模式的语法是:</target>
        </trans-unit>
        <trans-unit id="5f5677ee8a35a029aa3e90c1d56b65878192d3b4" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">Match报告字节片b是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="269393d413e09f2ec5ba2e6fbdd662834a23a90b" translate="yes" xml:space="preserve">
          <source>Match reports whether the byte slice b contains any match of the regular expression re.</source>
          <target state="translated">Match报告字节片断b是否包含正则表达式re的任何匹配。</target>
        </trans-unit>
        <trans-unit id="188538220b1d59de0ef20f48b5e9a854e7a08bec" translate="yes" xml:space="preserve">
          <source>Match requires pattern to match all of name, not just a substring. The only possible returned error is ErrBadPattern, when pattern is malformed.</source>
          <target state="translated">Match 要求 pattern 匹配所有的 name,而不仅仅是一个子串。唯一可能返回的错误是ErrBadPattern,当pattern是畸形的。</target>
        </trans-unit>
        <trans-unit id="fb78f24b3584ab26ff8d868ae02c24bc3e7a84f8" translate="yes" xml:space="preserve">
          <source>MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth.</source>
          <target state="translated">MatchEmptyWidth报告该指令是否匹配前后符文之间的空字符串。只有当i.Op ==InstEmptyWidth时,才应该调用它。</target>
        </trans-unit>
        <trans-unit id="766801810391656eb72b30e1a620adc09dc91643" translate="yes" xml:space="preserve">
          <source>MatchFile considers the name of the file and may use ctxt.OpenFile to read some or all of the file's content.</source>
          <target state="translated">MatchFile考虑了文件的名称,并可能使用ctxt.OpenFile来读取文件的部分或全部内容。</target>
        </trans-unit>
        <trans-unit id="32f23226c3beda09b3f84dfe037d9c9ada013d83" translate="yes" xml:space="preserve">
          <source>MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory.</source>
          <target state="translated">MatchFile报告给定目录中给定名称的文件是否与上下文相匹配,是否会被包含在该目录的ImportDir创建的包中。</target>
        </trans-unit>
        <trans-unit id="230e93d3f899e27c4d81d89f3ff53b1eca08bb37" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchReader报告RuneReader返回的文本是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="25c8a8e56012833544924619010cf5721432e9ab" translate="yes" xml:space="preserve">
          <source>MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.</source>
          <target state="translated">MatchReader报告RuneReader返回的文本是否包含任何匹配的正则表达式re。</target>
        </trans-unit>
        <trans-unit id="da28fa625630bc6b02e3ddab6dad208f72cd40bb" translate="yes" xml:space="preserve">
          <source>MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRune报告指令是否匹配(并消耗)r,只有当i.Op ==InstRune时,才应该调用它。</target>
        </trans-unit>
        <trans-unit id="c488501e6169e99f4e3f5cf4b601fce5b1d18d9c" translate="yes" xml:space="preserve">
          <source>MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune.</source>
          <target state="translated">MatchRunePos检查指令是否匹配(并消耗)r,如果匹配,MatchRunePos返回匹配符文对的索引(或者,当len(i.Rune)==1时,返回符文单体)。如果没有,MatchRunePos返回-1。MatchRunePos只应在i.Op ==InstRune时调用。</target>
        </trans-unit>
        <trans-unit id="c78293f6444063ae02b61b422c861a74ea5c0992" translate="yes" xml:space="preserve">
          <source>MatchString</source>
          <target state="translated">MatchString</target>
        </trans-unit>
        <trans-unit id="16440a205b6632a6f9ce394e96f4e30da62834e6" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.</source>
          <target state="translated">MatchString报告字符串s是否包含任何匹配的正则表达式模式。更复杂的查询需要使用编译和完整的Regexp接口。</target>
        </trans-unit>
        <trans-unit id="0b53f246428ae463a3e54d71ff6883543bf5e6b2" translate="yes" xml:space="preserve">
          <source>MatchString reports whether the string s contains any match of the regular expression re.</source>
          <target state="translated">MatchString报告字符串s是否包含正则表达式re的任何匹配。</target>
        </trans-unit>
        <trans-unit id="386301aac4b9205f957c7e2aded15dd3a3170a4d" translate="yes" xml:space="preserve">
          <source>Mathematical constants.</source>
          <target state="translated">数学常数。</target>
        </trans-unit>
        <trans-unit id="e9339d8c2f10a09643bf33b4b293ddbf19fb634d" translate="yes" xml:space="preserve">
          <source>Mathematical interval notation such as [0, n) is used throughout the documentation for this package.</source>
          <target state="translated">在这个软件包的整个文档中使用了数学区间符号,如[0,n)。</target>
        </trans-unit>
        <trans-unit id="b64028b7ef9651f5e0c9bf08d57c40c964fb143d" translate="yes" xml:space="preserve">
          <source>Max returns the larger of x or y.</source>
          <target state="translated">最大值返回x或y中的较大值。</target>
        </trans-unit>
        <trans-unit id="6c955f951ae2dab8e6f5e54e3a98c7139c879b48" translate="yes" xml:space="preserve">
          <source>MaxBase is the largest number base accepted for string conversions.</source>
          <target state="translated">MaxBase是字符串转换所接受的最大数基。</target>
        </trans-unit>
        <trans-unit id="d9d067026e10599a63c5386be336904174743560" translate="yes" xml:space="preserve">
          <source>MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called.</source>
          <target state="translated">MaxBytesReader类似于io.LimitReader,但目的是为了限制传入请求体的大小。与io.LimitReader相反,MaxBytesReader的结果是一个ReadCloser,对于超出限制的Read返回一个非EOF错误,并在其Close方法被调用时关闭底层阅读器。</target>
        </trans-unit>
        <trans-unit id="739ec125397a0373ef46f377effdf6be903c6fd8" translate="yes" xml:space="preserve">
          <source>MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources.</source>
          <target state="translated">MaxBytesReader可以防止客户端意外或恶意发送大量请求,浪费服务器资源。</target>
        </trans-unit>
        <trans-unit id="61be69d33fec3be907f4ea6e04af100d85f7675e" translate="yes" xml:space="preserve">
          <source>MaxCap walks the regexp to find the maximum capture index.</source>
          <target state="translated">MaxCap走过regexp,找到最大的捕获指数。</target>
        </trans-unit>
        <trans-unit id="df7b72cdcf2650790c955b9e993a0a0c2fbe25b4" translate="yes" xml:space="preserve">
          <source>MaxEncodedLen returns the maximum length of an encoding of n source bytes.</source>
          <target state="translated">MaxEncodedLen 返回 n 个源字节的最大编码长度。</target>
        </trans-unit>
        <trans-unit id="89c65689a7af2cc891fbeafce261f8df625c4303" translate="yes" xml:space="preserve">
          <source>MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.</source>
          <target state="translated">MaxVarintLenN是一个变异编码的N位整数的最大长度。</target>
        </trans-unit>
        <trans-unit id="1157d0585a10f5f650da7952c06f96ac83134419" translate="yes" xml:space="preserve">
          <source>MemProfile returns a profile of memory allocated and freed per allocation site.</source>
          <target state="translated">MemProfile返回每个分配站点分配和释放的内存的配置文件。</target>
        </trans-unit>
        <trans-unit id="d8d6b923c77de71210013c81589eaf2c4fe10654" translate="yes" xml:space="preserve">
          <source>MemProfile returns n, the number of records in the current memory profile. If len(p) &amp;gt;= n, MemProfile copies the profile into p and returns n, true. If len(p) &amp;lt; n, MemProfile does not change p and returns n, false.</source>
          <target state="translated">MemProfile返回n，即当前内存配置文件中的记录数。如果len（p）&amp;gt; = n，则MemProfile将配置文件复制到p中并返回n，true。如果len（p）&amp;lt;n，则MemProfile不会更改p并返回n，否则为false。</target>
        </trans-unit>
        <trans-unit id="c013eb0f98db13dab8418c5c8a82f2ae00733c42" translate="yes" xml:space="preserve">
          <source>MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.</source>
          <target state="translated">MemProfileRate控制内存配置文件中记录和报告的内存分配的分数。剖析器的目标是对每分配一个MemProfileRate字节的平均分配进行采样。</target>
        </trans-unit>
        <trans-unit id="e7ca02f761fad2cef95bf22ec3a49a7a10d4d7ec" translate="yes" xml:space="preserve">
          <source>MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.</source>
          <target state="translated">MemString返回r.AllocedBytesPerOp和r.AllocsPerOp,格式与'go test'相同。</target>
        </trans-unit>
        <trans-unit id="5885c324e2b06a6d3881d7dca39a2a9515c8b84e" translate="yes" xml:space="preserve">
          <source>MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number.</source>
          <target state="translated">MergeLine 将一行与下一行合并。它类似于用空格代替行末的换行符(不改变剩余的偏移量)。要获得行号,请参考例如 Position.Line。如果给定一个无效的行号,MergeLine会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="c56ee5f274246d4907a3f8792aa47b70201e2839" translate="yes" xml:space="preserve">
          <source>MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.</source>
          <target state="translated">MergePackageFiles通过合并属于一个包的文件的AST来创建一个文件AST。模式标志控制合并行为。</target>
        </trans-unit>
        <trans-unit id="7f6f0438a1b28dd75bfa1675a817c685d6ecf309" translate="yes" xml:space="preserve">
          <source>Method represents a single method.</source>
          <target state="translated">方法代表一个单一的方法。</target>
        </trans-unit>
        <trans-unit id="d5cc6ded0a12c1ea7e555fe80a4dd907a9326b65" translate="yes" xml:space="preserve">
          <source>Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.</source>
          <target state="translated">方法返回一个对应于v的第i'th方法的函数值。在返回函数上的Call的参数不应包括接收者,返回的函数将始终使用v作为接收者。如果i超出范围或者v是一个nil接口值,方法就会恐慌。</target>
        </trans-unit>
        <trans-unit id="8580bc7cf729ccd2e220561b0a2aa0093af75313" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id.</source>
          <target state="translated">方法为0 &amp;lt;= i &amp;lt;t.NumMethods（）返回接口t的第i个方法。这些方法按其唯一ID排序。</target>
        </trans-unit>
        <trans-unit id="e73d31c50554a72b3457fac0045f98cc3b8b72de" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of interface t for 0 &amp;lt;= i &amp;lt; t.NumMethods(). The methods are ordered by their unique Id. The interface must have been completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5919064169d4fa2dfa670c5cd1d31fe4f5ec77" translate="yes" xml:space="preserve">
          <source>Method returns the i'th method of named type t for 0 &amp;lt;= i &amp;lt; t.NumMethods().</source>
          <target state="translated">方法返回0 &amp;lt;= i &amp;lt;t.NumMethods（）的第i个命名类型为t的方法。</target>
        </trans-unit>
        <trans-unit id="7b406879ef1e276f5ac32d320c19bb15ff9ced44" translate="yes" xml:space="preserve">
          <source>MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.</source>
          <target state="translated">MethodByName返回一个与给定名称的v的方法相对应的函数值。返回函数的 Call 的参数不应包括接收器;返回的函数将始终使用 v 作为接收器。如果没有找到方法,则返回零值。</target>
        </trans-unit>
        <trans-unit id="1995bb7d8a495c29ba7a59b0b373d66ee1f82142" translate="yes" xml:space="preserve">
          <source>MethodSet</source>
          <target state="translated">MethodSet</target>
        </trans-unit>
        <trans-unit id="c5e9a1bdc9129c6b25b91c69272ee11aa65ae4ac" translate="yes" xml:space="preserve">
          <source>Methods of this form typically return the incoming receiver as well, to enable simple call chaining.</source>
          <target state="translated">这种形式的方法通常也会返回接收方,以实现简单的呼叫链。</target>
        </trans-unit>
        <trans-unit id="68e37169f0406f89039a63dc143d5a05fc9b5510" translate="yes" xml:space="preserve">
          <source>Methods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x:</source>
          <target state="translated">不需要传递结果值的方法(例如,Int.Sign),只需返回结果即可。在这种情况下,接收者通常是第一个操作数,名为x。</target>
        </trans-unit>
        <trans-unit id="ae0ec4a01266d62782eafe6da2c5652e2035cd23" translate="yes" xml:space="preserve">
          <source>Metric key format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7255f6144e583d2f9b057070f13f8273f6bf2d" translate="yes" xml:space="preserve">
          <source>Metrics are designated by a string key, rather than, for example, a field name in a struct. The full list of supported metrics is always available in the slice of Descriptions returned by All. Each Description also includes useful information about the metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594fd92ee6be7b72c6f8d9451d2a9f9e3bae51ed" translate="yes" xml:space="preserve">
          <source>Microseconds returns the duration as an integer microsecond count.</source>
          <target state="translated">Microseconds 以整数微秒数的形式返回持续时间。</target>
        </trans-unit>
        <trans-unit id="c825c82257bdcbc1a135579145266c6ee484713a" translate="yes" xml:space="preserve">
          <source>Milliseconds returns the duration as an integer millisecond count.</source>
          <target state="translated">Milliseconds 返回整数毫秒的持续时间。</target>
        </trans-unit>
        <trans-unit id="d4a6fe67a8f15c1c894bf05225db6c07db7dc926" translate="yes" xml:space="preserve">
          <source>Min returns the smaller of x or y.</source>
          <target state="translated">Min返回x或y中的较小值。</target>
        </trans-unit>
        <trans-unit id="dacfaba796bce8b807113e726ae0618041c980f0" translate="yes" xml:space="preserve">
          <source>MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf.</source>
          <target state="translated">MinPrec 返回精确表示 x 所需的最小精度(即 x.SetPrec(prec)开始四舍五入之前的最小prec)。对于|x| ==0和|x| ==Inf,结果为0。</target>
        </trans-unit>
        <trans-unit id="b959e8418a57efc341ef2ea80360e0eee71f265e" translate="yes" xml:space="preserve">
          <source>MinRead is the minimum slice size passed to a Read call by Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond what is required to hold the contents of r, ReadFrom will not grow the underlying buffer.</source>
          <target state="translated">MinRead是Buffer.ReadFrom传递给Read调用的最小分片大小。只要Buffer的MinRead字节数至少超过了容纳r内容所需的字节数,ReadFrom就不会增长底层缓冲区。</target>
        </trans-unit>
        <trans-unit id="ba682b9edf600874d186945b125535bdb2fd2d00" translate="yes" xml:space="preserve">
          <source>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</source>
          <target state="translated">Minute 返回t指定的小时内的分钟偏移量,范围为[0,59]。</target>
        </trans-unit>
        <trans-unit id="f75dd7f0b206dbae82a8f8f0b7023bff54f3a266" translate="yes" xml:space="preserve">
          <source>Minutes returns the duration as a floating point number of minutes.</source>
          <target state="translated">Minutes(分钟)返回浮点数的分钟数。</target>
        </trans-unit>
        <trans-unit id="eb3dbdbaa825e8d8a44607bf8d9e0b1911e69e12" translate="yes" xml:space="preserve">
          <source>MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type.</source>
          <target state="translated">如果V实现了T,则MissingMethod返回(nil,false),否则返回T所需要的缺失的方法,以及它是否缺失或只是有错误的类型。</target>
        </trans-unit>
        <trans-unit id="37de4657eb0dc5b3413cb095b60f3d8129f6593f" translate="yes" xml:space="preserve">
          <source>Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError.</source>
          <target state="translated">Mkdir用指定的名称和权限位(在umask之前)创建一个新目录。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="677ef1c770313b12ac646270f84a792125bb5633" translate="yes" xml:space="preserve">
          <source>MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.</source>
          <target state="translated">MkdirAll 创建一个名为 path 的目录,以及任何必要的父目录,然后返回 nil,否则返回错误。权限位perm(在umask之前)用于MkdirAll创建的所有目录。如果path已经是一个目录,MkdirAll什么也不做,返回nil。</target>
        </trans-unit>
        <trans-unit id="69abe658c607f76904840b22f129f99c5cdd5602" translate="yes" xml:space="preserve">
          <source>MkdirTemp</source>
          <target state="translated">MkdirTemp</target>
        </trans-unit>
        <trans-unit id="7a5b7f37aa4dbbfd95b5cb948d3603090e4e4163" translate="yes" xml:space="preserve">
          <source>MkdirTemp (Suffix)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d9ed356acc6188361ff1f707194945a55386da" translate="yes" xml:space="preserve">
          <source>MkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a &quot;*&quot;, the random string replaces the last &quot;*&quot; instead. If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f388dbfb78ec3e8821ae0844a947cecd488dd5ff" translate="yes" xml:space="preserve">
          <source>Mod</source>
          <target state="translated">Mod</target>
        </trans-unit>
        <trans-unit id="373154d6ec87032b198bd3426fdb98b629297d1b" translate="yes" xml:space="preserve">
          <source>Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.</source>
          <target state="translated">Mod返回x/y的浮点余数。结果的大小小于y,且其符号与x一致。</target>
        </trans-unit>
        <trans-unit id="f2b25579075ef3b96af2a2e04dfbe27a4023e7c3" translate="yes" xml:space="preserve">
          <source>Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.</source>
          <target state="translated">Mod返回r中的点q,使得p.X-q.X是r的宽度的倍数,p.Y-q.Y是r的高度的倍数。</target>
        </trans-unit>
        <trans-unit id="5301dec2851eeeadb9f8edd3bcc14178a7cc1eac" translate="yes" xml:space="preserve">
          <source>Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details.</source>
          <target state="translated">Mod将z设为y !=0的模数x%y,并返回z。如果y ==0,则会发生按零除法的运行时恐慌。Mod 实现了欧氏模数 (与 Go 不同);更多细节请参见 DivMod。</target>
        </trans-unit>
        <trans-unit id="6d74b87ee55add7bade81d22a2a4510010f96ac8" translate="yes" xml:space="preserve">
          <source>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring ℤ/nℤ. In this case, z is unchanged and the return value is nil.</source>
          <target state="translated">ModInverse 将 z 设为 g 在环 ℤ/nℤ 中的乘法逆,并返回 z。如果 g 和 n 不是相对质数,则 g 在环 ℤ/nℤ 中没有乘法逆。在这种情况下,z不变,返回值为nil。</target>
        </trans-unit>
        <trans-unit id="7a4fd0d385cd06f73e61243a029e76aa018a4f23" translate="yes" xml:space="preserve">
          <source>ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer.</source>
          <target state="translated">ModSqrt 设 z 为 x mod p 的平方根,如果存在这样的平方根,则返回 z。模数 p 必须是奇数素数。如果x不是平方模p,ModSqrt将z保持不变并返回nil。如果p不是奇数整数,这个函数就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="aac634faa69d653814bcee88f0a5dfc61028be1b" translate="yes" xml:space="preserve">
          <source>ModTime returns the modification time in UTC using the legacy ModifiedDate and ModifiedTime fields.</source>
          <target state="translated">ModTime使用传统的ModifiedDate和ModifiedTime字段返回以UTC为单位的修改时间。</target>
        </trans-unit>
        <trans-unit id="aa00a628811be04815f4dd62095833b576cd8722" translate="yes" xml:space="preserve">
          <source>Mode returns the permission and mode bits for the FileHeader.</source>
          <target state="translated">Mode 返回 FileHeader 的权限和模式位。</target>
        </trans-unit>
        <trans-unit id="28a0f960b89726a468e14a8ebdf922a21170bc22" translate="yes" xml:space="preserve">
          <source>Mode returns the rounding mode of x.</source>
          <target state="translated">Mode返回x的取整模式。</target>
        </trans-unit>
        <trans-unit id="6298c555b80608e54cb786bb4e651a115a6841d0" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New and NewFromFiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4ea19087de0202d8e6a728b310de2dbb997d4d" translate="yes" xml:space="preserve">
          <source>Mode values control the operation of New.</source>
          <target state="translated">模式值控制New的操作。</target>
        </trans-unit>
        <trans-unit id="ee5a2d9bea8822761c2af443e30dd8b140094e31" translate="yes" xml:space="preserve">
          <source>Model can convert any Color to one from its own color model. The conversion may be lossy.</source>
          <target state="translated">模型可以将任何颜色转换为自己的颜色模型。转换可能是有损的。</target>
        </trans-unit>
        <trans-unit id="0b1b5b05fec2cd6d8e78c93f5a64f37706828f50" translate="yes" xml:space="preserve">
          <source>ModelFunc returns a Model that invokes f to implement the conversion.</source>
          <target state="translated">ModelFunc 返回一个调用 f 来实现转换的 Model。</target>
        </trans-unit>
        <trans-unit id="5361e7791528a917952293ec5274927cfb3ce5f8" translate="yes" xml:space="preserve">
          <source>Models for the standard color types.</source>
          <target state="translated">标准颜色类型的模型。</target>
        </trans-unit>
        <trans-unit id="4ab1036aa9ff79a5be9e4d8141cfacd5fbaebbcc" translate="yes" xml:space="preserve">
          <source>Modf</source>
          <target state="translated">Modf</target>
        </trans-unit>
        <trans-unit id="e56d540b050862c318d1aab05d9e382cf0a4c4af" translate="yes" xml:space="preserve">
          <source>Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.</source>
          <target state="translated">Modf返回与f相加的整数和小数浮点数,两个值的符号都与f相同。</target>
        </trans-unit>
        <trans-unit id="c8fdb64fd7614b420c244d4e876ef3defb57abcc" translate="yes" xml:space="preserve">
          <source>Modular exponentation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="translated">特定大小的输入的模块化指数化不是密码学上的恒时操作。</target>
        </trans-unit>
        <trans-unit id="69af563fc3d8f6971f904cbb0080c2ef55ec0b2c" translate="yes" xml:space="preserve">
          <source>Modular exponentiation of inputs of a particular size is not a cryptographically constant-time operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd5487e8328e8658b359aa63c39e650ee5e1172" translate="yes" xml:space="preserve">
          <source>Module represents a module.</source>
          <target state="translated">模块代表一个模块。</target>
        </trans-unit>
        <trans-unit id="b1156729972d424016ec9426afb303f681b9f79f" translate="yes" xml:space="preserve">
          <source>Monotonic Clocks</source>
          <target state="translated">单调钟</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="66f2529dffac9fbc9ec633022a5f8b0bedc8c37f" translate="yes" xml:space="preserve">
          <source>Month returns the month of the year specified by t.</source>
          <target state="translated">Month 返回由 t 指定的年份的月份。</target>
        </trans-unit>
        <trans-unit id="668403e4d2bd4eddcb9aed021f2a174eb200dc88" translate="yes" xml:space="preserve">
          <source>More control over the server's behavior is available by creating a custom Server:</source>
          <target state="translated">通过创建自定义服务器,可以对服务器的行为进行更多的控制。</target>
        </trans-unit>
        <trans-unit id="85e92ae26cba75c5b6d8d17d26d228885ce889bf" translate="yes" xml:space="preserve">
          <source>More intricate examples appear below.</source>
          <target state="translated">更复杂的例子出现在下面。</target>
        </trans-unit>
        <trans-unit id="544eaf68f34e5f73c2388e2ae8096fe2204e2585" translate="yes" xml:space="preserve">
          <source>More reports whether there is another element in the current array or object being parsed.</source>
          <target state="translated">更多报告当前数组或正在解析的对象中是否有另一个元素。</target>
        </trans-unit>
        <trans-unit id="90d58f1e96850d37632fc55c5c016f2a97fe1679" translate="yes" xml:space="preserve">
          <source>Most applications should not use the cipher suites in this list, and should only use those returned by CipherSuites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3ee8adfe02375a24e073f00bd7e8a1f885bbc4" translate="yes" xml:space="preserve">
          <source>Most callers should instead use Open, which transparently decompresses data and verifies checksums.</source>
          <target state="translated">大多数调用者应该使用Open,它可以透明地解压数据并验证校验和。</target>
        </trans-unit>
        <trans-unit id="3646fecc5107fd2c20aa969acb21a6f56c99b136" translate="yes" xml:space="preserve">
          <source>Most clients are better served by the more efficient ReadDir method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204dcf13599d817427dd2073f0e35f29dec05bc1" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling GoroutineProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用GoroutineProfile。</target>
        </trans-unit>
        <trans-unit id="2d4c0e8a354401dd8233b4356c1a0bfb3bef2533" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling MutexProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用MutexProfile。</target>
        </trans-unit>
        <trans-unit id="fd55cd96fc64e1ee33e5ec28f8d3ef1539755bd8" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包,而不是直接调用ThreadCreateProfile。</target>
        </trans-unit>
        <trans-unit id="646d3b37e5e676f43944b0bc1ef49ce31304c768" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly.</source>
          <target state="translated">大多数客户端应该使用runtime/pprof包或测试包的-test.blockprofile标志,而不是直接调用BlockProfile。</target>
        </trans-unit>
        <trans-unit id="fb5152386c9af905d8957add4efa5a79dbea3046" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包或测试包的-test.cpuprofile标志,而不是直接调用SetCPUProfileRate。</target>
        </trans-unit>
        <trans-unit id="cc35c049e953a9f16068abcc035a22ebd5b44d39" translate="yes" xml:space="preserve">
          <source>Most clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly.</source>
          <target state="translated">大多数客户端应该使用运行时/pprof包或测试包的-test.memprofile标志,而不是直接调用MemProfile。</target>
        </trans-unit>
        <trans-unit id="4ec46c99b7f54aae4ce499a3028a52ae6552a566" translate="yes" xml:space="preserve">
          <source>Most code should use package sql.</source>
          <target state="translated">大多数代码应该使用包sql。</target>
        </trans-unit>
        <trans-unit id="19ad74392792ed9739e1d28d7638006df3165986" translate="yes" xml:space="preserve">
          <source>Most users will open a database via a driver-specific connection helper function that returns a *DB. No database drivers are included in the Go standard library. See &lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt; for a list of third-party drivers.</source>
          <target state="translated">大多数用户将通过特定于驱动程序的连接帮助程序函数来打开数据库，该函数返回* DB。Go标准库中没有数据库驱动程序。有关第三方驱动程序的列表，请参见&lt;a href=&quot;https://golang.org/s/sqldrivers&quot;&gt;https://golang.org/s/sqldrivers&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f91f314aaefda0dd307d2029c302761e8e26460" translate="yes" xml:space="preserve">
          <source>Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ed633024d8dc0b448fbe281ca6b8177fe27c56" translate="yes" xml:space="preserve">
          <source>Move moves n % r.Len() elements backward (n &amp;lt; 0) or forward (n &amp;gt;= 0) in the ring and returns that ring element. r must not be empty.</source>
          <target state="translated">Move将n％r.Len（）元素在环中向后（n &amp;lt;0）或向前（n&amp;gt; = 0）移动，并返回该环元素。r不能为空。</target>
        </trans-unit>
        <trans-unit id="9b69d844fd11e170cd47ef8ff2a97178038b339b" translate="yes" xml:space="preserve">
          <source>MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveAfter将元素e移动到mark之后的新位置。如果e或mark不是l的元素,或者e==mark,则列表不会被修改。元素和mark不能为零。</target>
        </trans-unit>
        <trans-unit id="33d96c6050800194a8407c20b5ca64f6846c7299" translate="yes" xml:space="preserve">
          <source>MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.</source>
          <target state="translated">MoveBefore将元素e移动到mark之前的新位置。如果e或mark不是l的元素,或者e==mark,则列表不会被修改。元素和mark不能为零。</target>
        </trans-unit>
        <trans-unit id="48e25efa9d98fcd9ecb09e7fe7ed87eb426e273a" translate="yes" xml:space="preserve">
          <source>MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToBack将元素e移动到列表l的后面,如果e不是l的元素,则列表不会被修改。元素不能是nil。</target>
        </trans-unit>
        <trans-unit id="6f362d110c32c4c4500cf8d4c490f31132fbb839" translate="yes" xml:space="preserve">
          <source>MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil.</source>
          <target state="translated">MoveToFront将元素e移动到列表l的前面,如果e不是l的元素,则列表不会被修改。元素不能是nil。</target>
        </trans-unit>
        <trans-unit id="90114025b275cbc4bcd8b562c1a58b937341fdfb" translate="yes" xml:space="preserve">
          <source>Mul returns the full-width product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul返回x和y的全宽乘积,(hi,lo)=x*y,乘积位的上半部分在hi中返回,下半部分在lo中返回。(hi,lo)=x*y,乘积位的上半部分在hi中返回,下半部分在lo中返回。</target>
        </trans-unit>
        <trans-unit id="26a6e266f6cfb3f2f503215e9850aa02f8f9da06" translate="yes" xml:space="preserve">
          <source>Mul returns the vector p*k.</source>
          <target state="translated">Mul返回向量p*k。</target>
        </trans-unit>
        <trans-unit id="da7ddc591d70c1b455e617b48abf92f18b455b2b" translate="yes" xml:space="preserve">
          <source>Mul sets z to the product x*y and returns z.</source>
          <target state="translated">Mul将z设为乘积x*y并返回z。</target>
        </trans-unit>
        <trans-unit id="77d0b9f0608c4902ed59d2c704e92843cbc28318" translate="yes" xml:space="preserve">
          <source>Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case.</source>
          <target state="translated">Mul将z设置为四舍五入的乘积x*y并返回z。精度、四舍五入和准确度报告与 Add 相同。如果一个操作数为零,而另一个操作数为无穷大,Mul会用ErrNaN恐慌。在这种情况下,z 的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="b861b19bddbd0bc8bab01f2fb9899e8f0de45d9e" translate="yes" xml:space="preserve">
          <source>Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul32返回x和y的64位乘积。(hi,lo)=x*y,乘积位的上半部分返回hi,下半部分返回lo。</target>
        </trans-unit>
        <trans-unit id="a25ed66383b36d2221150102c89edba8efbb0c02" translate="yes" xml:space="preserve">
          <source>Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y with the product bits' upper half returned in hi and the lower half returned in lo.</source>
          <target state="translated">Mul64返回x和y的128位乘积。(hi,lo)=x*y,乘积位的上半部分返回hi,下半部分返回lo。</target>
        </trans-unit>
        <trans-unit id="9b4ec4f00f8b7fc0f34cde307521a1856a53aa0b" translate="yes" xml:space="preserve">
          <source>MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a &amp;gt; b (empty range), the result is 1.</source>
          <target state="translated">MulRange将z设置为[a，b]范围内的所有整数的乘积，并返回z。如果a&amp;gt; b（空范围），则结果为1。</target>
        </trans-unit>
        <trans-unit id="9eaaace92dc7df7151a8f45536ad19d09279e182" translate="yes" xml:space="preserve">
          <source>MultiReader</source>
          <target state="translated">MultiReader</target>
        </trans-unit>
        <trans-unit id="5d860fccf2fdf207ce3f3ccf216ed942057c9707" translate="yes" xml:space="preserve">
          <source>MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.</source>
          <target state="translated">MultiReader返回一个Reader,它是所提供的输入阅读器的逻辑连接。它们是按顺序读取的。一旦所有输入都返回EOF,Read将返回EOF。如果任何一个读取器返回一个非零、非EOF的错误,Read将返回该错误。</target>
        </trans-unit>
        <trans-unit id="4faad6c802b39e83086bf59c7e2903092d5a691b" translate="yes" xml:space="preserve">
          <source>MultiWriter</source>
          <target state="translated">MultiWriter</target>
        </trans-unit>
        <trans-unit id="0e1b7f58a5f86256f9545cb408ae583680594854" translate="yes" xml:space="preserve">
          <source>MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.</source>
          <target state="translated">MultiWriter 创建一个写入器,将其写入的内容复制到所有提供的写入器,类似于 Unix 的 tee(1)命令。</target>
        </trans-unit>
        <trans-unit id="3688e77a9282752c7dda127e113710f59d4dafc0" translate="yes" xml:space="preserve">
          <source>MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.</source>
          <target state="translated">MulticastAddrs 返回一个特定接口的多播、加入组地址列表。</target>
        </trans-unit>
        <trans-unit id="b9bb2b61e03ad9524ce2fff2bf8e39b44ea3373a" translate="yes" xml:space="preserve">
          <source>MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream.</source>
          <target state="translated">如果这是一个multipart/form-data或multipart/mixed POST请求,MultipartReader返回一个MIME multipart reader,否则返回nil和一个错误。使用这个函数代替ParseMultipartForm来处理作为流的请求体。</target>
        </trans-unit>
        <trans-unit id="a782cf6ce52ba3c0409a2a494107b5e5d1c07de1" translate="yes" xml:space="preserve">
          <source>Multiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter.</source>
          <target state="translated">一个包/类型/函数/方法的多个示例函数,可以通过在名称后添加一个不同的后缀来提供。后缀必须以一个小写字母开头。</target>
        </trans-unit>
        <trans-unit id="97b40210f32960166bd52edfda4ec341de71235b" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Conn simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用Conn上的方法。</target>
        </trans-unit>
        <trans-unit id="6556b625ec1c61ad052df5128208f619bcfcc88f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a Listener simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用一个Listener上的方法。</target>
        </trans-unit>
        <trans-unit id="d58239811314fdc4f9e0084cf7b627a6e3f8ff5f" translate="yes" xml:space="preserve">
          <source>Multiple goroutines may invoke methods on a PacketConn simultaneously.</source>
          <target state="translated">多个goroutine可以同时调用PacketConn上的方法。</target>
        </trans-unit>
        <trans-unit id="e78e9f2f9df049dd02923df34377c4f53cba9951" translate="yes" xml:space="preserve">
          <source>Multiple invocations of this function will return the same value, so it can be used for equality checks and switch statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2c141b4f12a4ff075a8eeb676ff9cf5032e4dc" translate="yes" xml:space="preserve">
          <source>MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.</source>
          <target state="translated">MultiplePackageError描述了一个包含多个包的可构建Go源文件的目录。</target>
        </trans-unit>
        <trans-unit id="79a3dc65878a83d5c3f20c9bd1c6028718af5b1b" translate="yes" xml:space="preserve">
          <source>Multistream controls whether the reader supports multistream files.</source>
          <target state="translated">多流控制阅读器是否支持多流文件。</target>
        </trans-unit>
        <trans-unit id="5d72b823f6e2f60a18b59bcf20086228b774dfee" translate="yes" xml:space="preserve">
          <source>Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as</source>
          <target state="translated">Must是一个帮助程序,它封装了对函数的调用,返回(*Template,error),并在错误为非nil时进行恐慌。它用于变量初始化,如</target>
        </trans-unit>
        <trans-unit id="a51f1ed56a509883e121438647786188d9af7d2f" translate="yes" xml:space="preserve">
          <source>MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompile 和 Compile 一样,但如果表达式不能被解析,它就会惊慌失措。它简化了持有已编译正则表达式的全局变量的安全初始化。</target>
        </trans-unit>
        <trans-unit id="9116a0a3a6e98be619745d64aa7d73bda9c8d13e" translate="yes" xml:space="preserve">
          <source>MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.</source>
          <target state="translated">MustCompilePOSIX 与 CompilePOSIX 类似,但如果表达式不能被解析,它就会惊慌失措。它简化了持有已编译正则表达式的全局变量的安全初始化。</target>
        </trans-unit>
        <trans-unit id="3784bc24f8a3c7e8d169e2b4535e09805ebe5ca0" translate="yes" xml:space="preserve">
          <source>MutexProfile returns n, the number of records in the current mutex profile. If len(p) &amp;gt;= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.</source>
          <target state="translated">MutexProfile返回n，即当前互斥配置文件中的记录数。如果len（p）&amp;gt; = n，则MutexProfile将配置文件复制到p中并返回n，为true。否则，MutexProfile不会更改p，并返回n，false。</target>
        </trans-unit>
        <trans-unit id="5d847ec5889f3982ffb9b7ffa72ed90e47750577" translate="yes" xml:space="preserve">
          <source>NArg is the number of arguments remaining after flags have been processed.</source>
          <target state="translated">NArg是处理完标志后剩余的参数数量。</target>
        </trans-unit>
        <trans-unit id="2f24c1c2739257b059d4d3dc9321f1cdf1115063" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of command-line flags that have been set.</source>
          <target state="translated">NFlag返回已设置的命令行标志的数量。</target>
        </trans-unit>
        <trans-unit id="810e97bcf54f7c38d780b8018b94bedc96063ac9" translate="yes" xml:space="preserve">
          <source>NFlag returns the number of flags that have been set.</source>
          <target state="translated">NFlag返回已设置的标志数量。</target>
        </trans-unit>
        <trans-unit id="c725fb1ef92b939b16dd002af225b2de23e38031" translate="yes" xml:space="preserve">
          <source>NRGBA is an in-memory image whose At method returns color.NRGBA values.</source>
          <target state="translated">NRGBA是一个内存中的图像,其At方法返回color.NRGBA值。</target>
        </trans-unit>
        <trans-unit id="d8bb0d248591faba7b18624bf05d5a4e94d4a0a2" translate="yes" xml:space="preserve">
          <source>NRGBA represents a non-alpha-premultiplied 32-bit color.</source>
          <target state="translated">NRGBA代表一个非阿尔法预增的32位颜色。</target>
        </trans-unit>
        <trans-unit id="5b8e9eaa83b4e60710ae3746671221d4b97e37ff" translate="yes" xml:space="preserve">
          <source>NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.</source>
          <target state="translated">NRGBA64是一个内存中的图像,其At方法返回color.NRGBA64值。</target>
        </trans-unit>
        <trans-unit id="0c537b2ac3425dc17a66dbbf5b63bd3a7a48fb29" translate="yes" xml:space="preserve">
          <source>NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.</source>
          <target state="translated">NRGBA64表示非alpha预增的64位颜色,红、绿、蓝和alpha各为16位。</target>
        </trans-unit>
        <trans-unit id="2cacdaed348d8c69a0481b79dcd2e483e182ae7b" translate="yes" xml:space="preserve">
          <source>NType values; used in core files.</source>
          <target state="translated">NType值;在核心文件中使用。</target>
        </trans-unit>
        <trans-unit id="dfe809819a7c3bc6a6cb826d8f87edea50d7df8a" translate="yes" xml:space="preserve">
          <source>NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.</source>
          <target state="translated">NYCbCrA是一个非alpha预乘Y'CbCr-with-alpha颜色的内存图像。A和AStride类似于嵌入式YCbCr的Y和YStride字段。</target>
        </trans-unit>
        <trans-unit id="381ced7e52d37e0dab6bd72178c010245712478e" translate="yes" xml:space="preserve">
          <source>NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.</source>
          <target state="translated">NYCbCrA表示一个非alpha预增的Y'CbCr-with-alpha颜色,有8位,分别代表一个luma、两个chroma和一个alpha分量。</target>
        </trans-unit>
        <trans-unit id="3ddf7ce6d18dffcfd157667c9d84e86a1c6b7d4e" translate="yes" xml:space="preserve">
          <source>NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha colors.</source>
          <target state="translated">NYCbCrAModel是非alpha预乘Y'CbCr-with-alpha颜色的模型。</target>
        </trans-unit>
        <trans-unit id="57d5b53b7b3ad276283b2d42d51634e430be6df3" translate="yes" xml:space="preserve">
          <source>NaN returns a complex &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN返回一个复杂的&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="01647cea0fd9639449467ddb347270a0682c015d" translate="yes" xml:space="preserve">
          <source>NaN returns an IEEE 754 &amp;ldquo;not-a-number&amp;rdquo; value.</source>
          <target state="translated">NaN返回IEEE 754&amp;ldquo;非数字&amp;rdquo;值。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="458abd2d58ca4f6a99a8329ebea64a0b18022e43" translate="yes" xml:space="preserve">
          <source>Name Resolution</source>
          <target state="translated">名称解析</target>
        </trans-unit>
        <trans-unit id="ea688af26f8e22c900a79fc16d82ceab4193e65a" translate="yes" xml:space="preserve">
          <source>Name constraint validation follows the rules from RFC 5280, with the addition that DNS name constraints may use the leading period format defined for emails and URIs. When a constraint has a leading period it indicates that at least one additional label must be prepended to the constrained name to be considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99409b3041e22d0d0c5a802c5fd9d08e77da5379" translate="yes" xml:space="preserve">
          <source>Name constraints in the intermediates will be applied to all names claimed in the chain, not just opts.DNSName. Thus it is invalid for a leaf to claim example.com if an intermediate doesn't permit it, even if example.com is not the name being validated. Note that DirectoryName constraints are not supported.</source>
          <target state="translated">中间体中的名称约束将被应用于链中所有的名称,而不仅仅是opts.DNSName。因此,如果中间体不允许叶子声明example.com,即使example.com不是被验证的名称,叶子声明example.com也是无效的。注意,不支持DirectoryName约束。</target>
        </trans-unit>
        <trans-unit id="e4faca25c7d92ae57c0deecd43f083feb7d672a5" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. Note that Name is only an approximation of the X.509 structure. If an accurate representation is needed, asn1.Unmarshal the raw subject or issuer as an RDNSequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fba782366c931b096922fa065c94888533271bf" translate="yes" xml:space="preserve">
          <source>Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID.</source>
          <target state="translated">名称代表一个X.509区分的名称。这只包括DN的普通元素。当解析时,所有元素都存储在Names中,非标准元素可以从那里提取。当marshaling时,ExtraNames中的元素会被附加,并覆盖其他具有相同OID的值。</target>
        </trans-unit>
        <trans-unit id="e3f01020dd86fefd968bc57f34e6cf3dc39dbcdc" translate="yes" xml:space="preserve">
          <source>Name resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution.</source>
          <target state="translated">名称解析将程序中的每个标识符(ast.Ident)映射到它所表示的语言对象(Object)上。使用Info.{Defs,Uses,Implicits}获取名称解析的结果。</target>
        </trans-unit>
        <trans-unit id="dff2bc150a13aad1afbb3a0e77b91c6f29404d25" translate="yes" xml:space="preserve">
          <source>Name returns the file name of file f as registered with AddFile.</source>
          <target state="translated">Name 返回用 AddFile 注册的文件 f 的文件名。</target>
        </trans-unit>
        <trans-unit id="dbf0685fdc3e1fc7383fb6378b40c72d45ba31cf" translate="yes" xml:space="preserve">
          <source>Name returns the name of basic type b.</source>
          <target state="translated">名称返回基本类型b的名称。</target>
        </trans-unit>
        <trans-unit id="8fcb1133e9348f92420cdfc4678a083c2132530b" translate="yes" xml:space="preserve">
          <source>Name returns the name of the file as presented to Open.</source>
          <target state="translated">Name 返回提交给 Open 的文件名称。</target>
        </trans-unit>
        <trans-unit id="ddf8f3d9e671d5c8526b346806d1b0aee8900f60" translate="yes" xml:space="preserve">
          <source>Name returns the name of the flag set.</source>
          <target state="translated">名称返回标志集的名称。</target>
        </trans-unit>
        <trans-unit id="2302d490bb5c27edeb93f2429b3dd3925a94667d" translate="yes" xml:space="preserve">
          <source>Name returns the name of the function.</source>
          <target state="translated">Name 返回函数的名称。</target>
        </trans-unit>
        <trans-unit id="1e85527ce244650d2eef45c942c6fb4c49d00958" translate="yes" xml:space="preserve">
          <source>Name returns the name of the running test or benchmark.</source>
          <target state="translated">Name 返回正在运行的测试或基准的名称。</target>
        </trans-unit>
        <trans-unit id="ae31bd0a4e13087d9881916ed12efd37cc202962" translate="yes" xml:space="preserve">
          <source>Name returns the name of the template.</source>
          <target state="translated">名称返回模板的名称。</target>
        </trans-unit>
        <trans-unit id="9d0afdb2756b72089c5803a1fea5a6f6af89abf2" translate="yes" xml:space="preserve">
          <source>Name returns the name or alias of the column.</source>
          <target state="translated">Name 返回列的名称或别名。</target>
        </trans-unit>
        <trans-unit id="6fdae4adddc5e0ab59190994aa36753a8da75cde" translate="yes" xml:space="preserve">
          <source>Name returns the object's (package-local, unqualified) name.</source>
          <target state="translated">Name 返回对象的(package-local,unqualified)名称。</target>
        </trans-unit>
        <trans-unit id="715e38c6f54ac0414267875866ec7639f2185b6c" translate="yes" xml:space="preserve">
          <source>Name returns the package name.</source>
          <target state="translated">Name返回包名。</target>
        </trans-unit>
        <trans-unit id="f2f1501e711468701351739094e89f2faaa9754b" translate="yes" xml:space="preserve">
          <source>Name returns this profile's name, which can be passed to Lookup to reobtain the profile.</source>
          <target state="translated">Name返回这个配置文件的名称,它可以被传递给Lookup以重新获取配置文件。</target>
        </trans-unit>
        <trans-unit id="07ef5638500e255787c53cfed76765c95ef368f8" translate="yes" xml:space="preserve">
          <source>Named character classes as character class elements:</source>
          <target state="translated">将字符类命名为字符类元素。</target>
        </trans-unit>
        <trans-unit id="5214e3c70b9463e72846eff24f10e0e17205139c" translate="yes" xml:space="preserve">
          <source>Named provides a more concise way to create NamedArg values.</source>
          <target state="translated">Named提供了一种更简洁的方式来创建NamedArg值。</target>
        </trans-unit>
        <trans-unit id="9f9c1c1ca0e676e9e2072afd4d97cad1c4edafd2" translate="yes" xml:space="preserve">
          <source>NamedValue holds both the value name and value.</source>
          <target state="translated">NamedValue同时拥有值名和值。</target>
        </trans-unit>
        <trans-unit id="c99f38d2678a853989d8a832348bdca952de6c49" translate="yes" xml:space="preserve">
          <source>NamedValueChecker may be optionally implemented by Conn or Stmt. It provides the driver more control to handle Go and database types beyond the default Values types allowed.</source>
          <target state="translated">NamedValueChecker可以选择由Conn或Stmt实现。它为驱动程序提供了更多的控制,以处理Go和数据库类型,而不是默认允许的Value类型。</target>
        </trans-unit>
        <trans-unit id="4abb0014fb99c3ea27630821804136f4a291ddd2" translate="yes" xml:space="preserve">
          <source>Names returns the scope's element names in sorted order.</source>
          <target state="translated">Names按排序顺序返回作用域的元素名称。</target>
        </trans-unit>
        <trans-unit id="3bc9b96acdd25f0e29a5d98a8eb3024f16d84408" translate="yes" xml:space="preserve">
          <source>Namespaced and data- attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68be7148b1d69811d870e9714f9a627c5b3b1099" translate="yes" xml:space="preserve">
          <source>Naming a file dns_windows.go will cause it to be included only when building the package for Windows; similarly, math_386.s will be included only when building the package for 32-bit x86.</source>
          <target state="translated">将文件 dns_windows.go 命名为 dns_windows.go 将导致它只在为 Windows 构建包时被包含;同样,math_386.s 将只在为 32 位 x86 构建包时被包含。</target>
        </trans-unit>
        <trans-unit id="4bf5d85dcbaccbe3002900f02f86f380a1080e28" translate="yes" xml:space="preserve">
          <source>Nano returns the time stored in ts as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aee9ac8768fce9beebcaf8f73e63c4ab9417be" translate="yes" xml:space="preserve">
          <source>Nano returns the time stored in tv as nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabaa7d294786796f928e96fc93a4f221988121e" translate="yes" xml:space="preserve">
          <source>Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano 返回 ts,表示自 Unix 纪元以来经过的纳秒数。</target>
        </trans-unit>
        <trans-unit id="7cc13f72d19e3af8ee9e16f480775aaded9f3087" translate="yes" xml:space="preserve">
          <source>Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.</source>
          <target state="translated">Nano 返回 tv,表示自 Unix 时代以来经过的纳秒数。</target>
        </trans-unit>
        <trans-unit id="0e6c24671bd350d239a637f4eb004b1ac035f0f6" translate="yes" xml:space="preserve">
          <source>Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].</source>
          <target state="translated">Nanosecond 返回t指定的秒内的纳秒偏移量,范围为[0,999999999]。</target>
        </trans-unit>
        <trans-unit id="9254412c6c417a32ffd67afde8a4d3f64458a58f" translate="yes" xml:space="preserve">
          <source>Nanoseconds returns the duration as an integer nanosecond count.</source>
          <target state="translated">Nanoseconds 返回以整数纳秒计算的持续时间。</target>
        </trans-unit>
        <trans-unit id="ba032ae40abdc5925e0860a082adf4aba20cf4c6" translate="yes" xml:space="preserve">
          <source>Neg sets z to -x and returns z.</source>
          <target state="translated">Neg设置z为-x,并返回z。</target>
        </trans-unit>
        <trans-unit id="381b641c01f8a09410b41524ec6b9c342099d866" translate="yes" xml:space="preserve">
          <source>Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z.</source>
          <target state="translated">Neg设置z为x的(可能是四舍五入)值,并将其符号否定,然后返回z。</target>
        </trans-unit>
        <trans-unit id="8646ff662d17d59189bbe1c09e1b45ec2fcbe881" translate="yes" xml:space="preserve">
          <source>Nested template definitions</source>
          <target state="translated">嵌套模板定义</target>
        </trans-unit>
        <trans-unit id="d8c5cfb403999ea3c1717d789cd51587c786bc53" translate="yes" xml:space="preserve">
          <source>NetlinkMessage represents a netlink message.</source>
          <target state="translated">NetlinkMessage表示一个网链消息。</target>
        </trans-unit>
        <trans-unit id="9c4870d25f2151dc7bae14a92d6848398da82d87" translate="yes" xml:space="preserve">
          <source>NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.</source>
          <target state="translated">NetlinkRIB返回路由信息库,即RIB,它由网络设施信息、状态和参数组成。</target>
        </trans-unit>
        <trans-unit id="602233e97016bb5f79aa0bd9f5a926d8f7889c93" translate="yes" xml:space="preserve">
          <source>NetlinkRouteAttr represents a netlink route attribute.</source>
          <target state="translated">NetlinkRouteAttr表示一个网链路由属性。</target>
        </trans-unit>
        <trans-unit id="44279944636fb5149ee9e75b524255aa96e79a4e" translate="yes" xml:space="preserve">
          <source>NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.</source>
          <target state="translated">NetlinkRouteRequest表示从内核接收路由和链路状态的请求消息。</target>
        </trans-unit>
        <trans-unit id="884a4650baee52e272bb3c5efceff09f71b0dc8c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;ip&quot;。</target>
        </trans-unit>
        <trans-unit id="872aebe8ec9741bc61a3685b3731dbde3529008c" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;ip+net&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;ip+net&quot;。</target>
        </trans-unit>
        <trans-unit id="fa465c71127a452dc67c99401e7bc2d64148685d" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;tcp&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;tcp&quot;。</target>
        </trans-unit>
        <trans-unit id="985257f66305f39d2139512f1ac004ba3741bdd6" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;udp&quot;.</source>
          <target state="translated">Network 返回地址的网络名 &quot;udp&quot;。</target>
        </trans-unit>
        <trans-unit id="85eeab19d1e5738f817203c5a4d550375f022dc2" translate="yes" xml:space="preserve">
          <source>Network returns the address's network name, &quot;unix&quot;, &quot;unixgram&quot; or &quot;unixpacket&quot;.</source>
          <target state="translated">Network 返回地址的网络名称 &quot;unix&quot;、&quot;unixgram &quot;或 &quot;unixpacket&quot;。</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="73e705a3151bc08fd1addfd7992ec83ec85bc2d3" translate="yes" xml:space="preserve">
          <source>New (Errorf)</source>
          <target state="translated">新(错误)</target>
        </trans-unit>
        <trans-unit id="ce9f1f28f9b789d29a4ccd4ff058458cc3933476" translate="yes" xml:space="preserve">
          <source>New (File)</source>
          <target state="translated">新(文件)</target>
        </trans-unit>
        <trans-unit id="13a673772e81bed6fd77076f80c7ff1f6ee89e61" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">New分配一个新的HTML模板,该模板与给定的模板相关联,并使用相同的定界符。这种关联是转义的,允许一个模板用{{template}}动作调用另一个模板。</target>
        </trans-unit>
        <trans-unit id="1c98d75d213247ac29168d2da24b2789a4dbb7a8" translate="yes" xml:space="preserve">
          <source>New allocates a new HTML template with the given name.</source>
          <target state="translated">新建一个给定名称的HTML模板。</target>
        </trans-unit>
        <trans-unit id="34bc55c1fb0c505ee8f76b87c91bd2fc06fc027b" translate="yes" xml:space="preserve">
          <source>New allocates a new parse tree with the given name.</source>
          <target state="translated">New分配一个新的给定名称的解析树。</target>
        </trans-unit>
        <trans-unit id="685d42b22fd5f12d0d18a35ac55a1b6c69615a8a" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.</source>
          <target state="translated">New分配一个新的、未定义的模板,该模板与给定的模板相关联,并且具有相同的定界符。这种关联是转义的,允许一个模板用{{template}}动作调用另一个模板。</target>
        </trans-unit>
        <trans-unit id="1bfbe44c21200e9acb8918513405e990a5ad64ec" translate="yes" xml:space="preserve">
          <source>New allocates a new, undefined template with the given name.</source>
          <target state="translated">新建分配一个新的、未定义的模板,并使用给定的名称。</target>
        </trans-unit>
        <trans-unit id="d58e7e7be4ff87f86b4026a755b5a08e8395893d" translate="yes" xml:space="preserve">
          <source>New changes in the system cert pool might not be reflected in subsequent calls.</source>
          <target state="translated">系统证书池中的新变化可能不会反映在后续调用中。</target>
        </trans-unit>
        <trans-unit id="e8732c118b0cc7bc660fa4e5273983e4bed17a5c" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it.</source>
          <target state="translated">New计算给定包AST的包文档。New 会拥有 AST pkg 的所有权,并可以编辑或覆盖它。</target>
        </trans-unit>
        <trans-unit id="bc0e34f3cf5ad3fd313178553550b414b18c18ba" translate="yes" xml:space="preserve">
          <source>New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it. To have the Examples fields populated, use NewFromFiles and include the package's _test.go files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a02872376b9cd15170d6472cf48d2f256d4269" translate="yes" xml:space="preserve">
          <source>New creates a new Index for data. Index creation time is O(N) for N = len(data).</source>
          <target state="translated">New为数据创建一个新的Index。对于N=len(data),索引创建时间为O(N)。</target>
        </trans-unit>
        <trans-unit id="848e8a805c0a023e8c5b587ab5386886eded5422" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1938bcca0d3c4801a22481ce59e7278f4b6da953" translate="yes" xml:space="preserve">
          <source>New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties.</source>
          <target state="translated">新建一个新的记录仪。out 变量设置了日志数据将被写入的目的地。前缀出现在每个生成的日志行的开头。标志参数定义了日志属性。</target>
        </trans-unit>
        <trans-unit id="9a296c49d13ddf053bb1930fb55493ded12e0b12" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New创建一个新的哈希.Hash32使用Table表示的多项式计算CRC-32校验和。它的Sum方法将按大字节顺序列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f96eb28144daf2fb90bf412860be6e76ca52cf10" translate="yes" xml:space="preserve">
          <source>New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New创建一个新的Hash.Hash64使用Table表示的多项式计算CRC-64校验和。它的Sum方法将按大字节顺序列出值。返回的Hash64还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="44ec7b7b536da273869e89c5cb90df2959fd9688" translate="yes" xml:space="preserve">
          <source>New creates a ring of n elements.</source>
          <target state="translated">新建一个n元素的环。</target>
        </trans-unit>
        <trans-unit id="e7fd8b4c480fbc496999332eaae2de8518c1f830" translate="yes" xml:space="preserve">
          <source>New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the os.Args[0] is used.</source>
          <target state="translated">New建立一个与系统日志守护进程的新连接。每一次向返回的写入器写入时,都会用给定的优先级(syslog设施和严重性的组合)和前缀 tag 发送一条日志消息。如果 tag 为空,则使用 os.Args[0]。</target>
        </trans-unit>
        <trans-unit id="2c433bff47e0e23c62ed805b07cbec0f2f0b6f46" translate="yes" xml:space="preserve">
          <source>New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).</source>
          <target state="translated">New返回一个Value,表示指向指定类型的新零值的指针,也就是说,返回的Value的类型是PtrTo(ty)。也就是说,返回的Value的类型是PtrTo(ty)。</target>
        </trans-unit>
        <trans-unit id="0c3bbfe7ec852d2a1508f7c286818c11369b8298" translate="yes" xml:space="preserve">
          <source>New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe.</source>
          <target state="translated">New返回一个从给定参数初始化的新Data对象。客户端通常不需要直接调用这个函数,而是使用相应包debug/elf、debug/macho或debug/pe的文件类型的DWARF方法。</target>
        </trans-unit>
        <trans-unit id="c20d7d89f2e0839ea2c75a738970b383d37ac73d" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. New functions like sha256.New from crypto/sha256 can be used as h. h must return a new Hash every time it is called. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34063232a48f53eca99c828d036ef36cf5de37bb" translate="yes" xml:space="preserve">
          <source>New returns a new HMAC hash using the given hash.Hash type and key. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.</source>
          <target state="translated">New使用给定的hash.Hash类型和密钥返回一个新的HMAC哈希。请注意,与标准库中的其他哈希实现不同,返回的Hash没有实现encoding.BinaryMarshaler或encoding.BinaryUnmarshaler。</target>
        </trans-unit>
        <trans-unit id="dae1d45948f3340a826a534080ea715da59576dc" translate="yes" xml:space="preserve">
          <source>New returns a new Rand that uses random values from src to generate other random values.</source>
          <target state="translated">New返回一个新的Rand,使用src的随机值来生成其他随机值。</target>
        </trans-unit>
        <trans-unit id="99c2c428e0dc030c03d2e8b41267ed3ddbe36dfb" translate="yes" xml:space="preserve">
          <source>New returns a new cookie jar. A nil *Options is equivalent to a zero Options.</source>
          <target state="translated">New返回一个新的cookie罐。nil *Options相当于Options为零。</target>
        </trans-unit>
        <trans-unit id="1f821272946e1801b5f1d4a05a86314806248536" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.</source>
          <target state="translated">New返回一个新的hash.Hash,计算给定的哈希函数。如果哈希函数没有链接到二进制中,New会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="1098b04617924fcea48eac93732552bb3d10a9b9" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the MD5 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算MD5校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f0a16128a32aa274883c639054d37ccdc6937e39" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA-512 checksum.</source>
          <target state="translated">New返回一个新的Hash.Hash计算SHA-512校验和。</target>
        </trans-unit>
        <trans-unit id="cf1f289ea19766f37df0d90899ff5c24c8ae2c4a" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算SHA1校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="4fd916c9b4b6d94508616e145a5d3f06d397cd5d" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的计算SHA256校验和的hash.Hash。Hash还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="f8209c7edf904061031f392b03dfd5924df101b5" translate="yes" xml:space="preserve">
          <source>New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">New返回一个新的哈希.Hash32计算Adler-32校验和。它的Sum方法将按大字节顺序列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="e84f60f6e65d95fd4ece96b0004a9de85df6b343" translate="yes" xml:space="preserve">
          <source>New returns an error that formats as the given text. Each call to New returns a distinct error value even if the text is identical.</source>
          <target state="translated">New返回一个格式为给定文本的错误。每次调用New都会返回一个不同的错误值,即使文本是相同的。</target>
        </trans-unit>
        <trans-unit id="2d8951b361a0209c54ff9386028d34a39773602f" translate="yes" xml:space="preserve">
          <source>New returns an initialized list.</source>
          <target state="translated">New返回一个初始化的列表。</target>
        </trans-unit>
        <trans-unit id="5801fe069c8fe2aaa55fda0624f44928b4775b87" translate="yes" xml:space="preserve">
          <source>New uses JavaScript's &quot;new&quot; operator with value v as constructor and the given arguments. It panics if v is not a JavaScript function. The arguments get mapped to JavaScript values according to the ValueOf function.</source>
          <target state="translated">New使用JavaScript的 &quot;new &quot;操作符,将值v作为构造函数和给定参数。如果v不是JavaScript函数,它就会惊慌失措。根据ValueOf函数,参数会被映射到JavaScript值。</target>
        </trans-unit>
        <trans-unit id="de47e55b8079b059389f17b105e9ffd1afb3a3e3" translate="yes" xml:space="preserve">
          <source>New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128返回一个新的128位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="a8005a100f6b39010fda63d549052f17d08741bd" translate="yes" xml:space="preserve">
          <source>New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New128a返回一个新的128位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="0ce753ca8c15a0a1b2e753ae81ad1104c1644498" translate="yes" xml:space="preserve">
          <source>New224 returns a new hash.Hash computing the SHA224 checksum.</source>
          <target state="translated">New224返回一个新的Hash.Hash计算SHA224校验和。</target>
        </trans-unit>
        <trans-unit id="ccc0f5023730b0e5ae85216a310b3047f4aa8ea2" translate="yes" xml:space="preserve">
          <source>New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32返回一个新的32位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="d56753001efd2485e723a8e5a73fff58d273b67c" translate="yes" xml:space="preserve">
          <source>New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New32a返回一个新的32位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="7d5d99bcf25b2336b4de3cdadf8a35eaf7a0c199" translate="yes" xml:space="preserve">
          <source>New384 returns a new hash.Hash computing the SHA-384 checksum.</source>
          <target state="translated">New384返回一个新的Hash.Hash计算SHA-384校验和。</target>
        </trans-unit>
        <trans-unit id="4b7f283752df73a2e87a9802891e3f0dd0c8d4d7" translate="yes" xml:space="preserve">
          <source>New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.</source>
          <target state="translated">New512_224返回一个新的Hash.Hash计算SHA-512/224校验和。</target>
        </trans-unit>
        <trans-unit id="825abc60343f43e649b2364900655dff3568736f" translate="yes" xml:space="preserve">
          <source>New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.</source>
          <target state="translated">New512_256返回一个新的Hash.Hash计算SHA-512/256校验和。</target>
        </trans-unit>
        <trans-unit id="d87077707d6ea0d456a51c30f664d7873c8bd355" translate="yes" xml:space="preserve">
          <source>New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64返回一个新的64位FNV-1哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="46dd6ddaccb45d3f0be1865973ec33eaa9f63cd3" translate="yes" xml:space="preserve">
          <source>New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.</source>
          <target state="translated">New64a返回一个新的64位FNV-1a哈希.Hash。它的Sum方法将按大字节顺序排列数值。</target>
        </trans-unit>
        <trans-unit id="7b22f1177470c7c4e87fe25b4cd79c1fd84c6501" translate="yes" xml:space="preserve">
          <source>NewAlpha returns a new Alpha image with the given bounds.</source>
          <target state="translated">NewAlpha返回一个新的Alpha图像。</target>
        </trans-unit>
        <trans-unit id="add0bb0be61493133a58e39dd7700e6c9889401b" translate="yes" xml:space="preserve">
          <source>NewAlpha16 returns a new Alpha16 image with the given bounds.</source>
          <target state="translated">NewAlpha16返回给定边界的新Alpha16图像。</target>
        </trans-unit>
        <trans-unit id="4c61d8963b5a530bd472131f346eba16878a4408" translate="yes" xml:space="preserve">
          <source>NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.</source>
          <target state="translated">NewArray 返回给定元素类型和长度的新数组类型。长度为负数时表示未知长度。</target>
        </trans-unit>
        <trans-unit id="638c31aba3c5c6f8398df36fb530211241e94c4c" translate="yes" xml:space="preserve">
          <source>NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.</source>
          <target state="translated">NewAt返回一个Value,代表指向指定类型的值的指针,使用p作为该指针。</target>
        </trans-unit>
        <trans-unit id="72dec367b963904f8628c7bf12ee4335879a75b8" translate="yes" xml:space="preserve">
          <source>NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.</source>
          <target state="translated">NewBuffer使用buf作为初始内容创建并初始化一个新的Buffer。新的Buffer拥有buf的所有权,调用者在调用后不应该使用buf。NewBuffer的目的是为读取现有数据准备一个Buffer。它也可以用来设置写入内部缓冲区的初始大小。要做到这一点,buf应该具有所需的容量,但长度为零。</target>
        </trans-unit>
        <trans-unit id="ed5f25f81fed45774081165b1641415b15da1746" translate="yes" xml:space="preserve">
          <source>NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.</source>
          <target state="translated">NewBufferString使用字符串s作为初始内容创建并初始化一个新的Buffer。它的目的是为了准备一个缓冲区来读取一个现有的字符串。</target>
        </trans-unit>
        <trans-unit id="22844417cd1bd7e56381df290ad9aba37327ed60" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter</source>
          <target state="translated">NewCBCDecrypter</target>
        </trans-unit>
        <trans-unit id="ca52eb6c91f944ba65ea2ffb0b84fcc2a10abe90" translate="yes" xml:space="preserve">
          <source>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.</source>
          <target state="translated">NewCBCDecrypter返回一个BlockMode,它使用给定的Block以密码块链模式进行解密。iv的长度必须与Block的块大小相同,并且必须与用于加密数据的iv相匹配。</target>
        </trans-unit>
        <trans-unit id="255e7115ae5f4d3fbd66659d8c19d19341701776" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter</source>
          <target state="translated">NewCBCEncrypter</target>
        </trans-unit>
        <trans-unit id="fa88ee5beeb923f46e28b0b6307e4efcac6244ff" translate="yes" xml:space="preserve">
          <source>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCBCEncrypter返回一个BlockMode,使用给定的Block以密码块链模式进行加密。iv的长度必须与Block的块大小相同。</target>
        </trans-unit>
        <trans-unit id="38ff31a554e5558a01b8168178cf0796b7209a44" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter</source>
          <target state="translated">NewCFBDecrypter</target>
        </trans-unit>
        <trans-unit id="2d168991a51faf9df3fede3ceed6622acdae5d65" translate="yes" xml:space="preserve">
          <source>NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBDecrypter使用给定的Block返回一个使用密码反馈模式解密的Stream。iv必须与Block的块大小相同的长度。</target>
        </trans-unit>
        <trans-unit id="08b4648ba8de6f7a55002e90d7740de77aaee124" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter</source>
          <target state="translated">NewCFBEncrypter</target>
        </trans-unit>
        <trans-unit id="46ae2754dd56eaa723f258dcc13d30b6a837033a" translate="yes" xml:space="preserve">
          <source>NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.</source>
          <target state="translated">NewCFBEncrypter使用给定的Block返回一个使用密码反馈模式加密的Stream。iv必须与Block的块大小相同的长度。</target>
        </trans-unit>
        <trans-unit id="253cccaa3711561810055bfc51a9b95d2ac7b353" translate="yes" xml:space="preserve">
          <source>NewCMYK returns a new CMYK image with the given bounds.</source>
          <target state="translated">NewCMYK 返回一个给定边界的新 CMYK 图像。</target>
        </trans-unit>
        <trans-unit id="f23a2508c9195bfe11e43b2f877a2121ff4896e8" translate="yes" xml:space="preserve">
          <source>NewCTR</source>
          <target state="translated">NewCTR</target>
        </trans-unit>
        <trans-unit id="48cf25f578fd7e4d9bde53a1056264acc0f6565d" translate="yes" xml:space="preserve">
          <source>NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size.</source>
          <target state="translated">NewCTR返回一个流,它以计数器模式使用给定的Block进行加密/解密。iv的长度必须与Block的块大小相同。</target>
        </trans-unit>
        <trans-unit id="78b43a9ea76afd66f0e904c5af7000251dc2615e" translate="yes" xml:space="preserve">
          <source>NewCertPool returns a new, empty CertPool.</source>
          <target state="translated">NewCertPool 返回一个新的、空的 CertPool。</target>
        </trans-unit>
        <trans-unit id="24df68fca6c4873d326ba2cccc1b01b5610f3e8e" translate="yes" xml:space="preserve">
          <source>NewChan returns a new channel type for the given direction and element type.</source>
          <target state="translated">NewChan 返回给定方向和元素类型的新通道类型。</target>
        </trans-unit>
        <trans-unit id="62fa4bf0653f8c5396d1118a3de960d9396357d1" translate="yes" xml:space="preserve">
          <source>NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files.</source>
          <target state="translated">NewChecker为给定包返回一个新的Checker实例。软件包文件可以通过checker.Files.Files增量添加。</target>
        </trans-unit>
        <trans-unit id="2380ca2f8a09151f6aa44494bd0336745a8e73ba" translate="yes" xml:space="preserve">
          <source>NewChunkedReader is not needed by normal applications. The http package automatically decodes chunking when reading response bodies.</source>
          <target state="translated">一般的应用程序不需要NewChunkedReader。http包在读取响应体时,会自动解码chunking。</target>
        </trans-unit>
        <trans-unit id="f0cf338b02e3e48fa365cda270fb9dee555b3d17" translate="yes" xml:space="preserve">
          <source>NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP &quot;chunked&quot; format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.</source>
          <target state="translated">NewChunkedReader返回一个新的chunkedReader,它将从r读取的数据翻译成HTTP &quot;chunked &quot;格式后再返回。当读取到最后一个0长度的分块时,chunkedReader会返回io.EOF。</target>
        </trans-unit>
        <trans-unit id="349a471f1f7196f4cd28f8d83c309c02f591534f" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using NewChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">一般的应用程序不需要NewChunkedWriter。如果处理程序没有设置Content-Length头,http包会自动添加分块。在处理程序中使用 NewChunkedWriter 会导致双重分块或带有 Content-Length 长度的分块,这两种情况都是错误的。</target>
        </trans-unit>
        <trans-unit id="b746b9ef76b22845d6f63dc9d95e97e36a08dd5c" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter is not needed by normal applications. The http package adds chunking automatically if handlers don't set a Content-Length header. Using newChunkedWriter inside a handler would result in double chunking or chunking with a Content-Length length, both of which are wrong.</source>
          <target state="translated">一般的应用程序不需要NewChunkedWriter。如果处理程序没有设置Content-Length头,http包会自动添加分块。在处理程序中使用newChunkedWriter会导致双重分块或带有Content-Length长度的分块,这两种情况都是错误的。</target>
        </trans-unit>
        <trans-unit id="bbde3c49be540aed6f3b9a07213ce9f0f0985a47" translate="yes" xml:space="preserve">
          <source>NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP &quot;chunked&quot; format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.</source>
          <target state="translated">NewChunkedWriter返回一个新的chunkedWriter,它将写的内容翻译成HTTP &quot;chunked &quot;格式,然后再写到w中,关闭返回的chunkedWriter会发送最后的0长度的chunk,标志着流的结束,但不会发送出现在预告片后的最后CRLF;预告片和最后的CRLF必须分开写。</target>
        </trans-unit>
        <trans-unit id="0f92d63907abdded9ec398f437e0cf965d51343f" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.</source>
          <target state="translated">NewCipher创建并返回一个新的Cipher。密钥参数应该是RC4密钥,至少1个字节,最多256个字节。</target>
        </trans-unit>
        <trans-unit id="8328cb0f867c2e756f382b0ca63e4950d8850883" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewCipher创建并返回一个新的cipher.Block。</target>
        </trans-unit>
        <trans-unit id="6b22b2787fd6b2ed8659da500429f9fa3fe86072" translate="yes" xml:space="preserve">
          <source>NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.</source>
          <target state="translated">NewCipher创建并返回一个新的cipher.Block。密钥参数应该是AES密钥,可以是16、24或32字节,可以选择AES-128、AES-192或AES-256。</target>
        </trans-unit>
        <trans-unit id="b860dfa2340445fd2cf308e5a3748fea60faee9b" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.</source>
          <target state="translated">NewClient返回一个新的Client来处理对连接另一端的服务集的请求。它在连接的写端添加了一个缓冲区,因此头和有效载荷是作为一个单元发送的。</target>
        </trans-unit>
        <trans-unit id="b078c0d5ff1e636af20c5c0ed8dd22f85b7f4282" translate="yes" xml:space="preserve">
          <source>NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating.</source>
          <target state="translated">NewClient返回一个新的客户端,使用现有的连接和主机作为服务器名称,在验证时使用。</target>
        </trans-unit>
        <trans-unit id="f8fb1181ae8a229864a05cfebb15c90112fff65c" translate="yes" xml:space="preserve">
          <source>NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection.</source>
          <target state="translated">NewClient返回一个新的rpc.Client来处理对连接另一端的服务集的请求。</target>
        </trans-unit>
        <trans-unit id="856bbb45168cae23811fbc886f1b4d3be27846fe" translate="yes" xml:space="preserve">
          <source>NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.</source>
          <target state="translated">NewClientCodec在conn上使用JSON-RPC返回一个新的rpc.ClientCodec。</target>
        </trans-unit>
        <trans-unit id="b7383a602fa795d357297b4de95d8575b00a78ab" translate="yes" xml:space="preserve">
          <source>NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewClientConn是Go早期HTTP实现的一个产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="4aa403c83da74918792480724a9f264584f0a604" translate="yes" xml:space="preserve">
          <source>NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses.</source>
          <target state="translated">NewClientWithCodec与NewClient类似,但使用指定的编解码器来编码请求和解码响应。</target>
        </trans-unit>
        <trans-unit id="413a5b89d02aeac4a6363a735de94f49289195bd" translate="yes" xml:space="preserve">
          <source>NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.</source>
          <target state="translated">NewCommentMap通过将评论列表的评论组与节点指定的AST的节点关联起来,创建一个新的评论图。</target>
        </trans-unit>
        <trans-unit id="9378822df6d0b7340f61509bcb85e6fd00318896" translate="yes" xml:space="preserve">
          <source>NewCommentMap tries to associate a comment group to the &quot;largest&quot; node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment.</source>
          <target state="translated">NewCommentMap 试图将一个注释组关联到可能的 &quot;最大 &quot;节点。例如,如果注释是一个赋值后面的行注释,那么注释将与整个赋值相关联,而不仅仅是赋值中的最后一个操作数。</target>
        </trans-unit>
        <trans-unit id="4fd7049b9f856641359b9b5ca0cbb7b1cd2c0fac" translate="yes" xml:space="preserve">
          <source>NewCond returns a new Cond with Locker l.</source>
          <target state="translated">NewCond返回一个新的Cond与Locker l。</target>
        </trans-unit>
        <trans-unit id="eee961cdebdc3886242b174d6b32a3a25041270b" translate="yes" xml:space="preserve">
          <source>NewConn returns a new Conn using conn for I/O.</source>
          <target state="translated">NewConn返回一个使用conn作为I/O的新Conn。</target>
        </trans-unit>
        <trans-unit id="f81c5ab59d9f6c3c64039d6d5945f0e9cc54b88d" translate="yes" xml:space="preserve">
          <source>NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewConst 返回一个值为 val 的新常量。其余的参数设置了所有对象的属性。</target>
        </trans-unit>
        <trans-unit id="bdc96fab96f7e5d7b8628b8398bba38bf6580815" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new ascii85 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的ascii85流解码器。</target>
        </trans-unit>
        <trans-unit id="369f6e69c20c8e4d13528053c51cd1d3a61e68de" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base32 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的base32流解码器。</target>
        </trans-unit>
        <trans-unit id="d864a240d883e7dc24b71e88a8d5c0c1948d801c" translate="yes" xml:space="preserve">
          <source>NewDecoder constructs a new base64 stream decoder.</source>
          <target state="translated">NewDecoder构造一个新的base64流解码器。</target>
        </trans-unit>
        <trans-unit id="060a7de61a5514feea18b0489167470b12d0112a" translate="yes" xml:space="preserve">
          <source>NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering.</source>
          <target state="translated">如果r没有实现io.ByteReader,NewDecoder将自己进行缓冲。</target>
        </trans-unit>
        <trans-unit id="89572a28c9f62f14398327362d699001d2142b0d" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from r.</source>
          <target state="translated">NewDecoder返回一个新的从r中读取的解码器。</target>
        </trans-unit>
        <trans-unit id="96af6984e1ed3c2ee798e01c4c02872b06029e89" translate="yes" xml:space="preserve">
          <source>NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.</source>
          <target state="translated">NewDecoder 返回一个新的解码器,它从 io.Reader.Reader 中读取。如果r没有实现io.ByteReader,它将被包装在一个bufio.Reader中。</target>
        </trans-unit>
        <trans-unit id="56f76b42c4fa44e21b83722e16f9a4c656264781" translate="yes" xml:space="preserve">
          <source>NewDecoder returns an io.Reader that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.</source>
          <target state="translated">NewDecoder返回一个io.Reader,用于解码r中的十六进制字符,NewDecoder希望r中只包含偶数的十六进制字符。</target>
        </trans-unit>
        <trans-unit id="815c279b763f19acec3e56299892af2ccb9c6e0b" translate="yes" xml:space="preserve">
          <source>NewDecoder wraps an io.Reader interface around Decode.</source>
          <target state="translated">NewDecoder围绕Decode封装了一个io.Reader接口。</target>
        </trans-unit>
        <trans-unit id="415b5e5928dc67ca5917ce4d88ceda8c89e1b092" translate="yes" xml:space="preserve">
          <source>NewEncoder</source>
          <target state="translated">NewEncoder</target>
        </trans-unit>
        <trans-unit id="018ed3a7983059a17dab1b137a9844370d5a2b74" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.</source>
          <target state="translated">NewEncoder返回一个新的ascii85流编码器。写入到返回的写入器的数据将被编码,然后写入到w中。Ascii85编码以32位块操作;当完成写入时,调用者必须关闭返回的编码器,以清除任何尾部的部分块。</target>
        </trans-unit>
        <trans-unit id="dd7f4a301864c468eb1cb40a57cdfbd02a050c05" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder返回一个新的base32流编码器。写入到返回的写入器中的数据将使用 enc 编码,然后写入到 w 中。base32 编码以 5 字节块为单位运行;当完成写入时,调用者必须关闭返回的编码器,以清除任何部分写入的块。</target>
        </trans-unit>
        <trans-unit id="44ee1dd433d92306638dd13e3127df94408d4089" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.</source>
          <target state="translated">NewEncoder返回一个新的base64流编码器。写入到返回的写入器中的数据将使用 enc 编码,然后写入到 w 中。Base64 编码以 4 字节块的形式运行;当完成写入时,调用者必须关闭返回的编码器以清除任何部分写入的块。</target>
        </trans-unit>
        <trans-unit id="d754a23d4130a807a013e53a62e7006beaa7e442" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that will transmit on the io.Writer.</source>
          <target state="translated">NewEncoder返回一个新的编码器,将在io.Writer.Writer上传输。</target>
        </trans-unit>
        <trans-unit id="d092172077c4670e0835be93cc4b418229db1d7a" translate="yes" xml:space="preserve">
          <source>NewEncoder returns a new encoder that writes to w.</source>
          <target state="translated">NewEncoder返回一个写入w的新编码器。</target>
        </trans-unit>
        <trans-unit id="6bc807b2bebb618f92c16dd28d4ba73b4801ef86" translate="yes" xml:space="preserve">
          <source>NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.</source>
          <target state="translated">NewEncoder返回一个io.Writer,将小写的十六进制字符写入w。</target>
        </trans-unit>
        <trans-unit id="ec3215d4f7a860c50c96d8ebe05c612fbb607223" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string.</source>
          <target state="translated">NewEncoding 返回一个由给定字母定义的新编码,它必须是一个 32 字节的字符串。</target>
        </trans-unit>
        <trans-unit id="a225db48b3273b7eabd0d6e7950dc3ffe5785055" translate="yes" xml:space="preserve">
          <source>NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that does not contain the padding character or CR / LF ('\r', '\n'). The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding.</source>
          <target state="translated">NewEncoding返回一个由给定字母定义的新的填充编码,它必须是一个64字节的字符串,不包含填充字符或CR/LF('\r','\n')。产生的Encoding使用默认的padding字符('='),可以通过WithPadding改变或禁用。</target>
        </trans-unit>
        <trans-unit id="e3eb6effd2379105d96f5ae281be769ac968f9b4" translate="yes" xml:space="preserve">
          <source>NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFatFile创建一个新的FatFile,用于访问通用二进制中的所有Mach-O图像。Mach-O二进制文件应该从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="d86df188426dbb1a1da9539d4f76b961b9e5801b" translate="yes" xml:space="preserve">
          <source>NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible.</source>
          <target state="translated">NewField返回一个新的变量,代表一个结构字段。对于嵌入的字段,名称是字段可以访问的非限定类型名称。</target>
        </trans-unit>
        <trans-unit id="fa49724aa2bb7b06a7e49b7b14c21627f72f66fe" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建一个新的文件,用于访问底层阅读器中的Mach-O二进制文件。Mach-O二进制文件应该从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="c4cb0bcb5da3b7cb9c222f07d952f1deb79331f9" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a PE binary in an underlying reader.</source>
          <target state="translated">NewFile创建一个新文件,用于访问底层读卡器中的PE二进制文件。</target>
        </trans-unit>
        <trans-unit id="fb3c69eb6155088ad1b0a5da31e3f5031165ea55" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建了一个新文件,用于访问底层读卡器中的Plan 9二进制文件。Plan 9二进制文件将从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="02c382510f60f7ac0e7f9dd332c2062d9f122bae" translate="yes" xml:space="preserve">
          <source>NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.</source>
          <target state="translated">NewFile创建一个新的文件,用于访问底层阅读器中的ELF二进制文件。ELF二进制文件被期望从ReaderAt的0位置开始。</target>
        </trans-unit>
        <trans-unit id="dd7d78c4172dcb2fe6cfcff9bb7e67f44f614ee3" translate="yes" xml:space="preserve">
          <source>NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).</source>
          <target state="translated">NewFile 用给定的文件描述符和名称返回一个新文件。如果fd不是一个有效的文件描述符,那么返回的值将是nil。在Unix系统中,如果文件描述符处于非阻塞模式,NewFile将尝试返回一个可轮询的文件(SetDeadline方法可以使用的文件)。</target>
        </trans-unit>
        <trans-unit id="146b2f1f1201d86650233642cb2b7d8638ac3e22" translate="yes" xml:space="preserve">
          <source>NewFileSet creates a new file set.</source>
          <target state="translated">NewFileSet创建一个新的文件集。</target>
        </trans-unit>
        <trans-unit id="39ae9e749e1c008bbfaf63f08fa2bb4e930b56b2" translate="yes" xml:space="preserve">
          <source>NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.</source>
          <target state="translated">NewFileTransport 返回一个新的 RoundTripper,为提供的 FileSystem 服务。返回的 RoundTripper 忽略传入请求中的 URL 主机以及请求的大多数其他属性。</target>
        </trans-unit>
        <trans-unit id="f495b9657d10d27f36446d430fd6f4942c405b7b" translate="yes" xml:space="preserve">
          <source>NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.</source>
          <target state="translated">NewFlagSet返回一个新的、空的标志集,它具有指定的名称和错误处理属性。如果名称不是空的,它将被打印在默认的使用信息和错误信息中。</target>
        </trans-unit>
        <trans-unit id="6c1be2205981424ac6113bbac1c50ddc8e645067" translate="yes" xml:space="preserve">
          <source>NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.</source>
          <target state="translated">NewFloat分配并返回一个新的Float集到x,精度为53,舍入模式为ToNearestEven。如果x是一个NaN,NewFloat会用ErrNaN恐慌。</target>
        </trans-unit>
        <trans-unit id="2c91158e9955fcc78b6177862dde11c92e0a8e89" translate="yes" xml:space="preserve">
          <source>NewFromFiles</source>
          <target state="translated">NewFromFiles</target>
        </trans-unit>
        <trans-unit id="d5aa413c2ae053b79a6371a10ccf3bd1d17cfac2" translate="yes" xml:space="preserve">
          <source>NewFromFiles computes documentation for a package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2d01ef38cc1f681b00bbd8645c1b2f1cdf0884" translate="yes" xml:space="preserve">
          <source>NewFromFiles takes ownership of the AST files and may edit them, unless the PreserveAST Mode bit is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cad2834cd366b48375257d77d59b7e9a0915c1" translate="yes" xml:space="preserve">
          <source>NewFunc returns a new function with the given signature, representing the function's type.</source>
          <target state="translated">NewFunc 用给定的签名返回一个新函数,代表函数的类型。</target>
        </trans-unit>
        <trans-unit id="1ab1fbb5a4b914ad66a4cae1cb655fa076b9ba96" translate="yes" xml:space="preserve">
          <source>NewGCM (Decrypt)</source>
          <target state="translated">NewGCM(解密)</target>
        </trans-unit>
        <trans-unit id="88779115714f813ff34a3c2fff6aef4d291f21ae" translate="yes" xml:space="preserve">
          <source>NewGCM (Encrypt)</source>
          <target state="translated">新GCM(加密)</target>
        </trans-unit>
        <trans-unit id="d8e7f4fd8eb6323a1d235af8804d7f84b6c49124" translate="yes" xml:space="preserve">
          <source>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.</source>
          <target state="translated">NewGCM返回给定的128位、以伽罗瓦计数器模式封装的标准非ce长度的块密码。</target>
        </trans-unit>
        <trans-unit id="1973de63c4df3596c58655e33db1f26efd7af742" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length.</source>
          <target state="translated">NewGCMWithNonceSize返回给定的128位,以Galois Counter Mode封装的块密码,它接受给定长度的nonces。</target>
        </trans-unit>
        <trans-unit id="23bb3140d85ffc465c1c9d547b9527a6165fd0c6" translate="yes" xml:space="preserve">
          <source>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length. The length must not be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89798890939059366d5fe1d2975869f4976a143" translate="yes" xml:space="preserve">
          <source>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.</source>
          <target state="translated">NewGCMWithTagSize返回给定的128位,以Galois Counter模式封装的块密码,生成给定长度的标签。</target>
        </trans-unit>
        <trans-unit id="454b2fc86978be3ab7ad864f00d10ff49dc84b08" translate="yes" xml:space="preserve">
          <source>NewGray returns a new Gray image with the given bounds.</source>
          <target state="translated">NewGray 返回一个给定边界的新格雷图像。</target>
        </trans-unit>
        <trans-unit id="3f20d3a865eb95651d9773b55020e283c7cda789" translate="yes" xml:space="preserve">
          <source>NewGray16 returns a new Gray16 image with the given bounds.</source>
          <target state="translated">NewGray16 返回一个给定边界的新的 Gray16 图像。</target>
        </trans-unit>
        <trans-unit id="7063568571cff8011c550348a1d249dbcd1b3164" translate="yes" xml:space="preserve">
          <source>NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.</source>
          <target state="translated">NewIEEE创建一个新的哈希.Hash32使用IEEE多项式计算CRC-32校验和。它的Sum方法将按大字节顺序排列出值。返回的Hash32还实现了encoding.BinaryMarshaler和encoding.BinaryUnmarshaler来对哈希的内部状态进行marshal和unmarshal。</target>
        </trans-unit>
        <trans-unit id="4d0116b71b732a25476a4fce3bfdd9a186665b0a" translate="yes" xml:space="preserve">
          <source>NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser.</source>
          <target state="translated">NewIdent 创建一个没有位置的新Ident。对由Go解析器以外的代码生成的AST有用。</target>
        </trans-unit>
        <trans-unit id="a1da620d7851b36eddceb2d1155bd10520ef1e3d" translate="yes" xml:space="preserve">
          <source>NewIdentifier returns a new IdentifierNode with the given identifier name.</source>
          <target state="translated">NewIdentifier返回一个带有给定标识符名称的新IdentifierNode。</target>
        </trans-unit>
        <trans-unit id="525b5936156155224309c259d63dc7a201bbb3b9" translate="yes" xml:space="preserve">
          <source>NewInt allocates and returns a new Int set to x.</source>
          <target state="translated">NewInt分配并返回一个新的Int集到x。</target>
        </trans-unit>
        <trans-unit id="ce33b2838258d1a7fb77fc3c2496c70b71309e0c" translate="yes" xml:space="preserve">
          <source>NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterface为给定的方法和嵌入式类型返回一个新的(不完整的)接口。每个嵌入式类型必须有一个底层的接口类型。NewInterface拥有所给方法的所有权,并可以通过设置缺失的接收器来修改它们的类型。要计算接口的方法集,必须调用Complete。</target>
        </trans-unit>
        <trans-unit id="c1879314ab1ca85d9a540a3d842506cb8e3d5935" translate="yes" xml:space="preserve">
          <source>NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.</source>
          <target state="translated">NewInterfaceType为给定的方法和嵌入式类型返回一个新的(不完整的)接口。每个嵌入式类型必须有一个接口类型的底层类型(对于定义的类型,这个属性没有经过验证,因为这些类型可能正在设置过程中,还没有一个有效的底层类型)。NewInterfaceType对所提供的方法拥有所有权,并可以通过设置缺失的接收器来修改其类型。要计算接口的方法集,必须调用 Complete。</target>
        </trans-unit>
        <trans-unit id="412fcf56e8322a2530a374f7516c3ab81d822a6e" translate="yes" xml:space="preserve">
          <source>NewKeyFromSeed calculates a private key from a seed. It will panic if len(seed) is not SeedSize. This function is provided for interoperability with RFC 8032. RFC 8032's private keys correspond to seeds in this package.</source>
          <target state="translated">NewKeyFromSeed从种子中计算出一个私钥。如果len(seed)不是SeedSize,它将会恐慌。提供这个函数是为了与 RFC 8032 互操作。RFC 8032 的私钥对应于这个包中的种子。</target>
        </trans-unit>
        <trans-unit id="7f204c9bcbc69e7346a4be4a91e71094cadba874" translate="yes" xml:space="preserve">
          <source>NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &amp;lt; 1, a default capacity is used instead.</source>
          <target state="translated">NewLRUClientSessionCache返回具有使用LRU策略的给定容量的ClientSessionCache。如果容量&amp;lt;1，则使用默认容量。</target>
        </trans-unit>
        <trans-unit id="e85de83deae1f6ea413617fafa918347032b364d" translate="yes" xml:space="preserve">
          <source>NewLabel returns a new label.</source>
          <target state="translated">NewLabel 返回一个新标签。</target>
        </trans-unit>
        <trans-unit id="c00322f2990498c11eaea48009e4263db8d2b147" translate="yes" xml:space="preserve">
          <source>NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment.</source>
          <target state="translated">NewLineTable 返回一个与编码数据相对应的新 PC/行表。文本必须是相应文本段的起始地址。</target>
        </trans-unit>
        <trans-unit id="ee273ce2cc40669abe88f8cbd5b969c8b99cc1d8" translate="yes" xml:space="preserve">
          <source>NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.</source>
          <target state="translated">NewListener创建了一个Listener,它接受来自内部Listener的连接,并用Server包装每个连接。配置config必须是非零,并且必须包含至少一个证书,否则设置GetCertificate。</target>
        </trans-unit>
        <trans-unit id="b8ae0fc1fd1b3795d43931c769132b8b76d67124" translate="yes" xml:space="preserve">
          <source>NewLogger creates a log.Logger whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to log.New to create the Logger.</source>
          <target state="translated">NewLogger创建一个log.Logger,其输出以指定的优先级写入系统日志服务,这是syslog设施和严重性的组合。logFlag参数是传递给log.New创建Logger的标志集。</target>
        </trans-unit>
        <trans-unit id="c2cf8bf27d6896fb60a3c00c2f29046150140e53" translate="yes" xml:space="preserve">
          <source>NewMap returns a new map for the given key and element types.</source>
          <target state="translated">NewMap返回给定键和元素类型的新地图。</target>
        </trans-unit>
        <trans-unit id="02aaaae9f75a28f52b63beb3faa08f1c64a67962" translate="yes" xml:space="preserve">
          <source>NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.</source>
          <target state="translated">NewMethodSet 返回给定类型 T 的方法集。它总是返回一个非零的方法集,即使它是空的。</target>
        </trans-unit>
        <trans-unit id="8a80c96af1db7665cca4280156494ace76054fb6" translate="yes" xml:space="preserve">
          <source>NewNRGBA returns a new NRGBA image with the given bounds.</source>
          <target state="translated">NewNRGBA 返回一个给定边界的新 NRGBA 图像。</target>
        </trans-unit>
        <trans-unit id="91846ee562c7c231bc0d057ad08777b2cf971613" translate="yes" xml:space="preserve">
          <source>NewNRGBA64 returns a new NRGBA64 image with the given bounds.</source>
          <target state="translated">NewNRGBA64 返回一个给定边界的新 NRGBA64 图像。</target>
        </trans-unit>
        <trans-unit id="808f42c5f206bd7e6ba827599de3fbf867803134" translate="yes" xml:space="preserve">
          <source>NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.</source>
          <target state="translated">NewNYCbCrA返回一个新的NYCbCrA图像,具有给定的边界和子样本比。</target>
        </trans-unit>
        <trans-unit id="1fd8ffb265de65f1861cce1196f85b25e1d6856a" translate="yes" xml:space="preserve">
          <source>NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named.</source>
          <target state="translated">NewNamed为给定的类型名、底层类型和相关方法返回一个新的命名类型。如果给定的类型名obj还没有类型,那么它的类型将被设置为返回的命名类型。底层类型必须不是一个*Named。</target>
        </trans-unit>
        <trans-unit id="e782c15bb55a8ae8ebce9f874df5b1a0c46216d1" translate="yes" xml:space="preserve">
          <source>NewOFB</source>
          <target state="translated">NewOFB</target>
        </trans-unit>
        <trans-unit id="b57f2ce3c1f5586132093d982185af2e0ee68f6c" translate="yes" xml:space="preserve">
          <source>NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.</source>
          <target state="translated">NewOFB返回一个使用输出反馈模式下的块密码b进行加密或解密的Stream。初始化向量iv的长度必须等于b的块大小。</target>
        </trans-unit>
        <trans-unit id="8ec79b70c4182bbf15d13c7ed9c2f93fc95d113e" translate="yes" xml:space="preserve">
          <source>NewObj creates a new object of a given kind and name.</source>
          <target state="translated">NewObj创建一个给定种类和名称的新对象。</target>
        </trans-unit>
        <trans-unit id="36552f14153f539c86094444ec1ce5a1a1e5bd03" translate="yes" xml:space="preserve">
          <source>NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors.</source>
          <target state="translated">NewPackage 从一组 File 节点中创建一个新的 Package 节点。它跨文件解析未解析的标识符,并相应地更新每个文件的未解析列表。如果提供了一个非零的导入器和宇宙范围,它们将被用来解析未在任何包文件中声明的标识符。任何剩余的未解析的标识符都会被报告为未声明。如果文件属于不同的包,则选择一个包名,报告不同包名的文件,然后忽略。结果是一个包节点和一个 scanner.ErrorList(如果有错误)。</target>
        </trans-unit>
        <trans-unit id="8b93023f444decd83a57effbd1356f40d43944cd" translate="yes" xml:space="preserve">
          <source>NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.</source>
          <target state="translated">NewPackage 返回给定包的路径和名称的新包。该包并不完整,也不包含任何显式导入。</target>
        </trans-unit>
        <trans-unit id="7604882861f8171ac92bb5a0ff3402c04452837d" translate="yes" xml:space="preserve">
          <source>NewPaletted returns a new Paletted image with the given width, height and palette.</source>
          <target state="translated">NewPaletted以给定的宽度、高度和调色板返回一个新的Paletted图像。</target>
        </trans-unit>
        <trans-unit id="8157edaefd4d8244aead4c748c2239a1e9cdf406" translate="yes" xml:space="preserve">
          <source>NewParam returns a new variable representing a function parameter.</source>
          <target state="translated">NewParam 返回一个代表函数参数的新变量。</target>
        </trans-unit>
        <trans-unit id="760c953eeca5555c276ff2137d11f1ac464a3878" translate="yes" xml:space="preserve">
          <source>NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewPkgName 返回一个新的 PkgName 对象,代表一个导入的软件包。其余的参数设置了所有 Objects 的属性。</target>
        </trans-unit>
        <trans-unit id="7267fd8d7fb296d4d49d2c7f2fba8f9caa6a9909" translate="yes" xml:space="preserve">
          <source>NewPointer returns a new pointer type for the given element (base) type.</source>
          <target state="translated">NewPointer返回给定元素(base)类型的新指针类型。</target>
        </trans-unit>
        <trans-unit id="ad8326fa0e1c2920bea4e6fdd7be9537d18c5951" translate="yes" xml:space="preserve">
          <source>NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.</source>
          <target state="translated">NewProfile 用给定的名称创建一个新的配置文件。如果已经存在一个具有该名称的配置文件,NewProfile就会惊慌失措。惯例是使用 &quot;import/path.&quot;前缀来为每个包创建单独的名字空格。为了与各种读取 pprof 数据的工具兼容,profile 名称不应包含空格。</target>
        </trans-unit>
        <trans-unit id="7dee9fd54a2c7c0d2e2445231875724a5129fb2a" translate="yes" xml:space="preserve">
          <source>NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewProxyClientConn是Go早期HTTP实现的产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="7013b5c7630f0f9aff6a55861942f65a617ff634" translate="yes" xml:space="preserve">
          <source>NewRGBA returns a new RGBA image with the given bounds.</source>
          <target state="translated">NewRGBA 返回一个给定边界的新 RGBA 图像。</target>
        </trans-unit>
        <trans-unit id="06634c84293e78aa59af4c55605513918ba019e7" translate="yes" xml:space="preserve">
          <source>NewRGBA64 returns a new RGBA64 image with the given bounds.</source>
          <target state="translated">NewRGBA64 以给定的边界返回一个新的 RGBA64 图像。</target>
        </trans-unit>
        <trans-unit id="00d97e53207565a29c223d381563f8ace2580585" translate="yes" xml:space="preserve">
          <source>NewRat creates a new Rat with numerator a and denominator b.</source>
          <target state="translated">NewRat创建一个新的Rat,分子a和分母b。</target>
        </trans-unit>
        <trans-unit id="8b51e66ddf0c0bc242e2972b3ed47f8e19aa8aff" translate="yes" xml:space="preserve">
          <source>NewReadLogger returns a reader that behaves like r except that it logs (using log.Printf) each read to standard error, printing the prefix and the hexadecimal data read.</source>
          <target state="translated">NewReadLogger返回一个阅读器,它的行为与r类似,除了它将每次读取的数据记录(使用log.Printf)为标准错误,打印前缀和读取的十六进制数据。</target>
        </trans-unit>
        <trans-unit id="4ddd20c3c7ab3b134b41334b4749254502eec73c" translate="yes" xml:space="preserve">
          <source>NewReadWriter allocates a new ReadWriter that dispatches to r and w.</source>
          <target state="translated">NewReadWriter分配一个新的ReadWriter,派发给r和w。</target>
        </trans-unit>
        <trans-unit id="abdd552b8a6a378c711658cbda39673b4658c843" translate="yes" xml:space="preserve">
          <source>NewReader</source>
          <target state="translated">NewReader</target>
        </trans-unit>
        <trans-unit id="656b7888dc8300d6258cc09514612ef897a06356" translate="yes" xml:space="preserve">
          <source>NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.</source>
          <target state="translated">NewReader创建一个新的ReadCloser.如果r没有实现io.ByteReader,那么解压器可能会从r中读取更多的数据。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据,完成后调用Close ReadCloser是调用者的责任。</target>
        </trans-unit>
        <trans-unit id="03de0f94de657abcdcd727d93d1385934f4b4c2a" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading from r.</source>
          <target state="translated">NewReader创建一个新的Reader,从r中读取。</target>
        </trans-unit>
        <trans-unit id="9310cd05d389a1e08ddfb9e4317d864d066d18ff" translate="yes" xml:space="preserve">
          <source>NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader创建一个新的Reader,读取给定的阅读器。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据。</target>
        </trans-unit>
        <trans-unit id="1afded549345ec0238483e2ba55aa75ed2ded5bd" translate="yes" xml:space="preserve">
          <source>NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.</source>
          <target state="translated">NewReader创建一个新的io.ReadCloser。从返回的io.ReadCloser中读取并解压r中的数据。如果r没有实现io.ByteReader,解压器可能会从r中读取更多的数据,而不是必要的。用于文字代码的位数litWidth必须在[2,8]范围内,通常为8,它必须等于压缩过程中使用的litWidth。</target>
        </trans-unit>
        <trans-unit id="104785202390e0ba0e171f6e70831714a74466f6" translate="yes" xml:space="preserve">
          <source>NewReader creates a new multipart Reader reading from r using the given MIME boundary.</source>
          <target state="translated">NewReader使用给定的MIME边界创建一个新的多部分Reader从r中读取。</target>
        </trans-unit>
        <trans-unit id="c18de38552330a3ffd438fa2e288016ca23d0e4e" translate="yes" xml:space="preserve">
          <source>NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading.</source>
          <target state="translated">NewReader返回一个新的ReadCloser,它可以用来读取r的非压缩版本。如果r没有实现io.ByteReader,那么解压器可能会从r中读取更多不必要的数据。</target>
        </trans-unit>
        <trans-unit id="36241ff4da2c1821f96dba25272112a2ddbe76ee" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from b.</source>
          <target state="translated">NewReader从b中返回一个新的Reader读数。</target>
        </trans-unit>
        <trans-unit id="9e007e6c23a0a667f419ff954033af0ca806b580" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes.</source>
          <target state="translated">NewReader返回一个新的Reader,从r中读取,假设它有给定的字节大小。</target>
        </trans-unit>
        <trans-unit id="0a237744e6cd622e08bcaadcb57e9896c2c1bd36" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from r.</source>
          <target state="translated">NewReader从r返回一个新的Reader读物。</target>
        </trans-unit>
        <trans-unit id="8809e71360f0f480fd09d2bb6c73d758eb20bf24" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.</source>
          <target state="translated">NewReader返回一个从s读取的新Reader,它类似于bytes.NewBufferString,但更高效且只读。</target>
        </trans-unit>
        <trans-unit id="4b591a6aa8b2fa42d203301d41858890dc4a8ba3" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader that reads from r.</source>
          <target state="translated">NewReader返回一个新的Reader,从r中读取。</target>
        </trans-unit>
        <trans-unit id="c08939cbf0fe51e296c0a2ccf3a3311832697807" translate="yes" xml:space="preserve">
          <source>NewReader returns a new Reader whose buffer has the default size.</source>
          <target state="translated">NewReader返回一个新的Reader,它的缓冲区有默认的大小。</target>
        </trans-unit>
        <trans-unit id="ab008cb6047aabfffe29520f5a1d9f6947d1bb37" translate="yes" xml:space="preserve">
          <source>NewReader returns a quoted-printable reader, decoding from r.</source>
          <target state="translated">NewReader返回一个可引用打印的阅读器,由r解码。</target>
        </trans-unit>
        <trans-unit id="15423ba5dc90eb7ca320aa86b1e4769688d373ee" translate="yes" xml:space="preserve">
          <source>NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.</source>
          <target state="translated">NewReader返回一个io.Reader,它可以从r中解压bzip2数据。如果r没有实现io.ByteReader,解压器可能会从r中读取超过必要的数据。</target>
        </trans-unit>
        <trans-unit id="ceca3110c418c227d4c22c9ca1803e30b1fbc6a9" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.</source>
          <target state="translated">NewReaderDict和NewReader一样,但是用一个预设的字典来初始化阅读器。返回的Reader的行为就像未压缩的数据流从给定的字典开始,它已经被读取。NewReaderDict通常用于读取由NewWriterDict压缩的数据。</target>
        </trans-unit>
        <trans-unit id="15dcb5ef9b327e52dad13c8a81c8c78369449efa" translate="yes" xml:space="preserve">
          <source>NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.</source>
          <target state="translated">NewReaderDict和NewReader一样,但使用了预设的字典。如果压缩数据没有引用字典,NewReaderDict会忽略它。如果压缩数据引用了不同的字典,NewReaderDict返回ErrDictionary。</target>
        </trans-unit>
        <trans-unit id="62226d4a3a7ef180876e33ca9f9e3e5dd9d4d275" translate="yes" xml:space="preserve">
          <source>NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.</source>
          <target state="translated">NewReaderSize 返回一个新的Reader,其缓冲区至少有指定的大小。如果参数io.Reader已经是一个足够大的Reader,它返回底层Reader。</target>
        </trans-unit>
        <trans-unit id="9a90b37d52d4387ba6d3b8a70e9b4fe0675a973d" translate="yes" xml:space="preserve">
          <source>NewRecorder returns an initialized ResponseRecorder.</source>
          <target state="translated">NewRecorder 返回一个初始化的 ResponseRecorder。</target>
        </trans-unit>
        <trans-unit id="cc38b91034f7148cfc66856688fcf7b15792b799" translate="yes" xml:space="preserve">
          <source>NewReplacer</source>
          <target state="translated">NewReplacer</target>
        </trans-unit>
        <trans-unit id="98fb98214a91e4f9ae6ab220237b228d86508a63" translate="yes" xml:space="preserve">
          <source>NewReplacer panics if given an odd number of arguments.</source>
          <target state="translated">如果给定奇数的参数,NewReplacer会感到恐慌。</target>
        </trans-unit>
        <trans-unit id="2061a29533176cb14bbeea4aaacbdde390807809" translate="yes" xml:space="preserve">
          <source>NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches. The old string comparisons are done in argument order.</source>
          <target state="translated">NewReplacer从新旧字符串对的列表中返回一个新的Replacer。替换是按照目标字符串中出现的顺序进行的,没有重叠的匹配。旧的字符串比较是按照参数顺序进行的。</target>
        </trans-unit>
        <trans-unit id="06ae50f5cf1308acbe8676644fb3a80e68b35dfc" translate="yes" xml:space="preserve">
          <source>NewRequest panics on error for ease of use in testing, where a panic is acceptable.</source>
          <target state="translated">NewRequest在出错时慌乱,方便在测试中使用,其中慌乱是可以接受的。</target>
        </trans-unit>
        <trans-unit id="dbad5b531961f7dd8c542979ba9a9f6fb56fe9e3" translate="yes" xml:space="preserve">
          <source>NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing.</source>
          <target state="translated">NewRequest返回一个新的传入服务器Request,适合传递给http.Handler进行测试。</target>
        </trans-unit>
        <trans-unit id="5c6d605363051e92ce514815fc8e9cdd4cb00b63" translate="yes" xml:space="preserve">
          <source>NewRequest wraps NewRequestWithContext using the background context.</source>
          <target state="translated">NewRequest使用后台上下文包装NewRequestWithContext。</target>
        </trans-unit>
        <trans-unit id="9035fed12b576aa1b44e2c5e5447b9c7c51d7382" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the NewRequest function in the net/http/httptest package, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields.</source>
          <target state="translated">NewRequestWithContext返回一个适合用于Client.Do或Transport.RoundTrip的Request。要创建一个用于测试服务器处理程序的请求,可以使用net/http/httptest包中的NewRequest函数,使用ReadRequest,或者手动更新Request字段。对于一个传出的客户端请求,上下文控制着请求及其响应的整个生命周期:获取连接、发送请求、读取响应头和body。关于入站请求字段和出站请求字段的区别,请参见Request类型的文档。</target>
        </trans-unit>
        <trans-unit id="1c9af43cdfcafd0e3590f3e143e4db860b3e1b49" translate="yes" xml:space="preserve">
          <source>NewRequestWithContext returns a new Request given a method, URL, and optional body.</source>
          <target state="translated">NewRequestWithContext返回一个给定方法、URL和可选body的新Request。</target>
        </trans-unit>
        <trans-unit id="6032a09b3acaf432867b7a2e2a1165faa7e1e7a1" translate="yes" xml:space="preserve">
          <source>NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.</source>
          <target state="translated">NewScanner 会返回一个新的 Scanner 来读取 r。</target>
        </trans-unit>
        <trans-unit id="95df7c8275be1758c09804f6f255a61f60fde088" translate="yes" xml:space="preserve">
          <source>NewScope creates a new scope nested in the outer scope.</source>
          <target state="translated">NewScope创建一个嵌套在外层作用域中的新作用域。</target>
        </trans-unit>
        <trans-unit id="80fe301e9f5c51453bef4cd9884ae93f5be56853" translate="yes" xml:space="preserve">
          <source>NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.</source>
          <target state="translated">NewScope 返回包含在给定父作用域中的新的空作用域(如果有的话)。注释仅用于调试。</target>
        </trans-unit>
        <trans-unit id="11c7ae4097aa2447e01ff30db2236f8b8bdd3d07" translate="yes" xml:space="preserve">
          <source>NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.</source>
          <target state="translated">NewSectionReader返回一个SectionReader,该SectionReader从偏移量off开始读取,并在n个字节后以EOF停止。</target>
        </trans-unit>
        <trans-unit id="92cc00b8df6d155a718390d6b132a73074091695" translate="yes" xml:space="preserve">
          <source>NewServeMux allocates and returns a new ServeMux.</source>
          <target state="translated">NewServeMux分配并返回一个新的ServeMux。</target>
        </trans-unit>
        <trans-unit id="f4c25e90df416fbb8a0117d35fe5407fe24aa713" translate="yes" xml:space="preserve">
          <source>NewServer returns a new Server.</source>
          <target state="translated">NewServer返回一个新的服务器。</target>
        </trans-unit>
        <trans-unit id="babde56071601a12e116397bafca814c40fa7cd4" translate="yes" xml:space="preserve">
          <source>NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewServer启动并返回一个新的Server。调用者应该在完成后调用Close来关闭它。</target>
        </trans-unit>
        <trans-unit id="c2a60c8cf74ea37683e9a87d1c42a435ef059ce9" translate="yes" xml:space="preserve">
          <source>NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.</source>
          <target state="translated">NewServerCodec在conn上使用JSON-RPC返回一个新的rpc.ServerCodec。</target>
        </trans-unit>
        <trans-unit id="8ce930cf303061e4c3d16d518dfb921dd3f19755" translate="yes" xml:space="preserve">
          <source>NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.</source>
          <target state="translated">NewServerConn是Go早期HTTP实现的一个产物。它是低级的、旧的,而且没有被Go当前的HTTP栈使用。我们应该在Go 1之前删除它。</target>
        </trans-unit>
        <trans-unit id="af189f332f7b93936d5df009ddc216614f2c215d" translate="yes" xml:space="preserve">
          <source>NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.</source>
          <target state="translated">NewSignature为给定的接收器、参数和结果返回一个新的函数类型,其中任何一个都可以是nil。如果设置了variadic,则该函数是变型的,它必须至少有一个参数,并且最后一个参数必须是未命名的分片类型。</target>
        </trans-unit>
        <trans-unit id="f456531de00193a99678056eea0c8fcdbfa6dfa5" translate="yes" xml:space="preserve">
          <source>NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is &quot;/base&quot; and the incoming request was for &quot;/dir&quot;, the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy.</source>
          <target state="translated">NewSingleHostReverseProxy返回一个新的ReverseProxy,将URL路由到target中提供的scheme、host和base路径。如果target的路径是&quot;/base&quot;,而传入的请求是&quot;/dir&quot;,那么target的请求将是/base/dir。NewSingleHostReverseProxy不会重写Host头。要重写Host头,请直接使用ReverseProxy和自定义Director策略。</target>
        </trans-unit>
        <trans-unit id="881af40d9181550600eb2130180e0aa0b7ef4fc9" translate="yes" xml:space="preserve">
          <source>NewSlice returns a new slice type for the given element type.</source>
          <target state="translated">NewSlice 返回给定元素类型的新片类型。</target>
        </trans-unit>
        <trans-unit id="e721e99b1b2d7da11daa968d62a8bde773167ca1" translate="yes" xml:space="preserve">
          <source>NewSource returns a new pseudo-random Source seeded with the given value. Unlike the default Source used by top-level functions, this source is not safe for concurrent use by multiple goroutines.</source>
          <target state="translated">NewSource返回一个新的伪随机Source,其种子为给定的值。与顶层函数使用的默认Source不同,这个Source对于多个goroutine的并发使用是不安全的。</target>
        </trans-unit>
        <trans-unit id="2632cf950aa513ee1017bf4dcbadbfbcd59a77fb" translate="yes" xml:space="preserve">
          <source>NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.</source>
          <target state="translated">NewStruct 返回一个包含给定字段和相应字段标签的新结构。如果索引为 i 的字段有标签,则 tags[i]必须是该标签,但 len(tags)的长度可能只相当于持有索引为 i 的最大标签所需的长度,因此,如果没有字段有标签,则 tags 可能为 nil。</target>
        </trans-unit>
        <trans-unit id="103ea95c3f50f8126d8830a74f99ac0e3f79bcc5" translate="yes" xml:space="preserve">
          <source>NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.</source>
          <target state="translated">NewSyscallError作为一个错误返回一个新的SyscallError,其中包含给定的系统调用名和错误细节。为了方便起见,如果err为nil,NewSyscallError返回nil。</target>
        </trans-unit>
        <trans-unit id="15af8e116827b7526d8d125b743d53ce97e9ccf0" translate="yes" xml:space="preserve">
          <source>NewTLSServer</source>
          <target state="translated">NewTLSServer</target>
        </trans-unit>
        <trans-unit id="ee9c0929ee87d66c85d071ce6743847eebd27e1d" translate="yes" xml:space="preserve">
          <source>NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down.</source>
          <target state="translated">NewTLSServer使用TLS启动并返回一个新的服务器。调用者应该在完成后调用Close来关闭它。</target>
        </trans-unit>
        <trans-unit id="00d18b3ba661f69ed9cfe9015dd706b999fa00de" translate="yes" xml:space="preserve">
          <source>NewTable decodes the Go symbol table (the &quot;.gosymtab&quot; section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.</source>
          <target state="translated">NewTable 对 Go 符号表(ELF 中的&quot;.gosymtab &quot;部分)进行解码,返回一个内存中的表示。从Go 1.3开始,Go符号表不再包含符号数据。</target>
        </trans-unit>
        <trans-unit id="6c3faf897ce3b4d9467485319643370fa9199652" translate="yes" xml:space="preserve">
          <source>NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.</source>
          <target state="translated">NewTask创建一个具有taskType类型的任务实例,并将其与携带该任务的Context一起返回。如果输入上下文包含一个任务,新任务就是它的子任务。</target>
        </trans-unit>
        <trans-unit id="b8fb5e998a5bfa39f457a0e00d00ff8fbdd42ef8" translate="yes" xml:space="preserve">
          <source>NewTicker</source>
          <target state="translated">NewTicker</target>
        </trans-unit>
        <trans-unit id="eee251daae31d5716c4903a076b81feb4bcdc3be" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b035640e964a55296a2efb5506fa864ce9c9bfff" translate="yes" xml:space="preserve">
          <source>NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.</source>
          <target state="translated">NewTicker返回一个新的Ticker,其中包含一个通道,该通道将以duration参数指定的周期发送时间。它调整时间间隔或丢弃ticks来弥补慢速接收者。持续时间d必须大于零,如果不大于零,NewTicker会恐慌。停止ticker以释放相关资源。</target>
        </trans-unit>
        <trans-unit id="bf6547887c37f917a009906b59fe98e227a67450" translate="yes" xml:space="preserve">
          <source>NewTimer creates a new Timer that will send the current time on its channel after at least duration d.</source>
          <target state="translated">NewTimer创建了一个新的定时器,它将在至少持续时间d后在其通道上发送当前时间。</target>
        </trans-unit>
        <trans-unit id="09aa7464c6b6cfad4c77e4bd499188c3746a2702" translate="yes" xml:space="preserve">
          <source>NewTokenDecoder creates a new XML parser using an underlying token stream.</source>
          <target state="translated">NewTokenDecoder使用底层的token流创建一个新的XML解析器。</target>
        </trans-unit>
        <trans-unit id="4a23d472e6b06cb6e963edf429927add90a46a91" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher</source>
          <target state="translated">NewTripleDESCipher</target>
        </trans-unit>
        <trans-unit id="84af04213903c43ab9d1e733d66e68af85c238b7" translate="yes" xml:space="preserve">
          <source>NewTripleDESCipher creates and returns a new cipher.Block.</source>
          <target state="translated">NewTripleDESCipher创建并返回一个新的cipher.Block。</target>
        </trans-unit>
        <trans-unit id="f40b69134a3f0736deea2eaa2750678b0c5b55ae" translate="yes" xml:space="preserve">
          <source>NewTuple returns a new tuple for the given variables.</source>
          <target state="translated">NewTuple 返回给定变量的新元组。</target>
        </trans-unit>
        <trans-unit id="c765721cc8a5281c315a4053b16ddc74c0799a82" translate="yes" xml:space="preserve">
          <source>NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.</source>
          <target state="translated">NewTypeName返回一个新的类型名,表示给定的类型。其余的参数设置了所有 Objects 的属性。</target>
        </trans-unit>
        <trans-unit id="389032a37584685bd3442905ff3d707a5dc68c23" translate="yes" xml:space="preserve">
          <source>NewUniform returns a new Uniform image of the given color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc82f99da3f381417b3f2ddf213f8678bc887a05" translate="yes" xml:space="preserve">
          <source>NewUnstartedServer returns a new Server but doesn't start it.</source>
          <target state="translated">NewUnstartedServer返回一个新的服务器,但不启动它。</target>
        </trans-unit>
        <trans-unit id="077e4a879a7f7aeb3402f9e60fcfed25d2f462f1" translate="yes" xml:space="preserve">
          <source>NewVar returns a new variable. The arguments set the attributes found with all Objects.</source>
          <target state="translated">NewVar返回一个新变量。参数设置了所有对象的属性。</target>
        </trans-unit>
        <trans-unit id="931cae5ffd260d5017ab39bc76af1f4af39d3c45" translate="yes" xml:space="preserve">
          <source>NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written.</source>
          <target state="translated">NewWriteLogger返回了一个写入器,它的行为与w类似,除了它记录(使用log.Printf)每次写入的标准错误,打印前缀和写入的十六进制数据。</target>
        </trans-unit>
        <trans-unit id="32dc084c221b7ac68250900d07e80ef98477176c" translate="yes" xml:space="preserve">
          <source>NewWriter</source>
          <target state="translated">NewWriter</target>
        </trans-unit>
        <trans-unit id="db406b8d211203f1503f7b49dc65e93e6c1d2ac9" translate="yes" xml:space="preserve">
          <source>NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function.</source>
          <target state="translated">NewWriter分配并初始化一个新的tabwriter.Writer。参数与Init函数相同。</target>
        </trans-unit>
        <trans-unit id="eb99a0a4fd37c15275e7565ffb0b13403d80a96e" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer writing to w.</source>
          <target state="translated">NewWriter创建一个新的Writer写到w。</target>
        </trans-unit>
        <trans-unit id="3c66bbe4244d139551b9b86abb1f943bea6cca3c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.</source>
          <target state="translated">NewWriter创建一个新的Writer。对返回的Writer的写入会被压缩并写入w。</target>
        </trans-unit>
        <trans-unit id="6d237dd5c37ca4fbda972f04e6f597bc8e44916c" translate="yes" xml:space="preserve">
          <source>NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1&amp;lt;&amp;lt;litWidth.</source>
          <target state="translated">NewWriter创建一个新的io.WriteCloser。写入返回的io.WriteCloser被压缩并写入w。完成写入后，调用方有责任在WriteCloser上调用Close。用于文字代码的位数litWidth必须在[2,8]范围内，通常为8。输入字节必须小于1 &amp;lt;&amp;lt; litWidth。</target>
        </trans-unit>
        <trans-unit id="5d8c71239de18e81bb2408f6be3d174f8b53cc5b" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.</source>
          <target state="translated">NewWriter返回一个新的Writer,在给定的级别上压缩数据。按照zlib,级别范围从1(BestSpeed)到9(BestCompression);更高的级别通常运行得更慢,但压缩得更多。0级(NoCompression)不尝试任何压缩;它只添加必要的DEFLATE帧。级别-1(DefaultCompression)使用默认的压缩级别。级别-2(HuffmanOnly)将只使用Huffman压缩,为所有类型的输入提供非常快速的压缩,但牺牲了相当大的压缩效率。</target>
        </trans-unit>
        <trans-unit id="77a9ef9463dc28c378543b4ca1ab833768dcb916" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer that writes to w.</source>
          <target state="translated">NewWriter返回一个新的Writer,写到w。</target>
        </trans-unit>
        <trans-unit id="6ed1faccc6afb2894578d5ce15a1b66df2ed7562" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer whose buffer has the default size.</source>
          <target state="translated">NewWriter返回一个新的Writer,其缓冲区的大小是默认的。</target>
        </trans-unit>
        <trans-unit id="28df5b8c07e84a79a10bcd4ad1689f3c9f232d1d" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing a zip file to w.</source>
          <target state="translated">NewWriter返回一个新的Writer,向w写一个zip文件。</target>
        </trans-unit>
        <trans-unit id="15d873b5f31a0567bb2f33a96b73193d43330bbf" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer writing to w.</source>
          <target state="translated">NewWriter返回一个新的Writer写作到w。</target>
        </trans-unit>
        <trans-unit id="8553cec920a1bbc2b884d29ae54a45cdb28b9a7f" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w.</source>
          <target state="translated">NewWriter返回一个新的Writer。写入返回的writer的内容会被压缩并写入w。</target>
        </trans-unit>
        <trans-unit id="41a8b4d0cc45c1f4744d9ed11afc5cc850ba9075" translate="yes" xml:space="preserve">
          <source>NewWriter returns a new multipart Writer with a random boundary, writing to w.</source>
          <target state="translated">NewWriter返回一个新的具有随机边界的多部分Writer,写到w。</target>
        </trans-unit>
        <trans-unit id="ba4df4f4844996231636be43db04ad5d9a575122" translate="yes" xml:space="preserve">
          <source>NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary.</source>
          <target state="translated">NewWriterDict 与 NewWriter 类似,但用预设的字典初始化新的 Writer。返回的Writer的行为就像字典已经被写入它而不产生任何压缩输出一样。写入 w 的压缩数据只能由一个用相同字典初始化的 Reader 解压。</target>
        </trans-unit>
        <trans-unit id="d66b95134ebabf02390f85e665bafa07e307f028" translate="yes" xml:space="preserve">
          <source>NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.</source>
          <target state="translated">NewWriterLevel和NewWriter一样,但是指定了压缩级别,而不是假设DefaultCompression。</target>
        </trans-unit>
        <trans-unit id="2244762bcd986f7cb2bc9adec833aa8f04c34752" translate="yes" xml:space="preserve">
          <source>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.</source>
          <target state="translated">NewWriterLevelDict和NewWriterLevel一样,但是指定了一个要压缩的字典。</target>
        </trans-unit>
        <trans-unit id="fba4df7d4f867ec10b6be90ace669ea6f21a1c64" translate="yes" xml:space="preserve">
          <source>NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.</source>
          <target state="translated">NewWriterSize返回一个新的Writer,其缓冲区至少有指定的大小,如果参数io.Writer已经是一个足够大的Writer,它返回底层Writer。如果参数io.Writer已经是一个足够大的Writer,它将返回底层Writer。</target>
        </trans-unit>
        <trans-unit id="6a8e1967a776dd6bc255e00e323e531b785051db" translate="yes" xml:space="preserve">
          <source>NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.</source>
          <target state="translated">NewYCbCr 返回一个新的 YCbCr 图像,该图像具有给定的边界和子样本比。</target>
        </trans-unit>
        <trans-unit id="24448d424137595a3746992f824b6edb3b30eda0" translate="yes" xml:space="preserve">
          <source>NewZipf returns a Zipf variate generator. The generator generates values k &amp;isin; [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s &amp;gt; 1 and v &amp;gt;= 1.</source>
          <target state="translated">NewZipf返回一个Zipf变量生成器。生成器生成值k&amp;isin;[0，imax]，使得P（k）与（v + k）**（-s）成比例。要求：s&amp;gt; 1和v&amp;gt; = 1。</target>
        </trans-unit>
        <trans-unit id="7ce32fccbc1a59952ff2a17d5ecf204917f2f0f8" translate="yes" xml:space="preserve">
          <source>Newlines and commas may be included in a quoted-field</source>
          <target state="translated">在引号栏中可以包含新行和逗号。</target>
        </trans-unit>
        <trans-unit id="680ad9f662c74a9364f8a6a8275f58c7b8082fcd" translate="yes" xml:space="preserve">
          <source>Next advances the map iterator and reports whether there is another entry. It returns false when the iterator is exhausted; subsequent calls to Key, Value, or Next will panic.</source>
          <target state="translated">Next推进map迭代器,并报告是否有其他条目。当迭代器耗尽时,它返回false;随后对Key、Value或Next的调用会产生恐慌。</target>
        </trans-unit>
        <trans-unit id="a3886733d4cb9e8e0a30e9e159418bfd55e791d5" translate="yes" xml:space="preserve">
          <source>Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded.</source>
          <target state="translated">Next前进到tar存档的下一个条目。Header.Size 决定下一个文件可以读取多少字节。当前文件中的任何剩余数据将被自动丢弃。</target>
        </trans-unit>
        <trans-unit id="4901308d5dc25a2990110e9739d7a18a2e5ad01b" translate="yes" xml:space="preserve">
          <source>Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases.</source>
          <target state="translated">Next准备下一条结果行,以便用Scan方法读取。如果成功的话,它返回true,如果没有下一条结果行或者在准备时发生了错误,则返回false。应该参考Err来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="4b13fef4541a1e8d67cdfed20bd2375d09afaf54" translate="yes" xml:space="preserve">
          <source>Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position.</source>
          <target state="translated">Next读取并返回下一个Unicode字符。它在源码结束时返回 EOF。如果不是 nil,它通过调用 s.Error 报告读取错误;否则,它会向 os.Stderr 打印错误信息。Next 不会更新 Scanner 的 Position 字段;使用 Pos()来获取当前位置。</target>
        </trans-unit>
        <trans-unit id="f9300d09b7df4ad5d5720f19adfdc038ac61f1df" translate="yes" xml:space="preserve">
          <source>Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry.</source>
          <target state="translated">Next从编码后的条目流中读取下一个条目。它返回nil,当它到达该部分结束时,返回nil。如果当前偏移量无效,或者偏移量处的数据不能被解码为有效的条目,它将返回一个错误。</target>
        </trans-unit>
        <trans-unit id="5e6ab5cae4a8ae2aa846c67f99d971fa518e2e06" translate="yes" xml:space="preserve">
          <source>Next reports whether there are more iterations to execute.</source>
          <target state="translated">下一步报告是否有更多的迭代要执行。</target>
        </trans-unit>
        <trans-unit id="93f915543eeb533b1a50713e83a0f24c2c27db55" translate="yes" xml:space="preserve">
          <source>Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.</source>
          <target state="translated">Next返回一个包含缓冲区中下一个n个字节的分片,就像Read返回的字节一样前进缓冲区。如果缓冲区中的字节数少于n个,Next将返回整个缓冲区。该分片只在下一次调用读或写方法之前有效。</target>
        </trans-unit>
        <trans-unit id="c448db08820ee5a2da21a99a2f7ee9ecfecee2a6" translate="yes" xml:space="preserve">
          <source>Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).</source>
          <target state="translated">Next返回下一个调用者的帧信息。如果more为false,则没有更多的调用者(Frame值有效)。</target>
        </trans-unit>
        <trans-unit id="330b3e94c1faae753e446839e4e00b09aaa021f5" translate="yes" xml:space="preserve">
          <source>Next returns the next id for a request/response pair.</source>
          <target state="translated">Next返回请求/响应对的下一个id。</target>
        </trans-unit>
        <trans-unit id="31070c09d9898d8d82df0861c7359cedd6d1bee8" translate="yes" xml:space="preserve">
          <source>Next returns the next list element or nil.</source>
          <target state="translated">Next返回下一个列表元素或nil。</target>
        </trans-unit>
        <trans-unit id="835c3bdc06b3af77ee23ce1cd0bc1f932319b6e0" translate="yes" xml:space="preserve">
          <source>Next returns the next ring element. r must not be empty.</source>
          <target state="translated">Next返回下一个环元素,r不能为空。</target>
        </trans-unit>
        <trans-unit id="3515095d5db1d9b6b3020f18bccf17c7141a06e9" translate="yes" xml:space="preserve">
          <source>Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF.</source>
          <target state="translated">Next将*条目设置为该行表的下一行,并移动到下一行。如果没有更多的条目,并且行表被正确地终止,它将返回io.EOF。</target>
        </trans-unit>
        <trans-unit id="59243d78d75adcc23308fcf3c7522b53b0e48d6d" translate="yes" xml:space="preserve">
          <source>NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="translated">NextPart返回multipart中的下一个part或一个错误。当没有更多的部件时,返回错误io.EOF。</target>
        </trans-unit>
        <trans-unit id="0b0a0e6bb9ba56ca1889244a65d5fa48810d737e" translate="yes" xml:space="preserve">
          <source>NextRawPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe82d0a11eaa23908a02323edde641d4f84c09e" translate="yes" xml:space="preserve">
          <source>NextResultSet prepares the next result set for reading. It reports whether there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases.</source>
          <target state="translated">NextResultSet为读取下一个结果集做准备。它报告是否有进一步的结果集,如果没有进一步的结果集或者有错误前进到该结果集,则报告false。应参考Err方法来区分这两种情况。</target>
        </trans-unit>
        <trans-unit id="98468e4766dcce0e39d3ad725e6449c114807ef7" translate="yes" xml:space="preserve">
          <source>Nextafter returns the next representable float64 value after x towards y.</source>
          <target state="translated">Nextafter在x之后向y返回下一个可表示的float64值。</target>
        </trans-unit>
        <trans-unit id="75d1da7ce66cd551626a0d105347dbf7bbebadb0" translate="yes" xml:space="preserve">
          <source>Nextafter32 returns the next representable float32 value after x towards y.</source>
          <target state="translated">Nextafter32返回x之后朝y方向的下一个可表示的float32值。</target>
        </trans-unit>
        <trans-unit id="f22ed1e707c4376c926b166081941a42b8018a27" translate="yes" xml:space="preserve">
          <source>Nil represents the predeclared value nil.</source>
          <target state="translated">Nil代表预先声明的值nil。</target>
        </trans-unit>
        <trans-unit id="7b09d67cac8107c868d3a3b7af77e77ea7720296" translate="yes" xml:space="preserve">
          <source>NilNode holds the special identifier 'nil' representing an untyped nil constant.</source>
          <target state="translated">NilNode持有特殊的标识符'nil',代表一个非类型的nil常量。</target>
        </trans-unit>
        <trans-unit id="b524d9a99adffa02a516e6aa0d4d13aac2897fdc" translate="yes" xml:space="preserve">
          <source>NoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set Request.Body to nil.</source>
          <target state="translated">NoBody是一个没有字节的io.ReadCloser。Read总是返回EOF,Close总是返回nil。它可以在传出的客户端请求中使用,以明确地表示请求的字节数为零。然而,一个替代方案是简单地将Request.Body设置为nil。</target>
        </trans-unit>
        <trans-unit id="52ef1a3746a958c4a53a19c9d87395684668883e" translate="yes" xml:space="preserve">
          <source>NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)</source>
          <target state="translated">NoGoError是Import用来描述一个目录的错误,该目录中不包含可构建的Go源文件(它可能仍然包含测试文件、被构建标签隐藏的文件等)。(它可能仍然包含测试文件、被构建标签隐藏的文件等。)</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="14b0e62d6fc1422eb757516da0b18c46890cfc16" translate="yes" xml:space="preserve">
          <source>Node formats node in canonical gofmt style and writes the result to dst.</source>
          <target state="translated">节点以规范的gofmt样式格式化节点,并将结果写入dst。</target>
        </trans-unit>
        <trans-unit id="da15215d50f0207cc3f3bf867716d8b653cbbf4d" translate="yes" xml:space="preserve">
          <source>NodeType identifies the type of a parse tree node.</source>
          <target state="translated">NodeType标识一个解析树节点的类型。</target>
        </trans-unit>
        <trans-unit id="b2c069378b3bfe6ff1e505ef1691402f0b8b4e2b" translate="yes" xml:space="preserve">
          <source>Non-Go programs that call Go code</source>
          <target state="translated">调用围棋代码的非围棋程序</target>
        </trans-unit>
        <trans-unit id="902b501103969363a75f55b1d4ea5e8e3aaa9ff5" translate="yes" xml:space="preserve">
          <source>Non-string values can be used in JavaScript contexts. If {{.}} is</source>
          <target state="translated">非字符串值可以在JavaScript上下文中使用。如果{{.}}是</target>
        </trans-unit>
        <trans-unit id="3d2c97b640a04b4cfaa42b436b4f88eedd1e3354" translate="yes" xml:space="preserve">
          <source>Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.</source>
          <target state="translated">Noop向服务器发送NOOP命令。它什么也不做,只是检查与服务器的连接是否正常。</target>
        </trans-unit>
        <trans-unit id="85cca9a9c13590980a1e26da797767deb94d87fd" translate="yes" xml:space="preserve">
          <source>NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.</source>
          <target state="translated">NopCloser返回一个ReadCloser,它有一个无操作的Close方法,包裹着提供的Reader r。</target>
        </trans-unit>
        <trans-unit id="7bc360841341e5ff79e2d9db0ccaba1681a641e9" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64返回一个正态分布的float64,范围从-math.MaxFloat64到+math.MaxFloat64,包含标准正态分布(平均值=0,stddev=1)。要产生不同的正态分布,调用者可以使用调整输出。</target>
        </trans-unit>
        <trans-unit id="584a03e17a58b140265f4319a3b8d37d0b326573" translate="yes" xml:space="preserve">
          <source>NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:</source>
          <target state="translated">NormFloat64从默认的Source返回一个正态分布的float64,范围是[-math.MaxFloat64,+math.MaxFloat64],具有标准正态分布(平均值=0,stddev=1)。要产生不同的正态分布,调用者可以使用调整输出。</target>
        </trans-unit>
        <trans-unit id="16ef8f27fb77f3e3923ae623df4ac9f719342330" translate="yes" xml:space="preserve">
          <source>Not all drivers and databases support OUTPUT value parameters.</source>
          <target state="translated">并非所有的驱动程序和数据库都支持OUTPUT值参数。</target>
        </trans-unit>
        <trans-unit id="28197ebc86a75fec0d20747340a0a7790f4e6e65" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of types. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of type before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run-time panic.</source>
          <target state="translated">并非所有方法都适用于所有类型。如果有任何限制,会在每个方法的文档中注明。在调用特定类型的方法之前,请使用 Kind 方法找出类型的种类。调用不适合类型种类的方法会引起运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="aebe464c9e025a8d065addc9b1418e295beb91ab" translate="yes" xml:space="preserve">
          <source>Not all methods apply to all kinds of values. Restrictions, if any, are noted in the documentation for each method. Use the Kind method to find out the kind of value before calling kind-specific methods. Calling a method inappropriate to the kind of type causes a run time panic.</source>
          <target state="translated">并非所有方法都适用于所有类型的数值。如果有任何限制,会在每个方法的文档中注明。在调用特定种类的方法之前,请使用种类方法找出值的种类。调用不适合类型的方法会导致运行时的恐慌。</target>
        </trans-unit>
        <trans-unit id="0ad6482316efeb0367fac0cef294df9931657e21" translate="yes" xml:space="preserve">
          <source>Not sets z = ^x and returns z.</source>
          <target state="translated">不设置z=^x,并返回z。</target>
        </trans-unit>
        <trans-unit id="7742382b9eb1d24a7003bcf20989045729354b55" translate="yes" xml:space="preserve">
          <source>NotFound replies to the request with an HTTP 404 not found error.</source>
          <target state="translated">NotFound以HTTP 404 not found错误来回复该请求。</target>
        </trans-unit>
        <trans-unit id="d73243f8dff55155dc23697de39081a99659e339" translate="yes" xml:space="preserve">
          <source>NotFoundHandler</source>
          <target state="translated">NotFoundHandler</target>
        </trans-unit>
        <trans-unit id="4cb94eae88a4f55a499c64d3eb533d60d5f636a3" translate="yes" xml:space="preserve">
          <source>NotFoundHandler returns a simple request handler that replies to each request with a &amp;ldquo;404 page not found&amp;rdquo; reply.</source>
          <target state="translated">NotFoundHandler返回一个简单的请求处理程序，该处理程序使用&amp;ldquo; 404页面未找到&amp;rdquo;答复来答复每个请求。</target>
        </trans-unit>
        <trans-unit id="fa1f72946015817c3defa6f9ca3e62b13a4cbe23" translate="yes" xml:space="preserve">
          <source>NotNilFilter returns true for field values that are not nil; it returns false otherwise.</source>
          <target state="translated">NotNilFilter对非零的字段值返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="48697afd9134ab8c796d4134241a98bd8c0e1e0e" translate="yes" xml:space="preserve">
          <source>NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">NotNull是一个实现ValueConverter的类型,它不允许nil值,但在其他方面委托给另一个ValueConverter。</target>
        </trans-unit>
        <trans-unit id="ea5ffd3d5d924f61e0aab5c8328c4565de280e8f" translate="yes" xml:space="preserve">
          <source>Notational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver).</source>
          <target state="translated">符号惯例。输入的方法参数(包括接收者)在API中的命名是一致的,以明确其用途。输入的操作数通常被命名为x、y、a、b等,但从不命名为z。指定结果的参数被命名为z(通常是接收方)。</target>
        </trans-unit>
        <trans-unit id="08dfc0b4556c0a1e642330802e9a9fdabdeafde7" translate="yes" xml:space="preserve">
          <source>Note that *os.File implements the io.ReadSeeker interface.</source>
          <target state="translated">请注意,*os.File实现了io.ReadSeeker接口。</target>
        </trans-unit>
        <trans-unit id="c7438b24f5f10d8ed5111e3a3eeea38cdce805d1" translate="yes" xml:space="preserve">
          <source>Note that DWARF line tables only permit sequential, forward scans. Hence, in the worst case, this takes time linear in the size of the line table. If the caller wishes to do repeated fast PC lookups, it should build an appropriate index of the line table.</source>
          <target state="translated">请注意,DWARF行表只允许进行顺序的正向扫描。因此,在最坏的情况下,这需要的时间与行表的大小呈线性关系。如果调用者希望进行重复的快速PC查找,就应该建立行表的适当索引。</target>
        </trans-unit>
        <trans-unit id="1708406405db2b0b3521a819d371938a3ec0fc07" translate="yes" xml:space="preserve">
          <source>Note that Dir could expose sensitive files and directories. Dir will follow symlinks pointing out of the directory tree, which can be especially dangerous if serving from a directory in which users are able to create arbitrary symlinks. Dir will also allow access to files and directories starting with a period, which could expose sensitive directories like .git or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08c2aea787a35db90158742ee5e75a3c73282a4" translate="yes" xml:space="preserve">
          <source>Note that Dir will allow access to files and directories starting with a period, which could expose sensitive directories like a .git directory or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation.</source>
          <target state="translated">请注意,Dir将允许访问以句号开头的文件和目录,这可能会暴露敏感目录,如.git目录或敏感文件,如.htpasswd。要排除以句号开头的文件,请从服务器上删除这些文件/目录,或者创建一个自定义的FileSystem实现。</target>
        </trans-unit>
        <trans-unit id="393ff3471e998698fad165109d1597eedb023fa4" translate="yes" xml:space="preserve">
          <source>Note that DirFS(&quot;/prefix&quot;) only guarantees that the Open calls it makes to the operating system will begin with &quot;/prefix&quot;: DirFS(&quot;/prefix&quot;).Open(&quot;file&quot;) is the same as os.Open(&quot;/prefix/file&quot;). So if /prefix/file is a symbolic link pointing outside the /prefix tree, then using DirFS does not stop the access any more than using os.Open does. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74976bc5278e7780a62cf9ceb79267a86a939300" translate="yes" xml:space="preserve">
          <source>Note that FIPS 186-3 section 4.6 specifies that the hash should be truncated to the byte-length of the subgroup. This function does not perform that truncation itself.</source>
          <target state="translated">请注意,FIPS 186-3 第 4.6 节规定,哈希应该被截断到子组的字节长度。这个函数本身并不执行这种截断。</target>
        </trans-unit>
        <trans-unit id="bbf97d3b36e492a77bf717cf84e9406daab3263a" translate="yes" xml:space="preserve">
          <source>Note that Init may call err if there is an error in the first character of the file.</source>
          <target state="translated">请注意,如果文件的第一个字符有错误,Init可能会调用err。</target>
        </trans-unit>
        <trans-unit id="7a0c39680eb9df4d26108a728fd58d66d7905a72" translate="yes" xml:space="preserve">
          <source>Note that LineContinuations are not allowed. JSStr(&quot;foo\\nbar&quot;) is fine, but JSStr(&quot;foo\\\nbar&quot;) is not.</source>
          <target state="translated">注意,不允许使用LineContinuations。JSStr(&quot;foo\\nbar&quot;)可以,但JSStr(&quot;foo\\nbar&quot;)不可以。</target>
        </trans-unit>
        <trans-unit id="fa1d78ad1e16f8cfce0fba38b7b9641b9c047419" translate="yes" xml:space="preserve">
          <source>Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706c905f9e49dd39547ae798a12e332969a754b" translate="yes" xml:space="preserve">
          <source>Note that Push and Pop in this interface are for package heap's implementation to call. To add and remove things from the heap, use heap.Push and heap.Pop.</source>
          <target state="translated">注意,这个接口中的Push和Pop是给包heap的实现调用的。要从堆中添加和删除东西,可以使用heap.Push和heap.Pop。</target>
        </trans-unit>
        <trans-unit id="2ac58c63ec2feb638471975be648c8926228c666" translate="yes" xml:space="preserve">
          <source>Note that Sub(os.DirFS(&quot;/&quot;), &quot;prefix&quot;) is equivalent to os.DirFS(&quot;/prefix&quot;) and that neither of them guarantees to avoid operating system accesses outside &quot;/prefix&quot;, because the implementation of os.DirFS does not check for symbolic links inside &quot;/prefix&quot; that point to other directories. That is, os.DirFS is not a general substitute for a chroot-style security mechanism, and Sub does not change that fact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57724cba67b0754543683d705a43db50bcf5c63d" translate="yes" xml:space="preserve">
          <source>Note that both conversions must appear in the same expression, with only the intervening arithmetic between them:</source>
          <target state="translated">需要注意的是,这两种转换必须出现在同一个表达式中,它们之间只有中间的算式。</target>
        </trans-unit>
        <trans-unit id="00d2f4b507ea636132af470ff7c66414d9db9755" translate="yes" xml:space="preserve">
          <source>Note that calls with a positive delta that occur when the counter is zero must happen before a Wait. Calls with a negative delta, or calls with a positive delta that start when the counter is greater than zero, may happen at any time. Typically this means the calls to Add should execute before the statement creating the goroutine or other event to be waited for. If a WaitGroup is reused to wait for several independent sets of events, new Add calls must happen after all previous Wait calls have returned. See the WaitGroup example.</source>
          <target state="translated">请注意,当计数器为零时发生的正delta的呼叫必须在Wait之前发生。负delta的调用,或者当计数器大于零时开始的正delta的调用,可以在任何时候发生。通常这意味着对Add的调用应该在创建goroutine或其他要等待的事件的语句之前执行。如果重用一个WaitGroup来等待几组独立的事件,那么新的Add调用必须在所有之前的Wait调用返回后发生。请看WaitGroup的例子。</target>
        </trans-unit>
        <trans-unit id="5455acc6a0156c4dfa920acddbd7ebf8cf932467" translate="yes" xml:space="preserve">
          <source>Note that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes.</source>
          <target state="translated">请注意,即使对于支持Flush的ResponseWriters,如果客户端是通过HTTP代理连接的,在响应完成之前,缓冲的数据可能不会到达客户端。</target>
        </trans-unit>
        <trans-unit id="64cbc1b328d9716763cd1ed4ffd9ce9462300826" translate="yes" xml:space="preserve">
          <source>Note that for the CHAR and STRING kinds, the literal is stored with its quotes. For example, for a double-quoted STRING, the first and the last rune in the Value field will be &quot;. The Unquote and UnquoteChar functions in the strconv package can be used to unquote STRING and CHAR values, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3bd0ea640e306f27d50ba34f2f7b783e999786" translate="yes" xml:space="preserve">
          <source>Note that formatting of Go source code changes over time, so tools relying on consistent formatting should execute a specific version of the gofmt binary instead of using this package. That way, the formatting will be stable, and the tools won't need to be recompiled each time gofmt changes.</source>
          <target state="translated">请注意,Go源代码的格式化会随着时间的推移而改变,所以依赖一致格式化的工具应该执行特定版本的gofmt二进制,而不是使用这个包。这样一来,格式化将是稳定的,而且每次gofmt改变时,工具都不需要重新编译。</target>
        </trans-unit>
        <trans-unit id="e22ab49cba234a39b62136e423150811ceaf9eb2" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still read (and discard) 1 byte from the connection.</source>
          <target state="translated">请注意，如果len（b）== 0且len（oob）&amp;gt; 0，则此函数仍将从连接中读取（并丢弃）1个字节。</target>
        </trans-unit>
        <trans-unit id="1c2f06f3a5255f8d8b8129f0755c03b6610969a5" translate="yes" xml:space="preserve">
          <source>Note that if len(b) == 0 and len(oob) &amp;gt; 0, this function will still write 1 byte to the connection.</source>
          <target state="translated">请注意，如果len（b）== 0且len（oob）&amp;gt; 0，则此函数仍将向连接写入1个字节。</target>
        </trans-unit>
        <trans-unit id="6530be365312a7c4f8e32cd5888520ad9f3f1f1d" translate="yes" xml:space="preserve">
          <source>Note that if the session key is too small then it may be possible for an attacker to brute-force it. If they can do that then they can learn whether a random value was used (because it'll be different for the same ciphertext) and thus whether the padding was correct. This defeats the point of this function. Using at least a 16-byte key will protect against this attack.</source>
          <target state="translated">请注意,如果会话密钥太小,那么攻击者可能会对其进行强行破解。如果他们能做到这一点,那么他们就可以了解到是否使用了随机值(因为对于相同的密文,它将是不同的),从而了解到填充是否正确。这就违背了这个函数的意义。使用至少16字节的密钥可以防止这种攻击。</target>
        </trans-unit>
        <trans-unit id="344ecaa4cf851728d938597c41196d419ce8996a" translate="yes" xml:space="preserve">
          <source>Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address.</source>
          <target state="translated">请注意,在本文档中,将一个IP地址称为IPv4地址或IPv6地址是地址的语义属性,而不仅仅是字节分片的长度:一个16字节的分片仍然可以是一个IPv4地址。</target>
        </trans-unit>
        <trans-unit id="a249db9e2c9671edb18dbf9a7216586dc071e0a3" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs.</source>
          <target state="translated">请注意,不可能正确使用Reset的返回值,因为在耗尽通道和新的定时器到期之间有一个竞赛条件。如上所述,Reset应始终在停止或过期的通道上调用。返回值的存在是为了保持与现有程序的兼容性。</target>
        </trans-unit>
        <trans-unit id="9e389ad8751ed58f2ca67fb14ba2bd798ed9096f" translate="yes" xml:space="preserve">
          <source>Note that multiple subexpressions can be written using the same name, as in (?P&amp;lt;bob&amp;gt;a+)(?P&amp;lt;bob&amp;gt;b+), which declares two subexpressions named &quot;bob&quot;. In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47adc6d6003c04964db156378f371c69c6920eb2" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcbc6dbbe1cd946285db0917941f30791e5e34b" translate="yes" xml:space="preserve">
          <source>Note that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert, below). This can only happen for dot-imported objects whose scope is the scope of the package that exported them.</source>
          <target state="translated">请注意,如果对象被插入到了作用域中,并且当时已经有了父对象,那么obj.Parent()可能会与返回的作用域不同(参见下面的插入)。这只可能发生在点导入的对象上,其作用域是导出它们的包的作用域。</target>
        </trans-unit>
        <trans-unit id="fedc6a9186b4da1c6c4f2abf1943dc2cd31def02" translate="yes" xml:space="preserve">
          <source>Note that paths are slash-separated on all systems, even Windows. Paths containing other characters such as backslash and colon are accepted as valid, but those characters must never be interpreted by an FS implementation as path element separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b894b1c82e2b9813c83c86241df2c9ed11092e90" translate="yes" xml:space="preserve">
          <source>Note that re-use has some caveats. Notably, Values should not be read or manipulated while a Read with that value is outstanding; that is a data race. This property includes pointer-typed Values (for example, Float64Histogram) whose underlying storage will be reused by Read when possible. To safely use such values in a concurrent setting, all data must be deep-copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295b47a82aa942008478736d689df68628de7e25" translate="yes" xml:space="preserve">
          <source>Note that since a pattern ending in a slash names a rooted subtree, the pattern &quot;/&quot; matches all paths not matched by other registered patterns, not just the URL with Path == &quot;/&quot;.</source>
          <target state="translated">请注意,由于以斜杠结尾的模式命名了一个根的子树,所以模式&quot;/&quot;匹配所有未被其他注册模式匹配的路径,而不仅仅是路径==&quot;/&quot;的URL。</target>
        </trans-unit>
        <trans-unit id="5f4e1f66b103f275a7a85fe240ec0793b18c4588" translate="yes" xml:space="preserve">
          <source>Note that the 'x' form is the one used by most other languages and libraries.</source>
          <target state="translated">请注意,&quot;x &quot;形式是大多数其他语言和库所使用的形式。</target>
        </trans-unit>
        <trans-unit id="62af18353b85ece5ad43a8e2791ac7b4ef16a2b9" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values.</source>
          <target state="translated">请注意,Go ==运算符不仅比较时间瞬间,还比较位置和单调时钟读数。参见时间类型的文档,了解时间值的平等测试。</target>
        </trans-unit>
        <trans-unit id="9bc5465e665f7d6206122a236966d74814c47dbc" translate="yes" xml:space="preserve">
          <source>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.</source>
          <target state="translated">请注意,Go ==运算符不仅比较时间的瞬间,而且比较位置和单调时钟读数。因此,在没有首先保证所有值都设置了相同的Location(可以通过使用UTC或Local方法来实现),以及通过设置t=t.Round(0)来剥离单调时钟读数的情况下,不应该将时间值用作地图或数据库键。一般来说,更倾向于使用t.Equal(u)而不是t ==u,因为t.Equal使用了最精确的比较,并且正确处理了只有一个参数具有单调时钟读数的情况。</target>
        </trans-unit>
        <trans-unit id="f47d1736b65573bc0db0e46ddb437d8586c42dc1" translate="yes" xml:space="preserve">
          <source>Note that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later.</source>
          <target state="translated">请注意,围棋运行时会将恐慌和崩溃的信息写入标准错误;关闭 Stderr 可能会导致这些信息转到其他地方,也许是以后打开的文件。</target>
        </trans-unit>
        <trans-unit id="7b94d521ccf655c50db2b1ef784ea75e16313781" translate="yes" xml:space="preserve">
          <source>Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use RawPath, an optional field which only gets set if the default encoding is different from Path.</source>
          <target state="translated">请注意,路径字段是以解码形式存储的。/%47%6f%2f变成了/Go/。这样做的结果是,无法区分Path中哪些是原始URL中的斜线,哪些是%2f。这种区分很少是重要的,但是当它是重要的时候,代码应该使用RawPath,这是一个可选的字段,只有当默认编码与Path不同时才会被设置。</target>
        </trans-unit>
        <trans-unit id="2571b053e2312e837e4fa30b8af829d887a497ae" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb073049f21533864d69200a5feb9b782ae4382" translate="yes" xml:space="preserve">
          <source>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use &quot;UTC&quot; as the time zone abbreviation, while strictly speaking those RFCs require the use of &quot;GMT&quot; in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.</source>
          <target state="translated">请注意,RFC822、RFC850和RFC1123格式只能应用于本地时间。将它们应用于UTC时间将使用 &quot;UTC &quot;作为时区缩写,而严格来说,这些RFC要求在这种情况下使用 &quot;GMT&quot;。一般来说,对于坚持这种格式的服务器,应该使用RFC1123Z而不是RFC1123,对于新协议,应该首选RFC3339。RFC3339、RFC822、RFC822Z、RFC1123和RFC1123Z对格式化很有用;当与time.Parse一起使用时,它们并不接受RFC所允许的所有时间格式。RFC3339Nano格式从秒字段中去掉了尾部的零,因此一旦格式化后可能无法正确排序。</target>
        </trans-unit>
        <trans-unit id="bf45110f19f93211e34437dda6c947478fbddd92" translate="yes" xml:space="preserve">
          <source>Note that the examples in this package assume a Unix system. They may not run on Windows, and they do not run in the Go Playground used by golang.org and godoc.org.</source>
          <target state="translated">请注意,这个软件包中的例子是以Unix系统为前提的。它们可能无法在 Windows 上运行,也无法在 golang.org 和 godoc.org 使用的 Go Playground 中运行。</target>
        </trans-unit>
        <trans-unit id="b0a81d3e2cb77a7a98d611a9a24358352c170df1" translate="yes" xml:space="preserve">
          <source>Note that the input is still malleable, as new line characters (CR and LF) are still ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532559dd628d5f97489f0222823fd716d088b914" translate="yes" xml:space="preserve">
          <source>Note that the point at infinity (0, 0) is not considered on the curve, and although it can be returned by Add, Double, ScalarMult, or ScalarBaseMult, it can't be marshaled or unmarshaled, and IsOnCurve will return false for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabbff14cb2952c80edb181213c130b459a02692" translate="yes" xml:space="preserve">
          <source>Note that the pointer must point into an allocated object, so it may not be nil.</source>
          <target state="translated">请注意,指针必须指向一个已分配的对象,所以它不可能是零。</target>
        </trans-unit>
        <trans-unit id="ee73d643f6fa22eddd036e602800c4d837e9ec70" translate="yes" xml:space="preserve">
          <source>Note that using CGI means starting a new process to handle each request, which is typically less efficient than using a long-running server. This package is intended primarily for compatibility with existing systems.</source>
          <target state="translated">请注意,使用CGI意味着启动一个新的进程来处理每个请求,这通常比使用一个长期运行的服务器效率低。这个软件包的目的主要是为了与现有系统兼容。</target>
        </trans-unit>
        <trans-unit id="e229bb3e45eb0475b8c930c1335cc5ff4dab911b" translate="yes" xml:space="preserve">
          <source>Note that whether this function returns an error or not discloses secret information. If an attacker can cause this function to run repeatedly and learn whether each instance returned an error then they can decrypt and forge signatures as if they had the private key. See DecryptPKCS1v15SessionKey for a way of solving this problem.</source>
          <target state="translated">注意,这个函数是否返回错误会泄露秘密信息。如果攻击者可以使这个函数反复运行,并了解到每个实例是否返回错误,那么他们就可以像拥有私钥一样解密和伪造签名。解决这个问题的方法请参见DecryptPKCS1v15SessionKey。</target>
        </trans-unit>
        <trans-unit id="916171d84342fed453d228a3166add2d096261bc" translate="yes" xml:space="preserve">
          <source>Note: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type.</source>
          <target state="translated">注意:Eval和CheckExpr不应该被用来代替运行Check来计算类型和值,而是应该被用来代替Check,因为这些函数忽略了使用表达式的上下文(例如,赋值)。因此,顶层的非类型常量将返回一个非类型的类型,而不是各自的上下文特定类型。</target>
        </trans-unit>
        <trans-unit id="bd05f6d0d39a629d554e37dad544b0971bdc2e22" translate="yes" xml:space="preserve">
          <source>Note: Fscan etc. can read one character (rune) past the input they return, which means that a loop calling a scan routine may skip some of the input. This is usually a problem only when there is no space between input values. If the reader provided to Fscan implements ReadRune, that method will be used to read characters. If the reader also implements UnreadRune, that method will be used to save the character and successive calls will not lose data. To attach ReadRune and UnreadRune methods to a reader without that capability, use bufio.NewReader.</source>
          <target state="translated">注意:Fscan等可以从它们返回的输入中读取一个字符(符文),这意味着调用扫描例程的循环可能会跳过一些输入。这通常只有在输入值之间没有空格时才会出现问题。如果提供给Fscan的阅读器实现了ReadRune,那么该方法将被用来读取字符。如果阅读器也实现了UnreadRune,那么该方法将被用来保存字符,并且连续的调用不会丢失数据。要将ReadRune和UnreadRune方法附加到一个没有该功能的阅读器上,请使用bufio.NewReader.NewReader。</target>
        </trans-unit>
        <trans-unit id="2262c6082b97775886bda26c19137facc9855b36" translate="yes" xml:space="preserve">
          <source>Note: Since gobs can be stored permanently, it is good design to guarantee the encoding used by a GobEncoder is stable as the software evolves. For instance, it might make sense for GobEncode to include a version number in the encoding.</source>
          <target state="translated">注意:由于gob可以永久保存,所以保证GobEncoder使用的编码随着软件的发展而稳定是一个好的设计。例如,GobEncode在编码中包含一个版本号可能是有意义的。</target>
        </trans-unit>
        <trans-unit id="a1a8b94ea000b0ee13d1c73b1460cd401f581d14" translate="yes" xml:space="preserve">
          <source>Note: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues.</source>
          <target state="translated">注意:一个文件上的最大并发操作数可能受到操作系统或系统的限制。这个数字应该很高,但超过这个数字可能会降低性能或导致其他问题。</target>
        </trans-unit>
        <trans-unit id="e78b4237e62fef8d0e64dd07f8141dd5b9dd8dd5" translate="yes" xml:space="preserve">
          <source>Note: this method does not generate an RFC 5280 conformant X.509 v2 CRL. To generate a standards compliant CRL, use CreateRevocationList instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27a7e32b7a1bd280289613fd2ddd6c441487040" translate="yes" xml:space="preserve">
          <source>Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New.</source>
          <target state="translated">Notice会记录一条严重性为LOG_NOTICE的消息,忽略传递给New的严重性。</target>
        </trans-unit>
        <trans-unit id="6c03ee54ad3a51fc92a1d69943e99667847705b6" translate="yes" xml:space="preserve">
          <source>Notify</source>
          <target state="translated">Notify</target>
        </trans-unit>
        <trans-unit id="f32ad9d0db01cf6742ecb4a7f760ed9166d4e428" translate="yes" xml:space="preserve">
          <source>Notify (AllSignals)</source>
          <target state="translated">通知 (AllSignals)</target>
        </trans-unit>
        <trans-unit id="ec0a8c1ae8d23b04c5ac40659f605bd7d0769148" translate="yes" xml:space="preserve">
          <source>Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.</source>
          <target state="translated">如果没有提供信号,则所有输入的信号将被中继到c,否则,仅提供信号。</target>
        </trans-unit>
        <trans-unit id="1dd2e9632e1d54f09b183732b58f92622a16dfc8" translate="yes" xml:space="preserve">
          <source>Notify disables the default behavior for a given set of asynchronous signals and instead delivers them over one or more registered channels. Specifically, it applies to the signals SIGHUP, SIGINT, SIGQUIT, SIGABRT, and SIGTERM. It also applies to the job control signals SIGTSTP, SIGTTIN, and SIGTTOU, in which case the system default behavior does not occur. It also applies to some signals that otherwise cause no action: SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGCHLD, SIGCONT, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGWINCH, SIGIO, SIGPWR, SIGSYS, SIGINFO, SIGTHR, SIGWAITING, SIGLWP, SIGFREEZE, SIGTHAW, SIGLOST, SIGXRES, SIGJVM1, SIGJVM2, and any real time signals used on the system. Note that not all of these signals are available on all systems.</source>
          <target state="translated">Notify禁用给定异步信号集的默认行为,而是通过一个或多个注册通道来传递它们。具体来说,它适用于信号SIGHUP、SIGINT、SIGQUIT、SIGABRT和SIGTERM。它也适用于作业控制信号SIGTSTP、SIGTTIN和SIGTTOU,在这种情况下,系统默认行为不会发生。它也适用于一些其他情况下不会引起任何动作的信号。SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGCHLD、SIGCONT、SIGURG、SIGXCPU、SIGXFSZ、SIGVTALRM、SIGWINCH、SIGIO、SIGPWR、SIGSYS、SIGINFO、SIGTHR、SIGWAITING、SIGLWP、SIGFREEZE、SIGTHAW、SIGLOST、SIGXRES、SIGJVM1、SIGJVM2以及系统上使用的任何实时信号。需要注意的是,并不是所有的系统都能使用这些信号。</target>
        </trans-unit>
        <trans-unit id="ec1c8c26ce98414989276e685377bfa9bed740af" translate="yes" xml:space="preserve">
          <source>NotifyContext</source>
          <target state="translated">NotifyContext</target>
        </trans-unit>
        <trans-unit id="02ae0b499d7d8a520d67a814401a2f5ce01f64ec" translate="yes" xml:space="preserve">
          <source>NotifyContext returns a copy of the parent context that is marked done (its Done channel is closed) when one of the listed signals arrives, when the returned stop function is called, or when the parent context's Done channel is closed, whichever happens first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03da0ac3a6fe09e0b74b0584dcf52f14832da35" translate="yes" xml:space="preserve">
          <source>Now returns the current local time.</source>
          <target state="translated">现在返回当前当地时间。</target>
        </trans-unit>
        <trans-unit id="12f30fd28d8fbc7bdfb188f1073bae8ad0c81a0a" translate="yes" xml:space="preserve">
          <source>NsPerOp returns the &quot;ns/op&quot; metric.</source>
          <target state="translated">NsPerOp返回 &quot;ns/op &quot;指标。</target>
        </trans-unit>
        <trans-unit id="3e29aeff769634126fe308f4a3be01d64c577d98" translate="yes" xml:space="preserve">
          <source>NsecToTimespec converts a number of nanoseconds into a Timespec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f04b0789ea5fe434b5bac945daef8d6c790ae0" translate="yes" xml:space="preserve">
          <source>NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.</source>
          <target state="translated">NsecToTimespec取Unix纪元以来的纳秒数,并返回相应的Timespec值。</target>
        </trans-unit>
        <trans-unit id="0982b86aa619573eb41cb1f627ccd8ec0dad5961" translate="yes" xml:space="preserve">
          <source>NsecToTimeval converts a number of nanoseconds into a Timeval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba97613a512663d90a9d8bf323b048ee6483da36" translate="yes" xml:space="preserve">
          <source>NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.</source>
          <target state="translated">NsecToTimeval取Unix纪元以来的纳秒数,并返回相应的Timeval值。</target>
        </trans-unit>
        <trans-unit id="50a5fe209ccfd051610f95a63741ad7f7b729cb1" translate="yes" xml:space="preserve">
          <source>Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter.</source>
          <target state="translated">Null是一个实现ValueConverter的类型,它允许nil值,但在其他情况下委托给另一个ValueConverter。</target>
        </trans-unit>
        <trans-unit id="98cd8ff39a93a75c21d65e0a235ee463a7bbb829" translate="yes" xml:space="preserve">
          <source>Null returns the JavaScript value &quot;null&quot;.</source>
          <target state="translated">Null返回JavaScript值 &quot;null&quot;。</target>
        </trans-unit>
        <trans-unit id="6f8b0f41b489cc3f5ce2776f939ca31dc0509085" translate="yes" xml:space="preserve">
          <source>NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullBool代表一个可能为空的bool。NullBool实现了Scanner接口,所以它可以作为一个扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="6792a3139e23717e375cad9a592c4bd259439184" translate="yes" xml:space="preserve">
          <source>NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.</source>
          <target state="translated">NullBytes包含代表DER编码的ASN.1 NULL类型的字节。</target>
        </trans-unit>
        <trans-unit id="5f6d3dcfb1e3aa678952637bbe19fdc90b78b127" translate="yes" xml:space="preserve">
          <source>NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullFloat64表示一个可能为空的float64。NullFloat64实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="9e472847699046a5829bc4e4e7c408ab93169a01" translate="yes" xml:space="preserve">
          <source>NullInt32 represents an int32 that may be null. NullInt32 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt32代表一个可能是空的int32。NullInt32实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="9129057ccbbeafcc9b65fe6615ea2dfe0d92de58" translate="yes" xml:space="preserve">
          <source>NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullInt64代表一个可能是空的int64。NullInt64实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="d0dce04dd9159fa0b0caa17ec78453211e1469bd" translate="yes" xml:space="preserve">
          <source>NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).</source>
          <target state="translated">NullRawValue是一个RawValue,它的Tag设置为ASN.1 NULL类型标签(5)。</target>
        </trans-unit>
        <trans-unit id="74f3d9e74fdee0a23974ea8f9c10c75b52420438" translate="yes" xml:space="preserve">
          <source>NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination:</source>
          <target state="translated">NullString表示一个可能是空的字符串。NullString实现了Scanner接口,所以它可以被用作扫描目标。</target>
        </trans-unit>
        <trans-unit id="764711d7b7a7e05fa628aa8a88164882909b5ea1" translate="yes" xml:space="preserve">
          <source>NullTime represents a time.Time that may be null. NullTime implements the Scanner interface so it can be used as a scan destination, similar to NullString.</source>
          <target state="translated">NullTime代表一个可能是空的time.Time。NullTime实现了Scanner接口,所以它可以被用作扫描目标,类似于NullString。</target>
        </trans-unit>
        <trans-unit id="f04c9d785121ddad7627d64968a461809b36b14b" translate="yes" xml:space="preserve">
          <source>Nullable reports whether the column may be null. If a driver does not support this property ok will be false.</source>
          <target state="translated">Nullable报告列是否为空。如果一个驱动程序不支持这个属性,那么ok将为false。</target>
        </trans-unit>
        <trans-unit id="b616503fdba110413e1c79f07f22ca93729b1af0" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; it may be &amp;lt;= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x.</source>
          <target state="translated">Num返回x的分子；结果可能是&amp;lt;=0。结果是对x分子的引用；如果将新值分配给x，它可能会更改，反之亦然。分子的符号与x的符号相对应。</target>
        </trans-unit>
        <trans-unit id="49dfb6250d5c5b7065edd1796c9ba60b2981b754" translate="yes" xml:space="preserve">
          <source>Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x.</source>
          <target state="translated">Num 返回 x 的分子;x 必须是 Int、Float 或 Unknown。如果x是未知数,或者如果它太大或太小而不能作为分数表示,结果就是未知数。否则,结果是一个与x同号的Int。</target>
        </trans-unit>
        <trans-unit id="07e8e8142272a14853fc3d4225faf1955a80ec0e" translate="yes" xml:space="preserve">
          <source>NumCPU returns the number of logical CPUs usable by the current process.</source>
          <target state="translated">NumCPU返回当前进程可使用的逻辑CPU数量。</target>
        </trans-unit>
        <trans-unit id="3bdcf0e9793febfba96be526d3f799da8d6c4599" translate="yes" xml:space="preserve">
          <source>NumCgoCall returns the number of cgo calls made by the current process.</source>
          <target state="translated">NumCgoCall返回当前进程的cgo调用次数。</target>
        </trans-unit>
        <trans-unit id="99d769aca95925934bfe7234523a8e266cfa3e86" translate="yes" xml:space="preserve">
          <source>NumChildren returns the number of scopes nested in s.</source>
          <target state="translated">NumChildren返回嵌套在s中的作用域的数量。</target>
        </trans-unit>
        <trans-unit id="7f8d5fa9c98c840bdcabc50036c605aaa61914fa" translate="yes" xml:space="preserve">
          <source>NumEmbeddeds returns the number of embedded types in interface t.</source>
          <target state="translated">NumEmbeddeds返回接口t中嵌入类型的数量。</target>
        </trans-unit>
        <trans-unit id="48274f29256d93bd977745ada6c383a46661d04c" translate="yes" xml:space="preserve">
          <source>NumError</source>
          <target state="translated">NumError</target>
        </trans-unit>
        <trans-unit id="085f257e02817fe0403777855cdf9b9d714c7182" translate="yes" xml:space="preserve">
          <source>NumExplicitMethods returns the number of explicitly declared methods of interface t.</source>
          <target state="translated">NumExplicitMethods 返回接口 t 的显式声明方法的数量。</target>
        </trans-unit>
        <trans-unit id="dc69c4938a12562dfc9db7decbe294fadc96a88a" translate="yes" xml:space="preserve">
          <source>NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.</source>
          <target state="translated">NumField返回v结构中的字段数,如果v的Kind不是Struct,它就会惊慌失措。</target>
        </trans-unit>
        <trans-unit id="37d55c8516ca892bb76b586c5b36e164d3bfee83" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of fields in the struct (including blank and embedded fields).</source>
          <target state="translated">NumFields返回结构中的字段数(包括空白字段和嵌入字段)。</target>
        </trans-unit>
        <trans-unit id="67aa508431878c89dfc1facabaf28776d55930aa" translate="yes" xml:space="preserve">
          <source>NumFields returns the number of parameters or struct fields represented by a FieldList.</source>
          <target state="translated">NumFields 返回一个 FieldList 所代表的参数或结构域的数量。</target>
        </trans-unit>
        <trans-unit id="64877a16861b7f92b7b931c3dd32e6bffe105163" translate="yes" xml:space="preserve">
          <source>NumGoroutine returns the number of goroutines that currently exist.</source>
          <target state="translated">NumGoroutine 返回当前存在的goroutine的数量。</target>
        </trans-unit>
        <trans-unit id="20f482d6f3d78d176b8cba126c2420b8ebb6a1e9" translate="yes" xml:space="preserve">
          <source>NumMethod returns the number of exported methods in the value's method set.</source>
          <target state="translated">NumMethod返回值的方法集中导出的方法数量。</target>
        </trans-unit>
        <trans-unit id="e16da0849c5c39aaf5008c6fb5c0acd6258e7143" translate="yes" xml:space="preserve">
          <source>NumMethods returns the number of explicit methods whose receiver is named type t.</source>
          <target state="translated">NumMethods 返回显式方法的数量,这些方法的接收者被命名为t类型。</target>
        </trans-unit>
        <trans-unit id="efca93e8ccf5085b691b876b60dbb50f530aac0f" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t.</source>
          <target state="translated">NumMethods返回接口t的方法总数。</target>
        </trans-unit>
        <trans-unit id="a0673e2061679abd4029b9bc04ce1dc9f32ef5a9" translate="yes" xml:space="preserve">
          <source>NumMethods returns the total number of methods of interface t. The interface must have been completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56f8cd32be5e8eed5e5b31f9ccdc038bef949c9" translate="yes" xml:space="preserve">
          <source>NumSubexp returns the number of parenthesized subexpressions in this Regexp.</source>
          <target state="translated">NumSubexp返回该Regexpression中括号内子表达式的数量。</target>
        </trans-unit>
        <trans-unit id="8bd18a7cf0e1d4bc6bca5d9c1e222116af743cd5" translate="yes" xml:space="preserve">
          <source>NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.</source>
          <target state="translated">NumberNode持有一个数字:有符号或无符号整数、浮点数或复数。该值被解析并存储在所有可以表示该值的类型下。这在少量的代码中模拟了围棋理想常量的行为。</target>
        </trans-unit>
        <trans-unit id="aebc8ea3b91ff7b79f4c3ee912e30d014d9c0e7c" translate="yes" xml:space="preserve">
          <source>Numbers are translated by reading and writing fixed-size values. A fixed-size value is either a fixed-size arithmetic type (bool, int8, uint8, int16, float32, complex64, ...) or an array or struct containing only fixed-size values.</source>
          <target state="translated">数字是通过读写固定大小的值来翻译的。一个固定大小的值可以是一个固定大小的算术类型(bool,int8,uint8,int16,float32,complex64,...),也可以是一个只包含固定大小值的数组或结构。</target>
        </trans-unit>
        <trans-unit id="514d0c82a993264caef98a3606fa7dc9d584da1d" translate="yes" xml:space="preserve">
          <source>Numbers fundamental to the encoding.</source>
          <target state="translated">编码的基本数字。</target>
        </trans-unit>
        <trans-unit id="f72c4497b8297399ea538316ed693eb0b0f69dbb" translate="yes" xml:space="preserve">
          <source>Numeric Conversions</source>
          <target state="translated">数值转换</target>
        </trans-unit>
        <trans-unit id="294de652150e65884a04c4fc22af8edbb1682a0b" translate="yes" xml:space="preserve">
          <source>Numeric time zone offsets format as follows:</source>
          <target state="translated">数值时区偏移的格式如下:</target>
        </trans-unit>
        <trans-unit id="42abdd30b855d13cdf926751fede5f671a054974" translate="yes" xml:space="preserve">
          <source>OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.</source>
          <target state="translated">OAEP的参数化是由一个哈希函数作为随机神谕。对给定消息的加密和解密必须使用相同的哈希函数,sha256.New()是一个合理的选择。</target>
        </trans-unit>
        <trans-unit id="7c5f4d9d83e4f742a8c6f7a878b2a58947298d00" translate="yes" xml:space="preserve">
          <source>OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.</source>
          <target state="translated">OAEPOptions是一个接口,用于向使用crypto.Decrypter接口的OAEP解密传递选项。</target>
        </trans-unit>
        <trans-unit id="ad8427a11879cfd2d8db1b9e8e8f59a37957814e" translate="yes" xml:space="preserve">
          <source>OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)</source>
          <target state="translated">OCSPResponse返回来自TLS服务器的钉书机OCSP响应(如果有的话)。(只对客户端连接有效。)</target>
        </trans-unit>
        <trans-unit id="e8520e97ccf3aeee86e1f8ac2f743514a534e58a" translate="yes" xml:space="preserve">
          <source>OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.</source>
          <target state="translated">OSABI在Header.Ident[EI_OSABI]和Header.OSABI中找到。</target>
        </trans-unit>
        <trans-unit id="68fe95dd58ed02ddd93208f0b1d291299be0c119" translate="yes" xml:space="preserve">
          <source>Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases.</source>
          <target state="translated">Obj返回x.f所表示的对象;对于字段选择,返回一个*Var,对于其他情况,返回一个*Func。</target>
        </trans-unit>
        <trans-unit id="9eb16182993cc59927b4da07ba021ca619da9eaa" translate="yes" xml:space="preserve">
          <source>Obj returns the type name for the named type t.</source>
          <target state="translated">Obj返回命名类型t的类型名。</target>
        </trans-unit>
        <trans-unit id="ea5997c7d13deb46517727f9e2dc50eb58fb0ac9" translate="yes" xml:space="preserve">
          <source>ObjKind describes what an object represents.</source>
          <target state="translated">ObjKind描述了一个对象所代表的内容。</target>
        </trans-unit>
        <trans-unit id="148bd125b03ec79b1e809f1705cff50161dd08f8" translate="yes" xml:space="preserve">
          <source>ObjectOf returns the object denoted by the specified id, or nil if not found.</source>
          <target state="translated">ObjectOf返回指定id所表示的对象,如果没有找到,则返回nil。</target>
        </trans-unit>
        <trans-unit id="696fabf5d47e7927b31c4529cb32de76645f9e45" translate="yes" xml:space="preserve">
          <source>ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.</source>
          <target state="translated">ObjectString 返回 obj 的字符串形式。该限定符控制包级对象的打印,也可以为零。</target>
        </trans-unit>
        <trans-unit id="2a0a0f32e63d21edc60ea1562ca9a173b5386b67" translate="yes" xml:space="preserve">
          <source>Of the asynchronous signals, the SIGHUP signal is sent when a program loses its controlling terminal. The SIGINT signal is sent when the user at the controlling terminal presses the interrupt character, which by default is ^C (Control-C). The SIGQUIT signal is sent when the user at the controlling terminal presses the quit character, which by default is ^\ (Control-Backslash). In general you can cause a program to simply exit by pressing ^C, and you can cause it to exit with a stack dump by pressing ^\.</source>
          <target state="translated">在异步信号中,SIGHUP信号是在程序失去控制终端时发出的。当用户在控制端按下中断字符时发送SIGINT信号,默认为^C(Control-C)。SIGQUIT信号是在控制终端的用户按下退出字符时发出的,默认情况下是^C(Control-Backlash)。一般来说,你可以通过按^C使程序简单地退出,也可以通过按^\使程序以堆栈转储的方式退出。</target>
        </trans-unit>
        <trans-unit id="65a759f4644d298e31d53fd1d1620c7a2eccb79e" translate="yes" xml:space="preserve">
          <source>Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset.</source>
          <target state="translated">Offset返回给定文件位置p的偏移量;p必须是该文件中有效的Pos值。f.Offset(f.Pos(offset))==offset。</target>
        </trans-unit>
        <trans-unit id="e668fecf796eebcf71860aea79f4acfd32998a26" translate="yes" xml:space="preserve">
          <source>Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field. The return value of Offsetof is a Go constant.</source>
          <target state="translated">Offsetof返回x代表的字段在结构中的偏移量,其形式必须是structValue.field。换句话说,它返回结构的开始和字段的开始之间的字节数。Offsetof的返回值是一个围棋常量。</target>
        </trans-unit>
        <trans-unit id="0ac54daba3530c56c22c7ab5fd0f77563ce7acd3" translate="yes" xml:space="preserve">
          <source>Often, ascii85-encoded data is wrapped in &amp;lt;~ and ~&amp;gt; symbols. Encode does not add these.</source>
          <target state="translated">通常，ASCII85编码的数据用&amp;lt;〜和〜&amp;gt;符号包装。编码不添加这些。</target>
        </trans-unit>
        <trans-unit id="6413c8b7ce1d9eff6207fb9349fe2d0c981a61bc" translate="yes" xml:space="preserve">
          <source>On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cc25224e88c84b965606d1525d366853ed4824" translate="yes" xml:space="preserve">
          <source>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented.</source>
          <target state="translated">在AIX、DragonFly BSD、NetBSD、OpenBSD、Plan 9和Solaris上,没有实现Interface的MulticastAddrs方法。</target>
        </trans-unit>
        <trans-unit id="322a40be48fec2648aeb02ef3005e17bc581549f" translate="yes" xml:space="preserve">
          <source>On ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d045aa427adecabc2fe461f86a4e36227e3495" translate="yes" xml:space="preserve">
          <source>On ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</source>
          <target state="translated">在ARM、x86-32和32位MIPS上,调用者有责任安排原子访问的64位字的64位对齐。变量或分配的结构、数组或片中的第一个字可以依靠64位对齐。</target>
        </trans-unit>
        <trans-unit id="78d4a89f2d2e09c9cf23ea8b902790da4d5ff91d" translate="yes" xml:space="preserve">
          <source>On DragonFly BSD and OpenBSD, listening on the &quot;tcp&quot; and &quot;udp&quot; networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details.</source>
          <target state="translated">在DragonFly BSD和OpenBSD上,&quot;tcp &quot;和 &quot;udp &quot;网络上的监听不能同时监听IPv4和IPv6连接。这是由于 IPv4 流量不会被路由到 IPv6 套接字--如果要支持两个地址族,则需要两个单独的套接字。详情请参见 inet6(4)。</target>
        </trans-unit>
        <trans-unit id="bc2494255e41ee3a52e5ab617366af15ab263764" translate="yes" xml:space="preserve">
          <source>On JS and NaCl, methods and functions related to Interface are not implemented.</source>
          <target state="translated">在JS和NaCl上,没有实现与Interface相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="192f11c9370338b47035100e9f2d82d3defced91" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ce1e2fb44b89c9c5878b1c6736f5b7ccf5c3c1" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ade6d9d0e9dc1e5841a92c33c3f4dc6e0db317" translate="yes" xml:space="preserve">
          <source>On JS and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523f976c2cabf45b1020d7ffffaa352ae10a88bf" translate="yes" xml:space="preserve">
          <source>On JS and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4b947349b83f8062406fe052b018a151c0a171" translate="yes" xml:space="preserve">
          <source>On JS and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22fcd32dddc8742d71eeb00fd66a97a307dec2b" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to IPConn are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实施与IPConnect相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="c330a67c6571f090abbe696684e69b144f23ffce" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实现UnixConn和UnixListener的相关方法和功能。</target>
        </trans-unit>
        <trans-unit id="187bea53a3943264ca3ab448938a9eb5588890ad" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented.</source>
          <target state="translated">在JS、NaCl和Plan 9上,没有实现syscall.RawConn的控制、读和写方法。</target>
        </trans-unit>
        <trans-unit id="8af01a3a36621e313c89de20d229f16557b6c642" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the File method of TCPConn and TCPListener is not implemented.</source>
          <target state="translated">在JS、NaCl和Windows上,没有实现TCPConn和TCPListener的File方法。</target>
        </trans-unit>
        <trans-unit id="c3a3c87314e5ae7220ae61af7b9a4aaad742b9fa" translate="yes" xml:space="preserve">
          <source>On JS, NaCl and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented.</source>
          <target state="translated">在JS、NaCl和Windows上,没有实现FileConn、FileListener和FilePacketConn函数。</target>
        </trans-unit>
        <trans-unit id="013710184aedbc65d0484c3d6e19b6b05cf4d0a4" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to Interface are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50eadbc0d323969884ecf9cc0009e49c34ea969b" translate="yes" xml:space="preserve">
          <source>On JS, methods and functions related to UDPConn are not implemented.</source>
          <target state="translated">在JS上,没有实现与UDPConn相关的方法和功能。</target>
        </trans-unit>
        <trans-unit id="a1c684d38068da43548a6ff99a071652823f3627" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the CryptGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="translated">在Linux和FreeBSD上,Reader使用getrandom(2),如果可用的话,否则使用/dev/urandom。在 OpenBSD 上,Reader 使用 getentropy(2)。在其他类似Unix的系统上,Reader从/dev/urandom读取。在Windows系统上,Reader使用CryptGenRandom API。在Wasm系统上,Reader使用Web Crypto API。</target>
        </trans-unit>
        <trans-unit id="a9dc397364bf0485259b5abb3ca6453bbc0cfd31" translate="yes" xml:space="preserve">
          <source>On Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the RtlGenRandom API. On Wasm, Reader uses the Web Crypto API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ff5cc97c5ee66d154a1695c234ed4080927ad5" translate="yes" xml:space="preserve">
          <source>On NaCl and Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="translated">在NaCl和Plan 9上,UDPConn的ReadMsgUDP和WriteMsgUDP方法没有实现。</target>
        </trans-unit>
        <trans-unit id="87e667c5ede44ae5764673fc28b292659a0f5bd8" translate="yes" xml:space="preserve">
          <source>On NaCl, the ListenMulticastUDP function is not implemented.</source>
          <target state="translated">在NaCl上,没有实现ListenMulticastUDP功能。</target>
        </trans-unit>
        <trans-unit id="a330e696a92e2d53090bac7c262b179695141719" translate="yes" xml:space="preserve">
          <source>On POSIX systems Gid contains a decimal number representing the group ID.</source>
          <target state="translated">在POSIX系统中,Gid包含一个代表组ID的十进制数。</target>
        </trans-unit>
        <trans-unit id="2703d3b45f73f82bdf72e3fead14e53678acde02" translate="yes" xml:space="preserve">
          <source>On Plan 9, signals have type syscall.Note, which is a string. Calling Notify with a syscall.Note will cause that value to be sent on the channel when that string is posted as a note.</source>
          <target state="translated">在计划9上,信号的类型是syscall.Note,这是一个字符串。用syscall.Note调用Notify,当该字符串作为备注发布时,将导致该值在通道上发送。</target>
        </trans-unit>
        <trans-unit id="3750cfdfc10eef27e8dec499f3310e013386e383" translate="yes" xml:space="preserve">
          <source>On Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b29c33c1c929a09e8c06f8cea419c82c9628ed0" translate="yes" xml:space="preserve">
          <source>On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used.</source>
          <target state="translated">在计划9上,使用了模式的权限位,即ModeAppend、ModeExclusive和ModeTemporary。</target>
        </trans-unit>
        <trans-unit id="f8763fb392ab0ac0ea38c3b25946a7a1236134b7" translate="yes" xml:space="preserve">
          <source>On Plan 9, the resolver always accesses /net/cs and /net/dns.</source>
          <target state="translated">在计划9中,解析器总是访问/net/cs和/net/dns。</target>
        </trans-unit>
        <trans-unit id="a1fe82f792d7b21f9ebd6296c1d86e735f0892e1" translate="yes" xml:space="preserve">
          <source>On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName.</source>
          <target state="translated">在Solaris上,它返回共享逻辑数据链路的逻辑网络接口之一;为了更精确,使用InterfaceByName。</target>
        </trans-unit>
        <trans-unit id="d85518513a854a5111d381e48be350b2e36728b6" translate="yes" xml:space="preserve">
          <source>On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively.</source>
          <target state="translated">在UNIX系统中,环境变量SSL_CERT_FILE和SSL_CERT_DIR可以分别用来覆盖SSL证书文件和SSL证书文件目录的系统默认位置。</target>
        </trans-unit>
        <trans-unit id="3ae424a5db2afedd39c9f3dac84609afa2ca2005" translate="yes" xml:space="preserve">
          <source>On Unix systems other than macOS the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. The latter can be a colon-separated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f58a825e10f84944f638859f6290d9816daa64" translate="yes" xml:space="preserve">
          <source>On Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists.</source>
          <target state="translated">在Unix系统中,无论进程是否存在,FindProcess总是成功地返回一个给定pid的进程。</target>
        </trans-unit>
        <trans-unit id="98e3b9345fcee9a653cd9ea250ff090f5fd5a0bd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp.</source>
          <target state="translated">在Unix系统中,如果是非空的,则返回$TMPDIR,否则返回/tmp.在Windows系统中,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录中返回第一个非空值。在Windows系统中,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录中返回第一个非空值。在Plan 9上,它返回/tmp.在Windows上,它使用GetTempPath,从%TMP%、%TEMP%、%USERPROFILE%或Windows目录返回第一个非空值。</target>
        </trans-unit>
        <trans-unit id="d3d0aebf8d4f43a79a7a617076bea555037789dd" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a069a183e2963c2a249b77ad664c6a016ed84b52" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CACHE_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache.</source>
          <target state="translated">在Unix系统上，如果非空，则返回&lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt;指定的$ XDG_CACHE_HOME，否则返回$ HOME / .cache。在Darwin上，它返回$ HOME / Library / Caches。在Windows上，它返回％LocalAppData％。在计划9中，它返回$ home / lib / cache。</target>
        </trans-unit>
        <trans-unit id="c4f447ec06dd9cfc46159127ffa2dcc14e35ae88" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1807151e52b0b2b36b5236bbf2d0ef14a9ec1abc" translate="yes" xml:space="preserve">
          <source>On Unix systems, it returns $XDG_CONFIG_HOME as specified by &lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt; if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib.</source>
          <target state="translated">在Unix系统上，如果非空，则返回&lt;a href=&quot;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html&lt;/a&gt;指定的$ XDG_CONFIG_HOME，否则返回$ HOME / .config。在Darwin上，它返回$ HOME / Library / Application Support。在Windows上，它返回％AppData％。在计划9中，它返回$ home / lib。</target>
        </trans-unit>
        <trans-unit id="2893f193d590bc3c2b7840d64034a29f26c7240a" translate="yes" xml:space="preserve">
          <source>On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo.</source>
          <target state="translated">在Unix系统中,解析器有两种解析名称的选择。它可以使用纯粹的Go解析器,将DNS请求直接发送到/etc/resolv.conf中列出的服务器,也可以使用基于cgo的解析器,调用getaddrinfo和getnameinfo等C库例程。</target>
        </trans-unit>
        <trans-unit id="3c7408069288e442b0e9334096b1f9423749a2cb" translate="yes" xml:space="preserve">
          <source>On Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable.</source>
          <target state="translated">在Unix上,包括macOS,它返回$HOME环境变量,在Windows上,它返回%USERPROFILE%。在Windows上,它返回%USERPROFILE%。在Plan 9上,它返回$home环境变量。</target>
        </trans-unit>
        <trans-unit id="5c4d1d5958d138a86f133f67425aa5377e82d717" translate="yes" xml:space="preserve">
          <source>On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used.</source>
          <target state="translated">在Unix上,使用模式的权限位ModeSetuid、ModeSetgid和ModeSticky。</target>
        </trans-unit>
        <trans-unit id="b3748b447fc18cd33fa72cfd10ff7a8e4c810a41" translate="yes" xml:space="preserve">
          <source>On Unix-like systems, StartCPUProfile does not work by default for Go code built with -buildmode=c-archive or -buildmode=c-shared. StartCPUProfile relies on the SIGPROF signal, but that signal will be delivered to the main program's SIGPROF signal handler (if any) not to the one used by Go. To make it work, call os/signal.Notify for syscall.SIGPROF, but note that doing so may break any profiling being done by the main program.</source>
          <target state="translated">在类似 Unix 的系统中,对于以 -buildmode=c-archive 或 -buildmode=c-shared 构建的 Go 代码,StartCPUProfile 默认不工作。StartCPUProfile依赖于SIGPROF信号,但该信号将被传递给主程序的SIGPROF信号处理程序(如果有的话),而不是Go使用的信号处理程序。为了使它工作,调用 os/signal.Notify 来获取 syscall.SIGPROF,但注意这样做可能会破坏主程序正在进行的任何剖析。</target>
        </trans-unit>
        <trans-unit id="38c48a0935e355c448766738061267dd6c7374a5" translate="yes" xml:space="preserve">
          <source>On Windows a ^C (Control-C) or ^BREAK (Control-Break) normally cause the program to exit. If Notify is called for os.Interrupt, ^C or ^BREAK will cause os.Interrupt to be sent on the channel, and the program will not exit. If Reset is called, or Stop is called on all channels passed to Notify, then the default behavior will be restored.</source>
          <target state="translated">在 Windows 上,^C (Control-C)或 ^BREAK (Control-Break)通常会导致程序退出。如果调用Notify来处理os.Interrupt,^C或^BREAK将导致os.Interrupt被发送到该通道上,而程序不会退出。如果调用Reset,或者在所有传递给Notify的通道上调用Stop,那么将恢复默认行为。</target>
        </trans-unit>
        <trans-unit id="84cb9183f88acab7f0a3e8615676023c95cfe1f4" translate="yes" xml:space="preserve">
          <source>On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError.</source>
          <target state="translated">在Windows或Plan 9上,Chown总是返回syscall.EWINDOWS或EPLAN9错误,包裹在*PathError中。</target>
        </trans-unit>
        <trans-unit id="f5c6a1e271d70b402bf7e630854ac58bbcf34f9f" translate="yes" xml:space="preserve">
          <source>On Windows, MIME types are extracted from the registry.</source>
          <target state="translated">在Windows上,MIME类型是从注册表中提取的。</target>
        </trans-unit>
        <trans-unit id="5350be8357b453f05f4ce5a07cf3bf1dba9318a4" translate="yes" xml:space="preserve">
          <source>On Windows, escaping is disabled. Instead, '\\' is treated as path separator.</source>
          <target state="translated">在Windows系统中,转义符被禁用。取而代之的是,'\\'被当作路径分隔符。</target>
        </trans-unit>
        <trans-unit id="a41bed9c4201556ec574f1ac26f677457e930cdc" translate="yes" xml:space="preserve">
          <source>On Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError.</source>
          <target state="translated">在Windows上,它总是返回syscall.EWINDOWS错误,包裹在*PathError中。</target>
        </trans-unit>
        <trans-unit id="6f31a978cb1a7e83893ce791c5aa32ff7ac495fa" translate="yes" xml:space="preserve">
          <source>On Windows, it returns -1.</source>
          <target state="translated">在Windows下,它返回-1。</target>
        </trans-unit>
        <trans-unit id="6a02f4fe5f583e59f31f6cbc5e10b9216b10a0af" translate="yes" xml:space="preserve">
          <source>On Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative.</source>
          <target state="translated">在 Windows 上,它返回 syscall.EWINDOWS。请参阅 os/user 软件包以获得一个可能的替代方案。</target>
        </trans-unit>
        <trans-unit id="0d3a0f41f0df73942f4fecfe70a64ca015408110" translate="yes" xml:space="preserve">
          <source>On Windows, methods and functions related to UnixConn and UnixListener don't work for &quot;unixgram&quot; and &quot;unixpacket&quot;.</source>
          <target state="translated">在Windows上,与UnixConn和UnixListener相关的方法和函数对 &quot;unixgram &quot;和 &quot;unixpacket &quot;不起作用。</target>
        </trans-unit>
        <trans-unit id="bd2981a73df24a936314bf6d1873afd69dc8adde" translate="yes" xml:space="preserve">
          <source>On Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file.</source>
          <target state="translated">在Windows上,只使用模式的0200位(所有者可写);它控制文件的只读属性是被设置还是被清除。其他位目前未被使用。为了与围棋1.12及更早的版本兼容,请使用非零模式。对只读文件使用模式0400,对可读+可写文件使用模式0600。</target>
        </trans-unit>
        <trans-unit id="2612d030cdd95b20b0743477158be3874169bfe3" translate="yes" xml:space="preserve">
          <source>On Windows, processes receive the whole command line as a single string and do their own parsing. Command combines and quotes Args into a command line string with an algorithm compatible with applications using CommandLineToArgvW (which is the most common way). Notable exceptions are msiexec.exe and cmd.exe (and thus, all batch files), which have a different unquoting algorithm. In these or other similar cases, you can do the quoting yourself and provide the full command line in SysProcAttr.CmdLine, leaving Args empty.</source>
          <target state="translated">在Windows上,进程以单个字符串的形式接收整个命令行,并进行自己的解析。Command将Args组合并引用成一个命令行字符串,其算法与使用CommandLineToArgvW(这是最常见的方式)的应用程序兼容。值得注意的例外是msiexec.exe和cmd.exe(因此,所有批处理文件),它们有不同的解引号算法。在这些或其他类似的情况下,你可以自己做引号,并在SysProcAttr.CmdLine中提供完整的命令行,将Args留空。</target>
        </trans-unit>
        <trans-unit id="0058230d55ce789eb5612e2b93e4da6eea793a83" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of IPConn is not implemented.</source>
          <target state="translated">在Windows上,没有实现IPConnect的File方法。</target>
        </trans-unit>
        <trans-unit id="d755b555a5935f43a3d90e65b76056dcf10027ed" translate="yes" xml:space="preserve">
          <source>On Windows, the File method of UDPConn is not implemented.</source>
          <target state="translated">在Windows上,UDPConn的File方法没有实现。</target>
        </trans-unit>
        <trans-unit id="f31f810d1a4482b639a8bee446be568ce053ee4a" translate="yes" xml:space="preserve">
          <source>On Windows, the Write method of syscall.RawConn does not integrate with the runtime's network poller. It cannot wait for the connection to become writeable, and does not respect deadlines. If the user-provided callback returns false, the Write method will fail immediately.</source>
          <target state="translated">在Windows上,syscall.RawConn的Write方法没有与运行时的网络轮询器集成。它不能等待连接变得可写,也不尊重截止日期。如果用户提供的回调返回false,Write方法将立即失败。</target>
        </trans-unit>
        <trans-unit id="8b8fbd99e87c243a50d7f3fe8f96df26bcf452aa" translate="yes" xml:space="preserve">
          <source>On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.</source>
          <target state="translated">在Windows上,解析器总是使用C库函数,如GetAddrInfo和DnsQuery。</target>
        </trans-unit>
        <trans-unit id="bf70d5852ec76636f3807a9db0f77a9465a35084" translate="yes" xml:space="preserve">
          <source>On all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls.</source>
          <target state="translated">在所有平台上,当从Go到C到Go的调用请求堆栈跟踪时,会调用traceback函数。在linux/amd64、linux/ppc64le和freebsd/amd64上,当一个正在执行cgo调用的线程接收到一个信号时,也会调用traceback函数。追溯函数不应该对它被调用的时间做出假设,因为未来的Go版本可能会进行额外的调用。</target>
        </trans-unit>
        <trans-unit id="d6c40e8d8a1cb9c0f6c9d4c03dcd550161059582" translate="yes" xml:space="preserve">
          <source>On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as &quot;writev&quot;).</source>
          <target state="translated">在某些机器上,对于某些类型的连接,这被优化为操作系统特定的批量写入操作(如 &quot;writev&quot;)。</target>
        </trans-unit>
        <trans-unit id="c77b73816658f653733e14c2986094f012e8e513" translate="yes" xml:space="preserve">
          <source>On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed.</source>
          <target state="translated">出错时,可以忽略任何Response。只有当CheckRedirect失败时,才会出现一个非nil错误的Response,即使如此,返回的Response.Body也已经被关闭。</target>
        </trans-unit>
        <trans-unit id="13e02db1965a04d36b6a5db4b5d676787f23298f" translate="yes" xml:space="preserve">
          <source>On every POSIX platform, reads from the &quot;ip4&quot; network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet.</source>
          <target state="translated">在每个POSIX平台上,使用ReadFrom或ReadFromIP方法从 &quot;ip4 &quot;网络读取数据时,即使有可用空间,也可能无法返回一个完整的IPv4数据包,包括它的头。即使在Read或ReadMsgIP可以返回一个完整数据包的情况下,这种情况也会发生。基于这个原因,如果你对接收完整的数据包很重要,建议不要使用这些方法。</target>
        </trans-unit>
        <trans-unit id="3c23c9c1e399b461c8c28a7144948fd27bdb61bb" translate="yes" xml:space="preserve">
          <source>On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function.</source>
          <target state="translated">在许多Linux系统中,/etc/ssl/cert.pem将包含系统范围内的根CA集,其格式适合该功能。</target>
        </trans-unit>
        <trans-unit id="ca1a155daae24035a913fb63720c32b8136a4b91" translate="yes" xml:space="preserve">
          <source>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.</source>
          <target state="translated">在非Linux ARM上,64位函数使用ARMv6k内核之前不可用的指令。</target>
        </trans-unit>
        <trans-unit id="1357e885cae46582ed3a6ff4521cb427fb02bd90" translate="yes" xml:space="preserve">
          <source>On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u.</source>
          <target state="translated">在某些系统中,如果计算机进入睡眠状态,单调时钟将停止。在这样的系统中,t.Sub(u)可能无法准确反映t和u之间的实际时间。</target>
        </trans-unit>
        <trans-unit id="66c05351e7478785f8f137c02ebcef5c050b614d" translate="yes" xml:space="preserve">
          <source>On the other hand, a free list maintained as part of a short-lived object is not a suitable use for a Pool, since the overhead does not amortize well in that scenario. It is more efficient to have such objects implement their own free list.</source>
          <target state="translated">另一方面,作为短命对象的一部分维护的自由列表并不适合用于Pool,因为在这种情况下,开销不能很好地摊销。让这类对象实现自己的自由列表更为有效。</target>
        </trans-unit>
        <trans-unit id="389950f4460ec73a72ec78dde5ba3b73d32c35ab" translate="yes" xml:space="preserve">
          <source>On x86-32, the 64-bit functions use instructions unavailable before the Pentium MMX.</source>
          <target state="translated">在x86-32上,64位函数使用了Pentium MMX之前不可用的指令。</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="d104fb961a8c78122b2f62dee3ef43757b182f86" translate="yes" xml:space="preserve">
          <source>Once Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed.</source>
          <target state="translated">一旦在服务器上调用了Shutdown,它就不能被重复使用;未来对Serve等方法的调用将返回ErrServerClosed。</target>
        </trans-unit>
        <trans-unit id="843e914dc9185fa382b5f053202ed67b742aeba3" translate="yes" xml:space="preserve">
          <source>Once f returns and err is nil, the Conn will continue to be usable until Conn.Close is called.</source>
          <target state="translated">一旦f返回,err为nil,Conn将继续可用,直到Conn.Close被调用。</target>
        </trans-unit>
        <trans-unit id="0c1d5279ebafd6b3423844bd2276728e8cc52fbd" translate="yes" xml:space="preserve">
          <source>Once is an object that will perform exactly one action.</source>
          <target state="translated">Once是一个对象,它将准确地执行一个动作。</target>
        </trans-unit>
        <trans-unit id="7227e9a075a44764452a578989f4cc83bbee577f" translate="yes" xml:space="preserve">
          <source>Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.</source>
          <target state="translated">一旦解析完毕,模板可以安全地并行执行,尽管如果并行执行共享一个Writer,输出可能会交错。</target>
        </trans-unit>
        <trans-unit id="0281f78c03be67c1f2a3acafcdaa61c0cdc49c86" translate="yes" xml:space="preserve">
          <source>One or two minus signs may be used; they are equivalent. The last form is not permitted for boolean flags because the meaning of the command</source>
          <target state="translated">可以使用一个或两个减号,它们是等价的。布尔标志不允许使用最后一种形式,因为命令的含义为</target>
        </trans-unit>
        <trans-unit id="69577389d4c08755d52755f4e17faf59267dd621" translate="yes" xml:space="preserve">
          <source>OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.</source>
          <target state="translated">OneByteReader返回一个Reader,通过从r中读取一个字节来实现每个非空的Read。</target>
        </trans-unit>
        <trans-unit id="99aaec6fa8f2d0bdb9045bd117dd6c71497e9a74" translate="yes" xml:space="preserve">
          <source>OnesCount</source>
          <target state="translated">OnesCount</target>
        </trans-unit>
        <trans-unit id="433a6ff8b314e9c198548ae00ba6fcecd1eee098" translate="yes" xml:space="preserve">
          <source>OnesCount returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount 返回 x 中的一比特数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="c380e0ef7643051dda1d040515dc580f28605550" translate="yes" xml:space="preserve">
          <source>OnesCount16</source>
          <target state="translated">OnesCount16</target>
        </trans-unit>
        <trans-unit id="0999fcac9097d75e1573b11d0ffd816e52cf5855" translate="yes" xml:space="preserve">
          <source>OnesCount16 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount16 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="11a58244491d18b07e203d19e0549197d7478647" translate="yes" xml:space="preserve">
          <source>OnesCount32</source>
          <target state="translated">OnesCount32</target>
        </trans-unit>
        <trans-unit id="5f0db4433d3c95e463c6c2a1eadf16ccd1d19ea6" translate="yes" xml:space="preserve">
          <source>OnesCount32 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount32 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="f8bf5b0787d28b51c08417f12183c3a8050bbddf" translate="yes" xml:space="preserve">
          <source>OnesCount64</source>
          <target state="translated">OnesCount64</target>
        </trans-unit>
        <trans-unit id="f4aecef923e1b31d46e0ebe7b85940e72b4c07f4" translate="yes" xml:space="preserve">
          <source>OnesCount64 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount64 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="d82a2ce39ad5e48e37815f9f28a1215fe50fea08" translate="yes" xml:space="preserve">
          <source>OnesCount8</source>
          <target state="translated">OnesCount8</target>
        </trans-unit>
        <trans-unit id="cb4e53f8fd7e82903aefdeda2e2114c5812e0d65" translate="yes" xml:space="preserve">
          <source>OnesCount8 returns the number of one bits (&quot;population count&quot;) in x.</source>
          <target state="translated">OnesCount8 返回 x 中的 1 位数(&quot;人口数&quot;)。</target>
        </trans-unit>
        <trans-unit id="e2a07178400736bcb7be81ae2feca4dcd008d7f5" translate="yes" xml:space="preserve">
          <source>Only methods that satisfy these criteria will be made available for remote access; other methods will be ignored:</source>
          <target state="translated">只有满足这些标准的方法才会被提供给远程访问,其他方法将被忽略。</target>
        </trans-unit>
        <trans-unit id="f19caf46e787ec1b99d851f024d8d32d31c130ae" translate="yes" xml:space="preserve">
          <source>Only one call to Dial is necessary. On write failures, the syslog client will attempt to reconnect to the server and write again.</source>
          <target state="translated">只需要调用一次Dial。在写入失败时,syslog客户端将尝试重新连接到服务器并再次写入。</target>
        </trans-unit>
        <trans-unit id="0bb2640773cf0b724d4c0f4b422833704c7b1dde" translate="yes" xml:space="preserve">
          <source>Only some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do.</source>
          <target state="translated">只有某些类型的文件支持设置截止日期。对于不支持截止日期的文件,调用SetDeadline会返回ErrNoDeadline。在大多数系统中,普通文件不支持截止日期,但管道支持。</target>
        </trans-unit>
        <trans-unit id="1f2bc4d6c6973cdf7add1d2aa0d072a9bc333db3" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard nonce lengths. All other users should use NewGCM, which is faster and more resistant to misuse.</source>
          <target state="translated">只有当您需要与使用非标准非ce长度的现有密码系统兼容时才使用此函数。所有其他用户应该使用NewGCM,它速度更快,更能防止滥用。</target>
        </trans-unit>
        <trans-unit id="15128cc4fc0390673cf1d5ff25c809ffa9a2a0a9" translate="yes" xml:space="preserve">
          <source>Only use this function if you require compatibility with an existing cryptosystem that uses non-standard tag lengths. All other users should use NewGCM, which is more resistant to misuse.</source>
          <target state="translated">只有当您需要与使用非标准标签长度的现有密码系统兼容时,才使用此功能。所有其他用户应该使用NewGCM,它更容易被滥用。</target>
        </trans-unit>
        <trans-unit id="1b727317ee1d6f8ec7fdb2282449eaeba440af19" translate="yes" xml:space="preserve">
          <source>Op is a Porter-Duff compositing operator.</source>
          <target state="translated">Op是Porter-Duff的合成操作员。</target>
        </trans-unit>
        <trans-unit id="5af1dc92a9e2658f3244c1615c860d1105099061" translate="yes" xml:space="preserve">
          <source>OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.</source>
          <target state="translated">OpError是通常由net包中的函数返回的错误类型。它描述了错误的操作、网络类型和地址。</target>
        </trans-unit>
        <trans-unit id="18f672481765f9d884600846dfaa4fd9da765b39" translate="yes" xml:space="preserve">
          <source>Opaque scans the entire image and reports whether it is fully opaque.</source>
          <target state="translated">不透明扫描整个图像并报告是否完全不透明。</target>
        </trans-unit>
        <trans-unit id="b7443a4b74ca4cfa1bcd5bba9250ca69f1869f28" translate="yes" xml:space="preserve">
          <source>Open implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d.</source>
          <target state="translated">Open使用os.Open实现FileSystem,打开根目录和相对目录d的文件进行阅读。</target>
        </trans-unit>
        <trans-unit id="6171c49e2bc16b1abb139c13c4d94d148a1c46f3" translate="yes" xml:space="preserve">
          <source>Open may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">Open可能只是验证其参数,而不创建与数据库的连接。要验证数据源名称是否有效,请调用Ping。</target>
        </trans-unit>
        <trans-unit id="5020abe2d6e35be83ee66706a97f7b42a3cce7b0" translate="yes" xml:space="preserve">
          <source>Open opens a Go plugin. If a path has already been opened, then the existing *Plugin is returned. It is safe for concurrent use by multiple goroutines.</source>
          <target state="translated">Open打开一个围棋插件,如果已经打开一个路径,则返回现有的*Plugin。如果已经打开了一个路径,则返回现有的*Plugin。它对多个goroutine的并发使用是安全的。</target>
        </trans-unit>
        <trans-unit id="66a147f16950427bc220b36b7335c4430f2e435a" translate="yes" xml:space="preserve">
          <source>Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.</source>
          <target state="translated">Open打开由其数据库驱动程序名称和特定驱动程序的数据源名称指定的数据库,通常至少由数据库名称和连接信息组成。</target>
        </trans-unit>
        <trans-unit id="37d7b9b7fb804765c0c890c3a9927f5e792e10c2" translate="yes" xml:space="preserve">
          <source>Open opens and returns the FileHeader's associated File.</source>
          <target state="translated">打开并返回FileHeader的相关文件。</target>
        </trans-unit>
        <trans-unit id="4d09e8d3dfbdf4323b9d5cdc91f1fd80d7807611" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading and returns it as an fs.File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f531c4cd3491cbb25cd300045e949a3c6a2f783" translate="yes" xml:space="preserve">
          <source>Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError.</source>
          <target state="translated">Open打开命名的文件进行读取。如果成功,返回的文件上的方法可以用于读取;相关文件描述符的模式为O_RDONLY。如果出现错误,将是*PathError类型。</target>
        </trans-unit>
        <trans-unit id="b390953cf8856a09a788eb0abb38c45237e64b69" translate="yes" xml:space="preserve">
          <source>Open opens the named file in the ZIP archive, using the semantics of fs.FS.Open: paths are always slash separated, with no leading / or ../ elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371cc608c2ba1c0990eaf9fb6894bbf2a52158f7" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Mach-O binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 Mach-O 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="7d04ca361fd4f73d2b0f9d528191bbbad4f3caa9" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a PE binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 PE 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="401e69358b39b00234c49cca571dfb25656931d2" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 Plan 9 a.out 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="9b1194bbc276659f78fdca3adfdc9b10d19c8660" translate="yes" xml:space="preserve">
          <source>Open opens the named file using os.Open and prepares it for use as an ELF binary.</source>
          <target state="translated">Open 使用 os.Open 打开命名的文件,并准备将其作为 ELF 二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="534129bcf580066c175776306db4a220c2bad897" translate="yes" xml:space="preserve">
          <source>Open opens the named file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50055a1ded1f305ba4233bb037ec0d820624aa9" translate="yes" xml:space="preserve">
          <source>Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently.</source>
          <target state="translated">Open返回一个ReadCloser,提供对文件内容的访问。可以同时读取多个文件。</target>
        </trans-unit>
        <trans-unit id="dc15ea0e79b5a5fd3585bbb7eb793bc7927e0c43" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF program body.</source>
          <target state="translated">Open返回一个新的读取ELF程序体的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="cb2948f8796f4e20787b4c3d93aa97d5e5dd5298" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.</source>
          <target state="translated">Open返回一个新的ReadSeeker,读取ELF部分。即使ELF文件中存储的是压缩的部分,ReadSeeker也会读取未压缩的数据。</target>
        </trans-unit>
        <trans-unit id="21b5b726e4f4ade0871cc002a3334fa728428adc" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Mach-O section.</source>
          <target state="translated">Open返回一个新的读取Mach-O部分的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="b61efb693d7cf70cb90d5aedf0d5a372c5aa6512" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the PE section s.</source>
          <target state="translated">Open返回一个新的读取PE段s的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="84fc1af6d68e3cc755958db236fc07677794c372" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the Plan 9 a.out section.</source>
          <target state="translated">Open返回一个新的读取Plan 9 a.out部分的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="387b57706c30c22b6f03a484c6bd4b511d83f9ce" translate="yes" xml:space="preserve">
          <source>Open returns a new ReadSeeker reading the segment.</source>
          <target state="translated">Open返回一个新的读取段的ReadSeeker。</target>
        </trans-unit>
        <trans-unit id="1007daa5b98f8257c13edf3ea065301dd1ebaf2b" translate="yes" xml:space="preserve">
          <source>OpenDB may just validate its arguments without creating a connection to the database. To verify that the data source name is valid, call Ping.</source>
          <target state="translated">OpenDB可能只是验证其参数,而不创建与数据库的连接。要验证数据源名称是否有效,请调用Ping。</target>
        </trans-unit>
        <trans-unit id="25e1b5a42de4942dfe6b4bfced8324ba7ad01162" translate="yes" xml:space="preserve">
          <source>OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name.</source>
          <target state="translated">OpenDB使用Connector打开数据库,允许驱动程序绕过基于字符串的数据源名称。</target>
        </trans-unit>
        <trans-unit id="02205221603211c0f70a26822c2a5ea1275e3176" translate="yes" xml:space="preserve">
          <source>OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary.</source>
          <target state="translated">OpenFat 使用 os.Open 打开命名的文件,并准备将其作为 Mach-O 通用二进制文件使用。</target>
        </trans-unit>
        <trans-unit id="f89511e6449f4d72c17e5b2730171b3d593b5ed7" translate="yes" xml:space="preserve">
          <source>OpenFile</source>
          <target state="translated">OpenFile</target>
        </trans-unit>
        <trans-unit id="0c82063df1128e3daff7e360a09afecb32d7114a" translate="yes" xml:space="preserve">
          <source>OpenFile (Append)</source>
          <target state="translated">OpenFile (Append)</target>
        </trans-unit>
        <trans-unit id="4fc4a091591f11a5786d39de5a16c7ed7ce1eeab" translate="yes" xml:space="preserve">
          <source>OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.</source>
          <target state="translated">OpenFile是通用的打开调用;大多数用户会使用Open或Create来代替。它用指定的标志(O_RDONLY等)打开命名的文件。如果文件不存在,并且传递了O_CREATE标志,则用perm模式(在umask之前)创建文件。如果成功,返回的File上的方法可以用于I/O。如果有一个错误,它的类型将是*PathError。</target>
        </trans-unit>
        <trans-unit id="154227f07677e156add449cf112307bf838866a9" translate="yes" xml:space="preserve">
          <source>OpenReader will open the Zip file specified by name and return a ReadCloser.</source>
          <target state="translated">OpenReader将打开由名称指定的Zip文件,并返回一个ReadCloser。</target>
        </trans-unit>
        <trans-unit id="6cbb449ad00bd956208ebf3bc7a9b2a9d9466e94" translate="yes" xml:space="preserve">
          <source>Operating systems provide both a &amp;ldquo;wall clock,&amp;rdquo; which is subject to changes for clock synchronization, and a &amp;ldquo;monotonic clock,&amp;rdquo; which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading.</source>
          <target state="translated">操作系统同时提供&amp;ldquo;挂钟&amp;rdquo;和&amp;ldquo;单调时钟&amp;rdquo;，&amp;ldquo;挂钟&amp;rdquo;会随时钟同步的变化而变化。一般规则是壁钟用于指示时间，单调时钟用于测量时间。在该程序包中，不是拆分API，而是按时间返回时间。现在，它既包含挂钟读数又包含单调时钟读数。以后的计时操作将使用挂钟读数，但以后的时间测量操作（尤其是比较和减法）将使用单调时钟读数。</target>
        </trans-unit>
        <trans-unit id="f30cabbd8e785b594ba56b3801fd9d4f1260078a" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To &quot;copy&quot; a Float value, an existing (or newly allocated) Float must be set to a new value using the Float.Set method; shallow copies of Floats are not supported and may lead to errors.</source>
          <target state="translated">操作总是取指针参数(*Float)而不是Float值,每个唯一的Float值都需要自己唯一的*Float指针。要 &quot;复制 &quot;一个Float值,必须使用Float.Set方法将一个现有的(或新分配的)Float设置为一个新的值;不支持Float的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="b1165d6e4bac8282c929350a1919aee2062c5958" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To &quot;copy&quot; an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors.</source>
          <target state="translated">操作总是取指针参数(*Int)而不是Int值,每个唯一的Int值都需要它自己唯一的*Int指针。要 &quot;复制 &quot;一个Int值,必须使用Int.Set方法将一个现有的(或新分配的)Int设置为一个新的值;不支持对Ints的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="be2237e984f46419a4f93c71fc7a1e90b45fca20" translate="yes" xml:space="preserve">
          <source>Operations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To &quot;copy&quot; a Rat value, an existing (or newly allocated) Rat must be set to a new value using the Rat.Set method; shallow copies of Rats are not supported and may lead to errors.</source>
          <target state="translated">操作总是采取指针参数(*Rat)而不是Rat值,每个独特的Rat值需要它自己独特的*Rat指针。要 &quot;复制 &quot;一个Rat值,必须使用Rat.Set方法将一个现有的(或新分配的)Rat设置为一个新的值;不支持Rat的浅层复制,并可能导致错误。</target>
        </trans-unit>
        <trans-unit id="5ff98727eb74457bb348de0295d7fc660d04eb4a" translate="yes" xml:space="preserve">
          <source>Operations to set or modify these public variables are atomic.</source>
          <target state="translated">设置或修改这些公共变量的操作是原子的。</target>
        </trans-unit>
        <trans-unit id="a344aa2f0644d620585ef6109d1a2e6c58d16a89" translate="yes" xml:space="preserve">
          <source>Option sets options for the template. Options are described by strings, either a simple string or &quot;key=value&quot;. There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.</source>
          <target state="translated">Option设置模板的选项。选项用字符串来描述,可以是简单的字符串,也可以是 &quot;key=value&quot;。一个选项字符串中最多只能有一个等号。如果选项字符串未被识别或无效,Option就会崩溃。</target>
        </trans-unit>
        <trans-unit id="cce1a4813966599e90a08f133505dd0509cbda9c" translate="yes" xml:space="preserve">
          <source>OptionalHeader64.DllCharacteristics and OptionalHeader32.DllCharacteristics values. These can be combined together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc236bd251ed2cc9db099c813ca0960052738d0" translate="yes" xml:space="preserve">
          <source>OptionalHeader64.Subsystem and OptionalHeader32.Subsystem values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fd04b8e4249d97e36c417ecf8d4f601359dc00" translate="yes" xml:space="preserve">
          <source>Optionally, a single extra argument of type Mode can be provided to control low-level aspects of the documentation extraction behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bdd06043dd23aedf196f8c5aa67a749424f26f" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters.</source>
          <target state="translated">选项是编码参数。</target>
        </trans-unit>
        <trans-unit id="2ae1ba4c5551ccfa17f3cc4234e6c983b6c4a751" translate="yes" xml:space="preserve">
          <source>Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.</source>
          <target state="translated">选项是编码参数。质量范围从1到100(含),越高越好。</target>
        </trans-unit>
        <trans-unit id="3574245ef01db27c04b70bab947169f3717705e6" translate="yes" xml:space="preserve">
          <source>Options are the options for creating a new Jar.</source>
          <target state="translated">选项是创建新Jar的选项。</target>
        </trans-unit>
        <trans-unit id="adec537139c73f02b553920372adc3c02c28272e" translate="yes" xml:space="preserve">
          <source>Or sets z = x | y and returns z.</source>
          <target state="translated">或者设置z=x | y并返回z。</target>
        </trans-unit>
        <trans-unit id="1b4b94d1371289b3526620aa944ef691c23c5e97" translate="yes" xml:space="preserve">
          <source>Or to collect a 5-second execution trace:</source>
          <target state="translated">或者收集5秒的执行跟踪。</target>
        </trans-unit>
        <trans-unit id="50c67b4d826544d33e4676d47eb11f1c27fb8432" translate="yes" xml:space="preserve">
          <source>Or to look at a 30-second CPU profile:</source>
          <target state="translated">或者看一下30秒的CPU曲线。</target>
        </trans-unit>
        <trans-unit id="b615664e9607d56a174a9eae8d3c5a2c6e80bd6a" translate="yes" xml:space="preserve">
          <source>Or to look at the goroutine blocking profile, after calling runtime.SetBlockProfileRate in your program:</source>
          <target state="translated">或者在程序中调用runtime.SetBlockProfileRate后,看看goroutine阻塞配置文件。</target>
        </trans-unit>
        <trans-unit id="9e825dc80cfaf2eaa80db6ce23de3b3fc8a8346c" translate="yes" xml:space="preserve">
          <source>Or to look at the holders of contended mutexes, after calling runtime.SetMutexProfileFraction in your program:</source>
          <target state="translated">或者在程序中调用runtime.SetMutexProfileFraction后,查看争用的mutexes的持有者。</target>
        </trans-unit>
        <trans-unit id="8ab86bd1259ac4f40dd163dea09a395538c7b9f8" translate="yes" xml:space="preserve">
          <source>Or you can create custom flags that satisfy the Value interface (with pointer receivers) and couple them to flag parsing by</source>
          <target state="translated">或者你可以创建满足Value接口的自定义标志(带有指针接收器),并通过以下方式将它们与标志解析结合起来</target>
        </trans-unit>
        <trans-unit id="9e10a8547b0d36316e030b08eda98a7d2a3b8233" translate="yes" xml:space="preserve">
          <source>Order specifies the bit ordering in an LZW data stream.</source>
          <target state="translated">顺序指定LZW数据流中的位顺序。</target>
        </trans-unit>
        <trans-unit id="5cbea92714ef396bc3e8932074a0396b90c6e75c" translate="yes" xml:space="preserve">
          <source>Other ASN.1 types are not supported; if it encounters them, Unmarshal returns a parse error.</source>
          <target state="translated">不支持其他ASN.1类型;如果遇到这些类型,Unmarshal会返回一个解析错误。</target>
        </trans-unit>
        <trans-unit id="7ba1580fd9fc904fa02322480bcec7e07c54f2cc" translate="yes" xml:space="preserve">
          <source>Other definitions of spacing characters are set by category Z and property Pattern_White_Space.</source>
          <target state="translated">其他间距字符的定义由类别Z和属性Pattern_White_Space设置。</target>
        </trans-unit>
        <trans-unit id="b7a56a76d64dcdb6eb16b696315251945b43a236" translate="yes" xml:space="preserve">
          <source>Other flags:</source>
          <target state="translated">其他旗帜:</target>
        </trans-unit>
        <trans-unit id="bd1405bb0e6eee6e420fe2dfb40f43a986aa8880" translate="yes" xml:space="preserve">
          <source>Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets.</source>
          <target state="translated">其他成语,如time.Since(start)、time.Until(deadline)和time.Now().Before(deadline),对挂钟重设也有类似的健壮性。</target>
        </trans-unit>
        <trans-unit id="aa4d97b3571d62fa73ceb918bc9a47b9937e01e1" translate="yes" xml:space="preserve">
          <source>Other packages</source>
          <target state="translated">其他配套</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
